- contents:
  - '                  Stream Control Transmission Protocol

    '
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Abstract\n   This document obsoletes RFC 2960 and RFC 3309.  It describes the\n
    \  Stream Control Transmission Protocol (SCTP).  SCTP is designed to\n   transport
    Public Switched Telephone Network (PSTN) signaling messages\n   over IP networks,
    but is capable of broader applications.\n   SCTP is a reliable transport protocol
    operating on top of a\n   connectionless packet network such as IP.  It offers
    the following\n   services to its users:\n   --  acknowledged error-free non-duplicated
    transfer of user data,\n   --  data fragmentation to conform to discovered path
    MTU size,\n   --  sequenced delivery of user messages within multiple streams,
    with\n       an option for order-of-arrival delivery of individual user\n       messages,\n
    \  --  optional bundling of multiple user messages into a single SCTP\n       packet,
    and\n   --  network-level fault tolerance through supporting of multi-homing\n
    \      at either or both ends of an association.\n   The design of SCTP includes
    appropriate congestion avoidance behavior\n   and resistance to flooding and masquerade
    attacks.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1. Introduction ....................................................5\n
    \     1.1. Motivation .................................................5\n      1.2.
    Architectural View of SCTP .................................6\n      1.3. Key
    Terms ..................................................6\n      1.4. Abbreviations
    .............................................10\n      1.5. Functional View of
    SCTP ...................................10\n           1.5.1. Association Startup
    and Takedown ...................11\n           1.5.2. Sequenced Delivery within
    Streams ..................12\n           1.5.3. User Data Fragmentation ............................12\n
    \          1.5.4. Acknowledgement and Congestion Avoidance ...........12\n           1.5.5.
    Chunk Bundling .....................................13\n           1.5.6. Packet
    Validation ..................................13\n           1.5.7. Path Management
    ....................................13\n      1.6. Serial Number Arithmetic ..................................14\n
    \     1.7. Changes from RFC 2960 .....................................15\n   2.
    Conventions ....................................................15\n   3. SCTP
    Packet Format .............................................15\n      3.1. SCTP
    Common Header Field Descriptions .....................16\n      3.2. Chunk Field
    Descriptions ..................................17\n           3.2.1. Optional/Variable-Length
    Parameter Format ..........19\n           3.2.2. Reporting of Unrecognized Parameters
    ...............21\n      3.3. SCTP Chunk Definitions ....................................21\n
    \          3.3.1. Payload Data (DATA) (0) ............................22\n           3.3.2.
    Initiation (INIT) (1) ..............................24\n                  3.3.2.1.
    Optional/Variable-Length\n                           Parameters in INIT ........................27\n
    \          3.3.3. Initiation Acknowledgement (INIT ACK) (2) ..........30\n                  3.3.3.1.
    Optional or Variable-Length Parameters ....33\n           3.3.4. Selective Acknowledgement
    (SACK) (3) ...............34\n           3.3.5. Heartbeat Request (HEARTBEAT)
    (4) ..................38\n           3.3.6. Heartbeat Acknowledgement (HEARTBEAT
    ACK) (5) ......39\n           3.3.7. Abort Association (ABORT) (6) ......................40\n
    \          3.3.8. Shutdown Association (SHUTDOWN) (7) ................41\n           3.3.9.
    Shutdown Acknowledgement (SHUTDOWN ACK) (8) ........41\n           3.3.10. Operation
    Error (ERROR) (9) .......................42\n                  3.3.10.1. Invalid
    Stream Identifier (1) ............44\n                  3.3.10.2. Missing Mandatory
    Parameter (2) ..........44\n                  3.3.10.3. Stale Cookie Error (3)
    ...................45\n                  3.3.10.4. Out of Resource (4) ......................45\n
    \                 3.3.10.5. Unresolvable Address (5) .................46\n                  3.3.10.6.
    Unrecognized Chunk Type (6) ..............46\n                  3.3.10.7. Invalid
    Mandatory Parameter (7) ..........47\n                  3.3.10.8. Unrecognized
    Parameters (8) ..............47\n                  3.3.10.9. No User Data (9)
    .........................48\n                  3.3.10.10. Cookie Received While
    Shutting\n                             Down (10) ...............................48\n
    \                 3.3.10.11. Restart of an Association with\n                             New
    Addresses (11) ......................49\n                  3.3.10.12. User-Initiated
    Abort (12) ...............49\n                  3.3.10.13. Protocol Violation
    (13) .................50\n           3.3.11. Cookie Echo (COOKIE ECHO) (10) ....................50\n
    \          3.3.12. Cookie Acknowledgement (COOKIE ACK) (11) ..........51\n           3.3.13.
    Shutdown Complete (SHUTDOWN COMPLETE) (14) ........51\n   4. SCTP Association
    State Diagram .................................52\n   5. Association Initialization
    .....................................56\n      5.1. Normal Establishment of an
    Association ....................56\n           5.1.1. Handle Stream Parameters
    ...........................58\n           5.1.2. Handle Address Parameters ..........................58\n
    \          5.1.3. Generating State Cookie ............................61\n           5.1.4.
    State Cookie Processing ............................62\n           5.1.5. State
    Cookie Authentication ........................62\n           5.1.6. An Example
    of Normal Association Establishment .....64\n      5.2. Handle Duplicate or Unexpected
    INIT, INIT ACK,\n           COOKIE ECHO, and ..........................................65\n
    \          5.2.1. INIT Received in COOKIE-WAIT or\n                  COOKIE-ECHOED
    State (Item B) .......................66\n           5.2.2. Unexpected INIT in
    States Other than\n                  CLOSED, COOKIE-ECHOED, .............................66\n
    \          5.2.3. Unexpected INIT ACK ................................67\n           5.2.4.
    Handle a COOKIE ECHO when a TCB Exists .............67\n                  5.2.4.1.
    An Example of a Association Restart .......69\n           5.2.5. Handle Duplicate
    COOKIE-ACK. .......................71\n           5.2.6. Handle Stale COOKIE Error
    ..........................71\n      5.3. Other Initialization Issues ...............................72\n
    \          5.3.1. Selection of Tag Value .............................72\n      5.4.
    Path Verification .........................................72\n   6. User Data
    Transfer .............................................73\n      6.1. Transmission
    of DATA Chunks ...............................75\n      6.2. Acknowledgement on
    Reception of DATA Chunks ...............78\n           6.2.1. Processing a Received
    SACK .........................81\n      6.3. Management of Retransmission Timer
    ........................83\n           6.3.1. RTO Calculation ....................................83\n
    \          6.3.2. Retransmission Timer Rules .........................85\n           6.3.3.
    Handle T3-rtx Expiration ...........................86\n      6.4. Multi-Homed
    SCTP Endpoints ................................87\n           6.4.1. Failover
    from an Inactive Destination Address ......88\n      6.5. Stream Identifier and
    Stream Sequence Number ..............88\n      6.6. Ordered and Unordered Delivery
    ............................88\n      6.7. Report Gaps in Received DATA TSNs .........................89\n
    \     6.8. CRC32c Checksum Calculation ...............................90\n      6.9.
    Fragmentation and Reassembly ..............................91\n      6.10. Bundling
    .................................................92\n   7. Congestion Control
    .............................................93\n      7.1. SCTP Differences from
    TCP Congestion Control ..............94\n      7.2. SCTP Slow-Start and Congestion
    Avoidance ..................95\n           7.2.1. Slow-Start .........................................96\n
    \          7.2.2. Congestion Avoidance ...............................97\n           7.2.3.
    Congestion Control .................................98\n           7.2.4. Fast
    Retransmit on Gap Reports .....................98\n      7.3. Path MTU Discovery
    .......................................100\n   8. Fault Management ..............................................100\n
    \     8.1. Endpoint Failure Detection ...............................100\n      8.2.
    Path Failure Detection ...................................101\n      8.3. Path
    Heartbeat ...........................................102\n      8.4. Handle \"Out
    of the Blue\" Packets .........................104\n      8.5. Verification Tag
    .........................................105\n           8.5.1. Exceptions in
    Verification Tag Rules ..............105\n   9. Termination of Association ....................................106\n
    \     9.1. Abort of an Association ..................................107\n      9.2.
    Shutdown of an Association ...............................107\n   10. Interface
    with Upper Layer ...................................110\n      10.1. ULP-to-SCTP
    .............................................110\n      10.2. SCTP-to-ULP .............................................120\n
    \  11. Security Considerations ......................................123\n      11.1.
    Security Objectives .....................................123\n      11.2. SCTP
    Responses to Potential Threats .....................124\n           11.2.1. Countering
    Insider Attacks .......................124\n           11.2.2. Protecting against
    Data Corruption in the\n                   Network ..........................................124\n
    \          11.2.3. Protecting Confidentiality .......................124\n           11.2.4.
    Protecting against Blind\n                   Denial-of-Service Attacks ........................125\n
    \                 11.2.4.1. Flooding ................................125\n                  11.2.4.2.
    Blind Masquerade ........................126\n                  11.2.4.3. Improper
    Monopolization of Services .....127\n      11.3. SCTP Interactions with Firewalls
    ........................127\n      11.4. Protection of Non-SCTP-Capable Hosts
    ....................128\n   12. Network Management Considerations ............................128\n
    \  13. Recommended Transmission Control Block (TCB) Parameters ......129\n      13.1.
    Parameters Necessary for the SCTP Instance ..............129\n      13.2. Parameters
    Necessary per Association (i.e., the TCB) ....129\n      13.3. Per Transport Address
    Data ..............................131\n      13.4. General Parameters Needed
    ...............................132\n   14. IANA Considerations ..........................................132\n
    \     14.1. IETF-defined Chunk Extension ............................132\n      14.2.
    IETF-Defined Chunk Parameter Extension ..................133\n      14.3. IETF-Defined
    Additional Error Causes ....................133\n      14.4. Payload Protocol
    Identifiers ............................134\n      14.5. Port Numbers Registry
    ...................................134\n   15. Suggested SCTP Protocol Parameter
    Values .....................136\n   16. Acknowledgements .............................................137\n
    \  Appendix A. Explicit Congestion Notification .....................139\n   Appendix
    B. CRC32c Checksum Calculation ..........................140\n   Appendix C. ICMP
    Handling ........................................142\n   References .......................................................149\n
    \     Normative References ..........................................149\n      Informative
    References ........................................150\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   This section explains the reasoning behind the development
    of the\n   Stream Control Transmission Protocol (SCTP), the services it offers,\n
    \  and the basic concepts needed to understand the detailed description\n   of
    the protocol.\n   This document obsoletes [RFC2960] and [RFC3309].\n"
  - contents:
    - "1.1.  Motivation\n   TCP [RFC0793] has performed immense service as the primary
      means of\n   reliable data transfer in IP networks.  However, an increasing
      number\n   of recent applications have found TCP too limiting, and have\n   incorporated
      their own reliable data transfer protocol on top of UDP\n   [RFC0768].  The
      limitations that users have wished to bypass include\n   the following:\n   --
      TCP provides both reliable data transfer and strict order-of-\n      transmission
      delivery of data.  Some applications need reliable\n      transfer without sequence
      maintenance, while others would be\n      satisfied with partial ordering of
      the data.  In both of these\n      cases, the head-of-line blocking offered
      by TCP causes unnecessary\n      delay.\n   -- The stream-oriented nature of
      TCP is often an inconvenience.\n      Applications must add their own record
      marking to delineate their\n      messages, and must make explicit use of the
      push facility to\n      ensure that a complete message is transferred in a reasonable\n
      \     time.\n   -- The limited scope of TCP sockets complicates the task of
      providing\n      highly-available data transfer capability using multi-homed
      hosts.\n   -- TCP is relatively vulnerable to denial-of-service attacks, such
      as\n      SYN attacks.\n   Transport of PSTN signaling across the IP network
      is an application\n   for which all of these limitations of TCP are relevant.
      \ While this\n   application directly motivated the development of SCTP, other\n
      \  applications may find SCTP a good match to their requirements.\n"
    title: 1.1.  Motivation
  - contents:
    - "1.2.  Architectural View of SCTP\n   SCTP is viewed as a layer between the
      SCTP user application (\"SCTP\n   user\" for short) and a connectionless packet
      network service such as\n   IP.  The remainder of this document assumes SCTP
      runs on top of IP.\n   The basic service offered by SCTP is the reliable transfer
      of user\n   messages between peer SCTP users.  It performs this service within\n
      \  the context of an association between two SCTP endpoints.  Section 10\n   of
      this document sketches the API that should exist at the boundary\n   between
      the SCTP and the SCTP user layers.\n   SCTP is connection-oriented in nature,
      but the SCTP association is a\n   broader concept than the TCP connection.  SCTP
      provides the means for\n   each SCTP endpoint (Section 1.3) to provide the other
      endpoint\n   (during association startup) with a list of transport addresses\n
      \  (i.e., multiple IP addresses in combination with an SCTP port)\n   through
      which that endpoint can be reached and from which it will\n   originate SCTP
      packets.  The association spans transfers over all of\n   the possible source/destination
      combinations that may be generated\n   from each endpoint's lists.\n       _____________
      \                                     _____________\n      |  SCTP User  |                                    |
      \ SCTP User  |\n      | Application |                                    | Application
      |\n      |-------------|                                    |-------------|\n
      \     |    SCTP     |                                    |    SCTP     |\n      |
      \ Transport  |                                    |  Transport  |\n      |   Service
      \  |                                    |   Service   |\n      |-------------|
      \                                   |-------------|\n      |             |One
      or more    ----      One or more|             |\n      | IP Network  |IP address
      \     \\/        IP address| IP Network  |\n      |   Service   |appearances
      \    /\\       appearances|   Service   |\n      |_____________|               ----
      \                |_____________|\n        SCTP Node A |<-------- Network transport
      ------->| SCTP Node B\n                         Figure 1: An SCTP Association\n"
    title: 1.2.  Architectural View of SCTP
  - contents:
    - "1.3.  Key Terms\n   Some of the language used to describe SCTP has been introduced
      in the\n   previous sections.  This section provides a consolidated list of
      the\n   key terms and their definitions.\n   o  Active destination transport
      address: A transport address on a\n      peer endpoint that a transmitting endpoint
      considers available for\n      receiving user messages.\n   o  Bundling: An
      optional multiplexing operation, whereby more than\n      one user message may
      be carried in the same SCTP packet.  Each\n      user message occupies its own
      DATA chunk.\n   o  Chunk: A unit of information within an SCTP packet, consisting
      of\n      a chunk header and chunk-specific content.\n   o  Congestion window
      (cwnd): An SCTP variable that limits the data,\n      in number of bytes, a
      sender can send to a particular destination\n      transport address before
      receiving an acknowledgement.\n   o  Cumulative TSN Ack Point: The TSN of the
      last DATA chunk\n      acknowledged via the Cumulative TSN Ack field of a SACK.\n
      \  o  Idle destination address: An address that has not had user\n      messages
      sent to it within some length of time, normally the\n      HEARTBEAT interval
      or greater.\n   o  Inactive destination transport address: An address that is\n
      \     considered inactive due to errors and unavailable to transport\n      user
      messages.\n   o  Message = user message: Data submitted to SCTP by the Upper
      Layer\n      Protocol (ULP).\n   o  Message Authentication Code (MAC): An integrity
      check mechanism\n      based on cryptographic hash functions using a secret
      key.\n      Typically, message authentication codes are used between two\n      parties
      that share a secret key in order to validate information\n      transmitted
      between these parties.  In SCTP, it is used by an\n      endpoint to validate
      the State Cookie information that is returned\n      from the peer in the COOKIE
      ECHO chunk.  The term \"MAC\" has\n      different meanings in different contexts.
      \ SCTP uses this term\n      with the same meaning as in [RFC2104].\n   o  Network
      Byte Order: Most significant byte first, a.k.a., big\n      endian.\n   o  Ordered
      Message: A user message that is delivered in order with\n      respect to all
      previous user messages sent within the stream on\n      which the message was
      sent.\n   o  Outstanding TSN (at an SCTP endpoint): A TSN (and the associated\n
      \     DATA chunk) that has been sent by the endpoint but for which it\n      has
      not yet received an acknowledgement.\n   o  Path: The route taken by the SCTP
      packets sent by one SCTP\n      endpoint to a specific destination transport
      address of its peer\n      SCTP endpoint.  Sending to different destination
      transport\n      addresses does not necessarily guarantee getting separate paths.\n
      \  o  Primary Path: The primary path is the destination and source\n      address
      that will be put into a packet outbound to the peer\n      endpoint by default.
      \ The definition includes the source address\n      since an implementation
      MAY wish to specify both destination and\n      source address to better control
      the return path taken by reply\n      chunks and on which interface the packet
      is transmitted when the\n      data sender is multi-homed.\n   o  Receiver Window
      (rwnd): An SCTP variable a data sender uses to\n      store the most recently
      calculated receiver window of its peer, in\n      number of bytes.  This gives
      the sender an indication of the space\n      available in the receiver's inbound
      buffer.\n   o  SCTP association: A protocol relationship between SCTP endpoints,\n
      \     composed of the two SCTP endpoints and protocol state information\n      including
      Verification Tags and the currently active set of\n      Transmission Sequence
      Numbers (TSNs), etc.  An association can be\n      uniquely identified by the
      transport addresses used by the\n      endpoints in the association.  Two SCTP
      endpoints MUST NOT have\n      more than one SCTP association between them at
      any given time.\n   o  SCTP endpoint: The logical sender/receiver of SCTP packets.
      \ On a\n      multi-homed host, an SCTP endpoint is represented to its peers
      as\n      a combination of a set of eligible destination transport addresses\n
      \     to which SCTP packets can be sent and a set of eligible source\n      transport
      addresses from which SCTP packets can be received.  All\n      transport addresses
      used by an SCTP endpoint must use the same\n      port number, but can use multiple
      IP addresses.  A transport\n      address used by an SCTP endpoint must not
      be used by another SCTP\n      endpoint.  In other words, a transport address
      is unique to an\n      SCTP endpoint.\n   o  SCTP packet (or packet): The unit
      of data delivery across the\n      interface between SCTP and the connectionless
      packet network\n      (e.g., IP).  An SCTP packet includes the common SCTP header,\n
      \     possible SCTP control chunks, and user data encapsulated within\n      SCTP
      DATA chunks.\n   o  SCTP user application (SCTP user): The logical higher-layer\n
      \     application entity which uses the services of SCTP, also called\n      the
      Upper-Layer Protocol (ULP).\n   o  Slow-Start Threshold (ssthresh): An SCTP
      variable.  This is the\n      threshold that the endpoint will use to determine
      whether to\n      perform slow start or congestion avoidance on a particular\n
      \     destination transport address.  Ssthresh is in number of bytes.\n   o
      \ Stream: A unidirectional logical channel established from one to\n      another
      associated SCTP endpoint, within which all user messages\n      are delivered
      in sequence except for those submitted to the\n      unordered delivery service.\n
      \  Note: The relationship between stream numbers in opposite directions\n   is
      strictly a matter of how the applications use them.  It is the\n   responsibility
      of the SCTP user to create and manage these\n   correlations if they are so
      desired.\n   o  Stream Sequence Number: A 16-bit sequence number used internally\n
      \     by SCTP to ensure sequenced delivery of the user messages within a\n      given
      stream.  One Stream Sequence Number is attached to each user\n      message.\n
      \  o  Tie-Tags: Two 32-bit random numbers that together make a 64-bit\n      nonce.
      \ These tags are used within a State Cookie and TCB so that\n      a newly restarting
      association can be linked to the original\n      association within the endpoint
      that did not restart and yet not\n      reveal the true Verification Tags of
      an existing association.\n   o  Transmission Control Block (TCB): An internal
      data structure\n      created by an SCTP endpoint for each of its existing SCTP\n
      \     associations to other SCTP endpoints.  TCB contains all the status\n      and
      operational information for the endpoint to maintain and\n      manage the corresponding
      association.\n   o  Transmission Sequence Number (TSN): A 32-bit sequence number
      used\n      internally by SCTP.  One TSN is attached to each chunk containing\n
      \     user data to permit the receiving SCTP endpoint to acknowledge its\n      receipt
      and detect duplicate deliveries.\n   o  Transport address: A transport address
      is traditionally defined by\n      a network-layer address, a transport-layer
      protocol, and a\n      transport-layer port number.  In the case of SCTP running
      over IP,\n      a transport address is defined by the combination of an IP address\n
      \     and an SCTP port number (where SCTP is the transport protocol).\n   o
      \ Unacknowledged TSN (at an SCTP endpoint): A TSN (and the\n      associated
      DATA chunk) that has been received by the endpoint but\n      for which an acknowledgement
      has not yet been sent.  Or in the\n      opposite case, for a packet that has
      been sent but no\n      acknowledgement has been received.\n   o  Unordered
      Message: Unordered messages are \"unordered\" with respect\n      to any other
      message; this includes both other unordered messages\n      as well as other
      ordered messages.  An unordered message might be\n      delivered prior to or
      later than ordered messages sent on the same\n      stream.\n   o  User message:
      The unit of data delivery across the interface\n      between SCTP and its user.\n
      \  o  Verification Tag: A 32-bit unsigned integer that is randomly\n      generated.
      \ The Verification Tag provides a key that allows a\n      receiver to verify
      that the SCTP packet belongs to the current\n      association and is not an
      old or stale packet from a previous\n      association.\n"
    title: 1.3.  Key Terms
  - contents:
    - "1.4.  Abbreviations\n   MAC    -  Message Authentication Code [RFC2104]\n   RTO
      \   -  Retransmission Timeout\n   RTT    -  Round-Trip Time\n   RTTVAR -  Round-Trip
      Time Variation\n   SCTP   -  Stream Control Transmission Protocol\n   SRTT   -
      \ Smoothed RTT\n   TCB    -  Transmission Control Block\n   TLV    -  Type-Length-Value
      coding format\n   TSN    -  Transmission Sequence Number\n   ULP    -  Upper-Layer
      Protocol\n"
    title: 1.4.  Abbreviations
  - contents:
    - "1.5.  Functional View of SCTP\n   The SCTP transport service can be decomposed
      into a number of\n   functions.  These are depicted in Figure 2 and explained
      in the\n   remainder of this section.\n                           SCTP User
      Application\n            -----------------------------------------------------\n
      \            _____________                  ____________________\n            |
      \            |                | Sequenced Delivery |\n            | Association
      |                |   within Streams   |\n            |             |                |____________________|\n
      \           |   Startup   |\n            |             |         ____________________________\n
      \           |     and     |        |    User Data Fragmentation |\n            |
      \            |        |____________________________|\n            |   Takedown
      \ |\n            |             |         ____________________________\n            |
      \            |        |     Acknowledgement        |\n            |             |
      \       |          and               |\n            |             |        |
      \   Congestion Avoidance    |\n            |             |        |____________________________|\n
      \           |             |\n            |             |         ____________________________\n
      \           |             |        |       Chunk Bundling       |\n            |
      \            |        |____________________________|\n            |             |\n
      \           |             |     ________________________________\n            |
      \            |    |      Packet Validation         |\n            |             |
      \   |________________________________|\n            |             |\n            |
      \            |     ________________________________\n            |             |
      \   |     Path Management            |\n            |_____________|    |________________________________|\n
      \             Figure 2: Functional View of the SCTP Transport Service\n"
    - contents:
      - "1.5.1.  Association Startup and Takedown\n   An association is initiated
        by a request from the SCTP user (see the\n   description of the ASSOCIATE
        (or SEND) primitive in Section 10).\n   A cookie mechanism, similar to one
        described by Karn and Simpson in\n   [RFC2522], is employed during the initialization
        to provide\n   protection against synchronization attacks.  The cookie mechanism\n
        \  uses a four-way handshake, the last two legs of which are allowed to\n
        \  carry user data for fast setup.  The startup sequence is described in\n
        \  Section 5 of this document.\n   SCTP provides for graceful close (i.e.,
        shutdown) of an active\n   association on request from the SCTP user.  See
        the description of\n   the SHUTDOWN primitive in Section 10.  SCTP also allows
        ungraceful\n   close (i.e., abort), either on request from the user (ABORT\n
        \  primitive) or as a result of an error condition detected within the\n   SCTP
        layer.  Section 9 describes both the graceful and the ungraceful\n   close
        procedures.\n   SCTP does not support a half-open state (like TCP) wherein
        one side\n   may continue sending data while the other end is closed.  When
        either\n   endpoint performs a shutdown, the association on each peer will
        stop\n   accepting new data from its user and only deliver data in queue at\n
        \  the time of the graceful close (see Section 9).\n"
      title: 1.5.1.  Association Startup and Takedown
    - contents:
      - "1.5.2.  Sequenced Delivery within Streams\n   The term \"stream\" is used
        in SCTP to refer to a sequence of user\n   messages that are to be delivered
        to the upper-layer protocol in\n   order with respect to other messages within
        the same stream.  This is\n   in contrast to its usage in TCP, where it refers
        to a sequence of\n   bytes (in this document, a byte is assumed to be 8 bits).\n
        \  The SCTP user can specify at association startup time the number of\n   streams
        to be supported by the association.  This number is\n   negotiated with the
        remote end (see Section 5.1.1).  User messages\n   are associated with stream
        numbers (SEND, RECEIVE primitives, Section\n   10).  Internally, SCTP assigns
        a Stream Sequence Number to each\n   message passed to it by the SCTP user.
        \ On the receiving side, SCTP\n   ensures that messages are delivered to the
        SCTP user in sequence\n   within a given stream.  However, while one stream
        may be blocked\n   waiting for the next in-sequence user message, delivery
        from other\n   streams may proceed.\n   SCTP provides a mechanism for bypassing
        the sequenced delivery\n   service.  User messages sent using this mechanism
        are delivered to\n   the SCTP user as soon as they are received.\n"
      title: 1.5.2.  Sequenced Delivery within Streams
    - contents:
      - "1.5.3.  User Data Fragmentation\n   When needed, SCTP fragments user messages
        to ensure that the SCTP\n   packet passed to the lower layer conforms to the
        path MTU.  On\n   receipt, fragments are reassembled into complete messages
        before\n   being passed to the SCTP user.\n"
      title: 1.5.3.  User Data Fragmentation
    - contents:
      - "1.5.4.  Acknowledgement and Congestion Avoidance\n   SCTP assigns a Transmission
        Sequence Number (TSN) to each user data\n   fragment or unfragmented message.
        \ The TSN is independent of any\n   Stream Sequence Number assigned at the
        stream level.  The receiving\n   end acknowledges all TSNs received, even
        if there are gaps in the\n   sequence.  In this way, reliable delivery is
        kept functionally\n   separate from sequenced stream delivery.\n   The acknowledgement
        and congestion avoidance function is responsible\n   for packet retransmission
        when timely acknowledgement has not been\n   received.  Packet retransmission
        is conditioned by congestion\n   avoidance procedures similar to those used
        for TCP.  See Section 6\n   and Section 7 for a detailed description of the
        protocol procedures\n   associated with this function.\n"
      title: 1.5.4.  Acknowledgement and Congestion Avoidance
    - contents:
      - "1.5.5.  Chunk Bundling\n   As described in Section 3, the SCTP packet as
        delivered to the lower\n   layer consists of a common header followed by one
        or more chunks.\n   Each chunk may contain either user data or SCTP control
        information.\n   The SCTP user has the option to request bundling of more
        than one\n   user message into a single SCTP packet.  The chunk bundling function\n
        \  of SCTP is responsible for assembly of the complete SCTP packet and\n   its
        disassembly at the receiving end.\n   During times of congestion, an SCTP
        implementation MAY still perform\n   bundling even if the user has requested
        that SCTP not bundle.  The\n   user's disabling of bundling only affects SCTP
        implementations that\n   may delay a small period of time before transmission
        (to attempt to\n   encourage bundling).  When the user layer disables bundling,
        this\n   small delay is prohibited but not bundling that is performed during\n
        \  congestion or retransmission.\n"
      title: 1.5.5.  Chunk Bundling
    - contents:
      - "1.5.6.  Packet Validation\n   A mandatory Verification Tag field and a 32-bit
        checksum field (see\n   Appendix B for a description of the CRC32c checksum)
        are included in\n   the SCTP common header.  The Verification Tag value is
        chosen by each\n   end of the association during association startup.  Packets
        received\n   without the expected Verification Tag value are discarded, as
        a\n   protection against blind masquerade attacks and against stale SCTP\n
        \  packets from a previous association.  The CRC32c checksum should be\n   set
        by the sender of each SCTP packet to provide additional\n   protection against
        data corruption in the network.  The receiver of\n   an SCTP packet with an
        invalid CRC32c checksum silently discards the\n   packet.\n"
      title: 1.5.6.  Packet Validation
    - contents:
      - "1.5.7.  Path Management\n   The sending SCTP user is able to manipulate the
        set of transport\n   addresses used as destinations for SCTP packets through
        the\n   primitives described in Section 10.  The SCTP path management\n   function
        chooses the destination transport address for each outgoing\n   SCTP packet
        based on the SCTP user's instructions and the currently\n   perceived reachability
        status of the eligible destination set.  The\n   path management function
        monitors reachability through heartbeats\n   when other packet traffic is
        inadequate to provide this information\n   and advises the SCTP user when
        reachability of any far-end transport\n   address changes.  The path management
        function is also responsible\n   for reporting the eligible set of local transport
        addresses to the\n   far end during association startup, and for reporting
        the transport\n   addresses returned from the far end to the SCTP user.\n
        \  At association startup, a primary path is defined for each SCTP\n   endpoint,
        and is used for normal sending of SCTP packets.\n   On the receiving end,
        the path management is responsible for\n   verifying the existence of a valid
        SCTP association to which the\n   inbound SCTP packet belongs before passing
        it for further processing.\n   Note: Path Management and Packet Validation
        are done at the same\n   time, so although described separately above, in
        reality they cannot\n   be performed as separate items.\n"
      title: 1.5.7.  Path Management
    title: 1.5.  Functional View of SCTP
  - contents:
    - "1.6.  Serial Number Arithmetic\n   It is essential to remember that the actual
      Transmission Sequence\n   Number space is finite, though very large.  This space
      ranges from 0\n   to 2**32 - 1.  Since the space is finite, all arithmetic dealing
      with\n   Transmission Sequence Numbers must be performed modulo 2**32.  This\n
      \  unsigned arithmetic preserves the relationship of sequence numbers as\n   they
      cycle from 2**32 - 1 to 0 again.  There are some subtleties to\n   computer
      modulo arithmetic, so great care should be taken in\n   programming the comparison
      of such values.  When referring to TSNs,\n   the symbol \"=<\" means \"less
      than or equal\"(modulo 2**32).\n   Comparisons and arithmetic on TSNs in this
      document SHOULD use Serial\n   Number Arithmetic as defined in [RFC1982] where
      SERIAL_BITS = 32.\n   An endpoint SHOULD NOT transmit a DATA chunk with a TSN
      that is more\n   than 2**31 - 1 above the beginning TSN of its current send
      window.\n   Doing so will cause problems in comparing TSNs.\n   Transmission
      Sequence Numbers wrap around when they reach 2**32 - 1.\n   That is, the next
      TSN a DATA chunk MUST use after transmitting TSN =\n   2*32 - 1 is TSN = 0.\n
      \  Any arithmetic done on Stream Sequence Numbers SHOULD use Serial\n   Number
      Arithmetic as defined in [RFC1982] where SERIAL_BITS = 16.\n   All other arithmetic
      and comparisons in this document use normal\n   arithmetic.\n"
    title: 1.6.  Serial Number Arithmetic
  - contents:
    - "1.7.  Changes from RFC 2960\n   SCTP was originally defined in [RFC2960], which
      this document\n   obsoletes.  Readers interested in the details of the various
      changes\n   that this document incorporates are asked to consult [RFC4460].\n"
    title: 1.7.  Changes from RFC 2960
  title: 1.  Introduction
- contents:
  - "2.  Conventions\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
    \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\"
    in this\n   document are to be interpreted as described in RFC 2119 [RFC2119].\n"
  title: 2.  Conventions
- contents:
  - "3.  SCTP Packet Format\n   An SCTP packet is composed of a common header and
    chunks.  A chunk\n   contains either control information or user data.\n   The
    SCTP packet format is shown below:\n        0                   1                   2
    \                  3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
    4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \      |                        Common Header                          |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \      |                          Chunk #1                             |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \      |                           ...                                 |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \      |                          Chunk #n                             |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  Multiple chunks can be bundled into one SCTP packet up to the MTU\n   size,
    except for the INIT, INIT ACK, and SHUTDOWN COMPLETE chunks.\n   These chunks
    MUST NOT be bundled with any other chunk in a packet.\n   See Section 6.10 for
    more details on chunk bundling.\n   If a user data message doesn't fit into one
    SCTP packet it can be\n   fragmented into multiple chunks using the procedure
    defined in\n   Section 6.9.\n   All integer fields in an SCTP packet MUST be transmitted
    in network\n   byte order, unless otherwise stated.\n"
  - contents:
    - "3.1.  SCTP Common Header Field Descriptions\n                       SCTP Common
      Header Format\n        0                   1                   2                   3\n
      \       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \      |     Source Port Number        |     Destination Port Number   |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \      |                      Verification Tag                         |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \      |                           Checksum                            |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Source Port Number: 16 bits (unsigned integer)\n      This is the SCTP sender's
      port number.  It can be used by the\n      receiver in combination with the
      source IP address, the SCTP\n      destination port, and possibly the destination
      IP address to\n      identify the association to which this packet belongs.
      \ The port\n      number 0 MUST NOT be used.\n   Destination Port Number: 16
      bits (unsigned integer)\n      This is the SCTP port number to which this packet
      is destined.\n      The receiving host will use this port number to de-multiplex
      the\n      SCTP packet to the correct receiving endpoint/application.  The\n
      \     port number 0 MUST NOT be used.\n   Verification Tag: 32 bits (unsigned
      integer)\n      The receiver of this packet uses the Verification Tag to validate\n
      \     the sender of this SCTP packet.  On transmit, the value of this\n      Verification
      Tag MUST be set to the value of the Initiate Tag\n      received from the peer
      endpoint during the association\n      initialization, with the following exceptions:\n
      \     -  A packet containing an INIT chunk MUST have a zero Verification\n            Tag.\n
      \     -  A packet containing a SHUTDOWN COMPLETE chunk with the T bit\n         set
      MUST have the Verification Tag copied from the packet with\n         the SHUTDOWN
      ACK chunk.\n      -  A packet containing an ABORT chunk may have the verification\n
      \        tag copied from the packet that caused the ABORT to be sent.\n         For
      details see Section 8.4 and Section 8.5.\n   An INIT chunk MUST be the only
      chunk in the SCTP packet carrying it.\n   Checksum: 32 bits (unsigned integer)\n
      \     This field contains the checksum of this SCTP packet.  Its\n      calculation
      is discussed in Section 6.8.  SCTP uses the CRC32c\n      algorithm as described
      in Appendix B for calculating the checksum.\n"
    title: 3.1.  SCTP Common Header Field Descriptions
  - contents:
    - "3.2.  Chunk Field Descriptions\n   The figure below illustrates the field format
      for the chunks to be\n   transmitted in the SCTP packet.  Each chunk is formatted
      with a Chunk\n   Type field, a chunk-specific Flag field, a Chunk Length field,
      and a\n   Value field.\n        0                   1                   2                   3\n
      \       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \      |   Chunk Type  | Chunk  Flags  |        Chunk Length           |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \      \\                                                               \\\n
      \      /                          Chunk Value                          /\n       \\
      \                                                              \\\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Chunk Type: 8 bits (unsigned integer)\n      This field identifies the type
      of information contained in the\n      Chunk Value field.  It takes a value
      from 0 to 254.  The value of\n      255 is reserved for future use as an extension
      field.\n      The values of Chunk Types are defined as follows:\n   ID Value
      \   Chunk Type\n   -----       ----------\n   0          - Payload Data (DATA)\n
      \  1          - Initiation (INIT)\n   2          - Initiation Acknowledgement
      (INIT ACK)\n   3          - Selective Acknowledgement (SACK)\n   4          -
      Heartbeat Request (HEARTBEAT)\n   5          - Heartbeat Acknowledgement (HEARTBEAT
      ACK)\n   6          - Abort (ABORT)\n   7          - Shutdown (SHUTDOWN)\n   8
      \         - Shutdown Acknowledgement (SHUTDOWN ACK)\n   9          - Operation
      Error (ERROR)\n   10         - State Cookie (COOKIE ECHO)\n   11         - Cookie
      Acknowledgement (COOKIE ACK)\n   12         - Reserved for Explicit Congestion
      Notification Echo\n                (ECNE)\n   13         - Reserved for Congestion
      Window Reduced (CWR)\n   14         - Shutdown Complete (SHUTDOWN COMPLETE)\n
      \  15 to 62   - available\n   63         - reserved for IETF-defined Chunk Extensions\n
      \  64 to 126  - available\n   127        - reserved for IETF-defined Chunk Extensions\n
      \  128 to 190 - available\n   191        - reserved for IETF-defined Chunk Extensions\n
      \  192 to 254 - available\n   255        - reserved for IETF-defined Chunk Extensions\n
      \     Chunk Types are encoded such that the highest-order 2 bits specify\n      the
      action that must be taken if the processing endpoint does not\n      recognize
      the Chunk Type.\n      00 -  Stop processing this SCTP packet and discard it,
      do not\n            process any further chunks within it.\n      01 -  Stop
      processing this SCTP packet and discard it, do not\n            process any
      further chunks within it, and report the\n            unrecognized chunk in
      an 'Unrecognized Chunk Type'.\n      10 -  Skip this chunk and continue processing.\n
      \     11 -  Skip this chunk and continue processing, but report in an\n            ERROR
      chunk using the 'Unrecognized Chunk Type' cause of\n            error.\n      Note:
      The ECNE and CWR chunk types are reserved for future use of\n      Explicit
      Congestion Notification (ECN); see Appendix A.\n   Chunk Flags: 8 bits\n      The
      usage of these bits depends on the Chunk type as given by the\n      Chunk Type
      field.  Unless otherwise specified, they are set to 0\n      on transmit and
      are ignored on receipt.\n   Chunk Length: 16 bits (unsigned integer)\n      This
      value represents the size of the chunk in bytes, including\n      the Chunk
      Type, Chunk Flags, Chunk Length, and Chunk Value fields.\n      Therefore, if
      the Chunk Value field is zero-length, the Length\n      field will be set to
      4.  The Chunk Length field does not count any\n      chunk padding.\n      Chunks
      (including Type, Length, and Value fields) are padded out\n      by the sender
      with all zero bytes to be a multiple of 4 bytes\n      long.  This padding MUST
      NOT be more than 3 bytes in total.  The\n      Chunk Length value does not include
      terminating padding of the\n      chunk.  However, it does include padding of
      any variable-length\n      parameter except the last parameter in the chunk.
      \ The receiver\n      MUST ignore the padding.\n      Note: A robust implementation
      should accept the chunk whether or\n      not the final padding has been included
      in the Chunk Length.\n   Chunk Value: variable length\n      The Chunk Value
      field contains the actual information to be\n      transferred in the chunk.
      \ The usage and format of this field is\n      dependent on the Chunk Type.\n
      \  The total length of a chunk (including Type, Length, and Value\n   fields)
      MUST be a multiple of 4 bytes.  If the length of the chunk is\n   not a multiple
      of 4 bytes, the sender MUST pad the chunk with all\n   zero bytes, and this
      padding is not included in the Chunk Length\n   field.  The sender MUST NOT
      pad with more than 3 bytes.  The receiver\n   MUST ignore the padding bytes.\n
      \  SCTP-defined chunks are described in detail in Section 3.3.  The\n   guidelines
      for IETF-defined chunk extensions can be found in Section\n   14.1 of this document.\n"
    - contents:
      - "3.2.1.  Optional/Variable-Length Parameter Format\n   Chunk values of SCTP
        control chunks consist of a chunk-type-specific\n   header of required fields,
        followed by zero or more parameters.  The\n   optional and variable-length
        parameters contained in a chunk are\n   defined in a Type-Length-Value format
        as shown below.\n        0                   1                   2                   3\n
        \       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |          Parameter Type       |       Parameter Length        |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      \\                                                               \\\n
        \      /                       Parameter Value                         /\n
        \      \\                                                               \\\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Chunk Parameter Type: 16 bits (unsigned integer)\n      The Type field
        is a 16-bit identifier of the type of parameter.\n      It takes a value of
        0 to 65534.\n      The value of 65535 is reserved for IETF-defined extensions.\n
        \     Values other than those defined in specific SCTP chunk\n      descriptions
        are reserved for use by IETF.\n   Chunk Parameter Length: 16 bits (unsigned
        integer)\n      The Parameter Length field contains the size of the parameter
        in\n      bytes, including the Parameter Type, Parameter Length, and\n      Parameter
        Value fields.  Thus, a parameter with a zero-length\n      Parameter Value
        field would have a Length field of 4.  The\n      Parameter Length does not
        include any padding bytes.\n   Chunk Parameter Value: variable length\n      The
        Parameter Value field contains the actual information to be\n      transferred
        in the parameter.\n      The total length of a parameter (including Type,
        Parameter Length,\n      and Value fields) MUST be a multiple of 4 bytes.
        \ If the length of\n      the parameter is not a multiple of 4 bytes, the
        sender pads the\n      parameter at the end (i.e., after the Parameter Value
        field) with\n      all zero bytes.  The length of the padding is not included
        in the\n      Parameter Length field.  A sender MUST NOT pad with more than
        3\n      bytes.  The receiver MUST ignore the padding bytes.\n      The Parameter
        Types are encoded such that the highest-order 2 bits\n      specify the action
        that must be taken if the processing endpoint\n      does not recognize the
        Parameter Type.\n      00 -  Stop processing this parameter; do not process
        any further\n            parameters within this chunk.\n      01 -  Stop processing
        this parameter, do not process any further\n            parameters within
        this chunk, and report the unrecognized\n            parameter in an 'Unrecognized
        Parameter', as described in\n            Section 3.2.2.\n      10 -  Skip
        this parameter and continue processing.\n      11 -  Skip this parameter and
        continue processing but report the\n            unrecognized parameter in
        an 'Unrecognized Parameter', as\n            described in Section 3.2.2.\n
        \  Please note that in all four cases, an INIT ACK or COOKIE ECHO chunk\n
        \  is sent.  In the 00 or 01 case, the processing of the parameters\n   after
        the unknown parameter is canceled, but no processing already\n   done is rolled
        back.\n   The actual SCTP parameters are defined in the specific SCTP chunk\n
        \  sections.  The rules for IETF-defined parameter extensions are\n   defined
        in Section 14.2.  Note that a parameter type MUST be unique\n   across all
        chunks.  For example, the parameter type '5' is used to\n   represent an IPv4
        address (see Section 3.3.2.1).  The value '5' then\n   is reserved across
        all chunks to represent an IPv4 address and MUST\n   NOT be reused with a
        different meaning in any other chunk.\n"
      title: 3.2.1.  Optional/Variable-Length Parameter Format
    - contents:
      - "3.2.2.  Reporting of Unrecognized Parameters\n   If the receiver of an INIT
        chunk detects unrecognized parameters and\n   has to report them according
        to Section 3.2.1, it MUST put the\n   'Unrecognized Parameter' parameter(s)
        in the INIT ACK chunk sent in\n   response to the INIT chunk.  Note that if
        the receiver of the INIT\n   chunk is NOT going to establish an association
        (e.g., due to lack of\n   resources), an 'Unrecognized Parameter' would NOT
        be included with\n   any ABORT being sent to the sender of the INIT.\n   If
        the receiver of an INIT ACK chunk detects unrecognized parameters\n   and
        has to report them according to Section 3.2.1, it SHOULD bundle\n   the ERROR
        chunk containing the 'Unrecognized Parameters' error cause\n   with the COOKIE
        ECHO chunk sent in response to the INIT ACK chunk.\n   If the receiver of
        the INIT ACK cannot bundle the COOKIE ECHO chunk\n   with the ERROR chunk,
        the ERROR chunk MAY be sent separately but not\n   before the COOKIE ACK has
        been received.\n   Note: Any time a COOKIE ECHO is sent in a packet, it MUST
        be the\n   first chunk.\n"
      title: 3.2.2.  Reporting of Unrecognized Parameters
    title: 3.2.  Chunk Field Descriptions
  - contents:
    - "3.3.  SCTP Chunk Definitions\n   This section defines the format of the different
      SCTP chunk types.\n"
    - contents:
      - "3.3.1.  Payload Data (DATA) (0)\n   The following format MUST be used for
        the DATA chunk:\n        0                   1                   2                   3\n
        \       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |   Type = 0    | Reserved|U|B|E|    Length                     |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |                              TSN                              |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |      Stream Identifier S      |   Stream Sequence Number n    |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |                  Payload Protocol Identifier                  |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      \\                                                               \\\n
        \      /                 User Data (seq n of Stream S)                 /\n
        \      \\                                                               \\\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Reserved: 5 bits\n      Should be set to all '0's and ignored by the receiver.\n
        \  U bit: 1 bit\n      The (U)nordered bit, if set to '1', indicates that
        this is an\n      unordered DATA chunk, and there is no Stream Sequence Number\n
        \     assigned to this DATA chunk.  Therefore, the receiver MUST ignore\n
        \     the Stream Sequence Number field.\n      After reassembly (if necessary),
        unordered DATA chunks MUST be\n      dispatched to the upper layer by the
        receiver without any attempt\n      to reorder.\n      If an unordered user
        message is fragmented, each fragment of the\n      message MUST have its U
        bit set to '1'.\n   B bit: 1 bit\n      The (B)eginning fragment bit, if set,
        indicates the first fragment\n      of a user message.\n   E bit: 1 bit\n
        \     The (E)nding fragment bit, if set, indicates the last fragment of\n
        \     a user message.\n   An unfragmented user message shall have both the
        B and E bits set to\n   '1'.  Setting both B and E bits to '0' indicates a
        middle fragment of\n   a multi-fragment user message, as summarized in the
        following table:\n               B E                  Description\n            ============================================================\n
        \           |  1 0 | First piece of a fragmented user message          |\n
        \           +----------------------------------------------------------+\n
        \           |  0 0 | Middle piece of a fragmented user message         |\n
        \           +----------------------------------------------------------+\n
        \           |  0 1 | Last piece of a fragmented user message           |\n
        \           +----------------------------------------------------------+\n
        \           |  1 1 | Unfragmented message                              |\n
        \           ============================================================\n
        \           |             Table 1: Fragment Description Flags          |\n
        \           ============================================================\n
        \  When a user message is fragmented into multiple chunks, the TSNs are\n
        \  used by the receiver to reassemble the message.  This means that the\n
        \  TSNs for each fragment of a fragmented user message MUST be strictly\n
        \  sequential.\n   Length: 16 bits (unsigned integer)\n      This field indicates
        the length of the DATA chunk in bytes from\n      the beginning of the type
        field to the end of the User Data field\n      excluding any padding.  A DATA
        chunk with one byte of user data\n      will have Length set to 17 (indicating
        17 bytes).\n      A DATA chunk with a User Data field of length L will have
        the\n      Length field set to (16 + L) (indicating 16+L bytes) where L MUST\n
        \     be greater than 0.\n   TSN: 32 bits (unsigned integer)\n      This value
        represents the TSN for this DATA chunk.  The valid\n      range of TSN is
        from 0 to 4294967295 (2**32 - 1).  TSN wraps back\n      to 0 after reaching
        4294967295.\n   Stream Identifier S: 16 bits (unsigned integer)\n      Identifies
        the stream to which the following user data belongs.\n   Stream Sequence Number
        n: 16 bits (unsigned integer)\n      This value represents the Stream Sequence
        Number of the following\n      user data within the stream S.  Valid range
        is 0 to 65535.\n      When a user message is fragmented by SCTP for transport,
        the same\n      Stream Sequence Number MUST be carried in each of the fragments
        of\n      the message.\n   Payload Protocol Identifier: 32 bits (unsigned
        integer)\n      This value represents an application (or upper layer) specified\n
        \     protocol identifier.  This value is passed to SCTP by its upper\n      layer
        and sent to its peer.  This identifier is not used by SCTP\n      but can
        be used by certain network entities, as well as by the\n      peer application,
        to identify the type of information being\n      carried in this DATA chunk.
        \ This field must be sent even in\n      fragmented DATA chunks (to make sure
        it is available for agents in\n      the middle of the network).  Note that
        this field is NOT touched\n      by an SCTP implementation; therefore, its
        byte order is NOT\n      necessarily big endian.  The upper layer is responsible
        for any\n      byte order conversions to this field.\n      The value 0 indicates
        that no application identifier is specified\n      by the upper layer for
        this payload data.\n   User Data: variable length\n      This is the payload
        user data.  The implementation MUST pad the\n      end of the data to a 4-byte
        boundary with all-zero bytes.  Any\n      padding MUST NOT be included in
        the Length field.  A sender MUST\n      never add more than 3 bytes of padding.\n"
      title: 3.3.1.  Payload Data (DATA) (0)
    - contents:
      - "3.3.2.  Initiation (INIT) (1)\n   This chunk is used to initiate an SCTP
        association between two\n   endpoints.  The format of the INIT chunk is shown
        below:\n        0                   1                   2                   3\n
        \       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |   Type = 1    |  Chunk Flags  |      Chunk Length             |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |                         Initiate Tag                          |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |           Advertised Receiver Window Credit (a_rwnd)          |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |  Number of Outbound Streams   |  Number of Inbound Streams    |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |                          Initial TSN                          |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      \\                                                               \\\n
        \      /              Optional/Variable-Length Parameters              /\n
        \      \\                                                               \\\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  The INIT chunk contains the following parameters.  Unless otherwise\n   noted,
        each parameter MUST only be included once in the INIT chunk.\n            Fixed
        Parameters                     Status\n            ----------------------------------------------\n
        \           Initiate Tag                        Mandatory\n            Advertised
        Receiver Window Credit   Mandatory\n            Number of Outbound Streams
        \         Mandatory\n            Number of Inbound Streams           Mandatory\n
        \           Initial TSN                         Mandatory\n          Variable
        Parameters                  Status     Type Value\n          -------------------------------------------------------------\n
        \         IPv4 Address (Note 1)               Optional    5 IPv6 Address\n
        \         (Note 1)               Optional    6 Cookie Preservative\n          Optional
        \   9 Reserved for ECN Capable (Note 2)   Optional\n          32768 (0x8000)
        Host Name Address (Note 3)          Optional\n          11 Supported Address
        Types (Note 4)    Optional    12\n   Note 1: The INIT chunks can contain multiple
        addresses that can be\n   IPv4 and/or IPv6 in any combination.\n   Note 2:
        The ECN Capable field is reserved for future use of Explicit\n   Congestion
        Notification.\n   Note 3: An INIT chunk MUST NOT contain more than one Host
        Name\n   Address parameter.  Moreover, the sender of the INIT MUST NOT combine\n
        \  any other address types with the Host Name Address in the INIT.  The\n
        \  receiver of INIT MUST ignore any other address types if the Host Name\n
        \  Address parameter is present in the received INIT chunk.\n   Note 4: This
        parameter, when present, specifies all the address types\n   the sending endpoint
        can support.  The absence of this parameter\n   indicates that the sending
        endpoint can support any address type.\n   IMPLEMENTATION NOTE: If an INIT
        chunk is received with known\n   parameters that are not optional parameters
        of the INIT chunk, then\n   the receiver SHOULD process the INIT chunk and
        send back an INIT ACK.\n   The receiver of the INIT chunk MAY bundle an ERROR
        chunk with the\n   COOKIE ACK chunk later.  However, restrictive implementations
        MAY\n   send back an ABORT chunk in response to the INIT chunk.\n   The Chunk
        Flags field in INIT is reserved, and all bits in it should\n   be set to 0
        by the sender and ignored by the receiver.  The sequence\n   of parameters
        within an INIT can be processed in any order.\n   Initiate Tag: 32 bits (unsigned
        integer)\n      The receiver of the INIT (the responding end) records the
        value of\n      the Initiate Tag parameter.  This value MUST be placed into
        the\n      Verification Tag field of every SCTP packet that the receiver of\n
        \     the INIT transmits within this association.\n      The Initiate Tag
        is allowed to have any value except 0.  See\n      Section 5.3.1 for more
        on the selection of the tag value.\n      If the value of the Initiate Tag
        in a received INIT chunk is found\n      to be 0, the receiver MUST treat
        it as an error and close the\n      association by transmitting an ABORT.\n
        \  Advertised Receiver Window Credit (a_rwnd): 32 bits (unsigned\n   integer)\n
        \     This value represents the dedicated buffer space, in number of\n      bytes,
        the sender of the INIT has reserved in association with\n      this window.
        \ During the life of the association, this buffer\n      space SHOULD NOT
        be lessened (i.e., dedicated buffers taken away\n      from this association);
        however, an endpoint MAY change the value\n      of a_rwnd it sends in SACK
        chunks.\n   Number of Outbound Streams (OS): 16 bits (unsigned integer)\n
        \     Defines the number of outbound streams the sender of this INIT\n      chunk
        wishes to create in this association.  The value of 0 MUST\n      NOT be used.\n
        \     Note: A receiver of an INIT with the OS value set to 0 SHOULD\n      abort
        the association.\n   Number of Inbound Streams (MIS): 16 bits (unsigned integer)\n
        \     Defines the maximum number of streams the sender of this INIT\n      chunk
        allows the peer end to create in this association.  The\n      value 0 MUST
        NOT be used.\n      Note: There is no negotiation of the actual number of
        streams but\n      instead the two endpoints will use the min(requested, offered).\n
        \     See Section 5.1.1 for details.\n      Note: A receiver of an INIT with
        the MIS value of 0 SHOULD abort\n      the association.\n   Initial TSN (I-TSN):
        32 bits (unsigned integer)\n      Defines the initial TSN that the sender
        will use.  The valid range\n      is from 0 to 4294967295.  This field MAY
        be set to the value of\n      the Initiate Tag field.\n"
      - contents:
        - "3.3.2.1.  Optional/Variable-Length Parameters in INIT\n   The following
          parameters follow the Type-Length-Value format as\n   defined in Section
          3.2.1.  Any Type-Length-Value fields MUST come\n   after the fixed-length
          fields defined in the previous section.\n   IPv4 Address Parameter (5)\n
          \       0                   1                   2                   3\n
          \       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \      |        Type = 5               |      Length = 8               |\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \      |                        IPv4 Address                           |\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  IPv4 Address: 32 bits (unsigned integer)\n      Contains an IPv4 address
          of the sending endpoint.  It is binary\n      encoded.\n   IPv6 Address
          Parameter (6)\n        0                   1                   2                   3\n
          \       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \      |            Type = 6           |          Length = 20          |\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \      |                                                               |\n
          \      |                         IPv6 Address                          |\n
          \      |                                                               |\n
          \      |                                                               |\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  IPv6 Address: 128 bits (unsigned integer)\n      Contains an IPv6 [RFC2460]
          address of the sending endpoint.  It is\n      binary encoded.\n      Note:
          A sender MUST NOT use an IPv4-mapped IPv6 address [RFC4291],\n      but
          should instead use an IPv4 Address parameter for an IPv4\n      address.\n
          \     Combined with the Source Port Number in the SCTP common header,\n
          \     the value passed in an IPv4 or IPv6 Address parameter indicates a\n
          \     transport address the sender of the INIT will support for the\n      association
          being initiated.  That is, during the life time of\n      this association,
          this IP address can appear in the source address\n      field of an IP datagram
          sent from the sender of the INIT, and can\n      be used as a destination
          address of an IP datagram sent from the\n      receiver of the INIT.\n      More
          than one IP Address parameter can be included in an INIT\n      chunk when
          the INIT sender is multi-homed.  Moreover, a multi-\n      homed endpoint
          may have access to different types of network;\n      thus, more than one
          address type can be present in one INIT chunk,\n      i.e., IPv4 and IPv6
          addresses are allowed in the same INIT chunk.\n      If the INIT contains
          at least one IP Address parameter, then the\n      source address of the
          IP datagram containing the INIT chunk and\n      any additional address(es)
          provided within the INIT can be used as\n      destinations by the endpoint
          receiving the INIT.  If the INIT does\n      not contain any IP Address
          parameters, the endpoint receiving the\n      INIT MUST use the source address
          associated with the received IP\n      datagram as its sole destination
          address for the association.\n      Note that not using any IP Address parameters
          in the INIT and INIT\n      ACK is an alternative to make an association
          more likely to work\n      across a NAT box.\n   Cookie Preservative (9)\n
          \  The sender of the INIT shall use this parameter to suggest to the\n   receiver
          of the INIT for a longer life-span of the State Cookie.\n        0                   1
          \                  2                   3\n        0 1 2 3 4 5 6 7 8 9 0
          1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \      |          Type = 9             |          Length = 8           |\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \      |         Suggested Cookie Life-Span Increment (msec.)          |\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  Suggested Cookie Life-Span Increment: 32 bits (unsigned integer)\n      This
          parameter indicates to the receiver how much increment in\n      milliseconds
          the sender wishes the receiver to add to its default\n      cookie life-span.\n
          \     This optional parameter should be added to the INIT chunk by the\n
          \     sender when it reattempts establishing an association with a peer\n
          \     to which its previous attempt of establishing the association\n      failed
          due to a stale cookie operation error.  The receiver MAY\n      choose to
          ignore the suggested cookie life-span increase for its\n      own security
          reasons.\n   Host Name Address (11)\n   The sender of INIT uses this parameter
          to pass its Host Name (in\n   place of its IP addresses) to its peer.  The
          peer is responsible for\n   resolving the name.  Using this parameter might
          make it more likely\n   for the association to work across a NAT box.\n
          \      0                   1                   2                   3\n       0
          1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \      |          Type = 11            |          Length               |\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \      /                          Host Name                            /\n
          \      \\                                                               \\\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  Host Name: variable length\n      This field contains a host name in
          \"host name syntax\" per RFC 1123\n      Section 2.1 [RFC1123].  The method
          for resolving the host name is\n      out of scope of SCTP.\n      Note:
          At least one null terminator is included in the Host Name\n      string
          and must be included in the length.\n   Supported Address Types (12)\n   The
          sender of INIT uses this parameter to list all the address types\n   it
          can support.\n        0                   1                   2                   3\n
          \       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \      |          Type = 12            |          Length               |\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \      |        Address Type #1        |        Address Type #2        |\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \      |                            ......                             |\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-++-+-+-+-+-+-+-+-+-+-+-+-+-+-++-+-+-+\n
          \  Address Type: 16 bits (unsigned integer)\n      This is filled with the
          type value of the corresponding address\n      TLV (e.g., IPv4 = 5, IPv6
          = 6, Host name = 11).\n"
        title: 3.3.2.1.  Optional/Variable-Length Parameters in INIT
      title: 3.3.2.  Initiation (INIT) (1)
    - contents:
      - "3.3.3.  Initiation Acknowledgement (INIT ACK) (2)\n   The INIT ACK chunk
        is used to acknowledge the initiation of an SCTP\n   association.\n   The
        parameter part of INIT ACK is formatted similarly to the INIT\n   chunk.  It
        uses two extra variable parameters: The State Cookie and\n   the Unrecognized
        Parameter:\n   The format of the INIT ACK chunk is shown below:\n        0
        \                  1                   2                   3\n        0 1
        2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |   Type = 2    |  Chunk Flags  |      Chunk Length             |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |                         Initiate Tag                          |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |              Advertised Receiver Window Credit                |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |  Number of Outbound Streams   |  Number of Inbound Streams    |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |                          Initial TSN                          |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      \\                                                               \\\n
        \      /              Optional/Variable-Length Parameters              /\n
        \      \\                                                               \\\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Initiate Tag: 32 bits (unsigned integer)\n      The receiver of the INIT
        ACK records the value of the Initiate Tag\n      parameter.  This value MUST
        be placed into the Verification Tag\n      field of every SCTP packet that
        the INIT ACK receiver transmits\n      within this association.\n      The
        Initiate Tag MUST NOT take the value 0.  See Section 5.3.1 for\n      more
        on the selection of the Initiate Tag value.\n      If the value of the Initiate
        Tag in a received INIT ACK chunk is\n      found to be 0, the receiver MUST
        destroy the association\n      discarding its TCB.  The receiver MAY send
        an ABORT for debugging\n      purpose.\n   Advertised Receiver Window Credit
        (a_rwnd): 32 bits (unsigned\n   integer)\n      This value represents the
        dedicated buffer space, in number of\n      bytes, the sender of the INIT
        ACK has reserved in association with\n      this window.  During the life
        of the association, this buffer\n      space SHOULD NOT be lessened (i.e.,
        dedicated buffers taken away\n      from this association).\n   Number of
        Outbound Streams (OS): 16 bits (unsigned integer)\n      Defines the number
        of outbound streams the sender of this INIT ACK\n      chunk wishes to create
        in this association.  The value of 0 MUST\n      NOT be used, and the value
        MUST NOT be greater than the MIS value\n      sent in the INIT chunk.\n      Note:
        A receiver of an INIT ACK with the OS value set to 0 SHOULD\n      destroy
        the association discarding its TCB.\n   Number of Inbound Streams (MIS): 16
        bits (unsigned integer)\n      Defines the maximum number of streams the sender
        of this INIT ACK\n      chunk allows the peer end to create in this association.
        \ The\n      value 0 MUST NOT be used.\n      Note: There is no negotiation
        of the actual number of streams but\n      instead the two endpoints will
        use the min(requested, offered).\n      See Section 5.1.1 for details.\n      Note:
        A receiver of an INIT ACK with the MIS value set to 0 SHOULD\n      destroy
        the association discarding its TCB.\n   Initial TSN (I-TSN): 32 bits (unsigned
        integer)\n      Defines the initial TSN that the INIT ACK sender will use.
        \ The\n      valid range is from 0 to 4294967295.  This field MAY be set to
        the\n      value of the Initiate Tag field.\n         Fixed Parameters                     Status\n
        \        ----------------------------------------------\n         Initiate
        Tag                        Mandatory\n         Advertised Receiver Window
        Credit   Mandatory\n         Number of Outbound Streams          Mandatory\n
        \        Number of Inbound Streams           Mandatory\n         Initial TSN
        \                        Mandatory\n         Variable Parameters                  Status
        \    Type Value\n         -------------------------------------------------------------\n
        \        State Cookie                        Mandatory   7\n         IPv4
        Address (Note 1)               Optional    5\n         IPv6 Address (Note
        1)               Optional    6\n         Unrecognized Parameter              Optional
        \   8\n         Reserved for ECN Capable (Note 2)   Optional    32768 (0x8000)\n
        \        Host Name Address (Note 3)          Optional    11\n   Note 1: The
        INIT ACK chunks can contain any number of IP address\n   parameters that can
        be IPv4 and/or IPv6 in any combination.\n   Note 2: The ECN Capable field
        is reserved for future use of Explicit\n   Congestion Notification.\n   Note
        3: The INIT ACK chunks MUST NOT contain more than one Host Name\n   Address
        parameter.  Moreover, the sender of the INIT ACK MUST NOT\n   combine any
        other address types with the Host Name Address in the\n   INIT ACK.  The receiver
        of the INIT ACK MUST ignore any other address\n   types if the Host Name Address
        parameter is present.\n   IMPLEMENTATION NOTE: An implementation MUST be prepared
        to receive an\n   INIT ACK that is quite large (more than 1500 bytes) due
        to the\n   variable size of the State Cookie AND the variable address list.
        \ For\n   example if a responder to the INIT has 1000 IPv4 addresses it wishes\n
        \  to send, it would need at least 8,000 bytes to encode this in the\n   INIT
        ACK.\n   IMPLEMENTATION NOTE: If an INIT ACK chunk is received with known\n
        \  parameters that are not optional parameters of the INIT ACK chunk,\n   then
        the receiver SHOULD process the INIT ACK chunk and send back a\n   COOKIE
        ECHO.  The receiver of the INIT ACK chunk MAY bundle an ERROR\n   chunk with
        the COOKIE ECHO chunk.  However, restrictive\n   implementations MAY send
        back an ABORT chunk in response to the INIT\n   ACK chunk.\n   In combination
        with the Source Port carried in the SCTP common\n   header, each IP Address
        parameter in the INIT ACK indicates to the\n   receiver of the INIT ACK a
        valid transport address supported by the\n   sender of the INIT ACK for the
        life time of the association being\n   initiated.\n   If the INIT ACK contains
        at least one IP Address parameter, then the\n   source address of the IP datagram
        containing the INIT ACK and any\n   additional address(es) provided within
        the INIT ACK may be used as\n   destinations by the receiver of the INIT ACK.
        \ If the INIT ACK does\n   not contain any IP Address parameters, the receiver
        of the INIT ACK\n   MUST use the source address associated with the received
        IP datagram\n   as its sole destination address for the association.\n   The
        State Cookie and Unrecognized Parameters use the Type-Length-\n   Value format
        as defined in Section 3.2.1 and are described below.\n   The other fields
        are defined the same as their counterparts in the\n   INIT chunk.\n"
      - contents:
        - "3.3.3.1.  Optional or Variable-Length Parameters\n   State Cookie\n   Parameter
          Type Value: 7\n      Parameter Length: Variable size, depending on size
          of Cookie.\n   Parameter Value:\n      This parameter value MUST contain
          all the necessary state and\n      parameter information required for the
          sender of this INIT ACK to\n      create the association, along with a Message
          Authentication Code\n      (MAC).  See Section 5.1.3 for details on State
          Cookie definition.\n   Unrecognized Parameter:\n      Parameter Type Value:
          8\n   Parameter Length: Variable size.\n   Parameter Value:\n      This
          parameter is returned to the originator of the INIT chunk\n      when the
          INIT contains an unrecognized parameter that has a value\n      that indicates
          it should be reported to the sender.  This\n      parameter value field
          will contain unrecognized parameters copied\n      from the INIT chunk complete
          with Parameter Type, Length, and\n      Value fields.\n"
        title: 3.3.3.1.  Optional or Variable-Length Parameters
      title: 3.3.3.  Initiation Acknowledgement (INIT ACK) (2)
    - contents:
      - "3.3.4.  Selective Acknowledgement (SACK) (3)\n   This chunk is sent to the
        peer endpoint to acknowledge received DATA\n   chunks and to inform the peer
        endpoint of gaps in the received\n   subsequences of DATA chunks as represented
        by their TSNs.\n   The SACK MUST contain the Cumulative TSN Ack, Advertised
        Receiver\n   Window Credit (a_rwnd), Number of Gap Ack Blocks, and Number
        of\n   Duplicate TSNs fields.\n   By definition, the value of the Cumulative
        TSN Ack parameter is the\n   last TSN received before a break in the sequence
        of received TSNs\n   occurs; the next TSN value following this one has not
        yet been\n   received at the endpoint sending the SACK.  This parameter therefore\n
        \  acknowledges receipt of all TSNs less than or equal to its value.\n   The
        handling of a_rwnd by the receiver of the SACK is discussed in\n   detail
        in Section 6.2.1.\n   The SACK also contains zero or more Gap Ack Blocks.
        \ Each Gap Ack\n   Block acknowledges a subsequence of TSNs received following
        a break\n   in the sequence of received TSNs.  By definition, all TSNs\n   acknowledged
        by Gap Ack Blocks are greater than the value of the\n   Cumulative TSN Ack.\n
        \       0                   1                   2                   3\n        0
        1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |   Type = 3    |Chunk  Flags   |      Chunk Length             |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |                      Cumulative TSN Ack                       |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |          Advertised Receiver Window Credit (a_rwnd)           |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      | Number of Gap Ack Blocks = N  |  Number of Duplicate TSNs = X |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |  Gap Ack Block #1 Start       |   Gap Ack Block #1 End        |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      /                                                               /\n
        \      \\                              ...                              \\\n
        \      /                                                               /\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |   Gap Ack Block #N Start      |  Gap Ack Block #N End         |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |                       Duplicate TSN 1                         |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      /                                                               /\n
        \      \\                              ...                              \\\n
        \      /                                                               /\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |                       Duplicate TSN X                         |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Chunk Flags: 8 bits\n      Set to all '0's on transmit and ignored on receipt.\n
        \  Cumulative TSN Ack: 32 bits (unsigned integer)\n      This parameter contains
        the TSN of the last DATA chunk received in\n      sequence before a gap.  In
        the case where no DATA chunk has been\n      received, this value is set to
        the peer's Initial TSN minus one.\n   Advertised Receiver Window Credit (a_rwnd):
        32 bits (unsigned\n   integer)\n      This field indicates the updated receive
        buffer space in bytes of\n      the sender of this SACK; see Section 6.2.1
        for details.\n   Number of Gap Ack Blocks: 16 bits (unsigned integer)\n      Indicates
        the number of Gap Ack Blocks included in this SACK.\n   Number of Duplicate
        TSNs: 16 bit\n      This field contains the number of duplicate TSNs the endpoint
        has\n      received.  Each duplicate TSN is listed following the Gap Ack\n
        \     Block list.\n   Gap Ack Blocks:\n      These fields contain the Gap
        Ack Blocks.  They are repeated for\n      each Gap Ack Block up to the number
        of Gap Ack Blocks defined in\n      the Number of Gap Ack Blocks field.  All
        DATA chunks with TSNs\n      greater than or equal to (Cumulative TSN Ack
        + Gap Ack Block\n      Start) and less than or equal to (Cumulative TSN Ack
        + Gap Ack\n      Block End) of each Gap Ack Block are assumed to have been
        received\n      correctly.\n   Gap Ack Block Start: 16 bits (unsigned integer)\n
        \     Indicates the Start offset TSN for this Gap Ack Block.  To\n      calculate
        the actual TSN number the Cumulative TSN Ack is added to\n      this offset
        number.  This calculated TSN identifies the first TSN\n      in this Gap Ack
        Block that has been received.\n   Gap Ack Block End: 16 bits (unsigned integer)\n
        \     Indicates the End offset TSN for this Gap Ack Block.  To calculate\n
        \     the actual TSN number, the Cumulative TSN Ack is added to this\n      offset
        number.  This calculated TSN identifies the TSN of the last\n      DATA chunk
        received in this Gap Ack Block.\n   For example, assume that the receiver
        has the following DATA chunks\n   newly arrived at the time when it decides
        to send a Selective ACK,\n                           ----------\n                           |
        TSN=17 |\n                           ----------\n                           |
        \       | <- still missing\n                           ----------\n                           |
        TSN=15 |\n                           ----------\n                           |
        TSN=14 |\n                           ----------\n                           |
        \       | <- still missing\n                           ----------\n                           |
        TSN=12 |\n                           ----------\n                           |
        TSN=11 |\n                           ----------\n                           |
        TSN=10 |\n                           ----------\n   then the parameter part
        of the SACK MUST be constructed as follows\n   (assuming the new a_rwnd is
        set to 4660 by the sender):\n                     +--------------------------------+\n
        \                    |   Cumulative TSN Ack = 12      |\n                     +--------------------------------+\n
        \                    |        a_rwnd = 4660           |\n                     +----------------+---------------+\n
        \                    | num of block=2 | num of dup=0  |\n                     +----------------+---------------+\n
        \                    |block #1 strt=2 |block #1 end=3 |\n                     +----------------+---------------+\n
        \                    |block #2 strt=5 |block #2 end=5 |\n                     +----------------+---------------+\n
        \  Duplicate TSN: 32 bits (unsigned integer)\n      Indicates the number of
        times a TSN was received in duplicate\n      since the last SACK was sent.
        \ Every time a receiver gets a\n      duplicate TSN (before sending the SACK),
        it adds it to the list of\n      duplicates.  The duplicate count is reinitialized
        to zero after\n      sending each SACK.\n   For example, if a receiver were
        to get the TSN 19 three times it\n   would list 19 twice in the outbound SACK.
        \ After sending the SACK, if\n   it received yet one more TSN 19 it would
        list 19 as a duplicate once\n   in the next outgoing SACK.\n"
      title: 3.3.4.  Selective Acknowledgement (SACK) (3)
    - contents:
      - "3.3.5.  Heartbeat Request (HEARTBEAT) (4)\n   An endpoint should send this
        chunk to its peer endpoint to probe the\n   reachability of a particular destination
        transport address defined in\n   the present association.\n   The parameter
        field contains the Heartbeat Information, which is a\n   variable-length opaque
        data structure understood only by the sender.\n        0                   1
        \                  2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1
        2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |   Type = 4    | Chunk  Flags  |      Heartbeat Length         |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      \\                                                               \\\n
        \      /            Heartbeat Information TLV (Variable-Length)        /\n
        \      \\                                                               \\\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Chunk Flags: 8 bits\n      Set to 0 on transmit and ignored on receipt.\n
        \  Heartbeat Length: 16 bits (unsigned integer)\n      Set to the size of
        the chunk in bytes, including the chunk header\n      and the Heartbeat Information
        field.\n   Heartbeat Information: variable length\n      Defined as a variable-length
        parameter using the format described\n      in Section 3.2.1, i.e.:\n         Variable
        Parameters                  Status     Type Value\n         -------------------------------------------------------------\n
        \        Heartbeat Info                       Mandatory   1\n        0                   1
        \                  2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1
        2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |    Heartbeat Info Type=1      |         HB Info Length        |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      /                  Sender-Specific Heartbeat Info               /\n
        \      \\                                                               \\\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     The Sender-Specific Heartbeat Info field should normally include\n      information
        about the sender's current time when this HEARTBEAT\n      chunk is sent and
        the destination transport address to which this\n      HEARTBEAT is sent (see
        Section 8.3).  This information is simply\n      reflected back by the receiver
        in the HEARTBEAT ACK message (see\n      Section 3.3.6).  Note also that the
        HEARTBEAT message is both for\n      reachability checking and for path verification
        (see Section 5.4).\n      When a HEARTBEAT chunk is being used for path verification\n
        \     purposes, it MUST hold a 64-bit random nonce.\n"
      title: 3.3.5.  Heartbeat Request (HEARTBEAT) (4)
    - contents:
      - "3.3.6.  Heartbeat Acknowledgement (HEARTBEAT ACK) (5)\n   An endpoint should
        send this chunk to its peer endpoint as a response\n   to a HEARTBEAT chunk
        (see Section 8.3).  A HEARTBEAT ACK is always\n   sent to the source IP address
        of the IP datagram containing the\n   HEARTBEAT chunk to which this ack is
        responding.\n   The parameter field contains a variable-length opaque data
        structure.\n        0                   1                   2                   3\n
        \       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |   Type = 5    | Chunk  Flags  |    Heartbeat Ack Length       |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      \\                                                               \\\n
        \      /            Heartbeat Information TLV (Variable-Length)        /\n
        \      \\                                                               \\\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Chunk Flags: 8 bits\n      Set to 0 on transmit and ignored on receipt.\n
        \  Heartbeat Ack Length: 16 bits (unsigned integer)\n      Set to the size
        of the chunk in bytes, including the chunk header\n      and the Heartbeat
        Information field.\n   Heartbeat Information: variable length\n      This
        field MUST contain the Heartbeat Information parameter of the\n      Heartbeat
        Request to which this Heartbeat Acknowledgement is\n      responding.\n         Variable
        Parameters                  Status     Type Value\n         -------------------------------------------------------------\n
        \        Heartbeat Info                       Mandatory   1\n"
      title: 3.3.6.  Heartbeat Acknowledgement (HEARTBEAT ACK) (5)
    - contents:
      - "3.3.7.  Abort Association (ABORT) (6)\n   The ABORT chunk is sent to the
        peer of an association to close the\n   association.  The ABORT chunk may
        contain Cause Parameters to inform\n   the receiver about the reason of the
        abort.  DATA chunks MUST NOT be\n   bundled with ABORT.  Control chunks (except
        for INIT, INIT ACK, and\n   SHUTDOWN COMPLETE) MAY be bundled with an ABORT,
        but they MUST be\n   placed before the ABORT in the SCTP packet or they will
        be ignored by\n   the receiver.\n   If an endpoint receives an ABORT with
        a format error or no TCB is\n   found, it MUST silently discard it.  Moreover,
        under any\n   circumstances, an endpoint that receives an ABORT MUST NOT respond
        to\n   that ABORT by sending an ABORT of its own.\n        0                   1
        \                  2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1
        2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |   Type = 6    |Reserved     |T|           Length              |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      \\                                                               \\\n
        \      /                   zero or more Error Causes                   /\n
        \      \\                                                               \\\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Chunk Flags: 8 bits\n      Reserved: 7 bits\n      Set to 0 on transmit
        and ignored on receipt.\n      T bit: 1 bit\n      The T bit is set to 0 if
        the sender filled in the Verification Tag\n      expected by the peer.  If
        the Verification Tag is reflected, the T\n      bit MUST be set to 1.  Reflecting
        means that the sent Verification\n      Tag is the same as the received one.\n
        \     Note: Special rules apply to this chunk for verification; please\n      see
        Section 8.5.1 for details.\n   Length: 16 bits (unsigned integer)\n      Set
        to the size of the chunk in bytes, including the chunk header\n      and all
        the Error Cause fields present.\n      See Section 3.3.10 for Error Cause
        definitions.\n"
      title: 3.3.7.  Abort Association (ABORT) (6)
    - contents:
      - "3.3.8.  Shutdown Association (SHUTDOWN) (7)\n   An endpoint in an association
        MUST use this chunk to initiate a\n   graceful close of the association with
        its peer.  This chunk has the\n   following format.\n        0                   1
        \                  2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1
        2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |   Type = 7    | Chunk  Flags  |      Length = 8               |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |                      Cumulative TSN Ack                       |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Chunk Flags: 8 bits\n      Set to 0 on transmit and ignored on receipt.\n
        \  Length: 16 bits (unsigned integer)\n      Indicates the length of the parameter.
        \ Set to 8.\n   Cumulative TSN Ack: 32 bits (unsigned integer)\n      This
        parameter contains the TSN of the last chunk received in\n      sequence before
        any gaps.\n      Note: Since the SHUTDOWN message does not contain Gap Ack
        Blocks,\n      it cannot be used to acknowledge TSNs received out of order.
        \ In a\n      SACK, lack of Gap Ack Blocks that were previously included\n
        \     indicates that the data receiver reneged on the associated DATA\n      chunks.
        \ Since SHUTDOWN does not contain Gap Ack Blocks, the\n      receiver of the
        SHUTDOWN shouldn't interpret the lack of a Gap Ack\n      Block as a renege.
        \ (See Section 6.2 for information on reneging.)\n"
      title: 3.3.8.  Shutdown Association (SHUTDOWN) (7)
    - contents:
      - "3.3.9.  Shutdown Acknowledgement (SHUTDOWN ACK) (8)\n   This chunk MUST be
        used to acknowledge the receipt of the SHUTDOWN\n   chunk at the completion
        of the shutdown process; see Section 9.2 for\n   details.\n   The SHUTDOWN
        ACK chunk has no parameters.\n        0                   1                   2
        \                  3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |   Type = 8    |Chunk  Flags   |      Length = 4               |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Chunk Flags: 8 bits\n      Set to 0 on transmit and ignored on receipt.\n"
      title: 3.3.9.  Shutdown Acknowledgement (SHUTDOWN ACK) (8)
    - contents:
      - "3.3.10.  Operation Error (ERROR) (9)\n   An endpoint sends this chunk to
        its peer endpoint to notify it of\n   certain error conditions.  It contains
        one or more error causes.  An\n   Operation Error is not considered fatal
        in and of itself, but may be\n   used with an ABORT chunk to report a fatal
        condition.  It has the\n   following parameters:\n        0                   1
        \                  2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1
        2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |   Type = 9    | Chunk  Flags  |           Length              |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      \\                                                               \\\n
        \      /                    one or more Error Causes                   /\n
        \      \\                                                               \\\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Chunk Flags: 8 bits\n      Set to 0 on transmit and ignored on receipt.\n
        \  Length: 16 bits (unsigned integer)\n      Set to the size of the chunk
        in bytes, including the chunk header\n      and all the Error Cause fields
        present.\n   Error causes are defined as variable-length parameters using
        the\n   format described in Section 3.2.1, that is:\n        0                   1
        \                  2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1
        2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |           Cause Code          |       Cause Length            |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      /                    Cause-Specific Information                 /\n
        \      \\                                                               \\\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Cause Code: 16 bits (unsigned integer)\n      Defines the type of error
        conditions being reported.\n         Cause Code\n         Value           Cause
        Code\n         ---------      ----------------\n          1              Invalid
        Stream Identifier\n          2              Missing Mandatory Parameter\n
        \         3              Stale Cookie Error\n          4              Out
        of Resource\n          5              Unresolvable Address\n          6              Unrecognized
        Chunk Type\n          7              Invalid Mandatory Parameter\n          8
        \             Unrecognized Parameters\n          9              No User Data\n
        \        10              Cookie Received While Shutting Down\n         11
        \             Restart of an Association with New Addresses\n         12              User
        Initiated Abort\n         13              Protocol Violation\n   Cause Length:
        16 bits (unsigned integer)\n      Set to the size of the parameter in bytes,
        including the Cause\n      Code, Cause Length, and Cause-Specific Information
        fields.\n   Cause-Specific Information: variable length\n      This field
        carries the details of the error condition.\n   Section 3.3.10.1 - Section
        3.3.10.13 define error causes for SCTP.\n   Guidelines for the IETF to define
        new error cause values are\n   discussed in Section 14.3.\n"
      - contents:
        - "3.3.10.1.  Invalid Stream Identifier (1)\n   Cause of error\n   ---------------\n
          \  Invalid Stream Identifier: Indicates endpoint received a DATA chunk\n
          \  sent to a nonexistent stream.\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \      |     Cause Code=1              |      Cause Length=8           |\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \      |        Stream Identifier      |         (Reserved)            |\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  Stream Identifier: 16 bits (unsigned integer)\n      Contains the Stream
          Identifier of the DATA chunk received in\n      error.\n   Reserved: 16
          bits\n      This field is reserved.  It is set to all 0's on transmit and\n
          \     ignored on receipt.\n"
        title: 3.3.10.1.  Invalid Stream Identifier (1)
      - contents:
        - "3.3.10.2.  Missing Mandatory Parameter (2)\n   Cause of error\n   ---------------\n
          \  Missing Mandatory Parameter: Indicates that one or more mandatory TLV\n
          \  parameters are missing in a received INIT or INIT ACK.\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \      |     Cause Code=2              |      Cause Length=8+N*2       |\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \      |                   Number of missing params=N                  |\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \      |   Missing Param Type #1       |   Missing Param Type #2       |\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \      |   Missing Param Type #N-1     |   Missing Param Type #N       |\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  Number of Missing params: 32 bits (unsigned integer)\n      This field
          contains the number of parameters contained in the\n      Cause-Specific
          Information field.\n   Missing Param Type: 16 bits (unsigned integer)\n
          \     Each field will contain the missing mandatory parameter number.\n"
        title: 3.3.10.2.  Missing Mandatory Parameter (2)
      - contents:
        - "3.3.10.3.  Stale Cookie Error (3)\n   Cause of error\n   --------------\n
          \  Stale Cookie Error: Indicates the receipt of a valid State Cookie\n   that
          has expired.\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \      |     Cause Code=3              |       Cause Length=8          |\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \      |                 Measure of Staleness (usec.)                  |\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  Measure of Staleness: 32 bits (unsigned integer)\n      This field contains
          the difference, in microseconds, between the\n      current time and the
          time the State Cookie expired.\n      The sender of this error cause MAY
          choose to report how long past\n      expiration the State Cookie is by
          including a non-zero value in\n      the Measure of Staleness field.  If
          the sender does not wish to\n      provide this information, it should set
          the Measure of Staleness\n      field to the value of zero.\n"
        title: 3.3.10.3.  Stale Cookie Error (3)
      - contents:
        - "3.3.10.4.  Out of Resource (4)\n   Cause of error\n   ---------------\n
          \  Out of Resource: Indicates that the sender is out of resource.  This\n
          \  is usually sent in combination with or within an ABORT.\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \      |     Cause Code=4              |      Cause Length=4           |\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
        title: 3.3.10.4.  Out of Resource (4)
      - contents:
        - "3.3.10.5.  Unresolvable Address (5)\n   Cause of error\n   ---------------\n
          \  Unresolvable Address: Indicates that the sender is not able to\n   resolve
          the specified address parameter (e.g., type of address is not\n   supported
          by the sender).  This is usually sent in combination with\n   or within
          an ABORT.\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \      |     Cause Code=5              |      Cause Length             |\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \      /                  Unresolvable Address                         /\n
          \      \\                                                               \\\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  Unresolvable Address: variable length\n      The Unresolvable Address
          field contains the complete Type, Length,\n      and Value of the address
          parameter (or Host Name parameter) that\n      contains the unresolvable
          address or host name.\n"
        title: 3.3.10.5.  Unresolvable Address (5)
      - contents:
        - "3.3.10.6.  Unrecognized Chunk Type (6)\n   Cause of error\n   ---------------\n
          \  Unrecognized Chunk Type: This error cause is returned to the\n   originator
          of the chunk if the receiver does not understand the chunk\n   and the upper
          bits of the 'Chunk Type' are set to 01 or 11.\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \      |     Cause Code=6              |      Cause Length             |\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \      /                  Unrecognized Chunk                           /\n
          \      \\                                                               \\\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  Unrecognized Chunk: variable length\n      The Unrecognized Chunk field
          contains the unrecognized chunk from\n      the SCTP packet complete with
          Chunk Type, Chunk Flags, and Chunk\n      Length.\n"
        title: 3.3.10.6.  Unrecognized Chunk Type (6)
      - contents:
        - "3.3.10.7.  Invalid Mandatory Parameter (7)\n   Cause of error\n   ---------------\n
          \  Invalid Mandatory Parameter: This error cause is returned to the\n   originator
          of an INIT or INIT ACK chunk when one of the mandatory\n   parameters is
          set to an invalid value.\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \      |     Cause Code=7              |      Cause Length=4           |\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
        title: 3.3.10.7.  Invalid Mandatory Parameter (7)
      - contents:
        - "3.3.10.8.  Unrecognized Parameters (8)\n   Cause of error\n   ---------------\n
          \  Unrecognized Parameters: This error cause is returned to the\n   originator
          of the INIT ACK chunk if the receiver does not recognize\n   one or more
          Optional TLV parameters in the INIT ACK chunk.\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \      |     Cause Code=8              |      Cause Length             |\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \      /                  Unrecognized Parameters                      /\n
          \      \\                                                               \\\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  Unrecognized Parameters: variable length\n      The Unrecognized Parameters
          field contains the unrecognized\n      parameters copied from the INIT ACK
          chunk complete with TLV.  This\n      error cause is normally contained
          in an ERROR chunk bundled with\n      the COOKIE ECHO chunk when responding
          to the INIT ACK, when the\n      sender of the COOKIE ECHO chunk wishes
          to report unrecognized\n      parameters.\n"
        title: 3.3.10.8.  Unrecognized Parameters (8)
      - contents:
        - "3.3.10.9.  No User Data (9)\n   Cause of error\n   ---------------\n   No
          User Data: This error cause is returned to the originator of a\n   DATA
          chunk if a received DATA chunk has no user data.\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \      |     Cause Code=9              |      Cause Length=8           |\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \      /                  TSN value                                    /\n
          \      \\                                                               \\\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  TSN value: 32 bits (unsigned integer)\n      The TSN value field contains
          the TSN of the DATA chunk received\n      with no user data field.\n      This
          cause code is normally returned in an ABORT chunk (see\n      Section 6.2).\n"
        title: 3.3.10.9.  No User Data (9)
      - contents:
        - "3.3.10.10.  Cookie Received While Shutting Down (10)\n   Cause of error\n
          \  ---------------\n   Cookie Received While Shutting Down: A COOKIE ECHO
          was received while\n   the endpoint was in the SHUTDOWN-ACK-SENT state.
          \ This error is\n   usually returned in an ERROR chunk bundled with the
          retransmitted\n   SHUTDOWN ACK.\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \      |     Cause Code=10              |      Cause Length=4          |\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
        title: 3.3.10.10.  Cookie Received While Shutting Down (10)
      - contents:
        - "3.3.10.11.  Restart of an Association with New Addresses (11)\n   Cause
          of error\n   --------------\n   Restart of an association with new addresses:
          An INIT was received on\n   an existing association.  But the INIT added
          addresses to the\n   association that were previously NOT part of the association.
          \ The\n   new addresses are listed in the error code.  This ERROR is normally\n
          \  sent as part of an ABORT refusing the INIT (see Section 5.2).\n        0
          \                  1                   2                   3\n        0
          1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \      |         Cause Code=11         |      Cause Length=Variable    |\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \      /                       New Address TLVs                        /\n
          \      \\                                                               \\\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  Note: Each New Address TLV is an exact copy of the TLV that was found\n
          \  in the INIT chunk that was new, including the Parameter Type and the\n
          \  Parameter Length.\n"
        title: 3.3.10.11.  Restart of an Association with New Addresses (11)
      - contents:
        - "3.3.10.12.  User-Initiated Abort (12)\n   Cause of error\n   --------------\n
          \  This error cause MAY be included in ABORT chunks that are sent\n   because
          of an upper-layer request.  The upper layer can specify an\n   Upper Layer
          Abort Reason that is transported by SCTP transparently\n   and MAY be delivered
          to the upper-layer protocol at the peer.\n        0                   1
          \                  2                   3\n        0 1 2 3 4 5 6 7 8 9 0
          1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \      |         Cause Code=12         |      Cause Length=Variable    |\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \      /                    Upper Layer Abort Reason                   /\n
          \      \\                                                               \\\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
        title: 3.3.10.12.  User-Initiated Abort (12)
      - contents:
        - "3.3.10.13.  Protocol Violation (13)\n   Cause of error\n   --------------\n
          \  This error cause MAY be included in ABORT chunks that are sent\n   because
          an SCTP endpoint detects a protocol violation of the peer\n   that is not
          covered by the error causes described in Section 3.3.10.1\n   to Section
          3.3.10.12.  An implementation MAY provide additional\n   information specifying
          what kind of protocol violation has been\n   detected.\n        0                   1
          \                  2                   3\n        0 1 2 3 4 5 6 7 8 9 0
          1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \      |         Cause Code=13         |      Cause Length=Variable    |\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \      /                    Additional Information                     /\n
          \      \\                                                               \\\n
          \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
        title: 3.3.10.13.  Protocol Violation (13)
      title: 3.3.10.  Operation Error (ERROR) (9)
    - contents:
      - "3.3.11.  Cookie Echo (COOKIE ECHO) (10)\n   This chunk is used only during
        the initialization of an association.\n   It is sent by the initiator of an
        association to its peer to complete\n   the initialization process.  This
        chunk MUST precede any DATA chunk\n   sent within the association, but MAY
        be bundled with one or more DATA\n   chunks in the same packet.\n        0
        \                  1                   2                   3\n        0 1
        2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |   Type = 10   |Chunk  Flags   |         Length                |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      /                     Cookie                                    /\n
        \      \\                                                               \\\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Chunk Flags: 8 bit\n      Set to 0 on transmit and ignored on receipt.\n
        \  Length: 16 bits (unsigned integer)\n      Set to the size of the chunk
        in bytes, including the 4 bytes of\n      the chunk header and the size of
        the cookie.\n   Cookie: variable size\n      This field must contain the exact
        cookie received in the State\n      Cookie parameter from the previous INIT
        ACK.\n      An implementation SHOULD make the cookie as small as possible
        to\n      ensure interoperability.\n      Note: A Cookie Echo does NOT contain
        a State Cookie parameter;\n      instead, the data within the State Cookie's
        Parameter Value\n      becomes the data within the Cookie Echo's Chunk Value.
        \ This\n      allows an implementation to change only the first 2 bytes of
        the\n      State Cookie parameter to become a COOKIE ECHO chunk.\n"
      title: 3.3.11.  Cookie Echo (COOKIE ECHO) (10)
    - contents:
      - "3.3.12.  Cookie Acknowledgement (COOKIE ACK) (11)\n   This chunk is used
        only during the initialization of an association.\n   It is used to acknowledge
        the receipt of a COOKIE ECHO chunk.  This\n   chunk MUST precede any DATA
        or SACK chunk sent within the\n   association, but MAY be bundled with one
        or more DATA chunks or SACK\n   chunk's in the same SCTP packet.\n        0
        \                  1                   2                   3\n        0 1
        2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |   Type = 11   |Chunk  Flags   |     Length = 4                |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Chunk Flags: 8 bits\n      Set to 0 on transmit and ignored on receipt.\n"
      title: 3.3.12.  Cookie Acknowledgement (COOKIE ACK) (11)
    - contents:
      - "3.3.13.  Shutdown Complete (SHUTDOWN COMPLETE) (14)\n   This chunk MUST be
        used to acknowledge the receipt of the SHUTDOWN\n   ACK chunk at the completion
        of the shutdown process; see Section 9.2\n   for details.\n   The SHUTDOWN
        COMPLETE chunk has no parameters.\n        0                   1                   2
        \                  3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |   Type = 14   |Reserved     |T|      Length = 4               |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Chunk Flags: 8 bits\n      Reserved: 7 bits\n         Set to 0 on transmit
        and ignored on receipt.\n         T bit: 1 bit\n      The T bit is set to
        0 if the sender filled in the Verification Tag\n      expected by the peer.
        \ If the Verification Tag is reflected, the T\n      bit MUST be set to 1.
        \ Reflecting means that the sent Verification\n      Tag is the same as the
        received one.\n   Note: Special rules apply to this chunk for verification,
        please see\n   Section 8.5.1 for details.\n"
      title: 3.3.13.  Shutdown Complete (SHUTDOWN COMPLETE) (14)
    title: 3.3.  SCTP Chunk Definitions
  title: 3.  SCTP Packet Format
- contents:
  - "4.  SCTP Association State Diagram\n   During the life time of an SCTP association,
    the SCTP endpoint's\n   association progresses from one state to another in response
    to\n   various events.  The events that may potentially advance an\n   association's
    state include:\n   o  SCTP user primitive calls, e.g., [ASSOCIATE], [SHUTDOWN],
    [ABORT],\n   o  Reception of INIT, COOKIE ECHO, ABORT, SHUTDOWN, etc., control\n
    \     chunks, or\n   o  Some timeout events.\n   The state diagram in the figures
    below illustrates state changes,\n   together with the causing events and resulting
    actions.  Note that\n   some of the error conditions are not shown in the state
    diagram.\n   Full descriptions of all special cases are found in the text.\n   Note:
    Chunk names are given in all capital letters, while parameter\n   names have the
    first letter capitalized, e.g., COOKIE ECHO chunk type\n   vs. State Cookie parameter.
    \ If more than one event/message can occur\n   that causes a state transition,
    it is labeled (A), (B), etc.\n                      -----          -------- (from
    any state)\n                    /       \\      /  rcv ABORT      [ABORT]\n   rcv
    INIT        |         |    |   ----------  or ----------\n   --------------- |
    \        v    v   delete TCB     snd ABORT\n   generate Cookie  \\    +---------+
    \                delete TCB\n   snd INIT ACK       ---|  CLOSED |\n                         +---------+\n
    \                         /      \\      [ASSOCIATE]\n                         /
    \       \\     ---------------\n                        |          |    create
    TCB\n                        |          |    snd INIT\n                        |
    \         |    strt init timer\n         rcv valid      |          |\n       COOKIE
    \ ECHO     |          v\n   (1) ---------------- |      +------------+\n       create
    TCB       |      | COOKIE-WAIT| (2)\n       snd COOKIE ACK   |      +------------+\n
    \                       |          |\n                        |          |    rcv
    INIT ACK\n                        |          |    -----------------\n                        |
    \         |    snd COOKIE ECHO\n                        |          |    stop init
    timer\n                        |          |    strt cookie timer\n                        |
    \         v\n                        |      +--------------+\n                        |
    \     | COOKIE-ECHOED| (3)\n                        |      +--------------+\n
    \                       |          |\n                        |          |    rcv
    COOKIE ACK\n                        |          |    -----------------\n                        |
    \         |    stop cookie timer\n                        v          v\n                      +---------------+\n
    \                     |  ESTABLISHED  |\n                      +---------------+\n
    \                   (from the ESTABLISHED state only)\n                                  |\n
    \                                 |\n                         /--------+--------\\\n
    \    [SHUTDOWN]         /                   \\\n     -------------------|                   |\n
    \    check outstanding  |                   |\n     DATA chunks        |                   |\n
    \                       v                   |\n                   +---------+
    \             |\n                   |SHUTDOWN-|              | rcv SHUTDOWN\n
    \                  |PENDING  |              |------------------\n                   +---------+
    \             | check outstanding\n                        |                   |
    DATA chunks\n   No more outstanding  |                   |\n   ---------------------|
    \                  |\n   snd SHUTDOWN         |                   |\n   strt shutdown
    timer  |                   |\n                        v                   v\n
    \                  +---------+        +-----------+\n               (4) |SHUTDOWN-|
    \       | SHUTDOWN- |  (5,6)\n                   |SENT     |        | RECEIVED
    \ |\n                   +---------+        +-----------+\n                        |
    \ \\                |\n   (A) rcv SHUTDOWN ACK  |   \\               |\n   ----------------------|
    \   \\              |\n   stop shutdown timer   |     \\rcv:SHUTDOWN |\n   send
    SHUTDOWN COMPLETE|      \\  (B)       |\n   delete TCB            |       \\           |\n
    \                        |        \\          | No more outstanding\n                         |
    \        \\         |-----------------\n                         |          \\
    \       | send SHUTDOWN ACK\n   (B)rcv SHUTDOWN       |           \\       | strt
    shutdown timer\n   ----------------------|            \\      |\n   send SHUTDOWN
    ACK     |             \\     |\n   start shutdown timer  |              \\    |\n
    \  move to SHUTDOWN-     |               \\   |\n   ACK-SENT              |                |
    \ |\n                         |                v  |\n                         |
    \            +-----------+\n                         |             | SHUTDOWN-
    | (7)\n                         |             | ACK-SENT  |\n                         |
    \            +----------+-\n                         |                   | (C)rcv
    SHUTDOWN COMPLETE\n                         |                   |-----------------\n
    \                        |                   | stop shutdown timer\n                         |
    \                  | delete TCB\n                         |                   |\n
    \                        |                   | (D)rcv SHUTDOWN ACK\n                         |
    \                  |--------------\n                         |                   |
    stop shutdown timer\n                         |                   | send SHUTDOWN
    COMPLETE\n                         |                   | delete TCB\n                         |
    \                  |\n                         \\    +---------+    /\n                          \\-->|
    CLOSED  |<--/\n                              +---------+\n                Figure
    3: State Transition Diagram of SCTP\n   Notes:\n   1)  If the State Cookie in
    the received COOKIE ECHO is invalid (i.e.,\n       failed to pass the integrity
    check), the receiver MUST silently\n       discard the packet.  Or, if the received
    State Cookie is expired\n       (see Section 5.1.5), the receiver MUST send back
    an ERROR chunk.\n       In either case, the receiver stays in the CLOSED state.\n
    \  2)  If the T1-init timer expires, the endpoint MUST retransmit INIT\n       and
    restart the T1-init timer without changing state.  This MUST\n       be repeated
    up to 'Max.Init.Retransmits' times.  After that, the\n       endpoint MUST abort
    the initialization process and report the\n       error to the SCTP user.\n   3)
    \ If the T1-cookie timer expires, the endpoint MUST retransmit\n       COOKIE
    ECHO and restart the T1-cookie timer without changing\n       state.  This MUST
    be repeated up to 'Max.Init.Retransmits' times.\n       After that, the endpoint
    MUST abort the initialization process\n       and report the error to the SCTP
    user.\n   4)  In the SHUTDOWN-SENT state, the endpoint MUST acknowledge any\n
    \      received DATA chunks without delay.\n   5)  In the SHUTDOWN-RECEIVED state,
    the endpoint MUST NOT accept any\n       new send requests from its SCTP user.\n
    \  6)  In the SHUTDOWN-RECEIVED state, the endpoint MUST transmit or\n       retransmit
    data and leave this state when all data in queue is\n       transmitted.\n   7)
    \ In the SHUTDOWN-ACK-SENT state, the endpoint MUST NOT accept any\n       new
    send requests from its SCTP user.\n   The CLOSED state is used to indicate that
    an association is not\n   created (i.e., doesn't exist).\n"
  title: 4.  SCTP Association State Diagram
- contents:
  - "5.  Association Initialization\n   Before the first data transmission can take
    place from one SCTP\n   endpoint (\"A\") to another SCTP endpoint (\"Z\"), the
    two endpoints must\n   complete an initialization process in order to set up an
    SCTP\n   association between them.\n   The SCTP user at an endpoint should use
    the ASSOCIATE primitive to\n   initialize an SCTP association to another SCTP
    endpoint.\n   IMPLEMENTATION NOTE: From an SCTP user's point of view, an\n   association
    may be implicitly opened, without an ASSOCIATE primitive\n   (see Section 10.1
    B) being invoked, by the initiating endpoint's\n   sending of the first user data
    to the destination endpoint.  The\n   initiating SCTP will assume default values
    for all mandatory and\n   optional parameters for the INIT/INIT ACK.\n   Once
    the association is established, unidirectional streams are open\n   for data transfer
    on both ends (see Section 5.1.1).\n"
  - contents:
    - "5.1.  Normal Establishment of an Association\n   The initialization process
      consists of the following steps (assuming\n   that SCTP endpoint \"A\" tries
      to set up an association with SCTP\n   endpoint \"Z\" and \"Z\" accepts the
      new association):\n   A) \"A\" first sends an INIT chunk to \"Z\".  In the INIT,
      \"A\" must\n      provide its Verification Tag (Tag_A) in the Initiate Tag field.\n
      \     Tag_A SHOULD be a random number in the range of 1 to 4294967295\n      (see
      Section 5.3.1 for Tag value selection).  After sending the\n      INIT, \"A\"
      starts the T1-init timer and enters the COOKIE-WAIT\n      state.\n   B) \"Z\"
      shall respond immediately with an INIT ACK chunk.  The\n      destination IP
      address of the INIT ACK MUST be set to the source\n      IP address of the INIT
      to which this INIT ACK is responding.  In\n      the response, besides filling
      in other parameters, \"Z\" must set\n      the Verification Tag field to Tag_A,
      and also provide its own\n      Verification Tag (Tag_Z) in the Initiate Tag
      field.\n      Moreover, \"Z\" MUST generate and send along with the INIT ACK
      a\n      State Cookie.  See Section 5.1.3 for State Cookie generation.\n      Note:
      After sending out INIT ACK with the State Cookie parameter,\n      \"Z\" MUST
      NOT allocate any resources or keep any states for the new\n      association.
      \ Otherwise, \"Z\" will be vulnerable to resource\n      attacks.\n   C) Upon
      reception of the INIT ACK from \"Z\", \"A\" shall stop the T1-\n      init timer
      and leave the COOKIE-WAIT state.  \"A\" shall then send\n      the State Cookie
      received in the INIT ACK chunk in a COOKIE ECHO\n      chunk, start the T1-cookie
      timer, and enter the COOKIE-ECHOED\n      state.\n      Note: The COOKIE ECHO
      chunk can be bundled with any pending\n      outbound DATA chunks, but it MUST
      be the first chunk in the packet\n      and until the COOKIE ACK is returned
      the sender MUST NOT send any\n      other packets to the peer.\n   D) Upon reception
      of the COOKIE ECHO chunk, endpoint \"Z\" will reply\n      with a COOKIE ACK
      chunk after building a TCB and moving to the\n      ESTABLISHED state.  A COOKIE
      ACK chunk may be bundled with any\n      pending DATA chunks (and/or SACK chunks),
      but the COOKIE ACK chunk\n      MUST be the first chunk in the packet.\n      IMPLEMENTATION
      NOTE: An implementation may choose to send the\n      Communication Up notification
      to the SCTP user upon reception of a\n      valid COOKIE ECHO chunk.\n   E)
      Upon reception of the COOKIE ACK, endpoint \"A\" will move from the\n      COOKIE-ECHOED
      state to the ESTABLISHED state, stopping the T1-\n      cookie timer.  It may
      also notify its ULP about the successful\n      establishment of the association
      with a Communication Up\n      notification (see Section 10).\n   An INIT or
      INIT ACK chunk MUST NOT be bundled with any other chunk.\n   They MUST be the
      only chunks present in the SCTP packets that carry\n   them.\n   An endpoint
      MUST send the INIT ACK to the IP address from which it\n   received the INIT.\n
      \  Note: T1-init timer and T1-cookie timer shall follow the same rules\n   given
      in Section 6.3.\n   If an endpoint receives an INIT, INIT ACK, or COOKIE ECHO
      chunk but\n   decides not to establish the new association due to missing mandatory\n
      \  parameters in the received INIT or INIT ACK, invalid parameter\n   values,
      or lack of local resources, it SHOULD respond with an ABORT\n   chunk.  It SHOULD
      also specify the cause of abort, such as the type\n   of the missing mandatory
      parameters, etc., by including the error\n   cause parameters with the ABORT
      chunk.  The Verification Tag field in\n   the common header of the outbound
      SCTP packet containing the ABORT\n   chunk MUST be set to the Initiate Tag value
      of the peer.\n   Note that a COOKIE ECHO chunk that does NOT pass the integrity
      check\n   is NOT considered an 'invalid parameter' and requires special\n   handling;
      see Section 5.1.5.\n   After the reception of the first DATA chunk in an association
      the\n   endpoint MUST immediately respond with a SACK to acknowledge the DATA\n
      \  chunk.  Subsequent acknowledgements should be done as described in\n   Section
      6.2.\n   When the TCB is created, each endpoint MUST set its internal\n   Cumulative
      TSN Ack Point to the value of its transmitted Initial TSN\n   minus one.\n   IMPLEMENTATION
      NOTE: The IP addresses and SCTP port are generally\n   used as the key to find
      the TCB within an SCTP instance.\n"
    - contents:
      - "5.1.1.  Handle Stream Parameters\n   In the INIT and INIT ACK chunks, the
        sender of the chunk MUST\n   indicate the number of outbound streams (OSs)
        it wishes to have in\n   the association, as well as the maximum inbound streams
        (MISs) it\n   will accept from the other endpoint.\n   After receiving the
        stream configuration information from the other\n   side, each endpoint MUST
        perform the following check: If the peer's\n   MIS is less than the endpoint's
        OS, meaning that the peer is\n   incapable of supporting all the outbound
        streams the endpoint wants\n   to configure, the endpoint MUST use MIS outbound
        streams and MAY\n   report any shortage to the upper layer.  The upper layer
        can then\n   choose to abort the association if the resource shortage is\n
        \  unacceptable.\n   After the association is initialized, the valid outbound
        stream\n   identifier range for either endpoint shall be 0 to min(local OS,\n
        \  remote MIS)-1.\n"
      title: 5.1.1.  Handle Stream Parameters
    - contents:
      - "5.1.2.  Handle Address Parameters\n   During the association initialization,
        an endpoint shall use the\n   following rules to discover and collect the
        destination transport\n   address(es) of its peer.\n   A) If there are no
        address parameters present in the received INIT or\n      INIT ACK chunk,
        the endpoint shall take the source IP address from\n      which the chunk
        arrives and record it, in combination with the\n      SCTP source port number,
        as the only destination transport address\n      for this peer.\n   B) If
        there is a Host Name parameter present in the received INIT or\n      INIT
        ACK chunk, the endpoint shall resolve that host name to a\n      list of IP
        address(es) and derive the transport address(es) of\n      this peer by combining
        the resolved IP address(es) with the SCTP\n      source port.\n      The endpoint
        MUST ignore any other IP Address parameters if they\n      are also present
        in the received INIT or INIT ACK chunk.\n      The time at which the receiver
        of an INIT resolves the host name\n      has potential security implications
        to SCTP.  If the receiver of\n      an INIT resolves the host name upon the
        reception of the chunk,\n      and the mechanism the receiver uses to resolve
        the host name\n      involves potential long delay (e.g., DNS query), the
        receiver may\n      open itself up to resource attacks for the period of time
        while it\n      is waiting for the name resolution results before it can build
        the\n      State Cookie and release local resources.\n      Therefore, in
        cases where the name translation involves potential\n      long delay, the
        receiver of the INIT MUST postpone the name\n      resolution till the reception
        of the COOKIE ECHO chunk from the\n      peer.  In such a case, the receiver
        of the INIT SHOULD build the\n      State Cookie using the received Host Name
        (instead of destination\n      transport addresses) and send the INIT ACK
        to the source IP\n      address from which the INIT was received.\n      The
        receiver of an INIT ACK shall always immediately attempt to\n      resolve
        the name upon the reception of the chunk.\n      The receiver of the INIT
        or INIT ACK MUST NOT send user data\n      (piggy-backed or stand-alone) to
        its peer until the host name is\n      successfully resolved.\n      If the
        name resolution is not successful, the endpoint MUST\n      immediately send
        an ABORT with \"Unresolvable Address\" error cause\n      to its peer.  The
        ABORT shall be sent to the source IP address\n      from which the last peer
        packet was received.\n   C) If there are only IPv4/IPv6 addresses present
        in the received INIT\n      or INIT ACK chunk, the receiver MUST derive and
        record all the\n      transport addresses from the received chunk AND the
        source IP\n      address that sent the INIT or INIT ACK.  The transport addresses\n
        \     are derived by the combination of SCTP source port (from the\n      common
        header) and the IP Address parameter(s) carried in the INIT\n      or INIT
        ACK chunk and the source IP address of the IP datagram.\n      The receiver
        should use only these transport addresses as\n      destination transport
        addresses when sending subsequent packets to\n      its peer.\n   D) An INIT
        or INIT ACK chunk MUST be treated as belonging to an\n      already established
        association (or one in the process of being\n      established) if the use
        of any of the valid address parameters\n      contained within the chunk would
        identify an existing TCB.\n   IMPLEMENTATION NOTE: In some cases (e.g., when
        the implementation\n   doesn't control the source IP address that is used
        for transmitting),\n   an endpoint might need to include in its INIT or INIT
        ACK all\n   possible IP addresses from which packets to the peer could be\n
        \  transmitted.\n   After all transport addresses are derived from the INIT
        or INIT ACK\n   chunk using the above rules, the endpoint shall select one
        of the\n   transport addresses as the initial primary path.\n   Note: The
        INIT ACK MUST be sent to the source address of the INIT.\n   The sender of
        INIT may include a 'Supported Address Types' parameter\n   in the INIT to
        indicate what types of address are acceptable.  When\n   this parameter is
        present, the receiver of INIT (initiate) MUST\n   either use one of the address
        types indicated in the Supported\n   Address Types parameter when responding
        to the INIT, or abort the\n   association with an \"Unresolvable Address\"
        error cause if it is\n   unwilling or incapable of using any of the address
        types indicated by\n   its peer.\n   IMPLEMENTATION NOTE: In the case that
        the receiver of an INIT ACK\n   fails to resolve the address parameter due
        to an unsupported type, it\n   can abort the initiation process and then attempt
        a reinitiation by\n   using a 'Supported Address Types' parameter in the new
        INIT to\n   indicate what types of address it prefers.\n   IMPLEMENTATION
        NOTE: If an SCTP endpoint that only supports either\n   IPv4 or IPv6 receives
        IPv4 and IPv6 addresses in an INIT or INIT ACK\n   chunk from its peer, it
        MUST use all the addresses belonging to the\n   supported address family.
        \ The other addresses MAY be ignored.  The\n   endpoint SHOULD NOT respond
        with any kind of error indication.\n   IMPLEMENTATION NOTE: If an SCTP endpoint
        lists in the 'Supported\n   Address Types' parameter either IPv4 or IPv6,
        but uses the other\n   family for sending the packet containing the INIT chunk,
        or if it\n   also lists addresses of the other family in the INIT chunk, then
        the\n   address family that is not listed in the 'Supported Address Types'\n
        \  parameter SHOULD also be considered as supported by the receiver of\n   the
        INIT chunk.  The receiver of the INIT chunk SHOULD NOT respond\n   with any
        kind of error indication.\n"
      title: 5.1.2.  Handle Address Parameters
    - contents:
      - "5.1.3.  Generating State Cookie\n   When sending an INIT ACK as a response
        to an INIT chunk, the sender\n   of INIT ACK creates a State Cookie and sends
        it in the State Cookie\n   parameter of the INIT ACK.  Inside this State Cookie,
        the sender\n   should include a MAC (see [RFC2104] for an example), a timestamp
        on\n   when the State Cookie is created, and the lifespan of the State\n   Cookie,
        along with all the information necessary for it to establish\n   the association.\n
        \  The following steps SHOULD be taken to generate the State Cookie:\n   1)
        \ Create an association TCB using information from both the\n       received
        INIT and the outgoing INIT ACK chunk,\n   2)  In the TCB, set the creation
        time to the current time of day, and\n       the lifespan to the protocol
        parameter 'Valid.Cookie.Life' (see\n       Section 15),\n   3)  From the TCB,
        identify and collect the minimal subset of\n       information needed to re-create
        the TCB, and generate a MAC using\n       this subset of information and a
        secret key (see [RFC2104] for an\n       example of generating a MAC), and\n
        \  4)  Generate the State Cookie by combining this subset of information\n
        \      and the resultant MAC.\n   After sending the INIT ACK with the State
        Cookie parameter, the\n   sender SHOULD delete the TCB and any other local
        resource related to\n   the new association, so as to prevent resource attacks.\n
        \  The hashing method used to generate the MAC is strictly a private\n   matter
        for the receiver of the INIT chunk.  The use of a MAC is\n   mandatory to
        prevent denial-of-service attacks.  The secret key\n   SHOULD be random ([RFC4086]
        provides some information on randomness\n   guidelines); it SHOULD be changed
        reasonably frequently, and the\n   timestamp in the State Cookie MAY be used
        to determine which key\n   should be used to verify the MAC.\n   An implementation
        SHOULD make the cookie as small as possible to\n   ensure interoperability.\n"
      title: 5.1.3.  Generating State Cookie
    - contents:
      - "5.1.4.  State Cookie Processing\n   When an endpoint (in the COOKIE-WAIT
        state) receives an INIT ACK\n   chunk with a State Cookie parameter, it MUST
        immediately send a\n   COOKIE ECHO chunk to its peer with the received State
        Cookie.  The\n   sender MAY also add any pending DATA chunks to the packet
        after the\n   COOKIE ECHO chunk.\n   The endpoint shall also start the T1-cookie
        timer after sending out\n   the COOKIE ECHO chunk.  If the timer expires,
        the endpoint shall\n   retransmit the COOKIE ECHO chunk and restart the T1-cookie
        timer.\n   This is repeated until either a COOKIE ACK is received or\n   'Max.Init.Retransmits'
        (see Section 15) is reached causing the peer\n   endpoint to be marked unreachable
        (and thus the association enters\n   the CLOSED state).\n"
      title: 5.1.4.  State Cookie Processing
    - contents:
      - "5.1.5.  State Cookie Authentication\n   When an endpoint receives a COOKIE
        ECHO chunk from another endpoint\n   with which it has no association, it
        shall take the following\n   actions:\n   1)  Compute a MAC using the TCB
        data carried in the State Cookie and\n       the secret key (note the timestamp
        in the State Cookie MAY be\n       used to determine which secret key to use).
        \ [RFC2104] can be\n       used as a guideline for generating the MAC,\n   2)
        \ Authenticate the State Cookie as one that it previously generated\n       by
        comparing the computed MAC against the one carried in the\n       State Cookie.
        \ If this comparison fails, the SCTP packet,\n       including the COOKIE
        ECHO and any DATA chunks, should be silently\n       discarded,\n   3)  Compare
        the port numbers and the Verification Tag contained\n       within the COOKIE
        ECHO chunk to the actual port numbers and the\n       Verification Tag within
        the SCTP common header of the received\n       packet.  If these values do
        not match, the packet MUST be\n       silently discarded.\n   4)  Compare
        the creation timestamp in the State Cookie to the current\n       local time.
        \ If the elapsed time is longer than the lifespan\n       carried in the State
        Cookie, then the packet, including the\n       COOKIE ECHO and any attached
        DATA chunks, SHOULD be discarded,\n       and the endpoint MUST transmit an
        ERROR chunk with a \"Stale\n       Cookie\" error cause to the peer endpoint.\n
        \  5)  If the State Cookie is valid, create an association to the sender\n
        \      of the COOKIE ECHO chunk with the information in the TCB data\n       carried
        in the COOKIE ECHO and enter the ESTABLISHED state.\n   6)  Send a COOKIE
        ACK chunk to the peer acknowledging receipt of the\n       COOKIE ECHO.  The
        COOKIE ACK MAY be bundled with an outbound DATA\n       chunk or SACK chunk;
        however, the COOKIE ACK MUST be the first\n       chunk in the SCTP packet.\n
        \  7)  Immediately acknowledge any DATA chunk bundled with the COOKIE\n       ECHO
        with a SACK (subsequent DATA chunk acknowledgement should\n       follow the
        rules defined in Section 6.2).  As mentioned in step\n       6, if the SACK
        is bundled with the COOKIE ACK, the COOKIE ACK\n       MUST appear first in
        the SCTP packet.\n   If a COOKIE ECHO is received from an endpoint with which
        the receiver\n   of the COOKIE ECHO has an existing association, the procedures
        in\n   Section 5.2 should be followed.\n"
      title: 5.1.5.  State Cookie Authentication
    - contents:
      - "5.1.6.  An Example of Normal Association Establishment\n   In the following
        example, \"A\" initiates the association and then\n   sends a user message
        to \"Z\", then \"Z\" sends two user messages to \"A\"\n   later (assuming
        no bundling or fragmentation occurs):\n    Endpoint A                                          Endpoint
        Z\n    {app sets association with Z}\n    (build TCB)\n    INIT [I-Tag=Tag_A\n
        \         & other info]  ------\\\n    (Start T1-init timer)       \\\n    (Enter
        COOKIE-WAIT state)    \\---> (compose temp TCB and Cookie_Z)\n                                    /--
        INIT ACK [Veri Tag=Tag_A,\n                                   /             I-Tag=Tag_Z,\n
        \   (Cancel T1-init timer) <------/              Cookie_Z, & other info]\n
        \                                        (destroy temp TCB)\n    COOKIE ECHO
        [Cookie_Z] ------\\\n    (Start T1-init timer)         \\\n    (Enter COOKIE-ECHOED
        state)    \\---> (build TCB enter ESTABLISHED\n                                          state)\n
        \                                  /---- COOKIE-ACK\n                                  /\n
        \   (Cancel T1-init timer, <-----/\n     Enter ESTABLISHED state)\n    {app
        sends 1st user data; strm 0}\n    DATA [TSN=initial TSN_A\n        Strm=0,Seq=0
        & user data]--\\\n    (Start T3-rtx timer)            \\\n                                     \\->\n
        \                                  /----- SACK [TSN Ack=init\n                                  /
        \          TSN_A,Block=0]\n    (Cancel T3-rtx timer) <------/\n                                          ...\n
        \                                        {app sends 2 messages;strm 0}\n                                   /----
        DATA\n                                  /        [TSN=init TSN_Z\n                              <--/
        \         Strm=0,Seq=0 & user data 1]\n    SACK [TSN Ack=init TSN_Z,      /----
        DATA\n          Block=0]     --------\\  /        [TSN=init TSN_Z +1,\n                                \\/
        \         Strm=0,Seq=1 & user data 2]\n                         <------/\\\n
        \                                 \\\n                                   \\------>\n
        \                       Figure 4: INITIATION Example\n   If the T1-init timer
        expires at \"A\" after the INIT or COOKIE ECHO\n   chunks are sent, the same
        INIT or COOKIE ECHO chunk with the same\n   Initiate Tag (i.e., Tag_A) or
        State Cookie shall be retransmitted and\n   the timer restarted.  This shall
        be repeated Max.Init.Retransmits\n   times before \"A\" considers \"Z\" unreachable
        and reports the failure to\n   its upper layer (and thus the association enters
        the CLOSED state).\n   When retransmitting the INIT, the endpoint MUST follow
        the rules\n   defined in Section 6.3 to determine the proper timer value.\n"
      title: 5.1.6.  An Example of Normal Association Establishment
    title: 5.1.  Normal Establishment of an Association
  - contents:
    - "5.2.  Handle Duplicate or Unexpected INIT, INIT ACK, COOKIE ECHO, and\n      COOKIE
      ACK\n   During the life time of an association (in one of the possible\n   states),
      an endpoint may receive from its peer endpoint one of the\n   setup chunks (INIT,
      INIT ACK, COOKIE ECHO, and COOKIE ACK).  The\n   receiver shall treat such a
      setup chunk as a duplicate and process it\n   as described in this section.\n
      \  Note: An endpoint will not receive the chunk unless the chunk was\n   sent
      to an SCTP transport address and is from an SCTP transport\n   address associated
      with this endpoint.  Therefore, the endpoint\n   processes such a chunk as part
      of its current association.\n   The following scenarios can cause duplicated
      or unexpected chunks:\n   A) The peer has crashed without being detected, restarted
      itself, and\n      sent out a new INIT chunk trying to restore the association,\n
      \  B) Both sides are trying to initialize the association at about the\n      same
      time,\n   C) The chunk is from a stale packet that was used to establish the\n
      \     present association or a past association that is no longer in\n      existence,\n
      \  D) The chunk is a false packet generated by an attacker, or\n   E) The peer
      never received the COOKIE ACK and is retransmitting its\n      COOKIE ECHO.\n
      \  The rules in the following sections shall be applied in order to\n   identify
      and correctly handle these cases.\n"
    - contents:
      - "5.2.1.  INIT Received in COOKIE-WAIT or COOKIE-ECHOED State (Item B)\n   This
        usually indicates an initialization collision, i.e., each\n   endpoint is
        attempting, at about the same time, to establish an\n   association with the
        other endpoint.\n   Upon receipt of an INIT in the COOKIE-WAIT state, an endpoint
        MUST\n   respond with an INIT ACK using the same parameters it sent in its\n
        \  original INIT chunk (including its Initiate Tag, unchanged).  When\n   responding,
        the endpoint MUST send the INIT ACK back to the same\n   address that the
        original INIT (sent by this endpoint) was sent.\n   Upon receipt of an INIT
        in the COOKIE-ECHOED state, an endpoint MUST\n   respond with an INIT ACK
        using the same parameters it sent in its\n   original INIT chunk (including
        its Initiate Tag, unchanged), provided\n   that no NEW address has been added
        to the forming association.  If\n   the INIT message indicates that a new
        address has been added to the\n   association, then the entire INIT MUST be
        discarded, and NO changes\n   should be made to the existing association.
        \ An ABORT SHOULD be sent\n   in response that MAY include the error 'Restart
        of an association\n   with new addresses'.  The error SHOULD list the addresses
        that were\n   added to the restarting association.\n   When responding in
        either state (COOKIE-WAIT or COOKIE-ECHOED) with\n   an INIT ACK, the original
        parameters are combined with those from the\n   newly received INIT chunk.
        \ The endpoint shall also generate a State\n   Cookie with the INIT ACK.  The
        endpoint uses the parameters sent in\n   its INIT to calculate the State Cookie.\n
        \  After that, the endpoint MUST NOT change its state, the T1-init timer\n
        \  shall be left running, and the corresponding TCB MUST NOT be\n   destroyed.
        \ The normal procedures for handling State Cookies when a\n   TCB exists will
        resolve the duplicate INITs to a single association.\n   For an endpoint that
        is in the COOKIE-ECHOED state, it MUST populate\n   its Tie-Tags within both
        the association TCB and inside the State\n   Cookie (see Section 5.2.2 for
        a description of the Tie-Tags).\n"
      title: 5.2.1.  INIT Received in COOKIE-WAIT or COOKIE-ECHOED State (Item B)
    - contents:
      - "5.2.2.  Unexpected INIT in States Other than CLOSED, COOKIE-ECHOED,\n        COOKIE-WAIT,
        and SHUTDOWN-ACK-SENT\n   Unless otherwise stated, upon receipt of an unexpected
        INIT for this\n   association, the endpoint shall generate an INIT ACK with
        a State\n   Cookie.  Before responding, the endpoint MUST check to see if
        the\n   unexpected INIT adds new addresses to the association.  If new\n   addresses
        are added to the association, the endpoint MUST respond\n   with an ABORT,
        copying the 'Initiate Tag' of the unexpected INIT into\n   the 'Verification
        Tag' of the outbound packet carrying the ABORT.  In\n   the ABORT response,
        the cause of error MAY be set to 'restart of an\n   association with new addresses'.
        \ The error SHOULD list the addresses\n   that were added to the restarting
        association.  If no new addresses\n   are added, when responding to the INIT
        in the outbound INIT ACK, the\n   endpoint MUST copy its current Tie-Tags
        to a reserved place within\n   the State Cookie and the association's TCB.
        \ We shall refer to these\n   locations inside the cookie as the Peer's-Tie-Tag
        and the Local-Tie-\n   Tag.  We will refer to the copy within an association's
        TCB as the\n   Local Tag and Peer's Tag.  The outbound SCTP packet containing
        this\n   INIT ACK MUST carry a Verification Tag value equal to the Initiate\n
        \  Tag found in the unexpected INIT.  And the INIT ACK MUST contain a\n   new
        Initiate Tag (randomly generated; see Section 5.3.1).  Other\n   parameters
        for the endpoint SHOULD be copied from the existing\n   parameters of the
        association (e.g., number of outbound streams) into\n   the INIT ACK and cookie.\n
        \  After sending out the INIT ACK or ABORT, the endpoint shall take no\n   further
        actions; i.e., the existing association, including its\n   current state,
        and the corresponding TCB MUST NOT be changed.\n   Note: Only when a TCB exists
        and the association is not in a COOKIE-\n   WAIT or SHUTDOWN-ACK-SENT state
        are the Tie-Tags populated with a\n   value other than 0.  For a normal association
        INIT (i.e., the\n   endpoint is in the CLOSED state), the Tie-Tags MUST be
        set to 0\n   (indicating that no previous TCB existed).\n"
      title: 5.2.2.  Unexpected INIT in States Other than CLOSED, COOKIE-ECHOED,
    - contents:
      - "5.2.3.  Unexpected INIT ACK\n   If an INIT ACK is received by an endpoint
        in any state other than the\n   COOKIE-WAIT state, the endpoint should discard
        the INIT ACK chunk.\n   An unexpected INIT ACK usually indicates the processing
        of an old or\n   duplicated INIT chunk.\n"
      title: 5.2.3.  Unexpected INIT ACK
    - contents:
      - "5.2.4.  Handle a COOKIE ECHO when a TCB Exists\n   When a COOKIE ECHO chunk
        is received by an endpoint in any state for\n   an existing association (i.e.,
        not in the CLOSED state) the following\n   rules shall be applied:\n   1)
        \ Compute a MAC as described in step 1 of Section 5.1.5,\n   2)  Authenticate
        the State Cookie as described in step 2 of Section\n       5.1.5 (this is
        case C or D above).\n   3)  Compare the timestamp in the State Cookie to the
        current time.\n       If the State Cookie is older than the lifespan carried
        in the\n       State Cookie and the Verification Tags contained in the State\n
        \      Cookie do not match the current association's Verification Tags,\n
        \      the packet, including the COOKIE ECHO and any DATA chunks, should\n
        \      be discarded.  The endpoint also MUST transmit an ERROR chunk\n       with
        a \"Stale Cookie\" error cause to the peer endpoint (this is\n       case
        C or D in Section 5.2).\n       If both Verification Tags in the State Cookie
        match the\n       Verification Tags of the current association, consider the
        State\n       Cookie valid (this is case E in Section 5.2) even if the lifespan\n
        \      is exceeded.\n   4)  If the State Cookie proves to be valid, unpack
        the TCB into a\n       temporary TCB.\n   5)  Refer to Table 2 to determine
        the correct action to be taken.\n"
      - '+------------+------------+---------------+--------------+-------------+

        '
      - '|  Local Tag | Peer''s Tag | Local-Tie-Tag |Peer''s-Tie-Tag|   Action/   |

        '
      - '|            |            |               |              | Description |

        '
      - '+------------+------------+---------------+--------------+-------------+

        '
      - '|    X       |     X      |      M        |      M       |     (A)     |

        '
      - '+------------+------------+---------------+--------------+-------------+

        '
      - '|    M       |     X      |      A        |      A       |     (B)     |

        '
      - '+------------+------------+---------------+--------------+-------------+

        '
      - '|    M       |     0      |      A        |      A       |     (B)     |

        '
      - '+------------+------------+---------------+--------------+-------------+

        '
      - '|    X       |     M      |      0        |      0       |     (C)     |

        '
      - '+------------+------------+---------------+--------------+-------------+

        '
      - '|    M       |     M      |      A        |      A       |     (D)     |

        '
      - '+======================================================================+

        '
      - '|       Table 2: Handling of a COOKIE ECHO when a TCB Exists           |

        '
      - "+======================================================================+\n
        \  Legend:\n      X - Tag does not match the existing TCB.\n      M - Tag
        matches the existing TCB.\n      0 - No Tie-Tag in cookie (unknown).\n      A
        - All cases, i.e., M, X, or 0.\n   Note: For any case not shown in Table 2,
        the cookie should be\n   silently discarded.\n   Action\n   A) In this case,
        the peer may have restarted.  When the endpoint\n      recognizes this potential
        'restart', the existing session is\n      treated the same as if it received
        an ABORT followed by a new\n      COOKIE ECHO with the following exceptions:\n
        \     -  Any SCTP DATA chunks MAY be retained (this is an\n         implementation-specific
        option).\n      -  A notification of RESTART SHOULD be sent to the ULP instead
        of\n         a \"COMMUNICATION LOST\" notification.\n      All the congestion
        control parameters (e.g., cwnd, ssthresh)\n      related to this peer MUST
        be reset to their initial values (see\n      Section 6.2.1).\n      After
        this, the endpoint shall enter the ESTABLISHED state.\n      If the endpoint
        is in the SHUTDOWN-ACK-SENT state and recognizes\n      that the peer has
        restarted (Action A), it MUST NOT set up a new\n      association but instead
        resend the SHUTDOWN ACK and send an ERROR\n      chunk with a \"Cookie Received
        While Shutting Down\" error cause to\n      its peer.\n   B) In this case,
        both sides may be attempting to start an association\n      at about the same
        time, but the peer endpoint started its INIT\n      after responding to the
        local endpoint's INIT.  Thus, it may have\n      picked a new Verification
        Tag, not being aware of the previous tag\n      it had sent this endpoint.
        \ The endpoint should stay in or enter\n      the ESTABLISHED state, but it
        MUST update its peer's Verification\n      Tag from the State Cookie, stop
        any init or cookie timers that may\n      be running, and send a COOKIE ACK.\n
        \  C) In this case, the local endpoint's cookie has arrived late.\n      Before
        it arrived, the local endpoint sent an INIT and received an\n      INIT ACK
        and finally sent a COOKIE ECHO with the peer's same tag\n      but a new tag
        of its own.  The cookie should be silently\n      discarded.  The endpoint
        SHOULD NOT change states and should leave\n      any timers running.\n   D)
        When both local and remote tags match, the endpoint should enter\n      the
        ESTABLISHED state, if it is in the COOKIE-ECHOED state.  It\n      should
        stop any cookie timer that may be running and send a COOKIE\n      ACK.\n
        \  Note: The \"peer's Verification Tag\" is the tag received in the\n   Initiate
        Tag field of the INIT or INIT ACK chunk.\n"
      - contents:
        - "5.2.4.1.  An Example of a Association Restart\n   In the following example,
          \"A\" initiates the association after a\n   restart has occurred.  Endpoint
          \"Z\" had no knowledge of the restart\n   until the exchange (i.e., Heartbeats
          had not yet detected the failure\n   of \"A\") (assuming no bundling or
          fragmentation occurs):\n   Endpoint A                                          Endpoint
          Z\n   <-------------- Association is established---------------------->\n
          \  Tag=Tag_A                                             Tag=Tag_Z\n   <--------------------------------------------------------------->\n
          \  {A crashes and restarts}\n   {app sets up a association with Z}\n   (build
          TCB)\n   INIT [I-Tag=Tag_A'\n         & other info]  --------\\\n   (Start
          T1-init timer)         \\\n   (Enter COOKIE-WAIT state)      \\---> (find
          an existing TCB\n                                         compose temp TCB
          and Cookie_Z\n                                         with Tie-Tags to
          previous\n                                         association)\n                                   /---
          INIT ACK [Veri Tag=Tag_A',\n                                  /               I-Tag=Tag_Z',\n
          \  (Cancel T1-init timer) <------/                Cookie_Z[TieTags=\n                                                  Tag_A,Tag_Z\n
          \                                                  & other info]\n                                        (destroy
          temp TCB,leave original\n                                         in place)\n
          \  COOKIE ECHO [Veri=Tag_Z',\n                Cookie_Z\n                Tie=Tag_A,\n
          \               Tag_Z]----------\\\n   (Start T1-init timer)         \\\n
          \  (Enter COOKIE-ECHOED state)    \\---> (Find existing association,\n                                         Tie-Tags
          match old tags,\n                                         Tags do not match,
          i.e.,\n                                         case X X M M above,\n                                         Announce
          Restart to ULP\n                                         and reset association).\n
          \                                 /---- COOKIE ACK\n   (Cancel T1-init timer,
          <------/\n    Enter ESTABLISHED state)\n   {app sends 1st user data; strm
          0}\n   DATA [TSN=initial TSN_A\n       Strm=0,Seq=0 & user data]--\\\n   (Start
          T3-rtx timer)            \\\n                                    \\->\n
          \                                /--- SACK [TSN Ack=init TSN_A,Block=0]\n
          \  (Cancel T3-rtx timer) <------/\n                        Figure 5: A Restart
          Example\n"
        title: 5.2.4.1.  An Example of a Association Restart
      title: 5.2.4.  Handle a COOKIE ECHO when a TCB Exists
    - contents:
      - "5.2.5.  Handle Duplicate COOKIE-ACK.\n   At any state other than COOKIE-ECHOED,
        an endpoint should silently\n   discard a received COOKIE ACK chunk.\n"
      title: 5.2.5.  Handle Duplicate COOKIE-ACK.
    - contents:
      - "5.2.6.  Handle Stale COOKIE Error\n   Receipt of an ERROR chunk with a \"Stale
        Cookie\" error cause indicates\n   one of a number of possible events:\n   A)
        The association failed to completely setup before the State Cookie\n      issued
        by the sender was processed.\n   B) An old State Cookie was processed after
        setup completed.\n   C) An old State Cookie is received from someone that
        the receiver is\n      not interested in having an association with and the
        ABORT chunk\n      was lost.\n   When processing an ERROR chunk with a \"Stale
        Cookie\" error cause an\n   endpoint should first examine if an association
        is in the process of\n   being set up, i.e., the association is in the COOKIE-ECHOED
        state.\n   In all cases, if the association is not in the COOKIE-ECHOED state,\n
        \  the ERROR chunk should be silently discarded.\n   If the association is
        in the COOKIE-ECHOED state, the endpoint may\n   elect one of the following
        three alternatives.\n   1)  Send a new INIT chunk to the endpoint to generate
        a new State\n       Cookie and reattempt the setup procedure.\n   2)  Discard
        the TCB and report to the upper layer the inability to\n       set up the
        association.\n   3)  Send a new INIT chunk to the endpoint, adding a Cookie\n
        \      Preservative parameter requesting an extension to the life time\n       of
        the State Cookie.  When calculating the time extension, an\n       implementation
        SHOULD use the RTT information measured based on\n       the previous COOKIE
        ECHO / ERROR exchange, and should add no more\n       than 1 second beyond
        the measured RTT, due to long State Cookie\n       life times making the endpoint
        more subject to a replay attack.\n"
      title: 5.2.6.  Handle Stale COOKIE Error
    title: 5.2.  Handle Duplicate or Unexpected INIT, INIT ACK, COOKIE ECHO, and
  - contents:
    - '5.3.  Other Initialization Issues

      '
    - contents:
      - "5.3.1.  Selection of Tag Value\n   Initiate Tag values should be selected
        from the range of 1 to 2**32 -\n   1.  It is very important that the Initiate
        Tag value be randomized to\n   help protect against \"man in the middle\"
        and \"sequence number\"\n   attacks.  The methods described in [RFC4086] can
        be used for the\n   Initiate Tag randomization.  Careful selection of Initiate
        Tags is\n   also necessary to prevent old duplicate packets from previous\n
        \  associations being mistakenly processed as belonging to the current\n   association.\n
        \  Moreover, the Verification Tag value used by either endpoint in a\n   given
        association MUST NOT change during the life time of an\n   association.  A
        new Verification Tag value MUST be used each time the\n   endpoint tears down
        and then reestablishes an association to the same\n   peer.\n"
      title: 5.3.1.  Selection of Tag Value
    title: 5.3.  Other Initialization Issues
  - contents:
    - "5.4.  Path Verification\n   During association establishment, the two peers
      exchange a list of\n   addresses.  In the predominant case, these lists accurately
      represent\n   the addresses owned by each peer.  However, it is possible that
      a\n   misbehaving peer may supply addresses that it does not own.  To\n   prevent
      this, the following rules are applied to all addresses of the\n   new association:\n
      \  1)  Any address passed to the sender of the INIT by its upper layer\n      is
      automatically considered to be CONFIRMED.\n   2)  For the receiver of the COOKIE
      ECHO, the only CONFIRMED address\n      is the one to which the INIT-ACK was
      sent.\n   3)  All other addresses not covered by rules 1 and 2 are considered\n
      \     UNCONFIRMED and are subject to probing for verification.\n   To probe
      an address for verification, an endpoint will send\n   HEARTBEATs including
      a 64-bit random nonce and a path indicator (to\n   identify the address that
      the HEARTBEAT is sent to) within the\n   HEARTBEAT parameter.\n   Upon receipt
      of the HEARTBEAT ACK, a verification is made that the\n   nonce included in
      the HEARTBEAT parameter is the one sent to the\n   address indicated inside
      the HEARTBEAT parameter.  When this match\n   occurs, the address that the original
      HEARTBEAT was sent to is now\n   considered CONFIRMED and available for normal
      data transfer.\n   These probing procedures are started when an association
      moves to the\n   ESTABLISHED state and are ended when all paths are confirmed.\n
      \  In each RTO, a probe may be sent on an active UNCONFIRMED path in an\n   attempt
      to move it to the CONFIRMED state.  If during this probing\n   the path becomes
      inactive, this rate is lowered to the normal\n   HEARTBEAT rate.  At the expiration
      of the RTO timer, the error\n   counter of any path that was probed but not
      CONFIRMED is incremented\n   by one and subjected to path failure detection,
      as defined in Section\n   8.2.  When probing UNCONFIRMED addresses, however,
      the association\n   overall error count is NOT incremented.\n   The number of
      HEARTBEATS sent at each RTO SHOULD be limited by the\n   HB.Max.Burst parameter.
      \ It is an implementation decision as to how\n   to distribute HEARTBEATS to
      the peer's addresses for path\n   verification.\n   Whenever a path is confirmed,
      an indication MAY be given to the upper\n   layer.\n   An endpoint MUST NOT
      send any chunks to an UNCONFIRMED address, with\n   the following exceptions:\n
      \  -  A HEARTBEAT including a nonce MAY be sent to an UNCONFIRMED\n      address.\n
      \  -  A HEARTBEAT ACK MAY be sent to an UNCONFIRMED address.\n   -  A COOKIE
      ACK MAY be sent to an UNCONFIRMED address, but it MUST be\n      bundled with
      a HEARTBEAT including a nonce.  An implementation\n      that does NOT support
      bundling MUST NOT send a COOKIE ACK to an\n      UNCONFIRMED address.\n   -
      \ A COOKIE ECHO MAY be sent to an UNCONFIRMED address, but it MUST\n      be
      bundled with a HEARTBEAT including a nonce, and the packet MUST\n      NOT exceed
      the path MTU.  If the implementation does NOT support\n      bundling or if
      the bundled COOKIE ECHO plus HEARTBEAT (including\n      nonce) would exceed
      the path MTU, then the implementation MUST NOT\n      send a COOKIE ECHO to
      an UNCONFIRMED address.\n"
    title: 5.4.  Path Verification
  title: 5.  Association Initialization
- contents:
  - "6.  User Data Transfer\n   Data transmission MUST only happen in the ESTABLISHED,
    SHUTDOWN-\n   PENDING, and SHUTDOWN-RECEIVED states.  The only exception to this
    is\n   that DATA chunks are allowed to be bundled with an outbound COOKIE\n   ECHO
    chunk when in the COOKIE-WAIT state.\n   DATA chunks MUST only be received according
    to the rules below in\n   ESTABLISHED, SHUTDOWN-PENDING, and SHUTDOWN-SENT.  A
    DATA chunk\n   received in CLOSED is out of the blue and SHOULD be handled per\n
    \  Section 8.4.  A DATA chunk received in any other state SHOULD be\n   discarded.\n
    \  A SACK MUST be processed in ESTABLISHED, SHUTDOWN-PENDING, and\n   SHUTDOWN-RECEIVED.
    \ An incoming SACK MAY be processed in COOKIE-\n   ECHOED.  A SACK in the CLOSED
    state is out of the blue and SHOULD be\n   processed according to the rules in
    Section 8.4.  A SACK chunk\n   received in any other state SHOULD be discarded.\n
    \  An SCTP receiver MUST be able to receive a minimum of 1500 bytes in\n   one
    SCTP packet.  This means that an SCTP endpoint MUST NOT indicate\n   less than
    1500 bytes in its initial a_rwnd sent in the INIT or INIT\n   ACK.\n   For transmission
    efficiency, SCTP defines mechanisms for bundling of\n   small user messages and
    fragmentation of large user messages.  The\n   following diagram depicts the flow
    of user messages through SCTP.\n   In this section, the term \"data sender\" refers
    to the endpoint that\n   transmits a DATA chunk and the term \"data receiver\"
    refers to the\n   endpoint that receives a DATA chunk.  A data receiver will transmit\n
    \  SACK chunks.\n                 +--------------------------+\n                 |
    \     User Messages       |\n                 +--------------------------+\n       SCTP
    user        ^  |\n      ==================|==|=======================================\n
    \                       |  v (1)\n             +------------------+    +--------------------+\n
    \            | SCTP DATA Chunks |    |SCTP Control Chunks |\n             +------------------+
    \   +--------------------+\n                        ^  |             ^  |\n                        |
    \ v (2)         |  v (2)\n                     +--------------------------+\n
    \                    |      SCTP packets        |\n                     +--------------------------+\n
    \      SCTP                      ^  |\n      ===========================|==|===========================\n
    \                                |  v\n             Connectionless Packet Transfer
    Service (e.g., IP)\n   Notes:\n      1) When converting user messages into DATA
    chunks, an endpoint\n         will fragment user messages larger than the current
    association\n         path MTU into multiple DATA chunks.  The data receiver will\n
    \        normally reassemble the fragmented message from DATA chunks\n         before
    delivery to the user (see Section 6.9 for details).\n      2) Multiple DATA and
    control chunks may be bundled by the sender\n         into a single SCTP packet
    for transmission, as long as the\n         final size of the packet does not exceed
    the current path MTU.\n         The receiver will unbundle the packet back into
    the original\n         chunks.  Control chunks MUST come before DATA chunks in
    the\n         packet.\n                Figure 6: Illustration of User Data Transfer\n
    \  The fragmentation and bundling mechanisms, as detailed in Section 6.9\n   and
    Section 6.10, are OPTIONAL to implement by the data sender, but\n   they MUST
    be implemented by the data receiver, i.e., an endpoint MUST\n   properly receive
    and process bundled or fragmented data.\n"
  - contents:
    - "6.1.  Transmission of DATA Chunks\n   This document is specified as if there
      is a single retransmission\n   timer per destination transport address, but
      implementations MAY have\n   a retransmission timer for each DATA chunk.\n   The
      following general rules MUST be applied by the data sender for\n   transmission
      and/or retransmission of outbound DATA chunks:\n   A) At any given time, the
      data sender MUST NOT transmit new data to\n      any destination transport address
      if its peer's rwnd indicates\n      that the peer has no buffer space (i.e.,
      rwnd is 0; see Section\n      6.2.1).  However, regardless of the value of rwnd
      (including if it\n      is 0), the data sender can always have one DATA chunk
      in flight to\n      the receiver if allowed by cwnd (see rule B, below).  This
      rule\n      allows the sender to probe for a change in rwnd that the sender\n
      \     missed due to the SACK's having been lost in transit from the data\n      receiver
      to the data sender.\n      When the receiver's advertised window is zero, this
      probe is\n      called a zero window probe.  Note that a zero window probe SHOULD\n
      \     only be sent when all outstanding DATA chunks have been\n      cumulatively
      acknowledged and no DATA chunks are in flight.  Zero\n      window probing MUST
      be supported.\n      If the sender continues to receive new packets from the
      receiver\n      while doing zero window probing, the unacknowledged window probes\n
      \     should not increment the error counter for the association or any\n      destination
      transport address.  This is because the receiver MAY\n      keep its window
      closed for an indefinite time.  Refer to Section\n      6.2 on the receiver
      behavior when it advertises a zero window.\n      The sender SHOULD send the
      first zero window probe after 1 RTO\n      when it detects that the receiver
      has closed its window and SHOULD\n      increase the probe interval exponentially
      afterwards.  Also note\n      that the cwnd SHOULD be adjusted according to
      Section 7.2.1.  Zero\n      window probing does not affect the calculation of
      cwnd.\n      The sender MUST also have an algorithm for sending new DATA chunks\n
      \     to avoid silly window syndrome (SWS) as described in [RFC0813].\n      The
      algorithm can be similar to the one described in Section\n      4.2.3.4 of [RFC1122].\n
      \     However, regardless of the value of rwnd (including if it is 0),\n      the
      data sender can always have one DATA chunk in flight to the\n      receiver
      if allowed by cwnd (see rule B below).  This rule allows\n      the sender to
      probe for a change in rwnd that the sender missed\n      due to the SACK having
      been lost in transit from the data receiver\n      to the data sender.\n   B)
      At any given time, the sender MUST NOT transmit new data to a\n      given transport
      address if it has cwnd or more bytes of data\n      outstanding to that transport
      address.\n   C) When the time comes for the sender to transmit, before sending
      new\n      DATA chunks, the sender MUST first transmit any outstanding DATA\n
      \     chunks that are marked for retransmission (limited by the current\n      cwnd).\n
      \  D) When the time comes for the sender to transmit new DATA chunks,\n      the
      protocol parameter Max.Burst SHOULD be used to limit the\n      number of packets
      sent.  The limit MAY be applied by adjusting\n      cwnd as follows:\n      if((flightsize
      + Max.Burst*MTU) < cwnd) cwnd = flightsize +\n      Max.Burst*MTU\n      Or
      it MAY be applied by strictly limiting the number of packets\n      emitted
      by the output routine.\n   E) Then, the sender can send out as many new DATA
      chunks as rule A\n      and rule B allow.\n   Multiple DATA chunks committed
      for transmission MAY be bundled in a\n   single packet.  Furthermore, DATA chunks
      being retransmitted MAY be\n   bundled with new DATA chunks, as long as the
      resulting packet size\n   does not exceed the path MTU.  A ULP may request that
      no bundling is\n   performed, but this should only turn off any delays that
      an SCTP\n   implementation may be using to increase bundling efficiency.  It
      does\n   not in itself stop all bundling from occurring (i.e., in case of\n
      \  congestion or retransmission).\n   Before an endpoint transmits a DATA chunk,
      if any received DATA\n   chunks have not been acknowledged (e.g., due to delayed
      ack), the\n   sender should create a SACK and bundle it with the outbound DATA\n
      \  chunk, as long as the size of the final SCTP packet does not exceed\n   the
      current MTU.  See Section 6.2.\n   IMPLEMENTATION NOTE: When the window is full
      (i.e., transmission is\n   disallowed by rule A and/or rule B), the sender MAY
      still accept send\n   requests from its upper layer, but MUST transmit no more
      DATA chunks\n   until some or all of the outstanding DATA chunks are acknowledged
      and\n   transmission is allowed by rule A and rule B again.\n   Whenever a transmission
      or retransmission is made to any address, if\n   the T3-rtx timer of that address
      is not currently running, the sender\n   MUST start that timer.  If the timer
      for that address is already\n   running, the sender MUST restart the timer if
      the earliest (i.e.,\n   lowest TSN) outstanding DATA chunk sent to that address
      is being\n   retransmitted.  Otherwise, the data sender MUST NOT restart the\n
      \  timer.\n   When starting or restarting the T3-rtx timer, the timer value
      must be\n   adjusted according to the timer rules defined in Sections 6.3.2
      and\n   6.3.3.\n   Note: The data sender SHOULD NOT use a TSN that is more than
      2**31 -\n   1 above the beginning TSN of the current send window.\n"
    title: 6.1.  Transmission of DATA Chunks
  - contents:
    - "6.2.  Acknowledgement on Reception of DATA Chunks\n   The SCTP endpoint MUST
      always acknowledge the reception of each valid\n   DATA chunk when the DATA
      chunk received is inside its receive window.\n   When the receiver's advertised
      window is 0, the receiver MUST drop\n   any new incoming DATA chunk with a TSN
      larger than the largest TSN\n   received so far.  If the new incoming DATA chunk
      holds a TSN value\n   less than the largest TSN received so far, then the receiver
      SHOULD\n   drop the largest TSN held for reordering and accept the new incoming\n
      \  DATA chunk.  In either case, if such a DATA chunk is dropped, the\n   receiver
      MUST immediately send back a SACK with the current receive\n   window showing
      only DATA chunks received and accepted so far.  The\n   dropped DATA chunk(s)
      MUST NOT be included in the SACK, as they were\n   not accepted.  The receiver
      MUST also have an algorithm for\n   advertising its receive window to avoid
      receiver silly window\n   syndrome (SWS), as described in [RFC0813].  The algorithm
      can be\n   similar to the one described in Section 4.2.3.3 of [RFC1122].\n   The
      guidelines on delayed acknowledgement algorithm specified in\n   Section 4.2
      of [RFC2581] SHOULD be followed.  Specifically, an\n   acknowledgement SHOULD
      be generated for at least every second packet\n   (not every second DATA chunk)
      received, and SHOULD be generated\n   within 200 ms of the arrival of any unacknowledged
      DATA chunk.  In\n   some situations, it may be beneficial for an SCTP transmitter
      to be\n   more conservative than the algorithms detailed in this document\n
      \  allow.  However, an SCTP transmitter MUST NOT be more aggressive than\n   the
      following algorithms allow.\n   An SCTP receiver MUST NOT generate more than
      one SACK for every\n   incoming packet, other than to update the offered window
      as the\n   receiving application consumes new data.\n   IMPLEMENTATION NOTE:
      The maximum delay for generating an\n   acknowledgement may be configured by
      the SCTP administrator, either\n   statically or dynamically, in order to meet
      the specific timing\n   requirement of the protocol being carried.\n   An implementation
      MUST NOT allow the maximum delay to be configured\n   to be more than 500 ms.
      \ In other words, an implementation MAY lower\n   this value below 500 ms but
      MUST NOT raise it above 500 ms.\n   Acknowledgements MUST be sent in SACK chunks
      unless shutdown was\n   requested by the ULP, in which case an endpoint MAY
      send an\n   acknowledgement in the SHUTDOWN chunk.  A SACK chunk can acknowledge\n
      \  the reception of multiple DATA chunks.  See Section 3.3.4 for SACK\n   chunk
      format.  In particular, the SCTP endpoint MUST fill in the\n   Cumulative TSN
      Ack field to indicate the latest sequential TSN (of a\n   valid DATA chunk)
      it has received.  Any received DATA chunks with TSN\n   greater than the value
      in the Cumulative TSN Ack field are reported\n   in the Gap Ack Block fields.
      \ The SCTP endpoint MUST report as many\n   Gap Ack Blocks as can fit in a single
      SACK chunk limited by the\n   current path MTU.\n   Note: The SHUTDOWN chunk
      does not contain Gap Ack Block fields.\n   Therefore, the endpoint should use
      a SACK instead of the SHUTDOWN\n   chunk to acknowledge DATA chunks received
      out of order.\n   When a packet arrives with duplicate DATA chunk(s) and with
      no new\n   DATA chunk(s), the endpoint MUST immediately send a SACK with no\n
      \  delay.  If a packet arrives with duplicate DATA chunk(s) bundled with\n   new
      DATA chunks, the endpoint MAY immediately send a SACK.  Normally,\n   receipt
      of duplicate DATA chunks will occur when the original SACK\n   chunk was lost
      and the peer's RTO has expired.  The duplicate TSN\n   number(s) SHOULD be reported
      in the SACK as duplicate.\n   When an endpoint receives a SACK, it MAY use the
      duplicate TSN\n   information to determine if SACK loss is occurring.  Further
      use of\n   this data is for future study.\n   The data receiver is responsible
      for maintaining its receive buffers.\n   The data receiver SHOULD notify the
      data sender in a timely manner of\n   changes in its ability to receive data.
      \ How an implementation\n   manages its receive buffers is dependent on many
      factors (e.g.,\n   operating system, memory management system, amount of memory,
      etc.).\n   However, the data sender strategy defined in Section 6.2.1 is based\n
      \  on the assumption of receiver operation similar to the following:\n   A)
      At initialization of the association, the endpoint tells the peer\n      how
      much receive buffer space it has allocated to the association\n      in the
      INIT or INIT ACK.  The endpoint sets a_rwnd to this value.\n   B) As DATA chunks
      are received and buffered, decrement a_rwnd by the\n      number of bytes received
      and buffered.  This is, in effect,\n      closing rwnd at the data sender and
      restricting the amount of data\n      it can transmit.\n   C) As DATA chunks
      are delivered to the ULP and released from the\n      receive buffers, increment
      a_rwnd by the number of bytes delivered\n      to the upper layer.  This is,
      in effect, opening up rwnd on the\n      data sender and allowing it to send
      more data.  The data receiver\n      SHOULD NOT increment a_rwnd unless it has
      released bytes from its\n      receive buffer.  For example, if the receiver
      is holding\n      fragmented DATA chunks in a reassembly queue, it should not\n
      \     increment a_rwnd.\n   D) When sending a SACK, the data receiver SHOULD
      place the current\n      value of a_rwnd into the a_rwnd field.  The data receiver
      SHOULD\n      take into account that the data sender will not retransmit DATA\n
      \     chunks that are acked via the Cumulative TSN Ack (i.e., will drop\n      from
      its retransmit queue).\n   Under certain circumstances, the data receiver may
      need to drop DATA\n   chunks that it has received but hasn't released from its
      receive\n   buffers (i.e., delivered to the ULP).  These DATA chunks may have\n
      \  been acked in Gap Ack Blocks.  For example, the data receiver may be\n   holding
      data in its receive buffers while reassembling a fragmented\n   user message
      from its peer when it runs out of receive buffer space.\n   It may drop these
      DATA chunks even though it has acknowledged them in\n   Gap Ack Blocks.  If
      a data receiver drops DATA chunks, it MUST NOT\n   include them in Gap Ack Blocks
      in subsequent SACKs until they are\n   received again via retransmission.  In
      addition, the endpoint should\n   take into account the dropped data when calculating
      its a_rwnd.\n   An endpoint SHOULD NOT revoke a SACK and discard data.  Only
      in\n   extreme circumstances should an endpoint use this procedure (such as\n
      \  out of buffer space).  The data receiver should take into account\n   that
      dropping data that has been acked in Gap Ack Blocks can result\n   in suboptimal
      retransmission strategies in the data sender and thus\n   in suboptimal performance.\n
      \  The following example illustrates the use of delayed\n   acknowledgements:\n
      \   Endpoint A                                      Endpoint Z\n    {App sends
      3 messages; strm 0}\n    DATA [TSN=7,Strm=0,Seq=3] ------------> (ack delayed)\n
      \   (Start T3-rtx timer)\n    DATA [TSN=8,Strm=0,Seq=4] ------------> (send
      ack)\n                                  /------- SACK [TSN Ack=8,block=0]\n
      \   (cancel T3-rtx timer)  <-----/\n    DATA [TSN=9,Strm=0,Seq=5] ------------>
      (ack delayed)\n    (Start T3-rtx timer)\n                                           ...\n
      \                                          {App sends 1 message; strm 1}\n                                           (bundle
      SACK with DATA)\n                                    /----- SACK [TSN Ack=9,block=0]
      \\\n                                   /         DATA [TSN=6,Strm=1,Seq=2]\n
      \   (cancel T3-rtx timer)  <------/        (Start T3-rtx timer)\n    (ack delayed)\n
      \   (send ack)\n    SACK [TSN Ack=6,block=0] -------------> (cancel T3-rtx timer)\n
      \          Figure 7:  Delayed Acknowledgement Example\n   If an endpoint receives
      a DATA chunk with no user data (i.e., the\n   Length field is set to 16), it
      MUST send an ABORT with error cause\n   set to \"No User Data\".\n   An endpoint
      SHOULD NOT send a DATA chunk with no user data part.\n"
    - contents:
      - "6.2.1.  Processing a Received SACK\n   Each SACK an endpoint receives contains
        an a_rwnd value.  This value\n   represents the amount of buffer space the
        data receiver, at the time\n   of transmitting the SACK, has left of its total
        receive buffer space\n   (as specified in the INIT/INIT ACK).  Using a_rwnd,
        Cumulative TSN\n   Ack, and Gap Ack Blocks, the data sender can develop a
        representation\n   of the peer's receive buffer space.\n   One of the problems
        the data sender must take into account when\n   processing a SACK is that
        a SACK can be received out of order.  That\n   is, a SACK sent by the data
        receiver can pass an earlier SACK and be\n   received first by the data sender.
        \ If a SACK is received out of\n   order, the data sender can develop an incorrect
        view of the peer's\n   receive buffer space.\n   Since there is no explicit
        identifier that can be used to detect\n   out-of-order SACKs, the data sender
        must use heuristics to determine\n   if a SACK is new.\n   An endpoint SHOULD
        use the following rules to calculate the rwnd,\n   using the a_rwnd value,
        the Cumulative TSN Ack, and Gap Ack Blocks in\n   a received SACK.\n   A)
        At the establishment of the association, the endpoint initializes\n      the
        rwnd to the Advertised Receiver Window Credit (a_rwnd) the\n      peer specified
        in the INIT or INIT ACK.\n   B) Any time a DATA chunk is transmitted (or retransmitted)
        to a peer,\n      the endpoint subtracts the data size of the chunk from the
        rwnd of\n      that peer.\n   C) Any time a DATA chunk is marked for retransmission,
        either via\n      T3-rtx timer expiration (Section 6.3.3) or via Fast Retransmit\n
        \     (Section 7.2.4), add the data size of those chunks to the rwnd.\n      Note:
        If the implementation is maintaining a timer on each DATA\n      chunk, then
        only DATA chunks whose timer expired would be marked\n      for retransmission.\n
        \  D) Any time a SACK arrives, the endpoint performs the following:\n        i)
        If Cumulative TSN Ack is less than the Cumulative TSN Ack\n           Point,
        then drop the SACK.  Since Cumulative TSN Ack is\n           monotonically
        increasing, a SACK whose Cumulative TSN Ack is\n           less than the Cumulative
        TSN Ack Point indicates an out-of-\n           order SACK.\n       ii) Set
        rwnd equal to the newly received a_rwnd minus the number\n           of bytes
        still outstanding after processing the Cumulative\n           TSN Ack and
        the Gap Ack Blocks.\n      iii) If the SACK is missing a TSN that was previously
        acknowledged\n           via a Gap Ack Block (e.g., the data receiver reneged
        on the\n           data), then consider the corresponding DATA that might
        be\n           possibly missing: Count one miss indication towards Fast\n
        \          Retransmit as described in Section 7.2.4, and if no\n           retransmit
        timer is running for the destination address to\n           which the DATA
        chunk was originally transmitted, then T3-rtx\n           is started for that
        destination address.\n       iv) If the Cumulative TSN Ack matches or exceeds
        the Fast\n           Recovery exitpoint (Section 7.2.4), Fast Recovery is
        exited.\n"
      title: 6.2.1.  Processing a Received SACK
    title: 6.2.  Acknowledgement on Reception of DATA Chunks
  - contents:
    - "6.3.  Management of Retransmission Timer\n   An SCTP endpoint uses a retransmission
      timer T3-rtx to ensure data\n   delivery in the absence of any feedback from
      its peer.  The duration\n   of this timer is referred to as RTO (retransmission
      timeout).\n   When an endpoint's peer is multi-homed, the endpoint will calculate
      a\n   separate RTO for each different destination transport address of its\n
      \  peer endpoint.\n   The computation and management of RTO in SCTP follow closely
      how TCP\n   manages its retransmission timer.  To compute the current RTO, an\n
      \  endpoint maintains two state variables per destination transport\n   address:
      SRTT (smoothed round-trip time) and RTTVAR (round-trip time\n   variation).\n"
    - contents:
      - "6.3.1.  RTO Calculation\n   The rules governing the computation of SRTT,
        RTTVAR, and RTO are as\n   follows:\n   C1)  Until an RTT measurement has
        been made for a packet sent to the\n        given destination transport address,
        set RTO to the protocol\n        parameter 'RTO.Initial'.\n   C2)  When the
        first RTT measurement R is made, set\n        SRTT <- R,\n        RTTVAR <-
        R/2, and\n        RTO <- SRTT + 4 * RTTVAR.\n   C3)  When a new RTT measurement
        R' is made, set\n        RTTVAR <- (1 - RTO.Beta) * RTTVAR + RTO.Beta * |SRTT
        - R'|\n        and\n        SRTT <- (1 - RTO.Alpha) * SRTT + RTO.Alpha * R'\n
        \       Note: The value of SRTT used in the update to RTTVAR is its\n        value
        before updating SRTT itself using the second assignment.\n        After the
        computation, update RTO <- SRTT + 4 * RTTVAR.\n   C4)  When data is in flight
        and when allowed by rule C5 below, a new\n        RTT measurement MUST be
        made each round trip.  Furthermore, new\n        RTT measurements SHOULD be
        made no more than once per round trip\n        for a given destination transport
        address.  There are two\n        reasons for this recommendation: First, it
        appears that\n        measuring more frequently often does not in practice
        yield any\n        significant benefit [ALLMAN99]; second, if measurements
        are made\n        more often, then the values of RTO.Alpha and RTO.Beta in
        rule C3\n        above should be adjusted so that SRTT and RTTVAR still adjust
        to\n        changes at roughly the same rate (in terms of how many round\n
        \       trips it takes them to reflect new values) as they would if\n        making
        only one measurement per round-trip and using RTO.Alpha\n        and RTO.Beta
        as given in rule C3.  However, the exact nature of\n        these adjustments
        remains a research issue.\n   C5)  Karn's algorithm: RTT measurements MUST
        NOT be made using\n        packets that were retransmitted (and thus for which
        it is\n        ambiguous whether the reply was for the first instance of the\n
        \       chunk or for a later instance)\n        IMPLEMENTATION NOTE: RTT measurements
        should only be made using\n        a chunk with TSN r if no chunk with TSN
        less than or equal to r\n        is retransmitted since r is first sent.\n
        \  C6)  Whenever RTO is computed, if it is less than RTO.Min seconds\n        then
        it is rounded up to RTO.Min seconds.  The reason for this\n        rule is
        that RTOs that do not have a high minimum value are\n        susceptible to
        unnecessary timeouts [ALLMAN99].\n   C7)  A maximum value may be placed on
        RTO provided it is at least\n        RTO.max seconds.\n   There is no requirement
        for the clock granularity G used for\n   computing RTT measurements and the
        different state variables, other\n   than:\n   G1) Whenever RTTVAR is computed,
        if RTTVAR = 0, then adjust RTTVAR <-\n   G.\n   Experience [ALLMAN99] has
        shown that finer clock granularities (<=\n   100 msec) perform somewhat better
        than more coarse granularities.\n"
      title: 6.3.1.  RTO Calculation
    - contents:
      - "6.3.2.  Retransmission Timer Rules\n   The rules for managing the retransmission
        timer are as follows:\n   R1)  Every time a DATA chunk is sent to any address
        (including a\n        retransmission), if the T3-rtx timer of that address
        is not\n        running, start it running so that it will expire after the
        RTO\n        of that address.  The RTO used here is that obtained after any\n
        \       doubling due to previous T3-rtx timer expirations on the\n        corresponding
        destination address as discussed in rule E2 below.\n   R2)  Whenever all outstanding
        data sent to an address have been\n        acknowledged, turn off the T3-rtx
        timer of that address.\n   R3)  Whenever a SACK is received that acknowledges
        the DATA chunk\n        with the earliest outstanding TSN for that address,
        restart the\n        T3-rtx timer for that address with its current RTO (if
        there is\n        still outstanding data on that address).\n   R4)  Whenever
        a SACK is received missing a TSN that was previously\n        acknowledged
        via a Gap Ack Block, start the T3-rtx for the\n        destination address
        to which the DATA chunk was originally\n        transmitted if it is not already
        running.\n   The following example shows the use of various timer rules (assuming\n
        \  that the receiver uses delayed acks).\n   Endpoint A                                         Endpoint
        Z\n   {App begins to send}\n   Data [TSN=7,Strm=0,Seq=3] ------------> (ack
        delayed)\n   (Start T3-rtx timer)\n                                           {App
        sends 1 message; strm 1}\n                                           (bundle
        ack with data)\n   DATA [TSN=8,Strm=0,Seq=4] ----\\     /-- SACK [TSN Ack=7,Block=0]\n
        \                                 \\   /      DATA [TSN=6,Strm=1,Seq=2]\n
        \                                  \\ /     (Start T3-rtx timer)\n                                    \\\n
        \                                  / \\\n   (Restart T3-rtx timer)  <------/
        \  \\--> (ack delayed)\n   (ack delayed)\n   {send ack}\n   SACK [TSN Ack=6,Block=0]
        --------------> (Cancel T3-rtx timer)\n                                           ..\n
        \                                          (send ack)\n   (Cancel T3-rtx timer)
        \ <-------------- SACK [TSN Ack=8,Block=0]\n                       Figure
        8: Timer Rule Examples\n"
      title: 6.3.2.  Retransmission Timer Rules
    - contents:
      - "6.3.3.  Handle T3-rtx Expiration\n   Whenever the retransmission timer T3-rtx
        expires for a destination\n   address, do the following:\n   E1)  For the
        destination address for which the timer expires, adjust\n        its ssthresh
        with rules defined in Section 7.2.3 and set the\n        cwnd <- MTU.\n   E2)
        \ For the destination address for which the timer expires, set RTO\n        <-
        RTO * 2 (\"back off the timer\").  The maximum value discussed\n        in
        rule C7 above (RTO.max) may be used to provide an upper bound\n        to
        this doubling operation.\n   E3)  Determine how many of the earliest (i.e.,
        lowest TSN)\n        outstanding DATA chunks for the address for which the
        T3-rtx has\n        expired will fit into a single packet, subject to the
        MTU\n        constraint for the path corresponding to the destination\n        transport
        address to which the retransmission is being sent\n        (this may be different
        from the address for which the timer\n        expires; see Section 6.4).  Call
        this value K.  Bundle and\n        retransmit those K DATA chunks in a single
        packet to the\n        destination endpoint.\n   E4)  Start the retransmission
        timer T3-rtx on the destination address\n        to which the retransmission
        is sent, if rule R1 above indicates\n        to do so.  The RTO to be used
        for starting T3-rtx should be the\n        one for the destination address
        to which the retransmission is\n        sent, which, when the receiver is
        multi-homed, may be different\n        from the destination address for which
        the timer expired (see\n        Section 6.4 below).\n   After retransmitting,
        once a new RTT measurement is obtained (which\n   can happen only when new
        data has been sent and acknowledged, per\n   rule C5, or for a measurement
        made from a HEARTBEAT; see Section\n   8.3), the computation in rule C3 is
        performed, including the\n   computation of RTO, which may result in \"collapsing\"
        RTO back down\n   after it has been subject to doubling (rule E2).\n   Note:
        Any DATA chunks that were sent to the address for which the\n   T3-rtx timer
        expired but did not fit in one MTU (rule E3 above)\n   should be marked for
        retransmission and sent as soon as cwnd allows\n   (normally, when a SACK
        arrives).\n   The final rule for managing the retransmission timer concerns\n
        \  failover (see Section 6.4.1):\n   F1)  Whenever an endpoint switches from
        the current destination\n        transport address to a different one, the
        current retransmission\n        timers are left running.  As soon as the endpoint
        transmits a\n        packet containing DATA chunk(s) to the new transport
        address,\n        start the timer on that transport address, using the RTO
        value\n        of the destination address to which the data is being sent,
        if\n        rule R1 indicates to do so.\n"
      title: 6.3.3.  Handle T3-rtx Expiration
    title: 6.3.  Management of Retransmission Timer
  - contents:
    - "6.4.  Multi-Homed SCTP Endpoints\n   An SCTP endpoint is considered multi-homed
      if there are more than one\n   transport address that can be used as a destination
      address to reach\n   that endpoint.\n   Moreover, the ULP of an endpoint shall
      select one of the multiple\n   destination addresses of a multi-homed peer endpoint
      as the primary\n   path (see Section 5.1.2 and Section 10.1 for details).\n
      \  By default, an endpoint SHOULD always transmit to the primary path,\n   unless
      the SCTP user explicitly specifies the destination transport\n   address (and
      possibly source transport address) to use.\n   An endpoint SHOULD transmit reply
      chunks (e.g., SACK, HEARTBEAT ACK,\n   etc.) to the same destination transport
      address from which it\n   received the DATA or control chunk to which it is
      replying.  This\n   rule should also be followed if the endpoint is bundling
      DATA chunks\n   together with the reply chunk.\n   However, when acknowledging
      multiple DATA chunks received in packets\n   from different source addresses
      in a single SACK, the SACK chunk may\n   be transmitted to one of the destination
      transport addresses from\n   which the DATA or control chunks being acknowledged
      were received.\n   When a receiver of a duplicate DATA chunk sends a SACK to
      a multi-\n   homed endpoint, it MAY be beneficial to vary the destination address\n
      \  and not use the source address of the DATA chunk.  The reason is that\n   receiving
      a duplicate from a multi-homed endpoint might indicate that\n   the return path
      (as specified in the source address of the DATA\n   chunk) for the SACK is broken.\n
      \  Furthermore, when its peer is multi-homed, an endpoint SHOULD try to\n   retransmit
      a chunk that timed out to an active destination transport\n   address that is
      different from the last destination address to which\n   the DATA chunk was
      sent.\n   Retransmissions do not affect the total outstanding data count.\n
      \  However, if the DATA chunk is retransmitted onto a different\n   destination
      address, both the outstanding data counts on the new\n   destination address
      and the old destination address to which the data\n   chunk was last sent shall
      be adjusted accordingly.\n"
    - contents:
      - "6.4.1.  Failover from an Inactive Destination Address\n   Some of the transport
        addresses of a multi-homed SCTP endpoint may\n   become inactive due to either
        the occurrence of certain error\n   conditions (see Section 8.2) or adjustments
        from the SCTP user.\n   When there is outbound data to send and the primary
        path becomes\n   inactive (e.g., due to failures), or where the SCTP user
        explicitly\n   requests to send data to an inactive destination transport
        address,\n   before reporting an error to its ULP, the SCTP endpoint should
        try to\n   send the data to an alternate active destination transport address
        if\n   one exists.\n   When retransmitting data that timed out, if the endpoint
        is multi-\n   homed, it should consider each source-destination address pair
        in its\n   retransmission selection policy.  When retransmitting timed-out
        data,\n   the endpoint should attempt to pick the most divergent source-\n
        \  destination pair from the original source-destination pair to which\n   the
        packet was transmitted.\n   Note: Rules for picking the most divergent source-destination
        pair\n   are an implementation decision and are not specified within this\n
        \  document.\n"
      title: 6.4.1.  Failover from an Inactive Destination Address
    title: 6.4.  Multi-Homed SCTP Endpoints
  - contents:
    - "6.5.  Stream Identifier and Stream Sequence Number\n   Every DATA chunk MUST
      carry a valid stream identifier.  If an\n   endpoint receives a DATA chunk with
      an invalid stream identifier, it\n   shall acknowledge the reception of the
      DATA chunk following the\n   normal procedure, immediately send an ERROR chunk
      with cause set to\n   \"Invalid Stream Identifier\" (see Section 3.3.10), and
      discard the\n   DATA chunk.  The endpoint may bundle the ERROR chunk in the
      same\n   packet as the SACK as long as the ERROR follows the SACK.\n   The Stream
      Sequence Number in all the streams MUST start from 0 when\n   the association
      is established.  Also, when the Stream Sequence\n   Number reaches the value
      65535 the next Stream Sequence Number MUST\n   be set to 0.\n"
    title: 6.5.  Stream Identifier and Stream Sequence Number
  - contents:
    - "6.6.  Ordered and Unordered Delivery\n   Within a stream, an endpoint MUST
      deliver DATA chunks received with\n   the U flag set to 0 to the upper layer
      according to the order of\n   their Stream Sequence Number.  If DATA chunks
      arrive out of order of\n   their Stream Sequence Number, the endpoint MUST hold
      the received\n   DATA chunks from delivery to the ULP until they are reordered.\n
      \  However, an SCTP endpoint can indicate that no ordered delivery is\n   required
      for a particular DATA chunk transmitted within the stream by\n   setting the
      U flag of the DATA chunk to 1.\n   When an endpoint receives a DATA chunk with
      the U flag set to 1, it\n   must bypass the ordering mechanism and immediately
      deliver the data\n   to the upper layer (after reassembly if the user data is
      fragmented\n   by the data sender).\n   This provides an effective way of transmitting
      \"out-of-band\" data in\n   a given stream.  Also, a stream can be used as an
      \"unordered\" stream\n   by simply setting the U flag to 1 in all DATA chunks
      sent through\n   that stream.\n   IMPLEMENTATION NOTE: When sending an unordered
      DATA chunk, an\n   implementation may choose to place the DATA chunk in an outbound\n
      \  packet that is at the head of the outbound transmission queue if\n   possible.\n
      \  The 'Stream Sequence Number' field in a DATA chunk with U flag set to\n   1
      has no significance.  The sender can fill it with arbitrary value,\n   but the
      receiver MUST ignore the field.\n   Note: When transmitting ordered and unordered
      data, an endpoint does\n   not increment its Stream Sequence Number when transmitting
      a DATA\n   chunk with U flag set to 1.\n"
    title: 6.6.  Ordered and Unordered Delivery
  - contents:
    - "6.7.  Report Gaps in Received DATA TSNs\n   Upon the reception of a new DATA
      chunk, an endpoint shall examine the\n   continuity of the TSNs received.  If
      the endpoint detects a gap in\n   the received DATA chunk sequence, it SHOULD
      send a SACK with Gap Ack\n   Blocks immediately.  The data receiver continues
      sending a SACK after\n   receipt of each SCTP packet that doesn't fill the gap.\n
      \  Based on the Gap Ack Block from the received SACK, the endpoint can\n   calculate
      the missing DATA chunks and make decisions on whether to\n   retransmit them
      (see Section 6.2.1 for details).\n   Multiple gaps can be reported in one single
      SACK (see Section 3.3.4).\n   When its peer is multi-homed, the SCTP endpoint
      SHOULD always try to\n   send the SACK to the same destination address from
      which the last\n   DATA chunk was received.\n   Upon the reception of a SACK,
      the endpoint MUST remove all DATA\n   chunks that have been acknowledged by
      the SACK's Cumulative TSN Ack\n   from its transmit queue.  The endpoint MUST
      also treat all the DATA\n   chunks with TSNs not included in the Gap Ack Blocks
      reported by the\n   SACK as \"missing\".  The number of \"missing\" reports
      for each\n   outstanding DATA chunk MUST be recorded by the data sender in order\n
      \  to make retransmission decisions.  See Section 7.2.4 for details.\n   The
      following example shows the use of SACK to report a gap.\n       Endpoint A
      \                                   Endpoint Z {App\n       sends 3 messages;
      strm 0} DATA [TSN=6,Strm=0,Seq=2] ----------\n       -----> (ack delayed) (Start
      T3-rtx timer)\n       DATA [TSN=7,Strm=0,Seq=3] --------> X (lost)\n       DATA
      [TSN=8,Strm=0,Seq=4] ---------------> (gap detected,\n                                                   immediately
      send ack)\n                                       /----- SACK [TSN Ack=6,Block=1,\n
      \                                     /             Start=2,End=2]\n                               <-----/
      (remove 6 from out-queue,\n        and mark 7 as \"1\" missing report)\n                  Figure
      9: Reporting a Gap using SACK\n   The maximum number of Gap Ack Blocks that
      can be reported within a\n   single SACK chunk is limited by the current path
      MTU.  When a single\n   SACK cannot cover all the Gap Ack Blocks needed to be
      reported due to\n   the MTU limitation, the endpoint MUST send only one SACK,
      reporting\n   the Gap Ack Blocks from the lowest to highest TSNs, within the
      size\n   limit set by the MTU, and leave the remaining highest TSN numbers\n
      \  unacknowledged.\n"
    title: 6.7.  Report Gaps in Received DATA TSNs
  - contents:
    - "6.8.  CRC32c Checksum Calculation\n   When sending an SCTP packet, the endpoint
      MUST strengthen the data\n   integrity of the transmission by including the
      CRC32c checksum value\n   calculated on the packet, as described below.\n   After
      the packet is constructed (containing the SCTP common header\n   and one or
      more control or DATA chunks), the transmitter MUST\n   1)  fill in the proper
      Verification Tag in the SCTP common header and\n       initialize the checksum
      field to '0's,\n   2)  calculate the CRC32c checksum of the whole packet, including
      the\n       SCTP common header and all the chunks (refer to Appendix B for\n
      \      details of the CRC32c algorithm); and\n   3)  put the resultant value
      into the checksum field in the common\n       header, and leave the rest of
      the bits unchanged.\n   When an SCTP packet is received, the receiver MUST first
      check the\n   CRC32c checksum as follows:\n   1)  Store the received CRC32c
      checksum value aside.\n   2)  Replace the 32 bits of the checksum field in the
      received SCTP\n       packet with all '0's and calculate a CRC32c checksum value
      of the\n       whole received packet.\n   3)  Verify that the calculated CRC32c
      checksum is the same as the\n       received CRC32c checksum.  If it is not,
      the receiver MUST treat\n       the packet as an invalid SCTP packet.\n   The
      default procedure for handling invalid SCTP packets is to\n   silently discard
      them.\n   Any hardware implementation SHOULD be done in a way that is\n   verifiable
      by the software.\n"
    title: 6.8.  CRC32c Checksum Calculation
  - contents:
    - "6.9.  Fragmentation and Reassembly\n   An endpoint MAY support fragmentation
      when sending DATA chunks, but\n   it MUST support reassembly when receiving
      DATA chunks.  If an\n   endpoint supports fragmentation, it MUST fragment a
      user message if\n   the size of the user message to be sent causes the outbound
      SCTP\n   packet size to exceed the current MTU.  If an implementation does not\n
      \  support fragmentation of outbound user messages, the endpoint MUST\n   return
      an error to its upper layer and not attempt to send the user\n   message.\n
      \  Note: If an implementation that supports fragmentation makes\n   available
      to its upper layer a mechanism to turn off fragmentation,\n   it may do so.
      \ However, in so doing, it MUST react just like an\n   implementation that does
      NOT support fragmentation, i.e., it MUST\n   reject sends that exceed the current
      Path MTU (P-MTU).\n   IMPLEMENTATION NOTE: In this error case, the Send primitive
      discussed\n   in Section 10.1 would need to return an error to the upper layer.\n
      \  If its peer is multi-homed, the endpoint shall choose a size no\n   larger
      than the association Path MTU.  The association Path MTU is\n   the smallest
      Path MTU of all destination addresses.\n   Note: Once a message is fragmented,
      it cannot be re-fragmented.\n   Instead, if the PMTU has been reduced, then
      IP fragmentation must be\n   used.  Please see Section 7.3 for details of PMTU
      discovery.\n   When determining when to fragment, the SCTP implementation MUST
      take\n   into account the SCTP packet header as well as the DATA chunk\n   header(s).
      \ The implementation MUST also take into account the space\n   required for
      a SACK chunk if bundling a SACK chunk with the DATA\n   chunk.\n   Fragmentation
      takes the following steps:\n   1)  The data sender MUST break the user message
      into a series of DATA\n       chunks such that each chunk plus SCTP overhead
      fits into an IP\n       datagram smaller than or equal to the association Path
      MTU.\n   2)  The transmitter MUST then assign, in sequence, a separate TSN to\n
      \      each of the DATA chunks in the series.  The transmitter assigns\n       the
      same SSN to each of the DATA chunks.  If the user indicates\n       that the
      user message is to be delivered using unordered\n       delivery, then the U
      flag of each DATA chunk of the user message\n       MUST be set to 1.\n   3)
      \ The transmitter MUST also set the B/E bits of the first DATA\n       chunk
      in the series to '10', the B/E bits of the last DATA chunk\n       in the series
      to '01', and the B/E bits of all other DATA chunks\n       in the series to
      '00'.\n   An endpoint MUST recognize fragmented DATA chunks by examining the\n
      \  B/E bits in each of the received DATA chunks, and queue the\n   fragmented
      DATA chunks for reassembly.  Once the user message is\n   reassembled, SCTP
      shall pass the reassembled user message to the\n   specific stream for possible
      reordering and final dispatching.\n   Note: If the data receiver runs out of
      buffer space while still\n   waiting for more fragments to complete the reassembly
      of the message,\n   it should dispatch part of its inbound message through a
      partial\n   delivery API (see Section 10), freeing some of its receive buffer\n
      \  space so that the rest of the message may be received.\n"
    title: 6.9.  Fragmentation and Reassembly
  - contents:
    - "6.10.  Bundling\n   An endpoint bundles chunks by simply including multiple
      chunks in one\n   outbound SCTP packet.  The total size of the resultant IP
      datagram,\n   including the SCTP packet and IP headers, MUST be less that or
      equal\n   to the current Path MTU.\n   If its peer endpoint is multi-homed,
      the sending endpoint shall\n   choose a size no larger than the latest MTU of
      the current primary\n   path.\n   When bundling control chunks with DATA chunks,
      an endpoint MUST place\n   control chunks first in the outbound SCTP packet.
      \ The transmitter\n   MUST transmit DATA chunks within an SCTP packet in increasing
      order\n   of TSN.\n   Note: Since control chunks must be placed first in a packet
      and since\n   DATA chunks must be transmitted before SHUTDOWN or SHUTDOWN ACK\n
      \  chunks, DATA chunks cannot be bundled with SHUTDOWN or SHUTDOWN ACK\n   chunks.\n
      \  Partial chunks MUST NOT be placed in an SCTP packet.  A partial chunk\n   is
      a chunk that is not completely contained in the SCTP packet; i.e.,\n   the SCTP
      packet is too short to contain all the bytes of the chunk as\n   indicated by
      the chunk length.\n   An endpoint MUST process received chunks in their order
      in the\n   packet.  The receiver uses the Chunk Length field to determine the\n
      \  end of a chunk and beginning of the next chunk taking account of the\n   fact
      that all chunks end on a 4-byte boundary.  If the receiver\n   detects a partial
      chunk, it MUST drop the chunk.\n   An endpoint MUST NOT bundle INIT, INIT ACK,
      or SHUTDOWN COMPLETE with\n   any other chunks.\n"
    title: 6.10.  Bundling
  title: 6.  User Data Transfer
- contents:
  - "7.  Congestion Control\n   Congestion control is one of the basic functions in
    SCTP.  For some\n   applications, it may be likely that adequate resources will
    be\n   allocated to SCTP traffic to ensure prompt delivery of time-critical\n
    \  data -- thus, it would appear to be unlikely, during normal\n   operations,
    that transmissions encounter severe congestion\n   conditions.  However, SCTP
    must operate under adverse operational\n   conditions, which can develop upon
    partial network failures or\n   unexpected traffic surges.  In such situations,
    SCTP must follow\n   correct congestion control steps to recover from congestion
    quickly\n   in order to get data delivered as soon as possible.  In the absence\n
    \  of network congestion, these preventive congestion control algorithms\n   should
    show no impact on the protocol performance.\n   IMPLEMENTATION NOTE: As far as
    its specific performance requirements\n   are met, an implementation is always
    allowed to adopt a more\n   conservative congestion control algorithm than the
    one defined below.\n   The congestion control algorithms used by SCTP are based
    on\n   [RFC2581].  This section describes how the algorithms defined in\n   [RFC2581]
    are adapted for use in SCTP.  We first list differences in\n   protocol designs
    between TCP and SCTP, and then describe SCTP's\n   congestion control scheme.
    \ The description will use the same\n   terminology as in TCP congestion control
    whenever appropriate.\n   SCTP congestion control is always applied to the entire
    association,\n   and not to individual streams.\n"
  - contents:
    - "7.1.  SCTP Differences from TCP Congestion Control\n   Gap Ack Blocks in the
      SCTP SACK carry the same semantic meaning as\n   the TCP SACK.  TCP considers
      the information carried in the SACK as\n   advisory information only.  SCTP
      considers the information carried in\n   the Gap Ack Blocks in the SACK chunk
      as advisory.  In SCTP, any DATA\n   chunk that has been acknowledged by SACK,
      including DATA that arrived\n   at the receiving end out of order, is not considered
      fully delivered\n   until the Cumulative TSN Ack Point passes the TSN of the
      DATA chunk\n   (i.e., the DATA chunk has been acknowledged by the Cumulative
      TSN Ack\n   field in the SACK).  Consequently, the value of cwnd controls the\n
      \  amount of outstanding data, rather than (as in the case of non-SACK\n   TCP)
      the upper bound between the highest acknowledged sequence number\n   and the
      latest DATA chunk that can be sent within the congestion\n   window.  SCTP SACK
      leads to different implementations of Fast\n   Retransmit and Fast Recovery
      than non-SACK TCP.  As an example, see\n   [FALL96].\n   The biggest difference
      between SCTP and TCP, however, is multi-\n   homing.  SCTP is designed to establish
      robust communication\n   associations between two endpoints each of which may
      be reachable by\n   more than one transport address.  Potentially different
      addresses may\n   lead to different data paths between the two endpoints; thus,
      ideally\n   one may need a separate set of congestion control parameters for
      each\n   of the paths.  The treatment here of congestion control for multi-\n
      \  homed receivers is new with SCTP and may require refinement in the\n   future.
      \ The current algorithms make the following assumptions:\n   o  The sender usually
      uses the same destination address until being\n      instructed by the upper
      layer to do otherwise; however, SCTP may\n      change to an alternate destination
      in the event an address is\n      marked inactive (see Section 8.2).  Also,
      SCTP may retransmit to a\n      different transport address than the original
      transmission.\n   o  The sender keeps a separate congestion control parameter
      set for\n      each of the destination addresses it can send to (not each\n
      \     source-destination pair but for each destination).  The parameters\n      should
      decay if the address is not used for a long enough time\n      period.\n   o
      \ For each of the destination addresses, an endpoint does slow start\n      upon
      the first transmission to that address.\n   Note: TCP guarantees in-sequence
      delivery of data to its upper-layer\n   protocol within a single TCP session.
      \ This means that when TCP\n   notices a gap in the received sequence number,
      it waits until the gap\n   is filled before delivering the data that was received
      with sequence\n   numbers higher than that of the missing data.  On the other
      hand,\n   SCTP can deliver data to its upper-layer protocol even if there is
      a\n   gap in TSN if the Stream Sequence Numbers are in sequence for a\n   particular
      stream (i.e., the missing DATA chunks are for a different\n   stream) or if
      unordered delivery is indicated.  Although this does\n   not affect cwnd, it
      might affect rwnd calculation.\n"
    title: 7.1.  SCTP Differences from TCP Congestion Control
  - contents:
    - "7.2.  SCTP Slow-Start and Congestion Avoidance\n   The slow-start and congestion
      avoidance algorithms MUST be used by an\n   endpoint to control the amount of
      data being injected into the\n   network.  The congestion control in SCTP is
      employed in regard to the\n   association, not to an individual stream.  In
      some situations, it may\n   be beneficial for an SCTP sender to be more conservative
      than the\n   algorithms allow; however, an SCTP sender MUST NOT be more aggressive\n
      \  than the following algorithms allow.\n   Like TCP, an SCTP endpoint uses
      the following three control variables\n   to regulate its transmission rate.\n
      \  o  Receiver advertised window size (rwnd, in bytes), which is set by\n      the
      receiver based on its available buffer space for incoming\n      packets.\n
      \     Note: This variable is kept on the entire association.\n   o  Congestion
      control window (cwnd, in bytes), which is adjusted by\n      the sender based
      on observed network conditions.\n      Note: This variable is maintained on
      a per-destination-address\n      basis.\n   o  Slow-start threshold (ssthresh,
      in bytes), which is used by the\n      sender to distinguish slow-start and
      congestion avoidance phases.\n      Note: This variable is maintained on a per-destination-address\n
      \     basis.\n   SCTP also requires one additional control variable,\n   partial_bytes_acked,
      which is used during congestion avoidance phase\n   to facilitate cwnd adjustment.\n
      \  Unlike TCP, an SCTP sender MUST keep a set of these control variables\n   cwnd,
      ssthresh, and partial_bytes_acked for EACH destination address\n   of its peer
      (when its peer is multi-homed).  Only one rwnd is kept\n   for the whole association
      (no matter if the peer is multi-homed or\n   has a single address).\n"
    - contents:
      - "7.2.1.  Slow-Start\n   Beginning data transmission into a network with unknown
        conditions or\n   after a sufficiently long idle period requires SCTP to probe
        the\n   network to determine the available capacity.  The slow-start\n   algorithm
        is used for this purpose at the beginning of a transfer, or\n   after repairing
        loss detected by the retransmission timer.\n   o  The initial cwnd before
        DATA transmission or after a sufficiently\n      long idle period MUST be
        set to min(4*MTU, max (2*MTU, 4380\n      bytes)).\n   o  The initial cwnd
        after a retransmission timeout MUST be no more\n      than 1*MTU.\n   o  The
        initial value of ssthresh MAY be arbitrarily high (for\n      example, implementations
        MAY use the size of the receiver\n      advertised window).\n   o  Whenever
        cwnd is greater than zero, the endpoint is allowed to\n      have cwnd bytes
        of data outstanding on that transport address.\n   o  When cwnd is less than
        or equal to ssthresh, an SCTP endpoint MUST\n      use the slow-start algorithm
        to increase cwnd only if the current\n      congestion window is being fully
        utilized, an incoming SACK\n      advances the Cumulative TSN Ack Point, and
        the data sender is not\n      in Fast Recovery.  Only when these three conditions
        are met can\n      the cwnd be increased; otherwise, the cwnd MUST not be
        increased.\n      If these conditions are met, then cwnd MUST be increased
        by, at\n      most, the lesser of 1) the total size of the previously\n      outstanding
        DATA chunk(s) acknowledged, and 2) the destination's\n      path MTU.  This
        upper bound protects against the ACK-Splitting\n      attack outlined in [SAVAGE99].\n
        \  In instances where its peer endpoint is multi-homed, if an endpoint\n   receives
        a SACK that advances its Cumulative TSN Ack Point, then it\n   should update
        its cwnd (or cwnds) apportioned to the destination\n   addresses to which
        it transmitted the acknowledged data.  However, if\n   the received SACK does
        not advance the Cumulative TSN Ack Point, the\n   endpoint MUST NOT adjust
        the cwnd of any of the destination\n   addresses.\n   Because an endpoint's
        cwnd is not tied to its Cumulative TSN Ack\n   Point, as duplicate SACKs come
        in, even though they may not advance\n   the Cumulative TSN Ack Point an endpoint
        can still use them to clock\n   out new data.  That is, the data newly acknowledged
        by the SACK\n   diminishes the amount of data now in flight to less than cwnd,
        and so\n   the current, unchanged value of cwnd now allows new data to be
        sent.\n   On the other hand, the increase of cwnd must be tied to the\n   Cumulative
        TSN Ack Point advancement as specified above.  Otherwise,\n   the duplicate
        SACKs will not only clock out new data, but also will\n   adversely clock
        out more new data than what has just left the\n   network, during a time of
        possible congestion.\n   o  When the endpoint does not transmit data on a
        given transport\n      address, the cwnd of the transport address should be
        adjusted to\n      max(cwnd/2, 4*MTU) per RTO.\n"
      title: 7.2.1.  Slow-Start
    - contents:
      - "7.2.2.  Congestion Avoidance\n   When cwnd is greater than ssthresh, cwnd
        should be incremented by\n   1*MTU per RTT if the sender has cwnd or more
        bytes of data\n   outstanding for the corresponding transport address.\n   In
        practice, an implementation can achieve this goal in the following\n   way:\n
        \  o  partial_bytes_acked is initialized to 0.\n   o  Whenever cwnd is greater
        than ssthresh, upon each SACK arrival\n      that advances the Cumulative
        TSN Ack Point, increase\n      partial_bytes_acked by the total number of
        bytes of all new chunks\n      acknowledged in that SACK including chunks
        acknowledged by the new\n      Cumulative TSN Ack and by Gap Ack Blocks.\n
        \  o  When partial_bytes_acked is equal to or greater than cwnd and\n      before
        the arrival of the SACK the sender had cwnd or more bytes\n      of data outstanding
        (i.e., before arrival of the SACK, flightsize\n      was greater than or equal
        to cwnd), increase cwnd by MTU, and\n      reset partial_bytes_acked to (partial_bytes_acked
        - cwnd).\n   o  Same as in the slow start, when the sender does not transmit
        DATA\n      on a given transport address, the cwnd of the transport address\n
        \     should be adjusted to max(cwnd / 2, 4*MTU) per RTO.\n   o  When all
        of the data transmitted by the sender has been\n      acknowledged by the
        receiver, partial_bytes_acked is initialized\n      to 0.\n"
      title: 7.2.2.  Congestion Avoidance
    - contents:
      - "7.2.3.  Congestion Control\n   Upon detection of packet losses from SACK
        (see Section 7.2.4), an\n   endpoint should do the following:\n      ssthresh
        = max(cwnd/2, 4*MTU)\n      cwnd = ssthresh\n      partial_bytes_acked = 0\n
        \  Basically, a packet loss causes cwnd to be cut in half.\n   When the T3-rtx
        timer expires on an address, SCTP should perform slow\n   start by:\n      ssthresh
        = max(cwnd/2, 4*MTU)\n      cwnd = 1*MTU\n   and ensure that no more than
        one SCTP packet will be in flight for\n   that address until the endpoint
        receives acknowledgement for\n   successful delivery of data to that address.\n"
      title: 7.2.3.  Congestion Control
    - contents:
      - "7.2.4.  Fast Retransmit on Gap Reports\n   In the absence of data loss, an
        endpoint performs delayed\n   acknowledgement.  However, whenever an endpoint
        notices a hole in the\n   arriving TSN sequence, it SHOULD start sending a
        SACK back every time\n   a packet arrives carrying data until the hole is
        filled.\n   Whenever an endpoint receives a SACK that indicates that some
        TSNs\n   are missing, it SHOULD wait for two further miss indications (via\n
        \  subsequent SACKs for a total of three missing reports) on the same\n   TSNs
        before taking action with regard to Fast Retransmit.\n   Miss indications
        SHOULD follow the HTNA (Highest TSN Newly\n   Acknowledged) algorithm.  For
        each incoming SACK, miss indications\n   are incremented only for missing
        TSNs prior to the highest TSN newly\n   acknowledged in the SACK.  A newly
        acknowledged DATA chunk is one not\n   previously acknowledged in a SACK.
        \ If an endpoint is in Fast\n   Recovery and a SACK arrives that advances
        the Cumulative TSN Ack\n   Point, the miss indications are incremented for
        all TSNs reported\n   missing in the SACK.\n   When the third consecutive
        miss indication is received for a TSN(s),\n   the data sender shall do the
        following:\n   1)  Mark the DATA chunk(s) with three miss indications for\n
        \      retransmission.\n   2)  If not in Fast Recovery, adjust the ssthresh
        and cwnd of the\n       destination address(es) to which the missing DATA
        chunks were\n       last sent, according to the formula described in Section
        7.2.3.\n   3)  Determine how many of the earliest (i.e., lowest TSN) DATA
        chunks\n       marked for retransmission will fit into a single packet, subject\n
        \      to constraint of the path MTU of the destination transport\n       address
        to which the packet is being sent.  Call this value K.\n       Retransmit
        those K DATA chunks in a single packet.  When a Fast\n       Retransmit is
        being performed, the sender SHOULD ignore the value\n       of cwnd and SHOULD
        NOT delay retransmission for this single\n       packet.\n   4)  Restart the
        T3-rtx timer only if the last SACK acknowledged the\n       lowest outstanding
        TSN number sent to that address, or the\n       endpoint is retransmitting
        the first outstanding DATA chunk sent\n       to that address.\n   5)  Mark
        the DATA chunk(s) as being fast retransmitted and thus\n       ineligible
        for a subsequent Fast Retransmit.  Those TSNs marked\n       for retransmission
        due to the Fast-Retransmit algorithm that did\n       not fit in the sent
        datagram carrying K other TSNs are also\n       marked as ineligible for a
        subsequent Fast Retransmit.  However,\n       as they are marked for retransmission
        they will be retransmitted\n       later on as soon as cwnd allows.\n   6)
        \ If not in Fast Recovery, enter Fast Recovery and mark the highest\n       outstanding
        TSN as the Fast Recovery exit point.  When a SACK\n       acknowledges all
        TSNs up to and including this exit point, Fast\n       Recovery is exited.
        \ While in Fast Recovery, the ssthresh and\n       cwnd SHOULD NOT change
        for any destinations due to a subsequent\n       Fast Recovery event (i.e.,
        one SHOULD NOT reduce the cwnd further\n       due to a subsequent Fast Retransmit).\n
        \  Note: Before the above adjustments, if the received SACK also\n   acknowledges
        new DATA chunks and advances the Cumulative TSN Ack\n   Point, the cwnd adjustment
        rules defined in Section 7.2.1 and Section\n   7.2.2 must be applied first.\n
        \  A straightforward implementation of the above keeps a counter for\n   each
        TSN hole reported by a SACK.  The counter increments for each\n   consecutive
        SACK reporting the TSN hole.  After reaching 3 and\n   starting the Fast-Retransmit
        procedure, the counter resets to 0.\n   Because cwnd in SCTP indirectly bounds
        the number of outstanding\n   TSN's, the effect of TCP Fast Recovery is achieved
        automatically with\n   no adjustment to the congestion control window size.\n"
      title: 7.2.4.  Fast Retransmit on Gap Reports
    title: 7.2.  SCTP Slow-Start and Congestion Avoidance
  - contents:
    - "7.3.  Path MTU Discovery\n   [RFC4821], [RFC1981], and [RFC1191] specify \"Packetization
      Layer Path\n   MTU Discovery\", whereby an endpoint maintains an estimate of
      the\n   maximum transmission unit (MTU) along a given Internet path and\n   refrains
      from sending packets along that path that exceed the MTU,\n   other than occasional
      attempts to probe for a change in the Path MTU\n   (PMTU).  [RFC4821] is thorough
      in its discussion of the MTU discovery\n   mechanism and strategies for determining
      the current end-to-end MTU\n   setting as well as detecting changes in this
      value.\n   An endpoint SHOULD apply these techniques, and SHOULD do so on a\n
      \  per-destination-address basis.\n   There are two important SCTP-specific
      points regarding Path MTU\n   discovery:\n   1)  SCTP associations can span
      multiple addresses.  An endpoint MUST\n       maintain separate MTU estimates
      for each destination address of\n       its peer.\n   2)  The sender should
      track an association PMTU that will be the\n       smallest PMTU discovered
      for all of the peer's destination\n       addresses.  When fragmenting messages
      into multiple parts this\n       association PMTU should be used to calculate
      the size of each\n       fragment.  This will allow retransmissions to be seamlessly
      sent\n       to an alternate address without encountering IP fragmentation.\n"
    title: 7.3.  Path MTU Discovery
  title: 7.  Congestion Control
- contents:
  - '8.  Fault Management

    '
  - contents:
    - "8.1.  Endpoint Failure Detection\n   An endpoint shall keep a counter on the
      total number of consecutive\n   retransmissions to its peer (this includes retransmissions
      to all the\n   destination transport addresses of the peer if it is multi-homed),\n
      \  including unacknowledged HEARTBEAT chunks.  If the value of this\n   counter
      exceeds the limit indicated in the protocol parameter\n   'Association.Max.Retrans',
      the endpoint shall consider the peer\n   endpoint unreachable and shall stop
      transmitting any more data to it\n   (and thus the association enters the CLOSED
      state).  In addition, the\n   endpoint MAY report the failure to the upper layer
      and optionally\n   report back all outstanding user data remaining in its outbound\n
      \  queue.  The association is automatically closed when the peer\n   endpoint
      becomes unreachable.\n   The counter shall be reset each time a DATA chunk sent
      to that peer\n   endpoint is acknowledged (by the reception of a SACK) or a
      HEARTBEAT\n   ACK is received from the peer endpoint.\n"
    title: 8.1.  Endpoint Failure Detection
  - contents:
    - "8.2.  Path Failure Detection\n   When its peer endpoint is multi-homed, an
      endpoint should keep an\n   error counter for each of the destination transport
      addresses of the\n   peer endpoint.\n   Each time the T3-rtx timer expires on
      any address, or when a\n   HEARTBEAT sent to an idle address is not acknowledged
      within an RTO,\n   the error counter of that destination address will be incremented.\n
      \  When the value in the error counter exceeds the protocol parameter\n   'Path.Max.Retrans'
      of that destination address, the endpoint should\n   mark the destination transport
      address as inactive, and a\n   notification SHOULD be sent to the upper layer.\n
      \  When an outstanding TSN is acknowledged or a HEARTBEAT sent to that\n   address
      is acknowledged with a HEARTBEAT ACK, the endpoint shall\n   clear the error
      counter of the destination transport address to which\n   the DATA chunk was
      last sent (or HEARTBEAT was sent).  When the peer\n   endpoint is multi-homed
      and the last chunk sent to it was a\n   retransmission to an alternate address,
      there exists an ambiguity as\n   to whether or not the acknowledgement should
      be credited to the\n   address of the last chunk sent.  However, this ambiguity
      does not\n   seem to bear any significant consequence to SCTP behavior.  If
      this\n   ambiguity is undesirable, the transmitter may choose not to clear the\n
      \  error counter if the last chunk sent was a retransmission.\n   Note: When
      configuring the SCTP endpoint, the user should avoid\n   having the value of
      'Association.Max.Retrans' larger than the\n   summation of the 'Path.Max.Retrans'
      of all the destination addresses\n   for the remote endpoint.  Otherwise, all
      the destination addresses\n   may become inactive while the endpoint still considers
      the peer\n   endpoint reachable.  When this condition occurs, how SCTP chooses
      to\n   function is implementation specific.\n   When the primary path is marked
      inactive (due to excessive\n   retransmissions, for instance), the sender MAY
      automatically transmit\n   new packets to an alternate destination address if
      one exists and is\n   active.  If more than one alternate address is active
      when the\n   primary path is marked inactive, only ONE transport address SHOULD
      be\n   chosen and used as the new destination transport address.\n"
    title: 8.2.  Path Failure Detection
  - contents:
    - "8.3.  Path Heartbeat\n   By default, an SCTP endpoint SHOULD monitor the reachability
      of the\n   idle destination transport address(es) of its peer by sending a\n
      \  HEARTBEAT chunk periodically to the destination transport\n   address(es).
      \ HEARTBEAT sending MAY begin upon reaching the\n   ESTABLISHED state and is
      discontinued after sending either SHUTDOWN\n   or SHUTDOWN-ACK.  A receiver
      of a HEARTBEAT MUST respond to a\n   HEARTBEAT with a HEARTBEAT-ACK after entering
      the COOKIE-ECHOED state\n   (INIT sender) or the ESTABLISHED state (INIT receiver),
      up until\n   reaching the SHUTDOWN-SENT state (SHUTDOWN sender) or the SHUTDOWN-\n
      \  ACK-SENT state (SHUTDOWN receiver).\n   A destination transport address is
      considered \"idle\" if no new chunk\n   that can be used for updating path RTT
      (usually including first\n   transmission DATA, INIT, COOKIE ECHO, HEARTBEAT,
      etc.) and no\n   HEARTBEAT has been sent to it within the current heartbeat
      period of\n   that address.  This applies to both active and inactive destination\n
      \  addresses.\n   The upper layer can optionally initiate the following functions:\n
      \  A) Disable heartbeat on a specific destination transport address of a\n      given
      association,\n   B) Change the HB.interval,\n   C) Re-enable heartbeat on a
      specific destination transport address of\n      a given association, and\n
      \  D) Request an on-demand HEARTBEAT on a specific destination transport\n      address
      of a given association.\n   The endpoint should increment the respective error
      counter of the\n   destination transport address each time a HEARTBEAT is sent
      to that\n   address and not acknowledged within one RTO.\n   When the value
      of this counter reaches the protocol parameter\n   'Path.Max.Retrans', the endpoint
      should mark the corresponding\n   destination address as inactive if it is not
      so marked, and may also\n   optionally report to the upper layer the change
      of reachability of\n   this destination address.  After this, the endpoint should
      continue\n   HEARTBEAT on this destination address but should stop increasing
      the\n   counter.\n   The sender of the HEARTBEAT chunk should include in the
      Heartbeat\n   Information field of the chunk the current time when the packet
      is\n   sent out and the destination address to which the packet is sent.\n   IMPLEMENTATION
      NOTE: An alternative implementation of the heartbeat\n   mechanism that can
      be used is to increment the error counter variable\n   every time a HEARTBEAT
      is sent to a destination.  Whenever a\n   HEARTBEAT ACK arrives, the sender
      SHOULD clear the error counter of\n   the destination that the HEARTBEAT was
      sent to.  This in effect would\n   clear the previously stroked error (and any
      other error counts as\n   well).\n   The receiver of the HEARTBEAT should immediately
      respond with a\n   HEARTBEAT ACK that contains the Heartbeat Information TLV,
      together\n   with any other received TLVs, copied unchanged from the received\n
      \  HEARTBEAT chunk.\n   Upon the receipt of the HEARTBEAT ACK, the sender of
      the HEARTBEAT\n   should clear the error counter of the destination transport
      address\n   to which the HEARTBEAT was sent, and mark the destination transport\n
      \  address as active if it is not so marked.  The endpoint may\n   optionally
      report to the upper layer when an inactive destination\n   address is marked
      as active due to the reception of the latest\n   HEARTBEAT ACK.  The receiver
      of the HEARTBEAT ACK must also clear the\n   association overall error count
      as well (as defined in Section 8.1).\n   The receiver of the HEARTBEAT ACK should
      also perform an RTT\n   measurement for that destination transport address using
      the time\n   value carried in the HEARTBEAT ACK chunk.\n   On an idle destination
      address that is allowed to heartbeat, it is\n   recommended that a HEARTBEAT
      chunk is sent once per RTO of that\n   destination address plus the protocol
      parameter 'HB.interval', with\n   jittering of +/- 50% of the RTO value, and
      exponential backoff of the\n   RTO if the previous HEARTBEAT is unanswered.\n
      \  A primitive is provided for the SCTP user to change the HB.interval\n   and
      turn on or off the heartbeat on a given destination address.  The\n   heartbeat
      interval set by the SCTP user is added to the RTO of that\n   destination (including
      any exponential backoff).  Only one heartbeat\n   should be sent each time the
      heartbeat timer expires (if multiple\n   destinations are idle).  It is an implementation
      decision on how to\n   choose which of the candidate idle destinations to heartbeat
      to (if\n   more than one destination is idle).\n   Note: When tuning the heartbeat
      interval, there is a side effect that\n   SHOULD be taken into account.  When
      this value is increased, i.e.,\n   the HEARTBEAT takes longer, the detection
      of lost ABORT messages\n   takes longer as well.  If a peer endpoint ABORTs
      the association for\n   any reason and the ABORT chunk is lost, the local endpoint
      will only\n   discover the lost ABORT by sending a DATA chunk or HEARTBEAT chunk\n
      \  (thus causing the peer to send another ABORT).  This must be\n   considered
      when tuning the HEARTBEAT timer.  If the HEARTBEAT is\n   disabled, only sending
      DATA to the association will discover a lost\n   ABORT from the peer.\n"
    title: 8.3.  Path Heartbeat
  - contents:
    - "8.4.  Handle \"Out of the Blue\" Packets\n   An SCTP packet is called an \"out
      of the blue\" (OOTB) packet if it is\n   correctly formed (i.e., passed the
      receiver's CRC32c check; see\n   Section 6.8), but the receiver is not able
      to identify the\n   association to which this packet belongs.\n   The receiver
      of an OOTB packet MUST do the following:\n   1)  If the OOTB packet is to or
      from a non-unicast address, a\n       receiver SHOULD silently discard the packet.
      \ Otherwise,\n   2)  If the OOTB packet contains an ABORT chunk, the receiver
      MUST\n       silently discard the OOTB packet and take no further action.\n
      \      Otherwise,\n   3)  If the packet contains an INIT chunk with a Verification
      Tag set\n       to '0', process it as described in Section 5.1.  If, for whatever\n
      \      reason, the INIT cannot be processed normally and an ABORT has to\n       be
      sent in response, the Verification Tag of the packet\n       containing the
      ABORT chunk MUST be the Initiate Tag of the\n       received INIT chunk, and
      the T bit of the ABORT chunk has to be\n       set to 0, indicating that the
      Verification Tag is NOT reflected.\n   4)  If the packet contains a COOKIE ECHO
      in the first chunk, process\n       it as described in Section 5.1.  Otherwise,\n
      \  5)  If the packet contains a SHUTDOWN ACK chunk, the receiver should\n       respond
      to the sender of the OOTB packet with a SHUTDOWN\n       COMPLETE.  When sending
      the SHUTDOWN COMPLETE, the receiver of\n       the OOTB packet must fill in
      the Verification Tag field of the\n       outbound packet with the Verification
      Tag received in the\n       SHUTDOWN ACK and set the T bit in the Chunk Flags
      to indicate\n       that the Verification Tag is reflected.  Otherwise,\n   6)
      \ If the packet contains a SHUTDOWN COMPLETE chunk, the receiver\n       should
      silently discard the packet and take no further action.\n       Otherwise,\n
      \  7)  If the packet contains a \"Stale Cookie\" ERROR or a COOKIE ACK,\n       the
      SCTP packet should be silently discarded.  Otherwise,\n   8)  The receiver should
      respond to the sender of the OOTB packet with\n       an ABORT.  When sending
      the ABORT, the receiver of the OOTB\n       packet MUST fill in the Verification
      Tag field of the outbound\n       packet with the value found in the Verification
      Tag field of the\n       OOTB packet and set the T bit in the Chunk Flags to
      indicate that\n       the Verification Tag is reflected.  After sending this
      ABORT, the\n       receiver of the OOTB packet shall discard the OOTB packet
      and\n       take no further action.\n"
    title: 8.4.  Handle "Out of the Blue" Packets
  - contents:
    - "8.5.  Verification Tag\n   The Verification Tag rules defined in this section
      apply when sending\n   or receiving SCTP packets that do not contain an INIT,
      SHUTDOWN\n   COMPLETE, COOKIE ECHO (see Section 5.1), ABORT, or SHUTDOWN ACK\n
      \  chunk.  The rules for sending and receiving SCTP packets containing\n   one
      of these chunk types are discussed separately in Section 8.5.1.\n   When sending
      an SCTP packet, the endpoint MUST fill in the\n   Verification Tag field of
      the outbound packet with the tag value in\n   the Initiate Tag parameter of
      the INIT or INIT ACK received from its\n   peer.\n   When receiving an SCTP
      packet, the endpoint MUST ensure that the\n   value in the Verification Tag
      field of the received SCTP packet\n   matches its own tag.  If the received
      Verification Tag value does not\n   match the receiver's own tag value, the
      receiver shall silently\n   discard the packet and shall not process it any
      further except for\n   those cases listed in Section 8.5.1 below.\n"
    - contents:
      - "8.5.1.  Exceptions in Verification Tag Rules\n   A) Rules for packet carrying
        INIT:\n   -   The sender MUST set the Verification Tag of the packet to 0.\n
        \  -   When an endpoint receives an SCTP packet with the Verification\n       Tag
        set to 0, it should verify that the packet contains only an\n       INIT chunk.
        \ Otherwise, the receiver MUST silently discard the\n       packet.\n   B)
        Rules for packet carrying ABORT:\n   -   The endpoint MUST always fill in
        the Verification Tag field of\n       the outbound packet with the destination
        endpoint's tag value, if\n       it is known.\n   -   If the ABORT is sent
        in response to an OOTB packet, the endpoint\n       MUST follow the procedure
        described in Section 8.4.\n   -   The receiver of an ABORT MUST accept the
        packet if the\n       Verification Tag field of the packet matches its own
        tag and the\n       T bit is not set OR if it is set to its peer's tag and
        the T bit\n       is set in the Chunk Flags.  Otherwise, the receiver MUST
        silently\n       discard the packet and take no further action.\n   C) Rules
        for packet carrying SHUTDOWN COMPLETE:\n   -   When sending a SHUTDOWN COMPLETE,
        if the receiver of the SHUTDOWN\n       ACK has a TCB, then the destination
        endpoint's tag MUST be used,\n       and the T bit MUST NOT be set.  Only
        where no TCB exists should\n       the sender use the Verification Tag from
        the SHUTDOWN ACK, and\n       MUST set the T bit.\n   -   The receiver of
        a SHUTDOWN COMPLETE shall accept the packet if\n       the Verification Tag
        field of the packet matches its own tag and\n       the T bit is not set OR
        if it is set to its peer's tag and the T\n       bit is set in the Chunk Flags.
        \ Otherwise, the receiver MUST\n       silently discard the packet and take
        no further action.  An\n       endpoint MUST ignore the SHUTDOWN COMPLETE
        if it is not in the\n       SHUTDOWN-ACK-SENT state.\n   D) Rules for packet
        carrying a COOKIE ECHO\n   -   When sending a COOKIE ECHO, the endpoint MUST
        use the value of\n       the Initiate Tag received in the INIT ACK.\n   -
        \  The receiver of a COOKIE ECHO follows the procedures in Section\n       5.\n
        \  E) Rules for packet carrying a SHUTDOWN ACK\n   -   If the receiver is
        in COOKIE-ECHOED or COOKIE-WAIT state the\n       procedures in Section 8.4
        SHOULD be followed; in other words, it\n       should be treated as an Out
        Of The Blue packet.\n"
      title: 8.5.1.  Exceptions in Verification Tag Rules
    title: 8.5.  Verification Tag
  title: 8.  Fault Management
- contents:
  - "9.  Termination of Association\n   An endpoint should terminate its association
    when it exits from\n   service.  An association can be terminated by either abort
    or\n   shutdown.  An abort of an association is abortive by definition in\n   that
    any data pending on either end of the association is discarded\n   and not delivered
    to the peer.  A shutdown of an association is\n   considered a graceful close
    where all data in queue by either\n   endpoint is delivered to the respective
    peers.  However, in the case\n   of a shutdown, SCTP does not support a half-open
    state (like TCP)\n   wherein one side may continue sending data while the other
    end is\n   closed.  When either endpoint performs a shutdown, the association
    on\n   each peer will stop accepting new data from its user and only deliver\n
    \  data in queue at the time of sending or receiving the SHUTDOWN chunk.\n"
  - contents:
    - "9.1.  Abort of an Association\n   When an endpoint decides to abort an existing
      association, it MUST\n   send an ABORT chunk to its peer endpoint.  The sender
      MUST fill in\n   the peer's Verification Tag in the outbound packet and MUST
      NOT\n   bundle any DATA chunk with the ABORT.  If the association is aborted\n
      \  on request of the upper layer, a User-Initiated Abort error cause\n   (see
      Section 3.3.10.12) SHOULD be present in the ABORT chunk.\n   An endpoint MUST
      NOT respond to any received packet that contains an\n   ABORT chunk (also see
      Section 8.4).\n   An endpoint receiving an ABORT MUST apply the special Verification\n
      \  Tag check rules described in Section 8.5.1.\n   After checking the Verification
      Tag, the receiving endpoint MUST\n   remove the association from its record
      and SHOULD report the\n   termination to its upper layer.  If a User-Initiated
      Abort error\n   cause is present in the ABORT chunk, the Upper Layer Abort Reason\n
      \  SHOULD be made available to the upper layer.\n"
    title: 9.1.  Abort of an Association
  - contents:
    - "9.2.  Shutdown of an Association\n   Using the SHUTDOWN primitive (see Section
      10.1), the upper layer of\n   an endpoint in an association can gracefully close
      the association.\n   This will allow all outstanding DATA chunks from the peer
      of the\n   shutdown initiator to be delivered before the association terminates.\n
      \  Upon receipt of the SHUTDOWN primitive from its upper layer, the\n   endpoint
      enters the SHUTDOWN-PENDING state and remains there until\n   all outstanding
      data has been acknowledged by its peer.  The endpoint\n   accepts no new data
      from its upper layer, but retransmits data to the\n   far end if necessary to
      fill gaps.\n   Once all its outstanding data has been acknowledged, the endpoint\n
      \  shall send a SHUTDOWN chunk to its peer including in the Cumulative\n   TSN
      Ack field the last sequential TSN it has received from the peer.\n   It shall
      then start the T2-shutdown timer and enter the SHUTDOWN-SENT\n   state.  If
      the timer expires, the endpoint must resend the SHUTDOWN\n   with the updated
      last sequential TSN received from its peer.\n   The rules in Section 6.3 MUST
      be followed to determine the proper\n   timer value for T2-shutdown.  To indicate
      any gaps in TSN, the\n   endpoint may also bundle a SACK with the SHUTDOWN chunk
      in the same\n   SCTP packet.\n   An endpoint should limit the number of retransmissions
      of the\n   SHUTDOWN chunk to the protocol parameter 'Association.Max.Retrans'.\n
      \  If this threshold is exceeded, the endpoint should destroy the TCB\n   and
      MUST report the peer endpoint unreachable to the upper layer (and\n   thus the
      association enters the CLOSED state).  The reception of any\n   packet from
      its peer (i.e., as the peer sends all of its queued DATA\n   chunks) should
      clear the endpoint's retransmission count and restart\n   the T2-shutdown timer,
      giving its peer ample opportunity to transmit\n   all of its queued DATA chunks
      that have not yet been sent.\n   Upon reception of the SHUTDOWN, the peer endpoint
      shall\n   -  enter the SHUTDOWN-RECEIVED state,\n   -  stop accepting new data
      from its SCTP user, and\n   -  verify, by checking the Cumulative TSN Ack field
      of the chunk,\n      that all its outstanding DATA chunks have been received
      by the\n      SHUTDOWN sender.\n   Once an endpoint has reached the SHUTDOWN-RECEIVED
      state, it MUST NOT\n   send a SHUTDOWN in response to a ULP request, and should
      discard\n   subsequent SHUTDOWN chunks.\n   If there are still outstanding DATA
      chunks left, the SHUTDOWN\n   receiver MUST continue to follow normal data transmission
      procedures\n   defined in Section 6, until all outstanding DATA chunks are\n
      \  acknowledged; however, the SHUTDOWN receiver MUST NOT accept new data\n   from
      its SCTP user.\n   While in the SHUTDOWN-SENT state, the SHUTDOWN sender MUST\n
      \  immediately respond to each received packet containing one or more\n   DATA
      chunks with a SHUTDOWN chunk and restart the T2-shutdown timer.\n   If a SHUTDOWN
      chunk by itself cannot acknowledge all of the received\n   DATA chunks (i.e.,
      there are TSNs that can be acknowledged that are\n   larger than the cumulative
      TSN, and thus gaps exist in the TSN\n   sequence), or if duplicate TSNs have
      been received, then a SACK chunk\n   MUST also be sent.\n   The sender of the
      SHUTDOWN MAY also start an overall guard timer\n   'T5-shutdown-guard' to bound
      the overall time for the shutdown\n   sequence.  At the expiration of this timer,
      the sender SHOULD abort\n   the association by sending an ABORT chunk.  If the
      'T5-shutdown-\n   guard' timer is used, it SHOULD be set to the recommended
      value of 5\n   times 'RTO.Max'.\n   If the receiver of the SHUTDOWN has no more
      outstanding DATA chunks,\n   the SHUTDOWN receiver MUST send a SHUTDOWN ACK
      and start a T2-\n   shutdown timer of its own, entering the SHUTDOWN-ACK-SENT
      state.  If\n   the timer expires, the endpoint must resend the SHUTDOWN ACK.\n
      \  The sender of the SHUTDOWN ACK should limit the number of\n   retransmissions
      of the SHUTDOWN ACK chunk to the protocol parameter\n   'Association.Max.Retrans'.
      \ If this threshold is exceeded, the\n   endpoint should destroy the TCB and
      may report the peer endpoint\n   unreachable to the upper layer (and thus the
      association enters the\n   CLOSED state).\n   Upon the receipt of the SHUTDOWN
      ACK, the SHUTDOWN sender shall stop\n   the T2-shutdown timer, send a SHUTDOWN
      COMPLETE chunk to its peer,\n   and remove all record of the association.\n
      \  Upon reception of the SHUTDOWN COMPLETE chunk, the endpoint will\n   verify
      that it is in the SHUTDOWN-ACK-SENT state; if it is not, the\n   chunk should
      be discarded.  If the endpoint is in the SHUTDOWN-ACK-\n   SENT state, the endpoint
      should stop the T2-shutdown timer and remove\n   all knowledge of the association
      (and thus the association enters the\n   CLOSED state).\n   An endpoint SHOULD
      ensure that all its outstanding DATA chunks have\n   been acknowledged before
      initiating the shutdown procedure.\n   An endpoint should reject any new data
      request from its upper layer\n   if it is in the SHUTDOWN-PENDING, SHUTDOWN-SENT,
      SHUTDOWN-RECEIVED,\n   or SHUTDOWN-ACK-SENT state.\n   If an endpoint is in
      the SHUTDOWN-ACK-SENT state and receives an INIT\n   chunk (e.g., if the SHUTDOWN
      COMPLETE was lost) with source and\n   destination transport addresses (either
      in the IP addresses or in the\n   INIT chunk) that belong to this association,
      it should discard the\n   INIT chunk and retransmit the SHUTDOWN ACK chunk.\n
      \  Note: Receipt of an INIT with the same source and destination IP\n   addresses
      as used in transport addresses assigned to an endpoint but\n   with a different
      port number indicates the initialization of a\n   separate association.\n   The
      sender of the INIT or COOKIE ECHO should respond to the receipt\n   of a SHUTDOWN
      ACK with a stand-alone SHUTDOWN COMPLETE in an SCTP\n   packet with the Verification
      Tag field of its common header set to\n   the same tag that was received in
      the SHUTDOWN ACK packet.  This is\n   considered an Out of the Blue packet as
      defined in Section 8.4.  The\n   sender of the INIT lets T1-init continue running
      and remains in the\n   COOKIE-WAIT or COOKIE-ECHOED state.  Normal T1-init timer
      expiration\n   will cause the INIT or COOKIE chunk to be retransmitted and thus\n
      \  start a new association.\n   If a SHUTDOWN is received in the COOKIE-WAIT
      or COOKIE ECHOED state,\n   the SHUTDOWN chunk SHOULD be silently discarded.\n
      \  If an endpoint is in the SHUTDOWN-SENT state and receives a SHUTDOWN\n   chunk
      from its peer, the endpoint shall respond immediately with a\n   SHUTDOWN ACK
      to its peer, and move into the SHUTDOWN-ACK-SENT state\n   restarting its T2-shutdown
      timer.\n   If an endpoint is in the SHUTDOWN-ACK-SENT state and receives a\n
      \  SHUTDOWN ACK, it shall stop the T2-shutdown timer, send a SHUTDOWN\n   COMPLETE
      chunk to its peer, and remove all record of the association.\n"
    title: 9.2.  Shutdown of an Association
  title: 9.  Termination of Association
- contents:
  - "10.  Interface with Upper Layer\n   The Upper Layer Protocols (ULPs) shall request
    services by passing\n   primitives to SCTP and shall receive notifications from
    SCTP for\n   various events.\n   The primitives and notifications described in
    this section should be\n   used as a guideline for implementing SCTP.  The following
    functional\n   description of ULP interface primitives is shown for illustrative\n
    \  purposes.  Different SCTP implementations may have different ULP\n   interfaces.
    \ However, all SCTPs must provide a certain minimum set of\n   services to guarantee
    that all SCTP implementations can support the\n   same protocol hierarchy.\n"
  - contents:
    - "10.1.  ULP-to-SCTP\n   The following sections functionally characterize a ULP/SCTP\n
      \  interface.  The notation used is similar to most procedure or\n   function
      calls in high-level languages.\n   The ULP primitives described below specify
      the basic functions that\n   SCTP must perform to support inter-process communication.
      \ Individual\n   implementations must define their own exact format, and may
      provide\n   combinations or subsets of the basic functions in single calls.\n
      \  A) Initialize\n      Format: INITIALIZE ([local port],[local eligible address
      list])->\n      local SCTP instance name\n   This primitive allows SCTP to initialize
      its internal data structures\n   and allocate necessary resources for setting
      up its operation\n   environment.  Once SCTP is initialized, ULP can communicate
      directly\n   with other endpoints without re-invoking this primitive.\n   SCTP
      will return a local SCTP instance name to the ULP.\n   Mandatory attributes:\n
      \  None.\n   Optional attributes:\n   The following types of attributes may
      be passed along with the\n   primitive:\n   o  local port - SCTP port number,
      if ULP wants it to be specified.\n   o  local eligible address list - an address
      list that the local SCTP\n      endpoint should bind.  By default, if an address
      list is not\n      included, all IP addresses assigned to the host should be
      used by\n      the local endpoint.\n   IMPLEMENTATION NOTE: If this optional
      attribute is supported by an\n   implementation, it will be the responsibility
      of the implementation\n   to enforce that the IP source address field of any
      SCTP packets sent\n   out by this endpoint contains one of the IP addresses
      indicated in\n   the local eligible address list.\n   B) Associate\n      Format:
      ASSOCIATE(local SCTP instance name,\n              destination transport addr,
      outbound stream count)\n      -> association id [,destination transport addr
      list]\n            [,outbound stream count]\n   This primitive allows the upper
      layer to initiate an association to a\n   specific peer endpoint.\n   The peer
      endpoint shall be specified by one of the transport\n   addresses that defines
      the endpoint (see Section 1.3).  If the local\n   SCTP instance has not been
      initialized, the ASSOCIATE is considered\n   an error.\n   An association id,
      which is a local handle to the SCTP association,\n   will be returned on successful
      establishment of the association.  If\n   SCTP is not able to open an SCTP association
      with the peer endpoint,\n   an error is returned.\n   Other association parameters
      may be returned, including the complete\n   destination transport addresses
      of the peer as well as the outbound\n   stream count of the local endpoint.
      \ One of the transport addresses\n   from the returned destination addresses
      will be selected by the local\n   endpoint as default primary path for sending
      SCTP packets to this\n   peer.  The returned \"destination transport addr list\"
      can be used by\n   the ULP to change the default primary path or to force sending
      a\n   packet to a specific transport address.\n   IMPLEMENTATION NOTE: If ASSOCIATE
      primitive is implemented as a\n   blocking function call, the ASSOCIATE primitive
      can return\n   association parameters in addition to the association id upon\n
      \  successful establishment.  If ASSOCIATE primitive is implemented as a\n   non-blocking
      call, only the association id shall be returned and\n   association parameters
      shall be passed using the COMMUNICATION UP\n   notification.\n   Mandatory attributes:\n
      \  o  local SCTP instance name - obtained from the INITIALIZE operation.\n   o
      \ destination transport addr - specified as one of the transport\n      addresses
      of the peer endpoint with which the association is to be\n      established.\n
      \  o  outbound stream count - the number of outbound streams the ULP\n      would
      like to open towards this peer endpoint.\n   Optional attributes:\n   None.\n
      \  C) Shutdown\n      Format: SHUTDOWN(association id)\n      -> result\n   Gracefully
      closes an association.  Any locally queued user data will\n   be delivered to
      the peer.  The association will be terminated only\n   after the peer acknowledges
      all the SCTP packets sent.  A success\n   code will be returned on successful
      termination of the association.\n   If attempting to terminate the association
      results in a failure, an\n   error code shall be returned.\n   Mandatory attributes:\n
      \  o association id - local handle to the SCTP association.\n   Optional attributes:\n
      \  None.\n   D) Abort\n      Format: ABORT(association id [, Upper Layer Abort
      Reason]) ->\n      result\n   Ungracefully closes an association.  Any locally
      queued user data\n   will be discarded, and an ABORT chunk is sent to the peer.
      \ A success\n   code will be returned on successful abort of the association.
      \ If\n   attempting to abort the association results in a failure, an error\n
      \  code shall be returned.\n   Mandatory attributes:\n   o association id -
      local handle to the SCTP association.\n   Optional attributes:\n   o Upper Layer
      Abort Reason - reason of the abort to be passed to the\n   peer.\n   None.\n
      \  E) Send\n    Format: SEND(association id, buffer address, byte count [,context]\n
      \           [,stream id] [,life time] [,destination transport address]\n            [,unordered
      flag] [,no-bundle flag] [,payload protocol-id] )\n    -> result\n   This is
      the main method to send user data via SCTP.\n   Mandatory attributes:\n   o
      \ association id - local handle to the SCTP association.\n   o  buffer address
      - the location where the user message to be\n      transmitted is stored.\n
      \  o  byte count - the size of the user data in number of bytes.\n   Optional
      attributes:\n   o  context - an optional 32-bit integer that will be carried
      in the\n      sending failure notification to the ULP if the transportation
      of\n      this user message fails.\n   o  stream id - to indicate which stream
      to send the data on.  If not\n      specified, stream 0 will be used.\n   o
      \ life time - specifies the life time of the user data.  The user\n      data
      will not be sent by SCTP after the life time expires.  This\n      parameter
      can be used to avoid efforts to transmit stale user\n      messages.  SCTP notifies
      the ULP if the data cannot be initiated\n      to transport (i.e., sent to the
      destination via SCTP's send\n      primitive) within the life time variable.
      \ However, the user data\n      will be transmitted if SCTP has attempted to
      transmit a chunk\n      before the life time expired.\n   IMPLEMENTATION NOTE:
      In order to better support the data life time\n   option, the transmitter may
      hold back the assigning of the TSN number\n   to an outbound DATA chunk to the
      last moment.  And, for\n   implementation simplicity, once a TSN number has
      been assigned the\n   sender should consider the send of this DATA chunk as
      committed,\n   overriding any life time option attached to the DATA chunk.\n
      \  o  destination transport address - specified as one of the\n      destination
      transport addresses of the peer endpoint to which this\n      packet should
      be sent.  Whenever possible, SCTP should use this\n      destination transport
      address for sending the packets, instead of\n      the current primary path.\n
      \  o  unordered flag - this flag, if present, indicates that the user\n      would
      like the data delivered in an unordered fashion to the peer\n      (i.e., the
      U flag is set to 1 on all DATA chunks carrying this\n      message).\n   o  no-bundle
      flag - instructs SCTP not to bundle this user data with\n      other outbound
      DATA chunks.  SCTP MAY still bundle even when this\n      flag is present, when
      faced with network congestion.\n   o  payload protocol-id - a 32-bit unsigned
      integer that is to be\n      passed to the peer indicating the type of payload
      protocol data\n      being transmitted.  This value is passed as opaque data
      by SCTP.\n   F) Set Primary\n      Format: SETPRIMARY(association id, destination
      transport address,\n                         [source transport address] )\n
      \     -> result\n   Instructs the local SCTP to use the specified destination
      transport\n   address as the primary path for sending packets.\n   The result
      of attempting this operation shall be returned.  If the\n   specified destination
      transport address is not present in the\n   \"destination transport address
      list\" returned earlier in an associate\n   command or communication up notification,
      an error shall be returned.\n   Mandatory attributes:\n   o  association id
      - local handle to the SCTP association.\n   o  destination transport address
      - specified as one of the transport\n      addresses of the peer endpoint, which
      should be used as the\n      primary address for sending packets.  This overrides
      the current\n      primary address information maintained by the local SCTP
      endpoint.\n   Optional attributes:\n   o  source transport address - optionally,
      some implementations may\n      allow you to set the default source address
      placed in all outgoing\n      IP datagrams.\n   G) Receive\n    Format: RECEIVE(association
      id, buffer address, buffer size\n            [,stream id])\n    -> byte count
      [,transport address] [,stream id] [,stream sequence\n       number] [,partial
      flag] [,delivery number] [,payload protocol-id]\n   This primitive shall read
      the first user message in the SCTP in-queue\n   into the buffer specified by
      ULP, if there is one available.  The\n   size of the message read, in bytes,
      will be returned.  It may,\n   depending on the specific implementation, also
      return other\n   information such as the sender's address, the stream id on
      which it\n   is received, whether there are more messages available for retrieval,\n
      \  etc.  For ordered messages, their Stream Sequence Number may also be\n   returned.\n
      \  Depending upon the implementation, if this primitive is invoked when\n   no
      message is available the implementation should return an\n   indication of this
      condition or should block the invoking process\n   until data does become available.\n
      \  Mandatory attributes:\n   o  association id - local handle to the SCTP association\n
      \  o  buffer address - the memory location indicated by the ULP to store\n      the
      received message.\n   o  buffer size - the maximum size of data to be received,
      in bytes.\n   Optional attributes:\n   o  stream id - to indicate which stream
      to receive the data on.\n   o  Stream Sequence Number - the Stream Sequence
      Number assigned by\n      the sending SCTP peer.\n   o  partial flag - if this
      returned flag is set to 1, then this\n      Receive contains a partial delivery
      of the whole message.  When\n      this flag is set, the stream id and Stream
      Sequence Number MUST\n      accompany this receive.  When this flag is set to
      0, it indicates\n      that no more deliveries will be received for this Stream
      Sequence\n      Number.\n   o  payload protocol-id - a 32-bit unsigned integer
      that is received\n      from the peer indicating the type of payload protocol
      of the\n      received data.  This value is passed as opaque data by SCTP.\n
      \  H) Status\n      Format: STATUS(association id)\n      -> status data\n   This
      primitive should return a data block containing the following\n   information:\n
      \     association connection state,\n      destination transport address list,\n
      \     destination transport address reachability states,\n      current receiver
      window size,\n      current congestion window sizes,\n      number of unacknowledged
      DATA chunks,\n      number of DATA chunks pending receipt,\n      primary path,\n
      \     most recent SRTT on primary path,\n      RTO on primary path,\n      SRTT
      and RTO on other destination addresses, etc.\n   Mandatory attributes:\n   o
      association id - local handle to the SCTP association.\n   Optional attributes:\n
      \  None.\n   I) Change Heartbeat\n      Format: CHANGE HEARTBEAT(association
      id,\n              destination transport address, new state [,interval])\n      ->
      result\n   Instructs the local endpoint to enable or disable heartbeat on the\n
      \  specified destination transport address.\n   The result of attempting this
      operation shall be returned.\n   Note: Even when enabled, heartbeat will not
      take place if the\n   destination transport address is not idle.\n   Mandatory
      attributes:\n   o  association id - local handle to the SCTP association.\n
      \  o  destination transport address - specified as one of the transport\n      addresses
      of the peer endpoint.\n   o  new state - the new state of heartbeat for this
      destination\n      transport address (either enabled or disabled).\n   Optional
      attributes:\n   o  interval - if present, indicates the frequency of the heartbeat
      if\n      this is to enable heartbeat on a destination transport address.\n
      \     This value is added to the RTO of the destination transport\n      address.
      \ This value, if present, affects all destinations.\n   J) Request HeartBeat\n
      \     Format: REQUESTHEARTBEAT(association id, destination transport\n              address)\n
      \     -> result\n   Instructs the local endpoint to perform a HeartBeat on the
      specified\n   destination transport address of the given association.  The returned\n
      \  result should indicate whether the transmission of the HEARTBEAT\n   chunk
      to the destination address is successful.\n   Mandatory attributes:\n   o  association
      id - local handle to the SCTP association.\n   o  destination transport address
      - the transport address of the\n      association on which a heartbeat should
      be issued.\n   K) Get SRTT Report\n      Format: GETSRTTREPORT(association id,\n
      \                           destination transport address)\n      -> srtt result\n
      \  Instructs the local SCTP to report the current SRTT measurement on\n   the
      specified destination transport address of the given association.\n   The returned
      result can be an integer containing the most recent SRTT\n   in milliseconds.\n
      \  Mandatory attributes:\n   o  association id - local handle to the SCTP association.\n
      \  o  destination transport address - the transport address of the\n      association
      on which the SRTT measurement is to be reported.\n   L) Set Failure Threshold\n
      \     Format: SETFAILURETHRESHOLD(association id, destination transport\n              address,
      failure threshold)\n      -> result\n   This primitive allows the local SCTP
      to customize the reachability\n   failure detection threshold 'Path.Max.Retrans'
      for the specified\n   destination address.\n   Mandatory attributes:\n   o  association
      id - local handle to the SCTP association.\n   o  destination transport address
      - the transport address of the\n      association on which the failure detection
      threshold is to be set.\n   o  failure threshold - the new value of 'Path.Max.Retrans'
      for the\n      destination address.\n   M) Set Protocol Parameters\n      Format:
      SETPROTOCOLPARAMETERS(association id,\n              [,destination transport
      address,]\n              protocol parameter list)\n      -> result\n   This
      primitive allows the local SCTP to customize the protocol\n   parameters.\n
      \  Mandatory attributes:\n   o  association id - local handle to the SCTP association.\n
      \  o  protocol parameter list - the specific names and values of the\n      protocol
      parameters (e.g., Association.Max.Retrans; see Section\n      15) that the SCTP
      user wishes to customize.\n   Optional attributes:\n   o  destination transport
      address - some of the protocol parameters\n      may be set on a per destination
      transport address basis.\n   N) Receive Unsent Message\n      Format: RECEIVE_UNSENT(data
      retrieval id, buffer address, buffer\n              size [,stream id] [, stream
      sequence number] [,partial\n              flag] [,payload protocol-id])\n   o
      \ data retrieval id - the identification passed to the ULP in the\n      failure
      notification.\n   o  buffer address - the memory location indicated by the ULP
      to store\n      the received message.\n   o  buffer size - the maximum size
      of data to be received, in bytes.\n   Optional attributes:\n   o  stream id
      - this is a return value that is set to indicate which\n      stream the data
      was sent to.\n   o  Stream Sequence Number - this value is returned indicating
      the\n      Stream Sequence Number that was associated with the message.\n   o
      \ partial flag - if this returned flag is set to 1, then this\n      message
      is a partial delivery of the whole message.  When this\n      flag is set, the
      stream id and Stream Sequence Number MUST\n      accompany this receive.  When
      this flag is set to 0, it indicates\n      that no more deliveries will be received
      for this Stream Sequence\n      Number.\n   o  payload protocol-id - The 32
      bit unsigned integer that was sent to\n      be sent to the peer indicating
      the type of payload protocol of the\n      received data.\n   o  Receive Unacknowledged
      Message\n      Format: RECEIVE_UNACKED(data retrieval id, buffer address, buffer\n
      \             size, [,stream id] [, stream sequence number] [,partial\n              flag]
      [,payload protocol-id])\n   o  data retrieval id - the identification passed
      to the ULP in the\n      failure notification.\n   o  buffer address - the memory
      location indicated by the ULP to store\n      the received message.\n   o  buffer
      size - the maximum size of data to be received, in bytes.\n   Optional attributes:\n
      \  o  stream id - this is a return value that is set to indicate which\n      stream
      the data was sent to.\n   o  Stream Sequence Number - this value is returned
      indicating the\n      Stream Sequence Number that was associated with the message.\n
      \  o  partial flag - if this returned flag is set to 1, then this\n      message
      is a partial delivery of the whole message.  When this\n      flag is set, the
      stream id and Stream Sequence Number MUST\n      accompany this receive.  When
      this flag is set to 0, it indicates\n      that no more deliveries will be received
      for this Stream Sequence\n      Number.\n   o  payload protocol-id - the 32-bit
      unsigned integer that was sent to\n      the peer indicating the type of payload
      protocol of the received\n      data.\n   P) Destroy SCTP Instance\n      Format:
      DESTROY(local SCTP instance name)\n   o  local SCTP instance name - this is
      the value that was passed to\n      the application in the initialize primitive
      and it indicates which\n      SCTP instance is to be destroyed.\n"
    title: 10.1.  ULP-to-SCTP
  - contents:
    - "10.2.  SCTP-to-ULP\n   It is assumed that the operating system or application
      environment\n   provides a means for the SCTP to asynchronously signal the ULP\n
      \  process.  When SCTP does signal a ULP process, certain information is\n   passed
      to the ULP.\n   IMPLEMENTATION NOTE: In some cases, this may be done through
      a\n   separate socket or error channel.\n   A) DATA ARRIVE notification\n   SCTP
      shall invoke this notification on the ULP when a user message is\n   successfully
      received and ready for retrieval.\n   The following may optionally be passed
      with the notification:\n   o  association id - local handle to the SCTP association.\n
      \  o  stream id - to indicate which stream the data is received on.\n   B) SEND
      FAILURE notification\n   If a message cannot be delivered, SCTP shall invoke
      this notification\n   on the ULP.\n   The following may optionally be passed
      with the notification:\n   o  association id - local handle to the SCTP association.\n
      \  o  data retrieval id - an identification used to retrieve unsent and\n      unacknowledged
      data.\n   o  cause code - indicating the reason of the failure, e.g., size too\n
      \     large, message life time expiration, etc.\n   o  context - optional information
      associated with this message (see D\n      in Section 10.1).\n   C) NETWORK
      STATUS CHANGE notification\n   When a destination transport address is marked
      inactive (e.g., when\n   SCTP detects a failure) or marked active (e.g., when
      SCTP detects a\n   recovery), SCTP shall invoke this notification on the ULP.\n
      \  The following shall be passed with the notification:\n   o  association id
      - local handle to the SCTP association.\n   o  destination transport address
      - this indicates the destination\n      transport address of the peer endpoint
      affected by the change.\n   o  new-status - this indicates the new status.\n
      \  D) COMMUNICATION UP notification\n   This notification is used when SCTP
      becomes ready to send or receive\n   user messages, or when a lost communication
      to an endpoint is\n   restored.\n   IMPLEMENTATION NOTE: If the ASSOCIATE primitive
      is implemented as a\n   blocking function call, the association parameters are
      returned as a\n   result of the ASSOCIATE primitive itself.  In that case,\n
      \  COMMUNICATION UP notification is optional at the association\n   initiator's
      side.\n   The following shall be passed with the notification:\n   o  association
      id -  local handle to the SCTP association.\n   o  status -  This indicates
      what type of event has occurred.\n   o  destination transport address list -
      \ the complete set of\n      transport addresses of the peer.\n   o  outbound
      stream count -  the maximum number of streams allowed to\n      be used in this
      association by the ULP.\n   o  inbound stream count -  the number of streams
      the peer endpoint\n      has requested with this association (this may not be
      the same\n      number as 'outbound stream count').\n   E) COMMUNICATION LOST
      notification\n   When SCTP loses communication to an endpoint completely (e.g.,
      via\n   Heartbeats) or detects that the endpoint has performed an abort\n   operation,
      it shall invoke this notification on the ULP.\n   The following shall be passed
      with the notification:\n   o  association id -  local handle to the SCTP association.\n
      \  o  status -  this indicates what type of event has occurred; the\n                status
      may indicate that a failure OR a normal\n                termination event occurred
      in response to a shutdown or\n                abort request.\n   The following
      may be passed with the notification:\n   o  data retrieval id -  an identification
      used to retrieve unsent and\n      unacknowledged data.\n   o  last-acked -
      \ the TSN last acked by that peer endpoint.\n   o  last-sent -  the TSN last
      sent to that peer endpoint.\n   o  Upper Layer Abort Reason -  the abort reason
      specified in case of\n      a user-initiated abort.\n   F) COMMUNICATION ERROR
      notification\n   When SCTP receives an ERROR chunk from its peer and decides
      to notify\n   its ULP, it can invoke this notification on the ULP.\n   The following
      can be passed with the notification:\n   o  association id -  local handle to
      the SCTP association.\n   o  error info -  this indicates the type of error
      and optionally some\n      additional information received through the ERROR
      chunk.\n   G) RESTART notification\n   When SCTP detects that the peer has restarted,
      it may send this\n   notification to its ULP.\n   The following can be passed
      with the notification:\n   o  association id -  local handle to the SCTP association.\n
      \  H) SHUTDOWN COMPLETE notification\n   When SCTP completes the shutdown procedures
      (Section 9.2), this\n   notification is passed to the upper layer.\n   The following
      can be passed with the notification:\n   o  association id -  local handle to
      the SCTP association.\n"
    title: 10.2.  SCTP-to-ULP
  title: 10.  Interface with Upper Layer
- contents:
  - '11.  Security Considerations

    '
  - contents:
    - "11.1.  Security Objectives\n   As a common transport protocol designed to reliably
      carry time-\n   sensitive user messages, such as billing or signaling messages
      for\n   telephony services, between two networked endpoints, SCTP has the\n
      \  following security objectives.\n   -  availability of reliable and timely
      data transport services\n   -  integrity of the user-to-user information carried
      by SCTP\n"
    title: 11.1.  Security Objectives
  - contents:
    - "11.2.  SCTP Responses to Potential Threats\n   SCTP may potentially be used
      in a wide variety of risk situations.\n   It is important for operators of systems
      running SCTP to analyze\n   their particular situations and decide on the appropriate
      counter-\n   measures.\n   Operators of systems running SCTP should consult
      [RFC2196] for\n   guidance in securing their site.\n"
    - contents:
      - "11.2.1.  Countering Insider Attacks\n   The principles of [RFC2196] should
        be applied to minimize the risk of\n   theft of information or sabotage by
        insiders.  Such procedures\n   include publication of security policies, control
        of access at the\n   physical, software, and network levels, and separation
        of services.\n"
      title: 11.2.1.  Countering Insider Attacks
    - contents:
      - "11.2.2.  Protecting against Data Corruption in the Network\n   Where the
        risk of undetected errors in datagrams delivered by the\n   lower-layer transport
        services is considered to be too great,\n   additional integrity protection
        is required.  If this additional\n   protection were provided in the application
        layer, the SCTP header\n   would remain vulnerable to deliberate integrity
        attacks.  While the\n   existing SCTP mechanisms for detection of packet replays
        are\n   considered sufficient for normal operation, stronger protections are\n
        \  needed to protect SCTP when the operating environment contains\n   significant
        risk of deliberate attacks from a sophisticated\n   adversary.\n   The SCTP
        Authentication extension SCTP-AUTH [RFC4895] MAY be used\n   when the threat
        environment requires stronger integrity protections,\n   but does not require
        confidentiality.\n"
      title: 11.2.2.  Protecting against Data Corruption in the Network
    - contents:
      - "11.2.3.  Protecting Confidentiality\n   In most cases, the risk of breach
        of confidentiality applies to the\n   signaling data payload, not to the SCTP
        or lower-layer protocol\n   overheads.  If that is true, encryption of the
        SCTP user data only\n   might be considered.  As with the supplementary checksum
        service,\n   user data encryption MAY be performed by the SCTP user application.\n
        \  Alternately, the user application MAY use an implementation-specific\n
        \  API to request that the IP Encapsulating Security Payload (ESP)\n   [RFC4303]
        be used to provide confidentiality and integrity.\n   Particularly for mobile
        users, the requirement for confidentiality\n   might include the masking of
        IP addresses and ports.  In this case,\n   ESP SHOULD be used instead of application-level
        confidentiality.  If\n   ESP is used to protect confidentiality of SCTP traffic,
        an ESP\n   cryptographic transform that includes cryptographic integrity\n
        \  protection MUST be used, because if there is a confidentiality threat\n
        \  there will also be a strong integrity threat.\n   Whenever ESP is in use,
        application-level encryption is not generally\n   required.\n   Regardless
        of where confidentiality is provided, the Internet Key\n   Exchange Protocol
        version 2 (IKEv2) [RFC4306] SHOULD be used for key\n   management.\n   Operators
        should consult [RFC4301] for more information on the\n   security services
        available at and immediately above the Internet\n   Protocol layer.\n"
      title: 11.2.3.  Protecting Confidentiality
    - contents:
      - "11.2.4.  Protecting against Blind Denial-of-Service Attacks\n   A blind attack
        is one where the attacker is unable to intercept or\n   otherwise see the
        content of data flows passing to and from the\n   target SCTP node.  Blind
        denial-of-service attacks may take the form\n   of flooding, masquerade, or
        improper monopolization of services.\n"
      - contents:
        - "11.2.4.1.  Flooding\n   The objective of flooding is to cause loss of service
          and incorrect\n   behavior at target systems through resource exhaustion,
          interference\n   with legitimate transactions, and exploitation of buffer-related\n
          \  software bugs.  Flooding may be directed either at the SCTP node or\n
          \  at resources in the intervening IP Access Links or the Internet.\n   Where
          the latter entities are the target, flooding will manifest\n   itself as
          loss of network services, including potentially the breach\n   of any firewalls
          in place.\n   In general, protection against flooding begins at the equipment\n
          \  design level, where it includes measures such as:\n   -  avoiding commitment
          of limited resources before determining that\n      the request for service
          is legitimate.\n   -  giving priority to completion of processing in progress
          over the\n      acceptance of new work.\n   -  identification and removal
          of duplicate or stale queued requests\n      for service.\n   -  not responding
          to unexpected packets sent to non-unicast\n      addresses.\n   Network
          equipment should be capable of generating an alarm and log if\n   a suspicious
          increase in traffic occurs.  The log should provide\n   information such
          as the identity of the incoming link and source\n   address(es) used, which
          will help the network or SCTP system operator\n   to take protective measures.
          \ Procedures should be in place for the\n   operator to act on such alarms
          if a clear pattern of abuse emerges.\n   The design of SCTP is resistant
          to flooding attacks, particularly in\n   its use of a four-way startup handshake,
          its use of a cookie to defer\n   commitment of resources at the responding
          SCTP node until the\n   handshake is completed, and its use of a Verification
          Tag to prevent\n   insertion of extraneous packets into the flow of an established\n
          \  association.\n   The IP Authentication Header and Encapsulating Security
          Payload might\n   be useful in reducing the risk of certain kinds of denial-of-service\n
          \  attacks.\n   The use of the host name feature in the INIT chunk could
          be used to\n   flood a target DNS server.  A large backlog of DNS queries,
          resolving\n   the host name received in the INIT chunk to IP addresses,
          could be\n   accomplished by sending INITs to multiple hosts in a given
          domain.\n   In addition, an attacker could use the host name feature in
          an\n   indirect attack on a third party by sending large numbers of INITs
          to\n   random hosts containing the host name of the target.  In addition
          to\n   the strain on DNS resources, this could also result in large numbers\n
          \  of INIT ACKs being sent to the target.  One method to protect against\n
          \  this type of attack is to verify that the IP addresses received from\n
          \  DNS include the source IP address of the original INIT.  If the list\n
          \  of IP addresses received from DNS does not include the source IP\n   address
          of the INIT, the endpoint MAY silently discard the INIT.\n   This last option
          will not protect against the attack against the DNS.\n"
        title: 11.2.4.1.  Flooding
      - contents:
        - "11.2.4.2.  Blind Masquerade\n   Masquerade can be used to deny service
          in several ways:\n   -  by tying up resources at the target SCTP node to
          which the\n      impersonated node has limited access.  For example, the
          target\n      node may by policy permit a maximum of one SCTP association
          with\n      the impersonated SCTP node.  The masquerading attacker may attempt\n
          \     to establish an association purporting to come from the\n      impersonated
          node so that the latter cannot do so when it requires\n      it.\n   -  by
          deliberately allowing the impersonation to be detected, thereby\n      provoking
          counter-measures that cause the impersonated node to be\n      locked out
          of the target SCTP node.\n   -  by interfering with an established association
          by inserting\n      extraneous content such as a SHUTDOWN request.\n   SCTP
          reduces the risk of blind masquerade attacks through IP spoofing\n   by
          use of the four-way startup handshake.  Because the initial\n   exchange
          is memory-less, no lockout mechanism is triggered by blind\n   masquerade
          attacks.  In addition, the INIT ACK containing the State\n   Cookie is transmitted
          back to the IP address from which it received\n   the INIT.  Thus, the attacker
          would not receive the INIT ACK\n   containing the State Cookie.  SCTP protects
          against insertion of\n   extraneous packets into the flow of an established
          association by use\n   of the Verification Tag.\n   Logging of received
          INIT requests and abnormalities such as\n   unexpected INIT ACKs might be
          considered as a way to detect patterns\n   of hostile activity.  However,
          the potential usefulness of such\n   logging must be weighed against the
          increased SCTP startup processing\n   it implies, rendering the SCTP node
          more vulnerable to flooding\n   attacks.  Logging is pointless without the
          establishment of operating\n   procedures to review and analyze the logs
          on a routine basis.\n"
        title: 11.2.4.2.  Blind Masquerade
      - contents:
        - "11.2.4.3.  Improper Monopolization of Services\n   Attacks under this heading
          are performed openly and legitimately by\n   the attacker.  They are directed
          against fellow users of the target\n   SCTP node or of the shared resources
          between the attacker and the\n   target node.  Possible attacks include
          the opening of a large number\n   of associations between the attacker's
          node and the target, or\n   transfer of large volumes of information within
          a legitimately\n   established association.\n   Policy limits should be
          placed on the number of associations per\n   adjoining SCTP node.  SCTP
          user applications should be capable of\n   detecting large volumes of illegitimate
          or \"no-op\" messages within a\n   given association and either logging
          or terminating the association\n   as a result, based on local policy.\n"
        title: 11.2.4.3.  Improper Monopolization of Services
      title: 11.2.4.  Protecting against Blind Denial-of-Service Attacks
    title: 11.2.  SCTP Responses to Potential Threats
  - contents:
    - "11.3.  SCTP Interactions with Firewalls\n   It is helpful for some firewalls
      if they can inspect just the first\n   fragment of a fragmented SCTP packet
      and unambiguously determine\n   whether it corresponds to an INIT chunk (for
      further information,\n   please refer to [RFC1858]).  Accordingly, we stress
      the requirements,\n   stated in Section 3.1, that (1) an INIT chunk MUST NOT
      be bundled\n   with any other chunk in a packet, and (2) a packet containing
      an INIT\n   chunk MUST have a zero Verification Tag.  Furthermore, we require\n
      \  that the receiver of an INIT chunk MUST enforce these rules by\n   silently
      discarding an arriving packet  with an INIT chunk that is\n   bundled with other
      chunks or has a non-zero verification tag and\n   contains an INIT-chunk.\n"
    title: 11.3.  SCTP Interactions with Firewalls
  - contents:
    - "11.4.  Protection of Non-SCTP-Capable Hosts\n   To provide a non-SCTP-capable
      host with the same level of protection\n   against attacks as for SCTP-capable
      ones, all SCTP stacks MUST\n   implement the ICMP handling described in Appendix
      C.\n   When an SCTP stack receives a packet containing multiple control or\n
      \  DATA chunks and the processing of the packet requires the sending of\n   multiple
      chunks in response, the sender of the response chunk(s) MUST\n   NOT send more
      than one packet.  If bundling is supported, multiple\n   response chunks that
      fit into a single packet MAY be bundled together\n   into one single response
      packet.  If bundling is not supported, then\n   the sender MUST NOT send more
      than one response chunk and MUST\n   discard all other responses.  Note that
      this rule does NOT apply to a\n   SACK chunk, since a SACK chunk is, in itself,
      a response to DATA and\n   a SACK does not require a response of more DATA.\n
      \  An SCTP implementation SHOULD abort the association if it receives a\n   SACK
      acknowledging a TSN that has not been sent.\n   An SCTP implementation that
      receives an INIT that would require a\n   large packet in response, due to the
      inclusion of multiple ERROR\n   parameters, MAY (at its discretion) elect to
      omit some or all of the\n   ERROR parameters to reduce the size of the INIT
      ACK.  Due to a\n   combination of the size of the COOKIE parameter and the number
      of\n   addresses a receiver of an INIT may be indicating to a peer, it is\n
      \  always possible that the INIT ACK will be larger than the original\n   INIT.
      \ An SCTP implementation SHOULD attempt to make the INIT ACK as\n   small as
      possible to reduce the possibility of byte amplification\n   attacks.\n"
    title: 11.4.  Protection of Non-SCTP-Capable Hosts
  title: 11.  Security Considerations
- contents:
  - "12.  Network Management Considerations\n   The MIB module for SCTP defined in
    [RFC3873] applies for the version\n   of the protocol specified in this document.\n"
  title: 12.  Network Management Considerations
- contents:
  - "13.  Recommended Transmission Control Block (TCB) Parameters\n   This section
    details a recommended set of parameters that should be\n   contained within the
    TCB for an implementation.  This section is for\n   illustrative purposes and
    should not be deemed as requirements on an\n   implementation or as an exhaustive
    list of all parameters inside an\n   SCTP TCB.  Each implementation may need its
    own additional parameters\n   for optimization.\n"
  - contents:
    - "13.1.  Parameters Necessary for the SCTP Instance\n   Associations: A list
      of current associations and mappings to the data\n                 consumers
      for each association.  This may be in the\n                 form of a hash table
      or other implementation-dependent\n                 structure.  The data consumers
      may be process\n                 identification information such as file descriptors,\n
      \                named pipe pointer, or table pointers dependent on how\n                 SCTP
      is implemented.\n   Secret Key:   A secret key used by this endpoint to compute
      the MAC.\n                 This SHOULD be a cryptographic quality random number\n
      \                with a sufficient length.  Discussion in RFC 4086 can\n                 be
      helpful in selection of the key.\n   Address List: The list of IP addresses
      that this instance has bound.\n                 This information is passed to
      one's peer(s) in INIT and\n                 INIT ACK chunks.\n   SCTP Port:
      \   The local SCTP port number to which the endpoint is\n                 bound.\n"
    title: 13.1.  Parameters Necessary for the SCTP Instance
  - contents:
    - "13.2.  Parameters Necessary per Association (i.e., the TCB)\n   Peer        :
      Tag value to be sent in every packet and is received\n   Verification: in the
      INIT or INIT ACK chunk.\n   Tag         :\n   My          : Tag expected in
      every inbound packet and sent in the\n   Verification: INIT or INIT ACK chunk.\n
      \  Tag         :\n   State       : A state variable indicating what state the
      association\n               : is in, i.e., COOKIE-WAIT, COOKIE-ECHOED, ESTABLISHED,\n
      \              : SHUTDOWN-PENDING, SHUTDOWN-SENT, SHUTDOWN-RECEIVED,\n               :
      SHUTDOWN-ACK-SENT.\n                 Note: No \"CLOSED\" state is illustrated
      since if a\n                 association is \"CLOSED\" its TCB SHOULD be removed.\n
      \  Peer        : A list of SCTP transport addresses to which the peer\n   Transport
      \  : is bound.  This information is derived from the INIT or\n   Address     :
      INIT ACK and is used to associate an inbound packet\n   List        : with a
      given association.  Normally, this information\n               : is hashed or
      keyed for quick lookup and access of the\n               : TCB.\n   Primary
      \    : This is the current primary destination transport\n   Path        : address
      of the peer endpoint.  It may also specify a\n               : source transport
      address on this endpoint.\n   Overall     : The overall association error count.\n
      \  Error Count :\n   Overall     : The threshold for this association that if
      the Overall\n   Error       : Error Count reaches will cause this association
      to be\n   Threshold   : torn down.\n   Peer Rwnd   : Current calculated value
      of the peer's rwnd.\n   Next TSN    : The next TSN number to be assigned to
      a new DATA chunk.\n               : This is sent in the INIT or INIT ACK chunk
      to the peer\n               : and incremented each time a DATA chunk is assigned
      a\n               : TSN (normally just prior to transmit or during\n               :
      fragmentation).\n   Last Rcvd   : This is the last TSN received in sequence.
      \ This value\n   TSN         : is set initially by taking the peer's initial
      TSN,\n               : received in the INIT or INIT ACK chunk, and\n               :
      subtracting one from it.\n   Mapping     : An array of bits or bytes indicating
      which out-of-\n   Array       : order TSNs have been received (relative to the\n
      \              : Last Rcvd TSN).  If no gaps exist, i.e., no out-of-\n               :
      order packets have been received, this array will\n               : be set to
      all zero.  This structure may be in the\n               : form of a circular
      buffer or bit array.\n   Ack State   : This flag indicates if the next received
      packet\n               : is to be responded to with a SACK.  This is initialized\n
      \              : to 0.  When a packet is received it is incremented.\n               :
      If this value reaches 2 or more, a SACK is sent and the\n               : value
      is reset to 0.  Note: This is used only when no\n               : DATA chunks
      are received out of order.  When DATA\n               : chunks are out of order,
      SACKs are not delayed (see\n               : Section 6).\n   Inbound     : An
      array of structures to track the inbound streams,\n   Streams     : normally
      including the next sequence number expected\n               : and possibly the
      stream number.\n   Outbound    : An array of structures to track the outbound
      streams,\n   Streams     : normally including the next sequence number to\n
      \              : be sent on the stream.\n   Reasm Queue : A reassembly queue.\n
      \  Local       : The list of local IP addresses bound in to this\n   Transport
      \  : association.\n   Address     :\n   List        :\n   Association : The
      smallest PMTU discovered for all of the\n   PMTU        : peer's transport addresses.\n"
    title: 13.2.  Parameters Necessary per Association (i.e., the TCB)
  - contents:
    - "13.3.  Per Transport Address Data\n   For each destination transport address
      in the peer's address list\n   derived from the INIT or INIT ACK chunk, a number
      of data elements\n   need to be maintained including:\n   Error Count : The
      current error count for this destination.\n   Error       : Current error threshold
      for this destination, i.e.,\n   Threshold   : what value marks the destination
      down if error count\n               : reaches this value.\n   cwnd        :
      The current congestion window.\n   ssthresh    : The current ssthresh value.\n
      \  RTO         : The current retransmission timeout value.\n   SRTT        :
      The current smoothed round-trip time.\n   RTTVAR      : The current RTT variation.\n
      \  partial     : The tracking method for increase of cwnd when in\n   bytes
      acked : congestion avoidance mode (see Section 7.2.2).\n   state       : The
      current state of this destination, i.e., DOWN, UP,\n               : ALLOW-HB,
      NO-HEARTBEAT, etc.\n   PMTU        : The current known path MTU.\n   Per         :
      A timer used by each destination.\n   Destination :\n   Timer       :\n   RTO-Pending
      : A flag used to track if one of the DATA chunks sent to\n               : this
      address is currently being used to compute an\n               : RTT.  If this
      flag is 0, the next DATA chunk sent to\n               : this destination should
      be used to compute an RTT and\n               : this flag should be set.  Every
      time the RTT\n               : calculation completes (i.e., the DATA chunk is
      SACK'd),\n               : clear this flag.\n   last-time   : The time to which
      this destination was last sent.\n               : This can be to determine if
      a HEARTBEAT is needed.\n"
    title: 13.3.  Per Transport Address Data
  - contents:
    - "13.4.  General Parameters Needed\n   Out Queue : A queue of outbound DATA chunks.\n
      \  In Queue  : A queue of inbound DATA chunks.\n"
    title: 13.4.  General Parameters Needed
  title: 13.  Recommended Transmission Control Block (TCB) Parameters
- contents:
  - "14.  IANA Considerations\n   SCTP defines three registries that IANA maintains:\n
    \  -  through definition of additional chunk types,\n   -  through definition
    of additional parameter types, or\n   -  through definition of additional cause
    codes within ERROR chunks.\n   SCTP requires that the IANA Port Numbers registry
    be opened for SCTP\n   port registrations, Section 14.5 describes how.  An IESG-appointed\n
    \  Expert Reviewer supports IANA in evaluating SCTP port allocation\n   requests.\n"
  - contents:
    - "14.1.  IETF-Defined Chunk Extension\n   The assignment of new chunk parameter
      type codes is done through an\n   IETF Consensus action, as defined in [RFC2434].
      \ Documentation of the\n   chunk parameter MUST contain the following information:\n
      \  a) A long and short name for the new chunk type.\n   b) A detailed description
      of the structure of the chunk, which MUST\n      conform to the basic structure
      defined in Section 3.2.\n   c) A detailed definition and description of intended
      use of each\n      field within the chunk, including the chunk flags if any.\n
      \  d) A detailed procedural description of the use of the new chunk type\n      within
      the operation of the protocol.\n   The last chunk type (255) is reserved for
      future extension if\n   necessary.\n"
    title: 14.1.  IETF-Defined Chunk Extension
  - contents:
    - "14.2.  IETF-Defined Chunk Parameter Extension\n   The assignment of new chunk
      parameter type codes is done through an\n   IETF Consensus action as defined
      in [RFC2434].  Documentation of the\n   chunk parameter MUST contain the following
      information:\n   a) Name of the parameter type.\n   b) Detailed description
      of the structure of the parameter field.\n      This structure MUST conform
      to the general Type-Length-Value\n      format described in Section 3.2.1.\n
      \  c) Detailed definition of each component of the parameter value.\n   d) Detailed
      description of the intended use of this parameter type,\n      and an indication
      of whether and under what circumstances multiple\n      instances of this parameter
      type may be found within the same\n      chunk.\n   e) Each parameter type MUST
      be unique across all chunks.\n"
    title: 14.2.  IETF-Defined Chunk Parameter Extension
  - contents:
    - "14.3.  IETF-Defined Additional Error Causes\n   Additional cause codes may
      be allocated in the range 11 to 65535\n   through a Specification Required action
      as defined in [RFC2434].\n   Provided documentation must include the following
      information:\n   a) Name of the error condition.\n   b) Detailed description
      of the conditions under which an SCTP\n      endpoint should issue an ERROR
      (or ABORT) with this cause code.\n   c) Expected action by the SCTP endpoint
      that receives an ERROR (or\n      ABORT) chunk containing this cause code.\n
      \  d) Detailed description of the structure and content of data fields\n      that
      accompany this cause code.\n   The initial word (32 bits) of a cause code parameter
      MUST conform to\n   the format shown in Section 3.3.10, i.e.:\n   -  first 2
      bytes contain the cause code value\n   -  last 2 bytes contain the length of
      the cause parameter.\n"
    title: 14.3.  IETF-Defined Additional Error Causes
  - contents:
    - "14.4.  Payload Protocol Identifiers\n   Except for value 0, which is reserved
      by SCTP to indicate an\n   unspecified payload protocol identifier in a DATA
      chunk, SCTP will\n   not be responsible for standardizing or verifying any payload\n
      \  protocol identifiers; SCTP simply receives the identifier from the\n   upper
      layer and carries it with the corresponding payload data.\n   The upper layer,
      i.e., the SCTP user, SHOULD standardize any specific\n   protocol identifier
      with IANA if it is so desired.  The use of any\n   specific payload protocol
      identifier is out of the scope of SCTP.\n"
    title: 14.4.  Payload Protocol Identifiers
  - contents:
    - "14.5.  Port Numbers Registry\n   SCTP services may use contact port numbers
      to provide service to\n   unknown callers, as in TCP and UDP.  IANA is therefore
      requested to\n   open the existing Port Numbers registry for SCTP using the
      following\n   rules, which we intend to mesh well with existing Port Numbers\n
      \  registration procedures.  An IESG-appointed Expert Reviewer supports\n   IANA
      in evaluating SCTP port allocation requests, according to the\n   procedure
      defined in [RFC2434].\n   Port numbers are divided into three ranges.  The Well
      Known Ports are\n   those from 0 through 1023, the Registered Ports are those
      from 1024\n   through 49151, and the Dynamic and/or Private Ports are those
      from\n   49152 through 65535.  Well Known and Registered Ports are intended\n
      \  for use by server applications that desire a default contact point on\n   a
      system.  On most systems, Well Known Ports can only be used by\n   system (or
      root) processes or by programs executed by privileged\n   users, while Registered
      Ports can be used by ordinary user processes\n   or programs executed by ordinary
      users.  Dynamic and/or Private Ports\n   are intended for temporary use, including
      client-side ports, out-of-\n   band negotiated ports, and application testing
      prior to registration\n   of a dedicated port; they MUST NOT be registered.\n
      \  The Port Numbers registry should accept registrations for SCTP ports\n   in
      the Well Known Ports and Registered Ports ranges.  Well Known and\n   Registered
      Ports SHOULD NOT be used without registration.  Although\n   in some cases --
      such as porting an application from TCP to SCTP --\n   it may seem natural to
      use an SCTP port before registration\n   completes, we emphasize that IANA will
      not guarantee registration of\n   particular Well Known and Registered Ports.
      \ Registrations should be\n   requested as early as possible.\n   Each port
      registration SHALL include the following information:\n   o  A short port name,
      consisting entirely of letters (A-Z and a-z),\n      digits (0-9), and punctuation
      characters from \"-_+./*\" (not\n      including the quotes).\n   o  The port
      number that is requested for registration.\n   o  A short English phrase describing
      the port's purpose.\n   o  Name and contact information for the person or entity
      performing\n      the registration, and possibly a reference to a document defining\n
      \     the port's use.  Registrations coming from IETF working groups\n      need
      only name the working group, but indicating a contact person\n      is recommended.\n
      \  Registrants are encouraged to follow these guidelines when submitting\n   a
      registration.\n   o  A port name SHOULD NOT be registered for more than one
      SCTP port\n      number.\n   o  A port name registered for TCP MAY be registered
      for SCTP as well.\n      Any such registration SHOULD use the same port number
      as the\n      existing TCP registration.\n   o  Concrete intent to use a port
      SHOULD precede port registration.\n      For example, existing TCP ports SHOULD
      NOT be registered in\n      advance of any intent to use those ports for SCTP.\n
      \     This document registers the following ports.  (These registrations\n      should
      be considered models to follow for future allocation\n      requests.)\n         discard
      \   9/sctp  Discard  # IETF TSVWG\n                                     # Randall
      Stewart <rrs@cisco.com>\n                                     # [RFC4960]\n
      \           The discard service, which accepts SCTP connections on port\n            9,
      discards all incoming application data and sends no data\n            in response.
      \ Thus, SCTP's discard port is analogous to\n            TCP's discard port,
      and might be used to check the health\n            of an SCTP stack.\n         ftp-data
      \ 20/sctp  FTP      # IETF TSVWG\n                                     # Randall
      Stewart <rrs@cisco.com>\n                                     # [RFC4960]\n
      \        ftp       21/sctp  FTP      # IETF TSVWG\n                                     #
      Randall Stewart <rrs@cisco.com>\n                                     # [RFC4960]\n
      \           File Transfer Protocol (FTP) data (20) and control ports\n            (21).\n
      \        ssh       22/sctp  SSH      # IETF TSVWG\n                                     #
      Randall Stewart <rrs@cisco.com>\n                                     # [RFC4960]\n
      \           The Secure Shell (SSH) remote login service, which allows\n            secure
      shell logins to a host.\n         http      80/sctp  HTTP     # IETF TSVWG\n
      \                                    # Randall Stewart <rrs@cisco.com>\n                                     #
      [RFC4960]\n            World Wide Web HTTP over SCTP.\n         bgp      179/sctp
      \ BGP      # IETF TSVWG\n                                     # Randall Stewart
      <rrs@cisco.com>\n                                     # [RFC4960]\n            Border
      Gateway Protocol over SCTP.\n         https    443/sctp  HTTPS    # IETF TSVWG\n
      \                                    # Randall Stewart <rrs@cisco.com>\n                                     #
      [RFC4960]\n            World Wide Web HTTP over TLS/SSL over SCTP.\n"
    title: 14.5.  Port Numbers Registry
  title: 14.  IANA Considerations
- contents:
  - "15.  Suggested SCTP Protocol Parameter Values\n   The following protocol parameters
    are RECOMMENDED:\n      RTO.Initial - 3 seconds\n      RTO.Min - 1 second\n      RTO.Max
    - 60 seconds\n      Max.Burst - 4\n      RTO.Alpha - 1/8\n      RTO.Beta - 1/4\n
    \     Valid.Cookie.Life - 60 seconds\n      Association.Max.Retrans - 10 attempts\n
    \     Path.Max.Retrans - 5 attempts (per destination address)\n      Max.Init.Retransmits
    - 8 attempts\n      HB.interval - 30 seconds\n      HB.Max.Burst - 1\n   IMPLEMENTATION
    NOTE: The SCTP implementation may allow ULP to\n   customize some of these protocol
    parameters (see Section 10).\n   Note: RTO.Min SHOULD be set as recommended above.\n"
  title: 15.  Suggested SCTP Protocol Parameter Values
- contents:
  - "16.  Acknowledgements\n   An undertaking represented by this updated document
    is not a small\n   feat and represents the summation of the initial authors of
    RFC 2960:\n   Q. Xie, K. Morneault, C. Sharp, H. Schwarzbauer, T. Taylor, I.\n
    \  Rytina, M. Kalla, L. Zhang, and V. Paxson.\n   Add to that, the comments from
    everyone who contributed to the\n   original RFC:\n   Mark Allman, R.J. Atkinson,
    Richard Band, Scott Bradner, Steve\n   Bellovin, Peter Butler, Ram Dantu, R. Ezhirpavai,
    Mike Fisk, Sally\n   Floyd, Atsushi Fukumoto, Matt Holdrege, Henry Houh, Christian\n
    \  Huitema, Gary Lehecka, Jonathan Lee, David Lehmann, John Loughney,\n   Daniel
    Luan, Barry Nagelberg, Thomas Narten, Erik Nordmark, Lyndon\n   Ong, Shyamal Prasad,
    Kelvin Porter, Heinz Prantner, Jarno Rajahalme,\n   Raymond E. Reeves, Renee Revis,
    Ivan Arias Rodriguez, A. Sankar, Greg\n   Sidebottom, Brian Wyld, La Monte Yarroll,
    and many others for their\n   invaluable comments.\n   Then, add the authors of
    the SCTP implementor's guide, I. Arias-\n   Rodriguez, K. Poon, A. Caro, and M.
    Tuexen.\n   Then add to these the efforts of all the subsequent seven SCTP\n   interoperability
    tests and those who commented on RFC 4460 as shown\n   in its acknowledgements:\n
    \  Barry Zuckerman, La Monte Yarroll, Qiaobing Xie, Wang Xiaopeng,\n   Jonathan
    Wood, Jeff Waskow, Mike Turner, John Townsend, Sabina\n   Torrente, Cliff Thomas,
    Yuji Suzuki, Manoj Solanki, Sverre Slotte,\n   Keyur Shah, Jan Rovins, Ben Robinson,
    Renee Revis, Ian Periam, RC\n   Monee, Sanjay Rao, Sujith Radhakrishnan, Heinz
    Prantner, Biren Patel,\n   Nathalie Mouellic, Mitch Miers, Bernward Meyknecht,
    Stan McClellan,\n   Oliver Mayor, Tomas Orti Martin, Sandeep Mahajan, David Lehmann,\n
    \  Jonathan Lee, Philippe Langlois, Karl Knutson, Joe Keller, Gareth\n   Keily,
    Andreas Jungmaier, Janardhan Iyengar, Mutsuya Irie, John\n   Hebert, Kausar Hassan,
    Fred Hasle, Dan Harrison, Jon Grim, Laurent\n   Glaude, Steven Furniss, Atsushi
    Fukumoto, Ken Fujita, Steve Dimig,\n   Thomas Curran, Serkan Cil, Melissa Campbell,
    Peter Butler, Rob\n   Brennan, Harsh Bhondwe, Brian Bidulock, Caitlin Bestler,
    Jon Berger,\n   Robby Benedyk, Stephen Baucke, Sandeep Balani, and Ronnie Sellar.\n
    \  A special thanks to Mark Allman, who should actually be a co-author\n   for
    his work on the max-burst, but managed to wiggle out due to a\n   technicality.
    \ Also, we would like to acknowledge Lyndon Ong and Phil\n   Conrad for their
    valuable input and many contributions.\n   And finally, you have this document,
    and those who have commented\n   upon that including Alfred Hoenes and Ronnie
    Sellars.\n   My thanks cannot be adequately expressed to all of you who have\n
    \  participated in the coding, testing, and updating process of this\n   document.
    \ All I can say is, Thank You!\n   Randall Stewart - Editor\n"
  title: 16.  Acknowledgements
- contents:
  - "Appendix A.  Explicit Congestion Notification\n   ECN [RFC3168] describes a proposed
    extension to IP that details a\n   method to become aware of congestion outside
    of datagram loss.  This\n   is an optional feature that an implementation MAY
    choose to add to\n   SCTP.  This appendix details the minor differences implementers
    will\n   need to be aware of if they choose to implement this feature.  In\n   general,
    [RFC3168] should be followed with the following exceptions.\n   Negotiation:\n
    \  [RFC3168] details negotiation of ECN during the SYN and SYN-ACK\n   stages
    of a TCP connection.  The sender of the SYN sets 2 bits in the\n   TCP flags,
    and the sender of the SYN-ACK sets only 1 bit.  The\n   reasoning behind this
    is to ensure that both sides are truly ECN\n   capable.  For SCTP, this is not
    necessary.  To indicate that an\n   endpoint is ECN capable, an endpoint SHOULD
    add to the INIT and or\n   INIT ACK chunk the TLV reserved for ECN.  This TLV
    contains no\n   parameters, and thus has the following format:\n        0                   1
    \                  2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3
    4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \      |   Parameter Type = 32768      |     Parameter Length = 4      |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  ECN-Echo:\n   [RFC3168] details a specific bit for a receiver to send back
    in its\n   TCP acknowledgements to notify the sender of the Congestion\n   Experienced
    (CE) bit having arrived from the network.  For SCTP, this\n   same indication
    is made by including the ECNE chunk.  This chunk\n   contains one data element,
    i.e., the lowest TSN associated with the\n   IP datagram marked with the CE bit,
    and looks as follows:\n        0                   1                   2                   3\n
    \       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \      | Chunk Type=12 | Flags=00000000|    Chunk Length = 8           |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \      |                      Lowest TSN Number                        |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \      Note: The ECNE is considered a Control chunk.\n   CWR:\n   [RFC3168] details
    a specific bit for a sender to send in the header\n   of its next outbound TCP
    segment to indicate to its peer that it has\n   reduced its congestion window.
    \ This is termed the CWR bit.  For\n   SCTP, the same indication is made by including
    the CWR chunk.  This\n   chunk contains one data element, i.e., the TSN number
    that was sent\n   in the ECNE chunk.  This element represents the lowest TSN number
    in\n   the datagram that was originally marked with the CE bit.\n        0                   1
    \                  2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3
    4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \      | Chunk Type=13 | Flags=00000000|    Chunk Length = 8           |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \      |                      Lowest TSN Number                        |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \      Note: The CWR is considered a Control chunk.\n"
  title: Appendix A.  Explicit Congestion Notification
- contents:
  - "Appendix B.  CRC32c Checksum Calculation\n   We define a 'reflected value' as
    one that is the opposite of the\n   normal bit order of the machine.  The 32-bit
    CRC (Cyclic Redundancy\n   Check) is calculated as described for CRC32c and uses
    the polynomial\n   code 0x11EDC6F41 (Castagnoli93) or x^32+x^28+x^27+x^26+x^25\n
    \  +x^23+x^22+x^20+x^19+x^18+ x^14+x^13+x^11+x^10+x^9+x^8+x^6+x^0.  The\n   CRC
    is computed using a procedure similar to ETHERNET CRC [ITU32],\n   modified to
    reflect transport-level usage.\n   CRC computation uses polynomial division.  A
    message bit-string M is\n   transformed to a polynomial, M(X), and the CRC is
    calculated from\n   M(X) using polynomial arithmetic.\n   When CRCs are used at
    the link layer, the polynomial is derived from\n   on-the-wire bit ordering: the
    first bit 'on the wire' is the high-\n   order coefficient.  Since SCTP is a transport-level
    protocol, it\n   cannot know the actual serial-media bit ordering.  Moreover,\n
    \  different links in the path between SCTP endpoints may use different\n   link-level
    bit orders.\n   A convention must therefore be established for mapping SCTP transport\n
    \  messages to polynomials for purposes of CRC computation.  The bit-\n   ordering
    for mapping SCTP messages to polynomials is that bytes are\n   taken most-significant
    first, but within each byte, bits are taken\n   least-significant first.  The
    first byte of the message provides the\n   eight highest coefficients.  Within
    each byte, the least-significant\n   SCTP bit gives the most-significant polynomial
    coefficient within\n   that byte, and the most-significant SCTP bit is the least-significant\n
    \  polynomial coefficient in that byte.  (This bit ordering is sometimes\n   called
    'mirrored' or 'reflected' [WILLIAMS93].)  CRC polynomials are\n   to be transformed
    back into SCTP transport-level byte values, using a\n   consistent mapping.\n
    \  The SCTP transport-level CRC value should be calculated as follows:\n   -  CRC
    input data are assigned to a byte stream, numbered from 0 to\n      N-1.\n   -
    \ The transport-level byte stream is mapped to a polynomial value.\n      An N-byte
    PDU with j bytes numbered 0 to N-1 is considered as\n      coefficients of a polynomial
    M(x) of order 8N-1, with bit 0 of\n      byte j being coefficient x^(8(N-j)-8),
    and bit 7 of byte j being\n      coefficient x^(8(N-j)-1).\n   -  The CRC remainder
    register is initialized with all 1s and the CRC\n      is computed with an algorithm
    that simultaneously multiplies by\n      x^32 and divides by the CRC polynomial.\n
    \  -  The polynomial is multiplied by x^32 and divided by G(x), the\n      generator
    polynomial, producing a remainder R(x) of degree less\n      than or equal to
    31.\n   -  The coefficients of R(x) are considered a 32-bit sequence.\n   -  The
    bit sequence is complemented.  The result is the CRC\n      polynomial.\n   -
    \ The CRC polynomial is mapped back into SCTP transport-level bytes.\n      The
    coefficient of x^31 gives the value of bit 7 of SCTP byte 0,\n      and the coefficient
    of x^24 gives the value of bit 0 of byte 0.\n      The coefficient of x^7 gives
    bit 7 of byte 3, and the coefficient\n      of x^0 gives bit 0 of byte 3.  The
    resulting 4-byte transport-\n      level sequence is the 32-bit SCTP checksum
    value.\n   IMPLEMENTATION NOTE: Standards documents, textbooks, and vendor\n   literature
    on CRCs often follow an alternative formulation, in which\n   the register used
    to hold the remainder of the long-division\n   algorithm is initialized to zero
    rather than all-1s, and instead the\n   first 32 bits of the message are complemented.
    \ The long-division\n   algorithm used in our formulation is specified such that
    the initial\n   multiplication by 2^32 and the long-division are combined into
    one\n   simultaneous operation.  For such algorithms, and for messages longer\n
    \  than 64 bits, the two specifications are precisely equivalent.  That\n   equivalence
    is the intent of this document.\n   Implementors of SCTP are warned that both
    specifications are to be\n   found in the literature, sometimes with no restriction
    on the long-\n   division algorithm.  The choice of formulation in this document
    is to\n   permit non-SCTP usage, where the same CRC algorithm may be used to\n
    \  protect messages shorter than 64 bits.\n   There may be a computational advantage
    in validating the association\n   against the Verification Tag, prior to performing
    a checksum, as\n   invalid tags will result in the same action as a bad checksum
    in most\n   cases.  The exceptions for this technique would be INIT and some\n
    \  SHUTDOWN-COMPLETE exchanges, as well as a stale COOKIE ECHO.  These\n   special-case
    exchanges must represent small packets and will minimize\n   the effect of the
    checksum calculation.\n"
  title: Appendix B.  CRC32c Checksum Calculation
- contents:
  - "Appendix C.  ICMP Handling\n   Whenever an ICMP message is received by an SCTP
    endpoint, the\n   following procedures MUST be followed to ensure proper utilization
    of\n   the information being provided by layer 3.\n   ICMP1) An implementation
    MAY ignore all ICMPv4 messages where the\n          type field is not set to \"Destination
    Unreachable\".\n   ICMP2) An implementation MAY ignore all ICMPv6 messages where
    the\n          type field is not \"Destination Unreachable\", \"Parameter\n          Problem\",,
    or \"Packet Too Big\".\n   ICMP3) An implementation MAY ignore any ICMPv4 messages
    where the\n          code does not indicate \"Protocol Unreachable\" or\n          \"Fragmentation
    Needed\".\n   ICMP4) An implementation MAY ignore all ICMPv6 messages of type\n
    \         \"Parameter Problem\" if the code is not \"Unrecognized Next\n          Header
    Type Encountered\".\n   ICMP5) An implementation MUST use the payload of the ICMP
    message (v4\n          or v6) to locate the association that sent the message
    to\n          which ICMP is responding.  If the association cannot be found,\n
    \         an implementation SHOULD ignore the ICMP message.\n   ICMP6) An implementation
    MUST validate that the Verification Tag\n          contained in the ICMP message
    matches the Verification Tag of\n          the peer.  If the Verification Tag
    is not 0 and does NOT\n          match, discard the ICMP message.  If it is 0
    and the ICMP\n          message contains enough bytes to verify that the chunk
    type is\n          an INIT chunk and that the Initiate Tag matches the tag of
    the\n          peer, continue with ICMP7.  If the ICMP message is too short\n
    \         or the chunk type or the Initiate Tag does not match, silently\n          discard
    the packet.\n   ICMP7) If the ICMP message is either a v6 \"Packet Too Big\" or
    a v4\n          \"Fragmentation Needed\", an implementation MAY process this\n
    \         information as defined for PATH MTU discovery.\n   ICMP8) If the ICMP
    code is an \"Unrecognized Next Header Type\n          Encountered\" or a \"Protocol
    Unreachable\", an implementation\n          MUST treat this message as an abort
    with the T bit set if it\n          does not contain an INIT chunk.  If it does
    contain an INIT\n          chunk and the association is in the COOKIE-WAIT state,
    handle\n          the ICMP message like an ABORT.\n   ICMP9) If the ICMPv6 code
    is \"Destination Unreachable\", the\n          implementation MAY mark the destination
    into the unreachable\n          state or alternatively increment the path error
    counter.\n   Note that these procedures differ from [RFC1122] and from its\n   requirements
    for processing of port-unreachable messages and the\n   requirements that an implementation
    MUST abort associations in\n   response to a \"protocol unreachable\" message.
    \ Port-unreachable\n   messages are not processed, since an implementation will
    send an\n   ABORT, not a port unreachable.  The stricter handling of the\n   \"protocol
    unreachable\" message is due to security concerns for hosts\n   that do NOT support
    SCTP.\n   The following non-normative sample code is taken from an open-source\n
    \  CRC generator [WILLIAMS93], using the \"mirroring\" technique and\n   yielding
    a lookup table for SCTP CRC32c with 256 entries, each 32\n   bits wide.  While
    neither especially slow nor especially fast, as\n   software table-lookup CRCs
    go, it has the advantage of working on\n   both big-endian and little-endian CPUs,
    using the same (host-order)\n   lookup tables, and using only the predefined ntohl()
    and htonl()\n   operations.  The code is somewhat modified from [WILLIAMS93],
    to\n   ensure portability between big-endian and little-endian\n   architectures.
    \ (Note that if the byte endian-ness of the target\n   architecture is known to
    be little-endian, the final bit-reversal and\n   byte-reversal steps can be folded
    into a single operation.)\n   /*************************************************************/\n
    \  /* Note Definition for Ross Williams table generator would   */\n   /* be:
    TB_WIDTH=4, TB_POLLY=0x1EDC6F41, TB_REVER=TRUE        */\n   /* For Mr. Williams
    direct calculation code use the settings */\n   /* cm_width=32, cm_poly=0x1EDC6F41,
    cm_init=0xFFFFFFFF,      */\n   /* cm_refin=TRUE, cm_refot=TRUE, cm_xorort=0x00000000
    \       */\n   /*************************************************************/\n
    \  /* Example of the crc table file */\n   #ifndef __crc32cr_table_h__\n   #define
    __crc32cr_table_h__\n   #define CRC32C_POLY 0x1EDC6F41\n   #define CRC32C(c,d)
    (c=(c>>8)^crc_c[(c^(d))&0xFF])\n   unsigned long  crc_c[256] =\n   {\n   0x00000000L,
    0xF26B8303L, 0xE13B70F7L, 0x1350F3F4L,\n   0xC79A971FL, 0x35F1141CL, 0x26A1E7E8L,
    0xD4CA64EBL,\n   0x8AD958CFL, 0x78B2DBCCL, 0x6BE22838L, 0x9989AB3BL,\n   0x4D43CFD0L,
    0xBF284CD3L, 0xAC78BF27L, 0x5E133C24L,\n   0x105EC76FL, 0xE235446CL, 0xF165B798L,
    0x030E349BL,\n   0xD7C45070L, 0x25AFD373L, 0x36FF2087L, 0xC494A384L,\n   0x9A879FA0L,
    0x68EC1CA3L, 0x7BBCEF57L, 0x89D76C54L,\n   0x5D1D08BFL, 0xAF768BBCL, 0xBC267848L,
    0x4E4DFB4BL,\n   0x20BD8EDEL, 0xD2D60DDDL, 0xC186FE29L, 0x33ED7D2AL,\n   0xE72719C1L,
    0x154C9AC2L, 0x061C6936L, 0xF477EA35L,\n   0xAA64D611L, 0x580F5512L, 0x4B5FA6E6L,
    0xB93425E5L,\n   0x6DFE410EL, 0x9F95C20DL, 0x8CC531F9L, 0x7EAEB2FAL,\n   0x30E349B1L,
    0xC288CAB2L, 0xD1D83946L, 0x23B3BA45L,\n   0xF779DEAEL, 0x05125DADL, 0x1642AE59L,
    0xE4292D5AL,\n   0xBA3A117EL, 0x4851927DL, 0x5B016189L, 0xA96AE28AL,\n   0x7DA08661L,
    0x8FCB0562L, 0x9C9BF696L, 0x6EF07595L,\n   0x417B1DBCL, 0xB3109EBFL, 0xA0406D4BL,
    0x522BEE48L,\n   0x86E18AA3L, 0x748A09A0L, 0x67DAFA54L, 0x95B17957L,\n   0xCBA24573L,
    0x39C9C670L, 0x2A993584L, 0xD8F2B687L,\n   0x0C38D26CL, 0xFE53516FL, 0xED03A29BL,
    0x1F682198L,\n   0x5125DAD3L, 0xA34E59D0L, 0xB01EAA24L, 0x42752927L,\n   0x96BF4DCCL,
    0x64D4CECFL, 0x77843D3BL, 0x85EFBE38L,\n   0xDBFC821CL, 0x2997011FL, 0x3AC7F2EBL,
    0xC8AC71E8L,\n   0x1C661503L, 0xEE0D9600L, 0xFD5D65F4L, 0x0F36E6F7L,\n   0x61C69362L,
    0x93AD1061L, 0x80FDE395L, 0x72966096L,\n   0xA65C047DL, 0x5437877EL, 0x4767748AL,
    0xB50CF789L,\n   0xEB1FCBADL, 0x197448AEL, 0x0A24BB5AL, 0xF84F3859L,\n   0x2C855CB2L,
    0xDEEEDFB1L, 0xCDBE2C45L, 0x3FD5AF46L,\n   0x7198540DL, 0x83F3D70EL, 0x90A324FAL,
    0x62C8A7F9L,\n   0xB602C312L, 0x44694011L, 0x5739B3E5L, 0xA55230E6L,\n   0xFB410CC2L,
    0x092A8FC1L, 0x1A7A7C35L, 0xE811FF36L,\n   0x3CDB9BDDL, 0xCEB018DEL, 0xDDE0EB2AL,
    0x2F8B6829L,\n   0x82F63B78L, 0x709DB87BL, 0x63CD4B8FL, 0x91A6C88CL,\n   0x456CAC67L,
    0xB7072F64L, 0xA457DC90L, 0x563C5F93L,\n   0x082F63B7L, 0xFA44E0B4L, 0xE9141340L,
    0x1B7F9043L,\n   0xCFB5F4A8L, 0x3DDE77ABL, 0x2E8E845FL, 0xDCE5075CL,\n   0x92A8FC17L,
    0x60C37F14L, 0x73938CE0L, 0x81F80FE3L,\n   0x55326B08L, 0xA759E80BL, 0xB4091BFFL,
    0x466298FCL,\n   0x1871A4D8L, 0xEA1A27DBL, 0xF94AD42FL, 0x0B21572CL,\n   0xDFEB33C7L,
    0x2D80B0C4L, 0x3ED04330L, 0xCCBBC033L,\n   0xA24BB5A6L, 0x502036A5L, 0x4370C551L,
    0xB11B4652L,\n   0x65D122B9L, 0x97BAA1BAL, 0x84EA524EL, 0x7681D14DL,\n   0x2892ED69L,
    0xDAF96E6AL, 0xC9A99D9EL, 0x3BC21E9DL,\n   0xEF087A76L, 0x1D63F975L, 0x0E330A81L,
    0xFC588982L,\n   0xB21572C9L, 0x407EF1CAL, 0x532E023EL, 0xA145813DL,\n   0x758FE5D6L,
    0x87E466D5L, 0x94B49521L, 0x66DF1622L,\n   0x38CC2A06L, 0xCAA7A905L, 0xD9F75AF1L,
    0x2B9CD9F2L,\n   0xFF56BD19L, 0x0D3D3E1AL, 0x1E6DCDEEL, 0xEC064EEDL,\n   0xC38D26C4L,
    0x31E6A5C7L, 0x22B65633L, 0xD0DDD530L,\n   0x0417B1DBL, 0xF67C32D8L, 0xE52CC12CL,
    0x1747422FL,\n   0x49547E0BL, 0xBB3FFD08L, 0xA86F0EFCL, 0x5A048DFFL,\n   0x8ECEE914L,
    0x7CA56A17L, 0x6FF599E3L, 0x9D9E1AE0L,\n   0xD3D3E1ABL, 0x21B862A8L, 0x32E8915CL,
    0xC083125FL,\n   0x144976B4L, 0xE622F5B7L, 0xF5720643L, 0x07198540L,\n   0x590AB964L,
    0xAB613A67L, 0xB831C993L, 0x4A5A4A90L,\n   0x9E902E7BL, 0x6CFBAD78L, 0x7FAB5E8CL,
    0x8DC0DD8FL,\n   0xE330A81AL, 0x115B2B19L, 0x020BD8EDL, 0xF0605BEEL,\n   0x24AA3F05L,
    0xD6C1BC06L, 0xC5914FF2L, 0x37FACCF1L,\n   0x69E9F0D5L, 0x9B8273D6L, 0x88D28022L,
    0x7AB90321L,\n   0xAE7367CAL, 0x5C18E4C9L, 0x4F48173DL, 0xBD23943EL,\n   0xF36E6F75L,
    0x0105EC76L, 0x12551F82L, 0xE03E9C81L,\n   0x34F4F86AL, 0xC69F7B69L, 0xD5CF889DL,
    0x27A40B9EL,\n   0x79B737BAL, 0x8BDCB4B9L, 0x988C474DL, 0x6AE7C44EL,\n   0xBE2DA0A5L,
    0x4C4623A6L, 0x5F16D052L, 0xAD7D5351L,\n   };\n   #endif\n    /* Example of table
    build routine */\n   #include <stdio.h>\n   #include <stdlib.h>\n   #define OUTPUT_FILE
    \  \"crc32cr.h\"\n   #define CRC32C_POLY    0x1EDC6F41L\n   FILE *tf;\n   unsigned
    long\n   reflect_32 (unsigned long b)\n   {\n     int i;\n     unsigned long rw
    = 0L;\n     for (i = 0; i < 32; i++){\n         if (b & 1)\n           rw |= 1
    << (31 - i);\n         b >>= 1;\n     }\n     return (rw);\n   }\n   unsigned
    long\n   build_crc_table (int index)\n   {\n     int i;\n     unsigned long rb;\n
    \    rb = reflect_32 (index);\n     for (i = 0; i < 8; i++){\n         if (rb
    & 0x80000000L)\n          rb = (rb << 1) ^ CRC32C_POLY;\n         else\n          rb
    <<= 1;\n     }\n     return (reflect_32 (rb));\n   }\n   main ()\n   {\n     int
    i;\n     printf (\"\\nGenerating CRC-32c table file <%s>\\n\",\n     OUTPUT_FILE);\n
    \    if ((tf = fopen (OUTPUT_FILE, \"w\")) == NULL){\n         printf (\"Unable
    to open %s\\n\", OUTPUT_FILE);\n         exit (1);\n     }\n     fprintf (tf,
    \"#ifndef __crc32cr_table_h__\\n\");\n     fprintf (tf, \"#define __crc32cr_table_h__\\n\\n\");\n
    \    fprintf (tf, \"#define CRC32C_POLY 0x%08lX\\n\",\n     CRC32C_POLY);\n     fprintf
    (tf,\n     \"#define CRC32C(c,d) (c=(c>>8)^crc_c[(c^(d))&0xFF])\\n\");\n     fprintf
    (tf, \"\\nunsigned long  crc_c[256] =\\n{\\n\");\n     for (i = 0; i < 256; i++){\n
    \        fprintf (tf, \"0x%08lXL, \", build_crc_table (i));\n         if ((i &
    3) == 3)\n           fprintf (tf, \"\\n\");\n     }\n     fprintf (tf, \"};\\n\\n#endif\\n\");\n
    \    if (fclose (tf) != 0)\n       printf (\"Unable to close <%s>.\" OUTPUT_FILE);\n
    \    else\n       printf (\"\\nThe CRC-32c table has been written to <%s>.\\n\",\n
    \        OUTPUT_FILE);\n   }\n   /* Example of crc insertion */\n   #include \"crc32cr.h\"\n
    \  unsigned long\n   generate_crc32c(unsigned char *buffer, unsigned int length)\n
    \  {\n     unsigned int i;\n     unsigned long crc32 = ~0L;\n     unsigned long
    result;\n     unsigned char byte0,byte1,byte2,byte3;\n     for (i = 0; i < length;
    i++){\n         CRC32C(crc32, buffer[i]);\n     }\n     result = ~crc32;\n     /*
    \ result now holds the negated polynomial remainder;\n      *  since the table
    and algorithm is \"reflected\" [williams95].\n      *  That is, result has the
    same value as if we mapped the message\n      *  to a polynomial, computed the
    host-bit-order polynomial\n      *  remainder, performed final negation, then
    did an end-for-end\n      *  bit-reversal.\n      *  Note that a 32-bit bit-reversal
    is identical to four inplace\n      *  8-bit reversals followed by an end-for-end
    byteswap.\n      *  In other words, the bytes of each bit are in the right order,\n
    \     *  but the bytes have been byteswapped.  So we now do an explicit\n      *
    \ byteswap.  On a little-endian machine, this byteswap and\n      *  the final
    ntohl cancel out and could be elided.\n      */\n     byte0 = result & 0xff;\n
    \    byte1 = (result>>8) & 0xff;\n     byte2 = (result>>16) & 0xff;\n     byte3
    = (result>>24) & 0xff;\n     crc32 = ((byte0 << 24) |\n              (byte1 <<
    16) |\n              (byte2 << 8)  |\n              byte3);\n     return ( crc32
    );\n   }\n   int\n   insert_crc32(unsigned char *buffer, unsigned int length)\n
    \  {\n     SCTP_message *message;\n     unsigned long crc32;\n     message = (SCTP_message
    *) buffer;\n     message->common_header.checksum = 0L;\n     crc32 = generate_crc32c(buffer,length);\n
    \    /* and insert it into the message */\n     message->common_header.checksum
    = htonl(crc32);\n     return 1;\n   }\n   int\n   validate_crc32(unsigned char
    *buffer, unsigned int length)\n   {\n     SCTP_message *message;\n     unsigned
    int i;\n     unsigned long original_crc32;\n     unsigned long crc32 = ~0L;\n
    \    /* save and zero checksum */\n     message = (SCTP_message *) buffer;\n     original_crc32
    = ntohl(message->common_header.checksum);\n     message->common_header.checksum
    = 0L;\n     crc32 = generate_crc32c(buffer,length);\n     return ((original_crc32
    == crc32)? 1 : -1);\n   }\n"
  title: Appendix C.  ICMP Handling
- contents:
  - 'References

    '
  title: References
- contents:
  - "Normative References\n   [ITU32]      \"ITU-T Recommendation V.42, \"Error-correcting
    procedures\n                for DCEs using asynchronous-to-synchronous\n                conversion\".\",
    ITU-T section 8.1.1.6.2.\n   [RFC0768]    Postel, J., \"User Datagram Protocol\",
    STD 6, RFC 768,\n                August 1980.\n   [RFC0793]    Postel, J., \"Transmission
    Control Protocol\", STD 7, RFC\n                793, September 1981.\n   [RFC1122]
    \   Braden, R., Ed., \"Requirements for Internet Hosts -\n                Communication
    Layers\", STD 3, RFC 1122, October 1989.\n   [RFC1123]    Braden, R., Ed., \"Requirements
    for Internet Hosts -\n                Application and Support\", STD 3, RFC 1123,
    October 1989.\n   [RFC1191]    Mogul, J. and S. Deering, \"Path MTU discovery\",
    RFC\n                1191, November 1990.\n   [RFC1981]    McCann, J., Deering,
    S., and J. Mogul, \"Path MTU\n                Discovery for IP version 6\", RFC
    1981, August 1996.\n   [RFC1982]    Elz, R. and R. Bush, \"Serial Number Arithmetic\",
    RFC\n                1982, August 1996.\n   [RFC2119]    Bradner, S., \"Key words
    for use in RFCs to Indicate\n                Requirement Levels\", BCP 14, RFC
    2119, March 1997.\n   [RFC2434]    Narten, T. and H. Alvestrand, \"Guidelines
    for Writing an\n                IANA Considerations Section in RFCs\", BCP 26,
    RFC 2434,\n                October 1998.\n   [RFC2460]    Deering, S. and R. Hinden,
    \"Internet Protocol, Version 6\n                (IPv6) Specification\", RFC 2460,
    December 1998.\n   [RFC2581]    Allman, M., Paxson, V., and W. Stevens, \"TCP
    Congestion\n                Control\", RFC 2581, April 1999.\n   [RFC3873]    Pastor,
    J. and M. Belinchon, \"Stream Control\n                Transmission Protocol (SCTP)
    Management Information Base\n                (MIB)\", RFC 3873, September 2004.\n
    \  [RFC4291]    Hinden, R. and S. Deering, \"IP Version 6 Addressing\n                Architecture\",
    RFC 4291, February 2006.\n   [RFC4301]    Kent, S. and K. Seo, \"Security Architecture
    for the\n                Internet Protocol\", RFC 4301, December 2005.\n   [RFC4303]
    \   Kent, S., \"IP Encapsulating Security Payload (ESP)\", RFC\n                4303,
    December 2005.\n   [RFC4306]    Kaufman, C., Ed., \"Internet Key Exchange (IKEv2)\n
    \               Protocol\", RFC 4306, December 2005.\n   [RFC4821]    Mathis,
    M. and J. Heffner, \"Packetization Layer Path MTU\n                Discovery\",
    RFC 4821, March 2007.\n"
  title: Normative References
- contents:
  - "Informative References\n   [FALL96]     Fall, K. and S. Floyd, \"Simulation-based
    Comparisons of\n                Tahoe, Reno, and SACK TCP\", SIGCOMM'99 V. 26
    N. 3 pp 5-\n                21, July 1996.\n   [SAVAGE99]   Savage, S., Cardwell,
    N., Wetherall, D., and T.\n                Anderson, \"TCP Congestion Control
    with a Misbehaving\n                Receiver\", ACM Computer Communications Review
    29(5),\n                October 1999.\n   [ALLMAN99]   Allman, M. and V. Paxson,
    \"On Estimating End-to-End\n                Network Path Properties\", SIGCOMM'99
    , 1999.\n   [WILLIAMS93] Williams, R., \"A PAINLESS GUIDE TO CRC ERROR DETECTION\n
    \               ALGORITHMS\", Internet publication,\n                http://www.geocities.com/SiliconValley/Pines/\n
    \               8659/crc.htm, August 1993.\n   [RFC0813]    Clark, D., \"Window
    and Acknowledgement Strategy in TCP\",\n                RFC 813, July 1982.\n
    \  [RFC1858]    Ziemba, G., Reed, D., and P. Traina, \"Security\n                Considerations
    for IP Fragment Filtering\", RFC 1858,\n                October 1995.\n   [RFC2104]
    \   Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC:\n                Keyed-Hashing
    for Message Authentication\", RFC 2104,\n                February 1997.\n   [RFC2196]
    \   Fraser, B., \"Site Security Handbook\", FYI 8, RFC 2196,\n                September
    1997.\n   [RFC2522]    Karn, P. and W. Simpson, \"Photuris: Session-Key\n                Management
    Protocol\", RFC 2522, March 1999.\n   [RFC2960]    Stewart, R., Xie, Q., Morneault,
    K., Sharp, C.,\n                Schwarzbauer, H., Taylor, T., Rytina, I., Kalla,
    M.,\n                Zhang, L., and V. Paxson, \"Stream Control Transmission\n
    \               Protocol\", RFC 2960, October 2000.\n   [RFC3309]    Stone, J.,
    Stewart, R., and D. Otis, \"Stream Control\n                Transmission Protocol
    (SCTP) Checksum Change\", RFC 3309,\n                September 2002.\n   [RFC3168]
    \   Ramakrishnan, K., Floyd, S., and D. Black, \"The Addition\n                of
    Explicit Congestion Notification (ECN) to IP\", RFC\n                3168, September
    2001.\n   [RFC4086]    Eastlake, D., 3rd, Schiller, J., and S. Crocker,\n                \"Randomness
    Requirements for Security\", BCP 106, RFC\n                4086, June 2005.\n
    \  [RFC4460]    Stewart, R., Arias-Rodriguez, I., Poon, K., Caro, A.,\n                and
    M. Tuexen, \"Stream Control Transmission Protocol\n                (SCTP) Specification
    Errata and Issues\", RFC 4460, April\n                2006.\n   [RFC4895]    Tuexen,
    M., Stewart, R., Lei, P., and E. Rescorla,\n                \"Authenticated Chunks
    for Stream Control Transmission\n                Protocol (SCTP)\", RFC 4895,
    August 2007.\n"
  title: Informative References
- contents:
  - "Editor's Address\n   Randall R. Stewart\n   4875 Forest Drive\n   Suite 200\n
    \  Columbia, SC  29206\n   US\n   EMail: rrs@cisco.com\n"
  title: Editor's Address
- contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2007).\n   This document
    is subject to the rights, licenses and restrictions\n   contained in BCP 78, and
    except as set forth therein, the authors\n   retain all their rights.\n   This
    document and the information contained herein are provided on an\n   \"AS IS\"
    basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE INTERNET ENGINEERING
    TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT
    LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION HEREIN WILL NOT INFRINGE
    ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the procedures with respect to
    rights in RFC documents can be\n   found in BCP 78 and BCP 79.\n   Copies of IPR
    disclosures made to the IETF Secretariat and any\n   assurances of licenses to
    be made available, or the result of an\n   attempt made to obtain a general license
    or permission for the use of\n   such proprietary rights by implementers or users
    of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at\n   ietf-ipr@ietf.org.\n"
  title: Intellectual Property
