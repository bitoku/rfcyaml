- title: __initial_text__
  contents:
  - '         Generic Security Service Application Program Interface

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This RFC specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" for the standardization state and status\n   of this protocol.\
    \  Distribution of this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   This Generic Security Service Application Program Interface (GSS-API)\n\
    \   definition provides security services to callers in a generic\n   fashion,\
    \ supportable with a range of underlying mechanisms and\n   technologies and hence\
    \ allowing source-level portability of\n   applications to different environments.\
    \ This specification defines\n   GSS-API services and primitives at a level independent\
    \ of underlying\n   mechanism and programming language environment, and is to\
    \ be\n   complemented by other, related specifications:\n        documents defining\
    \ specific parameter bindings for particular\n        language environments\n\
    \        documents defining token formats, protocols, and procedures to\n    \
    \    be implemented in order to realize GSS-API services atop\n        particular\
    \ security mechanisms\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. GSS-API Characteristics and Concepts .......................\
    \    2\n   1.1. GSS-API Constructs .......................................   \
    \ 5\n   1.1.1.  Credentials ...........................................    5\n\
    \   1.1.2.  Tokens ................................................    6\n   1.1.3.\
    \  Security Contexts .....................................    7\n   1.1.4.  Mechanism\
    \ Types .......................................    8\n   1.1.5.  Naming ................................................\
    \    9\n   1.1.6.  Channel Bindings ......................................   10\n\
    \   1.2.  GSS-API Features and Issues .............................   11\n   1.2.1.\
    \  Status Reporting ......................................   11\n   1.2.2.  Per-Message\
    \ Security Service Availability .............   12\n   1.2.3.  Per-Message Replay\
    \ Detection and Sequencing ...........   13\n   1.2.4.  Quality of Protection\
    \ .................................   15\n   2. Interface Descriptions .....................................\
    \   15\n   2.1.  Credential management calls .............................   17\n\
    \   2.1.1.  GSS_Acquire_cred call .................................   17\n   2.1.2.\
    \  GSS_Release_cred call .................................   19\n   2.1.3.  GSS_Inquire_cred\
    \ call .................................   20\n   2.2.  Context-level calls .....................................\
    \   21\n   2.2.1.  GSS_Init_sec_context call .............................   21\n\
    \   2.2.2.  GSS_Accept_sec_context call ...........................   26\n   2.2.3.\
    \  GSS_Delete_sec_context call ...........................   29\n   2.2.4.  GSS_Process_context_token\
    \ call ........................   30\n   2.2.5.  GSS_Context_time call .................................\
    \   31\n   2.3.  Per-message calls .......................................   32\n\
    \   2.3.1.  GSS_Sign call .........................................   32\n   2.3.2.\
    \  GSS_Verify call .......................................   33\n   2.3.3.  GSS_Seal\
    \ call .........................................   35\n   2.3.4.  GSS_Unseal call\
    \ .......................................   36\n   2.4.  Support calls ...........................................\
    \   37\n   2.4.1.  GSS_Display_status call ...............................   37\n\
    \   2.4.2.  GSS_Indicate_mechs call ...............................   38\n   2.4.3.\
    \  GSS_Compare_name call .................................   38\n   2.4.4.  GSS_Display_name\
    \ call .................................   39\n   2.4.5.  GSS_Import_name call\
    \ ..................................   40\n   2.4.6.  GSS_Release_name call .................................\
    \   41\n   2.4.7.  GSS_Release_buffer call ...............................   41\n\
    \   2.4.8.  GSS_Release_oid_set call ..............................   42\n   3.\
    \ Mechanism-Specific Example Scenarios .......................   42\n   3.1. \
    \ Kerberos V5, single-TGT .................................   43\n   3.2.  Kerberos\
    \ V5, double-TGT .................................   43\n   3.3.  X.509 Authentication\
    \ Framework ..........................   44\n   4. Related Activities .........................................\
    \   45\n   5. Acknowledgments ............................................   46\n\
    \   6. Security Considerations ....................................   46\n   7.\
    \ Author's Address ...........................................   46\n   Appendix\
    \ A ....................................................   47\n   Appendix B ....................................................\
    \   48\n   Appendix C ....................................................   49\n"
- title: 1. GSS-API Characteristics and Concepts
  contents:
  - "1. GSS-API Characteristics and Concepts\n   The operational paradigm in which\
    \ GSS-API operates is as follows. A\n   typical GSS-API caller is itself a communications\
    \ protocol, calling\n   on GSS-API in order to protect its communications with\n\
    \   authentication, integrity, and/or confidentiality security services.\n   A\
    \ GSS-API caller accepts tokens provided to it by its local GSS-API\n   implementation\
    \ and transfers the tokens to a peer on a remote system;\n   that peer passes\
    \ the received tokens to its local GSS-API\n   implementation for processing.\
    \ The security services available\n   through GSS-API in this fashion are implementable\
    \ (and have been\n   implemented) over a range of underlying mechanisms based\
    \ on secret-\n   key and public-key cryptographic technologies.\n   The GSS-API\
    \ separates the operations of initializing a security\n   context between peers,\
    \ achieving peer entity authentication (This\n   security service definition,\
    \ and other definitions used in this\n   document, corresponds to that provided\
    \ in International Standard ISO\n   7498-2-1988(E), Security Architecture.) (GSS_Init_sec_context()\
    \ and\n   GSS_Accept_sec_context() calls), from the operations of providing\n\
    \   per-message data origin authentication and data integrity protection\n   (GSS_Sign()\
    \ and GSS_Verify() calls) for messages subsequently\n   transferred in conjunction\
    \ with that context. Per-message GSS_Seal()\n   and GSS_Unseal() calls provide\
    \ the data origin authentication and\n   data integrity services which GSS_Sign()\
    \ and GSS_Verify() offer, and\n   also support selection of confidentiality services\
    \ as a caller\n   option.  Additional calls provide supportive functions to the\
    \ GSS-\n   API's users.\n   The following paragraphs provide an example illustrating\
    \ the\n   dataflows involved in use of the GSS-API by a client and server in a\n\
    \   mechanism-independent fashion, establishing a security context and\n   transferring\
    \ a protected message. The example assumes that credential\n   acquisition has\
    \ already been completed.  The example assumes that the\n   underlying authentication\
    \ technology is capable of authenticating a\n   client to a server using elements\
    \ carried within a single token, and\n   of authenticating the server to the client\
    \ (mutual authentication)\n   with a single returned token; this assumption holds\
    \ for presently-\n   documented CAT mechanisms but is not necessarily true for\
    \ other\n   cryptographic technologies and associated protocols.\n   The client\
    \ calls GSS_Init_sec_context()  to establish a security\n   context to the server\
    \ identified by targ_name, and elects to set the\n   mutual_req_flag so that mutual\
    \ authentication is performed in the\n   course of context establishment. GSS_Init_sec_context()\
    \  returns an\n   output_token to be passed to the server, and indicates\n   GSS_CONTINUE_NEEDED\
    \ status pending completion of the mutual\n   authentication sequence. Had mutual_req_flag\
    \ not been set, the\n   initial call to GSS_Init_sec_context()  would have returned\n\
    \   GSS_COMPLETE status. The client sends the output_token to the server.\n  \
    \ The server passes the received token as the input_token parameter to\n   GSS_Accept_sec_context().\
    \  GSS_Accept_sec_context indicates\n   GSS_COMPLETE status, provides the client's\
    \ authenticated identity in\n   the src_name result, and provides an output_token\
    \ to be passed to the\n   client. The server sends the output_token to the client.\n\
    \   The client passes the received token as the input_token parameter to\n   a\
    \ successor call to GSS_Init_sec_context(),  which processes data\n   included\
    \ in the token in order to achieve mutual authentication from\n   the client's\
    \ viewpoint. This call to GSS_Init_sec_context()  returns\n   GSS_COMPLETE status,\
    \ indicating successful mutual authentication and\n   the completion of context\
    \ establishment for this example.\n   The client generates a data message and\
    \ passes it to GSS_Seal().\n   GSS_Seal() performs data origin authentication,\
    \ data integrity, and\n   (optionally) confidentiality processing on the message\
    \ and\n   encapsulates the result into output_message, indicating GSS_COMPLETE\n\
    \   status. The client sends the output_message to the server.\n   The server\
    \ passes the received message to GSS_Unseal().  GSS_Unseal\n   inverts the encapsulation\
    \ performed by GSS_Seal(),  deciphers the\n   message if the optional confidentiality\
    \ feature was applied, and\n   validates the data origin authentication and data\
    \ integrity checking\n   quantities. GSS_Unseal()  indicates successful validation\
    \ by\n   returning GSS_COMPLETE status along with the resultant\n   output_message.\n\
    \   For purposes of this example, we assume that the server knows by\n   out-of-band\
    \ means that this context will have no further use after\n   one protected message\
    \ is transferred from client to server. Given\n   this premise, the server now\
    \ calls GSS_Delete_sec_context() to flush\n   context-level information. GSS_Delete_sec_context()\
    \ returns a\n   context_token for the server to pass to the client.\n   The client\
    \ passes the returned context_token to\n   GSS_Process_context_token(),  which\
    \ returns GSS_COMPLETE status after\n   deleting context-level information at\
    \ the client system.\n   The GSS-API design assumes and addresses several basic\
    \ goals,\n   including:\n      Mechanism independence: The GSS-API defines an\
    \ interface to\n      cryptographically implemented strong authentication and\
    \ other\n      security services at a generic level which is independent of\n\
    \      particular underlying mechanisms. For example, GSS-API-provided\n     \
    \ services can be implemented by secret-key technologies (e.g.,\n      Kerberos)\
    \ or public-key approaches (e.g., X.509).\n      Protocol environment independence:\
    \ The GSS-API is independent of\n      the communications protocol suites with\
    \ which it is employed,\n      permitting use in a broad range of protocol environments.\
    \ In\n      appropriate environments, an intermediate implementation \"veneer\"\
    \n      which is oriented to a particular communication protocol (e.g.,\n    \
    \  Remote Procedure Call (RPC)) may be interposed between\n      applications\
    \ which call that protocol and the GSS-API, thereby\n      invoking GSS-API facilities\
    \ in conjunction with that protocol's\n      communications invocations.\n   \
    \   Protocol association independence: The GSS-API's security context\n      construct\
    \ is independent of communications protocol association\n      constructs. This\
    \ characteristic allows a single GSS-API\n      implementation to be utilized\
    \ by a variety of invoking protocol\n      modules on behalf of those modules'\
    \ calling applications. GSS-API\n      services can also be invoked directly by\
    \ applications, wholly\n      independent of protocol associations.\n      Suitability\
    \ to a range of implementation placements: GSS-API\n      clients are not constrained\
    \ to reside within any Trusted Computing\n      Base (TCB) perimeter defined on\
    \ a system where the GSS-API is\n      implemented; security services are specified\
    \ in a manner suitable\n      to both intra-TCB and extra-TCB callers.\n"
- title: 1.1. GSS-API Constructs
  contents:
  - "1.1. GSS-API Constructs\n   This section describes the basic elements comprising\
    \ the GSS-API.\n"
- title: 1.1.1.  Credentials
  contents:
  - "1.1.1.  Credentials\n   Credentials structures provide the prerequisites enabling\
    \ peers to\n   establish security contexts with each other. A caller may designate\n\
    \   that its default credential be used for context establishment calls\n   without\
    \ presenting an explicit handle to that credential.\n   Alternately, those GSS-API\
    \ callers which need to make explicit\n   selection of particular credentials\
    \ structures may make references to\n   those credentials through GSS-API-provided\
    \ credential handles\n   (\"cred_handles\").\n   A single credential structure\
    \ may be used for initiation of outbound\n   contexts and acceptance of inbound\
    \ contexts. Callers needing to\n   operate in only one of these modes may designate\
    \ this fact when\n   credentials are acquired for use, allowing underlying mechanisms\
    \ to\n   optimize their processing and storage requirements. The credential\n\
    \   elements defined by a particular mechanism may contain multiple\n   cryptographic\
    \ keys, e.g., to enable authentication and message\n   encryption to be performed\
    \ with different algorithms.\n   A single credential structure may accommodate\
    \ credential information\n   associated with multiple underlying mechanisms (mech_types);\
    \ a\n   credential structure's contents will vary depending on the set of\n  \
    \ mech_types supported by a particular GSS-API implementation.\n   Commonly, a\
    \ single mech_type will be used for all security contexts\n   established by a\
    \ particular initiator to a particular target; the\n   primary motivation for\
    \ supporting credential sets representing\n   multiple mech_types is to allow\
    \ initiators on systems which are\n   equipped to handle multiple types to initiate\
    \ contexts to targets on\n   other systems which can accommodate only a subset\
    \ of the set\n   supported at the initiator's system.\n   It is the responsibility\
    \ of underlying system-specific mechanisms and\n   OS functions below the GSS-API\
    \ to ensure that the ability to acquire\n   and use credentials associated with\
    \ a given identity is constrained\n   to appropriate processes within a system.\
    \ This responsibility should\n   be taken seriously by implementors, as the ability\
    \ for an entity to\n   utilize a principal's credentials is equivalent to the\
    \ entity's\n   ability to successfully assert that principal's identity.\n   Once\
    \ a set of GSS-API credentials is established, the transferability\n   of that\
    \ credentials set to other processes or analogous constructs\n   within a system\
    \ is a local matter, not defined by the GSS-API. An\n   example local policy would\
    \ be one in which any credentials received\n   as a result of login to a given\
    \ user account, or of delegation of\n   rights to that account, are accessible\
    \ by, or transferable to,\n   processes running under that account.\n   The credential\
    \ establishment process (particularly when performed on\n   behalf of users rather\
    \ than server processes) is likely to require\n   access to passwords or other\
    \ quantities which should be protected\n   locally and exposed for the shortest\
    \ time possible. As a result, it\n   will often be appropriate for preliminary\
    \ credential establishment to\n   be performed through local means at user login\
    \ time, with the\n   result(s) cached for subsequent reference. These preliminary\n\
    \   credentials would be set aside (in a system-specific fashion) for\n   subsequent\
    \ use, either:\n      to be accessed by an invocation of the GSS-API GSS_Acquire_cred()\n\
    \      call, returning an explicit handle to reference that credential\n     \
    \ as the default credentials installed on behalf of a process\n"
- title: 1.1.2. Tokens
  contents:
  - "1.1.2. Tokens\n   Tokens are data elements transferred between GSS-API callers,\
    \ and are\n   divided into two classes. Context-level tokens are exchanged in\
    \ order\n   to establish and manage a security context between peers. Per-message\n\
    \   tokens are exchanged in conjunction with an established context to\n   provide\
    \ protective security services for corresponding data messages.\n   The internal\
    \ contents of both classes of tokens are specific to the\n   particular underlying\
    \ mechanism used to support the GSS-API; Appendix\n   B of this document provides\
    \ a uniform recommendation for designers of\n   GSS-API support mechanisms, encapsulating\
    \ mechanism-specific\n   information along with a globally-interpretable mechanism\
    \ identifier.\n   Tokens are opaque from the viewpoint of GSS-API callers. They\
    \ are\n   generated within the GSS-API implementation at an end system,\n   provided\
    \ to a GSS-API caller to be transferred to the peer GSS-API\n   caller at a remote\
    \ end system, and processed by the GSS-API\n   implementation at that remote end\
    \ system. Tokens may be output by\n   GSS-API primitives (and are to be transferred\
    \ to GSS-API peers)\n   independent of the status indications which those primitives\n\
    \   indicate. Token transfer may take place in an in-band manner,\n   integrated\
    \ into the same protocol stream used by the GSS-API callers\n   for other data\
    \ transfers, or in an out-of-band manner across a\n   logically separate channel.\n\
    \   Development of GSS-API support primitives based on a particular\n   underlying\
    \ cryptographic technique and protocol does not necessarily\n   imply that GSS-API\
    \ callers invoking that GSS-API mechanism type will\n   be able to interoperate\
    \ with peers invoking the same technique and\n   protocol outside the GSS-API\
    \ paradigm.  For example, the format of\n   GSS-API tokens defined in conjunction\
    \ with a particular mechanism,\n   and the techniques used to integrate those\
    \ tokens into callers'\n   protocols, may not be the same as those used by non-GSS-API\
    \ callers\n   of the same underlying technique.\n"
- title: 1.1.3.  Security Contexts
  contents:
  - "1.1.3.  Security Contexts\n   Security contexts are established between peers,\
    \ using credentials\n   established locally in conjunction with each peer or received\
    \ by\n   peers via delegation. Multiple contexts may exist simultaneously\n  \
    \ between a pair of peers, using the same or different sets of\n   credentials.\
    \ Coexistence of multiple contexts using different\n   credentials allows graceful\
    \ rollover when credentials expire.\n   Distinction among multiple contexts based\
    \ on the same credentials\n   serves applications by distinguishing different\
    \ message streams in a\n   security sense.\n   The GSS-API is independent of underlying\
    \ protocols and addressing\n   structure, and depends on its callers to transport\
    \ GSS-API-provided\n   data elements. As a result of these factors, it is a caller\n\
    \   responsibility to parse communicated messages, separating GSS-API-\n   related\
    \ data elements from caller-provided data.  The GSS-API is\n   independent of\
    \ connection vs. connectionless orientation of the\n   underlying communications\
    \ service.\n   No correlation between security context and communications protocol\n\
    \   association is dictated. (The optional channel binding facility,\n   discussed\
    \ in Section 1.1.6 of this document, represents an\n   intentional exception to\
    \ this rule, supporting additional protection\n   features within GSS-API supporting\
    \ mechanisms.) This separation\n   allows the GSS-API to be used in a wide range\
    \ of communications\n   environments, and also simplifies the calling sequences\
    \ of the\n   individual calls. In many cases (depending on underlying security\n\
    \   protocol, associated mechanism, and availability of cached\n   information),\
    \ the state information required for context setup can be\n   sent concurrently\
    \ with initial signed user data, without interposing\n   additional message exchanges.\n"
- title: 1.1.4.  Mechanism Types
  contents:
  - "1.1.4.  Mechanism Types\n   In order to successfully establish a security context\
    \ with a target\n   peer, it is necessary to identify an appropriate underlying\
    \ mechanism\n   type (mech_type) which both initiator and target peers support.\
    \ The\n   definition of a mechanism embodies not only the use of a particular\n\
    \   cryptographic technology (or a hybrid or choice among alternative\n   cryptographic\
    \ technologies), but also definition of the syntax and\n   semantics of data element\
    \ exchanges which that mechanism will employ\n   in order to support security\
    \ services.\n   It is recommended that callers initiating contexts specify the\n\
    \   \"default\" mech_type value, allowing system-specific functions within\n \
    \  or invoked by the GSS-API implementation to select the appropriate\n   mech_type,\
    \ but callers may direct that a particular mech_type be\n   employed when necessary.\n\
    \   The means for identifying a shared mech_type to establish a security\n   context\
    \ with a peer will vary in different environments and\n   circumstances; examples\
    \ include (but are not limited to):\n      use of a fixed mech_type, defined by\
    \ configuration, within an\n      environment\n      syntactic convention on a\
    \ target-specific basis, through\n      examination of a target's name\n     \
    \ lookup of a target's name in a naming service or other database in\n      order\
    \ to identify mech_types supported by that target\n      explicit negotiation\
    \ between GSS-API callers in advance of\n      security context setup\n   When\
    \ transferred between GSS-API peers, mech_type specifiers (per\n   Appendix B,\
    \ represented as Object Identifiers (OIDs)) serve to\n   qualify the interpretation\
    \ of associated tokens. (The structure and\n   encoding of Object Identifiers\
    \ is defined in ISO/IEC 8824,\n   \"Specification of Abstract Syntax Notation\
    \ One (ASN.1)\" and in\n   ISO/IEC 8825, \"Specification of Basic Encoding Rules\
    \ for Abstract\n   Syntax Notation One (ASN.1)\".) Use of hierarchically structured\
    \ OIDs\n   serves to preclude ambiguous interpretation of mech_type specifiers.\n\
    \   The OID representing the DASS MechType, for example, is\n   1.3.12.2.1011.7.5.\n"
- title: 1.1.5.  Naming
  contents:
  - "1.1.5.  Naming\n   The GSS-API avoids prescription of naming structures, treating\
    \ the\n   names transferred across the interface in order to initiate and\n  \
    \ accept security contexts as opaque octet string quantities.  This\n   approach\
    \ supports the GSS-API's goal of implementability atop a range\n   of underlying\
    \ security mechanisms, recognizing the fact that\n   different mechanisms process\
    \ and authenticate names which are\n   presented in different forms. Generalized\
    \ services offering\n   translation functions among arbitrary sets of naming environments\
    \ are\n   outside the scope of the GSS-API; availability and use of local\n  \
    \ conversion functions to translate among the naming formats supported\n   within\
    \ a given end system is anticipated.\n   Two distinct classes of name representations\
    \ are used in conjunction\n   with different GSS-API parameters:\n      a printable\
    \ form (denoted by OCTET STRING), for acceptance from\n      and presentation\
    \ to users; printable name forms are accompanied by\n      OID tags identifying\
    \ the namespace to which they correspond\n      an internal form (denoted by INTERNAL\
    \ NAME), opaque to callers and\n      defined by individual GSS-API implementations;\
    \ GSS-API\n      implementations supporting multiple namespace types are\n   \
    \   responsible for maintaining internal tags to disambiguate the\n      interpretation\
    \ of particular names\n      Tagging of printable names allows GSS-API callers\
    \ and underlying\n      GSS-API mechanisms to disambiguate name types and to determine\n\
    \      whether an associated name's type is one which they are capable of\n  \
    \    processing, avoiding aliasing problems which could result from\n      misinterpreting\
    \ a name of one type as a name of another type.\n   In addition to providing means\
    \ for names to be tagged with types,\n   this specification defines primitives\
    \ to support a level of naming\n   environment independence for certain calling\
    \ applications. To provide\n   basic services oriented towards the requirements\
    \ of callers which\n   need not themselves interpret the internal syntax and semantics\
    \ of\n   names, GSS-API calls for name comparison (GSS_Compare_name()),\n   human-readable\
    \ display (GSS_Display_name()),  input conversion\n   (GSS_Import_name()), and\
    \ internal name deallocation\n   (GSS_Release_name())  functions are defined.\
    \ (It is anticipated that\n   these proposed GSS-API calls will be implemented\
    \ in many end systems\n   based on system-specific name manipulation primitives\
    \ already extant\n   within those end systems; inclusion within the GSS-API is\
    \ intended to\n   offer GSS-API callers a portable means to perform specific\n\
    \   operations, supportive of authorization and audit requirements, on\n   authenticated\
    \ names.)\n   GSS_Import_name()  implementations can, where appropriate, support\n\
    \   more than one printable syntax corresponding to a given namespace\n   (e.g.,\
    \ alternative printable representations for X.500 Distinguished\n   Names), allowing\
    \ flexibility for their callers to select among\n   alternative representations.\
    \ GSS_Display_name() implementations\n   output a printable syntax selected as\
    \ appropriate to their\n   operational environments; this selection is a local\
    \ matter. Callers\n   desiring portability across alternative printable syntaxes\
    \ should\n   refrain from implementing comparisons based on printable name forms\n\
    \   and should instead use the GSS_Compare_name()  call to determine\n   whether\
    \ or not one internal-format name matches another.\n"
- title: 1.1.6.  Channel Bindings
  contents:
  - "1.1.6.  Channel Bindings\n   The GSS-API accommodates the concept of caller-provided\
    \ channel\n   binding (\"chan_binding\") information, used by GSS-API callers\
    \ to bind\n   the establishment of a security context to relevant characteristics\n\
    \   (e.g., addresses, transformed representations of encryption keys) of\n   the\
    \ underlying communications channel and of protection mechanisms\n   applied to\
    \ that communications channel.  Verification by one peer of\n   chan_binding information\
    \ provided by the other peer to a context\n   serves to protect against various\
    \ active attacks. The caller\n   initiating a security context must determine\
    \ the chan_binding values\n   before making the GSS_Init_sec_context()  call,\
    \ and consistent values\n   must be provided by both peers to a context. Callers\
    \ should not\n   assume that underlying mechanisms provide confidentiality protection\n\
    \   for channel binding information.\n   Use or non-use of the GSS-API channel\
    \ binding facility is a caller\n   option, and GSS-API supporting mechanisms can\
    \ support operation in an\n   environment where NULL channel bindings are presented.\
    \ When non-NULL\n   channel bindings are used, certain mechanisms will offer enhanced\n\
    \   security value by interpreting the bindings' content (rather than\n   simply\
    \ representing those bindings, or signatures computed on them,\n   within tokens)\
    \ and will therefore depend on presentation of specific\n   data in a defined\
    \ format. To this end, agreements among mechanism\n   implementors are defining\
    \ conventional interpretations for the\n   contents of channel binding arguments,\
    \ including address specifiers\n   (with content dependent on communications protocol\
    \ environment) for\n   context initiators and acceptors. (These conventions are\
    \ being\n   incorporated into related documents.) In order for GSS-API callers\
    \ to\n   be portable across multiple mechanisms and achieve the full security\n\
    \   functionality available from each mechanism, it is strongly\n   recommended\
    \ that GSS-API callers provide channel bindings consistent\n   with these conventions\
    \ and those of the networking environment in\n   which they operate.\n"
- title: 1.2.  GSS-API Features and Issues
  contents:
  - "1.2.  GSS-API Features and Issues\n   This section describes aspects of GSS-API\
    \ operations, of the security\n   services which the GSS-API provides, and provides\
    \ commentary on\n   design issues.\n"
- title: 1.2.1.  Status Reporting
  contents:
  - "1.2.1.  Status Reporting\n   Each GSS-API call provides two status return values.\
    \ Major_status\n   values provide a mechanism-independent indication of call status\n\
    \   (e.g., GSS_COMPLETE, GSS_FAILURE, GSS_CONTINUE_NEEDED), sufficient to\n  \
    \ drive normal control flow within the caller in a generic fashion.\n   Table\
    \ 1 summarizes the defined major_status return codes in tabular\n   fashion.\n\
    \   Table 1: GSS-API Major Status Codes\n      FATAL ERROR CODES\n      GSS_BAD_BINDINGS\
    \             channel binding mismatch\n      GSS_BAD_MECH                 unsupported\
    \ mechanism requested\n      GSS_BAD_NAME                 invalid name provided\n\
    \      GSS_BAD_NAMETYPE             name of unsupported type provided\n      GSS_BAD_STATUS\
    \               invalid input status selector\n      GSS_BAD_SIG             \
    \     token had invalid signature\n      GSS_CONTEXT_EXPIRED          specified\
    \ security context expired\n      GSS_CREDENTIALS_EXPIRED      expired credentials\
    \ detected\n      GSS_DEFECTIVE_CREDENTIAL     defective credential detected\n\
    \      GSS_DEFECTIVE_TOKEN          defective token detected\n      GSS_FAILURE\
    \                  failure, unspecified at GSS-API\n                         \
    \          level\n      GSS_NO_CONTEXT               no valid security context\
    \ specified\n      GSS_NO_CRED                  no valid credentials provided\n\
    \      INFORMATORY STATUS CODES\n      GSS_COMPLETE                 normal completion\n\
    \      GSS_CONTINUE_NEEDED          continuation call to routine\n           \
    \                        required\n      GSS_DUPLICATE_TOKEN          duplicate\
    \ per-message token\n                                   detected\n      GSS_OLD_TOKEN\
    \                timed-out per-message token\n                               \
    \    detected\n      GSS_UNSEQ_TOKEN              out-of-order per-message token\n\
    \                                   detected\n   Minor_status provides more detailed\
    \ status information which may\n   include status codes specific to the underlying\
    \ security mechanism.\n   Minor_status values are not specified in this document.\n\
    \   GSS_CONTINUE_NEEDED major_status returns, and optional message\n   outputs,\
    \ are provided in GSS_Init_sec_context()  and\n   GSS_Accept_sec_context()  calls\
    \ so that different mechanisms'\n   employment of different numbers of messages\
    \ within their\n   authentication sequences need not be reflected in separate\
    \ code paths\n   within calling applications. Instead, such cases are accomodated\
    \ with\n   sequences of continuation calls to GSS_Init_sec_context()  and\n  \
    \ GSS_Accept_sec_context().  The same mechanism is used to encapsulate\n   mutual\
    \ authentication within the GSS-API's context initiation calls.\n   For mech_types\
    \ which require interactions with third-party servers in\n   order to establish\
    \ a security context, GSS-API context establishment\n   calls may block pending\
    \ completion of such third-party interactions.\n   On the other hand, no GSS-API\
    \ calls pend on serialized interactions\n   with GSS-API peer entities.  As a\
    \ result, local GSS-API status\n   returns cannot reflect unpredictable or asynchronous\
    \ exceptions\n   occurring at remote peers, and reflection of such status information\n\
    \   is a caller responsibility outside the GSS-API.\n"
- title: 1.2.2. Per-Message Security Service Availability
  contents:
  - "1.2.2. Per-Message Security Service Availability\n   When a context is established,\
    \ two flags are returned to indicate the\n   set of per-message protection security\
    \ services which will be\n   available on the context:\n      the integ_avail\
    \ flag indicates whether per-message integrity and\n      data origin authentication\
    \ services are available\n      the conf_avail flag indicates whether per-message\
    \ confidentiality\n      services are available, and will never be returned TRUE\
    \ unless the\n      integ_avail flag is also returned TRUE\n      GSS-API callers\
    \ desiring per-message security services should\n      check the values of these\
    \ flags at context establishment time, and\n      must be aware that a returned\
    \ FALSE value for integ_avail means\n      that invocation of GSS_Sign()  or GSS_Seal()\
    \ primitives on the\n      associated context will apply no cryptographic protection\
    \ to user\n      data messages.\n   The GSS-API per-message protection service\
    \ primitives, as the\n   category name implies, are oriented to operation at the\
    \ granularity\n   of protocol data units. They perform cryptographic operations\
    \ on the\n   data units, transfer cryptographic control information in tokens,\n\
    \   and, in the case of GSS_Seal(), encapsulate the protected data unit.\n   As\
    \ such, these primitives are not oriented to efficient data\n   protection for\
    \ stream-paradigm protocols (e.g., Telnet) if\n   cryptography must be applied\
    \ on an octet-by-octet basis.\n"
- title: 1.2.3. Per-Message Replay Detection and Sequencing
  contents:
  - "1.2.3. Per-Message Replay Detection and Sequencing\n   Certain underlying mech_types\
    \ are expected to offer support for\n   replay detection and/or sequencing of\
    \ messages transferred on the\n   contexts they support. These optionally-selectable\
    \ protection\n   features are distinct from replay detection and sequencing features\n\
    \   applied to the context establishment operation itself; the presence\n   or\
    \ absence of context-level replay or sequencing features is wholly a\n   function\
    \ of the underlying mech_type's capabilities, and is not\n   selected or omitted\
    \ as a caller option.\n   The caller initiating a context provides flags (replay_det_req_flag\n\
    \   and sequence_req_flag) to specify whether the use of per-message\n   replay\
    \ detection and sequencing features is desired on the context\n   being established.\
    \ The GSS-API implementation at the initiator system\n   can determine whether\
    \ these features are supported (and whether they\n   are optionally selectable)\
    \ as a function of mech_type, without need\n   for bilateral negotiation with\
    \ the target. When enabled, these\n   features provide recipients with indicators\
    \ as a result of GSS-API\n   processing of incoming messages, identifying whether\
    \ those messages\n   were detected as duplicates or out-of-sequence. Detection\
    \ of such\n   events does not prevent a suspect message from being provided to\
    \ a\n   recipient; the appropriate course of action on a suspect message is a\n\
    \   matter of caller policy.\n   The semantics of the replay detection and sequencing\
    \ services applied\n   to received messages, as visible across the interface which\
    \ the GSS-\n   API provides to its clients, are as follows:\n   When replay_det_state\
    \ is TRUE, the possible major_status returns for\n   well-formed and correctly\
    \ signed messages are as follows:\n      1. GSS_COMPLETE indicates that the message\
    \ was within the window\n      (of time or sequence space) allowing replay events\
    \ to be detected,\n      and that the message was not a replay of a previously-processed\n\
    \      message within that window.\n      2. GSS_DUPLICATE_TOKEN indicates that\
    \ the signature on the\n      received message was correct, but that the message\
    \ was recognized\n      as a duplicate of a previously-processed message.\n  \
    \    3. GSS_OLD_TOKEN indicates that the signature on the received\n      message\
    \ was correct, but that the message is too old to be checked\n      for duplication.\n\
    \   When sequence_state is TRUE, the possible major_status returns for\n   well-formed\
    \ and correctly signed messages are as follows:\n      1. GSS_COMPLETE indicates\
    \ that the message was within the window\n      (of time or sequence space) allowing\
    \ replay events to be detected,\n      and that the message was not a replay of\
    \ a previously-processed\n      message within that window.\n      2. GSS_DUPLICATE_TOKEN\
    \ indicates that the signature on the\n      received message was correct, but\
    \ that the message was recognized\n      as a duplicate of a previously-processed\
    \ message.\n      3. GSS_OLD_TOKEN indicates that the signature on the received\n\
    \      message was correct, but that the token is too old to be checked\n    \
    \  for duplication.\n      4. GSS_UNSEQ_TOKEN indicates that the signature on\
    \ the received\n      message was correct, but that it is earlier in a sequenced\
    \ stream\n      than a message already processed on the context.  [Note:\n   \
    \   Mechanisms can be architected to provide a stricter form of\n      sequencing\
    \ service, delivering particular messages to recipients\n      only after all\
    \ predecessor messages in an ordered stream have been\n      delivered.  This\
    \ type of support is incompatible with the GSS-API\n      paradigm in which recipients\
    \ receive all messages, whether in\n      order or not, and provide them (one\
    \ at a time, without intra-GSS-\n      API message buffering) to GSS-API routines\
    \ for validation.  GSS-\n      API facilities provide supportive functions, aiding\
    \ clients to\n      achieve strict message stream integrity in an efficient manner\
    \ in\n      conjunction with sequencing provisions in communications\n      protocols,\
    \ but the GSS-API does not offer this level of message\n      stream integrity\
    \ service by itself.]\n   As the message stream integrity features (especially\
    \ sequencing) may\n   interfere with certain applications' intended communications\n\
    \   paradigms, and since support for such features is likely to be\n   resource\
    \ intensive, it is highly recommended that mech_types\n   supporting these features\
    \ allow them to be activated selectively on\n   initiator request when a context\
    \ is established. A context initiator\n   and target are provided with corresponding\
    \ indicators\n   (replay_det_state and sequence_state), signifying whether these\n\
    \   features are active on a given context.\n   An example mech_type supporting\
    \ per-message replay detection could\n   (when replay_det_state is TRUE) implement\
    \ the feature as follows: The\n   underlying mechanism would insert timestamps\
    \ in data elements output\n   by GSS_Sign() and GSS_Seal(), and would maintain\
    \ (within a time-\n   limited window) a cache (qualified by originator-recipient\
    \ pair)\n   identifying received data elements processed by GSS_Verify() and\n\
    \   GSS_Unseal(). When this feature is active, exception status returns\n   (GSS_DUPLICATE_TOKEN,\
    \ GSS_ OLD_TOKEN) will be provided when\n   GSS_Verify() or GSS_Unseal() is presented\
    \ with a message which is\n   either a detected duplicate of a prior message or\
    \ which is too old to\n   validate against a cache of recently received messages.\n"
- title: 1.2.4.  Quality of Protection
  contents:
  - "1.2.4.  Quality of Protection\n   Some mech_types will provide their users with\
    \ fine granularity\n   control over the means used to provide per-message protection,\n\
    \   allowing callers to trade off security processing overhead\n   dynamically\
    \ against the protection requirements of particular\n   messages. A per-message\
    \ quality-of-protection parameter (analogous to\n   quality-of-service, or QOS)\
    \ selects among different QOP options\n   supported by that mechanism. On context\
    \ establishment for a multi-QOP\n   mech_type, context-level data provides the\
    \ prerequisite data for a\n   range of protection qualities.\n   It is expected\
    \ that the majority of callers will not wish to exert\n   explicit mechanism-specific\
    \ QOP control and will therefore request\n   selection of a default QOP. Definitions\
    \ of, and choices among, non-\n   default QOP values are mechanism-specific, and\
    \ no ordered sequences\n   of QOP values can be assumed equivalent across different\
    \ mechanisms.\n   Meaningful use of non-default QOP values demands that callers\
    \ be\n   familiar with the QOP definitions of an underlying mechanism or\n   mechanisms,\
    \ and is therefore a non-portable construct.\n"
- title: 2.  Interface Descriptions
  contents:
  - "2.  Interface Descriptions\n   This section describes the GSS-API's service interface,\
    \ dividing the\n   set of calls offered into four groups. Credential management\
    \ calls\n   are related to the acquisition and release of credentials by\n   principals.\
    \ Context-level calls are related to the management of\n   security contexts between\
    \ principals. Per-message calls are related\n   to the protection of individual\
    \ messages on established security\n   contexts. Support calls provide ancillary\
    \ functions useful to GSS-API\n   callers. Table 2 groups and summarizes the calls\
    \ in tabular fashion.\n      Table 2:  GSS-API Calls\n      CREDENTIAL MANAGEMENT\n\
    \      GSS_Acquire_cred             acquire credentials for use\n      GSS_Release_cred\
    \             release credentials after use\n      GSS_Inquire_cred          \
    \   display information about\n                                   credentials\n\
    \      CONTEXT-LEVEL CALLS\n      GSS_Init_sec_context         initiate outbound\
    \ security context\n      GSS_Accept_sec_context       accept inbound security\
    \ context\n      GSS_Delete_sec_context       flush context when no longer needed\n\
    \      GSS_Process_context_token    process received control token on\n      \
    \                             context\n      GSS_Context_time             indicate\
    \ validity time remaining on\n                                   context\n   \
    \   PER-MESSAGE CALLS\n      GSS_Sign                     apply signature, receive\
    \ as token\n                                   separate from message\n      GSS_Verify\
    \                   validate signature token along with\n                    \
    \               message\n      GSS_Seal                     sign, optionally encrypt,\n\
    \                                   encapsulate\n      GSS_Unseal            \
    \       decapsulate, decrypt if needed,\n                                   validate\
    \ signature\n      SUPPORT CALLS\n      GSS_Display_status           translate\
    \ status codes to printable\n                                   form\n      GSS_Indicate_mechs\
    \           indicate mech_types supported on\n                               \
    \    local system\n      GSS_Compare_name             compare two names for equality\n\
    \      GSS_Display_name             translate name to printable form\n      GSS_Import_name\
    \              convert printable name to\n                                   normalized\
    \ form\n      GSS_Release_name             free storage of normalized-form\n \
    \                                  name\n      GSS_Release_buffer           free\
    \ storage of printable name\n      GSS_Release_oid_set          free storage of\
    \ OID set object\n"
- title: 2.1.  Credential management calls
  contents:
  - "2.1.  Credential management calls\n   These GSS-API calls provide functions related\
    \ to the management of\n   credentials. Their characterization with regard to\
    \ whether or not\n   they may block pending exchanges with other network entities\
    \ (e.g.,\n   directories or authentication servers) depends in part on OS-specific\n\
    \   (extra-GSS-API) issues, so is not specified in this document.\n   The GSS_Acquire_cred()\
    \  call is defined within the GSS-API in support\n   of application portability,\
    \ with a particular orientation towards\n   support of portable server applications.\
    \ It is recognized that (for\n   certain systems and mechanisms) credentials for\
    \ interactive users may\n   be managed differently from credentials for server\
    \ processes; in such\n   environments, it is the GSS-API implementation's responsibility\
    \ to\n   distinguish these cases and the procedures for making this\n   distinction\
    \ are a local matter. The GSS_Release_cred()  call provides\n   a means for callers\
    \ to indicate to the GSS-API that use of a\n   credentials structure is no longer\
    \ required. The GSS_Inquire_cred()\n   call allows callers to determine information\
    \ about a credentials\n   structure.\n"
- title: 2.1.1.  GSS_Acquire_cred call
  contents:
  - "2.1.1.  GSS_Acquire_cred call\n   Inputs:\n   o  desired_name INTERNAL NAME,\
    \ -NULL requests locally-determined\n      default\n   o  lifetime_req INTEGER,-in\
    \ seconds; 0 requests default\n   o  desired_mechs SET OF OBJECT IDENTIFIER,-empty\
    \ set requests\n      system-selected default\n   o  cred_usage INTEGER-0=INITIATE-AND-ACCEPT,\
    \ 1=INITIATE-ONLY,\n      2=ACCEPT-ONLY\n   Outputs:\n   o  major_status INTEGER,\n\
    \   o  minor_status INTEGER,\n   o  output_cred_handle OCTET STRING,\n   o  actual_mechs\
    \ SET OF OBJECT IDENTIFIER,\n   o  lifetime_rec INTEGER -in seconds, or reserved\
    \ value for\n      INDEFINITE\n   Return major_status codes:\n   o  GSS_COMPLETE\
    \ indicates that requested credentials were\n      successfully established, for\
    \ the duration indicated in\n      lifetime_rec, suitable for the usage requested\
    \ in cred_usage, for\n      the set of mech_types indicated in actual_mechs, and\
    \ that those\n      credentials can be referenced for subsequent use with the\
    \ handle\n      returned in output_cred_handle.\n   o  GSS_BAD_MECH indicates\
    \ that a mech_type unsupported by the GSS-API\n      implementation type was requested,\
    \ causing the credential\n      establishment operation to fail.\n   o  GSS_BAD_NAMETYPE\
    \ indicates that the provided desired_name is\n      uninterpretable or of a type\
    \ unsupported by the supporting GSS-API\n      implementation, so no credentials\
    \ could be established for the\n      accompanying desired_name.\n   o  GSS_BAD_NAME\
    \ indicates that the provided desired_name is\n      inconsistent in terms of\
    \ internally-incorporated type specifier\n      information, so no credentials\
    \ could be established for the\n      accompanying desired_name.\n   o  GSS_FAILURE\
    \ indicates that credential establishment failed for\n      reasons unspecified\
    \ at the GSS-API level, including lack of\n      authorization to establish and\
    \ use credentials associated with the\n      identity named in the input desired_name\
    \ argument.\n   GSS_Acquire_cred()  is used to acquire credentials so that a\n\
    \   principal can (as a function of the input cred_usage parameter)\n   initiate\
    \ and/or accept security contexts under the identity\n   represented by the desired_name\
    \ input argument. On successful\n   completion, the returned output_cred_handle\
    \ result provides a handle\n   for subsequent references to the acquired credentials.\
    \  Typically,\n   single-user client processes using only default credentials\
    \ for\n   context establishment purposes will have no need to invoke this call.\n\
    \   A caller may provide the value NULL for desired_name, signifying a\n   request\
    \ for credentials corresponding to a default principal\n   identity.  The procedures\
    \ used by GSS-API implementations to select\n   the appropriate principal identity\
    \ in response to this form of\n   request are local matters. It is possible that\
    \ multiple pre-\n   established credentials may exist for the same principal identity\n\
    \   (for example, as a result of multiple user login sessions) when\n   GSS_Acquire_cred()\
    \ is called; the means used in such cases to select\n   a specific credential\
    \ are local matters.  The input lifetime_req\n   argument to GSS_Acquire_cred()\
    \ may provide useful information for\n   local GSS-API implementations to employ\
    \ in making this disambiguation\n   in a manner which will best satisfy a caller's\
    \ intent.\n   The lifetime_rec result indicates the length of time for which the\n\
    \   acquired credentials will be valid, as an offset from the present. A\n   mechanism\
    \ may return a reserved value indicating INDEFINITE if no\n   constraints on credential\
    \ lifetime are imposed.  A caller of\n   GSS_Acquire_cred()  can request a length\
    \ of time for which acquired\n   credentials are to be valid (lifetime_req argument),\
    \ beginning at the\n   present, or can request credentials with a default validity\
    \ interval.\n   (Requests for postdated credentials are not supported within the\n\
    \   GSS-API.) Certain mechanisms and implementations may bind in\n   credential\
    \ validity period specifiers at a point preliminary to\n   invocation of the GSS_Acquire_cred()\
    \ call (e.g., in conjunction with\n   user login procedures). As a result, callers\
    \ requesting non-default\n   values for lifetime_req must recognize that such\
    \ requests cannot\n   always be honored and must be prepared to accommodate the\
    \ use of\n   returned credentials with different lifetimes as indicated in\n \
    \  lifetime_rec.\n   The caller of GSS_Acquire_cred() can explicitly specify a\
    \ set of\n   mech_types which are to be accommodated in the returned credentials\n\
    \   (desired_mechs argument), or can request credentials for a system-\n   defined\
    \ default set of mech_types. Selection of the system-specified\n   default set\
    \ is recommended in the interests of application\n   portability. The actual_mechs\
    \ return value may be interrogated by the\n   caller to determine the set of mechanisms\
    \ with which the returned\n   credentials may be used.\n"
- title: 2.1.2.  GSS_Release_cred call
  contents:
  - "2.1.2.  GSS_Release_cred call\n   Input:\n   o  cred_handle OCTET STRING-NULL\
    \ specifies default credentials\n   Outputs:\n   o  major_status INTEGER,\n  \
    \ o  minor_status INTEGER\n   Return major_status codes:\n   o  GSS_COMPLETE indicates\
    \ that the credentials referenced by the\n      input cred_handle were released\
    \ for purposes of subsequent access\n      by the caller. The effect on other\
    \ processes which may be\n      authorized shared access to such credentials is\
    \ a local matter.\n   o  GSS_NO_CRED indicates that no release operation was performed,\n\
    \      either because the input cred_handle was invalid or because the\n     \
    \ caller lacks authorization to access the referenced credentials.\n   o  GSS_FAILURE\
    \ indicates that the release operation failed for\n      reasons unspecified at\
    \ the GSS-API level.\n   Provides a means for a caller to explicitly request that\
    \ credentials\n   be released when their use is no longer required. Note that\
    \ system-\n   specific credential management functions are also likely to exist,\n\
    \   for example to assure that credentials shared among processes are\n   properly\
    \ deleted when all affected processes terminate, even if no\n   explicit release\
    \ requests are issued by those processes.  Given the\n   fact that multiple callers\
    \ are not precluded from gaining authorized\n   access to the same credentials,\
    \ invocation of GSS_Release_cred()\n   cannot be assumed to delete a particular\
    \ set of credentials on a\n   system-wide basis.\n"
- title: 2.1.3.  GSS_Inquire_cred call
  contents:
  - "2.1.3.  GSS_Inquire_cred call\n      Input:\n      o  cred_handle OCTET STRING\
    \ -NULL specifies default credentials\n      Outputs:\n      o  major_status INTEGER,\n\
    \      o  minor_status INTEGER,\n      o  cred_name INTERNAL NAME,\n      o  lifetime_rec\
    \ INTEGER -in seconds, or reserved value for\n         INDEFINITE\n      o  cred_usage\
    \ INTEGER, -0=INITIATE-AND-ACCEPT, 1=INITIATE-ONLY,\n         2=ACCEPT-ONLY\n\
    \      o  mech_set SET OF OBJECT IDENTIFIER\n      Return major_status codes:\n\
    \      o  GSS_COMPLETE indicates that the credentials referenced by the\n    \
    \     input cred_handle argument were valid, and that the output\n         cred_name,\
    \ lifetime_rec, and cred_usage values represent,\n         respectively, the credentials'\
    \ associated principal name,\n         remaining lifetime, suitable usage modes,\
    \ and supported\n         mechanism types.\n      o  GSS_NO_CRED indicates that\
    \ no information could be returned\n         about the referenced credentials,\
    \ either because the input\n         cred_handle was invalid or because the caller\
    \ lacks\n         authorization to access the referenced credentials.\n      o\
    \  GSS_FAILURE indicates that the release operation failed for\n         reasons\
    \ unspecified at the GSS-API level.\n   The GSS_Inquire_cred()  call is defined\
    \ primarily for the use of\n   those callers which make use of default credentials\
    \ rather than\n   acquiring credentials explicitly with GSS_Acquire_cred().  It\
    \ enables\n   callers to determine a credential structure's associated principal\n\
    \   name, remaining validity period, usability for security context\n   initiation\
    \ and/or acceptance, and supported mechanisms.\n"
- title: 2.2.  Context-level calls
  contents:
  - "2.2.  Context-level calls\n   This group of calls is devoted to the establishment\
    \ and management of\n   security contexts between peers. A context's initiator\
    \ calls\n   GSS_Init_sec_context(),  resulting in generation of a token which\
    \ the\n   caller passes to the target. At the target, that token is passed to\n\
    \   GSS_Accept_sec_context().  Depending on the underlying mech_type and\n   specified\
    \ options, additional token exchanges may be performed in the\n   course of context\
    \ establishment; such exchanges are accommodated by\n   GSS_CONTINUE_NEEDED status\
    \ returns from GSS_Init_sec_context()  and\n   GSS_Accept_sec_context().  Either\
    \ party to an established context may\n   invoke GSS_Delete_sec_context()  to\
    \ flush context information when a\n   context is no longer required. GSS_Process_context_token()\
    \  is used\n   to process received tokens carrying context-level control\n   information.\
    \ GSS_Context_time()  allows a caller to determine the\n   length of time for\
    \ which an established context will remain valid.\n"
- title: 2.2.1.  GSS_Init_sec_context call
  contents:
  - "2.2.1.  GSS_Init_sec_context call\n   Inputs:\n   o  claimant_cred_handle OCTET\
    \ STRING, -NULL specifies \"use\n      default\"\n   o  input_context_handle INTEGER,\
    \ -0 specifies \"none assigned\n      yet\"\n   o  targ_name INTERNAL NAME,\n\
    \   o  mech_type OBJECT IDENTIFIER, -NULL parameter specifies \"use\n      default\"\
    \n   o  deleg_req_flag BOOLEAN,\n   o  mutual_req_flag BOOLEAN,\n   o  replay_det_req_flag\
    \ BOOLEAN,\n   o  sequence_req_flag BOOLEAN,\n   o  lifetime_req INTEGER,-0 specifies\
    \ default lifetime\n   o  chan_bindings OCTET STRING,\n   o  input_token OCTET\
    \ STRING-NULL or token received from target\n   Outputs:\n   o  major_status INTEGER,\n\
    \   o  minor_status INTEGER,\n   o  output_context_handle INTEGER,\n   o  mech_type\
    \ OBJECT IDENTIFIER, -actual mechanism always\n      indicated, never NULL\n \
    \  o  output_token OCTET STRING, -NULL or token to pass to context\n      target\n\
    \   o  deleg_state BOOLEAN,\n   o  mutual_state BOOLEAN,\n   o  replay_det_state\
    \ BOOLEAN,\n   o  sequence_state BOOLEAN,\n   o  conf_avail BOOLEAN,\n   o  integ_avail\
    \ BOOLEAN,\n   o  lifetime_rec INTEGER - in seconds, or reserved value for\n \
    \     INDEFINITE\n   This call may block pending network interactions for those\
    \ mech_types\n   in which an authentication server or other network entity must\
    \ be\n   consulted on behalf of a context initiator in order to generate an\n\
    \   output_token suitable for presentation to a specified target.\n   Return major_status\
    \ codes:\n   o  GSS_COMPLETE indicates that context-level information was\n  \
    \    successfully initialized, and that the returned output_token will\n     \
    \ provide sufficient information for the target to perform per-\n      message\
    \ processing on the newly-established context.\n   o  GSS_CONTINUE_NEEDED indicates\
    \ that control information in the\n      returned output_token must be sent to\
    \ the target, and that a reply\n      must be received and passed as the input_token\
    \ argument to a\n      continuation call to GSS_Init_sec_context(),  before per-message\n\
    \      processing can be performed in conjunction with this context.\n   o  GSS_DEFECTIVE_TOKEN\
    \ indicates that consistency checks performed on\n      the input_token failed,\
    \ preventing further processing from being\n      performed based on that token.\n\
    \   o  GSS_DEFECTIVE_CREDENTIAL indicates that consistency checks\n      performed\
    \ on the credential structure referenced by\n      claimant_cred_handle failed,\
    \ preventing further processing from\n      being performed using that credential\
    \ structure.\n   o  GSS_BAD_SIG indicates that the received input_token contains\
    \ an\n      incorrect signature, so context setup cannot be accomplished.\n  \
    \ o  GSS_NO_CRED indicates that no context was established, either\n      because\
    \ the input cred_handle was invalid, because the referenced\n      credentials\
    \ are valid for context acceptor use only, or because\n      the caller lacks\
    \ authorization to access the referenced\n      credentials.\n   o  GSS_CREDENTIALS_EXPIRED\
    \ indicates that the credentials provided\n      through the input claimant_cred_handle\
    \ argument are no longer\n      valid, so context establishment cannot be completed.\n\
    \   o  GSS_BAD_BINDINGS indicates that a mismatch between the caller-\n      provided\
    \ chan_bindings and those extracted from the input_token\n      was detected,\
    \ signifying a security-relevant event and preventing\n      context establishment.\
    \ (This result will be returned by\n      GSS_Init_sec_context only for contexts\
    \ where mutual_state is\n      TRUE.)\n   o  GSS_NO_CONTEXT indicates that no\
    \ valid context was recognized for\n      the input context_handle provided; this\
    \ major status will be\n      returned only for successor calls following GSS_CONTINUE_NEEDED\n\
    \      status returns.\n   o  GSS_BAD_NAMETYPE indicates that the provided targ_name\
    \ is of a\n      type uninterpretable or unsupported by the supporting GSS-API\n\
    \      implementation, so context establishment cannot be completed.\n   o  GSS_BAD_NAME\
    \ indicates that the provided targ_name is inconsistent\n      in terms of internally-incorporated\
    \ type specifier information, so\n      context establishment cannot be accomplished.\n\
    \   o  GSS_FAILURE indicates that context setup could not be accomplished\n  \
    \    for reasons unspecified at the GSS-API level, and that no\n      interface-defined\
    \ recovery action is available.\n   This routine is used by a context initiator,\
    \ and ordinarily emits one\n   (or, for the case of a multi-step exchange, more\
    \ than one)\n   output_token suitable for use by the target within the selected\n\
    \   mech_type's protocol. Using information in the credentials structure\n   referenced\
    \ by claimant_cred_handle, GSS_Init_sec_context()\n   initializes the data structures\
    \ required to establish a security\n   context with target targ_name. The claimant_cred_handle\
    \ must\n   correspond to the same valid credentials structure on the initial\n\
    \   call to GSS_Init_sec_context()  and on any successor calls resulting\n   from\
    \ GSS_CONTINUE_NEEDED status returns; different protocol sequences\n   modeled\
    \ by the GSS_CONTINUE_NEEDED mechanism will require access to\n   credentials\
    \ at different points in the context establishment\n   sequence.\n   The input_context_handle\
    \ argument is 0, specifying \"not yet\n   assigned\", on the first GSS_Init_sec_context()\
    \  call relating to a\n   given context. That call returns an output_context_handle\
    \ for future\n   references to this context. When continuation attempts to\n \
    \  GSS_Init_sec_context()  are needed to perform context establishment,\n   the\
    \ previously-returned non-zero handle value is entered into the\n   input_context_handle\
    \ argument and will be echoed in the returned\n   output_context_handle argument.\
    \ On such continuation attempts (and\n   only on continuation attempts) the input_token\
    \ value is used, to\n   provide the token returned from the context's target.\n\
    \   The chan_bindings argument is used by the caller to provide\n   information\
    \ binding the security context to security-related\n   characteristics (e.g.,\
    \ addresses, cryptographic keys) of the\n   underlying communications channel.\
    \ See Section 1.1.6 of this document\n   for more discussion of this argument's\
    \ usage.\n   The input_token argument contains a message received from the target,\n\
    \   and is significant only on a call to GSS_Init_sec_context() which\n   follows\
    \ a previous return indicating GSS_CONTINUE_NEEDED\n   major_status.\n   It is\
    \ the caller's responsibility to establish a communications path\n   to the target,\
    \ and to transmit any returned output_token (independent\n   of the accompanying\
    \ returned major_status value) to the target over\n   that path. The output_token\
    \ can, however, be transmitted along with\n   the first application-provided input\
    \ message to be processed by\n   GSS_Sign() or GSS_Seal() in conjunction with\
    \ a successfully-\n   established context.\n   The initiator may request various\
    \ context-level functions through\n   input flags: the deleg_req_flag requests\
    \ delegation of access rights,\n   the mutual_req_flag requests mutual authentication,\
    \ the\n   replay_det_req_flag requests that replay detection features be\n   applied\
    \ to messages transferred on the established context, and the\n   sequence_req_flag\
    \ requests that sequencing be enforced. (See Section\n   1.2.3 for more information\
    \ on replay detection and sequencing\n   features.)\n   Not all of the optionally-requestable\
    \ features will be available in\n   all underlying mech_types; the corresponding\
    \ return state values\n   (deleg_state, mutual_state, replay_det_state, sequence_state)\n\
    \   indicate, as a function of mech_type processing capabilities and\n   initiator-provided\
    \ input flags, the set of features which will be\n   active on the context. These\
    \ state indicators' values are undefined\n   unless the routine's major_status\
    \ indicates COMPLETE. Failure to\n   provide the precise set of features requested\
    \ by the caller does not\n   cause context establishment to fail; it is the caller's\
    \ prerogative\n   to delete the context if the feature set provided is unsuitable\
    \ for\n   the caller's use.  The returned mech_type value indicates the\n   specific\
    \ mechanism employed on the context, and will never indicate\n   the value for\
    \ \"default\".\n   The conf_avail return value indicates whether the context supports\n\
    \   per-message confidentiality services, and so informs the caller\n   whether\
    \ or not a request for encryption through the conf_req_flag\n   input to GSS_Seal()\
    \ can be honored. In similar fashion, the\n   integ_avail return value indicates\
    \ whether per-message integrity\n   services are available (through either GSS_Sign()\
    \ or GSS_Seal()) on\n   the established context.\n   The lifetime_req input specifies\
    \ a desired upper bound for the\n   lifetime of the context to be established,\
    \ with a value of 0 used to\n   request a default lifetime. The lifetime_rec return\
    \ value indicates\n   the length of time for which the context will be valid,\
    \ expressed as\n   an offset from the present; depending on mechanism capabilities,\n\
    \   credential lifetimes, and local policy, it may not correspond to the\n   value\
    \ requested in lifetime_req.  If no constraints on context\n   lifetime are imposed,\
    \ this may be indicated by returning a reserved\n   value representing INDEFINITE\
    \ lifetime_req. The values of conf_avail,\n   integ_avail, and lifetime_rec are\
    \ undefined unless the routine's\n   major_status indicates COMPLETE.\n   If the\
    \ mutual_state is TRUE, this fact will be reflected within the\n   output_token.\
    \ A call to GSS_Accept_sec_context() at the target in\n   conjunction with such\
    \ a context will return a token, to be processed\n   by a continuation call to\
    \ GSS_Init_sec_context(), in order to achieve\n   mutual authentication.\n"
- title: 2.2.2.  GSS_Accept_sec_context call
  contents:
  - "2.2.2.  GSS_Accept_sec_context call\n   Inputs:\n   o  acceptor_cred_handle OCTET\
    \ STRING,-NULL specifies \"use\n      default\"\n   o  input_context_handle INTEGER,\
    \ -0 specifies \"not yet assigned\"\n   o  chan_bindings OCTET STRING,\n   o \
    \ input_token OCTET STRING\n   Outputs:\n   o  major_status INTEGER,\n   o  minor_status\
    \ INTEGER,\n   o  src_name INTERNAL NAME,\n   o  mech_type OBJECT IDENTIFIER,\n\
    \   o  output_context_handle INTEGER,\n   o  deleg_state BOOLEAN,\n   o  mutual_state\
    \ BOOLEAN,\n   o  replay_det_state BOOLEAN,\n   o  sequence_state BOOLEAN,\n \
    \  o  conf_avail BOOLEAN,\n   o  integ_avail BOOLEAN,\n   o  lifetime_rec INTEGER,\
    \ - in seconds, or reserved value for\n      INDEFINITE\n   o  delegated_cred_handle\
    \ OCTET STRING,\n   o  output_token OCTET STRING -NULL or token to pass to context\n\
    \      initiator\n   This call may block pending network interactions for those\
    \ mech_types\n   in which a directory service or other network entity must be\n\
    \   consulted on behalf of a context acceptor in order to validate a\n   received\
    \ input_token.\n   Return major_status codes:\n   o  GSS_COMPLETE indicates that\
    \ context-level data structures were\n      successfully initialized, and that\
    \ per-message processing can now\n      be performed in conjunction with this\
    \ context.\n   o  GSS_CONTINUE_NEEDED indicates that control information in the\n\
    \      returned output_token must be sent to the initiator, and that a\n     \
    \ response must be received and passed as the input_token argument\n      to a\
    \ continuation call to GSS_Accept_sec_context(), before per-\n      message processing\
    \ can be performed in conjunction with this\n      context.\n   o  GSS_DEFECTIVE_TOKEN\
    \ indicates that consistency checks performed on\n      the input_token failed,\
    \ preventing further processing from being\n      performed based on that token.\n\
    \   o  GSS_DEFECTIVE_CREDENTIAL indicates that consistency checks\n      performed\
    \ on the credential structure referenced by\n      acceptor_cred_handle failed,\
    \ preventing further processing from\n      being performed using that credential\
    \ structure.\n   o  GSS_BAD_SIG indicates that the received input_token contains\
    \ an\n      incorrect signature, so context setup cannot be accomplished.\n  \
    \ o  GSS_DUPLICATE_TOKEN indicates that the signature on the received\n      input_token\
    \ was correct, but that the input_token was recognized\n      as a duplicate of\
    \ an input_token already processed. No new context\n      is established.\n  \
    \ o  GSS_OLD_TOKEN indicates that the signature on the received\n      input_token\
    \ was correct, but that the input_token is too old to be\n      checked for duplication\
    \ against previously-processed input_tokens.\n      No new context is established.\n\
    \   o  GSS_NO_CRED indicates that no context was established, either\n      because\
    \ the input cred_handle was invalid, because the referenced\n      credentials\
    \ are valid for context initiator use only, or because\n      the caller lacks\
    \ authorization to access the referenced\n      credentials.\n   o  GSS_CREDENTIALS_EXPIRED\
    \ indicates that the credentials provided\n      through the input acceptor_cred_handle\
    \ argument are no longer\n      valid, so context establishment cannot be completed.\n\
    \   o  GSS_BAD_BINDINGS indicates that a mismatch between the caller-\n      provided\
    \ chan_bindings and those extracted from the input_token\n      was detected,\
    \ signifying a security-relevant event and preventing\n      context establishment.\n\
    \   o GSS_NO_CONTEXT indicates that no valid context was recognized for\n    \
    \  the input context_handle provided; this major status will be\n      returned\
    \ only for successor calls following GSS_CONTINUE_NEEDED\n      status returns.\n\
    \   o  GSS_FAILURE indicates that context setup could not be accomplished\n  \
    \    for reasons unspecified at the GSS-API level, and that no\n      interface-defined\
    \ recovery action is available.\n   The GSS_Accept_sec_context()  routine is used\
    \ by a context target.\n   Using information in the credentials structure referenced\
    \ by the\n   input acceptor_cred_handle, it verifies the incoming input_token\
    \ and\n   (following the successful completion of a context establishment\n  \
    \ sequence) returns the authenticated src_name and the mech_type used.\n   The\
    \ acceptor_cred_handle must correspond to the same valid\n   credentials structure\
    \ on the initial call to GSS_Accept_sec_context()\n   and on any successor calls\
    \ resulting from GSS_CONTINUE_NEEDED status\n   returns; different protocol sequences\
    \ modeled by the\n   GSS_CONTINUE_NEEDED mechanism will require access to credentials\
    \ at\n   different points in the context establishment sequence.\n   The input_context_handle\
    \ argument is 0, specifying \"not yet\n   assigned\", on the first GSS_Accept_sec_context()\
    \  call relating to a\n   given context. That call returns an output_context_handle\
    \ for future\n   references to this context; when continuation attempts to\n \
    \  GSS_Accept_sec_context()  are needed to perform context\n   establishment,\
    \ that handle value will be entered into the\n   input_context_handle argument.\n\
    \   The chan_bindings argument is used by the caller to provide\n   information\
    \ binding the security context to security-related\n   characteristics (e.g.,\
    \ addresses, cryptographic keys) of the\n   underlying communications channel.\
    \ See Section 1.1.6 of this document\n   for more discussion of this argument's\
    \ usage.\n   The returned state results (deleg_state, mutual_state,\n   replay_det_state,\
    \ and sequence_state) reflect the same context state\n   values as returned to\
    \ GSS_Init_sec_context()'s  caller at the\n   initiator system.\n   The conf_avail\
    \ return value indicates whether the context supports\n   per-message confidentiality\
    \ services, and so informs the caller\n   whether or not a request for encryption\
    \ through the conf_req_flag\n   input to GSS_Seal()  can be honored. In similar\
    \ fashion, the\n   integ_avail return value indicates whether per-message integrity\n\
    \   services are available (through either GSS_Sign()  or GSS_Seal())  on\n  \
    \ the established context.\n   The lifetime_rec return value indicates the length\
    \ of time for which\n   the context will be valid, expressed as an offset from\
    \ the present.\n   The values of deleg_state, mutual_state, replay_det_state,\n\
    \   sequence_state, conf_avail, integ_avail, and lifetime_rec are\n   undefined\
    \ unless the accompanying major_status indicates COMPLETE.\n   The delegated_cred_handle\
    \ result is significant only when deleg_state\n   is TRUE, and provides a means\
    \ for the target to reference the\n   delegated credentials. The output_token\
    \ result, when non-NULL,\n   provides a context-level token to be returned to\
    \ the context\n   initiator to continue a multi-step context establishment sequence.\
    \ As\n   noted with GSS_Init_sec_context(),  any returned token should be\n  \
    \ transferred to the context's peer (in this case, the context\n   initiator),\
    \ independent of the value of the accompanying returned\n   major_status.\n  \
    \ Note: A target must be able to distinguish a context-level\n   input_token,\
    \ which is passed to GSS_Accept_sec_context(),  from the\n   per-message data\
    \ elements passed to GSS_Verify()  or GSS_Unseal().\n   These data elements may\
    \ arrive in a single application message, and\n   GSS_Accept_sec_context()  must\
    \ be performed before per-message\n   processing can be performed successfully.\n"
- title: 2.2.3. GSS_Delete_sec_context call
  contents:
  - "2.2.3. GSS_Delete_sec_context call\n   Input:\n   o  context_handle INTEGER\n\
    \   Outputs:\n   o  major_status INTEGER,\n   o  minor_status INTEGER,\n   o \
    \ output_context_token OCTET STRING\n   Return major_status codes:\n   o  GSS_COMPLETE\
    \ indicates that the context was recognized, that\n      relevant context-specific\
    \ information was flushed, and that the\n      returned output_context_token is\
    \ ready for transfer to the\n      context's peer.\n   o  GSS_NO_CONTEXT indicates\
    \ that no valid context was recognized for\n      the input context_handle provide,\
    \ so no deletion was performed.\n   o  GSS_FAILURE indicates that the context\
    \ is recognized, but that the\n      GSS_Delete_sec_context()  operation could\
    \ not be performed for\n      reasons unspecified at the GSS-API level.\n   This\
    \ call may block pending network interactions for mech_types in\n   which active\
    \ notification must be made to a central server when a\n   security context is\
    \ to be deleted.\n   This call can be made by either peer in a security context,\
    \ to flush\n   context-specific information and to return an output_context_token\n\
    \   which can be passed to the context's peer informing it that the\n   peer's\
    \ corresponding context information can also be flushed. (Once a\n   context is\
    \ established, the peers involved are expected to retain\n   cached credential\
    \ and context-related information until the\n   information's expiration time\
    \ is reached or until a\n   GSS_Delete_sec_context() call is made.) Attempts to\
    \ perform per-\n   message processing on a deleted context will result in error\
    \ returns.\n"
- title: 2.2.4.  GSS_Process_context_token call
  contents:
  - "2.2.4.  GSS_Process_context_token call\n   Inputs:\n   o  context_handle INTEGER,\n\
    \   o  input_context_token OCTET STRING\n   Outputs:\n   o  major_status INTEGER,\n\
    \   o  minor_status INTEGER,\n   Return major_status codes:\n   o  GSS_COMPLETE\
    \ indicates that the input_context_token was\n      successfully processed in\
    \ conjunction with the context referenced\n      by context_handle.\n   o  GSS_DEFECTIVE_TOKEN\
    \ indicates that consistency checks performed on\n      the received context_token\
    \ failed, preventing further processing\n      from being performed with that\
    \ token.\n   o  GSS_NO_CONTEXT indicates that no valid context was recognized\
    \ for\n      the input context_handle provided.\n   o  GSS_FAILURE indicates that\
    \ the context is recognized, but that the\n      GSS_Process_context_token() \
    \ operation could not be performed for\n      reasons unspecified at the GSS-API\
    \ level.\n   This call is used to process context_tokens received from a peer\
    \ once\n   a context has been established, with corresponding impact on\n   context-level\
    \ state information. One use for this facility is\n   processing of the context_tokens\
    \ generated by\n   GSS_Delete_sec_context();  GSS_Process_context_token() will\
    \ not block\n   pending network interactions for that purpose. Another use is\
    \ to\n   process tokens indicating remote-peer context establishment failures\n\
    \   after the point where the local GSS-API implementation has already\n   indicated\
    \ GSS_COMPLETE status.\n"
- title: 2.2.5.  GSS_Context_time call
  contents:
  - "2.2.5.  GSS_Context_time call\n   Input:\n   o  context_handle INTEGER,\n   Outputs:\n\
    \   o  major_status INTEGER,\n   o  minor_status INTEGER,\n   o  lifetime_rec\
    \ INTEGER - in seconds, or reserved value for\n      INDEFINITE\n   Return major_status\
    \ codes:\n   o  GSS_COMPLETE indicates that the referenced context is valid, and\n\
    \      will remain valid for the amount of time indicated in\n      lifetime_rec.\n\
    \   o  GSS_CONTEXT_EXPIRED indicates that data items related to the\n      referenced\
    \ context have expired.\n   o  GSS_CREDENTIALS_EXPIRED indicates that the context\
    \ is recognized,\n      but that its associated credentials have expired.\n  \
    \ o  GSS_NO_CONTEXT indicates that no valid context was recognized for\n     \
    \ the input context_handle provided.\n   o  GSS_FAILURE indicates that the requested\
    \ operation failed for\n      reasons unspecified at the GSS-API level.\n   This\
    \ call is used to determine the amount of time for which a\n   currently established\
    \ context will remain valid.\n"
- title: 2.3.  Per-message calls
  contents:
  - "2.3.  Per-message calls\n   This group of calls is used to perform per-message\
    \ protection\n   processing on an established security context. None of these\
    \ calls\n   block pending network interactions. These calls may be invoked by\
    \ a\n   context's initiator or by the context's target.  The four members of\n\
    \   this group should be considered as two pairs; the output from\n   GSS_Sign()\
    \  is properly input to GSS_Verify(),  and the output from\n   GSS_Seal() is properly\
    \ input to GSS_Unseal().\n   GSS_Sign()  and GSS_Verify() support data origin\
    \ authentication and\n   data integrity services. When GSS_Sign()  is invoked\
    \ on an input\n   message, it yields a per-message token containing data items\
    \ which\n   allow underlying mechanisms to provide the specified security\n  \
    \ services. The original message, along with the generated per-message\n   token,\
    \ is passed to the remote peer; these two data elements are\n   processed by GSS_Verify(),\
    \  which validates the message in\n   conjunction with the separate token.\n \
    \  GSS_Seal()  and GSS_Unseal() support caller-requested confidentiality\n   in\
    \ addition to the data origin authentication and data integrity\n   services offered\
    \ by GSS_Sign()  and GSS_Verify(). GSS_Seal()  outputs\n   a single data element,\
    \ encapsulating optionally enciphered user data\n   as well as associated token\
    \ data items.  The data element output from\n   GSS_Seal()  is passed to the remote\
    \ peer and processed by\n   GSS_Unseal()  at that system. GSS_Unseal() combines\
    \ decipherment (as\n   required) with validation of data items related to authentication\
    \ and\n   integrity.\n"
- title: 2.3.1.  GSS_Sign call
  contents:
  - "2.3.1.  GSS_Sign call\n   Inputs:\n   o  context_handle INTEGER,\n   o  qop_req\
    \ INTEGER,-0 specifies default QOP\n   o  message OCTET STRING\n   Outputs:\n\
    \   o  major_status INTEGER,\n   o  minor_status INTEGER,\n   o  per_msg_token\
    \ OCTET STRING\n   Return major_status codes:\n   o  GSS_COMPLETE indicates that\
    \ a signature, suitable for an\n      established security context, was successfully\
    \ applied and that\n      the message and corresponding per_msg_token are ready\
    \ for\n      transmission.\n   o  GSS_CONTEXT_EXPIRED indicates that context-related\
    \ data items have\n      expired, so that the requested operation cannot be performed.\n\
    \   o  GSS_CREDENTIALS_EXPIRED indicates that the context is recognized,\n   \
    \   but that its associated credentials have expired, so that the\n      requested\
    \ operation cannot be performed.\n   o  GSS_NO_CONTEXT indicates that no valid\
    \ context was recognized for\n      the input context_handle provided.\n   o \
    \ GSS_FAILURE indicates that the context is recognized, but that the\n      requested\
    \ operation could not be performed for reasons unspecified\n      at the GSS-API\
    \ level.\n   Using the security context referenced by context_handle, apply a\n\
    \   signature to the input message (along with timestamps and/or other\n   data\
    \ included in support of mech_type-specific mechanisms) and return\n   the result\
    \ in per_msg_token. The qop_req parameter allows quality-\n   of-protection control.\
    \ The caller passes the message and the\n   per_msg_token to the target.\n   The\
    \ GSS_Sign()  function completes before the message and\n   per_msg_token is sent\
    \ to the peer; successful application of\n   GSS_Sign()  does not guarantee that\
    \ a corresponding GSS_Verify() has\n   been (or can necessarily be) performed\
    \ successfully when the message\n   arrives at the destination.\n"
- title: 2.3.2.  GSS_Verify call
  contents:
  - "2.3.2.  GSS_Verify call\n   Inputs:\n   o  context_handle INTEGER,\n   o  message\
    \ OCTET STRING,\n   o  per_msg_token OCTET STRING\n   Outputs:\n   o  qop_state\
    \ INTEGER,\n   o  major_status INTEGER,\n   o  minor_status INTEGER,\n   Return\
    \ major_status codes:\n   o  GSS_COMPLETE indicates that the message was successfully\
    \ verified.\n   o  GSS_DEFECTIVE_TOKEN indicates that consistency checks performed\
    \ on\n      the received per_msg_token failed, preventing further processing\n\
    \      from being performed with that token.\n   o  GSS_BAD_SIG indicates that\
    \ the received per_msg_token contains an\n      incorrect signature for the message.\n\
    \   o  GSS_DUPLICATE_TOKEN, GSS_OLD_TOKEN, and GSS_UNSEQ_TOKEN values\n      appear\
    \ in conjunction with the optional per-message replay\n      detection features\
    \ described in Section 1.2.3; their semantics are\n      described in that section.\n\
    \   o  GSS_CONTEXT_EXPIRED indicates that context-related data items have\n  \
    \    expired, so that the requested operation cannot be performed.\n   o  GSS_CREDENTIALS_EXPIRED\
    \ indicates that the context is recognized,\n      but that its associated credentials\
    \ have expired, so that the\n      requested operation cannot be performed.\n\
    \   o  GSS_NO_CONTEXT indicates that no valid context was recognized for\n   \
    \   the input context_handle provided.\n   o  GSS_FAILURE indicates that the context\
    \ is recognized, but that the\n      GSS_Verify()  operation could not be performed\
    \ for reasons\n      unspecified at the GSS-API level.\n   Using the security\
    \ context referenced by context_handle, verify that\n   the input per_msg_token\
    \ contains an appropriate signature for the\n   input message, and apply any active\
    \ replay detection or sequencing\n   features. Return an indication of the quality-of-protection\
    \ applied\n   to the processed message in the qop_state result.\n"
- title: 2.3.3. GSS_Seal call
  contents:
  - "2.3.3. GSS_Seal call\n   Inputs:\n   o  context_handle INTEGER,\n   o  conf_req_flag\
    \ BOOLEAN,\n   o  qop_req INTEGER,-0 specifies default QOP\n   o  input_message\
    \ OCTET STRING\n   Outputs:\n   o  major_status INTEGER,\n   o  minor_status INTEGER,\n\
    \   o  conf_state BOOLEAN,\n   o  output_message OCTET STRING\n   Return major_status\
    \ codes:\n   o  GSS_COMPLETE indicates that the input_message was successfully\n\
    \      processed and that the output_message is ready for transmission.\n   o\
    \  GSS_CONTEXT_EXPIRED indicates that context-related data items have\n      expired,\
    \ so that the requested operation cannot be performed.\n   o  GSS_CREDENTIALS_EXPIRED\
    \ indicates that the context is recognized,\n      but that its associated credentials\
    \ have expired, so that the\n      requested operation cannot be performed.\n\
    \   o  GSS_NO_CONTEXT indicates that no valid context was recognized for\n   \
    \   the input context_handle provided.\n   o  GSS_FAILURE indicates that the context\
    \ is recognized, but that the\n      GSS_Seal()  operation could not be performed\
    \ for reasons\n      unspecified at the GSS-API level.\n   Performs the data origin\
    \ authentication and data integrity functions\n   of GSS_Sign().  If the input\
    \ conf_req_flag is TRUE, requests that\n   confidentiality be applied to the input_message.\
    \  Confidentiality may\n   not be supported in all mech_types or by all implementations;\
    \ the\n   returned conf_state flag indicates whether confidentiality was\n   provided\
    \ for the input_message. The qop_req parameter allows\n   quality-of-protection\
    \ control.\n   In all cases, the GSS_Seal()  call yields a single output_message\n\
    \   data element containing (optionally enciphered) user data as well as\n   control\
    \ information.\n"
- title: 2.3.4. GSS_Unseal call
  contents:
  - "2.3.4. GSS_Unseal call\n   Inputs:\n   o  context_handle INTEGER,\n   o  input_message\
    \ OCTET STRING\n   Outputs:\n   o  conf_state BOOLEAN,\n   o  qop_state INTEGER,\n\
    \   o  major_status INTEGER,\n   o  minor_status INTEGER,\n   o  output_message\
    \ OCTET STRING\n   Return major_status codes:\n   o  GSS_COMPLETE indicates that\
    \ the input_message was successfully\n      processed and that the resulting output_message\
    \ is available.\n   o  GSS_DEFECTIVE_TOKEN indicates that consistency checks performed\
    \ on\n      the per_msg_token extracted from the input_message failed,\n     \
    \ preventing further processing from being performed.\n   o  GSS_BAD_SIG indicates\
    \ that an incorrect signature was detected for\n      the message.\n   o  GSS_DUPLICATE_TOKEN,\
    \ GSS_OLD_TOKEN, and GSS_UNSEQ_TOKEN values\n      appear in conjunction with\
    \ the optional per-message replay\n      detection features described in Section\
    \ 1.2.3; their semantics are\n      described in that section.\n   o  GSS_CONTEXT_EXPIRED\
    \ indicates that context-related data items have\n      expired, so that the requested\
    \ operation cannot be performed.\n   o  GSS_CREDENTIALS_EXPIRED indicates that\
    \ the context is recognized,\n      but that its associated credentials have expired,\
    \ so that the\n      requested operation cannot be performed.\n   o  GSS_NO_CONTEXT\
    \ indicates that no valid context was recognized for\n      the input context_handle\
    \ provided.\n   o  GSS_FAILURE indicates that the context is recognized, but that\
    \ the\n      GSS_Unseal()  operation could not be performed for reasons\n    \
    \  unspecified at the GSS-API level.\n   Processes a data element generated (and\
    \ optionally enciphered) by\n   GSS_Seal(),  provided as input_message. The returned\
    \ conf_state value\n   indicates whether confidentiality was applied to the input_message.\n\
    \   If conf_state is TRUE, GSS_Unseal()  deciphers the input_message.\n   Returns\
    \ an indication of the quality-of-protection applied to the\n   processed message\
    \ in the qop_state result. GSS_Seal()  performs the\n   data integrity and data\
    \ origin authentication checking functions of\n   GSS_Verify()  on the plaintext\
    \ data. Plaintext data is returned in\n   output_message.\n"
- title: 2.4.  Support calls
  contents:
  - "2.4.  Support calls\n   This group of calls provides support functions useful\
    \ to GSS-API\n   callers, independent of the state of established contexts. Their\n\
    \   characterization with regard to blocking or non-blocking status in\n   terms\
    \ of network interactions is unspecified.\n"
- title: 2.4.1.  GSS_Display_status call
  contents:
  - "2.4.1.  GSS_Display_status call\n   Inputs:\n   o  status_value INTEGER,-GSS-API\
    \ major_status or minor_status\n      return value\n   o  status_type INTEGER,-1\
    \ if major_status, 2 if minor_status\n   o  mech_type OBJECT IDENTIFIER-mech_type\
    \ to be used for minor_\n      status translation\n   Outputs:\n   o  major_status\
    \ INTEGER,\n   o  minor_status INTEGER,\n   o  status_string_set SET OF OCTET\
    \ STRING\n   Return major_status codes:\n   o  GSS_COMPLETE indicates that a valid\
    \ printable status\n      representation (possibly representing more than one\
    \ status event\n      encoded within the status_value) is available in the returned\n\
    \      status_string_set.\n   o  GSS_BAD_MECH indicates that translation in accordance\
    \ with an\n      unsupported mech_type was requested, so translation could not\
    \ be\n      performed.\n   o  GSS_BAD_STATUS indicates that the input status_value\
    \ was invalid,\n      or that the input status_type carried a value other than\
    \ 1 or 2,\n      so translation could not be performed.\n   o  GSS_FAILURE indicates\
    \ that the requested operation could not be\n      performed for reasons unspecified\
    \ at the GSS-API level.\n   Provides a means for callers to translate GSS-API-returned\
    \ major and\n   minor status codes into printable string representations.\n"
- title: 2.4.2.  GSS_Indicate_mechs call
  contents:
  - "2.4.2.  GSS_Indicate_mechs call\n   Input:\n   o  (none)\n   Outputs:\n   o \
    \ major_status INTEGER,\n   o  minor_status INTEGER,\n   o  mech_set SET OF OBJECT\
    \ IDENTIFIER\n   Return major_status codes:\n   o  GSS_COMPLETE indicates that\
    \ a set of available mechanisms has\n      been returned in mech_set.\n   o  GSS_FAILURE\
    \ indicates that the requested operation could not\n      be performed for reasons\
    \ unspecified at the GSS-API level.\n   Allows callers to determine the set of\
    \ mechanism types available on\n   the local system. This call is intended for\
    \ support of specialized\n   callers who need to request non-default mech_type\
    \ sets from\n   GSS_Acquire_cred(),  and should not be needed by other callers.\n"
- title: 2.4.3.  GSS_Compare_name call
  contents:
  - "2.4.3.  GSS_Compare_name call\n   Inputs:\n   o  name1 INTERNAL NAME,\n   o \
    \ name2 INTERNAL NAME\n   Outputs:\n   o  major_status INTEGER,\n   o  minor_status\
    \ INTEGER,\n   o  name_equal BOOLEAN\n   Return major_status codes:\n   o  GSS_COMPLETE\
    \ indicates that name1 and name2 were comparable, and\n      that the name_equal\
    \ result indicates whether name1 and name2 were\n      equal or unequal.\n   o\
    \  GSS_BAD_NAMETYPE indicates that one or both of name1 and name2\n      contained\
    \ internal type specifiers uninterpretable by the\n      supporting GSS-API implementation,\
    \ or that the two names' types\n      are different and incomparable, so the equality\
    \ comparison could\n      not be completed.\n   o  GSS_BAD_NAME indicates that\
    \ one or both of the input names was\n      ill-formed in terms of its internal\
    \ type specifier, so the\n      equality comparison could not be completed.\n\
    \   o  GSS_FAILURE indicates that the requested operation could not be\n     \
    \ performed for reasons unspecified at the GSS-API level.\n   Allows callers to\
    \ compare two internal name representations for\n   equality.\n"
- title: 2.4.4.  GSS_Display_name call
  contents:
  - "2.4.4.  GSS_Display_name call\n   Inputs:\n   o  name INTERNAL NAME\n   Outputs:\n\
    \   o  major_status INTEGER,\n   o  minor_status INTEGER,\n   o  name_string OCTET\
    \ STRING,\n   o  name_type OBJECT IDENTIFIER\n   Return major_status codes:\n\
    \   o  GSS_COMPLETE indicates that a valid printable name representation\n   \
    \   is available in the returned name_string.\n   o  GSS_BAD_NAMETYPE indicates\
    \ that the provided name was of a type\n      uninterpretable by the supporting\
    \ GSS-API implementation, so no\n      printable representation could be generated.\n\
    \   o  GSS_BAD_NAME indicates that the contents of the provided name were\n  \
    \    inconsistent with the internally-indicated name type, so no\n      printable\
    \ representation could be generated.\n   o  GSS_FAILURE indicates that the requested\
    \ operation could not be\n      performed for reasons unspecified at the GSS-API\
    \ level.\n   Allows callers to translate an internal name representation into\
    \ a\n   printable form with associated namespace type descriptor. The syntax\n\
    \   of the printable form is a local matter.\n"
- title: 2.4.5.  GSS_Import_name call
  contents:
  - "2.4.5.  GSS_Import_name call\n   Inputs:\n   o  input_name_string OCTET STRING,\n\
    \   o  input_name_type OBJECT IDENTIFIER\n   Outputs:\n   o  major_status INTEGER,\n\
    \   o  minor_status INTEGER,\n   o  output_name INTERNAL NAME\n   Return major_status\
    \ codes:\n   o  GSS_COMPLETE indicates that a valid name representation is output\n\
    \      in output_name and described by the type value in\n      output_name_type.\n\
    \   o  GSS_BAD_NAMETYPE indicates that the input_name_type is unsupported\n  \
    \    by the GSS-API implementation, so the import operation could not\n      be\
    \ completed.\n   o  GSS_BAD_NAME indicates that the provided input_name_string\
    \ is\n      ill-formed in terms of the input_name_type, so the import\n      operation\
    \ could not be completed.\n   o  GSS_FAILURE indicates that the requested operation\
    \ could not be\n      performed for reasons unspecified at the GSS-API level.\n\
    \   Allows callers to provide a printable name representation, designate\n   the\
    \ type of namespace in conjunction with which it should be parsed,\n   and convert\
    \ that printable representation to an internal form\n   suitable for input to\
    \ other GSS-API routines.  The syntax of the\n   input_name is a local matter.\n"
- title: 2.4.6. GSS_Release_name call
  contents:
  - "2.4.6. GSS_Release_name call\n   Inputs:\n   o  name INTERNAL NAME\n   Outputs:\n\
    \   o  major_status INTEGER,\n   o  minor_status INTEGER\n   Return major_status\
    \ codes:\n   o  GSS_COMPLETE indicates that the storage associated with the input\n\
    \      name was successfully released.\n   o  GSS_BAD_NAME indicates that the\
    \ input name argument did not\n      contain a valid name.\n   o  GSS_FAILURE\
    \ indicates that the requested operation could not be\n      performed for reasons\
    \ unspecified at the GSS-API level.\n   Allows callers to release the storage\
    \ associated with an internal\n   name representation.\n"
- title: 2.4.7. GSS_Release_buffer call
  contents:
  - "2.4.7. GSS_Release_buffer call\n   Inputs:\n   o  buffer OCTET STRING\n   Outputs:\n\
    \   o  major_status INTEGER,\n   o  minor_status INTEGER\n   Return major_status\
    \ codes:\n   o  GSS_COMPLETE indicates that the storage associated with the input\n\
    \      buffer was successfully released.\n   o  GSS_FAILURE indicates that the\
    \ requested operation could not be\n      performed for reasons unspecified at\
    \ the GSS-API level.\n   Allows callers to release the storage associated with\
    \ an OCTET STRING\n   buffer allocated by another GSS-API call.\n"
- title: 2.4.8. GSS_Release_oid_set call
  contents:
  - "2.4.8. GSS_Release_oid_set call\n   Inputs:\n   o  buffer SET OF OBJECT IDENTIFIER\n\
    \   Outputs:\n   o  major_status INTEGER,\n   o  minor_status INTEGER\n   Return\
    \ major_status codes:\n   o  GSS_COMPLETE indicates that the storage associated\
    \ with the input\n      object identifier set was successfully released.\n   o\
    \  GSS_FAILURE indicates that the requested operation could not be\n      performed\
    \ for reasons unspecified at the GSS-API level.\n   Allows callers to release\
    \ the storage associated with an object\n   identifier set object allocated by\
    \ another GSS-API call.\n"
- title: 3.  Mechanism-Specific Example Scenarios
  contents:
  - "3.  Mechanism-Specific Example Scenarios\n   This section provides illustrative\
    \ overviews of the use of various\n   candidate mechanism types to support the\
    \ GSS-API. These discussions\n   are intended primarily for readers familiar with\
    \ specific security\n   technologies, demonstrating how GSS-API functions can\
    \ be used and\n   implemented by candidate underlying mechanisms. They should\
    \ not be\n   regarded as constrictive to implementations or as defining the only\n\
    \   means through which GSS-API functions can be realized with a\n   particular\
    \ underlying technology, and do not demonstrate all GSS-API\n   features with\
    \ each technology.\n"
- title: 3.1. Kerberos V5, single-TGT
  contents:
  - "3.1. Kerberos V5, single-TGT\n   OS-specific login functions yield a TGT to the\
    \ local realm Kerberos\n   server; TGT is placed in a credentials structure for\
    \ the client.\n   Client calls GSS_Acquire_cred()  to acquire a cred_handle in\
    \ order to\n   reference the credentials for use in establishing security contexts.\n\
    \   Client calls GSS_Init_sec_context().  If the requested service is\n   located\
    \ in a different realm, GSS_Init_sec_context()  gets the\n   necessary TGT/key\
    \ pairs needed to traverse the path from local to\n   target realm; these data\
    \ are placed in the owner's TGT cache. After\n   any needed remote realm resolution,\
    \ GSS_Init_sec_context()  yields a\n   service ticket to the requested service\
    \ with a corresponding session\n   key; these data are stored in conjunction with\
    \ the context. GSS-API\n   code sends KRB_TGS_REQ request(s) and receives KRB_TGS_REP\n\
    \   response(s) (in the successful case) or KRB_ERROR.\n   Assuming success, GSS_Init_sec_context()\
    \  builds a Kerberos-formatted\n   KRB_AP_REQ message, and returns it in output_token.\
    \  The client sends\n   the output_token to the service.\n   The service passes\
    \ the received token as the input_token argument to\n   GSS_Accept_sec_context(),\
    \  which verifies the authenticator, provides\n   the service with the client's\
    \ authenticated name, and returns an\n   output_context_handle.\n   Both parties\
    \ now hold the session key associated with the service\n   ticket, and can use\
    \ this key in subsequent GSS_Sign(), GSS_Verify(),\n   GSS_Seal(), and GSS_Unseal()\
    \ operations.\n"
- title: 3.2. Kerberos V5, double-TGT
  contents:
  - "3.2. Kerberos V5, double-TGT\n   TGT acquisition as above.\n   Note: To avoid\
    \ unnecessary frequent invocations of error paths when\n   implementing the GSS-API\
    \ atop Kerberos V5, it seems appropriate to\n   represent \"single-TGT K-V5\"\
    \ and \"double-TGT K-V5\" with separate\n   mech_types, and this discussion makes\
    \ that assumption.\n   Based on the (specified or defaulted) mech_type,\n   GSS_Init_sec_context()\
    \  determines that the double-TGT protocol\n   should be employed for the specified\
    \ target. GSS_Init_sec_context()\n   returns GSS_CONTINUE_NEEDED major_status,\
    \ and its returned\n   output_token contains a request to the service for the\
    \ service's TGT.\n   (If a service TGT with suitably long remaining lifetime already\n\
    \   exists in a cache, it may be usable, obviating the need for this\n   step.)\
    \ The client passes the output_token to the service.  Note: this\n   scenario\
    \ illustrates a different use for the GSS_CONTINUE_NEEDED\n   status return facility\
    \ than for support of mutual authentication;\n   note that both uses can coexist\
    \ as successive operations within a\n   single context establishment operation.\n\
    \   The service passes the received token as the input_token argument to\n   GSS_Accept_sec_context(),\
    \  which recognizes it as a request for TGT.\n   (Note that current Kerberos V5\
    \ defines no intra-protocol mechanism to\n   represent such a request.) GSS_Accept_sec_context()\
    \  returns\n   GSS_CONTINUE_NEEDED major_status and provides the service's TGT\
    \ in\n   its output_token. The service sends the output_token to the client.\n\
    \   The client passes the received token as the input_token argument to a\n  \
    \ continuation of GSS_Init_sec_context(). GSS_Init_sec_context() caches\n   the\
    \ received service TGT and uses it as part of a service ticket\n   request to\
    \ the Kerberos authentication server, storing the returned\n   service ticket\
    \ and session key in conjunction with the context.\n   GSS_Init_sec_context()\
    \  builds a Kerberos-formatted authenticator,\n   and returns it in output_token\
    \ along with GSS_COMPLETE return\n   major_status. The client sends the output_token\
    \ to the service.\n   Service passes the received token as the input_token argument\
    \ to a\n   continuation call to GSS_Accept_sec_context().\n   GSS_Accept_sec_context()\
    \  verifies the authenticator, provides the\n   service with the client's authenticated\
    \ name, and returns\n   major_status GSS_COMPLETE.\n   GSS_Sign(),  GSS_Verify(),\
    \ GSS_Seal(), and GSS_Unseal()  as above.\n"
- title: 3.3.  X.509 Authentication Framework
  contents:
  - "3.3.  X.509 Authentication Framework\n   This example illustrates use of the\
    \ GSS-API in conjunction with\n   public-key mechanisms, consistent with the X.509\
    \ Directory\n   Authentication Framework.\n   The GSS_Acquire_cred()  call establishes\
    \ a credentials structure,\n   making the client's private key accessible for\
    \ use on behalf of the\n   client.\n   The client calls GSS_Init_sec_context(),\
    \  which interrogates the\n   Directory to acquire (and validate) a chain of public-key\n\
    \   certificates, thereby collecting the public key of the service.  The\n   certificate\
    \ validation operation determines that suitable signatures\n   were applied by\
    \ trusted authorities and that those certificates have\n   not expired. GSS_Init_sec_context()\
    \  generates a secret key for use\n   in per-message protection operations on\
    \ the context, and enciphers\n   that secret key under the service's public key.\n\
    \   The enciphered secret key, along with an authenticator quantity\n   signed\
    \ with the client's private key, is included in the output_token\n   from GSS_Init_sec_context().\
    \  The output_token also carries a\n   certification path, consisting of a certificate\
    \ chain leading from\n   the service to the client; a variant approach would defer\
    \ this path\n   resolution to be performed by the service instead of being asserted\n\
    \   by the client. The client application sends the output_token to the\n   service.\n\
    \   The service passes the received token as the input_token argument to\n   GSS_Accept_sec_context().\
    \  GSS_Accept_sec_context() validates the\n   certification path, and as a result\
    \ determines a certified binding\n   between the client's distinguished name and\
    \ the client's public key.\n   Given that public key, GSS_Accept_sec_context()\
    \ can process the\n   input_token's authenticator quantity and verify that the\
    \ client's\n   private key was used to sign the input_token. At this point, the\n\
    \   client is authenticated to the service. The service uses its private\n   key\
    \ to decipher the enciphered secret key provided to it for per-\n   message protection\
    \ operations on the context.\n   The client calls GSS_Sign()  or GSS_Seal() on\
    \ a data message, which\n   causes per-message authentication, integrity, and\
    \ (optional)\n   confidentiality facilities to be applied to that message. The\
    \ service\n   uses the context's shared secret key to perform corresponding\n\
    \   GSS_Verify()  and GSS_Unseal() calls.\n"
- title: 4.  Related Activities
  contents:
  - "4.  Related Activities\n   In order to implement the GSS-API atop existing, emerging,\
    \ and future\n   security mechanisms:\n      object identifiers must be assigned\
    \ to candidate GSS-API\n      mechanisms and the name types which they support\n\
    \      concrete data element formats must be defined for candidate\n      mechanisms\n\
    \   Calling applications must implement formatting conventions which will\n  \
    \ enable them to distinguish GSS-API tokens from other data carried in\n   their\
    \ application protocols.\n   Concrete language bindings are required for the programming\n\
    \   environments in which the GSS-API is to be employed; such bindings\n   for\
    \ the C language are available in an associated RFC.\n"
- title: 5.  Acknowledgments
  contents:
  - "5.  Acknowledgments\n   This proposal is the result of a collaborative effort.\n\
    \   Acknowledgments are due to the many members of the IETF Security Area\n  \
    \ Advisory Group (SAAG) and the Common Authentication Technology (CAT)\n   Working\
    \ Group for their contributions at meetings and by electronic\n   mail. Acknowledgments\
    \ are also due to Kannan Alagappan, Doug Barlow,\n   Bill Brown, Cliff Kahn, Charlie\
    \ Kaufman, Butler Lampson, Richard\n   Pitkin, Joe Tardo, and John Wray of Digital\
    \ Equipment Corporation,\n   and John Carr, John Kohl, Jon Rochlis, Jeff Schiller,\
    \ and Ted T'so of\n   MIT and Project Athena.  Joe Pato and Bill Sommerfeld of\
    \ HP/Apollo,\n   Walt Tuvell of OSF, and Bill Griffith and Mike Merritt of AT&T,\n\
    \   provided inputs which helped to focus and clarify directions.\n   Precursor\
    \ work by Richard Pitkin, presented to meetings of the\n   Trusted Systems Interoperability\
    \ Group (TSIG), helped to demonstrate\n   the value of a generic, mechanism-independent\
    \ security service API.\n"
- title: 6. Security Considerations
  contents:
  - "6. Security Considerations\n   Security issues are discussed throughout this\
    \ memo.\n"
- title: 7. Author's Address
  contents:
  - "7. Author's Address\n   John Linn\n   Geer Zolot Associates\n   One Main St.\n\
    \   Cambridge, MA  02142  USA\n   Phone: +1 617.374.3700\n   Email: Linn@gza.com\n"
- title: APPENDIX  A
  contents:
  - 'APPENDIX  A

    '
- title: PACS AND AUTHORIZATION SERVICES
  contents:
  - "PACS AND AUTHORIZATION SERVICES\n   Consideration has been given to modifying\
    \ the GSS-API service\n   interface to recognize and manipulate Privilege Attribute\n\
    \   Certificates (PACs) as in ECMA 138, carrying authorization data as a\n   side\
    \ effect of establishing a security context, but no such\n   modifications have\
    \ been incorporated at this time. This appendix\n   provides rationale for this\
    \ decision and discusses compatibility\n   alternatives between PACs and the GSS-API\
    \ which do not require that\n   PACs be made visible to GSS-API callers.\n   Existing\
    \ candidate mechanism types such as Kerberos and X.509 do not\n   incorporate\
    \ PAC manipulation features, and exclusion of such\n   mechanisms from the set\
    \ of candidates equipped to fully support the\n   GSS-API seems inappropriate.\
    \ Inclusion (and GSS-API visibility) of a\n   feature supported by only a limited\
    \ number of mechanisms could\n   encourage the development of ostensibly portable\
    \ applications which\n   would in fact have only limited portability.\n   The\
    \ status quo, in which PACs are not visible across the GSS-API\n   interface,\
    \ does not preclude implementations in which PACs are\n   carried transparently,\
    \ within the tokens defined and used for certain\n   mech_types, and stored within\
    \ peers' credentials and context-level\n   data structures. While invisible to\
    \ API callers, such PACs could be\n   used by operating system or other local\
    \ functions as inputs in the\n   course of mediating access requests made by callers.\
    \ This course of\n   action allows dynamic selection of PAC contents, if such\
    \ selection is\n   administratively-directed rather than caller-directed.\n  \
    \ In a distributed computing environment, authentication must span\n   different\
    \ systems; the need for such authentication provides\n   motivation for GSS-API\
    \ definition and usage. Heterogeneous systems in\n   a network can intercommunicate,\
    \ with globally authenticated names\n   comprising the common bond between locally\
    \ defined access control\n   policies. Access control policies to which authentication\
    \ provides\n   inputs are often local, or specific to particular operating systems\n\
    \   or environments. If the GSS-API made particular authorization models\n   visible\
    \ across its service interface, its scope of application would\n   become less\
    \ general. The current GSS-API paradigm is consistent with\n   the precedent set\
    \ by Kerberos, neither defining the interpretation of\n   authorization-related\
    \ data nor enforcing access controls based on\n   such data.\n   The GSS-API is\
    \ a general interface, whose callers may reside inside\n   or outside any defined\
    \ TCB or NTCB boundaries. Given this\n   characteristic, it appears more realistic\
    \ to provide facilities which\n   provide \"value-added\" security services to\
    \ its callers than to offer\n   facilities which enforce restrictions on those\
    \ callers. Authorization\n   decisions must often be mediated below the GSS-API\
    \ level in a local\n   manner against (or in spite of) applications, and cannot\
    \ be\n   selectively invoked or omitted at those applications' discretion.\n \
    \  Given that the GSS-API's placement prevents it from providing a\n   comprehensive\
    \ solution to the authorization issue, the value of a\n   partial contribution\
    \ specific to particular authorization models is\n   debatable.\n"
- title: APPENDIX  B
  contents:
  - 'APPENDIX  B

    '
- title: MECHANISM-INDEPENDENT TOKEN FORMAT
  contents:
  - "MECHANISM-INDEPENDENT TOKEN FORMAT\n   This appendix specifies a mechanism-independent\
    \ level of\n   encapsulating representation for the initial token of a GSS-API\n\
    \   context establishment sequence, incorporating an identifier of the\n   mechanism\
    \ type to be used on that context. Use of this format (with\n   ASN.1-encoded\
    \ data elements represented in BER, constrained in the\n   interests of parsing\
    \ simplicity to the Distinguished Encoding Rule\n   (DER) BER subset defined in\
    \ X.509, clause 8.7) is recommended to the\n   designers of GSS-API implementations\
    \ based on various mechanisms, so\n   that tokens can be interpreted unambiguously\
    \ at GSS-API peers. There\n   is no requirement that the mechanism-specific innerContextToken,\n\
    \   innerMsgToken, and sealedUserData data elements be encoded in ASN.1\n   BER.\n\
    \          -- optional top-level token definitions to\n          -- frame different\
    \ mechanisms\n          GSS-API DEFINITIONS ::=\n          BEGIN\n          MechType\
    \ ::= OBJECT IDENTIFIER\n          -- data structure definitions\n          --\
    \ callers must be able to distinguish among\n          -- InitialContextToken,\
    \ SubsequentContextToken,\n          -- PerMsgToken, and SealedMessage data elements\n\
    \          -- based on the usage in which they occur\n          InitialContextToken\
    \ ::=\n          -- option indication (delegation, etc.) indicated within\n  \
    \        -- mechanism-specific token\n          [APPLICATION 0] IMPLICIT SEQUENCE\
    \ {\n                  thisMech MechType,\n                  innerContextToken\
    \ ANY DEFINED BY thisMech\n                     -- contents mechanism-specific\n\
    \                  }\n          SubsequentContextToken ::= innerContextToken ANY\n\
    \          -- interpretation based on predecessor InitialContextToken\n      \
    \    PerMsgToken ::=\n          -- as emitted by GSS_Sign and processed by GSS_Verify\n\
    \                  innerMsgToken ANY\n          SealedMessage ::=\n          --\
    \ as emitted by GSS_Seal and processed by GSS_Unseal\n          -- includes internal,\
    \ mechanism-defined indicator\n          -- of whether or not encrypted\n    \
    \              sealedUserData ANY\n          END\n"
- title: APPENDIX  C
  contents:
  - 'APPENDIX  C

    '
- title: MECHANISM DESIGN CONSTRAINTS
  contents:
  - "MECHANISM DESIGN CONSTRAINTS\n   The following constraints on GSS-API mechanism\
    \ designs are adopted in\n   response to observed caller protocol requirements,\
    \ and adherence\n   thereto is anticipated in subsequent descriptions of GSS-API\n\
    \   mechanisms to be documented in standards-track Internet\n   specifications.\n\
    \   Use of the approach defined in Appendix B of this specification,\n   applying\
    \ a mechanism type tag to the InitialContextToken, is\n   required.\n   It is\
    \ strongly recommended that mechanisms offering per-message\n   protection services\
    \ also offer at least one of the replay detection\n   and sequencing services,\
    \ as mechanisms offering neither of the latter\n   will fail to satisfy recognized\
    \ requirements of certain candidate\n   caller protocols.\n"
