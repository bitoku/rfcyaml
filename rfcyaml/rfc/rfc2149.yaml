- title: __initial_text__
  contents:
  - '     Multicast Server Architectures for MARS-based ATM multicasting

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  This memo\n   does not specify an Internet standard of any kind.  Distribution\
    \ of\n   this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   A mechanism to support the multicast needs of layer 3 protocols\
    \ in\n   general, and IP in particular, over UNI 3.0/3.1 based ATM networks\n\
    \   has been described in RFC 2022.  Two basic approaches exist for the\n   intra-subnet\
    \ (intra-cluster) multicasting of IP packets.  One makes\n   use of a mesh of\
    \ point to multipoint VCs (the 'VC Mesh' approach),\n   while the other uses a\
    \ shared point to multipoint tree rooted on a\n   Multicast Server (MCS). This\
    \ memo provides details on the design and\n   implementation of an MCS, building\
    \ on the core mechanisms defined in\n   RFC 2022.  It also provides a mechanism\
    \ for using multiple MCSs per\n   group for providing fault tolerance.  This approach\
    \ can be used with\n   RFC 2022 based MARS server and clients, without needing\
    \ any change in\n   their functionality.\n"
- title: 1 Introduction
  contents:
  - "1 Introduction\n   A solution to the problem of mapping layer 3 multicast service\
    \ over\n   the connection-oriented ATM service provided by UNI 3.0/3.1, has been\n\
    \   presented in [GA96].  A Multicast Address Resolution Server (MARS) is\n  \
    \ used to maintain a mapping of layer 3 group addresses to ATM\n   addresses in\
    \ that architecture.  It can be considered to be an\n   extended analog of the\
    \ ATM ARP Server introduced in RFC 1577\n   ([ML93]).  Hosts in the ATM network\
    \ use the MARS to resolve layer 3\n   multicast addresses into corresponding lists\
    \ of ATM addresses of\n   group members.  Hosts keep the MARS informed when they\
    \ need to join\n   or leave a particular layer 3 group.\n   The MARS manages a\
    \ \"cluster\" of ATM-attached endpoints.  A \"cluster\"\n   is defined as\n  \
    \ \"The set of ATM interfaces choosing to participate in direct ATM\n   connections\
    \ to achieve multicasting of AALSDUs between themselves.\"\n   In practice, a\
    \ cluster is the set of endpoints that choose to use the\n   same MARS to register\
    \ their memberships and receive their updates\n   from.\n   A sender in the cluster\
    \ has two options for multicasting data to the\n   group members.  It can either\
    \ get the list of ATM addresses\n   constituting the group from the MARS, set\
    \ up a point-to-multipoint\n   virtual circuit (VC) with the group members as\
    \ leaves, and then\n   proceed to send data out on it.  Alternatively, the source\
    \ can make\n   use of a proxy Multicast Server (MCS).  The source transmits data\
    \ to\n   such an MCS, which in turn uses a point-to-multipoint VC to get the\n\
    \   data to the group members.\n   The MCS approach has been briefly introduced\
    \ in [GA96].  This memo\n   presents a detailed description of MCS architecture\
    \ and proposes a\n   simple mechanism for supporting multiple MCSs for fault tolerance.\n\
    \   We assume an understanding of the IP multicasting over UNI 3.0/3.1\n   ATM\
    \ network concepts described in [GA96], and access to it.  This\n   document is\
    \ organized as follows.  Section 2 presents interactions\n   with the local UNI\
    \ 3.0/3.1 signaling entity that are used later in\n   the document and have been\
    \ originally described in [GA96].  Section 3\n   presents an MCS architecture,\
    \ along with a description of its\n   interactions with the MARS. Section 4 describes\
    \ the working of an\n   MCS. The possibility of using multiple MCSs for the same\
    \ layer 3\n   group, and the mechanism needed to support such usage, is described\n\
    \   in section 5.  A comparison of the VC Mesh approach and the MCS\n   approach\
    \ is presented in Appendix A.\n"
- title: 2 Interaction with the local UNI 3.0/3.1 signaling entity
  contents:
  - "2 Interaction with the local UNI 3.0/3.1 signaling entity\n   The following generic\
    \ signaling functions are presumed to be\n   available to local AAL Users:\n \
    \  LCALL-RQ - Establish a unicast VC to a specific endpoint.\n   LMULTI-RQ - Establish\
    \ multicast VC to a specific endpoint.\n   LMULTI-ADD - Add new leaf node to previously\
    \ established VC.\n   LMULTI-DROP - Remove specific leaf node from established\
    \ VC.\n   LRELEASE - Release unicast VC, or all Leaves of a multicast VC.\n  \
    \ The following indications are assumed to be available to AAL Users,\n   generated\
    \ by by the local UNI 3.0/3.1 signaling entity:\n   LACK - Succesful completion\
    \ of a local request.\n   LREMOTE-CALL - A new VC has been established to the\
    \ AAL User.\n   ERRL-RQFAILED - A remote ATM endpoint rejected an LCALLRQ,\n \
    \                        LMULTIRQ, or L-MULTIADD.\n   ERRL-DROP - A remote ATM\
    \ endpoint dropped off an existing VC.\n   ERRL-RELEASE - An existing VC was terminated.\n"
- title: 3 MCS Architecture
  contents:
  - "3 MCS Architecture\n   The MCS acts as a proxy server which multicasts data received\
    \ from a\n   source to the group members in the cluster.  All multicast sources\n\
    \   transmitting to an MCS-based group send the data to the specified\n   MCS.\
    \ The MCS then forwards the data over a point to multipoint VC\n   that it maintains\
    \ to group members in the cluster.  Each multicast\n   source thus maintains a\
    \ single point-to-multipoint VC to the\n   designated MCS for the group.  The\
    \ designated MCS terminates one\n   point-to-multipoint VC from each cluster member\
    \ that is multicasting\n   to the layer 3 group.  Each group member is the leaf\
    \ of the point-\n   to-multipoint VC originating from the MCS.\n   A brief introduction\
    \ to possible MCS architectures has been presented\n   in [GA96].  The main contribution\
    \ of that document concerning the MCS\n   approach is the specification of the\
    \ MARS interaction with the MCS.\n   The next section lists control messages exchanged\
    \ by the MARS and\n   MCS.\n"
- title: 3.1 Control Messages exchanged by the MCS and the MARS
  contents:
  - "3.1 Control Messages exchanged by the MCS and the MARS\n   The following control\
    \ messages are exchanged by the MARS and the MCS.\n   operation code         \
    \       Control Message\n         1                       MARS_REQUEST\n     \
    \    2                       MARS_MULTI\n         3                       MARS_MSERV\n\
    \         6                       MARS_NAK\n         7                       MARS_UNSERV\n\
    \         8                       MARS_SJOIN\n         9                     \
    \  MARS_SLEAVE\n        12                       MARS_REDIRECT_MAP\n   MARSMSERV\
    \ and MARS-UNSERV are identical in format to the MARSJOIN\n   message.  MARSSJOIN\
    \ and MARS-SLEAVE are also identical in format to\n   MARSJOIN. As such, their\
    \ formats and those of MARSREQUEST, MARS-\n   MULTI, MARSNAK and MARSREDIRECT-MAP\
    \ are described in [GA96].  Their\n   usage is described in section 4.  All control\
    \ messages are LLC/SNAP\n   encapsulated as described in section 4.2 of [GA96].\
    \  (The \"mar$\"\n   notation used in this document is borrowed from [GA96], and\
    \ indicates\n   a specific field in the control message.)  Data messages are\n\
    \   reflected without any modification by the MCS.\n"
- title: 3.2 Association with a layer 3 group
  contents:
  - "3.2 Association with a layer 3 group\n   The simplest MCS architecture involves\
    \ taking incoming AALSDUs from\n   the multicast sources and sending them out\
    \ over the point-to-\n   multipoint VC to the group members.  The MCS can service\
    \ just one\n   layer 3 group using this design, as it has no way of distinguishing\n\
    \   between traffic destined for different groups.  So each layer 3 MCS-\n   supported\
    \ group will have its own designated MCS.\n   However it is desirable in the interests\
    \ of saving resources to\n   utilize the same MCS to support multiple groups.\
    \  This can be done by\n   adding minimal layer 3 specific processing into the\
    \ MCS. The MCS can\n   now look inside the received AALSDUs and determine which\
    \ layer 3\n   group they are destined for.  A single instance of such an MCS could\n\
    \   register its ATM address with the MARS for multiple layer 3 groups,\n   and\
    \ manage multiple point-to-multipoint VCs, one for each group.\n   This capability\
    \ is included in the MCS architecture, as is the\n   capability of having multiple\
    \ MCSs per group (section 5).\n"
- title: 4 Working of MCS
  contents:
  - "4 Working of MCS\n   An MCS MUST NOT share its ATM address with any other cluster\
    \ member\n   (MARS or otherwise).  However, it may share the same physical ATM\n\
    \   interface (even with other MCSs or the MARS), provided that each\n   logical\
    \ entity has a different ATM address.  This section describes\n   the working\
    \ of MCS and its interactions with the MARS and other\n   cluster members.\n"
- title: 4.1 Usage of MARSMSERV and MARS-UNSERV
  contents:
  - '4.1 Usage of MARSMSERV and MARS-UNSERV

    '
- title: 4.1.1 Registration (and deregistration) with the MARS
  contents:
  - "4.1.1 Registration (and deregistration) with the MARS\n   The ATM address of\
    \ the MARS MUST be known to the MCS by out-of-band\n   means at startup.  One\
    \ possible approach for doing this is for the\n   network administrator to specify\
    \ the MARS address at command line\n   while invoking the MCS. On startup, the\
    \ MCS MUST open a point-to-\n   point control VC (MARSVC) with the MARS. All traffic\
    \ from the MCS to\n   the MARS MUST be carried over the MARSVC. The MCS MUST register\
    \ with\n   the MARS using the MARS-MSERV message on startup.  To register, a\n\
    \   MARSMSERV MUST be sent by the MCS to the MARS over the MARSVC. On\n   receiving\
    \ this MARS-MSERV, the MARS adds the MCS to the\n   ServerControlVC. The ServerControlVC\
    \ is maintained by the MARS with\n   all MCSs as leaves, and is used to disseminate\
    \ general control\n   messages to all the MCSs.  The MCS MUST terminate this VC,\
    \ and MUST\n   expect a copy of the MCS registration MARSMSERV on the MARS-VC\
    \ from\n   the MARS.\n   An MCS can deregister by sending a MARSUNSERV to the\
    \ MARS. A copy of\n   this MARSUNSERV MUST be expected back from the MARS. The\
    \ MCS will\n   then be dropped from the ServerControlVC.\n   No protocol specific\
    \ group addresses are included in MCS registration\n   MARSMSERV and MARS-UNSERV.\
    \ The mar$flags.register bit MUST be set,\n   the mar$cmi field MUST be set to\
    \ zero, the mar$flags.sequence field\n   MUST be set to zero, the source ATM address\
    \ MUST be included and a\n   null source protocol address MAY be specified in\
    \ these MARSMSERV and\n   MARS-UNSERV. All other fields are set as described in\
    \ section 5.2.1\n   of [GA96] (the MCS can be considered to be a cluster member\
    \ while\n   reading that section).  It MUST keep retransmitting (section 4.1.3)\n\
    \   the MARSMSERV/MARS-UNSERV over the MARSVC until it receives a copy\n   back.\n\
    \   In case of failure to open the MARSVC, or error on it, the\n   reconnection\
    \ procedure outlined in section 4.5.2 is to be followed.\n"
- title: 4.1.2 Registration (and deregistration) of layer 3 groups
  contents:
  - "4.1.2 Registration (and deregistration) of layer 3 groups\n   The MCS can register\
    \ with the MARS to support particular group(s).\n   To register groups X through\
    \ Y, a MARSMSERV with a <min, max> pair of\n   <X, Y> MUST be sent to the MARS.\
    \ The MCS MUST expect a copy of the\n   MARSMSERV back from the MARS. The retransmission\
    \ strategy outlined in\n   section 4.1.3 is to be followed if no copy is received.\n\
    \   The MCS MUST similarly use MARSUNSERV if it wants to withdraw support\n  \
    \ for a specific layer 3 group.  A copy of the group MARSUNSERV MUST be\n   received,\
    \ failing which the retransmission strategy in section 4.1.3\n   is to be followed.\n\
    \   The mar$flags.register bit MUST be reset and the mar$flags.sequence\n   field\
    \ MUST be set to zero in the group MARSMSERV and MARS-UNSERV. All\n   other fields\
    \ are set as described in section 5.2.1 of [GA96] (the MCS\n   can be considered\
    \ to be a cluster member when reading that section).\n"
- title: 4.1.3 Retransmission of MARSMSERV and MARS-UNSERV
  contents:
  - "4.1.3 Retransmission of MARSMSERV and MARS-UNSERV\n   Transient problems may\
    \ cause loss of control messages.  The MCS needs\n   to retransmit MARSMSERV/MARS-UNSERV\
    \ at regular intervals when it does\n   not receive a copy back from the MARS.\
    \ This interval should be no\n   shorter than 5 seconds, and a default value of\
    \ 10 seconds is\n   recommended.  A maximum of 5 retransmissions are permitted\
    \ before a\n   failure is logged.  This MUST be considered a MARS failure, which\n\
    \   SHOULD result in the MARS reconnection mechanism described in section\n  \
    \ 4.5.2.\n   A \"copy\" is defined as a received message with the following fields\n\
    \   matching the previously transmitted MARSMSERV/MARS-UNSERV:\n   -  mar$op\n\
    \   -  mar$flags.register\n   -  mar$pnum\n   -  Source ATM address\n   -  first\
    \ <min, max> pair\n   In addition, a valid copy MUST have the following field\
    \ values:\n   -  mar$flags.punched = 0\n   -  mar$flags.copy = 1\n   If either\
    \ of the above is not true, the message MUST be dropped\n   without resetting\
    \ of the MARSMSERV/MARS-UNSERV timer.  There MUST be\n   only one MARSMSERV or\
    \ MARS-UNSERV outstanding at a time.\n"
- title: 4.1.4 Processing of MARSMSERV and MARS-UNSERV
  contents:
  - "4.1.4 Processing of MARSMSERV and MARS-UNSERV\n   The MARS transmits copies of\
    \ group MARSMSERV and MARS-UNSERV on the\n   ServerControlVC. So they are also\
    \ received by MCSs other than the\n   originating one.  This section discusses\
    \ the processing of these\n   messages by the other MCSs.\n   If a MARSMSERV is\
    \ seen that refers to a layer 3 group not supported\n   by the MCS, it MUST be\
    \ used to track the Server Sequence Number\n   (section 4.5.1) and then silently\
    \ dropped.\n   If a MARSMSERV is seen that refers to a layer 3 group supported\
    \ by\n   the MCS, the MCS learns of the existence of another MCS supporting\n\
    \   the same group.  This possibility is incorporated (of multiple MCSs\n   per\
    \ group) in this version of the MCS approach and is discussed in\n   section 5.\n"
- title: 4.2 Usage of MARSREQUEST and MARS-MULTI
  contents:
  - "4.2 Usage of MARSREQUEST and MARS-MULTI\n   As described in section 5.1, the\
    \ MCS learns at startup whether it is\n   an active or inactive MCS. After successful\
    \ registration with the\n   MARS, an MCS which has been designated as inactive\
    \ for a particular\n   group MUST NOT register to support that group with the\
    \ MARS. It\n   instead proceeds as in section 5.4.  The active MCS for a group\
    \ also\n   has to do some special processing, which we describe in that section.\n\
    \   The rest of section 4 describes the working of a single active MCS,\n   with\
    \ section 5 describing the active MCSs actions for supporting\n   multiple MCSs.\n\
    \   After the active MCS registers to support a layer 3 group, it uses\n   MARSREQUEST\
    \ and MARS-MULTI to obtain information about group\n   membership from the MARS.\
    \ These messages are also used during the\n   revalidation phase (section 4.5)\
    \ and when no outgoing VC exists for a\n   received layer 3 packet (section 4.3).\n\
    \   On registering to support a particular layer 3 group, the MCS MUST\n   send\
    \ a MARSREQUEST to the MARS. The mechanism to retrieve group\n   membership and\
    \ the format of MARSREQUEST and MARS-MULTI is described\n   in section 5.1.1 and\
    \ 5.1.2 of [GA96] respectively.  The MCS MUST use\n   this mechanism for sending\
    \ (and retransmitting) the MARSREQUEST and\n   processing the returned MARSMULTI(/s).\
    \  The MARS-MULTI MUST be\n   received correctly, and the MCS MUST use it to initialize\
    \ its\n   knowledge of group membership.\n   On successful reception of a MARSMULTI,\
    \ the MCS MUST attempt to open\n   the outgoing point-to-multipoint VC using the\
    \ mechanism described in\n   section 5.1.3 of [GA96], if any group members exist.\
    \  The MCS however\n   MUST start transmitting data on this VC after it has opened\
    \ it\n   successfully with at least one of the group members as a leaf, and\n\
    \   after it has attempted to add all the group members at least once.\n"
- title: 4.3 Usage of outgoing point-to-multipoint VC
  contents:
  - "4.3 Usage of outgoing point-to-multipoint VC\n   Cluster members which are sources\
    \ for MCS-supported layer 3 groups\n   send (encapsulated) layer 3 packets to\
    \ the designated MCSs.  An MCS,\n   on receiving them from cluster members, has\
    \ to send them out over the\n   specific point-to-multipoint VC for that layer\
    \ 3 group.  This VC is\n   setup as described in the previous section.  However,\
    \ it is possible\n   that no group members currently exist, thus causing no VC\
    \ to be\n   setup.  So an MCS may have no outgoing VC to forward received layer\
    \ 3\n   packets on, in which case it MUST initiate the MARSREQUEST and MARS-\n\
    \   MULTI sequence described in the previous section.  This new MARSMULTI\n  \
    \ could contain new members, whose MARSSJOINs may have been not\n   received by\
    \ the MCS (and the loss not detected due to absence of\n   traffic on the ServerControlVC).\n\
    \   If an MCS learns that there are no group members (MARSNAK received\n   from\
    \ MARS), it MUST delay sending out a new MARSREQUEST for that\n   group for a\
    \ period no less than 5 seconds and no more than 10\n   seconds.\n   Layer 3 packets\
    \ received from cluster members, while no outgoing\n   point-to-multipoint VC\
    \ exists for that group, MUST be silently\n   dropped after following the guidelines\
    \ in the previous paragraphs.\n   This might result in some layer 3 packets being\
    \ lost until the VC is\n   setup.\n   Each outgoing point-to-multipoint VC has\
    \ a revalidate flag associated\n   with it.  This flag MUST be checked whenever\
    \ a layer 3 packet is sent\n   out on that VC. No action is taken if it is not\
    \ set.  If it is set,\n   the packet is sent out, the revalidation procedure (section\
    \ 4.5.3)\n   MUST be initiated for this group, and the flag MUST be reset.\n \
    \  In case of error on a point-to-multipoint VC, the MCS MUST initiate\n   revalidation\
    \ procedures for that VC as described in section 4.5.3.\n   Once a point-to-multipoint\
    \ VC has been setup for a particular layer 3\n   group, the MCS MUST hold the\
    \ VC open and mark it as the outgoing path\n   for any subsequent layer 3 packets\
    \ being sent for that group address.\n   A point-to-multipoint VC MUST NOT have\
    \ an activity timer associated\n   with it.  It is to remain up at all times,\
    \ unless the MCS explicitly\n   stops supporting that layer 3 group, or no more\
    \ leaves exist on the\n   VC which causes it to be shut down.  The VC is kept\
    \ up inspite of\n   non-existent traffic to reduce the delay suffered by MCS supported\n\
    \   groups.  If the VC were to be shut down on absence of traffic, the VC\n  \
    \ reestablishment procedure (needed when new traffic for the layer 3\n   group\
    \ appears) would further increase the initial delay, which can be\n   potentially\
    \ higher than the VC mesh approach anyway as two VCs need\n   to be setup in the\
    \ MCS case (one from source to MCS, second from MCS\n   to group) as opposed to\
    \ only one (from source to group) in the VC\n   Mesh approach.  This approach\
    \ of keeping the VC from the MCS open\n   even in the absense of traffic is experimental.\
    \  A decision either\n   way can only be made after gaining experience (either\
    \ through\n   implementation or simulation) about the implications of keeping\
    \ the\n   VC open.\n   If the MCS supports multiple layer 3 groups, it MUST follow\
    \ the\n   procedure outlined in the four previous subsections for each group\n\
    \   that it is an active MCS. Each incoming data AALSDU MUST be examined\n   for\
    \ determining its recipient group, before being forwarded onto the\n   appropriate\
    \ outgoing point-to-multipoint VC.\n"
- title: 4.3.1 Group member dropping off a point-to-multipoint VC
  contents:
  - "4.3.1 Group member dropping off a point-to-multipoint VC\n   AN ERRL-DROP may\
    \ be received during the lifetime of a point-to-\n   multipoint VC indicating\
    \ that a leaf node has terminated its\n   participation at the ATM level.  The\
    \ ATM endpoint associated with the\n   ERRL-DROP MUST be removed from the locally\
    \ held set associated with\n   the VC. The revalidate flag on the VC MUST be set\
    \ after a random\n   interval of 1 through 10 seconds.\n   If an ERRL-RELEASE\
    \ is received for a VC, then the entire set is\n   cleared and the VC considered\
    \ to be completely shutdown.  A new VC\n   for this layer 3 group will be established\
    \ only on reception of new\n   traffic for the group (as described in section\
    \ 4.3).\n"
- title: 4.4 Processing of MARSSJOIN and MARS-SLEAVE
  contents:
  - "4.4 Processing of MARSSJOIN and MARS-SLEAVE\n   The MARS transmits equivalent\
    \ MARSSJOIN/MARS-SLEAVE on the\n   ServerControlVC when it receives MARSJOIN/MARS-LEAVE\
    \ from cluster\n   members.  The MCSs keep track of group membership updates through\n\
    \   these messages.  The format of these messages are identical to\n   MARSJOIN\
    \ and MARS-LEAVE, which are described in section 5.2.1 of\n   [GA96].  It is sufficient\
    \ to note here that these messages carry the\n   ATM address of the node joining/leaving\
    \ the group(/s), the group(/s)\n   being joined or left, and a Server Sequence\
    \ Number from MARS.\n   When a MARSSJOIN is seen which refers to (or encompasses)\
    \ a layer 3\n   group (or groups) supported by the MCS, the following action MUST\
    \ be\n   taken.  The new member's ATM address is extracted from the MARSSJOIN.\n\
    \   An L-MULTIADD is issued for the new member for each of those referred\n  \
    \ groups which have an outgoing point-to-multipoint VC. An LMULTI-RQ is\n   issued\
    \ for the new member for each of those refered groups which have\n   no outgoing\
    \ VCs.\n   When a MARSSLEAVE is seen that refers to (or encompasses) a layer 3\n\
    \   group (or groups) supported by the MCS, the following action MUST be\n   taken.\
    \  The leaving member's ATM address is extracted.  An LMULTI-\n   DROP is issued\
    \ for the member for each of the refered groups which\n   have an outgoing point-to-multipoint\
    \ VC.\n   There is a possibility of the above requests (LMULTI-RQ or LMULTIADD\n\
    \   or LMULTI-DROP) failing.  The UNI 3.0/3.1 failure cause must be\n   returned\
    \ in the ERRL-RQFAILED signal from the local signaling entity\n   to the AAL User.\
    \  If the failure cause is not 49 (Quality of Service\n   unavailable), 51 (user\
    \ cell rate not available - UNI 3.0), 37 (user\n   cell rate not available - UNI\
    \ 3.1), or 41 (Temporary failure), the\n   endpoint's ATM address is dropped from\
    \ the locally held view of the\n   group by the MCS. Otherwise, the request MUST\
    \ be re-attempted with\n   increasing delay (initial value between 5 to 10 seconds,\
    \ with delay\n   value doubling after each attempt) until it either succeeds or\
    \ the\n   multipoint VC is released or a MARSSLEAVE is received for that group\n\
    \   member.  If the VC is open, traffic on the VC MUST continue during\n   these\
    \ attempts.\n   MARSSJOIN and MARS-SLEAVE are processed differently if multiple\
    \ MCSs\n   share the members of the same layer 3 group (section 5.4).  MARSSJOIN\n\
    \   and MARSSLEAVE that do not refer to (or encompass) supported groups\n   MUST\
    \ be used to track the Server Sequence Number (section 4.5.1), but\n   are otherwise\
    \ ignored.\n"
- title: 4.5 Revalidation Procedures
  contents:
  - "4.5 Revalidation Procedures\n   The MCS has to initiate revalidation procedures\
    \ in case of certain\n   failures or errors.\n"
- title: 4.5.1 Server Sequence Number
  contents:
  - "4.5.1 Server Sequence Number\n   The MCS needs to track the Server Sequence Number\
    \ (SSN) in the\n   messages received on the ServerControlVC from the MARS. It\
    \ is carried\n   in the mar$msn of all messages (except MARSNAK) sent by the MARS\
    \ to\n   MCSs.  A jump in SSN implies that the MCS missed the previous\n   message(/s)\
    \ sent by the MARS. The MCS then sets the revalidate flag\n   on all outgoing\
    \ point-to-multipoint VCs after a random delay of\n   between 1 and 10 seconds,\
    \ to avoid all MCSs inundating the MARS\n   simultaneously in case of a more general\
    \ failure.\n   The only exception to the rule is if a sequence number is detected\n\
    \   during the establishment of a new group's VC (i.e.  a MARSMULTI was\n   correctly\
    \ received, but its mar$msn indicated that some previous MARS\n   traffic had\
    \ been missed on ClusterControlVC). In this case every open\n   VC, EXCEPT the\
    \ one just being established, MUST have its revalidate\n   flag set at some random\
    \ interval between 1 and 10 seconds from the\n   time the jump in SSN was detected.\
    \  (The VC being established is\n   considered already validated in this case).\n\
    \   Each MCS keeps its own 32 bit MCS Sequence Number (MSN) to track the\n   SSN.\
    \  Whenever a message is received that carries a mar$msn field,\n   the following\
    \ processing is performed:\n        Seq.diff = mar$msn - MSN\n        mar$msn\
    \ -> MSN\n        (.... process MARS message ....)\n        if ((Seq.diff != 1)\
    \ && (Seq.diff != 0))\n              then (.... revalidate group membership information\
    \ ....)\n   The mar$msn value in an individual MARSMULTI is not used to update\n\
    \   the MSN until all parts of the MARSMULTI (if > 1) have arrived.  (If\n   the\
    \ mar$msn changes during reception of a MARSMULTI series, the\n   MARS-MULTI is\
    \ discarded as described in section 5.1.1 of [GA96]).\n   The MCS sets its MSN\
    \ to zero on startup.  It gets the current value\n   of SSN when it receives the\
    \ copy of the registration MARSMSERV back\n   from the MARS.\n"
- title: 4.5.2 Reconnecting to the MARS
  contents:
  - "4.5.2 Reconnecting to the MARS\n   The MCSs are assumed to have been configured\
    \ with the ATM address of\n   at least one MARS at startup.  MCSs MAY choose to\
    \ maintain a table of\n   ATM addresses, each address representing alternative\
    \ MARS which will\n   be contacted in case of failure of the previous one.  This\
    \ table is\n   assumed to be ordered in descending order of preference.\n   An\
    \ MCS will decide that it has problems communicating with a MARS if:\n      *\
    \ It fails to establish a point-to-point VC with the MARS.\n      * MARSREQUEST\
    \ generates no response (no MARSMULTI or MARS-NAK\n      returned).\n      * ServerControlVC\
    \ fails.\n      * MARSMSERV or MARSUNSERV do not result in their respective copies\n\
    \      being\n        received.\n   (reconnection as in section 5.4 in [GA96],\
    \ with MCS-specific actions\n   used where needed).\n"
- title: 4.5.3 Revalidating a point-to-multipoint VC
  contents:
  - "4.5.3 Revalidating a point-to-multipoint VC\n   The revalidation flag associated\
    \ with a point-to-multipoint VC is\n   checked when a layer 3 packet is to be\
    \ sent out on the VC.\n   Revalidation procedures MUST be initiated for a point-to-multipoint\n\
    \   VC that has its revalidate flag set when a layer 3 packet is being\n   sent\
    \ out on it.  Thus more active groups get revalidated faster than\n   less active\
    \ ones.  The revalidation process MUST NOT result in\n   disruption of normal\
    \ traffic on the VC being revalidated.\n   The revalidation procedure is as follows.\
    \  The MCS reissues a\n   MARSREQUEST for the VC being revalidated.  The returned\
    \ set of\n   members is compared with the locally held set; LMULTI-ADDs MUST be\n\
    \   issued for new members, and LMULTI-DROPs MUST be issued for non-\n   existent\
    \ ones.  The revalidate flag MUST be reset for the VC.\n"
- title: 5 Multiple MCSs for a layer 3 group
  contents:
  - "5 Multiple MCSs for a layer 3 group\n   Having a single MCS for a layer 3 group\
    \ can cause it to become a\n   single point of failure and a bottleneck for groups\
    \ with large\n   numbers of active senders.  It is thus desirable to introduce\
    \ a level\n   of fault tolerance by having multiple MCS per group.  Support for\n\
    \   load sharing is not introduced in this document as to reduce the\n   complexity\
    \ of the protocol.\n"
- title: 5.1 Outline
  contents:
  - "5.1 Outline\n   The protocol described in this document offers fault tolerance\
    \ by\n   using multiple MCSs for the same group.  This is achieved by having a\n\
    \   standby MCS take over from a failed MCS which had been supporting the\n  \
    \ group.  The MCS currently supporting a group is refered to as the\n   active\
    \ MCS, while the one or more standby MCSs are refered to as\n   inactive MCSs.\
    \  There is only one active MCS existing at any given\n   instant for an MCS-supported\
    \ group.  The protocol makes use of the\n   HELLO messages as described in [LA96].\n\
    \   To reduce the complexity of the protocol, the following operational\n   guidelines\
    \ need to be followed.  These guidelines need to be enforced\n   by out-of-band\
    \ means which are not specified in this document and can\n   be implementation\
    \ dependent.\n      * The set of (one or more) MCSs (\"mcslist\") that support\
    \ a\n        particular IP Multicast group is predetermined and fixed.  This\n\
    \        set MUST be known to each MCS in the set at startup, and the\n      \
    \  ordering of MCSs in the set is the same for all MCSs in the set.\n        An\
    \ implementation of this would be to maintain the set of ATM\n        addresses\
    \ of the MCSs in a file, an identical copy of which is\n        kept at each MCS\
    \ in the set.\n      * All MCSs in \"mcslist\" have to be started up together,\
    \ with the\n        first MCS in \"mcslist\" being the last to be started.\n \
    \     * A failed MCS cannot be started up again.\n"
- title: 5.2 Discussion of Multiple MCSs in operation
  contents:
  - "5.2 Discussion of Multiple MCSs in operation\n   An MCS on startup determines\
    \ its position in the \"mcslist\".  If the\n   MCS is not the first in \"mcslist\"\
    , it does not register for\n   supporting the group with the MARS. If the MCS\
    \ is first in the set,\n   it does register to support the group.\n   The first\
    \ MCS thus becomes the active MCS and supports the group as\n   described in section\
    \ 4.  The active MCS also opens a point-to-\n   multipoint VC (HelloVC) to the\
    \ remaining MCSs in the set (the\n   inactive MCSs).  It starts sending HELLO\
    \ messages on this VC at a\n   fixed interval (HelloInterval seconds).  The inactive\
    \ MCSs maintain a\n   timer to keep track of the last received HELLO message.\
    \  If an\n   inactive MCS does not receive a message within HelloInterval*\n \
    \  DeadFactor seconds (values of HelloInterval and DeadFactor are the\n   same\
    \ at all the MCSs), or if the HelloVC is closed, it assumes\n   failure of the\
    \ active MCS and attempts to elect a new one.  The\n   election process is described\
    \ in section 5.5.\n   If an MCS is elected as the new active one, it registers\
    \ to support\n   the group with the MARS. It also initiates the transmission of\
    \ HELLO\n   messages to the remaining inactive MCSs.\n"
- title: 5.3 Inter-MCS control messages
  contents:
  - "5.3 Inter-MCS control messages\n   The protocol uses HELLO messages in the heartbeat\
    \ mechanism, and also\n   during the election process.  The format of the HELLO\
    \ message is\n   based on that described in [LA96].  The Hello message type code\
    \ is 5.\n    0                   1                   2                   3\n \
    \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Sender Len    |    Recvr Len  | State | Type  |    unused     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         HelloInterval         |          DeadFactor           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        IP Multicast address                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    Sender ATM address (variable length)       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                  Receiver ATM address (variable length)       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Sender Len\n     This field holds the length in octets of the Sender ATM address.\n\
    \   Recvr Len\n     This field holds the length in octets of the Receiver ATM\n\
    \     address.\n   State\n     Currently two states: No-Op (0x00) and Elected\
    \ (0x01).\n     It is used by a candidate MCS to indicate if it was successfully\n\
    \     elected.\n   Type\n     This is the code for the message type.\n   HelloInterval\n\
    \     The hello interval advertises the time between sending of\n     consecutive\
    \ Hello Messages by an active MCS.  If the time between\n     Hello messages exceeds\
    \ the HelloInterval then the Hello is to be\n     considered late by the inactive\
    \ MCS.\n   DeadFactor\n     This is a multiplier to the HelloInterval. If an inactive\
    \ MCS\n     does not receive a Hello message within the interval\n     HelloInterval*DeadFactor\
    \ from an active MCS that advertised\n     the HelloInterval then the inactive\
    \ MCS MUST consider the active\n     one to have failed.\n   IP Multicast address\n\
    \     This field is used to indicate the group to associate the HELLO\n     message\
    \ with. It is useful if MCSs can support more than one\n     group.\n   Sender\
    \ ATM address\n     This is the protocol address of the server which is sending\
    \ the\n     Hello.\n   Receiver ATM address\n     This is the protocol address\
    \ of the server which is to Reply to\n     the Hello.  If the sender does not\
    \ know this address then the\n     sender sets it to zero. (This happens in the\
    \ HELLO messages sent\n     from the active MCS to the inactive ones, as they\
    \ are multicast\n     and not sent to one specific receiver).\n"
- title: 5.4 The Multiple MCS protocol
  contents:
  - "5.4 The Multiple MCS protocol\n   As is indicated in section 5.1, all the MCSs\
    \ supporting the same IP\n   Multicast group MUST be started up together.  The\
    \ set of MCSs\n   (\"mcslist\") MUST be specified to each MCS in the set at startup.\n\
    \   After registering to support the group with the MARS, the first MCS\n   in\
    \ the set MUST open a point-to-multipoint VC (HelloVC) with the\n   remaining\
    \ MCSs in the \"mcslist\" as leaves, and thus assumes the role\n   of active MCS.\
    \ It MUST send HELLO messages HelloInterval seconds\n   apart on this VC. The\
    \ Hello message sent by the active MCS MUST have\n   the Receiver Len set to zero,\
    \ the State field set to \"Elected\", with\n   the other fields appropriately\
    \ set.  The Receiver ATM address field\n   does not exist in this HELLO message.\
    \  The initial value of\n   HelloInterval and DeadFactor MUST be the same at all\
    \ MCSs at startup.\n   The active MCS can choose to change these values by introducing\
    \ the\n   new value in the HELLO messages that are sent out.  The active MCS\n\
    \   MUST support the group as described in section 4.\n   The other MCSs in \"\
    mcslist\" determine the identity of the first MCS\n   from the \"mcslist\".  They\
    \ MUST NOT register to support the group with\n   the MARS, and become inactive\
    \ MCSs.  On startup, an inactive MCS\n   expects HELLO messages from the active\
    \ MCS. The inactive MCS MUST\n   terminate the HelloVC.  A timer MUST be maintained,\
    \ and if the\n   inactive MCS does not receive HELLO message from the active one\n\
    \   within a period HelloInterval*DeadFactor seconds, it assumes that the\n  \
    \ active MCS died, and initiates the election process as described in\n   section\
    \ 5.5.  If a HELLO message is received within this period, the\n   inactive MCS\
    \ does not initiate any further action, other than\n   restarting the timer. \
    \ The inactive MCSs MUST set their values of\n   HelloInterval and DeadFactor\
    \ to those specified by the active MCS in\n   the HELLO messages.\n   In case\
    \ of an MCS supporting multiple groups, it MUST register to\n   support those\
    \ groups for which it is the first MCS, and MUST NOT\n   register for other groups.\
    \  A MARSMSERV with multiple <min, max>\n   pairs may be used for registering\
    \ multiple disjoint sets of groups.\n   Support MUST be provided for the use of\
    \ a single \"mcslist\" for more\n   than one group.  This is intended to address\
    \ the case wherein an MCS\n   is intended to support multiple groups, with other\
    \ MCSs acting as\n   backups.  This subverts the need for using a different \"\
    mcslist\" for\n   each group being supported by the same set of MCSs.\n   On failure\
    \ of the active MCS, a new MCS assumes its role as described\n   in section 5.5.\
    \  In this case, the remaining inactive MCSs will\n   expect HELLO messages from\
    \ this new active MCS as described in the\n   previous paragraph.\n"
- title: 5.5 Failure handling
  contents:
  - '5.5 Failure handling

    '
- title: 5.5.1 Failure of active MCS
  contents:
  - "5.5.1 Failure of active MCS\n   The failure of the active MCS is detected by\
    \ the inactive MCSs if no\n   HELLO message is received within an interval of\n\
    \   HelloInterval*DeadFactor seconds, or if the HelloVC is closed.  In\n   this\
    \ case the next MCS in \"mcslist\" becomes the candidate MCS. It\n   MUST open\
    \ a point-to-multipoint VC to the remaining inactive MCSs\n   (HelloVC) and send\
    \ a HELLO message on it with the State field set to\n   No-Op.  The rest of the\
    \ message is formatted as described earlier.\n   On receiving a HELLO message\
    \ from a candidate MCS, an inactive MCS\n   MUST open a point-to-point VC to that\
    \ candidate.  It MUST send a\n   HELLO message back to it, with the Sender and\
    \ Receiver fields\n   appropriately set (not zero), and the State field being\
    \ No-Op.  If a\n   HELLO message is received by an inactive MCS from a non-candidate\n\
    \   MCS, it is ignored.  If no HELLO message is received from the\n   candidate\
    \ with the State field set to \"Elected\" in HelloInterval\n   seconds, the inactive\
    \ MCS MUST retransmit the HELLO. If no HELLO\n   message with State field set\
    \ to \"Elected\" is received by the inactive\n   MCSs within an interval of HelloInterval*DeadFactor\
    \ seconds, the next\n   MCS in \"mcslist\" is considered as the candidate MCS.\
    \ Note that the\n   values used for HelloInterval and DeadFactor in the election\
    \ phase\n   are the default ones.\n   The candidate MCS MUST wait for a period\
    \ of HelloInterval*DeadFactor\n   seconds for receiving HELLO messages from inactive\
    \ MCSs.  It MUST\n   transmit HELLO messages with State field set to No-Op at\n\
    \   HelloInterval seconds interval during this period.  If it receives\n   messages\
    \ from atleast half of the remaining inactive MCSs during this\n   period, it\
    \ considers itself elected and assumes the active MCS role.\n   It then registers\
    \ to support the group with the MARS, and starts\n   sending HELLO messages at\
    \ HelloInterval second intervals with State\n   field set to \"Elected\" on the\
    \ already existing HelloVC. The active\n   MCS can then alter the HelloInterval\
    \ and DeadFactor values if\n   desired, and communicate the same to the inactive\
    \ MCSs in the HELLO\n   message.\n"
- title: 5.5.2 Failure of inactive MCS
  contents:
  - "5.5.2 Failure of inactive MCS\n   If an inactive MCS drops off the HelloVC, the\
    \ active MCS MUST attempt\n   to add that MCS back to the VC for three attempts,\
    \ spaced\n   HelloInterval*DeadFactor seconds apart.  If even the third attempt\n\
    \   fails, the inactive MCS is considered dead.\n   An MCS, active or inactive,\
    \ MUST NOT be started up once it has\n   failed.  Failed MCSs can only be started\
    \ up by manual intervention\n   after shutting down all the MCSs, and restarting\
    \ them together.\n"
- title: 5.6 Compatibility with future MARS and MCS versions
  contents:
  - "5.6 Compatibility with future MARS and MCS versions\n   Future versions of MCSs\
    \ can be expected to use an enhanced MARS for\n   load sharing and fault tolerance\
    \ ([TA96]).  The MCS architecture\n   described in this document is compatible\
    \ with the enhanced MARS and\n   the future MCS versions.  This is because the\
    \ active MCS is the only\n   one which communicates with the MARS about the group.\
    \  Hence the\n   active MCS will only be informed by the enhanced MARS about the\n\
    \   subset of the group that it is to support.  Thus MCSs conforming to\n   this\
    \ document are compatible with [GA96] based MARS, as well as\n   enhanced MARS.\n"
- title: 6 Summary
  contents:
  - "6 Summary\n   This document describes the architecture of an MCS. It also provides\n\
    \   a mechanism for using multiple MCSs per group for providing fault\n   tolerance.\
    \  This approach can be used with [GA96] based MARS server\n   and clients, without\
    \ needing any change in their functionality.  It\n   uses the HELLO packet format\
    \ as described in [LA96] for the heartbeat\n   messages.\n"
- title: 7 Acknowledgements
  contents:
  - "7 Acknowledgements\n   We would like to acknowledge Grenville Armitage (Bellcore)\
    \ for\n   reviewing the document and suggesting improvements towards\n   simplifying\
    \ the multiple MCS functionalities.  Discussion with Joel\n   Halpern (Newbridge)\
    \ helped clarify the multiple MCS problem.  Anthony\n   Gallo (IBM RTP) pointed\
    \ out security issues that are not adequately\n   addressed in the current document.\
    \  Arvind Murching (Microsoft)\n   flagged a potential show stopper in section\
    \ 4.1.2.\n"
- title: 8 Authors' Address
  contents:
  - "8 Authors' Address\n   Rajesh Talpade\n   College of Computing\n   Georgia Institute\
    \ of Technology\n   Atlanta, GA 30332-0280\n   Phone: (404)-894-6737\n   Email:\
    \ taddy@cc.gatech.edu\n   Mostafa H. Ammar\n   College of Computing\n   Georgia\
    \ Institute of Technology\n   Atlanta, GA 30332-0280\n   Phone: (404)-894-3292\n\
    \   Email:  ammar@cc.gatech.edu\n"
- title: 9 References
  contents:
  - '9 References

    '
- title: '[GA96]   Armitage, G.J., "Support for Multicast over UNI 3.0/3.1 based'
  contents:
  - "[GA96]   Armitage, G.J., \"Support for Multicast over UNI 3.0/3.1 based\n   \
    \      ATM networks\", RFC 2022, November 1996.\n"
- title: '[BK95]   Birman, A., Kandlur, D., Rubas, J., "An extension to the MARS'
  contents:
  - "[BK95]   Birman, A., Kandlur, D., Rubas, J., \"An extension to the MARS\n   \
    \      model\", Work in Progress.\n"
- title: '[LM93]   Laubach, M., "Classical IP and ARP over ATM", RFC1577,'
  contents:
  - "[LM93]   Laubach, M., \"Classical IP and ARP over ATM\", RFC1577,\n         Hewlett-Packard\
    \ Laboratories, December 1993.\n"
- title: '[LA96]   Luciani, J., G. Armitage, and J. Halpern, "Server Cache'
  contents:
  - "[LA96]   Luciani, J., G. Armitage, and J. Halpern, \"Server Cache\n         Synchronization\
    \ Protocol (SCSP) - NBMA\", Work in Progress.\n"
- title: '[TA96]   Talpade, R., and Ammar, M.H., "Multiple MCS support using an'
  contents:
  - "[TA96]   Talpade, R., and Ammar, M.H., \"Multiple MCS support using an\n    \
    \     enhanced version of the MARS server.\", Work in Progress.\n"
