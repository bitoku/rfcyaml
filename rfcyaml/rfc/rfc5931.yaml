- title: __initial_text__
  contents:
  - "        Extensible Authentication Protocol (EAP) Authentication\n           \
    \              Using Only a Password\n"
- title: Abstract
  contents:
  - "Abstract\n   This memo describes an Extensible Authentication Protocol (EAP)\n\
    \   method, EAP-pwd, which uses a shared password for authentication.\n   The\
    \ password may be a low-entropy one and may be drawn from some set\n   of possible\
    \ passwords, like a dictionary, which is available to an\n   attacker.  The underlying\
    \ key exchange is resistant to active attack,\n   passive attack, and dictionary\
    \ attack.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It represents the consensus\
    \ of the IETF community.  It has\n   received public review and has been approved\
    \ for publication by the\n   Internet Engineering Steering Group (IESG).  Not\
    \ all documents\n   approved by the IESG are a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc5931.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2010 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n   This document\
    \ may contain material from IETF Documents or IETF\n   Contributions published\
    \ or made publicly available before November\n   10, 2008.  The person(s) controlling\
    \ the copyright in some of this\n   material may not have granted the IETF Trust\
    \ the right to allow\n   modifications of such material outside the IETF Standards\
    \ Process.\n   Without obtaining an adequate license from the person(s) controlling\n\
    \   the copyright in such materials, this document may not be modified\n   outside\
    \ the IETF Standards Process, and derivative works of it may\n   not be created\
    \ outside the IETF Standards Process, except to format\n   it for publication\
    \ as an RFC or to translate it into languages other\n   than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  4\n     1.1.  Background . . . . . . . . . . . . . . . . . . .\
    \ . . . . .  4\n     1.2.  Keyword Definitions  . . . . . . . . . . . . . . .\
    \ . . . .  4\n     1.3.  Requirements . . . . . . . . . . . . . . . . . . . .\
    \ . . .  4\n       1.3.1.  Resistance to Passive Attack . . . . . . . . . . .\
    \ . .  4\n       1.3.2.  Resistance to Active Attack  . . . . . . . . . . . .\
    \ .  5\n       1.3.3.  Resistance to Dictionary Attack  . . . . . . . . . . .\
    \  5\n       1.3.4.  Forward Secrecy  . . . . . . . . . . . . . . . . . . .  5\n\
    \   2.  Specification of EAP-pwd . . . . . . . . . . . . . . . . . . .  5\n  \
    \   2.1.  Notation . . . . . . . . . . . . . . . . . . . . . . . . .  5\n    \
    \ 2.2.  Discrete Logarithm Cryptography  . . . . . . . . . . . . .  7\n      \
    \ 2.2.1.  Finite Field Cryptography  . . . . . . . . . . . . . .  7\n       2.2.2.\
    \  Elliptic Curve Cryptography  . . . . . . . . . . . . .  8\n     2.3.  Assumptions\
    \  . . . . . . . . . . . . . . . . . . . . . . .  9\n     2.4.  Instantiating\
    \ the Random Function  . . . . . . . . . . . .  9\n     2.5.  Key Derivation Function\
    \  . . . . . . . . . . . . . . . . . 10\n     2.6.  Random Numbers . . . . . .\
    \ . . . . . . . . . . . . . . . . 10\n     2.7.  Representation and Processing\
    \ of Input Strings . . . . . . 11\n       2.7.1.  Identity Strings . . . . . .\
    \ . . . . . . . . . . . . . 11\n       2.7.2.  Passwords  . . . . . . . . . .\
    \ . . . . . . . . . . . . 11\n     2.8.  Protocol . . . . . . . . . . . . . .\
    \ . . . . . . . . . . . 12\n       2.8.1.  Overview . . . . . . . . . . . . .\
    \ . . . . . . . . . . 12\n       2.8.2.  Message Flows  . . . . . . . . . . .\
    \ . . . . . . . . . 12\n       2.8.3.  Fixing the Password Element  . . . . .\
    \ . . . . . . . . 14\n         2.8.3.1.  ECC Operation for PWE  . . . . . . .\
    \ . . . . . . . 15\n         2.8.3.2.  FFC Operation for pwe  . . . . . . . .\
    \ . . . . . . 16\n       2.8.4.  Message Construction . . . . . . . . . . . .\
    \ . . . . . 16\n         2.8.4.1.  ECC Groups . . . . . . . . . . . . . . . .\
    \ . . . . 16\n         2.8.4.2.  FFC Groups . . . . . . . . . . . . . . . . .\
    \ . . . 17\n       2.8.5.  Message Processing . . . . . . . . . . . . . . . .\
    \ . . 18\n         2.8.5.1.  EAP-pwd-ID Exchange  . . . . . . . . . . . . . .\
    \ . 18\n         2.8.5.2.  EAP-pwd-Commit Exchange  . . . . . . . . . . . . .\
    \ 20\n         2.8.5.3.  EAP-pwd-Confirm Exchange . . . . . . . . . . . . . 21\n\
    \     2.9.  Management of EAP-pwd Keys . . . . . . . . . . . . . . . . 22\n  \
    \   2.10. Mandatory-to-Implement Parameters  . . . . . . . . . . . . 23\n   3.\
    \  Packet Formats . . . . . . . . . . . . . . . . . . . . . . . . 23\n     3.1.\
    \  EAP-pwd Header . . . . . . . . . . . . . . . . . . . . . . 23\n     3.2.  EAP-pwd\
    \ Payloads . . . . . . . . . . . . . . . . . . . . . 25\n       3.2.1.  EAP-pwd-ID\
    \ . . . . . . . . . . . . . . . . . . . . . . 25\n       3.2.2.  EAP-pwd-Commit\
    \ . . . . . . . . . . . . . . . . . . . . 26\n       3.2.3.  EAP-pwd-Confirm \
    \ . . . . . . . . . . . . . . . . . . . 27\n     3.3.  Representation of Group\
    \ Elements and Scalars . . . . . . . 27\n       3.3.1.  Elements in FFC Groups\
    \ . . . . . . . . . . . . . . . . 27\n       3.3.2.  Elements in ECC Groups .\
    \ . . . . . . . . . . . . . . . 28\n       3.3.3.  Scalars  . . . . . . . . .\
    \ . . . . . . . . . . . . . . 28\n   4.  Fragmentation  . . . . . . . . . . .\
    \ . . . . . . . . . . . . . 28\n   5.  IANA Considerations  . . . . . . . . .\
    \ . . . . . . . . . . . . 29\n   6.  Security Considerations  . . . . . . . .\
    \ . . . . . . . . . . . 31\n     6.1.  Resistance to Passive Attack . . . . .\
    \ . . . . . . . . . . 31\n     6.2.  Resistance to Active Attack  . . . . . .\
    \ . . . . . . . . . 31\n     6.3.  Resistance to Dictionary Attack  . . . . .\
    \ . . . . . . . . 32\n     6.4.  Forward Secrecy  . . . . . . . . . . . . . .\
    \ . . . . . . . 34\n     6.5.  Group Strength . . . . . . . . . . . . . . . .\
    \ . . . . . . 34\n     6.6.  Random Functions . . . . . . . . . . . . . . . .\
    \ . . . . . 34\n   7.  Security Claims  . . . . . . . . . . . . . . . . . . .\
    \ . . . . 35\n   8.  Acknowledgements . . . . . . . . . . . . . . . . . . . .\
    \ . . . 37\n   9.  References . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . 38\n     9.1.  Normative References . . . . . . . . . . . . . . . . . .\
    \ . 38\n     9.2.  Informative References . . . . . . . . . . . . . . . . . .\
    \ 38\n"
- title: 1.  Introduction
  contents:
  - '1.  Introduction

    '
- title: 1.1.  Background
  contents:
  - "1.1.  Background\n   The predominant access method for the Internet today is\
    \ that of a\n   human using a username and password to authenticate to a computer\n\
    \   enforcing access control.  Proof of knowledge of the password\n   authenticates\
    \ the human and computer.\n   Typically these passwords are not stored on a user's\
    \ computer for\n   security reasons and must be entered each time the human desires\n\
    \   network access.  Therefore, the passwords must be ones that can be\n   repeatedly\
    \ entered by a human with a low probability of error.  They\n   will likely not\
    \ possess high-entropy, and it may be assumed that an\n   adversary with access\
    \ to a dictionary will have the ability to guess\n   a user's password.  It is\
    \ therefore desirable to have a robust\n   authentication method that is secure\
    \ even when used with a weak\n   password in the presence of a strong adversary.\n\
    \   EAP-pwd is an EAP method that addresses the problem of password-based\n  \
    \ authenticated key exchange -- using a possibly weak password for\n   authentication\
    \ to derive an authenticated and cryptographically\n   strong shared secret. \
    \ This problem was first described by Bellovin\n   and Merritt in [BM92] and [BM93].\
    \  There have been a number of\n   subsequent suggestions ([JAB96], [LUC97], [BMP00],\
    \ and others) for\n   password-based authenticated key exchanges.\n"
- title: 1.2.  Keyword Definitions
  contents:
  - "1.2.  Keyword Definitions\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in RFC 2119 [RFC2119].\n"
- title: 1.3.  Requirements
  contents:
  - "1.3.  Requirements\n   Any protocol that claims to solve the problem of password-\n\
    \   authenticated key exchange must be resistant to active, passive, and\n   dictionary\
    \ attack and have the quality of forward secrecy.  These\n   characteristics are\
    \ discussed further in the following sections.\n"
- title: 1.3.1.  Resistance to Passive Attack
  contents:
  - "1.3.1.  Resistance to Passive Attack\n   A passive, or benign, attacker is one\
    \ that merely relays messages\n   back and forth between the peer and server,\
    \ faithfully, and without\n   modification.  The contents of the messages are\
    \ available for\n   inspection, but that is all.  To achieve resistance to passive\n\
    \   attack, such an attacker must not be able to obtain any information\n   about\
    \ the password or anything about the resulting shared secret from\n   watching\
    \ repeated runs of the protocol.  Even if a passive attacker\n   is able to learn\
    \ the password, she will not be able to determine any\n   information about the\
    \ resulting secret shared by the peer and server.\n"
- title: 1.3.2.  Resistance to Active Attack
  contents:
  - "1.3.2.  Resistance to Active Attack\n   An active attacker is able to modify,\
    \ add, delete, and replay\n   messages sent between protocol participants.  For\
    \ this protocol to be\n   resistant to active attack, the attacker must not be\
    \ able to obtain\n   any information about the password or the shared secret by\
    \ using any\n   of its capabilities.  In addition, the attacker must not be able\
    \ to\n   fool a protocol participant into thinking that the protocol completed\n\
    \   successfully.\n   It is always possible for an active attacker to deny delivery\
    \ of a\n   message critical in completing the exchange.  This is no different\n\
    \   than dropping all messages and is not an attack against the protocol.\n"
- title: 1.3.3.  Resistance to Dictionary Attack
  contents:
  - "1.3.3.  Resistance to Dictionary Attack\n   For this protocol to be resistant\
    \ to dictionary attack, any advantage\n   an adversary can gain must be directly\
    \ related to the number of\n   interactions she makes with an honest protocol\
    \ participant and not\n   through computation.  The adversary will not be able\
    \ to obtain any\n   information about the password except whether a single guess\
    \ from a\n   single protocol run is correct or incorrect.\n"
- title: 1.3.4.  Forward Secrecy
  contents:
  - "1.3.4.  Forward Secrecy\n   Compromise of the password must not provide any information\
    \ about the\n   secrets generated by earlier runs of the protocol.\n"
- title: 2.  Specification of EAP-pwd
  contents:
  - '2.  Specification of EAP-pwd

    '
- title: 2.1.  Notation
  contents:
  - "2.1.  Notation\n   The following notation is used in this memo:\n   peer-ID\n\
    \       The peer's identity, the peer NAI [RFC4282].\n   server-ID\n       A string\
    \ that identifies the server to the peer.\n   password\n       The password shared\
    \ between the peer and server.\n   y = H(x)\n       The binary string x is given\
    \ to a function H, which produces a\n       fixed-length output y.\n   a | b\n\
    \       The concatenation of string a with string b.\n   [a]b\n       A string\
    \ consisting of the single bit \"a\" repeated \"b\" times.\n   x mod y\n     \
    \  The remainder of division of x by y.  The result will be between\n       0\
    \ and y.\n   g^x mod p\n       The multiplication of the value \"g\" with itself\
    \ \"x\" times, modulo\n       the value \"p\".\n   inv(Q)\n       The inverse\
    \ of an element, Q, from a finite field.\n   len(x)\n       The length in bits\
    \ of the string x.\n   chop(x, y)\n       The reduction of string x, being at\
    \ least y bits in length, to y\n       bits.\n   PRF(x,y)\n       A pseudo-random\
    \ function that takes a key, x, and variable-length\n       data, y, and produces\
    \ a fixed-length output that cannot be\n       distinguished (with a significant\
    \ advantage) from a random\n       source.\n   LSB(x)\n       Returns the least-significant\
    \ bit of the bitstring \"x\".\n   Ciphersuite\n       An encoding of a group to\
    \ use with EAP-pwd, the definition of\n       function H, and a PRF, in that order.\n\
    \   MK\n       The Master Key is generated by EAP-pwd.  This is a high-entropy\n\
    \       secret whose length depends on the random function used.\n   MSK\n   \
    \    The Master Session Key exported by EAP-pwd.  This is a high-\n       entropy\
    \ secret 512 bits in length.\n   EMSK\n       The Extended Master Session Key\
    \ exported by EAP-pwd.  This is a\n       high-entropy secret 512 bits in length.\n"
- title: 2.2.  Discrete Logarithm Cryptography
  contents:
  - "2.2.  Discrete Logarithm Cryptography\n   This protocol uses discrete logarithm\
    \ cryptography to achieve\n   authentication and key agreement (see [SP800-56A]).\
    \  Each party to\n   the exchange derives ephemeral keys with respect to a particular\
    \ set\n   of domain parameters (referred to here as a \"group\").  A group can\
    \ be\n   based on Finite Field Cryptography (FFC) or Elliptic Curve\n   Cryptography\
    \ (ECC).\n"
- title: 2.2.1.  Finite Field Cryptography
  contents:
  - "2.2.1.  Finite Field Cryptography\n   Domain parameters for the FFC groups used\
    \ by EAP-pwd include:\n   o  A prime, p, determining a prime field GF(p), the\
    \ integers modulo\n      p.  The FFC group will be a subgroup of GF(p)*, the multiplicative\n\
    \      group of non-zero elements in GF(p).  The group operation for FFC\n   \
    \   groups is multiplication modulo p.\n   o  An element, G, in GF(p)* which serves\
    \ as a generator for the FFC\n      group.  G is chosen such that its multiplicative\
    \ order is a\n      sufficiently large prime divisor of ((p-1)/2).\n   o  A prime,\
    \ r, which is the multiplicative order of G, and thus also\n      the size of\
    \ the cryptographic subgroup of GF(p)* that is generated\n      by G.\n   An integer\
    \ scalar, x, acts on an FFC group element, Y, via\n   exponentiation modulo p\
    \ -- Y^x mod p.\n   The inverse function for an FFC group is defined such that\
    \ the\n   product of an element and its inverse modulo the group prime equals\n\
    \   one (1).  In other words,\n       (q * inv(q)) mod p = 1\n   EAP-pwd uses\
    \ an IANA registry for the definition of groups.  Some FFC\n   groups in this\
    \ registry are based on safe primes and the order is not\n   included in the domain\
    \ parameters.  In this case only, the order, r,\n   MUST be computed as the prime\
    \ minus one divided by two -- (p-1)/2.\n   If the definition of the group includes\
    \ an order in its domain\n   parameters, that value MUST be used in this exchange\
    \ when an order is\n   called for.  If an FFC group definition does not have an\
    \ order in its\n   domain parameters and it is not based on a safe prime, it MUST\
    \ NOT be\n   used with EAP-pwd.\n"
- title: 2.2.2.  Elliptic Curve Cryptography
  contents:
  - "2.2.2.  Elliptic Curve Cryptography\n   Domain parameters for the ECC groups\
    \ used by EAP-pwd include:\n   o  A prime, p, determining a prime field GF(p).\
    \  The cryptographic\n      group will be a subgroup of the full elliptic curve\
    \ group that\n      consists of points on an elliptic curve -- elements from GF(p)\n\
    \      that satisfy the curve's equation -- together with the \"point at\n   \
    \   infinity\" that serves as the identity element.  The group\n      operation\
    \ for ECC groups is addition of points on the elliptic\n      curve.\n   o  Elements\
    \ a and b from GF(p) that define the curve's equation.  The\n      point (x, y)\
    \ in GF(p) x GF(p) is on the elliptic curve if and only\n      if (y^2 - x^3 -\
    \ a*x - b) mod p equals zero (0).\n   o  A point, G, on the elliptic curve, which\
    \ serves as a generator for\n      the ECC group.  G is chosen such that its order,\
    \ with respect to\n      elliptic curve addition, is a sufficiently large prime.\n\
    \   o  A prime, r, which is the order of G, and thus is also the size of\n   \
    \   the cryptographic subgroup that is generated by G.\n   o  A co-factor, f,\
    \ defined by the requirement that the size of the\n      full elliptic curve group\
    \ (including the \"point at infinity\") is\n      the product of f and r.\n  \
    \ An integer scalar, x, acts on an ECC group element, Y, via repetitive\n   addition\
    \ (Y is added to itself x times), also called point\n   multiplication -- x *\
    \ Y.\n   The inverse function for an ECC group is defined such that the sum of\n\
    \   an element and its inverse is the \"point at infinity\" (the identity\n  \
    \ for elliptic curve point addition).  In other words,\n       Q + inv(Q) = \"\
    O\"\n   Only ECC groups over GF(p) can be used by EAP-pwd.  ECC groups over\n\
    \   GF(2^m) SHALL NOT be used by EAP-pwd.  While such groups exist in the\n  \
    \ IANA registry used by EAP-pwd, their use in EAP-pwd is not defined.\n   In addition,\
    \ ECC groups with a co-factor greater than one (1) SHALL\n   NOT be used by EAP-pwd.\
    \  At the time of publication, no such groups\n   existed in the IANA registry\
    \ used by EAP-pwd.\n"
- title: 2.3.  Assumptions
  contents:
  - "2.3.  Assumptions\n   In order to see how the protocol addresses the requirements\
    \ above\n   (see Section 1.3), it is necessary to state some assumptions under\n\
    \   which the protocol can be evaluated.  They are:\n   1.  Function H maps a\
    \ binary string of indeterminate length onto a\n       fixed binary string that\
    \ is x bits in length.\n           H: {0,1}^* --> {0,1}^x\n   2.  Function H is\
    \ a \"random oracle\" (see [RANDOR]).  Given knowledge\n       of the input to\
    \ H, an adversary is unable to distinguish the\n       output of H from a random\
    \ data source.\n   3.  Function H is a one-way function.  Given the output of\
    \ H, it is\n       computationally infeasible for an adversary to determine the\n\
    \       input.\n   4.  For any given input to function H, each of the 2^x possible\n\
    \       outputs are equally probable.\n   5.  The discrete logarithm problem for\
    \ the chosen group is hard.\n       That is, given g, p, and y = g^x mod p, it\
    \ is computationally\n       infeasible to determine x.  Similarly, for an ECC\
    \ group given the\n       curve definition, a generator G, and Y = x * G, it is\n\
    \       computationally infeasible to determine x.\n   6.  There exists a pool\
    \ of passwords from which the password shared\n       by the peer and server is\
    \ drawn.  This pool can consist of words\n       from a dictionary, for example.\
    \  Each password in this pool has\n       an equal probability of being the shared\
    \ password.  All potential\n       attackers have access to this pool of passwords.\n"
- title: 2.4.  Instantiating the Random Function
  contents:
  - "2.4.  Instantiating the Random Function\n   The protocol described in this memo\
    \ uses a random function, H.  As\n   noted in Section 2.3, this is a \"random\
    \ oracle\" as defined in\n   [RANDOR].  At first glance, one may view this as\
    \ a hash function.  As\n   noted in [RANDOR], though, hash functions are too structured\
    \ to be\n   used directly as a random oracle.  But they can be used to\n   instantiate\
    \ the random oracle.\n   The random function, H, in this memo is instantiated\
    \ by HMAC-SHA256\n   (see [RFC4634]) with a key whose length is 32 octets and\
    \ whose value\n   is zero.  In other words,\n       H(x) = HMAC-SHA-256([0]32,\
    \ x)\n"
- title: 2.5.  Key Derivation Function
  contents:
  - "2.5.  Key Derivation Function\n   The keys output by this protocol, MSK and EMSK,\
    \ are each 512 bits in\n   length.  The shared secret that results from the successful\n\
    \   termination of this protocol is only 256 bits.  Therefore, it is\n   necessary\
    \ to stretch the shared secret using a key derivation\n   function (KDF).\n  \
    \ The KDF used in this protocol has a counter-mode with feedback\n   construction\
    \ using a generic pseudo-random function (PRF), according\n   to [SP800-108].\
    \  The specific value of the PRF is specified along\n   with the random function\
    \ and group when the server sends the first\n   EAP-pwd packet to the peer.\n\
    \   The KDF takes a key to stretch, a label to bind into the key, and an\n   indication\
    \ of the desired length of the output in bits.  It uses two\n   internal variables,\
    \ i and L, each of which is 16 bits in length and\n   is represented in network\
    \ order.  Algorithmically, it is:\n                KDF(key, label, length) {\n\
    \                  i = 1\n                  L = length\n                  K(1)\
    \ = PRF(key, i | label | L)\n                  res = K(1)\n                  while\
    \ (len(res) < length)\n                  do\n                    i = i + 1\n \
    \                   K(i) = PRF(key, K(i-1) | i | label | L)\n                \
    \    res = res | K(i)\n                  done\n                  return chop(res,\
    \ length)\n                }\n                     Figure 1: Key Derivation Function\n"
- title: 2.6.  Random Numbers
  contents:
  - "2.6.  Random Numbers\n   The security of EAP-pwd relies upon each side, the peer\
    \ and server,\n   producing quality secret random numbers.  A poor random number\
    \ chosen\n   by either side in a single exchange can compromise the shared secret\n\
    \   from that exchange and open up the possibility of dictionary attack.\n   Producing\
    \ quality random numbers without specialized hardware entails\n   using a cryptographic\
    \ mixing function (like a strong hash function)\n   to distill entropy from multiple,\
    \ uncorrelated sources of information\n   and events.  A very good discussion\
    \ of this can be found in\n   [RFC4086].\n"
- title: 2.7.  Representation and Processing of Input Strings
  contents:
  - '2.7.  Representation and Processing of Input Strings

    '
- title: 2.7.1.  Identity Strings
  contents:
  - "2.7.1.  Identity Strings\n   The strings representing the server identity and\
    \ peer identity MUST\n   follow the requirements of [RFC4282] for Network Access\
    \ Identifiers.\n   This ensures a canonical representation of identities by both\
    \ ends of\n   the conversation prior to their use in EAP-pwd.\n"
- title: 2.7.2.  Passwords
  contents:
  - "2.7.2.  Passwords\n   EAP-pwd requires passwords be input as binary strings.\
    \  For the\n   protocol to successfully terminate, each side must produce identical\n\
    \   binary strings from the password.  This imposes processing\n   requirements\
    \ on a password prior to its use.\n   Three techniques for password pre-processing\
    \ exist for EAP-pwd:\n   o   None: The input password string SHALL be treated\
    \ as an ASCII\n       string or a hexadecimal string with no treatment or normalization\n\
    \       performed.  The output SHALL be the binary representation of the\n   \
    \    input string.\n   o   RFC 2759: The input password string SHALL be processed\
    \ to produce\n       the output PasswordHashHash, as defined in [RFC2759], including\n\
    \       any approved errata to [RFC2759].  This technique is useful when\n   \
    \    the server does not have access to the plaintext password.\n   o   SASLprep:\
    \ The input password string is processed according to the\n       rules of the\
    \ [RFC4013] profile of [RFC3454].  A password SHALL be\n       considered a \"\
    stored string\" per [RFC3454], and unassigned code\n       points are therefore\
    \ prohibited.  The output SHALL be the binary\n       representation of the processed\
    \ UTF-8 character string.\n       Prohibited output and unassigned codepoints\
    \ encountered in\n       SASLprep pre-processing SHALL cause a failure of pre-processing,\n\
    \       and the output SHALL NOT be used with EAP-pwd.\n   Changing a password\
    \ is out of scope of EAP-pwd, but due to the\n   ambiguities in the way internationalized\
    \ character strings are\n   handled, 1) it SHOULD be done using SASLprep to ensure\
    \ a canonical\n   representation of the new password is stored on the server,\
    \ and 2)\n   subsequent invocations of EAP-pwd SHOULD use SASLprep to ensure that\n\
    \   the client generates an identical binary string from the input\n   password.\n"
- title: 2.8.  Protocol
  contents:
  - '2.8.  Protocol

    '
- title: 2.8.1.  Overview
  contents:
  - "2.8.1.  Overview\n   EAP is a two-party protocol spoken between an EAP peer and\
    \ an\n   authenticator.  For scaling purposes, the functionality of the\n   authenticator\
    \ that speaks EAP is frequently broken out into a stand-\n   alone EAP server.\
    \  In this case, the EAP peer communicates with an\n   EAP server through the\
    \ authenticator, with the authenticator merely\n   being a passthrough.\n   An\
    \ EAP method defines the specific authentication protocol being used\n   by EAP.\
    \  This memo defines a particular method and therefore defines\n   the messages\
    \ sent between the EAP server (or the \"EAP server\"\n   functionality in an authenticator\
    \ if it is not broken out) and the\n   EAP peer for the purposes of authentication\
    \ and key derivation.\n"
- title: 2.8.2.  Message Flows
  contents:
  - "2.8.2.  Message Flows\n   EAP-pwd defines three message exchanges: an Identity\
    \ exchange, a\n   Commit exchange, and a Confirm exchange.  A successful authentication\n\
    \   is shown in Figure 2.\n   The peer and server use the Identity exchange to\
    \ discover each\n   other's identities and to agree upon a Ciphersuite to use\
    \ in the\n   subsequent exchanges; in addition, the EAP Server uses the EAP-pwd-\n\
    \   ID/Request message to inform the client of any password pre-\n   processing\
    \ that may be required.  In the Commit exchange, the peer\n   and server exchange\
    \ information to generate a shared key and also to\n   bind each other to a particular\
    \ guess of the password.  In the\n   Confirm exchange, the peer and server prove\
    \ liveness and knowledge of\n   the password by generating and verifying verification\
    \ data.\n           +--------+                                     +--------+\n\
    \           |        |                  EAP-pwd-ID/Request |        |\n      \
    \     |  EAP   |<------------------------------------|  EAP   |\n           |\
    \  peer  |                                     | server |\n           |      \
    \  | EAP-pwd-ID/Response                 |        |\n           |        |------------------------------------>|\
    \        |\n           |        |                                     |      \
    \  |\n           |        |              EAP-pwd-Commit/Request |        |\n \
    \          |        |<------------------------------------|        |\n       \
    \    |        |                                     |        |\n           | \
    \       | EAP-pwd-Commit/Response             |        |\n           |       \
    \ |------------------------------------>|        |\n           |        |    \
    \                                 |        |\n           |        |          \
    \   EAP-pwd-Confirm/Request |        |\n           |        |<------------------------------------|\
    \        |\n           |        |                                     |      \
    \  |\n           |        | EAP-pwd-Confirm/Response            |        |\n \
    \          |        |------------------------------------>|        |\n       \
    \    |        |                                     |        |\n           | \
    \       |          EAP-Success                |        |\n           |       \
    \ |<------------------------------------|        |\n           +--------+    \
    \                                 +--------+\n                  Figure 2: A Successful\
    \ EAP-pwd Exchange\n   The components of the EAP-pwd-* messages are as follows:\n\
    \   EAP-pwd-ID/Request\n       Ciphersuite, Token, Password Processing Method,\
    \ Server_ID\n   EAP-pwd-ID/Response\n       Ciphersuite, Token, Password Processing\
    \ Method, Peer_ID\n   EAP-pwd-Commit/Request\n       Scalar_S, Element_S\n   EAP-pwd-Commit/Response\n\
    \       Scalar_P, Element_P\n   EAP-pwd-Confirm/Request\n       Confirm_S\n  \
    \ EAP-pwd-Confirm/Response\n       Confirm_P\n"
- title: 2.8.3.  Fixing the Password Element
  contents:
  - "2.8.3.  Fixing the Password Element\n   Once the EAP-pwd-ID exchange is completed,\
    \ the peer and server use\n   each other's identities and the agreed upon ciphersuite\
    \ to fix an\n   element in the negotiated group called the Password Element (PWE\
    \ or\n   pwe, for an element in an ECC group or an FFC group, respectively).\n\
    \   The resulting element must be selected in a deterministic fashion\n   using\
    \ the password but must result in selection of an element that\n   will not leak\
    \ any information about the password to an attacker.\n   From the point of view\
    \ of an attacker who does not know the password,\n   the Password Element will\
    \ be a random element in the negotiated\n   group.\n   To properly fix the Password\
    \ Element, both parties must have a common\n   view of the string \"password\"\
    .  Therefore, if a password pre-\n   processing algorithm was negotiated during\
    \ the EAP-pwd-ID exchange,\n   the client MUST perform the specified password\
    \ pre-processing prior\n   to fixing the Password Element.\n   Fixing the Password\
    \ Element involves an iterative hunting-and-pecking\n   technique using the prime\
    \ from the negotiated group's domain\n   parameter set and an ECC- or FFC-specific\
    \ operation depending on the\n   negotiated group.\n   First, an 8-bit counter\
    \ is set to the value one (1).  Then, the\n   agreed-upon random function is used\
    \ to generate a password seed from\n   the identities and the anti-clogging token\
    \ from the EAP-pwd-ID\n   exchange (see Section 2.8.5.1):\n      pwd-seed = H(token\
    \ | peer-ID | server-ID | password | counter)\n   Then, the pwd-seed is expanded\
    \ using the KDF from the agreed-upon\n   Ciphersuite out to the length of the\
    \ prime:\n      pwd-value = KDF(pwd-seed, \"EAP-pwd Hunting And Pecking\", len(p))\n\
    \   If the pwd-value is greater than or equal to the prime, p, the\n   counter\
    \ is incremented, and a new pwd-seed is generated and the\n   hunting-and-pecking\
    \ continues.  If pwd-value is less than the prime,\n   p, it is passed to the\
    \ group-specific operation which either returns\n   the selected Password Element\
    \ or fails.  If the group-specific\n   operation fails, the counter is incremented,\
    \ a new pwd-seed is\n   generated, and the hunting-and-pecking continues.  This\
    \ process\n   continues until the group-specific operation returns the Password\n\
    \   Element.\n"
- title: 2.8.3.1.  ECC Operation for PWE
  contents:
  - "2.8.3.1.  ECC Operation for PWE\n   The group-specific operation for ECC groups\
    \ uses pwd-value, pwd-seed,\n   and the equation for the curve to produce the\
    \ Password Element.\n   First, pwd-value is used directly as the x-coordinate,\
    \ x, with the\n   equation for the elliptic curve, with parameters a and b from\
    \ the\n   domain parameter set of the curve, to solve for a y-coordinate, y.\n\
    \   If there is no solution to the quadratic equation, this operation\n   fails\
    \ and the hunting-and-pecking process continues.  If a solution\n   is found,\
    \ then an ambiguity exists as there are technically two\n   solutions to the equation\
    \ and pwd-seed is used to unambiguously\n   select one of them.  If the low-order\
    \ bit of pwd-seed is equal to the\n   low-order bit of y, then a candidate PWE\
    \ is defined as the point\n   (x, y); if the low-order bit of pwd-seed differs\
    \ from the low-order\n   bit of y, then a candidate PWE is defined as the point\
    \ (x, p - y),\n   where p is the prime over which the curve is defined.  The candidate\n\
    \   PWE becomes PWE, and the hunting and pecking terminates successfully.\n  \
    \ Algorithmically, the process looks like this:\n      found = 0\n      counter\
    \ = 1\n      do {\n        pwd-seed = H(token | peer-ID | server-ID | password\
    \ | counter)\n        pwd-value = KDF(pwd-seed, \"EAP-pwd Hunting And Pecking\"\
    , len(p))\n        if (pwd-value < p)\n        then\n          x = pwd-value\n\
    \          if ( (y = sqrt(x^3 + ax + b)) != FAIL)\n          then\n          \
    \  if (LSB(y) == LSB(pwd-seed))\n            then\n              PWE = (x, y)\n\
    \            else\n              PWE = (x, p-y)\n            fi\n            found\
    \ = 1\n          fi\n        fi\n        counter = counter + 1\n      } while\
    \ (found == 0)\n                    Figure 3: Fixing PWE for ECC Groups\n"
- title: 2.8.3.2.  FFC Operation for pwe
  contents:
  - "2.8.3.2.  FFC Operation for pwe\n   The group-specific operation for FFC groups\
    \ takes pwd-value, and the\n   prime, p, and order, r, from the group's domain\
    \ parameter set (see\n   Section 2.2.1 when the order is not part of the defined\
    \ domain\n   parameter set) to directly produce a candidate Password Element,\
    \ pwe,\n   by exponentiating the pwd-value to the value ((p-1)/r) modulo the\n\
    \   prime.  If the result is greater than one (1), the candidate pwe\n   becomes\
    \ pwe, and the hunting and pecking terminates successfully.\n   Algorithmically,\
    \ the process looks like this:\n      found = 0\n      counter = 1\n      do {\n\
    \        pwd-seed = H(token | peer-ID | server-ID | password | counter)\n    \
    \    pwd-value = KDF(pwd-seed, \"EAP-pwd Hunting And Pecking\", len(p))\n    \
    \    if (pwd-value < p)\n        then\n          pwe = pwd-value ^ ((p-1)/r) mod\
    \ p\n          if (pwe > 1)\n          then\n            found = 1\n         \
    \ fi\n        fi\n        counter = counter + 1\n      } while (found == 0)\n\
    \                    Figure 4: Fixing PWE for FFC Groups\n"
- title: 2.8.4.  Message Construction
  contents:
  - "2.8.4.  Message Construction\n   After the EAP-pwd Identity exchange, the construction\
    \ of the\n   components of subsequent messages depends on the type of group from\n\
    \   the ciphersuite (ECC or FFC).  This section provides an overview of\n   the\
    \ authenticated key exchange.  For a complete description of\n   message generation\
    \ and processing, see Sections 2.8.5.2 and 2.8.5.3.\n"
- title: 2.8.4.1.  ECC Groups
  contents:
  - "2.8.4.1.  ECC Groups\n   Using the mapping function F() defined in Section 2.2.2\
    \ and the group\n   order r:\n   Server: EAP-pwd-Commit/Request\n      - choose\
    \ two random numbers, 1 < s_rand, s_mask < r\n      - compute Scalar_S = (s_rand\
    \ + s_mask) mod r\n      - compute Element_S = inv(s_mask * PWE)\n    Element_S\
    \ and Scalar_S are used to construct EAP-pwd-Commit/Request\n   Peer: EAP-pwd-Commit/Response\n\
    \      - choose two random numbers, 1 < p_rand, p_mask < r\n      - compute Scalar_P\
    \ = (p_rand + p_mask) mod r\n      - compute Element_P = inv(p_mask * PWE)\n \
    \   Element_P and Scalar_P are used to construct EAP-pwd-Commit/Response\n   Server:\
    \ EAP-pwd-Confirm/Request\n      - compute KS = (s_rand * (Scalar_P * PWE + Element_P))\n\
    \      - compute ks = F(KS)\n      - compute Confirm_S = H(ks | Element_S | Scalar_S\
    \ |\n                              Element_P | Scalar_P | Ciphersuite)\n    Confirm_S\
    \ is used to construct EAP-pwd-Confirm/Request\n   Peer: EAP-pwd-Confirm/Response\n\
    \      - compute KP = (p_rand * (Scalar_S * PWE + Element_S)),\n      - compute\
    \ kp = F(KP)\n      - compute Confirm_P = H(kp | Element_P | Scalar_P |\n    \
    \                          Element_S | Scalar_S | Ciphersuite)\n    Confirm_P\
    \ is used to construct EAP-pwd-Confirm/Response\n   The EAP Server computes the\
    \ shared secret as:\n     MK = H(ks | Confirm_P | Confirm_S)\n   The EAP Peer\
    \ computes the shared secret as:\n     MK = H(kp | Confirm_P | Confirm_S)\n  \
    \ The MSK and EMSK are derived from MK per Section 2.9.\n"
- title: 2.8.4.2.  FFC Groups
  contents:
  - "2.8.4.2.  FFC Groups\n   There is no mapping function, F(), required for an FFC\
    \ group.  Using\n   the order, r, for the group (see Section 2.2.1 when the order\
    \ is not\n   part of the defined domain parameters):\n   Server: EAP-pwd-Commit/Request\n\
    \      - choose two random numbers, 1 < s_rand, s_mask < r\n      - compute Scalar_S\
    \ = (s_rand + s_mask) mod r\n      - compute Element_S = inv(pwe^s_mask mod p)\n\
    \    Element_S and Scalar_S are used to construct EAP-pwd-Commit/Request\n   Peer:\
    \ EAP-pwd-Commit/Response\n      - choose random two numbers, 1 < p_rand, p_mask\
    \ < r\n      - compute Scalar_P = (p_rand + p_mask) mod r\n      - compute Element_P\
    \ = inv(pwe^p_mask mod p)\n    Element_P and Scalar_P are used to construct EAP-pwd-Commit/Response\n\
    \   Server: EAP-pwd-Confirm/Request\n      - compute ks = ((pwe^Scalar_P mod p)\
    \ * Element_P)^s_rand mod p\n      - compute Confirm_S = H(ks | Element_S | Scalar_S\
    \ |\n                              Element_P | Scalar_P | Ciphersuite)\n    Confirm_S\
    \ is used to construct EAP-pwd-Confirm/Request\n   Peer: EAP-pwd-Confirm/Response\n\
    \      - compute kp = ((pwe^Scalar_S mod p) * Element_S)^p_rand mod p\n      -\
    \ compute Confirm_P = H(kp | Element_P | Scalar_P |\n                        \
    \      Element_S | Scalar_S | Ciphersuite)\n    Confirm_P is used to construct\
    \ EAP-pwd-Confirm/Request\n   The EAP Server computes the shared secret as:\n\
    \     MK = H(ks | Confirm_P | Confirm_S)\n   The EAP Peer computes the shared\
    \ secret as:\n     MK = H(kp | Confirm_P | Confirm_S)\n   The MSK and EMSK are\
    \ derived from MK per Section 2.9.\n"
- title: 2.8.5.  Message Processing
  contents:
  - '2.8.5.  Message Processing

    '
- title: 2.8.5.1.  EAP-pwd-ID Exchange
  contents:
  - "2.8.5.1.  EAP-pwd-ID Exchange\n   Although EAP provides an Identity method to\
    \ determine the identity of\n   the peer, the value in the Identity Response may\
    \ have been truncated\n   or obfuscated to provide privacy or decorated for routing\
    \ purposes\n   [RFC3748], making it inappropriate for usage by the EAP-pwd method.\n\
    \   Therefore, the EAP-pwd-ID exchange is defined for the purpose of\n   exchanging\
    \ identities between the peer and server.\n   The EAP-pwd-ID/Request contains\
    \ the following quantities:\n   o  a ciphersuite\n   o  a representation of the\
    \ server's identity per Section 2.7.1\n   o  an anti-clogging token\n   o  a password\
    \ pre-processing method\n   The ciphersuite specifies the finite cyclic group,\
    \ random function,\n   and PRF selected by the server for use in the subsequent\n\
    \   authentication exchange.\n   The value of the anti-clogging token MUST be\
    \ unpredictable and SHOULD\n   NOT be from a source of random entropy.  The purpose\
    \ of the anti-\n   clogging token is to provide the server an assurance that the\
    \ peer\n   constructing the EAP-pwd-ID/Response is genuine and not part of a\n\
    \   flooding attack.\n   A password pre-processing method is communicated to ensure\n\
    \   interoperability by producing a canonical representation of the\n   password\
    \ string between the peer and server (see Section 2.7.2).\n   The EAP-pwd-ID/Request\
    \ is constructed according to Section 3.2.1 and\n   is transmitted to the peer.\n\
    \   Upon receipt of an EAP-pwd-ID/Request, the peer determines whether\n   the\
    \ ciphersuite and pre-processing method are acceptable.  If not,\n   the peer\
    \ MUST respond with an EAP-NAK.  If acceptable, the peer\n   responds to the EAP-pwd-ID/Request\
    \ with an EAP-pwd-ID/Response,\n   constructed according to Section 3.2.1, that\
    \ acknowledges the\n   Ciphersuite, token, and pre-processing method and then\
    \ adds its\n   identity.  After sending the EAP-pwd-ID/Response, the peer has\
    \ the\n   identity of the server (from the Request), its own identity (it\n  \
    \ encoded in the Response), a password pre-processing algorithm, and it\n   can\
    \ compute the Password Element as specified in Section 2.8.3.  The\n   Password\
    \ Element is stored in state allocated for this exchange.\n   The EAP-pwd-ID/Response\
    \ acknowledges the Ciphersuite from the\n   Request, acknowledges the anti-clogging\
    \ token from the Request\n   providing a demonstration of \"liveness\" on the\
    \ part of the peer, and\n   contains the identity of the peer.  Upon receipt of\
    \ the Response, the\n   server verifies that the Ciphersuite acknowledged by the\
    \ peer is the\n   same as that sent in the Request and that the anti-clogging\
    \ token\n   added by the peer in the Response is the same as that sent in the\n\
    \   Request.  If Ciphersuites or anti-clogging tokens differ, the server\n   MUST\
    \ respond with an EAP-Failure message.  If the anti-clogging\n   tokens are the\
    \ same, the server knows the peer is an active\n   participant in the exchange.\
    \  If the Ciphersuites are the same, the\n   server now knows its own identity\
    \ (it encoded in the Request) and the\n   peer's identity (from the Response)\
    \ and can compute the Password\n   Element according to Section 2.8.3.  The server\
    \ stores the Password\n   Element in state it has allocated for this exchange.\
    \  The server then\n   initiates an EAP-pwd-Commit exchange.\n"
- title: 2.8.5.2.  EAP-pwd-Commit Exchange
  contents:
  - "2.8.5.2.  EAP-pwd-Commit Exchange\n   The server begins the EAP-pwd-Confirm exchange\
    \ by choosing two random\n   numbers, s_rand and s_mask, between 1 and r (where\
    \ r is described in\n   Section 2.1 according to the group established in Section\
    \ 2.8.5.1)\n   such that their sum modulo r is greater than one (1).  It then\n\
    \   computes Element_S and Scalar_S as defined in Section 2.8.4 and\n   constructs\
    \ an EAP-pwd-Commit/Request according to Section 3.2.2.\n   Element_S and Scalar_S\
    \ are added to the state allocated for this\n   exchange, and the EAP-pwd-Commit/Request\
    \ is transmitted to the peer.\n   Upon receipt of the EAP-pwd-Commit/Request,\
    \ the peer validates the\n   length of the entire payload based upon the expected\
    \ lengths of\n   Element_S and Scalar_S (which are fixed according to the length\
    \ of\n   the agreed-upon group).  If the length is incorrect, the peer MUST\n\
    \   terminate the exchange.  If the length is correct, Element_S and\n   Scalar_S\
    \ are extracted from the EAP-pwd-Commit/Request.  Scalar_S is\n   then checked\
    \ to ensure it is between 1 and r, exclusive.  If it is\n   not, the peer MUST\
    \ terminate the exchange.  If it is, Element_S MUST\n   be validated depending\
    \ on the type of group -- Element validation for\n   FFC groups is described in\
    \ Section 2.8.5.2.1, and Element validation\n   for ECC groups is described in\
    \ Section 2.8.5.2.2.  If validation is\n   successful, the peer chooses two random\
    \ numbers, p_rand and p_mask,\n   between 1 and r (where r is described in Section\
    \ 2.1 according to the\n   group established in Section 2.8.5.1) such that their\
    \ sum modulo r is\n   greater than one (1), and computes Element_P and Scalar_P.\
    \  Next, the\n   peer computes kp from p_rand, Element_S, Scalar_S, and the Password\n\
    \   Element according to Section 2.8.4.  If kp is the \"identity element\"\n \
    \  -- the point at infinity for an ECC group or the value one (1) for an\n   FFC\
    \ group -- the peer MUST terminate the exchange.  If not, the peer\n   uses Element_P\
    \ and Scalar_P to construct an EAP-pwd-Commit/Response\n   according to Section\
    \ 3.2.2 and transmits the EAP-pwd-Commit/Response\n   to the server.\n   Upon\
    \ receipt of the EAP-pwd-Commit/Response, the server validates the\n   length\
    \ of the entire payload based upon the expected lengths of\n   Element_P and Scalar_P\
    \ (which are fixed according to the agreed-upon\n   group).  If the length is\
    \ incorrect, the server MUST respond with an\n   EAP-Failure message, and it MUST\
    \ terminate the exchange and free up\n   any state allocated.  If the length is\
    \ correct, Scalar_P and\n   Element_P are extracted from the EAP-pwd-Commit/Response\
    \ and compared\n   to Scalar_S and Element_S.  If Scalar_P equals Scalar_S and\
    \ Element_P\n   equals Element_S, it indicates a reflection attack and the server\n\
    \   MUST respond with an EAP-failure and terminate the exchange.  If they\n  \
    \ differ, Scalar_P is checked to ensure it is between 1 and r,\n   exclusive.\
    \  If not the server MUST respond with an EAP-failure and\n   terminate the exchange.\
    \  If it is, Element_P is verified depending on\n   the type of group -- Element\
    \ validation for FFC groups is described\n   in Section 2.8.5.2.1, and Element\
    \ validation for ECC groups is\n   described in Section 2.8.5.2.2.  If validation\
    \ is successful, the\n   server computes ks from s_rand, Element_P, Scalar_P,\
    \ and the Password\n   Element according to Section 2.8.4.  If ks is the \"identity\
    \ element\"\n   -- the point at infinity for an ECC group or the value one (1)\
    \ for an\n   FFC group -- the server MUST respond with an EAP-failure and\n  \
    \ terminate the exchange.  Otherwise, the server initiates an EAP-pwd-\n   Confirm\
    \ exchange.\n"
- title: 2.8.5.2.1.  Element Validation for FFC Groups
  contents:
  - "2.8.5.2.1.  Element Validation for FFC Groups\n   A received FFC Element is valid\
    \ if: 1) it is between one (1) and the\n   prime, p, exclusive; and 2) if modular\
    \ exponentiation of the Element\n   by the group order, r, equals one (1).  If\
    \ either of these conditions\n   are not true the received Element is invalid.\n"
- title: 2.8.5.2.2.  Element Validation for ECC Groups
  contents:
  - "2.8.5.2.2.  Element Validation for ECC Groups\n   Validating a received ECC Element\
    \ involves: 1) checking whether the\n   two coordinates, x and y, are both greater\
    \ than zero (0) and less\n   than the prime defining the underlying field; and\
    \ 2) checking whether\n   the x- and y-coordinates satisfy the equation of the\
    \ curve (that is,\n   that they produce a valid point on the curve that is not\
    \ the point at\n   infinity).  If either of these conditions are not met, the\
    \ received\n   Element is invalid; otherwise, the Element is valid.\n"
- title: 2.8.5.3.  EAP-pwd-Confirm Exchange
  contents:
  - "2.8.5.3.  EAP-pwd-Confirm Exchange\n   The server computes Confirm_S according\
    \ to Section 2.8.4, constructs\n   an EAP-pwd-Confirm/Request according to Section\
    \ 3.2.3, and sends it\n   to the peer.\n   Upon receipt of an EAP-pwd-Confirm/Request,\
    \ the peer validates the\n   length of the entire payload based upon the expected\
    \ length of\n   Confirm_S (whose length is fixed by the agreed-upon random function).\n\
    \   If the length is incorrect, the peer MUST terminate the exchange and\n   free\
    \ up any state allocated.  If the length is correct, the peer\n   verifies that\
    \ Confirm_S is the value it expects based on the value of\n   kp.  If the value\
    \ of Confirm_S is incorrect, the peer MUST terminate\n   the exchange and free\
    \ up any state allocated.  If the value of\n   Confirm_S is correct, the peer\
    \ computes Confirm_P, constructs an EAP-\n   pwd-Confirm/Response according to\
    \ Section 3.2.3, and sends it off to\n   the server.  The peer then computes MK\
    \ (according to Section 2.8.4)\n   and the MSK and EMSK (according to Section\
    \ 2.9) and stores these keys\n   in state allocated for this exchange.  The peer\
    \ SHOULD export the MSK\n   and EMSK at this time in anticipation of a secure\
    \ association\n   protocol by the lower layer to create session keys.  Alternatively,\n\
    \   the peer can wait until an EAP-Success message from the server before\n  \
    \ exporting the MSK and EMSK.\n   Upon receipt of an EAP-pwd-Confirm/Response,\
    \ the server validates the\n   length of the entire payload based upon the expected\
    \ length of\n   Confirm_P (whose length is fixed by the agreed-upon random function).\n\
    \   If the length is incorrect, the server MUST respond with an EAP-\n   Failure\
    \ message, and it MUST terminate the exchange and free up any\n   state allocated.\
    \  If the length is correct, the server verifies that\n   Confirm_P is the value\
    \ it expects based on the value of ks.  If the\n   value of Confirm_P is incorrect,\
    \ the server MUST respond with an EAP-\n   Failure message.  If the value of Confirm_P\
    \ is correct, the server\n   computes MK (according to Section 2.8.4) and the\
    \ MSK and EMSK\n   (according to Section 2.9).  It exports the MSK and EMSK and\
    \ responds\n   with an EAP-Success message.  The server SHOULD free up state\n\
    \   allocated for this exchange.\n"
- title: 2.9.  Management of EAP-pwd Keys
  contents:
  - "2.9.  Management of EAP-pwd Keys\n   [RFC5247] recommends each EAP method define\
    \ how to construct a\n   Method-ID and Session-ID to identify a particular EAP\
    \ session between\n   a peer and server.  This information is constructed thusly:\n\
    \       Method-ID = H(Ciphersuite | Scalar_P | Scalar_S)\n       Session-ID =\
    \ Type-Code | Method-ID\n   where Ciphersuite, Scalar_P, and Scalar_S are from\
    \ the specific\n   exchange being identified; H is the random function specified\
    \ in the\n   Ciphersuite; and, Type-Code is the code assigned for EAP-pwd, 52,\n\
    \   represented as a single octet.\n   The authenticated key exchange of EAP-pwd\
    \ generates a shared and\n   authenticated key, MK.  The size of MK is dependent\
    \ on the random\n   function, H, asserted in the Ciphersuite.  EAP-pwd must export\
    \ two\n   512-bit keys, MSK and EMSK.  Regardless of the value of len(MK),\n \
    \  implementations MUST invoke the KDF defined in Section 2.5 to\n   construct\
    \ the MSK and EMSK.  The MSK and EMSK are derived thusly:\n       MSK | EMSK =\
    \ KDF(MK, Session-ID, 1024)\n   [RFC4962] mentions the importance of naming keys,\
    \ particularly when\n   key caching is being used.  To facilitate such an important\n\
    \   optimization, names are assigned thusly:\n   o   EMSK-name = Session-ID |\
    \ 'E' | 'M'| 'S' | 'K'\n   o   MSK-name = Session-ID | 'M'| 'S' | 'K'\n   where\
    \ 'E' is a single octet of value 0x45, 'M' is a single octet of\n   value 0x4d,\
    \ 'S' is a single octet of value 0x53, and 'K' is a single\n   octet of value\
    \ 0x4b.\n   This naming scheme allows for key-management applications to quickly\n\
    \   and accurately identify keys for a particular session or all keys of\n   a\
    \ particular type.\n"
- title: 2.10.  Mandatory-to-Implement Parameters
  contents:
  - "2.10.  Mandatory-to-Implement Parameters\n   For the purposes of interoperability,\
    \ compliant EAP-pwd\n   implementations SHALL support the following parameters:\n\
    \   o   Diffie-Hellman Group: group 19 defined in [RFC5114]\n   o   Random Function:\
    \ defined in Section 2.4\n   o   PRF: HMAC-SHA256 defined in [RFC4634]\n   o \
    \  Password Pre-Processing: none\n"
- title: 3.  Packet Formats
  contents:
  - '3.  Packet Formats

    '
- title: 3.1.  EAP-pwd Header
  contents:
  - "3.1.  EAP-pwd Header\n   The EAP-pwd header has the following structure:\n  \
    \      0                   1                   2                   3\n       \
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |     Code      |  Identifier   |             Length            |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |     Type      |L|M|  PWD-Exch |         Total-Length          |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \                             Data...\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                         Figure 5: EAP-pwd Header\n   Code\n      Either 1 (for\
    \ Request) or 2 (for Response); see [RFC3748].\n   Identifier\n      The Identifier\
    \ field is one octet and aids in matching responses\n      with requests.  The\
    \ Identifier field MUST be changed on each\n      Request packet.\n   Length\n\
    \      The Length field is two octets and indicates the length of the EAP\n  \
    \    packet including the Code, Identifier, Length, Type, and Data\n      fields.\
    \  Octets outside the range of the Length field should be\n      treated as Data\
    \ Link Layer padding and MUST be ignored on\n      reception.\n   Type\n     \
    \ 52 - EAP-pwd\n   L and M bits\n      The L bit (Length included) is set to indicate\
    \ the presence of the\n      two-octet Total-Length field, and MUST be set for\
    \ the first\n      fragment of a fragmented EAP-pwd message or set of messages.\n\
    \      The M bit (more fragments) is set on all but the last fragment.\n   PWD-Exch\n\
    \      The PWD-Exch field identifies the type of EAP-pwd payload\n      encapsulated\
    \ in the Data field.  This document defines the\n      following values for the\
    \ PWD-Exch field:\n      *   0x00 : Reserved\n      *   0x01 : EAP-pwd-ID exchange\n\
    \      *   0x02 : EAP-pwd-Commit exchange\n      *   0x03 : EAP-pwd-Confirm exchange\n\
    \      All other values of the PWD-Exch field are unassigned.\n   Total-Length\n\
    \      The Total-Length field is two octets in length, and is present\n      only\
    \ if the L bit is set.  This field provides the total length of\n      the EAP-pwd\
    \ message or set of messages that is being fragmented.\n"
- title: 3.2.  EAP-pwd Payloads
  contents:
  - "3.2.  EAP-pwd Payloads\n   EAP-pwd payloads all contain the EAP-pwd header and\
    \ encoded\n   information.  Encoded information is comprised of sequences of data.\n\
    \   Payloads in the EAP-pwd-ID exchange also include a ciphersuite\n   statement\
    \ indicating what finite cyclic group to use, what\n   cryptographic primitive\
    \ to use for H, and what PRF to use for\n   deriving keys.\n"
- title: 3.2.1.  EAP-pwd-ID
  contents:
  - "3.2.1.  EAP-pwd-ID\n   The Group Description, Random Function, and PRF together,\
    \ and in that\n   order, comprise the Ciphersuite included in the calculation\
    \ of the\n   peer's and server's confirm messages.\n        0                \
    \   1                   2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |       Group Description       | Random Func'n |      PRF      |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |                             Token                             |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \      Prep     |                  Identity...\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                       Figure 6: EAP-pwd-ID Payload\n   The Group Description\
    \ field value is taken from the IANA registry for\n   \"Group Description\" created\
    \ by IKE [RFC2409].\n   This document defines the following value for the Random\
    \ Function\n   field:\n   o   0x01 : Function defined in this memo in Section\
    \ 2.4\n   The value 0x00 is reserved for private use between mutually\n   consenting\
    \ parties.  All other values of the Random Function field\n   are unassigned.\n\
    \   The PRF field has the following value:\n   o   0x01 : HMAC-SHA256 [RFC4634]\n\
    \   The value 0x00 is reserved for private use between mutually\n   consenting\
    \ parties.  All other values of the PRF field are\n   unassigned.\n   The Token\
    \ field contains an unpredictable value assigned by the\n   server in an EAP-pwd-ID/Request\
    \ and acknowledged by the peer in an\n   EAP-pwd-ID/Response (see Section 2.8.5).\n\
    \   The Prep field represents the password pre-processing technique (see\n   Section\
    \ 2.7.2) to be used by the client prior to generating the\n   password seed (see\
    \ Section 2.8.3).  This document defines the\n   following values for the Prep\
    \ field:\n   o   0x00 : None\n   o   0x01 : RFC2759\n   o   0x02 : SASLprep\n\
    \   All other values of the Prep field are unassigned.\n   The Identity field\
    \ depends on the tuple of PWD-Exch/Code.\n   o   EAP-pwd-ID/Request : Server_ID\n\
    \   o   EAP-pwd-ID/Response : Peer_ID\n   The length of the identity is computed\
    \ from the Length field in the\n   EAP header.\n"
- title: 3.2.2.  EAP-pwd-Commit
  contents:
  - "3.2.2.  EAP-pwd-Commit\n        0                   1                   2   \
    \                3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |                                                               |\n  \
    \     ~                           Element                             ~\n    \
    \   |                                                               |\n      \
    \ ~                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \                               |                               |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               ~\n       |                                  \
    \                             |\n       ~                            Scalar  \
    \           +-+-+-+-+-+-+-+-+\n       |                                      \
    \         |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \               Figure 7: EAP-pwd-Commit Payload\n   The Element and Scalar fields\
    \ depend on the tuple of PWD-Exch/Code.\n   o   EAP-pwd-Commit/Request : Element_S,\
    \ Scalar_S\n   o   EAP-pwd-Commit/Response : Element_P, Scalar_P\n   The Element\
    \ is encoded according to Section 3.3.  The length of the\n   Element is inferred\
    \ by the finite cyclic group from the agreed-upon\n   Ciphersuite.  The length\
    \ of the scalar can then be computed from the\n   Length in the EAP header.\n"
- title: 3.2.3.  EAP-pwd-Confirm
  contents:
  - "3.2.3.  EAP-pwd-Confirm\n        0                   1                   2  \
    \                 3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |                                                               |\n  \
    \     ~                            Confirm                            ~\n    \
    \   |                                                               |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n        \
    \             Figure 8: EAP-pwd-Confirm Payload\n   The Confirm field depends\
    \ on the tuple of PWD-Exch/Code.\n   o   EAP-pwd-Confirm/Request : Confirm_S\n\
    \   o   EAP-pwd-Confirm/Response : Confirm_P\n   The length of the Confirm field\
    \ computed from the Length in the EAP\n   header.\n"
- title: 3.3.  Representation of Group Elements and Scalars
  contents:
  - "3.3.  Representation of Group Elements and Scalars\n   Payloads in the EAP-pwd-Commit\
    \ exchange contain elements from the\n   agreed-upon finite cyclic cryptographic\
    \ group (either an FCC group or\n   an ECC group).  To ensure interoperability,\
    \ field elements and\n   scalars MUST be represented in payloads in accordance\
    \ with the\n   requirements described below.\n"
- title: 3.3.1.  Elements in FFC Groups
  contents:
  - "3.3.1.  Elements in FFC Groups\n   Elements in an FFC group MUST be represented\
    \ (in binary form) as\n   unsigned integers that are strictly less than the prime,\
    \ p, from the\n   group's domain parameter set.  The binary representation of\
    \ each\n   group element MUST have a bit length equal to the bit length of the\n\
    \   binary representation of p.  This length requirement is enforced, if\n   necessary,\
    \ by prepending the binary representation of the integer\n   with zeros until\
    \ the required length is achieved.\n"
- title: 3.3.2.  Elements in ECC Groups
  contents:
  - "3.3.2.  Elements in ECC Groups\n   Elements in an ECC group are points on the\
    \ agreed-upon elliptic\n   curve.  Each such element MUST be represented by the\
    \ concatenation of\n   two components, an x-coordinate and a y-coordinate.\n \
    \  Each of the two components, the x-coordinate and the y-coordinate,\n   MUST\
    \ be represented (in binary form) as an unsigned integer that is\n   strictly\
    \ less than the prime, p, from the group's domain parameter\n   set.  The binary\
    \ representation of each component MUST have a bit\n   length equal to the bit\
    \ length of the binary representation of p.\n   This length requirement is enforced,\
    \ if necessary, by prepending the\n   binary representation of the integer with\
    \ zeros until the required\n   length is achieved.\n   Since the field element\
    \ is represented in a payload by the\n   x-coordinate followed by the y-coordinate,\
    \ it follows that the length\n   of the element in the payload MUST be twice the\
    \ bit length of p.  In\n   other words, \"compressed representation\" is not used.\n"
- title: 3.3.3.  Scalars
  contents:
  - "3.3.3.  Scalars\n   Scalars MUST be represented (in binary form) as unsigned\
    \ integers\n   that are strictly less than r, the order of the generator of the\n\
    \   agreed-upon cryptographic group.  The binary representation of each\n   scalar\
    \ MUST have a bit length equal to the bit length of the binary\n   representation\
    \ of r.  This requirement is enforced, if necessary, by\n   prepending the binary\
    \ representation of the integer with zeros until\n   the required length is achieved.\n"
- title: 4.  Fragmentation
  contents:
  - "4.  Fragmentation\n   EAP [RFC3748] is a request-response protocol.  The server\
    \ sends\n   requests and the peer responds.  These request and response messages\n\
    \   are assumed to be limited to at most 1020 bytes.  Messages in EAP-pwd\n  \
    \ can be larger than 1020 bytes and therefore require support for\n   fragmentation\
    \ and reassembly.\n   Implementations MUST establish a fragmentation threshold\
    \ that\n   indicates the maximum size of an EAP-pwd payload.  When an\n   implementation\
    \ knows the maximum transmission unit (MTU) of its lower\n   layer, it SHOULD\
    \ calculate the fragmentation threshold from that\n   value.  In lieu of knowledge\
    \ of the lower layer's MTU, the\n   fragmentation threshold MUST be set to 1020\
    \ bytes.\n   Since EAP is a simple ACK-NAK protocol, fragmentation support can\
    \ be\n   added in a simple manner.  In EAP, fragments that are lost or damaged\n\
    \   in transit will be retransmitted, and since sequencing information is\n  \
    \ provided by the Identifier field in EAP, there is no need for a\n   fragment\
    \ offset field as is provided in IPv4.\n   EAP-pwd fragmentation support is provided\
    \ through the addition of\n   flags within the EAP-Response and EAP-Request packets,\
    \ as well as a\n   Total-Length field of two octets.  Flags include the Length\
    \ included\n   (L) and More fragments (M) bits.  The L flag is set to indicate\
    \ the\n   presence of the two-octet Total-Length field, and MUST be set for the\n\
    \   first fragment of a fragmented EAP-pwd message or set of messages.\n   The\
    \ M flag is set on all but the last fragment.  The Total-Length\n   field is two\
    \ octets, and provides the total length of the EAP-pwd\n   message or set of messages\
    \ that is being fragmented; this simplifies\n   buffer allocation.\n   When an\
    \ EAP-pwd peer receives an EAP-Request packet with the M bit\n   set, it MUST\
    \ respond with an EAP-Response with EAP-Type=EAP-pwd and\n   no data.  This serves\
    \ as a fragment ACK.  The EAP server MUST wait\n   until it receives the EAP-Response\
    \ before sending another fragment.\n   In order to prevent errors in processing\
    \ of fragments, the EAP server\n   MUST increment the Identifier field for each\
    \ fragment contained\n   within an EAP-Request, and the peer MUST include this\
    \ Identifier\n   value in the fragment ACK contained within the EAP-Response.\n\
    \   Retransmitted fragments will contain the same Identifier value.\n   Similarly,\
    \ when the EAP server receives an EAP-Response with the M\n   bit set, it MUST\
    \ respond with an EAP-Request with EAP-Type=EAP-pwd\n   and no data.  This serves\
    \ as a fragment ACK.  The EAP peer MUST wait\n   until it receives the EAP-Request\
    \ before sending another fragment.\n   In order to prevent errors in the processing\
    \ of fragments, the EAP\n   server MUST increment the Identifier value for each\
    \ fragment ACK\n   contained within an EAP-Request, and the peer MUST include\
    \ this\n   Identifier value in the subsequent fragment contained within an EAP-\n\
    \   Response.\n"
- title: 5.  IANA Considerations
  contents:
  - "5.  IANA Considerations\n   This memo contains new numberspaces to be managed\
    \ by IANA.  The\n   policies used to allocate numbers are described in [RFC5226].\
    \  IANA\n   has allocated a new EAP method type for EAP-pwd (52).\n   IANA has\
    \ created new registries for PWD-Exch messages, random\n   functions, PRFs, and\
    \ password pre-processing methods and has added\n   the message numbers, random\
    \ function, PRF, and pre-processing methods\n   specified in this memo to those\
    \ registries, respectively.\n   The following is the initial PWD-Exch message\
    \ registry layout:\n   o   0x00 : Reserved\n   o   0x01 : EAP-pwd-ID exchange\n\
    \   o   0x02 : EAP-pwd-Commit exchange\n   o   0x03 : EAP-pwd-Confirm exchange\n\
    \   The PWD-Exch field is 6 bits long.  The value 0x00 is reserved.  All\n   other\
    \ values are available through assignment by IANA.  IANA is\n   instructed to\
    \ assign values based on \"IETF Review\" (see [RFC5226]).\n   The following is\
    \ the initial Random Function registry layout:\n   o   0x00 : Private Use\n  \
    \ o   0x01 : Function defined in this memo, Section 2.4\n   The Random Function\
    \ field is 8 bits long.  The value 0x00 is for\n   Private Use between mutually\
    \ consenting parties.  All other values\n   are available through assignment by\
    \ IANA.  IANA is instructed to\n   assign values based on \"Specification Required\"\
    \ (see [RFC5226]).  The\n   Designated Expert performing the necessary review\
    \ MUST ensure the\n   random function has been cryptographically vetted.\n   The\
    \ following is the initial PRF registry layout:\n   o   0x00 : Private Use\n \
    \  o   0x01 : HMAC-SHA256 as defined in [RFC4634]\n   The PRF field is 8 bits\
    \ long.  The value 0x00 is for Private Use\n   between mutually consenting parties.\
    \  All other values are available\n   through assignment by IANA.  IANA is instructed\
    \ to assign values\n   based on \"IETF Review\" (see [RFC5226]).\n   The following\
    \ is the initial layout for the password pre-processing\n   method registry:\n\
    \   o   0x00 : None\n   o   0x01 : RFC2759\n   o   0x02 : SASLprep\n   The Prep\
    \ field is 8 bits long, and all other values are available\n   through assignment\
    \ by IANA.  IANA is instructed to assign values\n   based on \"Specification Required\"\
    \ (see [RFC5226]).\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   In Section 1.3, several security properties were\
    \ presented that\n   motivated the design of this protocol.  This section will\
    \ address how\n   well they are met.\n"
- title: 6.1.  Resistance to Passive Attack
  contents:
  - "6.1.  Resistance to Passive Attack\n   A passive attacker will see Scalar_P,\
    \ Element_P, Scalar_S, and\n   Element_S.  She can guess at passwords to compute\
    \ the password\n   element but will not know s_rand or p_rand and therefore will\
    \ not be\n   able to compute MK.\n   The secret random value of the peer (server)\
    \ is effectively hidden by\n   adding p_mask (s_mask) to p_rand (s_rand) modulo\
    \ the order of the\n   group.  If the order is \"r\", then there are approximately\
    \ \"r\"\n   distinct pairs of numbers that will sum to the value Scalar_P\n  \
    \ (Scalar_S).  Attempting to guess the particular pair is just as\n   difficult\
    \ as guessing the secret random value p_rand (s_rand), the\n   probability of\
    \ a guess is 1/(r - i) after \"i\" guesses.  For a large\n   value of r, this\
    \ exhaustive search technique is computationally\n   infeasible.  An attacker\
    \ would do better by determining the discrete\n   logarithm of Element_P (Element_S)\
    \ using an algorithm like the baby-\n   step giant-step algorithm (see [APPCRY]),\
    \ which runs on the order of\n   the square root of r group operations (e.g.,\
    \ a group with order 2^160\n   would require 2^80 exponentiations or point multiplications).\
    \  Based\n   on the assumptions made on the finite cyclic group in Section 2.3,\n\
    \   that is also computationally infeasible.\n"
- title: 6.2.  Resistance to Active Attack
  contents:
  - "6.2.  Resistance to Active Attack\n   An active attacker can launch her attack\
    \ after an honest server has\n   sent EAP-pwd-Commit/Request to an honest peer.\
    \  This would result in\n   the peer sending EAP-pwd-Commit/Response.  In this\
    \ case, the active\n   attack has been reduced to that of a passive attacker since\
    \ p_rand\n   and s_rand will remain unknown.  The active attacker could forge\
    \ a\n   value of Confirm_P (Confirm_S) and send it to the EAP server (EAP\n  \
    \ peer) in the hope that it will be accepted, but due to the\n   assumptions on\
    \ H made in Section 2.3, that is computationally\n   infeasible.\n   The active\
    \ attacker can launch her attack by forging EAP-pwd-Commit/\n   Request and sending\
    \ it to the peer.  This will result in the peer\n   responding with EAP-pwd-Commit/Response.\
    \  The attacker can then\n   attempt to compute ks, but since she doesn't know\
    \ the password, this\n   is infeasible.  It can be shown that an attack by forging\
    \ an EAP-pwd-\n   Commit/Response is an identical attack with equal infeasibility.\n"
- title: 6.3.  Resistance to Dictionary Attack
  contents:
  - "6.3.  Resistance to Dictionary Attack\n   An active attacker can wait until an\
    \ honest server sends EAP-pwd-\n   Commit/Request and then forge EAP-pwd-Commit/Response\
    \ and send it to\n   the server.  The server will respond with EAP-pwd-Confirm/Request.\n\
    \   Now the attacker can attempt to launch a dictionary attack.  She can\n   guess\
    \ at potential passwords, compute the password element, and\n   compute kp using\
    \ her p_rand, Scalar_S, and Element_S from the EAP-\n   pwd-Commit/Request and\
    \ the candidate password element from her guess.\n   She will know if her guess\
    \ is correct when she is able to verify\n   Confirm_S in EAP-pwd-Confirm/Request.\n\
    \   But the attacker committed to a password guess with her forged EAP-\n   pwd-Commit/Response\
    \ when she computed Element_P.  That value was used\n   by the server in his computation\
    \ of ks that was used when he\n   constructed Confirm_S in EAP-pwd-Confirm/Request.\
    \  Any guess of the\n   password that differs from the one used in the forged\
    \ EAP-pwd-Commit/\n   Response could not be verified as correct since the attacker\
    \ has no\n   way of knowing whether it is correct.  She is able to make one guess\n\
    \   and one guess only per attack.  This means that any advantage she can\n  \
    \ gain -- guess a password, if it fails exclude it from the pool of\n   possible\
    \ passwords and try again -- is solely through interaction\n   with an honest\
    \ protocol peer.\n   The attacker can commit to the guess with the forged EAP-pwd-Commit/\n\
    \   Response and then run through the dictionary, computing the password\n   element\
    \ and ks using her forged Scalar_P and Element_P.  She will\n   know she is correct\
    \ if she can compute the same value for Confirm_S\n   that the server produced\
    \ in EAP-pwd-Confirm/Request.  But this\n   requires the attacker to know s_rand,\
    \ which we noted above was not\n   possible.\n   The password element PWE/pwe\
    \ is chosen using a method described in\n   Section 2.8.3.  Since this is an element\
    \ in the group, there exists a\n   scalar value, q, such that:\n       PWE = q\
    \ * G, for an ECC group\n       pwe = g^q mod p, for an FFC group\n   Knowledge\
    \ of q can be used to launch a dictionary attack.  For the\n   sake of brevity,\
    \ the attack will be demonstrated assuming an ECC\n   group.  The attack works\
    \ thusly:\n   The attacker waits until an honest server sends an EAP-pwd-Commit/\n\
    \   Request.  The attacker then generates a random Scalar_P and a random\n   p_mask\
    \ and computes Element_P = p_mask * G.  The attacker sends the\n   bogus Scalar_P\
    \ and Element_P to the server and obtains Confirm_S in\n   return.  Note that\
    \ the server is unable to detect that Element_P was\n   calculated incorrectly.\n\
    \   The attacker now knows that:\n       KS = (Scalar_P * q + p_mask) * s_rand\
    \ * G\n   and\n       s_rand * G = Scalar_P * G - ((1/q) mod r * -Element_P)\n\
    \   Since Scalar_P, p_mask, G, and Element_P are all known, the attacker\n   can\
    \ run through the dictionary, make a password guess, compute PWE\n   using the\
    \ technique in Section 2.8.3, determine q, and then use the\n   equations above\
    \ to compute KS and see if it can verify Confirm_S. But\n   to determine q for\
    \ a candidate PWE, the attacker needs to perform a\n   discrete logarithm that\
    \ was assumed to be computationally infeasible\n   in Section 2.3.  Therefore,\
    \ this attack is also infeasible.\n   The best advantage an attacker can gain\
    \ in a single active attack is\n   to determine whether a single guess at the\
    \ password was correct.\n   Therefore, her advantage is solely through interaction\
    \ and not\n   computation, which is the definition for resistance to dictionary\n\
    \   attack.\n   Resistance to dictionary attack means that the attacker must launch\n\
    \   an active attack to make a single guess at the password.  If the size\n  \
    \ of the dictionary from which the password was extracted was D, and\n   each\
    \ password in the dictionary has an equal probability of being\n   chosen, then\
    \ the probability of success after a single guess is 1/D.\n   After X guesses,\
    \ and removal of failed guesses from the pool of\n   possible passwords, the probability\
    \ becomes 1/(D-X).  As X grows, so\n   does the probability of success.  Therefore,\
    \ it is possible for an\n   attacker to determine the password through repeated\
    \ brute-force,\n   active, guessing attacks.  This protocol does not presume to\
    \ be\n   secure against this, and implementations SHOULD ensure the size of D\n\
    \   is sufficiently large to prevent this attack.  Implementations SHOULD\n  \
    \ also take countermeasures -- for instance, refusing authentication\n   attempts\
    \ for a certain amount of time, after the number of failed\n   authentication\
    \ attempts reaches a certain threshold.  No such\n   threshold or amount of time\
    \ is recommended in this memo.\n"
- title: 6.4.  Forward Secrecy
  contents:
  - "6.4.  Forward Secrecy\n   The MSK and EMSK are extracted from MK, which is derived\
    \ from doing\n   group operations with s_rand, p_rand, and the password element.\
    \  The\n   peer and server choose random values with each run of the protocol.\n\
    \   So even if an attacker is able to learn the password, she will not\n   know\
    \ the random values used by either the peer or server from an\n   earlier run\
    \ and will therefore be unable to determine MK, or the MSK\n   or EMSK.  This\
    \ is the definition of Forward Secrecy.\n"
- title: 6.5.  Group Strength
  contents:
  - "6.5.  Group Strength\n   The strength of the shared secret, MK, derived in Section\
    \ 2.8.4\n   depends on the effort needed to solve the discrete logarithm problem\n\
    \   in the chosen group.  [RFC3766] has a good discussion on the strength\n  \
    \ estimates of symmetric keys derived from discrete logarithm\n   cryptography.\n\
    \   The mandatory-to-implement group defined in this memo is group 19, a\n   group\
    \ from [RFC5114] based on Elliptic Curve Cryptography (see\n   Section 2.2.2)\
    \ with a prime bit length of 256.  This group was chosen\n   because the current\
    \ best estimate of a symmetric key derived using\n   this group is 128 bits, which\
    \ is the typical length of a key for the\n   Advanced Encryption Standard ([FIPS-197]).\
    \  While it is possible to\n   obtain a equivalent measure of strength using a\
    \ group based on Finite\n   Field Cryptography (see Section 2.2.1), it would require\
    \ a much\n   larger prime and be more memory and compute intensive.\n"
- title: 6.6.  Random Functions
  contents:
  - "6.6.  Random Functions\n   The protocol described in this memo uses a function\
    \ referred to as a\n   \"random oracle\" (as defined in [RANDOR]).  A significant\
    \ amount of\n   care must be taken to instantiate a random oracle out of handy\n\
    \   cryptographic primitives.  The random oracle used here is based on\n   the\
    \ notion of a \"Randomness Extractor\" from [RFC5869].\n   This protocol can use\
    \ any properly instantiated random oracle.  To\n   ensure that any new value for\
    \ H will use a properly instantiated\n   random oracle, IANA has been instructed\
    \ (in Section 5) to only\n   allocate values from the Random Function registry\
    \ after being vetted\n   by an expert.\n   A few of the defined groups that can\
    \ be used with this protocol have\n   a security estimate (see Section 6.5) less\
    \ than 128 bits, many do not\n   though, and to prevent the random function from\
    \ being the gating\n   factor (or a target for attack), any new random function\
    \ MUST map its\n   input to a target of at least 128 bits and SHOULD map its input\
    \ to a\n   target of at least 256 bits.\n"
- title: 7.  Security Claims
  contents:
  - "7.  Security Claims\n   [RFC3748] requires that documents describing new EAP\
    \ methods clearly\n   articulate the security properties of the method.  In addition,\
    \ for\n   use with wireless LANs, [RFC4017] mandates and recommends several of\n\
    \   these.  The claims are:\n   a.  mechanism: password.\n   b.  claims:\n   \
    \    *   mutual authentication: the peer and server both authenticate\n      \
    \     each other by proving possession of a shared password.  This\n         \
    \  is REQUIRED by [RFC4017].\n       *   forward secrecy: compromise of the password\
    \ does not reveal\n           the secret keys -- MK, MSK, or EMSK -- from earlier\
    \ runs of\n           the protocol.\n       *   replay protection: an attacker\
    \ is unable to replay messages\n           from a previous exchange to either\
    \ learn the password or a\n           key derived by the exchange.  Similarly\
    \ the attacker is\n           unable to induce either the peer or server to believe\
    \ the\n           exchange has successfully completed when it hasn't.\n      \
    \     Reflection attacks are foiled because the server ensures that\n        \
    \   the scalar and element supplied by the peer do not equal its\n           own.\n\
    \       *   key derivation: keys are derived by performing a group\n         \
    \  operation in a finite cyclic group (e.g., exponentiation)\n           using\
    \ secret data contributed by both the peer and server.\n           An MSK and\
    \ EMSK are derived from that shared secret.  This is\n           REQUIRED by [RFC4017]\n\
    \       *   dictionary attack resistance: this protocol is resistant to\n    \
    \       dictionary attack because an attacker can only make one\n           password\
    \ guess per active attack.  The advantage gained by an\n           attacker is\
    \ through interaction not through computation.\n           This is REQUIRED by\
    \ [RFC4017].\n       *   session independence: this protocol is resistant to active\n\
    \           and passive attack and does not enable compromise of\n           subsequent\
    \ or prior MSKs or EMSKs from either passive or\n           active attack.\n \
    \      *   Denial-of-Service Resistance: it is possible for an attacker\n    \
    \       to cause a server to allocate state and consume CPU cycles\n         \
    \  generating Scalar_S and Element_S. Such an attack is gated,\n           though,\
    \ by the requirement that the attacker first obtain\n           connectivity through\
    \ a lower-layer protocol (e.g. 802.11\n           authentication followed by 802.11\
    \ association, or 802.3\n           \"link-up\") and respond to two EAP messages\
    \ --the EAP-ID/\n           Request and the EAP-pwd-ID/Request.  The EAP-pwd-ID\
    \ exchange\n           further includes an anti-clogging token that provides a\
    \ level\n           of assurance to the server that the peer is, at least,\n \
    \          performing a rudimentary amount of processing and not merely\n    \
    \       spraying packets.  This prevents distributed denial-of-\n           service\
    \ attacks and also requires the attacker to announce,\n           and commit to,\
    \ a lower-layer identity, such as a MAC (Media\n           Access Control) address.\n\
    \       *   Man-in-the-Middle Attack Resistance: this exchange is\n          \
    \ resistant to active attack, which is a requirement for\n           launching\
    \ a man-in-the-middle attack.  This is REQUIRED by\n           [RFC4017].\n  \
    \     *   shared state equivalence: upon completion of EAP-pwd, the\n        \
    \   peer and server both agree on MK, MSK, EMSK, Method-ID, and\n           Session-ID.\
    \  The peer has authenticated the server based on\n           the Server-ID, and\
    \ the server has authenticated the peer\n           based on the Peer-ID.  This\
    \ is due to the fact that Peer-ID,\n           Server-ID, and the shared password\
    \ are all combined to make\n           the password element, which must be shared\
    \ between the peer\n           and server for the exchange to complete.  This\
    \ is REQUIRED by\n           [RFC4017].\n       *   fragmentation: this protocol\
    \ defines a technique for\n           fragmentation and reassembly in Section\
    \ 4.\n       *   resistance to \"Denning-Sacco\" attack: learning keys\n     \
    \      distributed from an earlier run of the protocol, such as the\n        \
    \   MSK or EMSK, will not help an adversary learn the password.\n   c.  key strength:\
    \ the strength of the resulting key depends on the\n       finite cyclic group\
    \ chosen.  See Section 6.5.  This is REQUIRED\n       by [RFC4017].\n   d.  key\
    \ hierarchy: MSKs and EMSKs are derived from the MK using the\n       KDF defined\
    \ in Section 2.5 as described in Section 2.8.4.\n   e.  vulnerabilities (note\
    \ that none of these are REQUIRED by\n       [RFC4017]):\n       *   protected\
    \ ciphersuite negotiation: the ciphersuite offer made\n           by the server\
    \ is not protected from tampering by an active\n           attacker.  Downgrade\
    \ attacks are prevented, though, since\n           this is not a \"negotiation\"\
    \ with a list of acceptable\n           ciphersuites.  If a Ciphersuite was modified\
    \ by an active\n           attacker it would result in a failure to confirm the\
    \ message\n           sent by the other party, since the Ciphersuite is bound\
    \ by\n           each side into its confirm message, and the protocol would\n\
    \           fail as a result.\n       *   confidentiality: none of the messages\
    \ sent in this protocol\n           are encrypted.\n       *   integrity protection:\
    \ messages in the EAP-pwd-Commit exchange\n           are not integrity protected.\n\
    \       *   channel binding: this protocol does not enable the exchange\n    \
    \       of integrity-protected channel information that can be\n           compared\
    \ with values communicated via out-of-band mechanisms.\n       *   fast reconnect:\
    \ this protocol does not provide a fast-\n           reconnect capability.\n \
    \      *   cryptographic binding: this protocol is not a tunneled EAP\n      \
    \     method and therefore has no cryptographic information to\n           bind.\n\
    \       *   identity protection: the EAP-pwd-ID exchange is not\n           protected.\
    \  An attacker will see the server's identity in the\n           EAP-pwd-ID/Request\
    \ and see the peer's identity in EAP-pwd-ID/\n           Response.\n"
- title: 8.  Acknowledgements
  contents:
  - "8.  Acknowledgements\n   The authors would like to thank Scott Fluhrer for discovering\
    \ the\n   \"password as exponent\" attack that was possible in the initial\n \
    \  version of this memo and for his very helpful suggestions on the\n   techniques\
    \ for fixing the PWE/pwe to prevent it.  The authors would\n   also like to thank\
    \ Hideyuki Suzuki for his insight in discovering an\n   attack against a previous\
    \ version of the underlying key exchange\n   protocol.  Special thanks to Lily\
    \ Chen for helpful discussions on\n   hashing into an elliptic curve and to Jin-Meng\
    \ Ho for suggesting the\n   countermeasures to protect against a small sub-group\
    \ attack.  Rich\n   Davis suggested the defensive checks to Commit messages, and\
    \ his\n   various comments greatly improved the quality of this memo and the\n\
    \   underlying key exchange on which it is based.  Scott Kelly suggested\n   adding\
    \ the anti-clogging token to the ID exchange to prevent\n   distributed denial-of-service\
    \ attacks.  Dorothy Stanley provided\n   valuable suggestions to improve the quality\
    \ of this memo.  The\n   fragmentation method used was taken from [RFC5216].\n"
- title: 9.  References
  contents:
  - '9.  References

    '
- title: 9.1.  Normative References
  contents:
  - "9.1.  Normative References\n   [RFC2119]    Bradner, S., \"Key words for use\
    \ in RFCs to Indicate\n                Requirement Levels\", BCP 14, RFC 2119,\
    \ March 1997.\n   [RFC2759]    Zorn, G., \"Microsoft PPP CHAP Extensions, Version\
    \ 2\",\n                RFC 2759, January 2000.\n   [RFC3454]    Hoffman, P. and\
    \ M. Blanchet, \"Preparation of\n                Internationalized Strings (\"\
    stringprep\")\", RFC 3454,\n                December 2002.\n   [RFC3748]    Aboba,\
    \ B., Blunk, L., Vollbrecht, J., Carlson, J., and\n                H. Levkowetz,\
    \ \"Extensible Authentication Protocol\n                (EAP)\", RFC 3748, June\
    \ 2004.\n   [RFC4013]    Zeilenga, K., \"SASLprep: Stringprep Profile for User\n\
    \                Names and Passwords\", RFC 4013, February 2005.\n   [RFC4282]\
    \    Aboba, B., Beadles, M., Arkko, J., and P. Eronen, \"The\n               \
    \ Network Access Identifier\", RFC 4282, December 2005.\n   [RFC4634]    Eastlake,\
    \ D. and T. Hansen, \"US Secure Hash Algorithms\n                (SHA and HMAC-SHA)\"\
    , RFC 4634, July 2006.\n   [RFC5226]    Narten, T. and H. Alvestrand, \"Guidelines\
    \ for Writing an\n                IANA Considerations Section in RFCs\", BCP 26,\
    \ RFC 5226,\n                May 2008.\n   [SP800-108]  Chen, L., \"Recommendations\
    \ for Key Derivation Using\n                Pseudorandom Functions\", NIST Special\n\
    \                Publication 800-108, April 2008.\n   [SP800-56A]  Barker, E.,\
    \ Johnson, D., and M. Smid, \"Recommendations\n                for Pair-Wise Key\
    \ Establishment Schemes Using Discrete\n                Logarithm Cryptography\"\
    , NIST Special\n                Publication 800-56A, March 2007.\n"
- title: 9.2.  Informative References
  contents:
  - "9.2.  Informative References\n   [APPCRY]     Menezes, A., van Oorshot, P., and\
    \ S. Vanstone, \"Handbook\n                of Applied Cryptography\", CRC Press\
    \ Series on Discrete\n                Mathematics and Its Applications, 1996.\n\
    \   [BM92]       Bellovin, S. and M. Merritt, \"Encrypted Key Exchange:\n    \
    \            Password-Based Protocols Secure Against Dictionary\n            \
    \    Attack\", Proceedings of the IEEE Symposium on Security\n               \
    \ and Privacy, Oakland, 1992.\n   [BM93]       Bellovin, S. and M. Merritt, \"\
    Augmented Encrypted Key\n                Exchange: A Password-Based Protocol Secure\
    \ against\n                Dictionary Attacks and Password File Compromise\",\n\
    \                Proceedings of the 1st ACM Conference on Computer and\n     \
    \           Communication Security, ACM Press, 1993.\n   [BMP00]      Boyko, V.,\
    \ MacKenzie, P., and S. Patel, \"Provably Secure\n                Password Authenticated\
    \ Key Exchange Using Diffie-\n                Hellman\", Proceedings of Eurocrypt\
    \ 2000, LNCS\n                1807 Springer-Verlag, 2000.\n   [FIPS-197]   National\
    \ Institute of Standards and Technology, FIPS Pub\n                197: Advanced\
    \ Encryption Standard (AES), November 2001.\n   [JAB96]      Jablon, D., \"Strong\
    \ Password-Only Authenticated Key\n                Exchange\", ACM SIGCOMM Computer\
    \ Communication\n                Review Volume 1, Issue 5, October 1996.\n   [LUC97]\
    \      Lucks, S., \"Open Key Exchange: How to Defeat Dictionary\n            \
    \    Attacks Without Encrypting Public Keys\", Proceedings of\n              \
    \  the Security Protocols Workshop, LNCS 1361, Springer-\n                Verlag,\
    \ 1997.\n   [RANDOR]     Bellare, M. and P. Rogaway, \"Random Oracles are\n  \
    \              Practical: A Paradigm for Designing Efficient\n               \
    \ Protocols\", Proceedings of the 1st ACM Conference on\n                Computer\
    \ and Communication Security, ACM Press, 1993.\n   [RFC2409]    Harkins, D. and\
    \ D. Carrel, \"The Internet Key Exchange\n                (IKE)\", RFC 2409, November\
    \ 1998.\n   [RFC3766]    Orman, H. and P. Hoffman, \"Determining Strengths For\n\
    \                Public Keys Used For Exchanging Symmetric Keys\", BCP 86,\n \
    \               RFC 3766, April 2004.\n   [RFC4017]    Stanley, D., Walker, J.,\
    \ and B. Aboba, \"Extensible\n                Authentication Protocol (EAP) Method\
    \ Requirements for\n                Wireless LANs\", RFC 4017, March 2005.\n \
    \  [RFC4086]    Eastlake, D., Schiller, J., and S. Crocker, \"Randomness\n   \
    \             Requirements for Security\", BCP 106, RFC 4086,\n              \
    \  June 2005.\n   [RFC4962]    Housley, R. and B. Aboba, \"Guidance for Authentication,\n\
    \                Authorization, and Accounting (AAA) Key Management\",\n     \
    \           BCP 132, RFC 4962, July 2007.\n   [RFC5114]    Lepinski, M. and S.\
    \ Kent, \"Additional Diffie-Hellman\n                Groups for Use with IETF\
    \ Standards\", RFC 5114,\n                January 2008.\n   [RFC5216]    Simon,\
    \ D., Aboba, B., and R. Hurst, \"The EAP-TLS\n                Authentication Protocol\"\
    , RFC 5216, March 2008.\n   [RFC5247]    Aboba, B., Simon, D., and P. Eronen,\
    \ \"Extensible\n                Authentication Protocol (EAP) Key Management Framework\"\
    ,\n                RFC 5247, August 2008.\n   [RFC5869]    Krawczyk, H. and P.\
    \ Eronen, \"HMAC-based Extract-and-\n                Expand Key Derivation Function\
    \ (HKDF)\", RFC 5869,\n                May 2010.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Dan Harkins\n   Aruba Networks\n   1322 Crossman Avenue\n\
    \   Sunnyvale, CA  94089-1113\n   USA\n   EMail: dharkins@arubanetworks.com\n\
    \   Glen Zorn\n   Network Zen\n   1310 East Thomas Street\n   #306\n   Seattle,\
    \ WA  98102\n   USA\n   Phone: +1 (206) 377-9035\n   EMail: gwz@net-zen.net\n"
