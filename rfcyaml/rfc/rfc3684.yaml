- title: __initial_text__
  contents:
  - '    Topology Dissemination Based on Reverse-Path Forwarding (TBRPF)

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo defines an Experimental Protocol for the Internet\n\
    \   community.  It does not specify an Internet standard of any kind.\n   Discussion\
    \ and suggestions for improvement are requested.\n   Distribution of this memo\
    \ is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2004).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   Topology Dissemination Based on Reverse-Path Forwarding (TBRPF)\
    \ is a\n   proactive, link-state routing protocol designed for mobile ad-hoc\n\
    \   networks, which provides hop-by-hop routing along shortest paths to\n   each\
    \ destination.  Each node running TBRPF computes a source tree\n   (providing\
    \ paths to all reachable nodes) based on partial topology\n   information stored\
    \ in its topology table, using a modification of\n   Dijkstra's algorithm.  To\
    \ minimize overhead, each node reports only\n   *part* of its source tree to neighbors.\
    \  TBRPF uses a combination of\n   periodic and differential updates to keep all\
    \ neighbors informed of\n   the reported part of its source tree.  Each node also\
    \ has the option\n   to report additional topology information (up to the full\
    \ topology),\n   to provide improved robustness in highly mobile networks.  TBRPF\n\
    \   performs neighbor discovery using \"differential\" HELLO messages which\n\
    \   report only *changes* in the status of neighbors.  This results in\n   HELLO\
    \ messages that are much smaller than those of other link-state\n   routing protocols\
    \ such as OSPF.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction. . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   3\n   2.  Requirements. . . . . . . . . . . . . . . . . . . . .\
    \ . . . .   4\n   3.  Terminology . . . . . . . . . . . . . . . . . . . . . .\
    \ . . .   4\n   4.  Applicability Section . . . . . . . . . . . . . . . . . .\
    \ . .   5\n   5.  TBRPF Overview. . . . . . . . . . . . . . . . . . . . . . .\
    \ .   6\n       5.1.   Overview of Neighbor Discovery . . . . . . . . . . . .\
    \   6\n       5.2.   Overview of the Routing Module. .. . . . . . . . . . .  \
    \ 8\n   6.  TBRPF Packets . . . . . . . . . . . . . . . . . . . . . . . .  10\n\
    \       6.1.   TBRPF Packet Header. . . . . . . . . . . . . . . . . .  10\n  \
    \     6.2.   TBRPF Packet Body. . . . . . . . . . . . . . . . . . .  11\n    \
    \          6.2.1.  Padding Options (TYPE = 0 thru 1). . . . . . .  12\n      \
    \        6.2.2.  Messages (TYPE = 2 thru 10). . . . . . . . . .  13\n   7.  TBRPF\
    \ Neighbor Discovery. . . . . . . . . . . . . . . . . . .  13\n       7.1.   HELLO\
    \ Message Format . . . . . . . . . . . . . . . . .  13\n       7.2.   Neighbor\
    \ Table . . . . . . . . . . . . . . . . . . . .  14\n       7.3.   Sending HELLO\
    \ Messages . . . . . . . . . . . . . . . .  15\n       7.4.   Processing a Received\
    \ HELLO Message. . . . . . . . . .  16\n       7.5.   Expiration of Timer nbr_life\
    \ . . . . . . . . . . . . .  18\n       7.6.   Link-Layer Failure Notification.\
    \ . . . . . . . . . . .  18\n       7.7.   Optional Link Metrics. . . . . . .\
    \ . . . . . . . . . .  18\n       7.8.   Configurable Parameters. . . . . . .\
    \ . . . . . . . . .  19\n   8.  TBRPF Routing Module. . . . . . . . . . . . .\
    \ . . . . . . . .  19\n       8.1.   Conceptual Data Structures . . . . . . .\
    \ . . . . . . .  19\n       8.2.   TOPOLOGY UPDATE Message Format . . . . . .\
    \ . . . . . .  21\n       8.3.   Interface, Host, and Network Prefix Association\n\
    \              Message Formats. . . . . . . . . . . . . . . . . . . .  23\n  \
    \     8.4.   TBRPF Routing Operation. . . . . . . . . . . . . . . .  24\n    \
    \          8.4.1.  Periodic Processing. . . . . . . . . . . . . .  24\n      \
    \        8.4.2.  Updating the Source Tree and Topology\n                     \
    \ Graph. . . . . . . . . . . . . . . . . . . . .  25\n              8.4.3.  Updating\
    \ the Routing Table . . . . . . . . . .  26\n              8.4.4.  Updating the\
    \ Reported Node Set . . . . . . . .  27\n              8.4.5.  Generating Periodic\
    \ Updates. . . . . . . . . .  29\n              8.4.6.  Generating Differential\
    \ Updates. . . . . . . .  29\n              8.4.7.  Processing Topology Updates.\
    \ . . . . . . . . .  30\n              8.4.8.  Expiring Topology Information.\
    \ . . . . . . . .  32\n              8.4.9.  Optional Reporting of Redundant Topology\n\
    \                      Information. . . . . . . . . . . . . . . . . .  32\n  \
    \            8.4.10. Local Topology Changes . . . . . . . . . . . .  33\n    \
    \          8.4.11. Generating Association Messages. . . . . . . .  34\n      \
    \        8.4.12. Processing Association Messages. . . . . . . .  36\n        \
    \      8.4.13. Non-Relay Operation. . . . . . . . . . . . . .  37\n       8.5.\
    \   Configurable Parameters. . . . . . . . . . . . . . . .  38\n   9.  TBRPF Flooding\
    \ Mechanism. . . . . . . . . . . . . . . . . . .  38\n   10. Operation of TBRPF\
    \ in Mobile Ad-Hoc Networks. . . . . . . . .  39\n       10.1.  Data Link Layer\
    \ Assumptions. . . . . . . . . . . . . .  39\n       10.2.  Network Layer Assumptions.\
    \ . . . . . . . . . . . . . .  39\n       10.3.  Optional Automatic Address Resolution.\
    \ . . . . . . . .  40\n       10.4.  Support for Multiple Interfaces and/or\n\
    \              Alias Addresses. . . . . . . . . . . . . . . . . . . .  40\n  \
    \     10.5.  Support for Network Prefixes . . . . . . . . . . . . .  40\n    \
    \   10.6.  Support for non-MANET Hosts. . . . . . . . . . . . . .  40\n      \
    \ 10.7.  Internet Protocol Considerations . . . . . . . . . . .  41\n        \
    \      10.7.1. IPv4 Operation . . . . . . . . . . . . . . . .  41\n          \
    \    10.7.2. IPv6 Operation . . . . . . . . . . . . . . . .  41\n   11. IANA Considerations\
    \ . . . . . . . . . . . . . . . . . . . . .  41\n   12. Security Considerations\
    \ . . . . . . . . . . . . . . . . . . .  42\n   13. Acknowledgements. . . . .\
    \ . . . . . . . . . . . . . . . . . .  42\n   14. References. . . . . . . . .\
    \ . . . . . . . . . . . . . . . . .  42\n       14.1.  Normative References .\
    \ . . . . . . . . . . . . . . . .  42\n       14.2.  Informative References .\
    \ . . . . . . . . . . . . . . .  43\n   Authors' Addresses. . . . . . . . . .\
    \ . . . . . . . . . . . . . .  45\n   Full Copyright Statement. . . . . . . .\
    \ . . . . . . . . . . . . .  46\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Topology Dissemination Based on Reverse-Path Forwarding\
    \ (TBRPF) is a\n   proactive, link-state routing protocol designed for mobile\
    \ ad-hoc\n   networks (MANETs), which provides hop-by-hop routing along shortest\n\
    \   paths to each destination.  Each node running TBRPF computes a source\n  \
    \ tree (providing shortest paths to all reachable nodes) based on\n   partial\
    \ topology information stored in its topology table, using a\n   modification\
    \ of Dijkstra's algorithm.  To minimize overhead, each\n   node reports only *part*\
    \ of its source tree to neighbors.\n   TBRPF uses a combination of periodic and\
    \ differential updates to keep\n   all neighbors informed of the reported part\
    \ of its source tree.  Each\n   node also has the option to report addition topology\
    \ information (up\n   to the full topology), to provide improved robustness in\
    \ highly\n   mobile networks.\n   TBRPF performs neighbor discovery using \"differential\"\
    \ HELLO messages\n   which report only *changes* in the status of neighbors. \
    \ This results\n   in HELLO messages that are much smaller than those of other\
    \ link-\n   state routing protocols such as OSPF [6].\n   TBRPF consists of two\
    \ modules: the neighbor discovery module and the\n   routing module (which performs\
    \ topology discovery and route\n   computation).  An overview of these modules\
    \ is given in Section 5.\n"
- title: 2.  Requirements
  contents:
  - "2.  Requirements\n   The keywords \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\", when\n   they appear in this document, are to be interpreted as\
    \ described in\n   BCP 14, RFC 2119 [1].\n   This document also makes use of internal\
    \ conceptual variables to\n   describe protocol behavior and external variables\
    \ that an\n   implementation must allow system administrators to change.  The\n\
    \   specific variable names, how their values change, and how their\n   settings\
    \ influence protocol behavior are provided to demonstrate\n   protocol behavior.\
    \  An implementation is not required to have them in\n   the exact form described\
    \ here, so long as its external behavior is\n   consistent with that described\
    \ in this document.\n"
- title: 3.  Terminology
  contents:
  - "3.  Terminology\n   The following terms are used to describe TBRPF:\n   node\n\
    \      A router that implements TBRPF.\n   router ID\n      Each node is identified\
    \ by a unique 32-bit router ID (RID), which\n      for IPv4 is typically equal\
    \ to the IP address of one of its\n      interfaces.  The term \"node u\" denotes\
    \ the node whose RID is equal\n      to u.\n   interface\n      A node's attachment\
    \ to a communication facility or medium through\n      which it can communicate\
    \ with other nodes.  A node can have\n      multiple interfaces.  An interface\
    \ can be wireless or wired, and\n      can be broadcast (e.g., Ethernet) or point-to-point.\
    \  Each\n      interface is identified by its IP address.  The term \"interface\
    \ I\"\n      denotes the interface whose IP address is I.\n   link\n      A link\
    \ is an ordered pair of interfaces (I,J) where I and J are on\n      two different\
    \ nodes, and where interface I has recently received\n      packets sent from\
    \ interface J.  A link (i,j) from node i to node j\n      is said to exist if\
    \ node i has an interface I and node j has an\n      interface J such that (I,J)\
    \ is a link.  Nodes i and j are called\n      the \"tail\" and \"head\" of the\
    \ link, respectively.\n   bidirectional link\n      A link (I,J) such that interfaces\
    \ I and J can both hear each\n      other.  Also called a 2-way link.\n   neighbor\
    \ node\n      A node j is said to be a neighbor of node i if node i can hear\n\
    \      node j on some interface.  Node j is said to be a 2-way neighbor\n    \
    \  if there is a bidirectional link between i and j.\n   MANET interface\n   \
    \   Any wireless interface such that two neighbor nodes on the\n      interface\
    \ need not be neighbors of each other.  MANET nodes\n      typically have at least\
    \ one MANET interface, but this is not a\n      requirement.\n   topology\n  \
    \    The topology of the network is described by a graph G = (V, E),\n      where\
    \ V is the set of nodes u and E is the set of links (u,v) in\n      the network.\n\
    \   source tree\n      The directed tree (denoted T) computed by each node that\
    \ provides\n      shortest paths to all other reachable nodes.\n   topology update\n\
    \      A message that reports the state of one or more links.\n   parent\n   \
    \   The parent of node i for node u is the next node on the computed\n      shortest\
    \ path from node i to node u.\n   predecessor\n      The predecessor of a node\
    \ v on the source tree is the node u such\n      that the link (u,v) is in the\
    \ source tree.\n   leaf node\n      A leaf node of the source tree is a node on\
    \ the source tree that\n      is not the predecessor of any other node on the\
    \ source tree.\n   proactive routing protocol\n      A routing protocol in which\
    \ each node maintains routes to all\n      reachable destinations at all times,\
    \ whether or not there is\n      currently any need to deliver packets to those\
    \ destinations.  In\n      contrast, an \"on-demand\" routing protocol discovers\
    \ and maintains\n      routes only when they are needed.\n"
- title: 4.  Applicability Section
  contents:
  - "4.  Applicability Section\n   TBRPF is a proactive routing protocol designed\
    \ for mobile ad-hoc\n   networks (MANETs).  It can support networks with up to\
    \ a few hundred\n   nodes, and can be combined with hierarchical routing techniques\
    \ to\n   support much larger networks.  Because it employs techniques to\n   greatly\
    \ reduce control traffic, TBRPF can support much larger and\n   denser networks\
    \ than routing protocols based on the classical link-\n   state algorithm (e.g.,\
    \ OSPF).\n   The number of nodes that can be supported depends on several factors,\n\
    \   including the MAC data rate, the rate of topology changes, and the\n   network\
    \ density (average number of neighbors).  Simulations have been\n   reported in\
    \ which TBRPF has supported as many as 500 nodes.  In\n   simulations with 100\
    \ nodes and 20 traffic streams (sources), using\n   IEEE 802.11 with a data rate\
    \ of 2 Mbps, TBRPF was found to generate\n   approximately 80-120 kb/s of routing\
    \ control traffic for the\n   scenarios considered, which compared favorably with\
    \ other MANET\n   routing protocols [7][8].  A proof of correctness for TBRPF\
    \ can be\n   found in references [8] and [9].\n"
- title: 5.  TBRPF Overview
  contents:
  - "5.  TBRPF Overview\n   TBRPF consists of two main modules: the neighbor discovery\
    \ module,\n   and the routing module (which performs topology discovery and route\n\
    \   computation).\n"
- title: 5.1.  Overview of Neighbor Discovery
  contents:
  - "5.1.  Overview of Neighbor Discovery\n   The TBRPF Neighbor Discovery (TND) protocol\
    \ allows each node i to\n   quickly detect the neighbor nodes j such that a bidirectional\
    \ link\n   (I,J) exists between an interface I of node i and an interface J of\n\
    \   node j.  The protocol also quickly detects when a bidirectional link\n   breaks\
    \ or becomes unidirectional.\n   The key feature of TND is that it uses \"differential\"\
    \ HELLO messages\n   which report only *changes* in the status of links.  This\
    \ results in\n   HELLO messages that are much smaller than those of other link-state\n\
    \   routing protocols such as OSPF, in which each HELLO message includes\n   the\
    \ IDs of *all* neighbors.  As a result, HELLO messages can be sent\n   more frequently,\
    \ which allows faster detection of topology changes.\n   TND is designed to be\
    \ fully modular and independent of the routing\n   module.  TND performs ONLY\
    \ neighbor sensing, i.e., it determines\n   which nodes are (1-hop) neighbors.\
    \  In particular, it does not\n   discover 2-hop neighbors (which is handled by\
    \ the routing module).\n   As a result, TND can be used by other routing protocols,\
    \ and TBRPF\n   can use another neighbor discovery protocol in place of TND, e.g.,\n\
    \   one provided by the link layer.\n   Nodes with multiple interfaces run TND\
    \ separately on each interface,\n   similar to OSPF.  Thus, a neighbor table is\
    \ maintained for each local\n   interface, and a HELLO sent on a particular interface\
    \ contains only\n   information regarding neighbors heard on that interface.\n\
    \   We note that, in wireless networks, it is possible for a single\n   interface\
    \ I to receive packets from multiple interfaces J associated\n   with the same\
    \ neighbor node.  This could happen, for example, if the\n   neighbor uses a directional\
    \ antenna with different interfaces\n   representing different beams.  For this\
    \ reason, TBRPF includes\n   neighbor interface addresses in HELLO messages, unlike\
    \ OSPF, which\n   includes only router IDs in HELLO packets.\n   Each TBRPF node\
    \ maintains a neighbor table for each local interface\n   I, which stores state\
    \ information for each neighbor interface J heard\n   on that interface, i.e.,\
    \ for each link (I,J) between interface I and\n   a neighbor interface J.  The\
    \ status of each link can be 1-WAY, 2-WAY,\n   or LOST.  The neighbor table for\
    \ interface I determines the contents\n   of HELLO messages sent on interface\
    \ I, and is updated based on HELLO\n   messages received on interface I (and possibly\
    \ on link-layer\n   notifications).\n   Each TBRPF node sends (on each interface)\
    \ at least one HELLO message\n   per HELLO_INTERVAL.  Each HELLO message contains\
    \ three (possibly\n   empty) lists of neighbor interface addresses (which are\
    \ formatted as\n   three message subtypes): NEIGHBOR REQUEST, NEIGHBOR REPLY,\
    \ and\n   NEIGHBOR LOST.  Each HELLO message also contains the current HELLO\n\
    \   sequence number (HSEQ), which is incremented with each transmitted\n   HELLO.\n\
    \   In the following overview of the operation of TND, we assume that\n   interface\
    \ I belongs to node i, and interface J belongs to node j.\n   When a node i changes\
    \ the status of a link (I,J), it includes the\n   neighbor interface address J\
    \ in the appropriate list (NEIGHBOR\n   REQUEST/REPLY/LOST) in at most NBR_HOLD_COUNT\
    \ (typically 3)\n   consecutive HELLOs sent on interface I.  This ensures that\
    \ node j\n   will either receive one of these HELLOs on interface J, or will miss\n\
    \   NBR_HOLD_COUNT HELLOs and thus declare the link (J,I) to be LOST.\n   This\
    \ technique makes it unnecessary for a node to include each 1-WAY\n   or 2-WAY\
    \ neighbor in HELLOs indefinitely, unlike OSPF.\n   To avoid establishing a link\
    \ that is likely to be short lived (i.e.,\n   to employ hysteresis), node i must\
    \ receive (on interface I) at least\n   HELLO_ACQUIRE_COUNT (e.g., 2) of the last\
    \ HELLO_ACQUIRE_WINDOW (e.g.,\n   3) HELLOs sent from a neighbor interface J,\
    \ before declaring the link\n   (I,J) to be 1-WAY.  When this happens, node i\
    \ includes J in the\n   NEIGHBOR REQUEST list in each of its next NBR_HOLD_COUNT\
    \ HELLO\n   messages sent on interface I, or until a NEIGHBOR REPLY message\n\
    \   containing I is received on interface I from neighbor interface J.\n   If\
    \ node j receives (on interface J) one of the HELLOs sent from\n   interface I\
    \ that contains J in the NEIGHBOR REQUEST list, then node j\n   declares the link\
    \ (J,I) to be 2-WAY (unless it is already 2-WAY), and\n   includes I in the NEIGHBOR\
    \ REPLY list in each of its next\n   NBR_HOLD_COUNT HELLO messages sent on interface\
    \ J.  Upon receiving\n   one of these HELLOs on interface I, node i declares the\
    \ link (I,J) to\n   be 2-WAY.\n   If node i receives a HELLO on interface I, sent\
    \ from neighbor\n   interface J, whose HSEQ indicates that at least NBR_HOLD_COUNT\
    \ HELLOs\n   were missed, or if node i receives no HELLO on interface I sent from\n\
    \   interface J within NBR_HOLD_TIME seconds, then node i changes the\n   status\
    \ of link (I,J) to LOST (unless it is already LOST), and\n   includes J in the\
    \ NEIGHBOR LOST list in each of its next\n   NBR_HOLD_COUNT HELLO messages sent\
    \ on interface I (unless the link\n   changes status before these transmissions\
    \ are complete).  Node j will\n   either receive one of these HELLOs on interface\
    \ J or will miss\n   NBR_HOLD_COUNT HELLOs; in either case, node j will declare\
    \ the link\n   (J,I) to be LOST.  In this manner, both nodes will agree that the\n\
    \   link between I and J is no longer bidirectional, even if node j can\n   still\
    \ hear HELLOs from node i.\n   Each node may maintain and update one or more link\
    \ metrics for each\n   link (I,J) from a local interface I to a neighbor interface\
    \ J,\n   representing the quality of the link.  Such link metrics can be used\n\
    \   as additional conditions for changing the status of a neighbor, based\n  \
    \ on the link metric going above or below some threshold.  TBRPF also\n   allows\
    \ link metrics to be advertised in topology updates, and to be\n   used for computing\
    \ shortest paths.\n"
- title: 5.2.  Overview of the Routing Module
  contents:
  - "5.2.  Overview of the Routing Module\n   Each node running TBRPF maintains a\
    \ source tree, denoted T, which\n   provides shortest paths to all reachable nodes.\
    \  Each node computes\n   and updates its source tree based on partial topology\
    \ information\n   stored in its topology table, using a modification of Dijkstra's\n\
    \   algorithm.  To minimize overhead, each node reports only part of its\n   source\
    \ tree to neighbors.  The main idea behind the current version\n   of TBRPF came\
    \ from PTSP [10], another protocol in which each node\n   reports only part of\
    \ its source tree.  (However, TBRPF differs from\n   PTSP in several ways.)  The\
    \ current version of TBRPF should not be\n   confused with its previous version\
    \ [11], which is a full-topology\n   routing protocol.\n   The part of T that\
    \ a node reports to neighbors is called the\n   \"reported subtree\" and is denoted\
    \ RT.  Each node reports RT to\n   neighbors in *periodic* topology updates (e.g.,\
    \ every 5 seconds), and\n   reports changes (additions and deletions) to RT in\
    \ more frequent\n   *differential* updates (e.g., every 1 second).  Periodic updates\n\
    \   inform new neighbors of RT, and ensure that each neighbor eventually\n   learns\
    \ RT even if it does not receive all updates.  Differential\n   updates ensure\
    \ the fast propagation of each topology update to all\n   nodes that are affected\
    \ by the update.  A received topology update is\n   not forwarded, but *may* result\
    \ in a change to RT, which will be\n   reported in the next differential or periodic\
    \ update.  Whenever\n   possible, topology updates are included in the same packet\
    \ as a HELLO\n   message, to minimize the number of control packets sent.  TBRPF\
    \ does\n   not require reliable or sequenced delivery of messages, and does not\n\
    \   use ACKs or NACKs.\n   TBRPF supports multiple interfaces, associated hosts,\
    \ and network\n   prefixes.  Information regarding associated interfaces, hosts,\
    \ and\n   prefixes is disseminated efficiently in periodic and differential\n\
    \   updates, similar to the dissemination of topology updates.\n   The reported\
    \ subtree RT consists of links (u,v) of T such that u is\n   in the \"reported\
    \ node set\" RN, which is computed as follows.  Node i\n   includes a neighbor\
    \ j in RN if and only if node i determines that one\n   of its neighbors may select\
    \ i to be its next hop on its shortest path\n   to j.  To make this determination,\
    \ node i computes the shortest\n   paths, up to 2 hops, from each neighbor to\
    \ each other neighbor, using\n   only neighbors (or node i itself) as an intermediate\
    \ node, and using\n   relay priority (included in HELLO messages) and router ID\
    \ to break\n   ties.  After a node determines which neighbors are in RN, each\n\
    \   reachable node u is included in RN if and only if the next hop on the\n  \
    \ shortest path to u is in RN.  A node also includes itself in RN.  As\n   a result,\
    \ the reported subtree RT includes the subtrees of T that are\n   rooted at neighbors\
    \ in RN, and also includes all local links to\n   neighbors.\n   We note that\
    \ neighbors in RN are analogous to multipoint relay (MPR)\n   selectors [12].\
    \  Thus, if node i selects neighbor j to be in RN, then\n   node i effectively\
    \ selects itself to be an MPR of node j.  This is\n   quite different from [12],\
    \ in which a node does not select itself to\n   be an MPR, but selects a subset\
    \ of its neighbors to be MPRs.\n   A node with a larger relay priority reports\
    \ a larger part of its\n   source tree (on average), and is more likely to be\
    \ selected as a\n   next-hop relay by its neighbors.  A node with relay priority\
    \ equal to\n   0 is called a non-relay node, and never forwards packets originating\n\
    \   from other nodes.\n   TBRPF does not use sequence numbers for topology updates,\
    \ thus\n   reducing message overhead and avoiding wraparound problems.  Instead,\n\
    \   a technique similar to SPTA [13] is used in which, for each link\n   (u,v)\
    \ reported by one or more neighbors, only the next hop p(u) to u\n   is believed\
    \ regarding the state of the link.  (However, in SPTA each\n   node reports the\
    \ full topology.)  Using this technique, each node\n   maintains a topology graph\
    \ TG, consisting of links that are believed\n   to be up, and computes T as the\
    \ shortest-path tree within TG.  To\n   allow immediate rerouting, the restriction\
    \ that each link (u,v) in TG\n   must be reported by p(u) is relaxed temporarily\
    \ if p(u) changes to a\n   neighbor that is not reporting the link.\n   Each node\
    \ is required to report RT, but may report additional links,\n   e.g., to provide\
    \ increased robustness in highly mobile networks.\n   More precisely, a node may\
    \ maintain any subgraph H of TG that\n   contains T, and report the reported subgraph\
    \ RH, which consists of\n   links (u,v) of H such that u is in RN.  For example,\
    \ H can equal TG,\n   which would provide each node with the full network topology\
    \ if this\n   is done by all nodes.  H can also be a biconnected subgraph that\n\
    \   contains T, which would provide each node with two disjoint paths to\n   each\
    \ other node, if this is done by all nodes.\n   TBRPF allows the option to include\
    \ link metrics in topology updates,\n   and to compute paths that are shortest\
    \ with respect to the metric.\n   This allows packets to be sent along paths that\
    \ are higher quality\n   than minimum-hop paths.\n   TBRPF allows path optimality\
    \ to be traded off in order to reduce the\n   amount of control traffic in networks\
    \ with a large diameter, where\n   the degree of approximation is determined by\
    \ the configurable\n   parameter NON_TREE_PENALTY.\n"
- title: 6.  TBRPF Packets
  contents:
  - "6.  TBRPF Packets\n   Nodes send TBRPF protocol data in contiguous units known\
    \ as packets.\n   Each packet includes a header, optional header extensions, and\
    \ a body\n   comprising one or more messages and padding options as needed.  To\n\
    \   facilitate efficient receiver processing, senders SHOULD insert\n   padding\
    \ options as necessary to align multi-octet words within the\n   TBRPF packet\
    \ on natural boundaries (i.e., modulo-8/4/2 addresses for\n   64/32/16-bit words,\
    \ respectively).  Receivers MUST be capable of\n   processing multi-octet words\
    \ whether or not aligned on natural\n   boundaries.  The following sections specify\
    \ elements of the TBRPF\n   packet in more detail.\n"
- title: 6.1.  TBRPF Packet Header
  contents:
  - "6.1.  TBRPF Packet Header\n   TBRPF packet headers are variable-length (minimum\
    \ one octet).  The\n   format for the packet header is as follows:\n    0    \
    \               1                   2                   3\n    0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Vers |L|I|R|R|   Reserved    |      Header Extensions ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Version (4 bits)\n      The TBRPF version number.  This specification documents\
    \ version 4\n      of the protocol.\n   Flags (4 bits)\n      Two bits (L,I) specify\
    \ which header extensions (if any) follow.\n      Two bits (R) are reserved for\
    \ future use, and MUST be zero.  Any\n      extensions specified by these bits\
    \ MUST appear in the same order\n      as the bits (i.e., first L, then I) as\
    \ follows:\n   L - Length included\n      If the underlying delivery service provides\
    \ a length field, the\n      sender MAY set L = '0' and omit the length extension.\
    \  Otherwise,\n      the sender MUST set L = '1' and include a 16-bit unsigned\
    \ integer\n      length immediately after any previous header field.  The length\n\
    \      includes all header and data bytes and is written into the length\n   \
    \   field in network byte order.\n      Receivers examine the L bit to determine\
    \ whether the length field\n      is present.  If L = '1', the receiver reads\
    \ the length field to\n      determine the length of the TBRPF packet, including\
    \ the TBRPF\n      packet header.  Receivers discard any TBRPF packet if neither\
    \ the\n      underlying delivery service nor the TBRPF packet header provide\n\
    \      packet length.\n   I - Router ID (RID) included\n      If the underlying\
    \ delivery service encodes the sender's RID, the\n      sender MAY set I = '0'\
    \ and omit the RID field.  Otherwise, the\n      sender MUST set I = '1' and include\
    \ a 4-octet RID in network byte\n      order immediately after any previous header\
    \ fields.  The RID\n      option provides a mechanism for implicit network-level\
    \ address\n      resolution.  A receiver that detects a RID option SHOULD create\
    \ a\n      binding between the RID and the source address that appears in the\n\
    \      network-level header.\n   Reserved\n      Reserved for future use; MUST\
    \ be zero.\n"
- title: 6.2.  TBRPF Packet Body
  contents:
  - "6.2.  TBRPF Packet Body\n   The TBRPF packet body consists of the concatenation\
    \ of one or more\n   TBRPF messages (and padding options where necessary).  Messages\
    \ and\n   padding options within the TBRPF packet body are encoded using the\n\
    \   following format:\n   +-+-+-+-+-+-+-+-+- - - - -\n   |OPTIONS| TYPE  | VALUE\n\
    \   +-+-+-+-+-+-+-+-+- - - - -\n   OPTIONS (4 bits)\n      Four option bits that\
    \ depend on TYPE.\n   TYPE (4 bits)\n      Identifier for message type or padding\
    \ option.\n   VALUE\n      Variable-length field.  (Format and length depend on\
    \ TYPE, as\n      described in the following sections.)\n   The sequence of elements\
    \ MUST be processed strictly in the order they\n   appear within the TBRPF packet\
    \ body; a receiver must not, for\n   example, scan through the packet body looking\
    \ for a particular type\n   of element prior to processing all preceding elements\
    \ [2].  TBRPF\n   packet elements include padding options and messages as described\n\
    \   below.\n"
- title: 6.2.1.  Padding Options (TYPE = 0 thru 1)
  contents:
  - "6.2.1.  Padding Options (TYPE = 0 thru 1)\n   Senders MAY insert two types of\
    \ padding options where necessary,\n   e.g., to satisfy alignment requirements\
    \ for other elements [2].\n   Padding options may occur anywhere within the TBRPF\
    \ packet body.  The\n   following two padding options are defined:\n    Pad1 option\
    \ (TYPE = 0)\n   +-+-+-+-+-+-+-+-+\n   |   0   |   0   |\n   +-+-+-+-+-+-+-+-+\n\
    \   The Pad1 option inserts one octet of padding into the TBRPF packet\n   body;\
    \ the VALUE field is omitted.  If more than one octet of padding\n   is required,\
    \ the PadN option (described next) should be used, rather\n   than multiple Pad1\
    \ options.\n    PadN option (TYPE = 1)\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\
    \ - - - - - - - - - -\n   |   0   |   1   |      LEN      |  Zero-valued Octets\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - - - - -\n   The PadN option\
    \ inserts two or more octets of padding into the TBRPF\n   packet body.  The first\
    \ octet of the VALUE field contains an 8-bit\n   unsigned integer length containing\
    \ a value between 0 - 253 which\n   specifies the number of zero-valued octets\
    \ that immediately follow,\n   yielding a maximum total of 255 padding octets.\n"
- title: 6.2.2.  Messages (TYPE = 2 thru 10)
  contents:
  - "6.2.2.  Messages (TYPE = 2 thru 10)\n   Additional message types are described\
    \ as they occur in the following\n   sections.  Senders encode messages as specified\
    \ by the individual\n   message formats.  Receivers detect errors in message construction,\n\
    \   e.g., messages with unrecognized types, messages with a non-integral\n   number\
    \ of elements, or with fewer elements than indicated, etc.  In\n   all cases,\
    \ upon detecting an error, the receiver MUST discontinue\n   processing the current\
    \ TBRPF packet and discard any unprocessed\n   elements.\n"
- title: 7.  TBRPF Neighbor Discovery
  contents:
  - "7.  TBRPF Neighbor Discovery\n   This section describes the TBRPF Neighbor Discovery\
    \ (TND) protocol,\n   which allows each node to quickly detect bidirectional links\
    \ (I,J)\n   between a local interface I and a neighbor interface J, and to\n \
    \  quickly detect the loss of such links.  The interface between TND and\n   the\
    \ routing module is defined by the neighbor table maintained by TND\n   and the\
    \ three procedures Link_Up(I,J), Link_Down(I,J), and\n   Link_Change(I,J), which\
    \ are called by TND to announce a new link, the\n   loss of a link, and a change\
    \ in the metric of a link, respectively.\n"
- title: 7.1.  HELLO Message Format
  contents:
  - "7.1.  HELLO Message Format\n   The HELLO message has the following three subtypes:\n\
    \   -  NEIGHBOR REQUEST (TYPE = 2)\n   -  NEIGHBOR REPLY (TYPE = 3)\n   -  NEIGHBOR\
    \ LOST (TYPE = 4)\n   Each HELLO subtype has the following format:\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   0   | TYPE  |     HSEQ      |  Pri  |          n            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               Neighbor Interface Address (1)                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               Neighbor Interface Address (2)                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   ~                              ...                              ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               Neighbor Interface Address (n)                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   HSEQ (8 bits)\n      The HELLO sequence number.\n   Pri (4 bits)\n      This\
    \ field indicates the sending node's relay priority, which is\n      an integer\
    \ between 0 and 15.  A node with a higher relay priority\n      is more likely\
    \ to be selected as the next hop on a route.  The\n      value 0 is reserved for\
    \ non-relay nodes, i.e., nodes that should\n      never forward packets originating\
    \ from other nodes.  A router in\n      normal operation SHOULD have a relay priority\
    \ equal to 7.  A\n      router can change its relay priority dynamically, e.g.,\
    \ when its\n      power supply becomes critical.\n   n (12 bits)\n      The number\
    \ of 32-bit neighbor interface addresses in the message.\n   A HELLO message is\
    \ the concatenation of a NEIGHBOR REQUEST message, a\n   NEIGHBOR REPLY message,\
    \ and a NEIGHBOR LOST message, where each of\n   the last two messages is omitted\
    \ if its list of neighbor interface\n   addresses is empty.  Thus, a HELLO message\
    \ always includes a\n   (possibly empty) NEIGHBOR REQUEST.\n"
- title: 7.2.  Neighbor Table
  contents:
  - "7.2.  Neighbor Table\n   Each node maintains, for each of its local interfaces\
    \ I, a neighbor\n   table, which stores state information for each neighbor interface\
    \ J\n   from which HELLO messages have recently been received by interface I.\n\
    \   The entry for neighbor interface J, in the neighbor table for I,\n   contains\
    \ the following variables:\n      nbr_rid(I,J) - The router ID of the node associated\
    \ with neighbor\n      interface J.\n      nbr_status(I,J) - The current status\
    \ of the link (I,J), which can\n      be LOST, 1-WAY, or 2-WAY.\n      nbr_life(I,J)\
    \ - The amount of time (in seconds) remaining before\n      nbr_status(I,J) must\
    \ be changed to LOST if no further HELLO\n      message from interface J is received.\
    \  Set to NBR_HOLD_TIME\n      whenever a HELLO is received on interface I from\
    \ interface J.\n      nbr_hseq(I,J) - The value of HSEQ in the last HELLO message\n\
    \      received on interface I from interface J.  Used to determine the\n    \
    \  number of HELLOs that have been missed.\n      nbr_count(I,J) - The remaining\
    \ number of times a NEIGHBOR REQUEST/\n      REPLY/LOST message containing J must\
    \ be sent on interface I.\n      hello_history(I,J) - A list of the sequence numbers\
    \ of the last\n      HELLO_ACQUIRE_WINDOW HELLO messages received on interface\
    \ I from\n      interface J.\n      nbr_metric(I,J) - An optional measure of the\
    \ quality of the link\n      (I,J), represented by an integer between 1 and 255,\
    \ where smaller\n      values indicate better quality.  Defaults to 1 if not used.\n\
    \      nbr_pri(I,J) - The relay priority of the node associated with\n      interface\
    \ J.\n   The entry for interface J in the neighbor table for interface I may\n\
    \   be deleted if no HELLO has been received on interface I from\n   interface\
    \ J within the last 2*NBR_HOLD_TIME seconds.  (It is kept\n   while NEIGHBOR LOST\
    \ messages containing J are being transmitted.)\n   The absence of an entry for\
    \ a given interface J is equivalent to an\n   entry with nbr_status(I,J) = LOST\
    \ and hello_history(I,J) = NULL.\n   The three possible values of nbr_status(I,J)\
    \ have the following\n   informal meanings (the exact meanings are defined by\
    \ the protocol):\n   LOST\n      Interface I has not received a sufficient number\
    \ of HELLO messages\n      recently from Interface J.\n   1-WAY\n      Interface\
    \ I has received a sufficient number of HELLO messages\n      recently from Interface\
    \ J, but the link is not 2-WAY.\n   2-WAY\n      Interfaces I and J have both\
    \ received a sufficient number of HELLO\n      messages recently from each other.\n"
- title: 7.3.  Sending HELLO Messages
  contents:
  - "7.3.  Sending HELLO Messages\n   Each node MUST send, on each local interface,\
    \ at least one HELLO\n   message per HELLO_INTERVAL.  HELLO messages MAY be sent\
    \ more\n   frequently than this (e.g., for faster detection of topology\n   changes).\
    \  However, to avoid the possibility that HSEQ wraps around\n   to the same number\
    \ before a neighbor that stops receiving HELLO\n   messages changes the status\
    \ of the link to LOST, the time between two\n   consecutive HELLO messages (sent\
    \ on a given interface) MUST be\n   greater than NBR_HOLD_TIME/128 second.\n \
    \  To avoid synchronization of control messages, which can result in\n   collisions,\
    \ HELLO messages SHOULD NOT be transmitted at equal\n   intervals.  To achieve\
    \ this, a node MAY choose the interval between\n   consecutive HELLO messages\
    \ to be HELLO_INTERVAL - jitter, where\n   jitter is selected randomly from the\
    \ interval [0, MAX_JITTER].\n   Each HELLO message always includes a NEIGHBOR\
    \ REQUEST message, even\n   if its list of neighbor addresses is empty.  The NEIGHBOR\
    \ REQUEST\n   message includes the sequence number HSEQ, which is incremented\
    \ by 1\n   (modulo 256) each time a HELLO is sent.  The HELLO message also\n \
    \  includes a NEIGHBOR REPLY message if its list of neighbor addresses\n   is\
    \ nonempty, and a NEIGHBOR LOST message if its list of neighbor\n   addresses\
    \ is nonempty.  The contents of these three messages are\n   determined by the\
    \ following steps at node i for each interface I:\n   1. For each interface J\
    \ such that nbr_status(I,J) = LOST and\n      nbr_count(I,J) > 0, include J in\
    \ the NEIGHBOR LOST message and\n      decrement nbr_count(I,J).\n   2. For each\
    \ interface J such that nbr_status(I,J) = 1-WAY and\n      nbr_count(I,J) > 0,\
    \ include J in the NEIGHBOR REQUEST message and\n      decrement nbr_count(I,J).\n\
    \   3. For each interface J such that nbr_status(I,J) = 2-WAY and\n      nbr_count(I,J)\
    \ > 0, include J in the NEIGHBOR REPLY message and\n      decrement nbr_count(I,J).\n\
    \   If a node restarts, so that all entries are removed from the neighbor\n  \
    \ table, then the node MUST ensure that (for each interface) at least\n   one\
    \ of the following two conditions is satisfied:\n   1. The difference between\
    \ the transmission times of the first HELLO\n      sent after restarting and the\
    \ last HELLO sent before restarting is\n      at least 2*NBR_HOLD_TIME.\n   2.\
    \ Letting HSEQ_LAST denote the sequence number of the last HELLO\n      that was\
    \ sent before restarting, the sequence number of the first\n      HELLO sent after\
    \ restarting is set to HSEQ_LAST + NBR_HOLD_COUNT +\n      1 (modulo 256).\n \
    \  Either of these conditions ensures that, if node i with interface I\n   restarts,\
    \ then each neighbor of node i that has a link (J,I) to\n   interface I will set\
    \ the status of the link to LOST.\n"
- title: 7.4.  Processing a Received HELLO Message
  contents:
  - "7.4.  Processing a Received HELLO Message\n   When a node receives a HELLO message,\
    \ it obtains the IP address of\n   the sending interface from the IP header. \
    \ If the TBRPF packet header\n   of the received HELLO contains the RID option,\
    \ then the RID of the\n   sending node is obtained from the TBRPF packet header;\
    \ otherwise it\n   is equal to the IP address of the sending interface.  If node\
    \ i (with\n   RID equal to i) receives a HELLO message on interface I, sent by\
    \ node\n   j (with RID equal to j) on interface J, with sequence number HSEQ and\n\
    \   relay priority PRI, then node i performs the following steps:\n   1. If the\
    \ neighbor table for interface I does not contain an entry\n      for interface\
    \ J, create one with nbr_rid(I,J) = j, nbr_status(I,J)\n      = LOST (temporarily),\
    \ nbr_count(I,J) = 0, and nbr_hseq(I,J) =\n      HSEQ.\n   2. Update hello_history(I,J)\
    \ to reflect the received HELLO message.\n      If nbr_hseq(I,J) > HSEQ (due to\
    \ wraparound), set nbr_hseq(I,J) =\n      nbr_hseq(I,J) - 256.\n   3. If nbr_status(I,J)\
    \ = LOST and hello_history(I,J) indicates that\n      HELLO_ACQUIRE_COUNT of the\
    \ last HELLO_ACQUIRE_WINDOW HELLO\n      messages from interface J have been received:\n\
    \      a. If interface I does not appear in the NEIGHBOR REQUEST list or\n   \
    \      the NEIGHBOR REPLY list, set nbr_status(I,J) = 1-WAY and\n         nbr_count(I,J)\
    \ = NBR_HOLD_COUNT.\n      b. Else, set nbr_status(I,J) = 2-WAY and nbr_count(I,J)\
    \ =\n         NBR_HOLD_COUNT. Call Link_Up(I,J).\n   4. Else, if nbr_status(I,J)\
    \ = 1-WAY:\n      a. If HSEQ - nbr_hseq(I,J) > NBR_HOLD_COUNT, then set\n    \
    \     nbr_status(I,J) = LOST and nbr_count(I,J) = NBR_HOLD_COUNT.\n      b. Else,\
    \ if interface I appears in the NEIGHBOR REQUEST list, set\n         nbr_status(I,J)\
    \ = 2-WAY and nbr_count(I,J) = NBR_HOLD_COUNT.\n         Call Link_Up(I,J).\n\
    \      c. Else, if interface I appears in the NEIGHBOR REPLY list, set\n     \
    \    nbr_status(I,J) = 2-WAY and nbr_count(I,J) = 0.  Call\n         Link_Up(I,J).\n\
    \   5. Else, if nbr_status(I,J) = 2-WAY:\n      a. If interface I appears in the\
    \ NEIGHBOR LOST list, set\n         nbr_status(I,J) = LOST and nbr_count(I,J)\
    \ = 0.  Call\n         Link_Down(I,J).\n      b. Else, if HSEQ - nbr_hseq(I,J)\
    \ > NBR_HOLD_COUNT, set\n         nbr_status(I,J) = LOST and nbr_count(I,J) =\
    \ NBR_HOLD_COUNT.\n         Call Link_Down(I,J).\n      c. Else, if interface\
    \ I appears in the NEIGHBOR REQUEST list and\n         nbr_count(I,J) = 0, set\
    \ nbr_count(I,J) = NBR_HOLD_COUNT.\n   6. Set nbr_life(I,J) = NBR_HOLD_TIME, nbr_hseq(I,J)\
    \ = HSEQ, and\n      nbr_pri(I,J) = PRI.\n"
- title: 7.5.  Expiration of Timer nbr_life
  contents:
  - "7.5.  Expiration of Timer nbr_life\n   Upon expiration of the timer nbr_life(I,J)\
    \ in the neighbor table for\n   interface I, node i performs the following step:\n\
    \      If nbr_status(I,J) = 1-WAY or 2-WAY, set nbr_status(I,J) = LOST\n     \
    \ and nbr_count(I,J) = NBR_HOLD_COUNT.  Call Link_Down(I,J).\n"
- title: 7.6.  Link-Layer Failure Notification
  contents:
  - "7.6.  Link-Layer Failure Notification\n   Some link-layer protocols (e.g., IEEE\
    \ 802.11) provide a notification\n   that the link to a particular neighbor has\
    \ failed, e.g., after\n   attempting a maximum number of retransmissions.  If\
    \ such an\n   notification is provided by the link layer, then node i SHOULD\n\
    \   perform the following step upon receipt of a link-layer failure\n   notification\
    \ for the link (I,J) from local interface I to neighbor\n   interface J:\n   \
    \   If nbr_status(I,J) = 2-WAY, set nbr_status(I,J) = LOST and\n      nbr_count(I,J)\
    \ = NBR_HOLD_COUNT.  Call Link_Down(I,J).\n"
- title: 7.7.  Optional Link Metrics
  contents:
  - "7.7.  Optional Link Metrics\n   Each node MAY maintain and update one or more\
    \ link metrics for each\n   link (I,J), representing the quality of the link,\
    \ e.g., signal\n   strength, number of HELLOs received over some time interval,\n\
    \   reliability, stability, bandwidth, etc.  Each node MUST declare a\n   neighbor\
    \ to be LOST if either NBR_HOLD_COUNT HELLOs are missed or if\n   no HELLO is\
    \ received within NBR_HOLD_TIME seconds; however, a node\n   MAY also declare\
    \ a neighbor to be LOST based on a link metric being\n   above or below some threshold.\
    \  Each node MUST receive at least\n   HELLO_ACQUIRE_COUNT of the last HELLO_ACQUIRE_WINDOW\
    \ HELLOs from a\n   neighbor before declaring the neighbor 1-WAY or 2-WAY; however,\
    \ a\n   node MAY require an additional condition based on a link metric being\n\
    \   above or below some threshold, before declaring the neighbor 1-WAY or\n  \
    \ 2-WAY.  This document does not specify any particular link metric,\n   but an\
    \ implementation of TBRPF that uses such metrics is considered\n   to be compliant\
    \ with this specification.\n   The function Link_Change(I,J) is called to alert\
    \ the routing module\n   whenever nbr_metric(I,J) changes significantly.  If the\
    \ configurable\n   parameter USE_METRICS is equal to 1, then the metrics nbr_metric(I,J)\n\
    \   are used by the routing module for route computation, as described in\n  \
    \ Section 8.\n"
- title: 7.8.  Configurable Parameters
  contents:
  - "7.8.  Configurable Parameters\n   This section lists the parameters used by the\
    \ neighbor discovery\n   protocol, and their proposed default values.  All nodes\
    \ MUST be\n   configured to have the same value for all of the following\n   parameters.\n\
    \      Parameter Name          Default Value\n      --------------          -------------\n\
    \      HELLO_INTERVAL          1 second\n      MAX_JITTER              0.1 second\n\
    \      NBR_HOLD_TIME           3 seconds\n      NBR_HOLD_COUNT          3\n  \
    \    HELLO_ACQUIRE_COUNT     2\n      HELLO_ACQUIRE_WINDOW    3\n"
- title: 8.  TBRPF Routing Module
  contents:
  - "8.  TBRPF Routing Module\n   This section describes the TBRPF routing module,\
    \ which performs\n   topology discovery and route computation.\n"
- title: 8.1.  Conceptual Data Structures
  contents:
  - "8.1.  Conceptual Data Structures\n   In addition to the information required\
    \ by the neighbor discovery\n   protocol, each node running TBRPF maintains a\
    \ topology table TT,\n   which stores information for each known node and link\
    \ in the network.\n   Nodes are identified by their RIDs, i.e., node u is the\
    \ node whose\n   RID is u.  The following information is stored in the topology\
    \ table\n   at node i for each node u and link (u,v):\n      T(u,v) - Equal to\
    \ 1 if (u,v) is in node i's source tree T, and 0\n      otherwise.  The previous\
    \ source tree is also maintained as old_T.\n      RN(u) - Equal to 1 if u is in\
    \ node i's reported node set RN, and 0\n      otherwise.  The previous reported\
    \ node set is also maintained as\n      old_RN.\n      RT(u,v) - Equal to 1 if\
    \ (u,v) is in node i's reported subtree RT,\n      and 0 otherwise.  Since RT\
    \ is defined as the set of links (u,v) in\n      T such that u is in RN, this\
    \ variable need not be maintained\n      explicitly.\n      TG(u,v) - Equal to\
    \ 1 if (u,v) is in node i's topology graph TG,\n      and 0 otherwise.\n     \
    \ N - The set of 2-way neighbors of node i.\n      r(u,v) - The list of neighbors\
    \ that are reporting link (u,v) in\n      their reported subtree RT.  The set\
    \ of links (u,v) reported by\n      neighbor j is denoted RT_j.\n      r(u) -\
    \ The list of neighbors that are reporting node u in their\n      reported node\
    \ set RN.\n      p(u) - The current parent for node u, equal to the next node\
    \ on\n      the shortest path to u.\n      pred(u) - The node that is the predecessor\
    \ of node u in the source\n      tree T.  Equal to NULL if node u is not reachable.\n\
    \      pred(j,u) - The node that is the predecessor of node u in the\n      subtree\
    \ RT_j reported by neighbor j.\n      d(u) - The length of the shortest path to\
    \ node u.  If USE_METRICS\n      = 0, d(u) is the number of hops to node u.\n\
    \      reported(u,v) - Equal to 1 if link (u,v) in TG is reported by\n      p(u),\
    \ and 0 otherwise.\n      tg_expire(u) - Expiration time for links (u,v) in TG.\n\
    \      rt_expire(j,u) - Expiration time for links (u,v) in RT_j.\n      nr_expire(u,v)\
    \ - Expiration time for a link (u,v) in TG such that\n      reported(u,v) = 0.\
    \  Such non-reported links can be used\n      temporarily during rerouting.\n\
    \      metric(j,u,v) - The metric for link (u,v) reported by neighbor j.\n   \
    \   metric(u,v) - The metric for link (u,v) in TG.  For a neighbor j,\n      metric(i,j)\
    \ is the minimum of nbr_metric(I,J) over all 2-WAY links\n      (I,J) from i to\
    \ j.\n      cost(u,v) - The cost for link (u,v), equal to metric(u,v) if\n   \
    \   USE_METRICS = 1, and otherwise equal to 1.\n      local_if(j) - The address\
    \ of the preferred local interface for\n      forwarding packets to neighbor j.\n\
    \      nbr_if(j) - The address of the preferred interface of neighbor j.\n   The\
    \ routing table consists of a list of tuples of the form (rt_dest,\n   rt_next,\
    \ rt_dist, rt_if_id), where rt_dest is the destination IP\n   address or prefix,\
    \ rt_next is the interface address of the next hop\n   of the route, rt_dist is\
    \ the length of the route, and rt_if_id is the\n   ID of the local interface through\
    \ which the next hop can be reached.\n   Each node also maintains three tables\
    \ that describe associated IP\n   addresses or prefixes:  the \"interface table\"\
    , which associates\n   interface IP addresses with router IDs, the \"host table\"\
    , which\n   associates host IP addresses with router IDs, and the \"network prefix\n\
    \   table\", which associates network prefixes with router IDs.\n   The \"interface\
    \ table\" consists of tuples of the form (if_addr,\n   if_rid, if_expire), where\
    \ if_addr is an interface IP address\n   associated with the router with RID =\
    \ if_rid, and if_expire is the\n   time at which the tuple expires and MUST be\
    \ removed.  The interface\n   table at a node does NOT contain an entry in which\
    \ if_addr equals the\n   node's own RID; thus, a node does not advertise its own\
    \ RID as an\n   associated interface.\n   The \"host table\" consists of tuples\
    \ of the form (h_addr, h_rid,\n   h_expire), where h_addr is a host IP address\
    \ associated with the\n   router with RID = h_rid, and h_expire is the time at\
    \ which the tuple\n   expires and MUST be removed.\n   The \"network prefix table\"\
    \ consists of tuples of the form\n   (net_prefix, net_length, net_rid, net_expire),\
    \ where net_prefix and\n   net_length describe a network prefix associated with\
    \ the router with\n   RID = net_rid, and net_expire is the time at which the tuple\
    \ expires\n   and MUST be removed.  A MANET may be configured as a \"stub\" network,\n\
    \   in which case one or more gateway routers may announce a default\n   prefix\
    \ such that net_prefix = net_length = 0.  Two copies of each\n   table are kept:\
    \  an \"old\" copy that was last reported to neighbors,\n   and the current copy\
    \ that is updated when association messages are\n   received.\n"
- title: 8.2.  TOPOLOGY UPDATE Message Format
  contents:
  - "8.2.  TOPOLOGY UPDATE Message Format\n   The TOPOLOGY UPDATE message has the\
    \ two formats, depending on the\n   size of the message.  The normal format is\
    \ as follows, and is used\n   whenever n, NRL, and NRNL all do not exceed 255:\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |M|D|0|0|\
    \  TYPE |       n       |     NRL       |    NRNL       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      Router ID of u                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      Router ID of v_1                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   ~                              ...                              ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      Router ID of v_n                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     metric 1    |  metric 2   |            ...                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The message body contains the n+1 router IDs for nodes u,\n   v_1,...,v_n,\
    \ which represent the links (u,v_1),..., (u,v_n).  The\n   first NRL of the v_k\
    \ are reported leaf nodes, the next NRNL of the\n   v_k are reported non-leaf\
    \ nodes, and the last n - (NRL+NRNL) of the\n   v_k are not reported (not in RN).\n\
    \   The M bit indicates whether or not link metrics are included in the\n   message.\
    \  If M = 1, then a 1-octet metric is included for each of the\n   links (u,v_1),...,\
    \ (u,v_n), following the last router ID.\n   The D bit indicates whether or not\
    \ implicit deletion is used, and\n   must be set to 1 if and only if IMPLICIT_DELETION\
    \ = 1.\n   The TOPOLOGY UPDATE message has the following three subtypes:\n   FULL\
    \ (TYPE = 5)\n      A FULL update (FULL, n, NRL, NRNL, u, v_1,..., v_n) reports\
    \ that\n      the links (u,v_1),..., (u,v_n) belong to the sending router's\n\
    \      reported subtree RT, and that RT contains no other links with tail\n  \
    \    u.\n   ADD (TYPE = 6)\n      An ADD update (ADD, n, NRL, NRNL, u, v_1,...,\
    \ v_n) reports that\n      the links (u,v_1),..., (u,v_n) have been added to the\
    \ sending\n      router's reported subtree RT.\n   DELETE (TYPE = 7)\n      A\
    \ DELETE update (DELETE, n, NRL, NRNL, u, v_1,..., v_n) reports\n      that the\
    \ links (u,v_1),..., (u,v_n) have been deleted from the\n      sending router's\
    \ reported subtree RT.\n   If n, NRL, or NRNL is larger than 255, then the long\
    \ format of the\n   TOPOLOGY UPDATE message is used, in which the first 4 octets\
    \ of the\n   normal format are replaced by the following 8 octets:\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |M|D|1|0|  TYPE |      0        |             n                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            NRL                |            NRNL               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 8.3.  Interface, Host, and Network Prefix Association Message Formats
  contents:
  - "8.3.  Interface, Host, and Network Prefix Association Message Formats\n   The\
    \ INTERFACE ASSOCIATION (TYPE = 8) and HOST ASSOCIATION (TYPE = 9)\n   messages\
    \ have the following format:\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |ST | 0 |  TYPE |    Reserved   |             n                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         Router ID                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         IP Address                            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         IP Address                            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The message body contains the router ID of the originating node, and\n   n\
    \ IP addresses of interfaces (TYPE = 8) or hosts (TYPE = 9) that are\n   associated\
    \ with the router ID.  The ST field is defined below.\n   The NETWORK PREFIX ASSOCIATION\
    \ message (TYPE = 10) has the following\n   format:\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |ST | 0 |  TYPE |    Reserved   |             n                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         Router ID                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | PrefixLength  | Prefix byte 1 | Prefix byte 2 |     ...       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      ...      | PrefixLength  | Prefix byte 1 | Prefix byte 2 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      ...                                                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The message body contains the router ID of the originating node, and\n   n\
    \ network prefixes, each specified by a 1-octet prefix length\n   followed immediately\
    \ by the prefix, using the minimum number of whole\n   octets required.  To minimize\
    \ overhead, the prefix lengths and\n   prefixes are NOT aligned along word boundaries.\n\
    \   The INTERFACE ASSOCIATION, HOST ASSOCIATION, and NETWORK PREFIX\n   ASSOCIATION\
    \ messages each have the following three subtypes (similar\n   to those for the\
    \ TOPOLOGY UPDATE message):\n   FULL (ST = 0)\n      Indicates that this is a\
    \ FULL update that includes all interface\n      addresses, host addresses, or\
    \ network prefixes associated with the\n      given router ID.\n   ADD (ST = 1)\n\
    \      Indicates that the included IP addresses or network prefixes are\n    \
    \  associated with the router ID, but may not include all such IP\n      addresses\
    \ or network prefixes.\n   DELETE (ST = 2)\n      Indicates that the included\
    \ IP addresses or network prefixes are\n      no longer associated with the router\
    \ ID.\n"
- title: 8.4.  TBRPF Routing Operation
  contents:
  - "8.4.  TBRPF Routing Operation\n   This section describes the operation of the\
    \ TBRPF routing module.\n   The operation is divided into the following subsections:\
    \ periodic\n   processing, updating the source tree and topology graph, updating\
    \ the\n   routing table, updating the reported node set, generating periodic\n\
    \   updates, generating differential updates, processing topology\n   updates,\
    \ expiring topology information, optional reporting of\n   redundant topology\
    \ information, local topology changes, generating\n   association messages, processing\
    \ association messages, and non-relay\n   operation.  The operation is described\
    \ in terms of procedures (e.g.,\n   Update_All), which may be executed periodically\
    \ or in response to\n   some event, and may be called by other procedures.  In\
    \ all\n   procedures, node i is the node executing the procedure.\n"
- title: 8.4.1.  Periodic Processing
  contents:
  - "8.4.1.  Periodic Processing\n   Each node executes the procedure Update_All()\
    \ periodically, at least\n   once every DIFF_UPDATE_INTERVAL seconds, which is\
    \ typically equal to\n   HELLO_INTERVAL.  This procedure is defined as follows:\n"
- title: Update_All()
  contents:
  - "Update_All()\n  1. For each interface I, create empty message list msg_list(I).\n\
    \  2. For each interface I, generate a HELLO message for\n     interface I and\
    \ add it to msg_list(I).\n  3. Expire_Links().\n  4. Update_Source_Tree().\n \
    \ 5. Update_Routing_Table().\n  6. If REPORT_FULL_TREE = 0, execute Update_RN();\
    \ otherwise (the\n     full source tree is reported) Update_RN_Simple().\n  7.\
    \ If current_time >= next_periodic:\n     7.1. Generate_Periodic_Update().\n \
    \    7.2. Set next_periodic = current_time + PER_UPDATE_INTERVAL.\n  8. Else,\
    \ Generate_Diff_Update().\n  9. Generate_Association_Messages().\n 10. For each\
    \ interface I, send the msg_list(I) on interface I.\n 11. Set old_T = T and old_RN\
    \ = RN.\n"
- title: 8.4.2.  Updating the Source Tree and Topology Graph
  contents:
  - "8.4.2.  Updating the Source Tree and Topology Graph\n   The procedure Update_Source_Tree()\
    \ is a variant of Dijkstra's\n   algorithm, which is called periodically and in\
    \ response to topology\n   changes, to update the source tree T and the topology\
    \ graph TG.  This\n   algorithm computes shortest paths subject to two link cost\
    \ penalties.\n   The penalty NON_REPORT_PENALTY is added to the cost of links\
    \ (u,v)\n   that are not currently reported by the parent p(u) so that, whenever\n\
    \   possible, a link (u,v) is included in T only if it is currently\n   reported\
    \ by the parent.  To allow immediate rerouting when p(u)\n   changes, it may be\
    \ necessary to temporarily use a link (u,v) that is\n   not currently reported\
    \ by the new parent.  The penalty\n   NON_TREE_PENALTY is added to the cost of\
    \ links (u,v) that are not\n   currently in T, to reduce the number of changes\
    \ to T.  When there\n   exist multiple paths of equal cost to a given node, router\
    \ ID is used\n   to break ties.\n   The algorithm is defined as follows (where\
    \ node i is the node\n   executing the procedure):\n"
- title: Update_Source_Tree()
  contents:
  - "Update_Source_Tree()\n  1. For each node v in TT, set d(v) = INFINITY, pred(v)\
    \ = NULL,\n     old_p(v) = p(v), and p(v) = NULL.\n  2. Set d(i) = 0, p(i) = i,\
    \ pred(i) = i.\n  3. Set S = {i}. (S is the set of labeled nodes.)\n  4. For each\
    \ node j in N, set d(j) = c(i,j), pred(j) = i,\n     and p(j) = j.  (If USE_METRICS\
    \ = 0, then all link costs\n     c(i,j) are 1.)\n  5. While there exists an unlabeled\
    \ node u in TT such that\n     d(u) < INFINITY:\n     5.1. Let u be an unlabeled\
    \ node in TT with minimum d(u).\n          (A heap should be used to find u efficiently.)\n\
    \     5.2. Add u to S (u becomes labeled).\n     5.3. If p(u) is not equal to\
    \ old_p(u) (parent has changed):\n        5.3.1. For each link (u,v) in TG with\
    \ tail u, if\n               reported(u,v) = 1, set reported(u,v) = 0 and set\n\
    \               nr_expire(u,v) = current_time + PER_UPDATE_INTERVAL.\n       \
    \ 5.3.2. If p(u) is in r(u) (p(u) is reporting u):\n           5.3.2.1. Set tg_expire(u)\
    \ = rt_expire(p(u),u).\n           5.3.2.2. If p(u) = u (u is a neighbor), remove\
    \ all links\n                    (u,v) with tail u from TG.\n           5.3.2.3.\
    \ For each link (u,v) with p(u) in r(u,v):\n              5.3.2.3.1. Add (u,v)\
    \ to TG and set reported(u,v) = 1.\n              5.3.2.3.2. Set metric(u,v) =\
    \ metric(p(u),u,v).\n                         If USE_METRICS=1, set c(u,v)=metric(u,v).\n\
    \     5.4. For each node v such that (u,v) is in TG:\n        5.4.1. If reported(u,v)\
    \ = 0,\n               set cost = c(u,v) + NON_REPORT_PENALTY.\n             \
    \  (This penalizes (u,v) if not reported by p(u).)\n        5.4.2. Else, if p(u)\
    \ = u AND u is not in r(v),\n               set cost = c(u,v) + NON_REPORT_PENALTY.\n\
    \               (This penalizes (u,v) if u is a neighbor and is not\n        \
    \       reporting v.)\n        5.4.3. If (u,v) is not in old_T and p(u) != u,\n\
    \               set cost = cost + NON_TREE_PENALTY.\n        5.4.4. If (d(u) +\
    \ cost, u) is lexicographically less\n               than (d(v), pred(v)), set\
    \ d(v) = d(u) + c(u,v),\n               pred(v) = u, and p(v) = p(u).\n  6. Update\
    \ the source tree T as follows:\n     6.1. Remove all links from T.\n     6.2.\
    \ For each node u other than i such that pred(u) is not\n          NULL, add the\
    \ link (pred(u), u) to T.\n"
- title: 8.4.3.  Updating the Routing Table
  contents:
  - "8.4.3.  Updating the Routing Table\n   The routing table is updated following\
    \ any change to the source tree\n   or the association tables (interface table,\
    \ host table, or network\n   prefix table).  The routing table is updated according\
    \ to procedure\n   Update_Routing_Table(), which is defined as follows:\n"
- title: Update_Routing_Table()
  contents:
  - "Update_Routing_Table()\n  1. Remove all tuples from the routing table.\n  2.\
    \ For each node u in TT (other than this node) such that p(u) is\n     not NULL,\
    \ add the tuple (rt_dest, rt_next, rt_dist, rt_if_id)\n     to the routing table,\
    \ where:\n        rt_dest = u,\n        rt_if_id = local_if(p(u)),\n        rt_next\
    \ = nbr_if(p(u)),\n        rt_dist = d(u).\n  3. For each tuple (if_addr, if_rid,\
    \ if_expire) in the interface\n     table, if a routing table entry (rt_dest,\
    \ rt_next, rt_dist,\n     rt_if_id) exists such that rt_dest = if_rid, add the\
    \ tuple\n     (if_addr, rt_next, rt_dist, rt_if_id) to the routing table.\n  4.\
    \ For each tuple (h_addr, h_rid, h_expire) in the host table, if\n     there exists\
    \ a routing table entry (rt_dest, rt_next, rt_dist,\n     rt_if_id) such that\
    \ rt_dest = h_rid, add the tuple (h_addr,\n     rt_next, rt_dist, rt_if_id) to\
    \ the routing table, unless an\n     entry already exists with the same value\
    \ for h_addr and a\n     lexicographically smaller value for (rt_dist, rt_dest).\n\
    \  5. For each tuple (net_prefix, net_length, net_rid, net_expire)\n     in the\
    \ network prefix table, if there exists a routing table\n     entry (rt_dest,\
    \ rt_next, rt_dist, rt_if_id) such that\n     rt_dest = net_rid, add the tuple\
    \ (net_prefix/net_length,\n     rt_next, rt_dist, rt_if_id) to the routing table,\
    \ unless an\n     entry already exists with the same value for\n     net_prefix/net_length\
    \ and a lexicographically smaller value\n     for (rt_dist, rt_dest).\n"
- title: 8.4.4.  Updating the Reported Node Set
  contents:
  - "8.4.4.  Updating the Reported Node Set\n   Recall that the reported subtree RT\
    \ is defined to be the set of links\n   (u,v) in T such that u is in the reported\
    \ node set RN.  Each node\n   updates its RN immediately before generating periodic\
    \ or differential\n   topology updates.\n   If REPORT_FULL_TREE = 1 (so that a\
    \ node reports its entire source\n   tree), then RN simply consists of all reachable\
    \ nodes, i.e., all\n   nodes u such that pred(u) is not NULL.  The procedure that\
    \ computes\n   RN in this manner is called Update_RN_Simple().  The rest of this\n\
    \   section describes how RN is computed assuming REPORT_FULL_TREE = 0.\n   A\
    \ node first determines which of its neighbors belong to RN.  Node i\n   includes\
    \ a neighbor j in RN if and only if node i determines that one\n   of its neighbors\
    \ may select i to be its next hop on its shortest path\n   to j.  To make this\
    \ determination, node i computes the shortest\n   paths, up to 2 hops, from each\
    \ neighbor to each other neighbor, using\n   only neighbors (or node i itself)\
    \ as an intermediate node, and using\n   relay priority and router ID to break\
    \ ties.  If a link metric is\n   used, then shortest paths are computed with respect\
    \ to the link\n   metric; otherwise min-hop paths are computed.\n   After a node\
    \ determines which neighbors are in RN, each node u (other\n   than node i) in\
    \ the topology table is included in RN if and only if\n   the next hop p(u) to\
    \ u is in RN.  Equivalently, node u is included in\n   RN if and only if u is\
    \ in the subtree of T rooted at some neighbor j\n   that is in RN.  Thus, the\
    \ reported subtree RT includes the subtrees\n   of T that are rooted at neighbors\
    \ in RN.  Node i also includes itself\n   in RN; thus RT also includes all local\
    \ links (i,j) to neighbors j.\n   The precise procedure for updating RN is defined\
    \ as follows:\n"
- title: Update_RN()
  contents:
  - "Update_RN()\n  1. Set RN = empty.\n  2. For each neighbor s in N such that s\
    \ is in r(s), i.e.,\n     such that s is reporting itself:\n     (Initialize to\
    \ run Dijkstra for source s, for 2 hops.)\n     2.1. For each node j in N+{i},\
    \ set dist(j) = INFINITY and\n          par(j) = NULL.\n     2.2. Set dist(s)\
    \ = 0 and par(s) = s.\n     2.3. For each node j in N+{i} such that (s,j) is in\
    \ TG:\n        2.3.1. Set dist(j) = metric(s,j), par(j) = j.\n        2.3.2. For\
    \ each node k in N such that (j,k) is in TG:\n             2.3.2.1. Set cost =\
    \ metric(j,k).\n             2.3.2.2. If (dist(j) + cost, nbr_pri(j), j)\n   \
    \             is lexicographically less than\n                (dist(k), nbr_pri(par(k)),\
    \ par(k)),\n                set dist(k) = dist(j) + cost and par(k) = j.\n   \
    \  2.4. For each neighbor j in N, add j to RN if par(j) = i.\n  3. Add i to RN.\
    \ (Node i is always in RN.)\n  4. For each node u in the topology table, add u\
    \ to RN if p(u)\n     is in RN.\n   In some cases it may be desirable to limit\
    \ the radius (number of\n   hops) that topology information is propagated.  Since\
    \ each TBRPF\n   packet is sent only to immediate (1-hop) neighbors, this cannot\
    \ be\n   achieved by using a time-to-live field.  Instead, the propagation of\n\
    \   topology information can be limited to a radius of K hops by limiting\n  \
    \ RN (at all nodes) to include only nodes that are at most K-1 hops\n   away.\
    \  Assuming min-hop routing is used, so that d(u) is the number\n   of hops to\
    \ node u, this can be done by modifying Step 4 of\n   Update_RN() as follows:\n\
    \  4. For each node u in the topology table, add u to RN if p(u)\n     is in RN\
    \ and d(u) <= K-1.\n"
- title: 8.4.5.  Generating Periodic Updates
  contents:
  - "8.4.5.  Generating Periodic Updates\n   Every PER_UPDATE_INTERVAL seconds, each\
    \ node generates and transmits,\n   on all interfaces, a set of FULL TOPOLOGY\
    \ UPDATE messages (one\n   message for each node in RN that is not a leaf of T),\
    \ which describes\n   the reported subtree RT.  Whenever possible, these messages\
    \ are\n   included in a single packet, in order to minimize the number of\n  \
    \ control packets transmitted.\n   Each topology update message contains the router\
    \ IDs for n+1 nodes u,\n   v_1,...,v_n, which represent the n links (u,v_1),...,\
    \ (u,v_n).  The n\n   head nodes v_1,..., v_n are divided into three lists in\
    \ order to\n   convey additional information and thus reduce the number of messages\n\
    \   that must be generated.  In particular, the first NRL head nodes are\n   leaves\
    \ of T, thus avoiding the need to generate separate topology\n   update messages\
    \ for leaf nodes u.  Similarly, the last n-(NRL+NRNL)\n   head nodes are not in\
    \ RN, thus avoiding the need to generate separate\n   topology update messages\
    \ for nodes u that have been removed from RN.\n   Periodic update messages are\
    \ generated according to procedure\n   Generate_Periodic_Update(), defined as\
    \ follows (where node i is the\n   node executing the procedure):\n   Generate_Periodic_Update()\n\
    \     For each node u in RN (including node i) that is not a leaf of T,\n    \
    \ add the update (FULL, n, NRL, NRNL, u, v_1,..., v_n)\n     to msg_list(I) for\
    \ each interface I, where:\n     (a) v_1,..., v_n are the nodes v such that (u,v)\
    \ is in T,\n         the first NRL of these are nodes in RN that are leaves of\
    \ T,\n         the next NRNL of these are nodes in RN that are not leaves\n  \
    \       of T, and the last n-(NRL+NRNL) of these are not in RN.\n     (b) If USE_METRICS\
    \ = 1, then the M (metrics) bit is set to 1 and\n         the link metrics metric(u,v_1),...,\
    \ metric(u,v_n) are\n         included in the message.\n"
- title: 8.4.6.  Generating Differential Updates
  contents:
  - "8.4.6.  Generating Differential Updates\n   Every DIFF_UPDATE_INTERVAL seconds,\
    \ if it is not time to generate a\n   periodic update, and if RT has changed since\
    \ the last time a topology\n   update was generated, a set of TOPOLOGY UPDATE\
    \ messages describing\n   the changes to RT is generated and transmitted on all\
    \ interfaces.\n   These messages are constructed according to procedure\n   Generate_Differential_Update(),\
    \ defined as follows:\n"
- title: Generate_Differential_Update()
  contents:
  - "Generate_Differential_Update()\n  For each node u in RN:\n  1. If u is not in\
    \ old_RN (u was added to RN) and is not a leaf\n     of T, add the update (FULL,\
    \ n, NRL, NRNL, u, v_1,..., v_n)\n     to msg_list(I) for each I, where:\n   \
    \  (a) v_1,..., v_n, NRL, and NRNL are defined as above for\n         periodic\
    \ updates.\n     (b) If USE_METRICS = 1, then the M (metrics) bit is set to 1\n\
    \         and the link metrics metric(u,v_1),..., metric(u,v_n)\n         are\
    \ included in the message.\n  2. Else, if u is in old_RN and is not a leaf of\
    \ T:\n     2.1. Let v_1,..., v_n be the nodes v such that (u,v) is in T\n    \
    \      AND at least one of the following 3 conditions holds:\n              (a)\
    \ (u,v) is not in old_T, or\n              (b) v is in old_RN but not in RN, or\n\
    \              (c) v is a leaf and is in RN but not in old_RN.\n     2.2. If this\
    \ set of nodes is nonempty, add the update\n          (ADD, n, NRL, NRNL, u, v_1,...,\
    \ v_n) to msg_list(I) for\n          each interface I, where:\n          (a) NRL\
    \ and NRNL are defined as above.\n          (b) If USE_METRICS = 1, then the M\
    \ (metrics) bit is\n              set to 1 and the link metrics metric(u,v_1),...,\n\
    \              metric(u,v_n) are included in the message.\n  3. If u is in old_RN:\n\
    \     3.1. Let v_1,..., v_n be the nodes v such that (u,v) is in\n          old_T\
    \ but not in TG, and either IMPLICIT_DELETION = 0\n          or pred(v) is not\
    \ in RN (or is NULL).\n          (If IMPLICIT_DELETION = 1 and pred(v) is in RN,\
    \ then\n          the deletion of (u,v) is implied by an ADD update for\n    \
    \      another link (w,v).)\n      3.2. If this set of nodes is nonempty, add\
    \ the update\n         (DELETE, n, u, v_1,..., v_n) to msg_list(I) for each I.\n"
- title: 8.4.7.  Processing Topology Updates
  contents:
  - "8.4.7.  Processing Topology Updates\n   When a packet containing a list (msg_list)\
    \ of TOPOLOGY UPDATE\n   messages is received from node j, the list is processed\
    \ according to\n   the procedure Process_Updates(j, msg_list), defined as follows.\
    \  In\n   particular, this procedure updates TT, TG, and the reporting neighbor\n\
    \   lists r(u) and r(u,v).  If any link in T has been deleted from TG,\n   then\
    \ Update_Source_Tree() and Update_Routing_Table() are called to\n   provide immediate\
    \ rerouting.\n"
- title: Process_Updates(j, msg_list)
  contents:
  - "Process_Updates(j, msg_list)\n  1. For each update = (subtype, n, NRL, NRNL,\
    \ u, v_1,..., v_n)\n     in msg_list:\n     1.1. Create an entry for u in TT if\
    \ it does not exist.\n     1.2. If subtype = FULL, Process_Full_Update(j, update).\n\
    \     1.3. If subtype = ADD, Process_Add_Update(j, update).\n     1.4. If subtype\
    \ = DELETE, Process_Delete_Update(j, update).\n  2. If there exists any link in\
    \ T that is not in TG:\n     2.1. Update_Source_Tree().\n     2.2. Update_Routing_Table().\n"
- title: Process_Full_Update(j, update)
  contents:
  - "Process_Full_Update(j, update)\n  1. Add j to r(u).\n  2. Set rt_expire(j,u)\
    \ = current_time + TOP_HOLD_TIME.\n  3. For each link (u,v) s.t. j is in r(u,v):\n\
    \     3.1. Remove j from r(u,v).\n     3.2. If pred(j,v) = u, set pred(j,v) =\
    \ NULL.\n  4. If j = p(u) OR p(u) = NULL:\n     4.1. Set tg_expire(u) = current_time\
    \ + TOP_HOLD_TIME.\n     4.2. For each v s.t. (u,v) is in TG,\n          If reported(u,v)\
    \ = 1, remove (u,v) from TG.\n  5. Process_Add_Update(j, update).\n"
- title: Process_Add_Update(j, update)
  contents:
  - "Process_Add_Update(j, update)\n  For m = 1,..., n:\n     ((u,v_m) is the mth\
    \ link in update.)\n     1. Let v = v_m.\n     2. Create an entry for v in TT\
    \ if it does not exist.\n     3. Add j to r(u,v).\n     4. If j = p(u) OR p(u)\
    \ = NULL:\n        4.1. Add (u,v) to TG.\n        4.2. Set reported(u,v) = 1.\n\
    \     5. If the M (metrics) bit in update is 1:\n        5.1. Set metric(j,u,v)\
    \ to the m-th metric in the update.\n        5.2. If j = p(u) OR p(u) = NULL:\n\
    \           5.2.1. Set metric(u,v) = metric(j,u,v).\n           5.2.2. If USE_METRICS\
    \ = 1, set c(u,v) = metric(u,v).\n     6. If the D (implicit deletion) bit in\
    \ update is 1:\n        6.1. Set w = pred(j,v).\n        6.2. If (w != NULL AND\
    \ w != u):\n           6.2.1. Remove j from r(w,v).\n           6.2.2. If j =\
    \ p(w), remove (w,v) from TG.\n     7. Set pred(j,v) = u.  (Set new predecessor.)\n\
    \     8. If m <= NRL (v = v_m is a reported leaf):\n        8.1. Set leaf_update\
    \ = (FULL, 0, 0, 0, v).\n        8.2. Process_Full_Update(j, leaf_update).\n \
    \    9. If m > NRL + NRNL (v = v_m is not reported by j):\n        9.1. Remove\
    \ j from r(v).\n        9.2. Set rt_expire(j,v) = 0.\n        9.3. For each node\
    \ w s.t. j is in r(v,w),\n             remove j from r(v,w).\n        9.4. If\
    \ j = p(v), then for each node w s.t. (v,w) is in TG\n               and reported(v,w)\
    \ = 1, set reported(v,w) = 0 and set\n               nr_expire(v,w) = current_time\
    \ + PER_UPDATE_INTERVAL.\n"
- title: Process_Delete_Update(j, update)
  contents:
  - "Process_Delete_Update(j, update)\n  For m = 1,..., n:\n     ((u,v_m) is the mth\
    \ link in update.)\n     1. Let v = v_m.\n     2. Remove j from r(u,v).\n    \
    \ 3. If pred(j,v) = u, set pred(j,v) = NULL.\n     4. If j = p(u), remove (u,v)\
    \ from TG.\n"
- title: 8.4.8.  Expiring Topology Information
  contents:
  - "8.4.8.  Expiring Topology Information\n   Each node periodically checks for outdated\
    \ topology information based\n   on the expiration timers tg_expire(u), rt_expire(j,u),\
    \ and\n   nr_expire(u,v), and removes any expired entries from TG and from the\n\
    \   lists r(u) and r(u,v).  This is done according to the following\n   procedure\
    \ Expire_Links(), which is called periodically just before\n   the source tree\
    \ is updated.\n"
- title: Expire_Links()
  contents:
  - "Expire_Links()\n  For each node u in TT other than node i:\n     1. If tg_expire(u)\
    \ < current_time, then for each v s.t.\n        (u,v) is in TG, remove (u,v) from\
    \ TG.\n     2. Else, for each v s.t. (u,v) is in TG,\n        if reported(u,v)\
    \ = 0 AND nr_expire(u,v) < current_time,\n        remove (u,v) from TG.\n    \
    \ 3. For each node j in r(u), if rt_expire(j,u) < current_time:\n        3.1.\
    \ Remove j from r(u).\n        3.2. For each link (u,v) s.t. j is in r(u,v),\n\
    \             remove j from r(u,v).\n   In addition, the following cleanup steps\
    \ SHOULD be executed\n   periodically to remove unnecessary entries from the topology\
    \ table\n   TT.  A link (u,v) should be removed from TT if it is not in TG and\n\
    \   not in old_T.  A node u should be removed from TT if all of the\n   following\
    \ conditions hold: r(u) is empty, r(w,u) is empty for all w,\n   and no link of\
    \ TG has u as either the head or the tail.\n"
- title: 8.4.9.  Optional Reporting of Redundant Topology Information
  contents:
  - "8.4.9.  Optional Reporting of Redundant Topology Information\n   Each node is\
    \ required to report its reported subtree RT to neighbors.\n   However, each node\
    \ (independently of the other nodes) MAY report\n   additional links, e.g., to\
    \ provide increased robustness in highly\n   mobile networks.  For example, a\
    \ node may compute any subgraph H of\n   TG that contains T, and may report the\
    \ \"reported subgraph\" RH which\n   consists of links (u,v) of H such that u\
    \ is in RN.  In this case,\n   each periodic update describes RH instead of RT,\
    \ and each\n   differential update describes changes to RH.  If this option is\
    \ used,\n   then the parameter IMPLICIT_DELETION MUST be set to 0, since the\n\
    \   deletion of a link cannot be implied by the addition of another link\n   if\
    \ redundant topology information is reported.\n"
- title: 8.4.10.  Local Topology Changes
  contents:
  - "8.4.10.  Local Topology Changes\n   This section describes the procedures that\
    \ are followed when the\n   neighbor discovery module detects a new link, the\
    \ loss of a link, or\n   a change in the metric for a link.\n   When a link (I,J)\
    \ from a local interface I to a neighbor interface J\n   is discovered via the\
    \ neighbor discovery module, the procedure\n   Link_Up(I,J) is executed, as defined\
    \ below.  Letting j be the\n   neighbor node associated with interface J, Link_Up(I,J)\
    \ adds j to N\n   (if it does not already belong), updates the preferred local\n\
    \   interface local_if(j) and neighbor interface nbr_if(j) so that the\n   link\
    \ from local_if(j) to nbr_if(j) has the minimum metric among all\n   links from\
    \ i to j, and updates metric(i,j) to be this minimum metric.\n"
- title: Link_Up(I,J)
  contents:
  - "Link_Up(I,J)\n   1. Let j = nbr_rid(I,J).\n   2. If j is not in N:\n      2.1.\
    \ Add j to N.\n      2.2. Add (i,j) to TG.\n      2.3. Set reported(i,j) = 1.\n\
    \   3. If nbr_metric(I,J) < metric(i,j), set local_if(j) = I,\n      nbr_if(j)\
    \ = J, and metric(i,j) = nbr_metric(I,J).\n   4. If USE_METRICS = 1, set cost(i,j)\
    \ = metric(i,j).\n   When the loss of a link (I,J) from a local interface I to\
    \ a neighbor\n   interface J is detected via the neighbor discovery module, the\n\
    \   procedure Link_Down(I,J) is executed, as defined below.  Note that\n   routes\
    \ are updated immediately when a link is lost, and if the lost\n   link is due\
    \ to a link-layer failure notification, a differential\n   topology update is\
    \ sent immediately.\n"
- title: Link_Down(I,J)
  contents:
  - "Link_Down(I,J)\n   1. Let j = nbr_rid(I,J).\n   2. If there does not exist a\
    \ link (K,L) from node i to\n      node j with nbr_status(K,L) = 2-WAY:\n    \
    \  2.1. Remove j from N.\n      2.2. Remove (i,j) from TG.\n   3. If j is in N:\n\
    \      3.1. Let (K,L) be a link from i to j such that\n           nbr_metric(K,L)\
    \ is the minimum metric among\n           all links from i to j.\n      3.2. Set\
    \ local_if(j) = K, nbr_if(j) = L, and\n           metric(i,j) = nbr_metric(K,L).\n\
    \      3.3. If USE_METRICS = 1, set cost(i,j) = metric(i,j).\n   5. Update_Source_Tree().\n\
    \   6. Update_Routing_Table().\n   7. If j is not in N and lost link is due to\
    \ link-layer failure\n      notification:\n      7.1. If (REPORT_FULL_TREE = 0)\
    \ Update_RN().\n      7.2. Else, Update_RN_Simple().\n      7.3. Set msg_list\
    \ = empty.\n      7.4. Generate_Diff_Update().\n      7.5. Send msg_list on all\
    \ interfaces.\n      7.6. Set old_T = T and old_RN = RN.\n   If the metric of\
    \ a link (I,J) from a local interface I to a neighbor\n   interface J changes\
    \ via the neighbor discovery module, the following\n   procedure Link_Change(I,J)\
    \ is executed.\n"
- title: Link_Change(I,J)
  contents:
  - "Link_Change(I,J)\n   1. Let j = nbr_rid(I,J).\n   2. Let (K,L) be a link from\
    \ i to j such that\n      nbr_metric(K,L) is the minimum metric among\n      all\
    \ links from i to j.\n   3. Set local_if(j) = K, nbr_if(j) = L, and\n      metric(i,j)\
    \ = nbr_metric(K,L).\n   4. If USE_METRICS = 1, set cost(i,j) = metric(i,j).\n"
- title: 8.4.11.  Generating Association Messages
  contents:
  - "8.4.11.  Generating Association Messages\n   This section describes the procedures\
    \ used to generate INTERFACE\n   ASSOCIATION, HOST ASSOCIATION, and NETWORK PREFIX\
    \ ASSOCIATION\n   messages.  Addresses or prefixes in the interface table, host\
    \ table,\n   and network prefix table are reported to neighbors periodically every\n\
    \   IA_INTERVAL, HA_INTERVAL, and NPA_INTERVAL seconds, respectively.  In\n  \
    \ addition, differential changes to the tables are reported every\n   DIFF_UPDATE_INTERVAL\
    \ seconds if it is not time for a periodic update\n   (similar to differential\
    \ topology updates).  Each node reports only\n   addresses or prefixes that are\
    \ associated with nodes in the reported\n   node set RN; this ensures the efficient\
    \ broadcast of all associated\n   addresses and prefixes to all nodes in the network.\n\
    \   The generated messages are sent on each interface.  Whenever\n   possible,\
    \ these messages are combined into the same packet, in order\n   to minimize the\
    \ number of control packets transmitted.\n"
- title: Generate_Association_Messages()
  contents:
  - "Generate_Association_Messages()\n   1. Generate_Interface_Association_Messages().\n\
    \   2. Generate_Host_Association_Messages().\n   3. Generate_Network_Prefix_Association_Messages().\n"
- title: Generate_Interface_Association_Messages()
  contents:
  - "Generate_Interface_Association_Messages()\n   1. If current_time > next_ia_time:\n\
    \      1.1. Set next_ia_time = current_time + IA_INTERVAL.\n      1.2. For each\
    \ node u in RN:\n         1.2.1. Let addr_1,..., addr_n be the interface IP\n\
    \            addresses associated with RID u in the current\n            interface\
    \ table.\n         1.2.2. If this list is nonempty, add the INTERFACE\n      \
    \      ASSOCIATION message (FULL, n, u, addr_1,..., addr_n)\n            to msg_list(I)\
    \ for each I.\n   2. Else, for each node u in RN:\n      2.1. Add the INTERFACE\
    \ ASSOCIATION message (ADD, n, u,\n         addr_1,..., addr_n) to msg_list(I)\
    \ for each I, where\n         addr_1,..., addr_n are the interface IP addresses\
    \ that\n         are associated with RID u in the current interface table\n  \
    \       but not in the old interface table.\n      2.2. Add the INTERFACE ASSOCIATION\
    \ message (DELETE, n, u,\n         addr_1,..., addr_n) to msg_list(I) for each\
    \ I, where\n         addr_1,..., addr_n are the interface IP addresses that\n\
    \         are associated with RID u in the old interface table\n         but not\
    \ in the current interface table.\n"
- title: Generate_Host_Association_Messages()
  contents:
  - "Generate_Host_Association_Messages()\n   1. If current_time > next_ha_time:\n\
    \      1.1. Set next_ha_time = current_time + HA_INTERVAL.\n      1.2. For each\
    \ node u in RN:\n         1.2.1. Let addr_1,..., addr_n be the host IP addresses\n\
    \            associated with RID u in the current host table.\n         1.2.2.\
    \ If this list is nonempty, add the HOST ASSOCIATION\n            message (FULL,\
    \ n, u, addr_1,..., addr_n) to\n            msg_list(I) for each I.\n   2. Else,\
    \ for each node u in RN:\n      2.1. Add the HOST ASSOCIATION message (ADD, n,\
    \ u,\n         addr_1,..., addr_n) to msg_list(I) for each I, where\n        \
    \ addr_1,..., addr_n are the host IP addresses that\n         are associated with\
    \ RID u in the current host table\n         but not in the old host table.\n \
    \     2.2. Add the HOST ASSOCIATION message (DELETE, n, u,\n         addr_1,...,\
    \ addr_n) to msg_list(I) for each I, where\n         addr_1,..., addr_n are the\
    \ host IP addresses that\n         are associated with RID u in the old host table\n\
    \         but not in the current host table.\n"
- title: Generate_Network_Prefix_Association_Messages()
  contents:
  - "Generate_Network_Prefix_Association_Messages()\n   1. If current_time > next_npa_time:\n\
    \      1.1. Set next_npa_time = current_time + NPA_INTERVAL.\n      1.2. For each\
    \ node u in RN:\n         1.2.1. Let length_1, prefix_1,..., length_n, prefix_n\n\
    \            be the network prefix lengths and prefixes associated\n         \
    \   with RID u in the current network prefix table.\n         1.2.2. If this list\
    \ is nonempty, add the NETWORK PREFIX\n            ASSOCIATION message (FULL,\
    \ n, u, length_1, prefix_1,\n            ..., length_n, prefix_n) to msg_list(I)\
    \ for each I.\n   2. Else, for each node u in RN:\n      2.1. Add the NETWORK\
    \ PREFIX ASSOCIATION message\n         (ADD, n, u, prefix_1,..., prefix_n) to\
    \ msg_list(I) for\n         each I, where prefix_1,..., prefix_n are the network\n\
    \         prefixes that are associated with RID u in the current\n         prefix\
    \ table but not in the old prefix table.\n      2.1. Add the NETWORK PREFIX ASSOCIATION\
    \ message\n         (DELETE, n, u, prefix_1,..., prefix_n) to msg_list(I) for\n\
    \         each I, where prefix_1,..., prefix_n are the network\n         prefixes\
    \ that are associated with RID u in the old prefix\n         table but not in\
    \ the current prefix table.\n"
- title: 8.4.12.  Processing Association Messages
  contents:
  - "8.4.12.  Processing Association Messages\n   When an INTERFACE ASSOCIATION, HOST\
    \ ASSOCIATION, or NETWORK PREFIX\n   ASSOCIATION message is received from node\
    \ j, the interface table,\n   host table, or network prefix table, respectively,\
    \ is updated as\n   described in the following three procedures.\n"
- title: Process_Interface_Association_Messages(j, msg_list)
  contents:
  - "Process_Interface_Association_Messages(j, msg_list)\n  For each message (subtype,\
    \ n, u, addr_1,..., addr_n) in msg_list\n  such that j = p(u):\n     1. If subtype\
    \ = FULL, remove all entries with if_rid = u\n        from the interface table.\n\
    \     2. If subtype = FULL or ADD, then for m = 1,..., n,\n        add the tuple\
    \ (if_addr, if_rid, if_expire) to the\n        interface table, where:\n     \
    \      if_addr = addr_m,\n           if_rid = u,\n           if_expire = current_time\
    \ + IA_HOLD_TIME.\n     3. If subtype = DELETE, then for m = 1,..., n,\n     \
    \   remove the tuple (if_addr, if_rid, if_expire) from the\n        interface\
    \ table, where if_addr = addr_m and if_rid = u.\n"
- title: Process_Host_Association_Messages(j, msg_list)
  contents:
  - "Process_Host_Association_Messages(j, msg_list)\n  For each message (subtype,\
    \ n, u, addr_1,..., addr_n) in msg_list\n  such that j = p(u):\n     1. If subtype\
    \ = FULL, remove all entries with h_rid = u\n        from the host table.\n  \
    \   2. If subtype = FULL or ADD, then for m = 1,..., n,\n        add the tuple\
    \ (h_addr, h_rid, h_expire) to the\n        host table, where:\n           h_addr\
    \ = addr_m,\n           h_rid = u,\n           h_expire = current_time + HA_HOLD_TIME.\n\
    \     3. If subtype = DELETE, then for m = 1,..., n,\n        remove the tuple\
    \ (h_addr, h_rid, h_expire) from the\n        host table, where h_addr = addr_m\
    \ and h_rid = u.\n"
- title: Process_Network_Prefix_Association_Messages(j, msg_list)
  contents:
  - "Process_Network_Prefix_Association_Messages(j, msg_list)\n   For each message\
    \ (subtype, n, u, length_1, prefix_1, ...,\n   length_n, prefix_n) in msg_list\
    \ such that j = p(u):\n      1. If subtype = FULL, remove all entries with net_rid\
    \ = u\n         from the prefix table.\n      2. If subtype = FULL or ADD, then\
    \ for m = 1,..., n,\n         add the tuple (net_prefix, net_length, net_rid,\n\
    \         net_expire) to the network prefix table, where:\n            net_prefix\
    \ = prefix_m,\n            net_length = length_m,\n            net_rid = u,\n\
    \            net_expire = current_time + NPA_HOLD_TIME.\n      3. If subtype =\
    \ DELETE, then for m = 1,..., n,\n         remove the tuple (net_prefix, net_length,\
    \ net_rid,\n         net_expire) from the network prefix table, where\n      \
    \   net_prefix = prefix_m, net_length = length_m,\n         and net_rid = u.\n"
- title: 8.4.13.  Non-Relay Operation
  contents:
  - "8.4.13.  Non-Relay Operation\n   Nodes with relay priority equal to zero are\
    \ called non-relay nodes,\n   and do not forward packets (of any type) that are\
    \ received from other\n   nodes.  A non-relay node is implemented simply by not\
    \ generating or\n   transmitting any TOPOLOGY UPDATE messages.  A non-relay node\
    \ may\n   report (in association messages) addresses or prefixes that are\n  \
    \ associated with itself, but not those associated with other nodes.\n   HELLO\
    \ messages must be transmitted in order to establish links with\n   neighbor nodes.\
    \  The following procedures can be omitted in non-relay\n   nodes: Update_RN(),\
    \ Generate_Periodic_Update(), and\n   Generate_Diff_Update().\n"
- title: 8.5.  Configurable Parameters
  contents:
  - "8.5.  Configurable Parameters\n   This section lists the configurable parameters\
    \ used by the routing\n   module, and their proposed default values.  All nodes\
    \ MUST have the\n   same value for all of the following parameters except\n  \
    \ REPORT_FULL_TREE and IMPLICIT_DELETION.\n      Parameter Name          Default\
    \ Value\n      --------------          -------------\n      DIFF_UPDATE_INTERVAL\
    \    1 second\n      PER_UPDATE_INTERVAL     5 seconds\n      TOP_HOLD_TIME  \
    \         15 seconds\n      NON_REPORT_PENALTY      1.01\n      NON_TREE_PENALTY\
    \        0.01\n      IA_INTERVAL             10 seconds\n      IA_HOLD_TIME  \
    \          3 * IA_INTERVAL\n      HA_INTERVAL             10 seconds\n      HA_HOLD_TIME\
    \            3 * HA_INTERVAL\n      NPA_INTERVAL            10 seconds\n     \
    \ NPA_HOLD_TIME           3 * NPA_INTERVAL\n      USE_METRICS             0\n\
    \      REPORT_FULL_TREE        0\n      IMPLICIT_DELETION       1\n"
- title: 9.  TBRPF Flooding Mechanism
  contents:
  - "9.  TBRPF Flooding Mechanism\n   This section describes a mechanism for the efficient\
    \ best-effort\n   flooding (or network-wide broadcast) of packets to all nodes\
    \ of a\n   connected ad-hoc network.  This mechanism can be considered an\n  \
    \ optimization of the classical flooding algorithm in which each packet\n   is\
    \ transmitted by every node of the network.  In TBRPF flooding,\n   information\
    \ provided by TBRPF is used to decide whether a given\n   received flooded packet\
    \ should be forwarded.  As a result, each\n   packet is transmitted by only a\
    \ relatively small subset of nodes,\n   thus consuming much less bandwidth than\
    \ classical flooding.\n   This document specifies that the flooding mechanism\
    \ use the IPv4\n   multicast address 224.0.1.20 (currently assigned by IANA for\
    \ \"any\n   private experiment\").  Every node maintains a duplicate cache to\
    \ keep\n   track of which flooded packets have already been received.  The\n \
    \  duplicate cache contains, for each received flooded packet, the\n   flooded\
    \ packet identifier (FPI), which for IPv4 is composed of the\n   source IP address,\
    \ the IP identification, and the fragment offset\n   values obtained from the\
    \ IP header [14].\n   When a node receives a packet whose destination IP address\
    \ is the\n   flooding address (224.0.1.20), it checks its duplicate cache for\
    \ an\n   entry that matches the packet.  If such an entry exists, the node\n \
    \  silently discards the flooded packet since it has already been\n   received.\
    \  Otherwise, the node retransmits the packet on all\n   interfaces (see the exception\
    \ below) if and only if the following\n   conditions hold:\n   1. The TBRPF node\
    \ associated with the source IP address of the packet\n      belongs to the set\
    \ RN of reported nodes computed by TBRPF.\n   2. When decremented, the 'ip_ttl'\
    \ in the IPv4 packet header\n      (respectively, the 'hop_count' in the IPv6\
    \ packet header) is\n      greater than zero.\n   If the packet is to be retransmitted,\
    \ it is sent after a small random\n   time interval in order to avoid collisions.\
    \  If the interface on\n   which the packet was received is not a MANET interface\
    \ (see the\n   Terminology section), then the packet should not be retransmitted\
    \ on\n   that interface.\n"
- title: 10.  Operation of TBRPF in Mobile Ad-Hoc Networks
  contents:
  - "10.  Operation of TBRPF in Mobile Ad-Hoc Networks\n   TBRPF is particularly well\
    \ suited to MANETs consisting of mobile\n   nodes with wireless network interfaces\
    \ operating in peer-to-peer\n   fashion over a multiple access communications\
    \ channel.  Although\n   applicable across a much broader field of use, TBRPF\
    \ is particularly\n   well suited for supporting the standard DARPA Internet protocols\n\
    \   [3][2].  In the following sections, we discuss practical\n   considerations\
    \ for the operation of TBRPF on MANETs.\n"
- title: 10.1.  Data Link Layer Assumptions
  contents:
  - "10.1.  Data Link Layer Assumptions\n   We assume a MANET data link layer that\
    \ supports broadcast, multicast\n   and unicast addressing with best-effort (not\
    \ guaranteed) delivery\n   services between neighbors (i.e., a pair of nodes within\
    \ operational\n   communications range of one another).  We further assume that\
    \ each\n   interface belonging to a node in the MANET is assigned a unicast data\n\
    \   link layer address that is unique within the MANET's scope.  While\n   such\
    \ uniqueness is not strictly guaranteed, the assumption of\n   uniqueness is consistent\
    \ with current practices for deployment of the\n   Internet protocols on specific\
    \ link layers.  Methods for duplicate\n   link layer address detection and deconfliction\
    \ are beyond the scope\n   of this document.\n"
- title: 10.2.  Network Layer Assumptions
  contents:
  - "10.2.  Network Layer Assumptions\n   MANETs are formed as collections of routers\
    \ and non-routing nodes\n   that use network layer addresses when calculating\
    \ the MANET topology.\n   We assume that each node has at least one data link\
    \ layer interface\n   (described above) and that each such interface is assigned\
    \ a network\n   layer address that is unique within the MANET.  (Methods for network\n\
    \   layer address assignment and duplicate address detection are beyond\n   the\
    \ scope of this document.)  We further assume that each node will\n   select a\
    \ unique Router ID (RID) for use in TBRPF protocol messages,\n   whether or not\
    \ the node acts as a MANET router.  Finally, we assume\n   that each MANET router\
    \ supports the multi-hop relay paradigm at the\n   network layer; i.e., each router\
    \ provides an inter-node forwarding\n   service via network layer host routes\
    \ which reflect the current MANET\n   topology as perceived by TBRPF.\n"
- title: 10.3.  Optional Automatic Address Resolution
  contents:
  - "10.3.  Optional Automatic Address Resolution\n   TBRPF employs a proactive neighbor\
    \ discovery protocol at the network\n   layer that maintains bi-directional link\
    \ state for neighboring nodes\n   through the periodic transmission of messages.\
    \  Since TBRPF neighbor\n   discovery messages contain both the data link and\
    \ network layer\n   address of the sender, implementations MAY perform automatic\n\
    \   network-to-data link layer address resolution for the nodes with\n   which\
    \ they form links.  An implementation may use such a mechanism to\n   avoid additional\
    \ message overhead and potential for packet loss\n   associated with on-demand\
    \ address resolution mechanisms such as ARP\n   [15] or IPv6 Neighbor Discovery\
    \ [16].  Implementations MUST respond\n   to on-demand address resolution requests\
    \ in the normal manner.\n"
- title: 10.4.  Support for Multiple Interfaces and/or Alias Addresses
  contents:
  - "10.4.  Support for Multiple Interfaces and/or Alias Addresses\n   MANET nodes\
    \ may comprise multiple interfaces; each with a unique\n   network layer address.\
    \  Additionally, MANET nodes may wish to publish\n   alias addresses such as when\
    \ multiple network layer addresses are\n   assigned to the same interface or when\
    \ the MANET node is serving as a\n   Mobile IP [17] home agent.  Multiple interfaces\
    \ and alias addresses\n   are advertised in INTERFACE ASSOCIATION messages, which\
    \ bind each\n   such address to the node's RID.\n"
- title: 10.5.  Support for Network Prefixes
  contents:
  - "10.5.  Support for Network Prefixes\n   MANET routers may advertise network prefixes\
    \ which the router\n   discovered via attached networks, external routes advertised\
    \ by other\n   protocols, or other means.  Network prefixes are advertised in\n\
    \   NETWORK PREFIX ASSOCIATION messages, which bind each such prefix to\n   the\
    \ node's RID.\n"
- title: 10.6.  Support for non-MANET Hosts
  contents:
  - "10.6.  Support for non-MANET Hosts\n   Non-MANET hosts may establish connections\
    \ to MANET routers through\n   on-demand mechanisms such as ARP or IPv6 Neighbor\
    \ Discovery.  Such\n   connections do not constitute a MANET link and therefore\
    \ are not\n   reported in TBRPF topology updates.  Non-MANET hosts are advertised\n\
    \   in HOST ASSOCIATION messages, which bind the IP address of each host\n   to\
    \ the node's RID.\n"
- title: 10.7.  Internet Protocol Considerations
  contents:
  - "10.7.  Internet Protocol Considerations\n   TBRPF packets are communicated using\
    \ UDP/IP.  Port 712 has been\n   assigned by IANA for exclusive use by TBRPF.\
    \  Implementations in\n   private networks MAY employ alternate data delivery\
    \ services (i.e.,\n   raw IP or local data-link encapsulation).  The selection\
    \ of an\n   alternate data delivery service MUST be consistent among all MANET\n\
    \   routers in the private network.  In all implementations, the data\n   delivery\
    \ service MUST provide a checksum facility.\n   The following sections specify\
    \ the operation of TBRPF over UDP/IP.\n"
- title: 10.7.1.  IPv4 Operation
  contents:
  - "10.7.1.  IPv4 Operation\n   When IPv4 is used, TBRPF nodes obey IPv4 host and\
    \ router requirements\n   [4][5].  TBRPF packets are sent to the multicast address\
    \ 224.0.0.2\n   (All Routers) and thus reach all TBRPF routers within single-hop\n\
    \   transmission range of the sender.  TBRPF routers MUST NOT forward\n   packets\
    \ sent to this multicast address.\n   Since non-negligible packet loss due to\
    \ link failure, interference,\n   etc. can occur, implementations SHOULD avoid\
    \ IPv4 fragmentation/\n   reassembly whenever possible, by splitting large TBRPF\
    \ protocol\n   packets into multiple smaller packets at the application layer.\
    \  When\n   fragmentation is unavoidable, senders SHOULD NOT send TBRPF packets\n\
    \   that exceed the minimum reassembly buffer size ([4], section 3.3.2)\n   for\
    \ all receivers in the network.\n"
- title: 10.7.2.  IPv6 Operation
  contents:
  - "10.7.2.  IPv6 Operation\n   The specification of TBRPF for IPv6 is the same as\
    \ for IPv4, except\n   that 32-bit IPv4 addresses are replaced by 128-bit IPv6\
    \ addresses.\n   However, to minimize overhead, router IDs remain at 32 bits,\
    \ similar\n   to OSPF for IPv6 [18].\n"
- title: 11.  IANA Considerations
  contents:
  - "11.  IANA Considerations\n   The IANA has assigned port number 712 for TBRPF.\n\
    \   The TBRPF flooding mechanism specified in this document uses the IPv4\n  \
    \ multicast address 224.0.1.20, which is currently assigned by IANA for\n   \"\
    any private experiment\".  In the event that this specification is\n   advanced\
    \ to standards track, a new multicast address assignment would\n   be requested\
    \ for this purpose.\n"
- title: 12.  Security Considerations
  contents:
  - "12.  Security Considerations\n   Wireless networks are vulnerable to a variety\
    \ of attacks, including\n   denial-of-service attacks (e.g., flooding and jamming),\
    \ man-in-the-\n   middle attacks (e.g., interception, insertion, deletion,\n \
    \  modification, replaying) and service theft.  To counter such attacks,\n   it\
    \ is important to prevent the spoofing (impersonation) of TBRPF\n   nodes, and\
    \ to prevent unauthorized nodes from joining the network via\n   neighbor discovery.\
    \  To achieve this, TBRPF packets can be\n   authenticated using the IP Authentication\
    \ Header [19][20].  In\n   addition, the Encapsulating Security Payload (ESP)\
    \ header [21] can be\n   used to provide confidentiality (encryption) of TBRPF\
    \ packets.\n   The IETF SEcuring Neighbor Discovery (SEND) Working Group analyzes\n\
    \   trust models and threats for ad hoc networks [22].  TBRPF can be\n   extended\
    \ in a straightforward manner to use SEND mechanisms, e.g.,\n   [23].\n"
- title: 13.  Acknowledgements
  contents:
  - "13.  Acknowledgements\n   The authors would like to thank the Army Systems Engineering\
    \ Office\n   (ASEO) for funding part of this work.\n   The authors would like\
    \ to thank several members of the MANET working\n   group for many helpful comments\
    \ and suggestions, including Thomas\n   Clausen, Philippe Jacquet, and Joe Macker.\n\
    \   The authors would like to thank Bhargav Bellur for major\n   contributions\
    \ to the original (full-topology) version of TBRPF,\n   Ambatipudi Sastry for\
    \ his support and advice, and Julie S. Wong for\n   developing a new implementation\
    \ of TBRPF and suggesting several\n   clarifications to the TBRPF Routing Operation\
    \ section.\n"
- title: 14.  References
  contents:
  - '14.  References

    '
- title: 14.1.  Normative References
  contents:
  - "14.1.  Normative References\n   [1]  Bradner, S., \"Key words for use in RFCs\
    \ to Indicate Requirement\n        Levels\", BCP 14, RFC 2119, March 1997.\n \
    \  [2]  Deering, S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6)\n   \
    \     Specification\", RFC 2460, December 1998.\n   [3]  Postel, J., \"Internet\
    \ Protocol\", STD 5, RFC 791, September 1981.\n   [4]  Braden, R., Ed., \"Requirements\
    \ for Internet Hosts -\n        Communication Layers\", STD 3, RFC 1122, October\
    \ 1989.\n   [5]  Baker, F., Ed., \"Requirements for IP Version 4 Routers\", RFC\n\
    \        1812, June 1995.\n"
- title: 14.2.  Informative References
  contents:
  - "14.2.  Informative References\n   [6]  Moy, J., \"OSPF Version 2\", STD 54, RFC\
    \ 2328, April 1998.\n   [7]  Ogier, R., Message in IETF email archive for MANET,\n\
    \        ftp://ftp.ietf.org/ietf-mail-archive/manet/2002-02.mail,\n        February\
    \ 2002.\n   [8]  Ogier, R., \"Topology Dissemination Based on Reverse-Path\n \
    \       Forwarding (TBRPF): Correctness and Simulation Evaluation\",\n       \
    \ Technical Report, SRI International, October 2003.\n   [9]  Ogier, R., Message\
    \ in IETF email archive for MANET,\n        ftp://ftp.ietf.org/ietf-mail-archive/manet/2002-03.mail,\
    \ March\n        2002.\n   [10] Ogier, R., \"Efficient Routing Protocols for Packet-Radio\n\
    \        Networks Based on Tree Sharing\", Proc. Sixth IEEE Intl. Workshop\n \
    \       on Mobile Multimedia Communications (MOMUC'99), November 1999.\n   [11]\
    \ Bellur, B. and R. Ogier, \"A Reliable, Efficient Topology\n        Broadcast\
    \ Protocol for Dynamic Networks\", Proc. IEEE INFOCOM\n        '99, New York\"\
    , March 1999.\n   [12] Clausen, T. and P. Jacquet, Eds., \"Optimized Link State\
    \ Routing\n        Protocol (OLSR)\", RFC 3626, October 2003.\n   [13] Bertsekas,\
    \ D. and R. Gallager, \"Data Networks\", Prentice-Hall,\n        1987.\n   [14]\
    \ Perkins, C., Belding-Royer, E. and S. Das, \"IP Flooding in Ad\n        Hoc\
    \ Mobile Networks\", Work in Progress, November 2001.\n   [15] Plummer, D., \"\
    Ethernet Address Resolution Protocol: Or\n        converting network protocol\
    \ addresses to 48.bit Ethernet address\n        for transmission on Ethernet hardware\"\
    , STD 37, RFC 826,\n        November 1982.\n   [16] Narten, T., Nordmark, E. and\
    \ W. Simpson, \"Neighbor Discovery for\n        IP Version 6 (IPv6)\", RFC 2461,\
    \ December 1998.\n   [17] Perkins, C., Ed., \"IP Mobility Support for IPv4\",\
    \ RFC 3344,\n        August 2002.\n   [18] Coltun, R., Ferguson, D. and J. Moy,\
    \ \"OSPF for IPv6\", RFC 2740,\n        December 1999.\n   [19] Kent, S. and R.\
    \ Atkinson, \"Security Architecture for the\n        Internet Protocol\", RFC\
    \ 2401, November 1998.\n   [20] Kent, S. and R. Atkinson, \"IP Authentication\
    \ Header\", RFC 2402,\n        November 1998.\n   [21] Kent, S. and R. Atkinson,\
    \ \"IP Encapsulating Security Payload\n        (ESP)\", RFC 2406, November 1998.\n\
    \   [22] Nikander, P., \"IPv6 Neighbor Discovery Trust Models and\n        Threats\"\
    , Work in Progress, April 2003.\n   [23] Arkko, J., \"SEcure Neighbor Discovery\
    \ (SEND)\", Work in Progress,\n        June 2003.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Richard G. Ogier\n   SRI International\n   333 Ravenswood\
    \ Ave.\n   Menlo Park, CA  94025\n   USA\n   Phone: +1 650 859-4216\n   Fax: \
    \  +1 650 859-4812\n   EMail: ogier@erg.sri.com\n   Fred L. Templin\n   Nokia\n\
    \   313 Fairchild Drive\n   Mountain View, CA  94043\n   USA\n   Phone: +1 650\
    \ 625 2331\n   Fax:   +1 650 625 2502\n   EMail: ftemplin@iprg.nokia.com\n   Mark\
    \ G. Lewis\n   SRI International\n   333 Ravenswood Ave.\n   Menlo Park, CA  94025\n\
    \   USA\n   Phone: +1 650 859-4302\n   Fax:   +1 650 859-4812\n   EMail: lewis@erg.sri.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2004).  This\
    \ document is subject\n   to the rights, licenses and restrictions contained in\
    \ BCP 78 and\n   except as set forth therein, the authors retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE\n   REPRESENTS\
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE\n   INTERNET ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed\n   to pertain to the implementation or use of the technology\n   described\
    \ in this document or the extent to which any license\n   under such rights might\
    \ or might not be available; nor does it\n   represent that it has made any independent\
    \ effort to identify any\n   such rights.  Information on the procedures with\
    \ respect to\n   rights in RFC documents can be found in BCP 78 and BCP 79.\n\
    \   Copies of IPR disclosures made to the IETF Secretariat and any\n   assurances\
    \ of licenses to be made available, or the result of an\n   attempt made to obtain\
    \ a general license or permission for the use\n   of such proprietary rights by\
    \ implementers or users of this\n   specification can be obtained from the IETF\
    \ on-line IPR repository\n   at http://www.ietf.org/ipr.\n   The IETF invites\
    \ any interested party to bring to its attention\n   any copyrights, patents or\
    \ patent applications, or other\n   proprietary rights that may cover technology\
    \ that may be required\n   to implement this standard.  Please address the information\
    \ to the\n   IETF at ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
