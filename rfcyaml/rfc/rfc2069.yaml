- title: __initial_text__
  contents:
  - '          An Extension to HTTP : Digest Access Authentication

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   The protocol referred to as \"HTTP/1.0\" includes the specification\
    \ for\n   a Basic Access Authentication scheme.  This scheme is not considered\n\
    \   to be a secure method of user authentication, as the user name and\n   password\
    \ are passed over the network as clear text.  A specification\n   for a different\
    \ authentication scheme is needed to address this\n   severe limitation.  This\
    \ document provides specification for such a\n   scheme, referred to as \"Digest\
    \ Access Authentication\".  Like Basic,\n   Digest access authentication verifies\
    \ that both parties to a\n   communication know a shared secret (a password);\
    \ unlike Basic, this\n   verification can be done without sending the password\
    \ in the clear,\n   which is Basic's biggest weakness. As with most other authentication\n\
    \   protocols, the greatest sources of risks are usually found not in the\n  \
    \ core protocol itself but in policies and procedures surrounding its\n   use.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   INTRODUCTION......................................................\
    \  2\n    1.1  PURPOSE ....................................................  2\n\
    \    1.2  OVERALL OPERATION ..........................................  3\n  \
    \  1.3  REPRESENTATION OF DIGEST VALUES ............................  3\n    1.4\
    \  LIMITATIONS ................................................  3\n   2. DIGEST\
    \ ACCESS AUTHENTICATION SCHEME............................  3\n    2.1 SPECIFICATION\
    \ OF DIGEST HEADERS .............................  3\n     2.1.1 THE WWW-AUTHENTICATE\
    \ RESPONSE HEADER .....................  4\n     2.1.2 THE AUTHORIZATION REQUEST\
    \ HEADER .........................  6\n     2.1.3 THE AUTHENTICATION-INFO HEADER\
    \ ...........................  9\n    2.2 DIGEST OPERATION ............................................\
    \ 10\n    2.3 SECURITY PROTOCOL NEGOTIATION ............................... 10\n\
    \    2.4 EXAMPLE ..................................................... 11\n  \
    \  2.5 PROXY-AUTHENTICATION AND PROXY-AUTHORIZATION ................ 11\n   3.\
    \ SECURITY CONSIDERATIONS........................................ 12\n    3.1\
    \ COMPARISON WITH BASIC AUTHENTICATION ........................ 13\n    3.2 REPLAY\
    \ ATTACKS .............................................. 13\n    3.3 MAN IN THE\
    \ MIDDLE ........................................... 14\n    3.4 SPOOFING BY COUNTERFEIT\
    \ SERVERS ............................. 15\n    3.5 STORING PASSWORDS ...........................................\
    \ 15\n    3.6 SUMMARY ..................................................... 16\n\
    \   4.  ACKNOWLEDGMENTS............................................... 16\n  \
    \ 5. REFERENCES..................................................... 16\n   6.\
    \ AUTHORS' ADDRESSES............................................. 17\n"
- title: Introduction
  contents:
  - 'Introduction

    '
- title: 1.1  Purpose
  contents:
  - "1.1  Purpose\n   The protocol referred to as \"HTTP/1.0\" includes specification\
    \ for a\n   Basic Access Authentication scheme[1].  This scheme is not considered\n\
    \   to be a secure method of user authentication, as the user name and\n   password\
    \ are passed over the network in an unencrypted form.  A\n   specification for\
    \ a new authentication scheme is needed for future\n   versions of the HTTP protocol.\
    \  This document provides specification\n   for such a scheme, referred to as\
    \ \"Digest Access Authentication\".\n   The Digest Access Authentication scheme\
    \ is not intended to be a\n   complete answer to the need for security in the\
    \ World Wide Web. This\n   scheme provides no encryption of object content. The\
    \ intent is simply\n   to create a weak access authentication method which avoids\
    \ the most\n   serious flaws of Basic authentication.\n   It is proposed that\
    \ this access authentication scheme be included in\n   the proposed HTTP/1.1 specification.\n"
- title: 1.2  Overall Operation
  contents:
  - "1.2  Overall Operation\n   Like Basic Access Authentication, the Digest scheme\
    \ is based on a\n   simple challenge-response paradigm.  The Digest scheme challenges\n\
    \   using a nonce value.  A valid response contains a checksum (by\n   default\
    \ the MD5 checksum) of the username, the password, the given\n   nonce value,\
    \ the HTTP method, and the requested URI.  In this way,\n   the password is never\
    \ sent in the clear.  Just as with the Basic\n   scheme, the username and password\
    \ must be prearranged in some fashion\n   which is not addressed by this document.\n"
- title: 1.3  Representation of digest values
  contents:
  - "1.3  Representation of digest values\n   An optional header allows the server\
    \ to specify the algorithm used to\n   create the checksum or digest.  By default\
    \ the MD5 algorithm is used\n   and that is the only algorithm described in this\
    \ document.\n   For the purposes of this document, an MD5 digest of 128 bits is\n\
    \   represented as 32 ASCII printable characters.  The bits in the 128\n   bit\
    \ digest are converted from most significant to least significant\n   bit, four\
    \ bits at a time to their ASCII presentation as follows.\n   Each four bits is\
    \ represented by its familiar hexadecimal notation\n   from the characters 0123456789abcdef.\
    \  That is, binary 0000 gets\n   represented by the character '0', 0001, by '1',\
    \ and so on up to the\n   representation of 1111 as 'f'.\n"
- title: 1.4  Limitations
  contents:
  - "1.4  Limitations\n   The digest authentication scheme described in this document\
    \ suffers\n   from many known limitations.  It is intended as a replacement for\n\
    \   basic authentication and nothing more.  It is a password-based system\n  \
    \ and (on the server side) suffers from all the same problems of any\n   password\
    \ system.  In particular, no provision is made in this\n   protocol for the initial\
    \ secure arrangement between user and server\n   to establish the user's password.\n\
    \   Users and implementors should be aware that this protocol is not as\n   secure\
    \ as kerberos, and not as secure as any client-side private-key\n   scheme.  Nevertheless\
    \ it is better than nothing, better than what is\n   commonly used with telnet\
    \ and ftp, and better than Basic\n   authentication.\n"
- title: 2. Digest Access Authentication Scheme
  contents:
  - '2. Digest Access Authentication Scheme

    '
- title: 2.1 Specification of Digest Headers
  contents:
  - "2.1 Specification of Digest Headers\n   The Digest Access Authentication scheme\
    \ is conceptually similar to\n   the Basic scheme.  The formats of the modified\
    \ WWW-Authenticate\n   header line and the Authorization header line are specified\
    \ below,\n   using the extended BNF defined in the HTTP/1.1 specification, section\n\
    \   2.1.  In addition, a new header, Authentication-info, is specified.\n"
- title: 2.1.1 The WWW-Authenticate Response Header
  contents:
  - "2.1.1 The WWW-Authenticate Response Header\n   If a server receives a request\
    \ for an access-protected object, and an\n   acceptable Authorization header is\
    \ not sent, the server responds with\n   a \"401 Unauthorized\" status code, and\
    \ a WWW-Authenticate header,\n   which is defined as follows:\n     WWW-Authenticate\
    \    = \"WWW-Authenticate\" \":\" \"Digest\"\n                              digest-challenge\n\
    \     digest-challenge    = 1#( realm | [ domain ] | nonce |\n               \
    \           [ digest-opaque ] |[ stale ] | [ algorithm ] )\n     realm       \
    \        = \"realm\" \"=\" realm-value\n     realm-value         = quoted-string\n\
    \     domain              = \"domain\" \"=\" <\"> 1#URI <\">\n     nonce     \
    \          = \"nonce\" \"=\" nonce-value\n     nonce-value         = quoted-string\n\
    \     opaque              = \"opaque\" \"=\" quoted-string\n     stale       \
    \        = \"stale\" \"=\" ( \"true\" | \"false\" )\n     algorithm          \
    \ = \"algorithm\" \"=\" ( \"MD5\" | token )\n   The meanings of the values of\
    \ the parameters used above are as\n   follows:\n     realm\n     A string to\
    \ be displayed to users so they know which username and\n     password to use.\
    \  This string should contain at least the name of\n     the host performing the\
    \ authentication and might additionally\n     indicate the collection of users\
    \ who might have access.  An example\n     might be \"registered_users@gotham.news.com\"\
    .  The realm is a\n     \"quoted-string\" as specified in section 2.2 of the HTTP/1.1\n\
    \     specification [2].\n     domain\n     A comma-separated list of URIs, as\
    \ specified for HTTP/1.0.  The\n     intent is that the client could use this\
    \ information to know the\n     set of URIs for which the same authentication\
    \ information should be\n     sent.  The URIs in this list may exist on different\
    \ servers.  If\n     this keyword is omitted or empty, the client should assume\
    \ that the\n     domain consists of all URIs on the responding server.\n     nonce\n\
    \     A server-specified data string which may be uniquely generated each\n  \
    \   time a 401 response is made.  It is recommended that this string be\n    \
    \ base64 or hexadecimal data.  Specifically, since the string is\n     passed\
    \ in the header lines as a quoted string, the double-quote\n     character is\
    \ not allowed.\n     The contents of the nonce are implementation dependent. \
    \ The\n     quality of the implementation depends on a good choice.  A\n     recommended\
    \ nonce would include\n             H(client-IP \":\" time-stamp \":\" private-key\
    \ )\n     Where client-IP is the dotted quad IP address of the client making\n\
    \     the request, time-stamp is a server-generated time value,  private-\n  \
    \   key is data known only to the server.  With a nonce of this form a\n     server\
    \ would normally recalculate the nonce after receiving the\n     client authentication\
    \ header and reject the request if it did not\n     match the nonce from that\
    \ header. In this way the server can limit\n     the reuse of a nonce to the IP\
    \ address to which it was issued and\n     limit the time of the nonce's validity.\
    \  Further discussion of the\n     rationale for nonce construction is in section\
    \ 3.2 below.\n     An implementation might choose not to accept a previously used\n\
    \     nonce or a previously used digest to protect against a replay\n     attack.\
    \  Or, an implementation might choose to use one-time nonces\n     or digests\
    \ for POST or PUT requests and a time-stamp for GET\n     requests.  For more\
    \ details on the issues involved see section 3.\n     of this document.\n    \
    \ The nonce is opaque to the client.\n     opaque\n     A string of data, specified\
    \ by the server, which should be\n     returned by the client unchanged.  It is\
    \ recommended that this\n     string be base64 or hexadecimal data.  This field\
    \ is a\n     \"quoted-string\" as specified in section 2.2 of the HTTP/1.1\n \
    \    specification [2].\n     stale\n     A flag, indicating that the previous\
    \ request from the client was\n     rejected because the nonce value was stale.\
    \  If stale is TRUE (in\n     upper or lower case), the client may wish to simply\
    \ retry the\n     request with a new encrypted response, without reprompting the\n\
    \     user for a new username and password.  The server should only set\n    \
    \ stale to true if it receives a request for which the nonce is\n     invalid\
    \ but with a valid digest for that nonce (indicating that\n     the client knows\
    \ the correct username/password).\n     algorithm\n     A string indicating a\
    \ pair of algorithms used to produce the\n     digest and a checksum.  If this\
    \ not present it is assumed to be\n     \"MD5\". In this document the string obtained\
    \ by applying the\n     digest algorithm to the data \"data\" with secret \"secret\"\
    \ will be\n     denoted by KD(secret, data), and the string obtained by applying\n\
    \     the checksum algorithm to the data \"data\" will be denoted\n     H(data).\n\
    \     For the \"MD5\" algorithm\n        H(data) = MD5(data)\n     and\n     \
    \   KD(secret, data) = H(concat(secret, \":\", data))\n     i.e., the digest is\
    \ the MD5 of the secret concatenated with a colon\n     concatenated with the\
    \ data.\n"
- title: 2.1.2 The Authorization Request Header
  contents:
  - "2.1.2 The Authorization Request Header\n   The client is expected to retry the\
    \ request, passing an Authorization\n   header line, which is defined as follows.\n"
- title: Authorization       = "Authorization" ":" "Digest" digest-response
  contents:
  - 'Authorization       = "Authorization" ":" "Digest" digest-response

    '
- title: digest-response     = 1#( username | realm | nonce | digest-uri |
  contents:
  - "digest-response     = 1#( username | realm | nonce | digest-uri |\n         \
    \                response | [ digest ] | [ algorithm ] |\n                   \
    \      opaque )\n"
- title: username            = "username" "=" username-value
  contents:
  - 'username            = "username" "=" username-value

    '
- title: username-value      = quoted-string
  contents:
  - 'username-value      = quoted-string

    '
- title: digest-uri          = "uri" "=" digest-uri-value
  contents:
  - 'digest-uri          = "uri" "=" digest-uri-value

    '
- title: digest-uri-value    = request-uri         ; As specified by HTTP/1.1
  contents:
  - 'digest-uri-value    = request-uri         ; As specified by HTTP/1.1

    '
- title: response            = "response" "=" response-digest
  contents:
  - 'response            = "response" "=" response-digest

    '
- title: digest             = "digest" "=" entity-digest
  contents:
  - 'digest             = "digest" "=" entity-digest

    '
- title: response-digest     = <"> *LHEX <">
  contents:
  - 'response-digest     = <"> *LHEX <">

    '
- title: entity-digest      = <"> *LHEX <">
  contents:
  - 'entity-digest      = <"> *LHEX <">

    '
- title: LHEX                = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" |
  contents:
  - "LHEX                = \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" |\
    \ \"7\" |\n                      \"8\" | \"9\" | \"a\" | \"b\" | \"c\" | \"d\"\
    \ | \"e\" | \"f\"\n   The definitions of response-digest and entity-digest above\
    \ indicate\n   the encoding for their values. The following definitions show how\
    \ the\n   value is computed:\n     response-digest     =\n          <\"> < KD\
    \ ( H(A1), unquoted nonce-value \":\" H(A2) > <\">\n     A1             = unquoted\
    \ username-value \":\" unquoted realm-value\n                                \
    \                \":\" password\n     password       = < user's password >\n \
    \    A2             = Method \":\" digest-uri-value\n   The \"username-value\"\
    \ field is a \"quoted-string\" as specified in\n   section 2.2 of the HTTP/1.1\
    \ specification [2].  However, the\n   surrounding quotation marks are removed\
    \ in forming the string A1.\n   Thus if the Authorization header includes the\
    \ fields\n    username=\"Mufasa\", realm=\"myhost@testrealm.com\"\n   and the\
    \ user Mufasa has password \"CircleOfLife\" then H(A1) would be\n   H(Mufasa:myhost@testrealm.com:CircleOfLife)\
    \ with no quotation marks\n   in the digested string.\n   No white space is allowed\
    \ in any of the strings to which the digest\n   function H() is applied unless\
    \ that white space exists in the quoted\n   strings or entity body whose contents\
    \ make up the string to be\n   digested.  For example, the string A1 in the illustrated\
    \ above must\n   be Mufasa:myhost@testrealm.com:CircleOfLife with no white space\
    \ on\n   either side of the colons.  Likewise, the other strings digested by\n\
    \   H() must not have white space on either side of the colons which\n   delimit\
    \ their fields unless that white space was in the quoted\n   strings or entity\
    \ body being digested.\n   \"Method\" is the HTTP request method as specified\
    \ in section 5.1 of\n   [2].  The \"request-uri\" value is the Request-URI from\
    \ the request\n   line as specified in section 5.1 of [2].  This may be \"*\"\
    , an\n   \"absoluteURL\" or an \"abs_path\" as specified in section 5.1.2 of [2],\n\
    \   but it MUST agree with the Request-URI. In particular, it MUST be an\n   \"\
    absoluteURL\" if the Request-URI is an \"absoluteURL\".\n   The authenticating\
    \ server must assure that the document designated by\n   the \"uri\" parameter\
    \ is the same as the document served.  The purpose\n   of duplicating information\
    \ from the request URL in this field is to\n   deal with the possibility that\
    \ an intermediate proxy may alter the\n   client's request.  This altered (but\
    \ presumably semantically\n   equivalent) request would not result in the same\
    \ digest as that\n   calculated by the client.\n   The optional \"digest\" field\
    \ contains a digest of the entity body and\n   some of the associated entity headers.\
    \  This digest can be useful in\n   both request and response transactions.  In\
    \ a request it can insure\n   the integrity of POST data or data being PUT to\
    \ the server.  In a\n   response it insures the integrity of the served document.\
    \  The value\n   of the \"digest\" field is an <entity-digest> which is defined\
    \ as\n   follows.\n"
- title: entity-digest = <"> KD (H(A1), unquoted nonce-value ":" Method ":"
  contents:
  - "entity-digest = <\"> KD (H(A1), unquoted nonce-value \":\" Method \":\"\n   \
    \                        date \":\" entity-info \":\" H(entity-body)) <\">\n \
    \      ; format is <\"> *LHEX <\">\n"
- title: date = = rfc1123-date            ; see section 3.3.1 of [2]
  contents:
  - 'date = = rfc1123-date            ; see section 3.3.1 of [2]

    '
- title: entity-info = H(
  contents:
  - "entity-info = H(\n          digest-uri-value \":\"\n          media-type \":\"\
    \         ; Content-type, see section 3.7 of [2]\n          *DIGIT \":\"     \
    \        ; Content length, see 10.12 of [2]\n          content-coding \":\"  \
    \   ; Content-encoding, see 3.5 of [2]\n          last-modified \":\"      ; last\
    \ modified date, see 10.25 of [2]\n          expires                ; expiration\
    \ date; see 10.19 of [2]\n          )\n"
- title: last-modified   = rfc1123-date  ; see section 3.3.1 of [2]
  contents:
  - 'last-modified   = rfc1123-date  ; see section 3.3.1 of [2]

    '
- title: expires         = rfc1123-date
  contents:
  - "expires         = rfc1123-date\n   The entity-info elements incorporate the values\
    \ of the URI used to\n   request the entity as well as the associated entity headers\
    \ Content-\n   type, Content-length, Content-encoding, Last-modified, and Expires.\n\
    \   These headers are all end-to-end headers (see section 13.5.1 of [2])\n   which\
    \ must not be modified by proxy caches.  The \"entity-body\" is as\n   specified\
    \ by section 10.13 of [2] or RFC 1864.\n   Note that not all entities will have\
    \ an associated URI or all of\n   these headers.  For example, an entity which\
    \ is the data of a POST\n   request will typically not have a digest-uri-value\
    \ or Last-modified\n   or Expires headers.  If an entity does not have a digest-uri-value\
    \ or\n   a header corresponding to one of the entity-info fields, then that\n\
    \   field is left empty in the computation of entity-info.  All the\n   colons\
    \ specified above are present, however.  For example the value\n   of the entity-info\
    \ associated with POST data which has content-type\n   \"text/plain\", no content-encoding\
    \ and a length of 255 bytes would be\n   H(:text/plain:255:::).  Similarly a request\
    \ may not have a \"Date\"\n   header.  In this case the date field of the entity-digest\
    \ should be\n   empty.\n   In the entity-info and entity-digest computations,\
    \ except for the\n   blank after the comma in \"rfc1123-date\", there must be\
    \ no white space\n   between \"words\" and \"tspecials\", and exactly one blank\
    \ between\n   \"words\" (see section 2.2 of [2]).\n   Implementors should be aware\
    \ of how authenticated transactions\n   interact with proxy caches.  The HTTP/1.1\
    \ protocol specifies that\n   when a shared cache (see section 13.10 of [2]) has\
    \ received a request\n   containing an Authorization header and a response from\
    \ relaying that\n   request, it MUST NOT return that response as a reply to any\
    \ other\n   request, unless one of two Cache-control (see section 14.9 of [2])\n\
    \   directives was present in the response.  If the original response\n   included\
    \ the \"must-revalidate\" Cache-control directive, the cache MAY\n   use the entity\
    \ of that response in replying to a subsequent request,\n   but MUST first revalidate\
    \ it with the origin server, using the\n   request headers from the new request\
    \ to allow the origin server to\n   authenticate the new request.  Alternatively,\
    \ if the original\n   response included the \"public\" Cache-control directive,\
    \ the response\n   entity MAY be returned in reply to any subsequent request.\n"
- title: 2.1.3 The AuthenticationInfo Header
  contents:
  - "2.1.3 The AuthenticationInfo Header\n   When authentication succeeds, the Server\
    \ may optionally provide a\n   Authentication-info header indicating that the\
    \ server wants to\n   communicate some information regarding the successful authentication\n\
    \   (such as an entity digest or a new nonce to be used for the next\n   transaction).\
    \  It has two fields, digest and nextnonce.  Both are\n   optional.\n    AuthenticationInfo\
    \ = \"Authentication-info\" \":\"\n                                      1#( digest\
    \ | nextnonce )\n    nextnonce      = \"nextnonce\" \"=\" nonce-value\n    digest\
    \ = \"digest\" \"=\" entity-digest\n   The optional digest allows the client to\
    \ verify that the body of the\n   response has not been changed en-route.  The\
    \ server would probably\n   only send this when it has the document and can compute\
    \ it.  The\n   server would probably not bother generating this header for CGI\n\
    \   output.  The value of the \"digest\" is an <entity-digest> which is\n   computed\
    \ as described above.\n   The value of the nextnonce parameter is the nonce the\
    \ server wishes\n   the client to use for the next authentication response.  Note\
    \ that\n   either field is optional.  In particular the server may send the\n\
    \   Authentication-info header with only the nextnonce field as a means\n   of\
    \ implementing one-time nonces.  If the nextnonce field is present\n   the client\
    \ is strongly encouraged to use it for the next WWW-\n   Authenticate header.\
    \  Failure of the client to do so may result in a\n   request to re-authenticate\
    \ from the server with the \"stale=TRUE.\"\n"
- title: 2.2 Digest Operation
  contents:
  - "2.2 Digest Operation\n   Upon receiving the Authorization header, the server\
    \ may check its\n   validity by looking up its known password which corresponds\
    \ to the\n   submitted username.  Then, the server must perform the same MD5\n\
    \   operation performed by the client, and compare the result to the\n   given\
    \ response-digest.\n   Note that the HTTP server does not actually need to know\
    \ the user's\n   clear text password.  As long as H(A1) is available to the server,\n\
    \   the validity of an Authorization header may be verified.\n   A client may\
    \ remember the username, password and nonce values, so\n   that future requests\
    \ within the specified <domain> may include the\n   Authorization header preemptively.\
    \  The server may choose to accept\n   the old Authorization header information,\
    \ even though the nonce value\n   included might not be fresh. Alternatively,\
    \ the server could return a\n   401 response with a new nonce value, causing the\
    \ client to retry the\n   request.  By specifying stale=TRUE with this response,\
    \ the server\n   hints to the client that the request should be retried with the\
    \ new\n   nonce, without reprompting the user for a new username and password.\n\
    \   The opaque data is useful for transporting state information around.\n   For\
    \ example, a server could be responsible for authenticating content\n   which\
    \ actually sits on another server.  The first 401 response would\n   include a\
    \ domain field which includes the URI on the second server,\n   and the opaque\
    \ field for specifying state information.  The client\n   will retry the request,\
    \ at which time the server may respond with a\n   301/302 redirection, pointing\
    \ to the URI on the second server.  The\n   client will follow the redirection,\
    \ and pass the same Authorization\n   header, including the <opaque> data which\
    \ the second server may\n   require.\n   As with the basic scheme, proxies must\
    \ be completely transparent in\n   the Digest access authentication scheme. That\
    \ is, they must forward\n   the WWW-Authenticate, Authentication-info and Authorization\
    \ headers\n   untouched. If a proxy wants to authenticate a client before a request\n\
    \   is forwarded to the server, it can be done using the Proxy-\n   Authenticate\
    \ and Proxy-Authorization headers described in section 2.5\n   below.\n"
- title: 2.3 Security Protocol Negotiation
  contents:
  - "2.3 Security Protocol Negotiation\n   It is useful for a server to be able to\
    \ know which security schemes a\n   client is capable of handling.\n   If this\
    \ proposal is accepted as a required part of the HTTP/1.1\n   specification, then\
    \ a server may assume Digest support when a client\n   identifies itself as HTTP/1.1\
    \ compliant.\n   It is possible that a server may want to require Digest as its\n\
    \   authentication method, even if the server does not know that the\n   client\
    \ supports it.  A client is encouraged to fail gracefully if the\n   server specifies\
    \ any authentication scheme it cannot handle.\n"
- title: 2.4 Example
  contents:
  - "2.4 Example\n   The following example assumes that an access-protected document\
    \ is\n   being requested from the server.  The URI of the document is\n   \"http://www.nowhere.org/dir/index.html\"\
    .  Both client and server know\n   that the username for this document is \"Mufasa\"\
    , and the password is\n   \"CircleOfLife\".\n   The first time the client requests\
    \ the document, no Authorization\n   header is sent, so the server responds with:\n"
- title: HTTP/1.1 401 Unauthorized
  contents:
  - 'HTTP/1.1 401 Unauthorized

    '
- title: 'WWW-Authenticate: Digest    realm="testrealm@host.com",'
  contents:
  - "WWW-Authenticate: Digest    realm=\"testrealm@host.com\",\n                 \
    \           nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\",\n                  \
    \          opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"\n  The client may prompt\
    \ the user for the username and password, after\n  which it will respond with\
    \ a new request, including the following\n  Authorization header:\n"
- title: 'Authorization: Digest       username="Mufasa",'
  contents:
  - "Authorization: Digest       username=\"Mufasa\",\n                          \
    \  realm=\"testrealm@host.com\",\n                            nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\"\
    ,\n                            uri=\"/dir/index.html\",\n                    \
    \        response=\"e966c932a9242554e42c8ee200cec7f6\",\n                    \
    \        opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"\n"
- title: 2.5 Proxy-Authentication and Proxy-Authorization
  contents:
  - "2.5 Proxy-Authentication and Proxy-Authorization\n   The digest authentication\
    \ scheme may also be used for authenticating\n   users to proxies, proxies to\
    \ proxies, or proxies to end servers by\n   use of the Proxy-Authenticate and\
    \ Proxy-Authorization headers. These\n   headers are instances of the general\
    \ Proxy-Authenticate and Proxy-\n   Authorization headers specified in sections\
    \ 10.30 and 10.31 of the\n   HTTP/1.1 specification [2] and their behavior is\
    \ subject to\n   restrictions described there.  The transactions for proxy\n \
    \  authentication are very similar to those already described.  Upon\n   receiving\
    \ a request which requires authentication, the proxy/server\n   must issue the\
    \ \"HTTP/1.1 401 Unauthorized\" header followed by a\n   \"Proxy-Authenticate\"\
    \ header of the form\n     Proxy-Authentication     = \"Proxy-Authentication\"\
    \ \":\" \"Digest\"\n                                   digest-challenge\n   where\
    \ digest-challenge is as defined above in section 2.1. The\n   client/proxy must\
    \ then re-issue the request with a Proxy-Authenticate\n   header of the form\n\
    \     Proxy-Authorization      = \"Proxy-Authorization\" \":\"\n             \
    \                      digest-response\n   where digest-response is as defined\
    \ above in section 2.1. When\n   authentication succeeds, the Server may optionally\
    \ provide a Proxy-\n   Authentication-info header of the form\n"
- title: Proxy-Authentication-info = "Proxy-Authentication-info" ":" nextnonce
  contents:
  - "Proxy-Authentication-info = \"Proxy-Authentication-info\" \":\" nextnonce\n \
    \  where nextnonce has the same semantics as the nextnonce field in the\n   Authentication-info\
    \ header described above in section 2.1.\n   Note that in principle a client could\
    \ be asked to authenticate itself\n   to both a proxy and an end-server.  It might\
    \ receive an \"HTTP/1.1 401\n   Unauthorized\" header followed by both a WWW-Authenticate\
    \ and a\n   Proxy-Authenticate header.  However, it can never receive more than\n\
    \   one Proxy-Authenticate header since such headers are only for\n   immediate\
    \ connections and must not be passed on by proxies.  If the\n   client receives\
    \ both headers, it must respond with both the\n   Authorization and Proxy-Authorization\
    \ headers as described above,\n   which will likely involve different combinations\
    \ of username,\n   password, nonce, etc.\n"
- title: 3. Security Considerations
  contents:
  - "3. Security Considerations\n   Digest Authentication does not provide a strong\
    \ authentication\n   mechanism.  That is not its intent.  It is intended solely\
    \ to replace\n   a much weaker and even more dangerous authentication mechanism:\
    \ Basic\n   Authentication.  An important design constraint is that the new\n\
    \   authentication scheme be free of patent and export restrictions.\n   Most\
    \ needs for secure HTTP transactions cannot be met by Digest\n   Authentication.\
    \  For those needs SSL or SHTTP are more appropriate\n   protocols.  In particular\
    \ digest authentication cannot be used for\n   any transaction requiring encrypted\
    \ content.  Nevertheless many\n   functions remain for which digest authentication\
    \ is both useful and\n   appropriate.\n"
- title: 3.1 Comparison with Basic Authentication
  contents:
  - "3.1 Comparison with Basic Authentication\n   Both Digest and Basic Authentication\
    \ are very much on the weak end of\n   the security strength spectrum. But a comparison\
    \ between the two\n   points out the utility, even necessity, of replacing Basic\
    \ by Digest.\n   The greatest threat to the type of transactions for which these\n\
    \   protocols are used is network snooping.  This kind of transaction\n   might\
    \ involve, for example, online access to a database whose use is\n   restricted\
    \ to paying subscribers.  With Basic authentication an\n   eavesdropper can obtain\
    \ the password of the user.  This not only\n   permits him to access anything\
    \ in the database, but, often worse,\n   will permit access to anything else the\
    \ user protects with the same\n   password.\n   By contrast, with Digest Authentication\
    \ the eavesdropper only gets\n   access to the transaction in question and not\
    \ to the user's password.\n   The information gained by the eavesdropper would\
    \ permit a replay\n   attack, but only with a request for the same document, and\
    \ even that\n   might be difficult.\n"
- title: 3.2 Replay Attacks
  contents:
  - "3.2 Replay Attacks\n   A replay attack against digest authentication would usually\
    \ be\n   pointless for a simple GET request since an eavesdropper would\n   already\
    \ have seen the only document he could obtain with a replay.\n   This is because\
    \ the URI of the requested document is digested in the\n   client response and\
    \ the server will only deliver that document. By\n   contrast under Basic Authentication\
    \ once the eavesdropper has the\n   user's password, any document protected by\
    \ that password is open to\n   him.  A GET request containing form data could\
    \ only be \"replayed\"\n   with the identical data.  However, this could be problematic\
    \ if it\n   caused a CGI script to take some action on the server.\n   Thus, for\
    \ some purposes, it is necessary to protect against replay\n   attacks.  A good\
    \ digest implementation can do this in various ways.\n   The server created \"\
    nonce\" value is implementation dependent, but if\n   it contains a digest of\
    \ the client IP, a time-stamp, and a private\n   server key (as recommended above)\
    \ then a replay attack is not simple.\n   An attacker must convince the server\
    \ that the request is coming from\n   a false IP address and must cause the server\
    \ to deliver the document\n   to an IP address different from the address to which\
    \ it believes it\n   is sending the document.  An attack can only succeed in the\
    \ period\n   before the time-stamp expires.  Digesting the client IP and time-\n\
    \   stamp in the nonce permits an implementation which does not maintain\n   state\
    \ between transactions.\n   For applications where no possibility of replay attack\
    \ can be\n   tolerated the server can use one-time response digests which will\
    \ not\n   be honored for a second use.  This requires the overhead of the\n  \
    \ server remembering which digests have been used until the nonce\n   time-stamp\
    \ (and hence the digest built with it) has expired, but it\n   effectively protects\
    \ against replay attacks. Instead of maintaining a\n   list of the values of used\
    \ digests, a server would hash these values\n   and require re-authentication\
    \ whenever a hash collision occurs.\n   An implementation must give special attention\
    \ to the possibility of\n   replay attacks with POST and PUT requests.  A successful\
    \ replay\n   attack could result in counterfeit form data or a counterfeit version\n\
    \   of a PUT file.  The use of one-time digests or one-time nonces is\n   recommended.\
    \  It is also recommended that the optional <digest> be\n   implemented for use\
    \ with POST or PUT requests to assure the integrity\n   of the posted data.  Alternatively,\
    \ a server may choose to allow\n   digest authentication only with GET requests.\
    \ Responsible server\n   implementors will document the risks described here as\
    \ they pertain\n   to a given implementation.\n"
- title: 3.3 Man in the Middle
  contents:
  - "3.3 Man in the Middle\n   Both Basic and Digest authentication are vulnerable\
    \ to \"man in the\n   middle\" attacks, for example, from a hostile or compromised\
    \ proxy.\n   Clearly, this would present all the problems of eavesdropping.  But\n\
    \   it could also offer some additional threats.\n   A simple but effective attack\
    \ would be to replace the Digest\n   challenge with a Basic challenge, to spoof\
    \ the client into revealing\n   their password. To protect against this attack,\
    \ clients should\n   remember if a site has used Digest authentication in the\
    \ past, and\n   warn the user if the site stops using it. It might also be a good\n\
    \   idea for the browser to be configured to demand Digest authentication\n  \
    \ in general, or from specific sites.\n   Or, a hostile proxy might spoof the\
    \ client into making a request the\n   attacker wanted rather than one the client\
    \ wanted.  Of course, this\n   is still much harder than a comparable attack against\
    \ Basic\n   Authentication.\n   There are several attacks on the \"digest\" field\
    \ in the\n   Authentication-info header.  A simple but effective attack is just\
    \ to\n   remove the field, so that the client will not be able to use it to\n\
    \   detect modifications to the response entity. Sensitive applications\n   may\
    \ wish to allow configuration to require that the digest field be\n   present\
    \ when appropriate. More subtly, the attacker can alter any of\n   the entity-headers\
    \ not incorporated in the computation of the digest,\n   The attacker can alter\
    \ most of the request headers in the client's\n   request, and can alter any response\
    \ header in the origin-server's\n   reply, except those headers whose values are\
    \ incorporated into the\n   \"digest\" field.\n   Alteration of Accept* or User-Agent\
    \ request headers can only result\n   in a denial of service attack that returns\
    \ content in an unacceptable\n   media type or language. Alteration of cache control\
    \ headers also can\n   only result in denial of service. Alteration of Host will\
    \ be\n   detected, if the full URL is in the response-digest. Alteration of\n\
    \   Referer or From is not important, as these are only hints.\n"
- title: 3.4 Spoofing by Counterfeit Servers
  contents:
  - "3.4 Spoofing by Counterfeit Servers\n   Basic Authentication is vulnerable to\
    \ spoofing by counterfeit\n   servers. If a user can be led to believe that she\
    \ is connecting to a\n   host containing information protected by a password she\
    \ knows, when\n   in fact she is connecting to a hostile server, then the hostile\n\
    \   server can request a password, store it away for later use, and feign\n  \
    \ an error.  This type of attack is more difficult with Digest\n   Authentication\
    \ -- but the client must know to demand that Digest\n   authentication be used,\
    \ perhaps using some of the techniques\n   described above to counter \"man-in-the-middle\"\
    \ attacks.\n"
- title: 3.5 Storing passwords
  contents:
  - "3.5 Storing passwords\n   Digest authentication requires that the authenticating\
    \ agent (usually\n   the server) store some data derived from the user's name\
    \ and password\n   in a \"password file\" associated with a given realm.  Normally\
    \ this\n   might contain pairs consisting of username and H(A1), where H(A1) is\n\
    \   the digested value of the username, realm, and password as described\n   above.\n\
    \   The security implications of this are that if this password file is\n   compromised,\
    \ then an attacker gains immediate access to documents on\n   the server using\
    \ this realm.  Unlike, say a standard UNIX password\n   file, this information\
    \ need not be decrypted in order to access\n   documents in the server realm associated\
    \ with this file.  On the\n   other hand, decryption, or more likely a brute force\
    \ attack, would be\n   necessary to obtain the user's password.  This is the reason\
    \ that the\n   realm is part of the digested data stored in the password file.\
    \  It\n   means that if one digest authentication password file is compromised,\n\
    \   it does not automatically compromise others with the same username\n   and\
    \ password (though it does expose them to brute force attack).\n   There are two\
    \ important security consequences of this.  First the\n   password file must be\
    \ protected as if it contained unencrypted\n   passwords, because for the purpose\
    \ of accessing documents in its\n   realm, it effectively does.\n   A second consequence\
    \ of this is that the realm string should be\n   unique among all realms which\
    \ any single user is likely to use.  In\n   particular a realm string should include\
    \ the name of the host doing\n   the authentication.  The inability of the client\
    \ to authenticate the\n   server is a weakness of Digest Authentication.\n"
- title: 3.6 Summary
  contents:
  - "3.6 Summary\n   By modern cryptographic standards Digest Authentication is weak.\
    \  But\n   for a large range of purposes it is valuable as a replacement for\n\
    \   Basic Authentication.  It remedies many, but not all, weaknesses of\n   Basic\
    \ Authentication.  Its strength may vary depending on the\n   implementation.\
    \  In particular the structure of the nonce (which is\n   dependent on the server\
    \ implementation) may affect the ease of\n   mounting a replay attack.  A range\
    \ of server options is appropriate\n   since, for example, some implementations\
    \ may be willing to accept the\n   server overhead of one-time nonces or digests\
    \ to eliminate the\n   possibility of replay while others may satisfied with a\
    \ nonce like\n   the one recommended above restricted to a single IP address and\
    \ with\n   a limited lifetime.\n   The bottom line is that *any* compliant implementation\
    \ will be\n   relatively weak by cryptographic standards, but *any* compliant\n\
    \   implementation will be far superior to Basic Authentication.\n"
- title: 4.  Acknowledgments
  contents:
  - "4.  Acknowledgments\n   In addition to the authors, valuable discussion instrumental\
    \ in\n   creating this document has come from Peter J. Churchyard, Ned Freed,\n\
    \   and David M. Kristol.\n"
- title: 5. References
  contents:
  - "5. References\n   [1]  Berners-Lee, T.,  Fielding, R., and H. Frystyk,\n    \
    \    \"Hypertext Transfer Protocol -- HTTP/1.0\",\n        RFC 1945, May 1996.\n\
    \   [2]  Berners-Lee, T., Fielding, R., and H. Frystyk,\n        \"Hypertext Transfer\
    \ Protocol -- HTTP/1.1\"\n        RFC 2068, January 1997.\n   [3]  Rivest, R.,\
    \ \"The MD5 Message-Digest Algorithm\",\n        RFC 1321, April 1992.\n"
- title: 6. Authors' Addresses
  contents:
  - "6. Authors' Addresses\n   John Franks\n   Professor of Mathematics\n   Department\
    \ of Mathematics\n   Northwestern University\n   Evanston, IL 60208-2730, USA\n\
    \   EMail: john@math.nwu.edu\n   Phillip M. Hallam-Baker\n   European Union Fellow\n\
    \   CERN\n   Geneva\n   Switzerland\n   EMail: hallam@w3.org\n   Jeffery L. Hostetler\n\
    \   Senior Software Engineer\n   Spyglass, Inc.\n   3200 Farber Drive\n   Champaign,\
    \ IL  61821, USA\n   EMail: jeff@spyglass.com\n   Paul J. Leach\n   Microsoft\
    \ Corporation\n   1 Microsoft Way\n   Redmond, WA 98052, USA\n   EMail: paulle@microsoft.com\n\
    \   Ari Luotonen\n   Member of Technical Staff\n   Netscape Communications Corporation\n\
    \   501 East Middlefield Road\n   Mountain View, CA 94043, USA\n   EMail: luotonen@netscape.com\n\
    \   Eric W. Sink\n   Senior Software Engineer\n   Spyglass, Inc.\n   3200 Farber\
    \ Drive\n   Champaign, IL  61821, USA\n   EMail: eric@spyglass.com\n   Lawrence\
    \ C. Stewart\n   Open Market, Inc.\n   215 First Street\n   Cambridge, MA  02142,\
    \ USA\n   EMail: stewart@OpenMarket.com\n"
