- title: __initial_text__
  contents:
  - ''
- title: Independent Submission                                       D. Ovsienko
  contents:
  - "Independent Submission                                       D. Ovsienko\n  \
    \          Babel Hashed Message Authentication Code (HMAC)\n                 \
    \     Cryptographic Authentication\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes a cryptographic authentication mechanism\
    \ for\n   the Babel routing protocol.  This document updates RFC 6126.  The\n\
    \   mechanism allocates two new TLV types for the authentication data,\n   uses\
    \ Hashed Message Authentication Code (HMAC), and is both optional\n   and backward\
    \ compatible.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for examination, experimental implementation, and\n   evaluation.\n\
    \   This document defines an Experimental Protocol for the Internet\n   community.\
    \  This is a contribution to the RFC Series, independently\n   of any other RFC\
    \ stream.  The RFC Editor has chosen to publish this\n   document at its discretion\
    \ and makes no statement about its value for\n   implementation or deployment.\
    \  Documents approved for publication by\n   the RFC Editor are not a candidate\
    \ for any level of Internet\n   Standard; see Section 2 of RFC 5741.\n   Information\
    \ about the current status of this document, any errata,\n   and how to provide\
    \ feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7298.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2014 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \      1.1. Requirements Language ......................................5\n  \
    \ 2. Cryptographic Aspects ...........................................5\n    \
    \  2.1. Mandatory-to-Implement and Optional Hash Algorithms ........5\n      2.2.\
    \ Definition of Padding ......................................6\n      2.3. Cryptographic\
    \ Sequence Number Specifics ....................8\n      2.4. Definition of HMAC\
    \ .........................................9\n   3. Updates to Protocol Data Structures\
    \ ............................11\n      3.1. RxAuthRequired ............................................11\n\
    \      3.2. LocalTS ...................................................11\n  \
    \    3.3. LocalPC ...................................................11\n    \
    \  3.4. MaxDigestsIn ..............................................11\n      3.5.\
    \ MaxDigestsOut .............................................12\n      3.6. ANM\
    \ Table .................................................12\n      3.7. ANM Timeout\
    \ ...............................................13\n      3.8. Configured Security\
    \ Associations ..........................14\n      3.9. Effective Security Associations\
    \ ...........................16\n   4. Updates to Protocol Encoding ...................................17\n\
    \      4.1. Justification .............................................17\n  \
    \    4.2. TS/PC TLV .................................................19\n    \
    \  4.3. HMAC TLV ..................................................20\n   5. Updates\
    \ to Protocol Operation ..................................21\n      5.1. Per-Interface\
    \ TS/PC Number Updates ........................21\n      5.2. Deriving ESAs from\
    \ CSAs ...................................23\n      5.3. Updates to Packet Sending\
    \ .................................25\n      5.4. Updates to Packet Receiving\
    \ ...............................28\n      5.5. Authentication-Specific Statistics\
    \ Maintenance ............30\n   6. Implementation Notes ...........................................31\n\
    \      6.1. Source Address Selection for Sending ......................31\n  \
    \    6.2. Output Buffer Management ..................................31\n    \
    \  6.3. Optimizations of Deriving Procedure for ESAs ..............32\n      6.4.\
    \ Duplication of Security Associations ......................33\n   7. Network\
    \ Management Aspects .....................................34\n      7.1. Backward\
    \ Compatibility ....................................34\n      7.2. Multi-Domain\
    \ Authentication ...............................35\n      7.3. Migration to and\
    \ from Authenticated Exchange ..............36\n      7.4. Handling of Authentication\
    \ Key Exhaustion .................37\n   8. Security Considerations ........................................38\n\
    \   9. IANA Considerations ............................................43\n  \
    \ 10. Acknowledgements ..............................................43\n   11.\
    \ References ....................................................44\n      11.1.\
    \ Normative References .....................................44\n      11.2. Informative\
    \ References ...................................44\n   Appendix A. Figures and\
    \ Tables ....................................47\n   Appendix B. Test Vectors ..........................................52\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Authentication of routing protocol exchanges is a common\
    \ means of\n   securing computer networks.  The use of protocol authentication\n\
    \   mechanisms helps in ascertaining that only the intended routers\n   participate\
    \ in routing information exchange and that the exchanged\n   routing information\
    \ is not modified by a third party.\n   [BABEL] (\"the original specification\"\
    ) defines data structures,\n   encoding, and the operation of a basic Babel routing\
    \ protocol\n   instance (\"instance of the original protocol\").  This document\
    \ (\"this\n   specification\") defines data structures, encoding, and the operation\n\
    \   of an extension to the Babel protocol -- an authentication mechanism\n   (\"\
    this mechanism\").  Both the instance of the original protocol and\n   this mechanism\
    \ are mostly self-contained and interact only at\n   coupling points defined in\
    \ this specification.\n   A major design goal of this mechanism is transparency\
    \ to operators\n   that is not affected by implementation and configuration specifics.\n\
    \   A complying implementation makes all meaningful details of\n   authentication-specific\
    \ processing clear to the operator, even when\n   some of the operational parameters\
    \ cannot be changed.\n   The currently established (see [RIP2-AUTH], [OSPF2-AUTH],\n\
    \   [ISIS-AUTH-A], [RFC6039], and [OSPF3-AUTH-BIS]) approach to an\n   authentication\
    \ mechanism design for datagram-based routing protocols\n   such as Babel relies\
    \ on two principal data items embedded into\n   protocol packets, typically as\
    \ two integral parts of a single data\n   structure:\n   o  A fixed-length unsigned\
    \ integer, typically called a cryptographic\n      sequence number, used in replay\
    \ attack protection.\n   o  A variable-length sequence of octets, a result of\
    \ the Hashed\n      Message Authentication Code (HMAC) construction (see [RFC2104])\n\
    \      computed on meaningful data items of the packet (including the\n      cryptographic\
    \ sequence number) on one hand and a secret key on the\n      other, used in proving\
    \ that both the sender and the receiver share\n      the same secret key and that\
    \ the meaningful data was not changed\n      in transmission.\n   Depending on\
    \ the design specifics, either all protocol packets or\n   only those packets\
    \ protecting the integrity of protocol exchange are\n   authenticated.  This mechanism\
    \ authenticates all protocol packets.\n   Although the HMAC construction is just\
    \ one of many possible\n   approaches to cryptographic authentication of packets,\
    \ this mechanism\n   makes use of relevant prior experience by using HMAC as well,\
    \ and its\n   solution space correlates with the solution spaces of the mechanisms\n\
    \   above.  At the same time, it allows for a future extension that\n   treats\
    \ HMAC as a particular case of a more generic mechanism.\n   Practical experience\
    \ with the mechanism defined herein should be\n   useful in designing such a future\
    \ extension.\n   This specification defines the use of the cryptographic sequence\n\
    \   number in detail sufficient to make replay attack protection strength\n  \
    \ predictable.  That is, an operator can tell the strength from the\n   declared\
    \ characteristics of an implementation and, if the\n   implementation allows the\
    \ changing of relevant parameters, the effect\n   of a reconfiguration as well.\n\
    \   This mechanism explicitly allows for multiple HMAC results per\n   authenticated\
    \ packet.  Since meaningful data items of a given packet\n   remain the same,\
    \ each such HMAC result stands for a different secret\n   key and/or a different\
    \ hash algorithm.  This enables a simultaneous,\n   independent authentication\
    \ within multiple domains.  This\n   specification is not novel in this regard;\
    \ for example, the Layer 2\n   Tunneling Protocol (L2TPv3) allows for one or two\
    \ results per\n   authenticated packet ([RFC3931] Section 5.4.1), and Mobile Ad\
    \ Hoc\n   Network (MANET) protocols allow for several ([RFC7183] Section 6.1).\n\
    \   An important concern addressed by this mechanism is limiting the\n   amount\
    \ of HMAC computations done per authenticated packet,\n   independently for sending\
    \ and receiving.  Without these limits, the\n   number of computations per packet\
    \ could be as high as the number of\n   configured authentication keys (in the\
    \ sending case) or as high as\n   the number of keys multiplied by the number\
    \ of supplied HMAC results\n   (in the receiving case).\n   These limits establish\
    \ a basic competition between the configured\n   keys and (in the receiving case)\
    \ an additional competition between\n   the supplied HMAC results.  This specification\
    \ defines related data\n   structures and procedures in a way to make such competition\n\
    \   transparent and predictable for an operator.\n   Wherever this specification\
    \ mentions the operator reading or changing\n   a particular data structure, variable,\
    \ parameter, or event counter\n   \"at runtime\", it is up to the implementor\
    \ how this is to be done.\n   For example, the implementation can employ an interactive\
    \ command\n   line interface (CLI), a management protocol such as the Simple\n\
    \   Network Management Protocol (SNMP), a means of inter-process\n   communication\
    \ such as a local socket, or a combination of these.\n"
- title: 1.1.  Requirements Language
  contents:
  - "1.1.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in BCP 14 [RFC2119].\n"
- title: 2.  Cryptographic Aspects
  contents:
  - '2.  Cryptographic Aspects

    '
- title: 2.1.  Mandatory-to-Implement and Optional Hash Algorithms
  contents:
  - "2.1.  Mandatory-to-Implement and Optional Hash Algorithms\n   [RFC2104] defines\
    \ HMAC as a construction that can use any\n   cryptographic hash algorithm with\
    \ a known digest length and internal\n   block size.  This specification preserves\
    \ this property of HMAC by\n   defining data processing that itself does not depend\
    \ on any\n   particular hash algorithm either.  However, since this mechanism\
    \ is a\n   protocol extension case, there are relevant design considerations to\n\
    \   take into account.\n   Section 4.5 of [RFC6709] suggests selecting one hash\
    \ algorithm as\n   mandatory to implement for the purpose of global interoperability\n\
    \   (Section 3.2 of [RFC6709]) and selecting another of distinct lineage\n   as\
    \ recommended for implementation for the purpose of cryptographic\n   agility.\
    \  This specification makes the latter property guaranteed,\n   rather than probable,\
    \ through an elevation of the requirement level.\n   There are two mandatory-to-implement\
    \ hash algorithms; each is\n   unambiguously defined and generally available in\
    \ multiple\n   implementations.\n   An implementation of this mechanism MUST include\
    \ support for two hash\n   algorithms:\n   o  RIPEMD-160 (160-bit digest)\n  \
    \ o  SHA-1 (160-bit digest)\n   Besides that, an implementation of this mechanism\
    \ MAY include support\n   for additional hash algorithms, provided each such algorithm\
    \ is\n   publicly and openly specified and its digest length is 128 bits or\n\
    \   more (to meet the constraint implied in Section 2.2).  Implementors\n   SHOULD\
    \ consider strong, well-known hash algorithms as additional\n   implementation\
    \ options and MUST NOT consider a hash algorithm if\n   meaningful attacks exist\
    \ for it or it is commonly viewed as\n   deprecated.\n   In the latter case, it\
    \ is important to take into account\n   considerations both common (such as those\
    \ made in [RFC4270]) and\n   specific to the HMAC application of the hash algorithm.\
    \  For example,\n   [RFC6151] considers MD5 collisions and concludes that new\
    \ protocol\n   designs should not use HMAC-MD5, while [RFC6194] includes a\n \
    \  comparable analysis of SHA-1 that finds HMAC-SHA-1 secure for the\n   same\
    \ purpose.\n   For example, the following hash algorithms meet these requirements\
    \ at\n   the time of this writing (in alphabetical order):\n   o  GOST R 34.11-94\
    \ (256-bit digest)\n   o  SHA-224 (224-bit digest, SHA-2 family)\n   o  SHA-256\
    \ (256-bit digest, SHA-2 family)\n   o  SHA-384 (384-bit digest, SHA-2 family)\n\
    \   o  SHA-512 (512-bit digest, SHA-2 family)\n   o  Tiger (192-bit digest)\n\
    \   o  Whirlpool (512-bit digest, 2nd rev., 2003)\n   The set of hash algorithms\
    \ available in an implementation MUST be\n   clearly stated.  When known weak\
    \ authentication keys exist for a hash\n   algorithm used in the HMAC construction,\
    \ an implementation MUST deny\n   the use of such keys.\n"
- title: 2.2.  Definition of Padding
  contents:
  - "2.2.  Definition of Padding\n   Many practical applications of HMAC for authentication\
    \ of datagram-\n   based network protocols (including routing protocols) involve\
    \ the\n   padding procedure, a design-specific conditioning of the message that\n\
    \   both the sender and the receiver perform before the HMAC computation.\n  \
    \ The specific padding procedure of this mechanism addresses the\n   following\
    \ needs:\n   o  Data Initialization\n      A design that places the HMAC result(s)\
    \ computed for a message\n      inside that same message after the computation\
    \ has to have\n      previously (i.e., before the computation) allocated in that\n\
    \      message some data unit(s) purposed specifically for those HMAC\n      result(s)\
    \ (in this mechanism, it is the HMAC TLV(s); see\n      Section 4.3).  The padding\
    \ procedure sets the respective octets of\n      the data unit(s), in the simplest\
    \ case to a fixed value known as\n      the padding constant.\n      The particular\
    \ value of the constant is specific to each design.\n      For instance, in [RIP2-AUTH]\
    \ as well as works derived from it\n      ([ISIS-AUTH-B], [OSPF2-AUTH], and [OSPF3-AUTH-BIS]),\
    \ the value is\n      0x878FE1F3.  In many other designs (for instance, [RFC3315],\n\
    \      [RFC3931], [RFC4030], [RFC4302], [RFC5176], and [ISIS-AUTH-A]),\n     \
    \ the value is 0x00.\n      However, the HMAC construction is defined on the basis\
    \ of a\n      cryptographic hash algorithm, that is, an algorithm meeting a\n\
    \      particular set of requirements made for any input message.  Thus,\n   \
    \   any padding constant values, whether single- or multiple-octet, as\n     \
    \ well as any other message-conditioning methods, don't affect\n      cryptographic\
    \ characteristics of the hash algorithm and the HMAC\n      construction, respectively.\n\
    \   o  Source Address Protection\n      In the specific case of datagram-based\
    \ routing protocols, the\n      protocol packet (that is, the message being authenticated)\
    \ often\n      does not include network-layer addresses, although the source and\n\
    \      (to a lesser extent) the destination address of the datagram may\n    \
    \  be meaningful in the scope of the protocol instance.\n      In Babel, the source\
    \ address may be used as a prefix next hop (see\n      Section 3.5.3 of [BABEL]).\
    \  A well-known (see Section 2.3 of\n      [OSPF3-AUTH-BIS]) solution to the source\
    \ address protection\n      problem is to set the first respective octets of the\
    \ data unit(s)\n      above to the source address (yet setting the rest of the\
    \ octets to\n      the padding constant).  This procedure adapts this solution\
    \ to the\n      specifics of Babel, which allows for the exchange of protocol\n\
    \      packets using both IPv4 and IPv6 datagrams (see Section 4 of\n      [BABEL]).\
    \  Even though in the case of IPv6 exchange a Babel\n      speaker currently uses\
    \ only link-local source addresses\n      (Section 3.1 of [BABEL]), this procedure\
    \ protects all octets of an\n      arbitrary given source address for the reasons\
    \ of future\n      extensibility.  The procedure implies that future Babel extensions\n\
    \      will never use an IPv4-mapped IPv6 address as a packet source\n      address.\n\
    \      This procedure does not protect the destination address, which is\n   \
    \   currently considered meaningless (Section 3.1 of [BABEL]) in the\n      same\
    \ scope.  A future extension that looks to add such protection\n      would likely\
    \ use a new TLV or sub-TLV to include the destination\n      address in the protocol\
    \ packet (see Section 4.1).\n   Description of the padding procedure:\n   1. \
    \ Set the first 16 octets of the Digest field of the given HMAC\n       TLV to:\n\
    \       *  the given source address, if it is an IPv6 address, or\n       *  the\
    \ IPv4-mapped IPv6 address (per Section 2.5.5.2 of\n          [RFC4291]) holding\
    \ the given source address, if it is an IPv4\n          address.\n   2.  Set the\
    \ remaining (TLV Length - 18) octets of the Digest field of\n       the given\
    \ HMAC TLV to 0x00 each.\n   For an example of a Babel packet with padded HMAC\
    \ TLVs, see Table 3\n   in Appendix A.\n"
- title: 2.3.  Cryptographic Sequence Number Specifics
  contents:
  - "2.3.  Cryptographic Sequence Number Specifics\n   The operation of this mechanism\
    \ may involve multiple local and\n   multiple remote cryptographic sequence numbers,\
    \ each essentially\n   being a 48-bit unsigned integer.  This specification uses\
    \ the term\n   \"TS/PC number\" to avoid confusion with the route's (Section 2.5\
    \ of\n   [BABEL]) or node's (Section 3.2.1 of [BABEL]) sequence numbers of the\n\
    \   original Babel specification and to stress the fact that there are\n   two\
    \ distinguished parts of this 48-bit number, each handled in its\n   specific\
    \ way (see Section 5.1):\n    0                   1     2 3                  \
    \ 4\n    0 1 2 3 4 5 6 7 8 9 0 //  9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\n   +-+-+-+-+-+-+-+-+-+-+-//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         TS         //         |              PC               |\n   +-+-+-+-+-+-+-+-+-+-//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                      //\n   The high-order 32 bits are called \"timestamp\"\
    \ (TS), and the low-order\n   16 bits are called \"packet counter\" (PC).\n  \
    \ This mechanism stores, updates, compares, and encodes each TS/PC\n   number\
    \ as two independent unsigned integers -- TS and PC,\n   respectively.  Such a\
    \ comparison of TS/PC numbers, as performed in\n   item 3 of Section 5.4, is algebraically\
    \ equivalent to a comparison of\n   the respective 48-bit unsigned integers. \
    \ Any byte order conversion,\n   when required, is performed on TS and PC parts\
    \ independently.\n"
- title: 2.4.  Definition of HMAC
  contents:
  - "2.4.  Definition of HMAC\n   The algorithm description below uses the following\
    \ nomenclature,\n   which is consistent with [FIPS-198]:\n   Text   The data on\
    \ which the HMAC is calculated (note item (b) of\n          Section 8).  In this\
    \ specification, it is the contents of a\n          Babel packet ranging from\
    \ the beginning of the Magic field of\n          the Babel packet header to the\
    \ end of the last octet of the\n          Packet Body field, as defined in Section\
    \ 4.2 of [BABEL] (see\n          Figure 2 in Appendix A).\n   H      The specific\
    \ hash algorithm (see Section 2.1).\n   K      A sequence of octets of an arbitrary,\
    \ known length.\n   Ko     The cryptographic key used with the hash algorithm.\n\
    \   B      The block size of H, measured in octets rather than bits.\n       \
    \   Note that B is the internal block size, not the digest length.\n   L     \
    \ The digest length of H, measured in octets rather than bits.\n   XOR    The\
    \ bitwise exclusive-or operation.\n   Opad   The hexadecimal value 0x5C repeated\
    \ B times.\n   Ipad   The hexadecimal value 0x36 repeated B times.\n   The algorithm\
    \ below is the original, unmodified HMAC construction as\n   defined in both [RFC2104]\
    \ and [FIPS-198]; hence, it is different from\n   the algorithms defined in [RIP2-AUTH],\
    \ [ISIS-AUTH-B], [OSPF2-AUTH],\n   and [OSPF3-AUTH-BIS] in exactly two regards:\n\
    \   o  The algorithm below sets the size of Ko to B, not to L (L is not\n    \
    \  greater than B).  This resolves both ambiguity in XOR expressions\n      and\
    \ incompatibility in the handling of keys that have length\n      greater than\
    \ L but not greater than B.\n   o  The algorithm below does not change the value\
    \ of Text before or\n      after the computation.  Padding a Babel packet before\
    \ the\n      computation and placing the result inside the packet are both\n \
    \     performed elsewhere.\n   The intent of this is to enable the most straightforward\
    \ use of\n   cryptographic libraries by implementations of this specification.\
    \  At\n   the time of this writing, implementations of the original HMAC\n   construction\
    \ coupled with hash algorithms of choice are generally\n   available.\n   Description\
    \ of the algorithm:\n   1.  Preparation of the Key\n       In this application,\
    \ Ko is always B octets long.  If K is B\n       octets long, then Ko is set to\
    \ K.  If K is more than B octets\n       long, then Ko is set to H(K) with the\
    \ necessary amount of zeroes\n       appended to the end of H(K), such that Ko\
    \ is B octets long.  If K\n       is less than B octets long, then Ko is set to\
    \ K with zeroes\n       appended to the end of K, such that Ko is B octets long.\n\
    \   2.  First-Hash\n       A First-Hash, also known as the inner hash, is computed\n\
    \       as follows:\n                    First-Hash = H(Ko XOR Ipad || Text)\n\
    \   3.  Second-Hash\n       A Second-Hash, also known as the outer hash, is computed\n\
    \       as follows:\n                 Second-Hash = H(Ko XOR Opad || First-Hash)\n\
    \   4.  Result\n       The resulting Second-Hash becomes the authentication data\
    \ that is\n       returned as the result of HMAC calculation.\n   Note that in\
    \ the case of Babel the Text parameter will never exceed a\n   few thousand octets\
    \ in length.  In this specific case, the\n   optimization discussed in Section\
    \ 6 of [FIPS-198] applies, namely,\n   for a given K that is more than B octets\
    \ long, the following\n   associated intermediate results may be precomputed only\
    \ once:\n   Ko, (Ko XOR Ipad), and (Ko XOR Opad).\n"
- title: 3.  Updates to Protocol Data Structures
  contents:
  - '3.  Updates to Protocol Data Structures

    '
- title: 3.1.  RxAuthRequired
  contents:
  - "3.1.  RxAuthRequired\n   RxAuthRequired is a boolean parameter.  Its default\
    \ value MUST be\n   TRUE.  An implementation SHOULD make RxAuthRequired a per-interface\n\
    \   parameter but MAY make it specific to the whole protocol instance.\n   The\
    \ conceptual purpose of RxAuthRequired is to enable a smooth\n   migration from\
    \ an unauthenticated Babel packet exchange to an\n   authenticated Babel packet\
    \ exchange and back (see Section 7.3).  The\n   current value of RxAuthRequired\
    \ directly affects the receiving\n   procedure defined in Section 5.4.  An implementation\
    \ SHOULD allow the\n   operator to change the RxAuthRequired value at runtime\
    \ or by means of\n   a Babel speaker restart.  An implementation MUST allow the\
    \ operator\n   to discover the effective value of RxAuthRequired at runtime or\
    \ from\n   the system documentation.\n"
- title: 3.2.  LocalTS
  contents:
  - "3.2.  LocalTS\n   LocalTS is a 32-bit unsigned integer variable.  It is the TS\
    \ part of\n   a per-interface TS/PC number.  LocalTS is a strictly per-interface\n\
    \   variable not intended to be changed by the operator.  Its\n   initialization\
    \ is explained in Section 5.1.\n"
- title: 3.3.  LocalPC
  contents:
  - "3.3.  LocalPC\n   LocalPC is a 16-bit unsigned integer variable.  It is the PC\
    \ part of\n   a per-interface TS/PC number.  LocalPC is a strictly per-interface\n\
    \   variable not intended to be changed by the operator.  Its\n   initialization\
    \ is explained in Section 5.1.\n"
- title: 3.4.  MaxDigestsIn
  contents:
  - "3.4.  MaxDigestsIn\n   MaxDigestsIn is an unsigned integer parameter conceptually\
    \ purposed\n   for limiting the amount of CPU time spent processing a received\n\
    \   authenticated packet.  The receiving procedure performs the most\n   CPU-intensive\
    \ operation -- the HMAC computation -- only at most\n   MaxDigestsIn (Section\
    \ 5.4 item 7) times for a given packet.\n   The MaxDigestsIn value MUST be at\
    \ least 2.  An implementation SHOULD\n   make MaxDigestsIn a per-interface parameter\
    \ but MAY make it specific\n   to the whole protocol instance.  An implementation\
    \ SHOULD allow the\n   operator to change the value of MaxDigestsIn at runtime\
    \ or by means\n   of a Babel speaker restart.  An implementation MUST allow the\n\
    \   operator to discover the effective value of MaxDigestsIn at runtime\n   or\
    \ from the system documentation.\n"
- title: 3.5.  MaxDigestsOut
  contents:
  - "3.5.  MaxDigestsOut\n   MaxDigestsOut is an unsigned integer parameter conceptually\
    \ purposed\n   for limiting the amount of a sent authenticated packet's space\
    \ spent\n   on authentication data.  The sending procedure adds at most\n   MaxDigestsOut\
    \ (Section 5.3 item 5) HMAC results to a given packet.\n   The MaxDigestsOut value\
    \ MUST be at least 2.  An implementation SHOULD\n   make MaxDigestsOut a per-interface\
    \ parameter but MAY make it specific\n   to the whole protocol instance.  An implementation\
    \ SHOULD allow the\n   operator to change the value of MaxDigestsOut at runtime\
    \ or by means\n   of a Babel speaker restart, in a safe range.  The maximum safe\
    \ value\n   of MaxDigestsOut is implementation specific (see Section 6.2).  An\n\
    \   implementation MUST allow the operator to discover the effective\n   value\
    \ of MaxDigestsOut at runtime or from the system documentation.\n"
- title: 3.6.  ANM Table
  contents:
  - "3.6.  ANM Table\n   The ANM (Authentic Neighbours Memory) table resembles the\
    \ neighbour\n   table defined in Section 3.2.3 of [BABEL].  Note that the term\n\
    \   \"neighbour table\" means the neighbour table of the original Babel\n   specification,\
    \ and the term \"ANM table\" means the table defined\n   herein.  Indexing of\
    \ the ANM table is done in exactly the same way as\n   indexing of the neighbour\
    \ table, but its purpose, field set, and\n   associated procedures are different.\n\
    \   The conceptual purpose of the ANM table is to provide longer-term\n   replay\
    \ attack protection than would be possible using the neighbour\n   table.  Expiry\
    \ of an inactive entry in the neighbour table depends on\n   the last received\
    \ Hello Interval of the neighbour and typically\n   stands for tens to hundreds\
    \ of seconds (see Appendixes A and B of\n   [BABEL]).  Expiry of an inactive entry\
    \ in the ANM table depends only\n   on the local speaker's configuration.  The\
    \ ANM table retains (for at\n   least the amount of seconds set by the ANM timeout\
    \ parameter as\n   defined in Section 3.7) a copy of the TS/PC number advertised\
    \ in\n   authentic packets by each remote Babel speaker.\n   The ANM table is\
    \ indexed by pairs of the form (Interface, Source).\n   Every table entry consists\
    \ of the following fields:\n   o  Interface\n      An implementation-specific\
    \ reference to the local node's interface\n      through which the authentic packet\
    \ was received.\n   o  Source\n      The source address of the Babel speaker from\
    \ which the authentic\n      packet was received.\n   o  LastTS\n      A 32-bit\
    \ unsigned integer -- the TS part of a remote TS/PC number.\n   o  LastPC\n  \
    \    A 16-bit unsigned integer -- the PC part of a remote TS/PC number.\n   Each\
    \ ANM table entry has an associated aging timer, which is reset by\n   the receiving\
    \ procedure (Section 5.4 item 9).  If the timer expires,\n   the entry is deleted\
    \ from the ANM table.\n   An implementation SHOULD use persistent memory (NVRAM)\
    \ to retain the\n   contents of the ANM table across restarts of the Babel speaker,\
    \ but\n   only as long as both the Interface field reference and expiry of the\n\
    \   aging timer remain correct.  An implementation MUST be clear\n   regarding\
    \ if and how persistent memory is used for the ANM table.  An\n   implementation\
    \ SHOULD allow the operator to retrieve the current\n   contents of the ANM table\
    \ at runtime.  An implementation SHOULD allow\n   the operator to remove some\
    \ or all ANM table entries at runtime or by\n   means of a Babel speaker restart.\n"
- title: 3.7.  ANM Timeout
  contents:
  - "3.7.  ANM Timeout\n   ANM timeout is an unsigned integer parameter.  An implementation\n\
    \   SHOULD make ANM timeout a per-interface parameter but MAY make it\n   specific\
    \ to the whole protocol instance.  ANM timeout is conceptually\n   purposed for\
    \ limiting the maximum age (in seconds) of entries in the\n   ANM table that stand\
    \ for inactive Babel speakers.  The maximum age is\n   immediately related to\
    \ replay attack protection strength.  The\n   strongest protection is achieved\
    \ with the maximum possible value of\n   ANM timeout set, but it may not provide\
    \ the best overall result for\n   specific network segments and implementations\
    \ of this mechanism.\n   Specifically, implementations unable to maintain the\
    \ local TS/PC\n   number strictly increasing across Babel speaker restarts will\
    \ reuse\n   the advertised TS/PC numbers after each restart (see Section 5.1).\n\
    \   The neighbouring speakers will treat the new packets as replayed and\n   discard\
    \ them until the aging timer of the respective ANM table entry\n   expires or\
    \ the new TS/PC number exceeds the one stored in the entry.\n   Another possible,\
    \ but less probable, case could be an environment\n   that uses IPv6 for the exchange\
    \ of Babel datagrams and that involves\n   physical moves of network-interface\
    \ hardware between Babel speakers.\n   Even when performed without restarting\
    \ the speakers, these physical\n   moves would cause random drops of the TS/PC\
    \ number advertised for a\n   given (Interface, Source) index, as viewed by neighbouring\
    \ speakers,\n   since IPv6 link-local addresses are typically derived from interface\n\
    \   hardware addresses.\n   Assuming that in such cases the operators would prefer\
    \ to use a lower\n   ANM timeout value to let the entries expire on their own\
    \ rather than\n   having to manually remove them from the ANM table each time,\
    \ an\n   implementation SHOULD set the default value of ANM timeout to a value\n\
    \   between 30 and 300 seconds.\n   At the same time, network segments may exist\
    \ with every Babel speaker\n   having its advertised TS/PC number strictly increasing\
    \ over the\n   deployed lifetime.  Assuming that in such cases the operators would\n\
    \   prefer using a much higher ANM timeout value, an implementation\n   SHOULD\
    \ allow the operator to change the value of ANM timeout at\n   runtime or by means\
    \ of a Babel speaker restart.  An implementation\n   MUST allow the operator to\
    \ discover the effective value of ANM\n   timeout at runtime or from the system\
    \ documentation.\n"
- title: 3.8.  Configured Security Associations
  contents:
  - "3.8.  Configured Security Associations\n   A Configured Security Association\
    \ (CSA) is a data structure\n   conceptually purposed for associating authentication\
    \ keys and hash\n   algorithms with Babel interfaces.  All CSAs are managed in\
    \ finite\n   sequences, one sequence per interface (hereafter referred to as\n\
    \   \"interface's sequence of CSAs\").  Each interface's sequence of CSAs,\n \
    \  as an integral part of the Babel speaker configuration, MAY be\n   intended\
    \ for persistent storage as long as this conforms with the\n   implementation's\
    \ key-management policy.  The default state of an\n   interface's sequence of\
    \ CSAs is empty, which has a special meaning of\n   no authentication configured\
    \ for the interface.  The sending\n   (Section 5.3 item 1) and the receiving (Section\
    \ 5.4 item 1)\n   procedures address this convention accordingly.\n   A single\
    \ CSA structure consists of the following fields:\n   o  HashAlgo\n      An implementation-specific\
    \ reference to one of the hash algorithms\n      supported by this implementation\
    \ (see Section 2.1).\n   o  KeyChain\n      A finite sequence of elements (hereafter\
    \ referred to as \"KeyChain\n      sequence\") representing authentication keys,\
    \ each element being a\n      structure consisting of the following fields:\n\
    \      *  LocalKeyID\n         An unsigned integer of an implementation-specific\
    \ bit length.\n      *  AuthKeyOctets\n         A sequence of octets of an arbitrary,\
    \ known length to be used\n         as the authentication key.\n      *  KeyStartAccept\n\
    \         The time that this Babel speaker will begin considering this\n     \
    \    authentication key for accepting packets with authentication\n         data.\n\
    \      *  KeyStartGenerate\n         The time that this Babel speaker will begin\
    \ considering this\n         authentication key for generating packet authentication\
    \ data.\n      *  KeyStopGenerate\n         The time that this Babel speaker will\
    \ stop considering this\n         authentication key for generating packet authentication\
    \ data.\n      *  KeyStopAccept\n         The time that this Babel speaker will\
    \ stop considering this\n         authentication key for accepting packets with\
    \ authentication\n         data.\n   Since there is no limit imposed on the number\
    \ of CSAs per interface,\n   but the number of HMAC computations per sent/received\
    \ packet is\n   limited (through MaxDigestsOut and MaxDigestsIn, respectively),\
    \ it\n   may appear that only a fraction of the associated keys and hash\n   algorithms\
    \ are used in the process.  The ordering of elements within\n   a sequence of\
    \ CSAs and within a KeyChain sequence is important to\n   make the association\
    \ selection process deterministic and transparent.\n   Once this ordering is deterministic\
    \ at the Babel interface level, the\n   intermediate data derived by the procedure\
    \ defined in Section 5.2\n   will be deterministically ordered as well.\n   An\
    \ implementation SHOULD allow an operator to set any arbitrary order\n   of elements\
    \ within a given interface's sequence of CSAs and within\n   the KeyChain sequence\
    \ of a given CSA.  Regardless of whether this\n   requirement is or isn't met,\
    \ the implementation MUST provide a means\n   to discover the actual element order\
    \ used.  Whichever order is used\n   by an implementation, it MUST be preserved\
    \ across Babel speaker\n   restarts.\n   Note that none of the CSA structure fields\
    \ is constrained to contain\n   unique values.  Section 6.4 explains this in more\
    \ detail.  It is\n   possible for the KeyChain sequence to be empty, although\
    \ this is not\n   the intended manner of using CSAs.\n   The KeyChain sequence\
    \ has a direct prototype, which is the \"key\n   chain\" syntax item of some existing\
    \ router configuration languages.\n   If an implementation already implements\
    \ this syntax item, it is\n   suggested that the implementation reuse it, that\
    \ is, implement a CSA\n   syntax item that refers to a key chain item rather than\
    \ reimplement\n   the latter in full.\n"
- title: 3.9.  Effective Security Associations
  contents:
  - "3.9.  Effective Security Associations\n   An Effective Security Association (ESA)\
    \ is a data structure\n   immediately used in sending (Section 5.3) and receiving\
    \ (Section 5.4)\n   procedures.  Its conceptual purpose is to determine a runtime\n\
    \   interface between those procedures and the deriving procedure defined\n  \
    \ in Section 5.2.  All ESAs are temporary data units managed as\n   elements of\
    \ finite sequences that are not intended for persistent\n   storage.  Element\
    \ ordering within each such finite sequence\n   (hereafter referred to as \"sequence\
    \ of ESAs\") MUST be preserved as\n   long as the sequence exists.\n   A single\
    \ ESA structure consists of the following fields:\n   o  HashAlgo\n      An implementation-specific\
    \ reference to one of the hash algorithms\n      supported by this implementation\
    \ (see Section 2.1).\n   o  KeyID\n      A 16-bit unsigned integer.\n   o  AuthKeyOctets\n\
    \      A sequence of octets of an arbitrary, known length to be used as\n    \
    \  the authentication key.\n   Note that among the protocol data structures introduced\
    \ by this\n   mechanism, the ESA structure is the only one not directly interfaced\n\
    \   with the system operator (see Figure 1 in Appendix A); it is not\n   immediately\
    \ present in the protocol encoding, either.  However, the\n   ESA structure is\
    \ not just a possible implementation technique but an\n   integral part of this\
    \ specification: the deriving (Section 5.2), the\n   sending (Section 5.3), and\
    \ the receiving (Section 5.4) procedures are\n   defined in terms of the ESA structure\
    \ and its semantics provided\n   herein.  The ESA structure is as meaningful for\
    \ a correct\n   implementation as the other protocol data structures.\n"
- title: 4.  Updates to Protocol Encoding
  contents:
  - '4.  Updates to Protocol Encoding

    '
- title: 4.1.  Justification
  contents:
  - "4.1.  Justification\n   The choice of encoding is very important in the long\
    \ term.  The\n   protocol encoding limits various authentication mechanism designs\
    \ and\n   encodings, which in turn limit future developments of the protocol.\n\
    \   Considering existing implementations of the Babel protocol instance\n   itself\
    \ and related modules of packet analysers, the current encoding\n   of Babel allows\
    \ for compact and robust decoders.  At the same time,\n   this encoding allows\
    \ for future extensions of Babel by three (not\n   excluding each other) principal\
    \ means as defined in Sections 4.2 and\n   4.3 of [BABEL] and further discussed\
    \ in [BABEL-EXTENSION]:\n   a.  A Babel packet consists of a four-octet header\
    \ followed by a\n       packet body, that is, a sequence of TLVs (see Figure 2\
    \ in\n       Appendix A).  Besides the header and the body, an actual Babel\n\
    \       datagram may have an arbitrary amount of trailing data between\n     \
    \  the end of the packet body and the end of the datagram.  An\n       instance\
    \ of the original protocol silently ignores such trailing\n       data.\n   b.\
    \  The packet body uses a binary format allowing for 256 TLV types\n       and\
    \ imposing no requirements on TLV ordering or number of TLVs of\n       a given\
    \ type in a packet.  [BABEL] allocates TLV types 0 through\n       10 (see Table\
    \ 1 in Appendix A), defines the TLV body structure\n       for each, and establishes\
    \ the requirement for a Babel protocol\n       instance to ignore any unknown\
    \ TLV types silently.  This makes it\n       possible to examine a packet body\
    \ (to validate the framing and/or\n       to pick particular TLVs for further\
    \ processing), taking into\n       account only the type (to distinguish between\
    \ a Pad1 TLV and any\n       other TLV) and the length of each TLV, regardless\
    \ of whether any\n       additional TLV types are eventually deployed (and if\
    \ so, how\n       many).\n   c.  Within each TLV of the packet body, there may\
    \ be some extra data\n       after the expected length of the TLV body.  An instance\
    \ of the\n       original protocol silently ignores any such extra data.  Note\n\
    \       that any TLV types without the expected length defined (such as\n    \
    \   the PadN TLV) cannot be extended with the extra data.\n   Considering each\
    \ of these three principal extension means for the\n   specific purpose of adding\
    \ authentication data items to each protocol\n   packet, the following arguments\
    \ can be made:\n   o  The use of the TLV extra data of some existing TLV type\
    \ would not\n      be a solution, since no particular TLV type is guaranteed to\
    \ be\n      present in a Babel packet.\n   o  The use of the TLV extra data could\
    \ also conflict with future\n      developments of the protocol encoding.\n  \
    \ o  Since the packet trailing data is currently unstructured, using it\n    \
    \  would involve defining an encoding structure and associated\n      procedures;\
    \ this would add to the complexity of both specification\n      and implementation\
    \ and would increase exposure to protocol attacks\n      such as fuzzing.\n  \
    \ o  A naive use of the packet trailing data would make it unavailable\n     \
    \ to any future extension of Babel.  Since this mechanism is\n      possibly not\
    \ the last extension and since some other extensions\n      may allow no other\
    \ embedding means except the packet trailing\n      data, the defined encoding\
    \ structure would have to enable the\n      multiplexing of data items belonging\
    \ to different extensions.\n      Such a definition is out of the scope of this\
    \ work.\n   o  Deprecating an extension (or only its protocol encoding) that uses\n\
    \      purely purpose-allocated TLVs is as simple as deprecating the\n      TLVs.\n\
    \   o  The use of purpose-allocated TLVs is transparent for both the\n      original\
    \ protocol and any its future extensions, regardless of the\n      embedding technique(s)\
    \ used by the latter.\n   Considering all of the above, this mechanism uses neither\
    \ the packet\n   trailing data nor the TLV extra data but uses two new TLV types:\n\
    \   type 11 for a TS/PC number and type 12 for an HMAC result (see\n   Table 1\
    \ in Appendix A).\n"
- title: 4.2.  TS/PC TLV
  contents:
  - "4.2.  TS/PC TLV\n   The purpose of a TS/PC TLV is to store a single TS/PC number.\
    \  There\n   is exactly one TS/PC TLV in an authenticated Babel packet.\n    0\
    \                   1                   2                   3\n    0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   Type = 11   |     Length    |         PacketCounter         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           Timestamp                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Fields:\n   Type            Set to 11 to indicate a TS/PC TLV.\n   Length\
    \          The length, in octets, of the body, exclusive of the\n            \
    \       Type and Length fields.\n   PacketCounter   A 16-bit unsigned integer\
    \ in network byte order --\n                   the PC part of a TS/PC number stored\
    \ in this TLV.\n   Timestamp       A 32-bit unsigned integer in network byte order\
    \ --\n                   the TS part of a TS/PC number stored in this TLV.\n \
    \  Note that the ordering of PacketCounter and Timestamp in the TLV\n   structure\
    \ is the opposite of the ordering of TS and PC in the TS/PC\n   number and the\
    \ 48-bit equivalent (see Section 2.3).\n   Considering the expected length and\
    \ the extra data as mentioned in\n   Section 4.3 of [BABEL], the expected length\
    \ of a TS/PC TLV body is\n   unambiguously defined as 6 octets.  The receiving\
    \ procedure would\n   correctly process any TS/PC TLV with body length not less\
    \ than the\n   expected length, ignoring any extra data (Section 5.4 items 3 and\
    \ 9).\n   The sending procedure produces a TS/PC TLV with body length equal to\n\
    \   the expected length and the Length field, respectively, set as\n   described\
    \ in Section 5.3 item 3.\n   Future Babel extensions (such as sub-TLVs) MAY modify\
    \ the sending\n   procedure to include the extra data after the fixed-size TS/PC\
    \ TLV\n   body defined herein, making adjustments to the Length TLV field, the\n\
    \   \"Body length\" packet header field, and output buffer management (as\n  \
    \ explained in Section 6.2) necessary.\n"
- title: 4.3.  HMAC TLV
  contents:
  - "4.3.  HMAC TLV\n   The purpose of an HMAC TLV is to store a single HMAC result.\
    \  To\n   assist a receiver in reproducing the HMAC computation, LocalKeyID\n\
    \   modulo 2^16 of the authentication key is also provided in the TLV.\n   There\
    \ is at least one HMAC TLV in an authenticated Babel packet.\n    0          \
    \         1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   Type = 12   |    Length     |             KeyID             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   Digest...\n   +-+-+-+-+-+-+-+-+-+-+-+-\n   Fields:\n   Type          \
    \  Set to 12 to indicate an HMAC TLV.\n   Length          The length, in octets,\
    \ of the body, exclusive of the\n                   Type and Length fields.\n\
    \   KeyID           A 16-bit unsigned integer in network byte order.\n   Digest\
    \          A variable-length sequence of octets that is at least\n           \
    \        16 octets long (see Section 2.2).\n   Considering the expected length\
    \ and the extra data as mentioned in\n   Section 4.3 of [BABEL], the expected\
    \ length of an HMAC TLV body is\n   not defined.  The receiving and padding procedures\
    \ process every\n   octet of the Digest field, deriving the field boundary from\
    \ the\n   Length field value (Section 5.4 item 7 and Section 2.2,\n   respectively).\
    \  The sending procedure produces HMAC TLVs with the\n   Length field precisely\
    \ sizing the Digest field to match the digest\n   length of the hash algorithm\
    \ used (Section 5.3 items 5 and 8).\n   The HMAC TLV structure defined herein\
    \ is final.  Future Babel\n   extensions MUST NOT extend it with any extra data.\n"
- title: 5.  Updates to Protocol Operation
  contents:
  - '5.  Updates to Protocol Operation

    '
- title: 5.1.  Per-Interface TS/PC Number Updates
  contents:
  - "5.1.  Per-Interface TS/PC Number Updates\n   The LocalTS and LocalPC interface-specific\
    \ variables constitute the\n   TS/PC number of a Babel interface.  This number\
    \ is advertised in the\n   TS/PC TLV of authenticated Babel packets sent from\
    \ that interface.\n   There is only one property that is mandatory for the advertised\
    \ TS/PC\n   number: its 48-bit equivalent (see Section 2.3) MUST be strictly\n\
    \   increasing within the scope of a given interface of a Babel speaker\n   as\
    \ long as the protocol instance is continuously operating.  This\n   property,\
    \ combined with ANM tables of neighbouring Babel speakers,\n   provides them with\
    \ the most basic replay attack protection.\n   Initialization and increment are\
    \ two principal updates performed on\n   an interface TS/PC number.  The initialization\
    \ is performed when a\n   new interface becomes a part of a Babel protocol instance.\
    \  The\n   increment is performed by the sending procedure (Section 5.3 item 2)\n\
    \   before advertising the TS/PC number in a TS/PC TLV.\n   Depending on the particular\
    \ implementation method of these two\n   updates, the advertised TS/PC number\
    \ may possess additional\n   properties that improve the replay attack protection\
    \ strength.  This\n   includes, but is not limited to, the methods below.\n  \
    \ a.  The most straightforward implementation would use LocalTS as a\n       plain\
    \ wrap counter, defining the updates as follows:\n       initialization  Set LocalPC\
    \ to 0, and set LocalTS to 0.\n       increment       Increment LocalPC by 1.\
    \  If LocalPC wraps\n                       (0xFFFF + 1 = 0x0000), increment LocalTS\
    \ by 1.\n       In this case, the advertised TS/PC numbers would be reused after\n\
    \       each Babel protocol instance restart, making neighbouring\n       speakers\
    \ reject authenticated packets until the respective ANM\n       table entries\
    \ expire or the new TS/PC number exceeds the old (see\n       Sections 3.6 and\
    \ 3.7).\n   b.  A more advanced implementation could make use of any 32-bit\n\
    \       unsigned integer timestamp (number of time units since an\n       arbitrary\
    \ epoch), such as the UNIX timestamp, if the timestamp\n       itself spans a\
    \ reasonable time range and is guaranteed against a\n       decrease (such as\
    \ one resulting from network time use).  The\n       updates would be defined\
    \ as follows:\n       initialization  Set LocalPC to 0, and set LocalTS to 0.\n\
    \       increment       If the current timestamp is greater than LocalTS,\n  \
    \                     set LocalTS to the current timestamp and LocalPC\n     \
    \                  to 0, then consider the update complete.\n                \
    \       Otherwise, increment LocalPC by 1, and if LocalPC\n                  \
    \     wraps, increment LocalTS by 1.\n       In this case, the advertised TS/PC\
    \ number would remain unique\n       across the speaker's deployed lifetime without\
    \ the need for any\n       persistent storage.  However, a suitable timestamp\
    \ source is not\n       available in every implementation case.\n   c.  Another\
    \ advanced implementation could use LocalTS in a way\n       similar to the \"\
    wrap/boot count\" suggested in Section 4.1 of\n       [OSPF3-AUTH-BIS], defining\
    \ the updates as follows:\n       initialization  Set LocalPC to 0.  If there\
    \ is a TS value stored\n                       in NVRAM for the current interface,\
    \ set LocalTS\n                       to the stored TS value, then increment the\
    \ stored\n                       TS value by 1.  Otherwise, set LocalTS to 0,\
    \ and\n                       set the stored TS value to 1.\n       increment\
    \       Increment LocalPC by 1.  If LocalPC wraps, set\n                     \
    \  LocalTS to the TS value stored in NVRAM for the\n                       current\
    \ interface, then increment the stored TS\n                       value by 1.\n\
    \       In this case, the advertised TS/PC number would also remain\n       unique\
    \ across the speaker's deployed lifetime, relying on NVRAM\n       for storing\
    \ multiple TS numbers, one per interface.\n   As long as the TS/PC number retains\
    \ its mandatory property stated\n   above, it is up to the implementor to determine\
    \ which methods of TS/\n   PC number updates are available and whether the operator\
    \ can\n   configure the method per interface and/or at runtime.  However, an\n\
    \   implementation MUST disclose the essence of each update method it\n   includes,\
    \ in a comprehensible form such as natural language\n   description, pseudocode,\
    \ or source code.  An implementation MUST\n   allow the operator to discover which\
    \ update method is effective for\n   any given interface, either at runtime or\
    \ from the system\n   documentation.  These requirements are necessary to enable\
    \ the\n   optimal (see Section 3.7) management of ANM timeout in a network\n \
    \  segment.\n   Note that wrapping (0xFFFFFFFF + 1 = 0x00000000) of LastTS is\n\
    \   unlikely, but possible, causing the advertised TS/PC number to be\n   reused.\
    \  Resolving this situation requires replacing all\n   authentication keys of\
    \ the involved interface.  In addition to that,\n   if the wrap was caused by\
    \ a timestamp reaching its end of epoch,\n   using this mechanism will be impossible\
    \ for the involved interface\n   until some different timestamp or update implementation\
    \ method is\n   used.\n"
- title: 5.2.  Deriving ESAs from CSAs
  contents:
  - "5.2.  Deriving ESAs from CSAs\n   Neither receiving nor sending procedures work\
    \ with the contents of an\n   interface's sequence of CSAs directly; both (Section\
    \ 5.4 item 4 and\n   Section 5.3 item 4, respectively) derive a sequence of ESAs\
    \ from the\n   sequence of CSAs and use the derived sequence (see Figure 1 in\n\
    \   Appendix A).  There are two main goals achieved through this\n   indirection:\n\
    \   o  Elimination of expired authentication keys and deduplication of\n     \
    \ security associations.  This is done as early as possible to keep\n      subsequent\
    \ procedures focused on their respective tasks.\n   o  Maintenance of particular\
    \ ordering within the derived sequence of\n      ESAs.  The ordering deterministically\
    \ depends on the ordering\n      within the interface's sequence of CSAs and the\
    \ ordering within\n      the KeyChain sequence of each CSA.  The particular correlation\n\
    \      maintained by this procedure implements a concept of fair\n      (independent\
    \ of the number of keys contained by each) competition\n      between CSAs.\n\
    \   The deriving procedure uses the following input arguments:\n   o  input sequence\
    \ of CSAs\n   o  direction (sending or receiving)\n   o  current time (CT)\n \
    \  The processing of input arguments begins with an empty output\n   sequence\
    \ of ESAs and consists of the following steps:\n   1.  Make a temporary copy of\
    \ the input sequence of CSAs.\n   2.  Remove all expired authentication keys from\
    \ each KeyChain\n       sequence of the copy, that is, any keys such that:\n \
    \      *  for receiving: KeyStartAccept is greater than CT or\n          KeyStopAccept\
    \ is less than CT\n       *  for sending: KeyStartGenerate is greater than CT\
    \ or\n          KeyStopGenerate is less than CT\n       Note well that there are\
    \ no special exceptions.  Remove all\n       expired keys, even if there are no\
    \ keys left after that (see\n       Section 7.4).\n   3.  Use the copy to populate\
    \ the output sequence of ESAs as follows:\n       3.1.  When the KeyChain sequence\
    \ of the first CSA contains at\n             least one key, use its first key\
    \ to produce an ESA with\n             fields set as follows:\n             HashAlgo\
    \       Set to HashAlgo of the current CSA.\n             KeyID          Set to\
    \ LocalKeyID modulo 2^16 of the current\n                            key of the\
    \ current CSA.\n             AuthKeyOctets  Set to AuthKeyOctets of the current\
    \ key of\n                            the current CSA.\n             Append this\
    \ ESA to the end of the output sequence.\n       3.2.  When the KeyChain sequence\
    \ of the second CSA contains at\n             least one key, use its first key\
    \ the same way, and so forth\n             until all first keys of the copy are\
    \ processed.\n       3.3.  When the KeyChain sequence of the first CSA contains\
    \ at\n             least two keys, use its second key the same way.\n       3.4.\
    \  When the KeyChain sequence of the second CSA contains at\n             least\
    \ two keys, use its second key the same way, and so\n             forth until\
    \ all second keys of the copy are processed.\n       3.5.  ...and so forth, until\
    \ all keys of all CSAs of the copy are\n             processed, exactly once each.\n\
    \       In the description above, the ordinals (\"first\", \"second\", and so\n\
    \       on) with regard to keys stand for an element position after the\n    \
    \   removal of expired keys, not before.  For example, if a KeyChain\n       sequence\
    \ was { Ka, Kb, Kc, Kd } before the removal and became\n       { Ka, Kd } after,\
    \ then Ka would be the \"first\" element and Kd\n       would be the \"second\"\
    .\n   4.  Deduplicate the ESAs in the output sequence; that is, wherever\n   \
    \    two or more ESAs exist that share the same (HashAlgo, KeyID,\n       AuthKeyOctets)\
    \ triplet value, remove all of these ESAs except the\n       one closest to the\
    \ beginning of the sequence.\n   The resulting sequence will contain zero or more\
    \ unique ESAs, ordered\n   in a way deterministically correlated with the ordering\
    \ of CSAs\n   within the original input sequence of CSAs and the ordering of keys\n\
    \   within each KeyChain sequence.  This ordering maximizes the\n   probability\
    \ of having an equal amount of keys per original CSA in any\n   N first elements\
    \ of the resulting sequence.  Possible optimizations\n   of this deriving procedure\
    \ are outlined in Section 6.3.\n"
- title: 5.3.  Updates to Packet Sending
  contents:
  - "5.3.  Updates to Packet Sending\n   Perform the following authentication-specific\
    \ processing after the\n   instance of the original protocol considers an outgoing\
    \ Babel packet\n   ready for sending, but before the packet is actually sent (see\n\
    \   Figure 1 in Appendix A).  After that, send the packet, regardless of\n   whether\
    \ the authentication-specific processing modified the outgoing\n   packet or left\
    \ it intact.\n   1.  If the current outgoing interface's sequence of CSAs is empty,\n\
    \       finish authentication-specific processing and consider the packet\n  \
    \     ready for sending.\n   2.  Increment the TS/PC number of the current outgoing\
    \ interface, as\n       explained in Section 5.1.\n   3.  Add to the packet body\
    \ (see the note at the end of this section)\n       a TS/PC TLV with fields set\
    \ as follows:\n       Type            Set to 11.\n       Length          Set to\
    \ 6.\n       PacketCounter   Set to the current value of the LocalPC variable\n\
    \                       of the current outgoing interface.\n       Timestamp \
    \      Set to the current value of the LocalTS variable\n                    \
    \   of the current outgoing interface.\n       Note that the current step may\
    \ involve byte order conversion.\n   4.  Derive a sequence of ESAs, using the\
    \ procedure defined in\n       Section 5.2, with the current interface's sequence\
    \ of CSAs as the\n       input sequence of CSAs, the current time as CT, and \"\
    sending\" as\n       the direction.  Proceed to the next step even if the derived\n\
    \       sequence is empty.\n   5.  Iterate over the derived sequence, using its\
    \ ordering.  For each\n       ESA, add to the packet body (see the note at the\
    \ end of this\n       section) an HMAC TLV with fields set as follows:\n     \
    \  Type     Set to 12.\n       Length   Set to 2 plus the digest length of HashAlgo\
    \ of the\n                current ESA.\n       KeyID    Set to KeyID of the current\
    \ ESA.\n       Digest   Size exactly equal to the digest length of HashAlgo of\n\
    \                the current ESA.  Pad (see Section 2.2), using the\n        \
    \        source address of the current packet (see Section 6.1).\n       As soon\
    \ as there are MaxDigestsOut HMAC TLVs added to the current\n       packet body,\
    \ immediately proceed to the next step.\n       Note that the current step may\
    \ involve byte order conversion.\n   6.  Increment the \"Body length\" field value\
    \ of the current packet\n       header by the total length of TS/PC and HMAC TLVs\
    \ appended to the\n       current packet body so far.\n       Note that the current\
    \ step may involve byte order conversion.\n   7.  Make a temporary copy of the\
    \ current packet.\n   8.  Iterate over the derived sequence again, using the same\
    \ order and\n       number of elements.  For each ESA (and, respectively, for\
    \ each\n       HMAC TLV recently appended to the current packet body), compute\n\
    \       an HMAC result (see Section 2.4), using the temporary copy (not\n    \
    \   the original packet) as Text, HashAlgo of the current ESA as H,\n       and\
    \ AuthKeyOctets of the current ESA as K.  Write the HMAC result\n       to the\
    \ Digest field of the current HMAC TLV (see Table 4 in\n       Appendix A) of\
    \ the current packet (not the copy).\n   9.  After this point, allow no more changes\
    \ to the current packet\n       header and body, and consider it ready for sending.\n\
    \   Note that even when the derived sequence of ESAs is empty, the packet\n  \
    \ is sent anyway, with only a TS/PC TLV appended to its body.  Although\n   such\
    \ a packet would not be authenticated, the presence of the sole\n   TS/PC TLV\
    \ would indicate authentication key exhaustion to operators\n   of neighbouring\
    \ Babel speakers.  See also Section 7.4.\n   Also note that it is possible to\
    \ place the authentication-specific\n   TLVs in the packet's sequence of TLVs\
    \ in a number of different valid\n   ways so long as there is exactly one TS/PC\
    \ TLV in the sequence and\n   the ordering of HMAC TLVs relative to each other,\
    \ as produced in\n   step 5 above, is preserved.\n   For example, see Figure 2\
    \ in Appendix A.  The diagrams represent a\n   Babel packet without (D1) and with\
    \ (D2, D3, D4) authentication-\n   specific TLVs.  The optional trailing data\
    \ block that is present in\n   D1 is preserved in D2, D3, and D4.  Indexing (1,\
    \ 2, ..., n) of the\n   HMAC TLVs means the order in which the sending procedure\
    \ produced\n   them (and, respectively, the HMAC results).  In D2, the added TLVs\n\
    \   are appended: the previously existing TLVs are followed by the TS/PC\n   TLV,\
    \ which is followed by the HMAC TLVs.  In D3, the added TLVs are\n   prepended:\
    \ the TS/PC TLV is the first and is followed by the HMAC\n   TLVs, which are followed\
    \ by the previously existing TLVs.  In D4, the\n   added TLVs are intermixed with\
    \ the previously existing TLVs and the\n   TS/PC TLV is placed after the HMAC\
    \ TLVs.  All three packets meet the\n   requirements above.\n   Implementors SHOULD\
    \ use appending (D2) for adding the authentication-\n   specific TLVs to the sequence;\
    \ this is expected to result in more\n   straightforward implementation and troubleshooting\
    \ in most use cases.\n"
- title: 5.4.  Updates to Packet Receiving
  contents:
  - "5.4.  Updates to Packet Receiving\n   Perform the following authentication-specific\
    \ processing after an\n   incoming Babel packet is received from the local network\
    \ stack but\n   before it is acted upon by the Babel protocol instance (see Figure\
    \ 1\n   in Appendix A).  The final action conceptually depends not only upon\n\
    \   the result of the authentication-specific processing but also on the\n   current\
    \ value of the RxAuthRequired parameter.  Immediately after any\n   processing\
    \ step below accepts or refuses the packet, either deliver\n   the packet to the\
    \ instance of the original protocol (when the packet\n   is accepted or RxAuthRequired\
    \ is FALSE) or discard it (when the\n   packet is refused and RxAuthRequired is\
    \ TRUE).\n   1.   If the current incoming interface's sequence of CSAs is empty,\n\
    \        accept the packet.\n   2.   If the current packet does not contain exactly\
    \ one TS/PC TLV,\n        refuse it.\n   3.   Perform a lookup in the ANM table\
    \ for an entry having Interface\n        equal to the current incoming interface\
    \ and Source equal to the\n        source address of the current packet.  If such\
    \ an entry does not\n        exist, immediately proceed to the next step.  Otherwise,\
    \ compare\n        the entry's LastTS and LastPC field values with the Timestamp\n\
    \        and PacketCounter values, respectively, of the TS/PC TLV of the\n   \
    \     packet.  That is, refuse the packet if at least one of the\n        following\
    \ two conditions is true:\n        *  Timestamp is less than LastTS\n        *\
    \  Timestamp is equal to LastTS and PacketCounter is not greater\n           than\
    \ LastPC\n        Note that the current step may involve byte order conversion.\n\
    \   4.   Derive a sequence of ESAs, using the procedure defined in\n        Section\
    \ 5.2, with the current interface's sequence of CSAs as\n        the input sequence\
    \ of CSAs, current time as CT, and \"receiving\"\n        as the direction.  If\
    \ the derived sequence is empty, refuse the\n        packet.\n   5.   Make a temporary\
    \ copy of the current packet.\n   6.   Pad (see Section 2.2) every HMAC TLV present\
    \ in the temporary\n        copy (not the original packet), using the source address\
    \ of the\n        original packet.\n   7.   Iterate over all the HMAC TLVs of\
    \ the original input packet (not\n        the copy), using their order of appearance\
    \ in the packet.  For\n        each HMAC TLV, look up all ESAs in the derived\
    \ sequence such\n        that 2 plus the digest length of HashAlgo of the ESA\
    \ is equal to\n        Length of the TLV and KeyID of the ESA is equal to the\
    \ value of\n        KeyID of the TLV.  Iterate over these ESAs in the relative\
    \ order\n        of their appearance on the full sequence of ESAs.  Note that\n\
    \        nesting the iterations the opposite way (over ESAs, then over\n     \
    \   HMAC TLVs) would be wrong.\n        For each of these ESAs, compute an HMAC\
    \ result (see\n        Section 2.4), using the temporary copy (not the original\
    \ packet)\n        as Text, HashAlgo of the current ESA as H, and AuthKeyOctets\
    \ of\n        the current ESA as K.  If the current HMAC result exactly\n    \
    \    matches the contents of the Digest field of the current HMAC\n        TLV,\
    \ immediately proceed to the next step.  Otherwise, if the\n        number of\
    \ HMAC computations done for the current packet so far\n        is equal to MaxDigestsIn,\
    \ immediately proceed to the next step.\n        Otherwise, follow the normal\
    \ order of iterations.\n        Note that the current step may involve byte order\
    \ conversion.\n   8.   Refuse the input packet unless there was a matching HMAC\
    \ result\n        in the previous step.\n   9.   Modify the ANM table, using the\
    \ same index as for the entry\n        lookup above, to contain an entry with\
    \ LastTS set to the value\n        of Timestamp and LastPC set to the value of\
    \ PacketCounter fields\n        of the TS/PC TLV of the current packet.  That\
    \ is, either add a\n        new ANM table entry or update the existing one, depending\
    \ on the\n        result of the entry lookup above.  Reset the entry's aging timer\n\
    \        to the current value of ANM timeout.\n        Note that the current step\
    \ may involve byte order conversion.\n   10.  Accept the input packet.\n   Before\
    \ performing the authentication-specific processing above, an\n   implementation\
    \ SHOULD perform those basic procedures of the original\n   protocol that don't\
    \ take any protocol actions on the contents of the\n   packet but that will discard\
    \ the packet if it is not sufficiently\n   well formed for further processing.\
    \  Although the exact composition\n   of such procedures belongs to the scope\
    \ of the original protocol, it\n   seems reasonable to state that a packet SHOULD\
    \ be discarded early,\n   regardless of whether any authentication-specific processing\
    \ is due,\n   unless its source address conforms to Section 3.1 of [BABEL] and\
    \ is\n   not the receiving speaker's own address (see item (e) of Section 8).\n\
    \   Note that RxAuthRequired affects only the final action but not the\n   defined\
    \ flow of authentication-specific processing.  The purpose of\n   this is to preserve\
    \ authentication-specific processing feedback (such\n   as log messages and event-counter\
    \ updates), even with RxAuthRequired\n   set to FALSE.  This allows an operator\
    \ to predict the effect of\n   changing RxAuthRequired from FALSE to TRUE during\
    \ a migration\n   scenario (Section 7.3) implementation.\n"
- title: 5.5.  Authentication-Specific Statistics Maintenance
  contents:
  - "5.5.  Authentication-Specific Statistics Maintenance\n   A Babel speaker implementing\
    \ this mechanism SHOULD maintain a set of\n   counters for the following events,\
    \ per protocol instance and per\n   interface:\n   a.  Sending an unauthenticated\
    \ Babel packet through an interface\n       having an empty sequence of CSAs (Section\
    \ 5.3 item 1).\n   b.  Sending an unauthenticated Babel packet with a TS/PC TLV\
    \ but\n       without any HMAC TLVs, due to an empty derived sequence of ESAs\n\
    \       (Section 5.3 item 4).\n   c.  Sending an authenticated Babel packet containing\
    \ both TS/PC and\n       HMAC TLVs (Section 5.3 item 9).\n   d.  Accepting a Babel\
    \ packet received through an interface having an\n       empty sequence of CSAs\
    \ (Section 5.4 item 1).\n   e.  Refusing a received Babel packet due to an empty\
    \ derived sequence\n       of ESAs (Section 5.4 item 4).\n   f.  Refusing a received\
    \ Babel packet that does not contain exactly\n       one TS/PC TLV (Section 5.4\
    \ item 2).\n   g.  Refusing a received Babel packet due to the TS/PC TLV failing\
    \ the\n       ANM table check (Section 5.4 item 3).  With possible future\n  \
    \     extensions in mind, in implementations of this mechanism, this\n       event\
    \ SHOULD leave out some small amount, per current (Interface,\n       Source,\
    \ LastTS, LastPC) tuple, of the packets refused due to the\n       Timestamp value\
    \ being equal to LastTS and the PacketCounter value\n       being equal to LastPC.\n\
    \   h.  Refusing a received Babel packet missing any HMAC TLVs\n       (Section\
    \ 5.4 item 8).\n   i.  Refusing a received Babel packet due to none of the processed\n\
    \       HMAC TLVs passing the ESA check (Section 5.4 item 8).\n   j.  Accepting\
    \ a received Babel packet having both TS/PC and HMAC TLVs\n       (Section 5.4\
    \ item 10).\n   k.  Delivery of a refused packet to the instance of the original\n\
    \       protocol due to the RxAuthRequired parameter being set to FALSE.\n   Note\
    \ that the terms \"accepting\" and \"refusing\" are used in the sense\n   of the\
    \ receiving procedure; that is, \"accepting\" does not mean a\n   packet delivered\
    \ to the instance of the original protocol purely\n   because the RxAuthRequired\
    \ parameter is set to FALSE.  Event-counter\n   readings SHOULD be available to\
    \ the operator at runtime.\n"
- title: 6.  Implementation Notes
  contents:
  - '6.  Implementation Notes

    '
- title: 6.1.  Source Address Selection for Sending
  contents:
  - "6.1.  Source Address Selection for Sending\n   Section 3.1 of [BABEL] allows\
    \ for the exchange of protocol datagrams,\n   using IPv4, IPv6, or both.  The\
    \ source address of the datagram is a\n   unicast (link-local in the case of IPv6)\
    \ address.  Within an address\n   family used by a Babel speaker, there may be\
    \ more than one address\n   eligible for the exchange and assigned to the same\
    \ network interface.\n   The original specification considers this case out of\
    \ scope and\n   leaves it up to the speaker's network stack to select one particular\n\
    \   address as the datagram source address, but the sending procedure\n   requires\
    \ (Section 5.3 item 5) exact knowledge of the packet source\n   address for proper\
    \ padding of HMAC TLVs.\n   As long as a network interface has more than one address\
    \ eligible for\n   the exchange within the same address family, the Babel speaker\
    \ SHOULD\n   internally choose one of those addresses for Babel packet sending\n\
    \   purposes and then indicate this choice to both the sending procedure\n   and\
    \ the network stack (see Figure 1 in Appendix A).  Wherever this\n   requirement\
    \ cannot be met, this limitation MUST be clearly stated in\n   the system documentation\
    \ to allow an operator to plan network address\n   management accordingly.\n"
- title: 6.2.  Output Buffer Management
  contents:
  - "6.2.  Output Buffer Management\n   An instance of the original protocol will\
    \ buffer produced TLVs until\n   the buffer becomes full or a delay timer has\
    \ expired.  This is\n   performed independently for each Babel interface, with\
    \ each buffer\n   sized according to the interface MTU (see Sections 3.1 and 4\
    \ of\n   [BABEL]).\n   Since TS/PC TLVs, HMAC TLVs, and any other TLVs -- and\
    \ most likely\n   the TLVs of the original protocol -- share the same packet space\
    \ (see\n   Figure 2 in Appendix A) and, respectively, the same buffer space, a\n\
    \   particular portion of each interface buffer needs to be reserved for\n   one\
    \ TS/PC TLV and up to MaxDigestsOut HMAC TLVs.  The amount (R) of\n   this reserved\
    \ buffer space is calculated as follows:\n                    R = St + MaxDigestsOut\
    \ * Sh\n                    R = 8  + MaxDigestsOut * (4 + Lmax)\n   St      The\
    \ size of a TS/PC TLV.\n   Sh      The size of an HMAC TLV.\n   Lmax    The maximum\
    \ possible digest length in octets for a particular\n           interface.  It\
    \ SHOULD be calculated based on the particular\n           interface's sequence\
    \ of CSAs but MAY be taken as the maximum\n           digest length supported\
    \ by a particular implementation.\n   An implementation allowing for a per-interface\
    \ value of MaxDigestsOut\n   or Lmax has to account for a different value of R\
    \ across different\n   interfaces, even interfaces having the same MTU.  An implementation\n\
    \   allowing for a runtime change to the value of R (due to MaxDigestsOut\n  \
    \ or Lmax) has to take care of the TLVs already buffered by the time of\n   the\
    \ change -- specifically, when the value of R increases.\n   The maximum safe\
    \ value of the MaxDigestsOut parameter depends on the\n   interface MTU and maximum\
    \ digest length used.  In general, at least\n   200-300 octets of a Babel packet\
    \ should always be available to data\n   other than TS/PC and HMAC TLVs.  An implementation\
    \ following the\n   requirements of Section 4 of [BABEL] would send packets of\
    \ 512 octets\n   or larger.  If, for example, the maximum digest length is 64\
    \ octets\n   and the MaxDigestsOut value is 4, the value of R would be 280,\n\
    \   leaving less than half of a 512-octet packet for any other TLVs.  As\n   long\
    \ as the interface MTU is larger or the digest length is smaller,\n   higher values\
    \ of MaxDigestsOut can be used safely.\n"
- title: 6.3.  Optimizations of Deriving Procedure for ESAs
  contents:
  - "6.3.  Optimizations of Deriving Procedure for ESAs\n   The following optimizations\
    \ of the deriving procedure for ESAs can\n   reduce the amount of CPU time consumed\
    \ by authentication-specific\n   processing, preserving an implementation's effective\
    \ behaviour.\n   a.  The most straightforward implementation would treat the deriving\n\
    \       procedure as a per-packet action, but since the procedure is\n       deterministic\
    \ (its output depends on its input only), it is\n       possible to significantly\
    \ reduce the number of times the\n       procedure is performed.\n       The procedure\
    \ would obviously return the same result for the same\n       input arguments\
    \ (sequence of CSAs, direction, CT) values.\n       However, it is possible to\
    \ predict when the result will remain\n       the same, even for a different input.\
    \  That is, when the input\n       sequence of CSAs and the direction both remain\
    \ the same but CT\n       changes, the result will remain the same as long as\
    \ CT's order on\n       the time axis (relative to all critical points of the\
    \ sequence of\n       CSAs) remains unchanged.  Here, the critical points are\n\
    \       KeyStartAccept and KeyStopAccept (for the receiving direction),\n    \
    \   and KeyStartGenerate and KeyStopGenerate (for the sending\n       direction),\
    \ of all keys of all CSAs of the input sequence.  In\n       other words, in this\
    \ case the result will remain the same as long\n       as (1) none of the active\
    \ keys expire and (2) none of the\n       inactive keys enter into operation.\n\
    \       An implementation optimized in this way would perform the full\n     \
    \  deriving procedure for a given (interface, direction) pair only\n       after\
    \ an operator's change to the interface's sequence of CSAs or\n       after reaching\
    \ one of the critical points mentioned above.\n   b.  Considering that the sending\
    \ procedure iterates over at most\n       MaxDigestsOut elements of the derived\
    \ sequence of ESAs\n       (Section 5.3 item 5), there would be little sense,\
    \ in the case of\n       the sending direction, in returning more than MaxDigestsOut\
    \ ESAs\n       in the derived sequence.  Note that a similar optimization would\n\
    \       be relatively difficult in the case of the receiving direction,\n    \
    \   since the number of ESAs actually used in examining a particular\n       received\
    \ packet (not to be confused with the number of HMAC\n       computations) depends\
    \ on additional factors besides just\n       MaxDigestsIn.\n"
- title: 6.4.  Duplication of Security Associations
  contents:
  - "6.4.  Duplication of Security Associations\n   This specification defines three\
    \ data structures as finite sequences:\n   a KeyChain sequence, an interface's\
    \ sequence of CSAs, and a sequence\n   of ESAs.  There are associated semantics\
    \ to take into account during\n   implementation, in that the same element can\
    \ appear multiple times at\n   different positions of the sequence.  In particular,\
    \ none of the CSA\n   structure fields (including HashAlgo, LocalKeyID, and AuthKeyOctets),\n\
    \   alone or in a combination, have to be unique within a given CSA, or\n   within\
    \ a given sequence of CSAs, or within all sequences of CSAs of a\n   Babel speaker.\n\
    \   In the CSA space defined in this way, for any two authentication\n   keys,\
    \ their one field (in)equality would not imply another field\n   (in)equality.\
    \  In other words, it is acceptable to have more than one\n   authentication key\
    \ with the same LocalKeyID or the same\n   AuthKeyOctets, or both at a time. \
    \ It is a conscious design decision\n   that CSA semantics allow for duplication\
    \ of security associations.\n   Consequently, ESA semantics allow for duplication\
    \ of intermediate\n   ESAs in the sequence until the explicit deduplication (Section\
    \ 5.2\n   item 4).\n   One of the intentions of this is to define the security\
    \ association\n   management in a way that allows the addressing of some specifics\
    \ of\n   Babel as a mesh routing protocol.  For example, a system operator\n \
    \  configuring a Babel speaker to participate in more than one\n   administrative\
    \ domain could find each domain using its own\n   authentication key (AuthKeyOctets)\
    \ under the same LocalKeyID value,\n   e.g., a \"well-known\" or \"default\" value\
    \ like 0 or 1.  Since\n   reconfiguring the domains to use distinct LocalKeyID\
    \ values isn't\n   always feasible, the multi-domain Babel speaker, using several\n\
    \   distinct authentication keys under the same LocalKeyID, would make a\n   valid\
    \ use case for such duplication.\n   Furthermore, if the operator decided in this\
    \ situation to migrate one\n   of the domains to a different LocalKeyID value\
    \ in a seamless way, the\n   respective Babel speakers would use the same authentication\
    \ key\n   (AuthKeyOctets) under two different LocalKeyID values for the time of\n\
    \   the transition (see also item (f) of Section 8).  This would make a\n   similar\
    \ use case.\n   Another intention of this design decision is to decouple security\n\
    \   association management from authentication key management as much as\n   possible,\
    \ so that the latter, be it manual keying or a key-management\n   protocol, could\
    \ be designed and implemented independently (as the\n   respective reasoning made\
    \ in Section 3.1 of [RIP2-AUTH] still\n   applies).  This way, the additional\
    \ key-management constraints, if\n   any, would remain out of the scope of this\
    \ authentication mechanism.\n   A similar thinking justifies the LocalKeyID field\
    \ having a bit length\n   in an ESA structure definition, but not in that of the\
    \ CSA.\n"
- title: 7.  Network Management Aspects
  contents:
  - '7.  Network Management Aspects

    '
- title: 7.1.  Backward Compatibility
  contents:
  - "7.1.  Backward Compatibility\n   Support of this mechanism is optional.  It does\
    \ not change the\n   default behaviour of a Babel speaker and causes no compatibility\n\
    \   issues with speakers properly implementing the original Babel\n   specification.\
    \  Given two Babel speakers -- one implementing this\n   mechanism and configured\
    \ for authenticated exchange (A) and another\n   not implementing it (B) -- these\
    \ speakers would not distribute\n   routing information unidirectionally, form\
    \ a routing loop, or\n   experience other protocol logic issues specific purely\
    \ to the use of\n   this mechanism.\n   The Babel design requires a bidirectional\
    \ neighbour reachability\n   condition between two given speakers for a successful\
    \ exchange of\n   routing information.  Apparently, neighbour reachability would\
    \ be\n   unidirectional in the case above.  The presence of TS/PC and HMAC\n \
    \  TLVs in Babel packets sent by A would be transparent to B, but a lack\n   of\
    \ authentication data in Babel packets sent by B would make them\n   effectively\
    \ invisible to the instance of the original protocol of A.\n   Unidirectional\
    \ links are not specific to the use of this mechanism;\n   they naturally exist\
    \ on their own and are properly detected and coped\n   with by the original protocol\
    \ (see Section 3.4.2 of [BABEL]).\n"
- title: 7.2.  Multi-Domain Authentication
  contents:
  - "7.2.  Multi-Domain Authentication\n   The receiving procedure treats a packet\
    \ as authentic as soon as one\n   of its HMAC TLVs passes the check against the\
    \ derived sequence of\n   ESAs.  This allows for packet exchange authenticated\
    \ with multiple\n   (hash algorithm, authentication key) pairs simultaneously,\
    \ in\n   combinations as arbitrary as permitted by MaxDigestsIn and\n   MaxDigestsOut.\n\
    \   For example, consider three Babel speakers with one interface each,\n   configured\
    \ with the following CSAs:\n   o  speaker A: (hash algorithm H1; key SK1), (hash\
    \ algorithm H1;\n      key SK2)\n   o  speaker B: (hash algorithm H1; key SK1)\n\
    \   o  speaker C: (hash algorithm H1; key SK2)\n   Packets sent by A would contain\
    \ two HMAC TLVs each.  Packets sent by\n   B and C would contain one HMAC TLV\
    \ each.  A and B would authenticate\n   the exchange between themselves, using\
    \ H1 and SK1; A and C would use\n   H1 and SK2; B and C would discard each other's\
    \ packets.\n   Consider a similar set of speakers configured with different CSAs:\n\
    \   o  speaker D: (hash algorithm H2; key SK3), (hash algorithm H3;\n      key\
    \ SK4)\n   o  speaker E: (hash algorithm H2; key SK3), (hash algorithm H4;\n \
    \     keys SK5 and SK6)\n   o  speaker F: (hash algorithm H3; keys SK4 and SK7),\
    \ (hash\n      algorithm H5; key SK8)\n   Packets sent by D would contain two\
    \ HMAC TLVs each.  Packets sent by\n   E and F would contain three HMAC TLVs each.\
    \  D and E would\n   authenticate the exchange between themselves, using H2 and\
    \ SK3; D and\n   F would use H3 and SK4; E and F would discard each other's packets.\n\
    \   The simultaneous use of H4, SK5, and SK6 by E, as well as the use of\n   SK7,\
    \ H5, and SK8 by F (for their own purposes), would remain\n   insignificant to\
    \ D.\n   An operator implementing multi-domain authentication should keep in\n\
    \   mind that values of MaxDigestsIn and MaxDigestsOut may be different\n   both\
    \ within the same Babel speaker and across different speakers.\n   Since the minimum\
    \ value of both parameters is 2 (see Sections 3.4 and\n   3.5), when more than\
    \ two authentication domains are configured\n   simultaneously it is advisable\
    \ to confirm that every involved speaker\n   can handle a sufficient number of\
    \ HMAC results for both sending and\n   receiving.\n   The recommended method\
    \ of Babel speaker configuration for\n   multi-domain authentication is to not\
    \ only use a different\n   authentication key for each domain but also a separate\
    \ CSA for each\n   domain, even when hash algorithms are the same.  This allows\
    \ for fair\n   competition between CSAs and sometimes limits the consequences\
    \ of a\n   possible misconfiguration to the scope of one CSA.  See also item (f)\n\
    \   of Section 8.\n"
- title: 7.3.  Migration to and from Authenticated Exchange
  contents:
  - "7.3.  Migration to and from Authenticated Exchange\n   It is common in practice\
    \ to consider a migration to the authenticated\n   exchange of routing information\
    \ only after the network has already\n   been deployed and put into active use.\
    \  Performing the migration in a\n   way without regular traffic interruption\
    \ is typically demanded, and\n   this specification allows a smooth migration\
    \ using the RxAuthRequired\n   interface parameter defined in Section 3.1.  This\
    \ measure is similar\n   to the \"transition mode\" suggested in Section 5 of\
    \ [OSPF3-AUTH-BIS].\n   An operator performing the migration needs to arrange\
    \ configuration\n   changes as follows:\n   1.  Decide on particular hash algorithm(s)\
    \ and key(s) to be used.\n   2.  Identify all speakers and their involved interfaces\
    \ that need to\n       be migrated to authenticated exchange.\n   3.  For each\
    \ of the speakers and the interfaces to be reconfigured,\n       first set the\
    \ RxAuthRequired parameter to FALSE, then configure\n       necessary CSA(s).\n\
    \   4.  Examine the speakers to confirm that Babel packets are\n       successfully\
    \ authenticated according to the configuration (for\n       instance, by examining\
    \ ANM table entries and authentication-\n       specific statistics; see Figure\
    \ 1 in Appendix A), and address any\n       discrepancies before proceeding further.\n\
    \   5.  For each of the speakers and the reconfigured interfaces, set the\n  \
    \     RxAuthRequired parameter to TRUE.\n   Likewise, temporarily setting RxAuthRequired\
    \ to FALSE can be used to\n   migrate smoothly from an authenticated packet exchange\
    \ back to an\n   unauthenticated one.\n"
- title: 7.4.  Handling of Authentication Key Exhaustion
  contents:
  - "7.4.  Handling of Authentication Key Exhaustion\n   This specification employs\
    \ a common concept of multiple\n   authentication keys coexisting for a given\
    \ interface, with two\n   independent lifetime ranges associated with each key\
    \ (one for sending\n   and another for receiving).  It is typically recommended\
    \ that the\n   keys be configured using finite lifetimes, adding new keys before\
    \ the\n   old keys expire.  However, it is obviously possible for all keys to\n\
    \   expire for a given interface (for sending, receiving, or both).\n   Possible\
    \ ways of addressing this situation raise their own concerns:\n   o  Automatic\
    \ switching to unauthenticated protocol exchange.  This\n      behaviour invalidates\
    \ the initial purposes of authentication and\n      is commonly viewed as unacceptable\
    \ ([RIP2-AUTH] Section 5.1,\n      [OSPF2-AUTH] Section 3.2, and [OSPF3-AUTH-BIS]\
    \ Section 3).\n   o  Stopping routing information exchange over the interface.\
    \  This\n      behaviour is likely to impact regular traffic routing and is\n\
    \      commonly viewed as \"not advisable\" ([RIP2-AUTH], [OSPF2-AUTH], and\n\
    \      [OSPF3-AUTH]), although [OSPF3-AUTH-BIS] is different in this\n      regard.\n\
    \   o  The use of the \"most recently expired\" key over its intended\n      lifetime\
    \ range.  This behaviour is recommended for implementation\n      in [RIP2-AUTH],\
    \ [OSPF2-AUTH], and [OSPF3-AUTH] but not in\n      [OSPF3-AUTH-BIS].  Such use\
    \ of this key may become a problem, due\n      to an offline cryptographic attack\
    \ (see item (f) of Section 8) or\n      a compromise of the key.  In addition,\
    \ distinguishing a recently\n      expired key from a key that has never been\
    \ used may be impossible\n      after a router restart.\n   The design of this\
    \ mechanism prevents automatic switching to\n   unauthenticated exchange and is\
    \ consistent with similar\n   authentication mechanisms in this regard, but since\
    \ the best choice\n   between two other options depends on local site policy,\
    \ this decision\n   is left up to the operator rather than the implementor (in\
    \ a way\n   resembling the \"fail secure\" configuration knob described in\n \
    \  Section 5.1 of [RIP2-AUTH]).\n   Although the deriving procedure does not allow\
    \ for any exceptions in\n   the filtering of expired keys (Section 5.2 item 2),\
    \ the operator can\n   trivially enforce one of the two remaining behaviour options\
    \ through\n   local key-management procedures.  In particular, when using the\
    \ key\n   over its intended lifetime is preferable to regular traffic\n   disruption,\
    \ the operator would explicitly leave the old key expiry\n   time open until the\
    \ new key is added to the router configuration.  In\n   the opposite case, the\
    \ operator would always configure the old key\n   with a finite lifetime and bear\
    \ associated risks.\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   The use of this mechanism implies requirements\
    \ common to the use of\n   shared authentication keys, including, but not limited\
    \ to:\n   o  holding the keys secret,\n   o  including sufficient amounts of random\
    \ bits into each key,\n   o  rekeying on a regular basis, and\n   o  never reusing\
    \ a used key for a different purpose.\n   That said, proper design and implementation\
    \ of a key-management\n   policy are out of the scope of this work.  Many publications\
    \ on this\n   subject exist and should be used for this purpose (BCP 107 [RFC4107],\n\
    \   BCP 132 [RFC4962], and [RFC6039] are suggested as starting points).\n   It\
    \ is possible for a network that exercises rollover of\n   authentication keys\
    \ to experience accidental expiration of all the\n   keys for a network interface,\
    \ as discussed at greater length in\n   Section 7.4.  With that and the guidance\
    \ of Section 5.1 of\n   [RIP2-AUTH] in mind, in such an event the Babel speaker\
    \ MUST send a\n   \"last key expired\" notification to the operator (e.g., via\
    \ syslog,\n   SNMP, and/or other implementation-specific means), most likely in\n\
    \   relation to item (b) of Section 5.5.  Also, any actual occurrence of\n   an\
    \ authentication key expiration MUST cause a security event to be\n   logged by\
    \ the implementation.  The log item MUST include at least a\n   note that the\
    \ authentication key has expired, the Babel routing\n   protocol instance(s) affected,\
    \ the network interface(s) affected, the\n   LocalKeyID that is affected, and\
    \ the current date/time.  Operators\n   are encouraged to check such logs as an\
    \ operational security\n   practice.\n   Considering particular attacks being\
    \ in scope or out of scope on one\n   hand and measures taken to protect against\
    \ particular in-scope\n   attacks on the other, the original Babel protocol and\
    \ this\n   authentication mechanism are in line with similar datagram-based\n\
    \   routing protocols and their respective mechanisms.  In particular,\n   the\
    \ primary concerns addressed are:\n   a.  Peer Entity Authentication\n       The\
    \ Babel speaker authentication mechanism defined herein is\n       believed to\
    \ be as strong as the class itself to which it belongs.\n       This specification\
    \ is built on fundamental concepts implemented\n       for authentication of similar\
    \ routing protocols: per-packet\n       authentication, the use of the HMAC construction,\
    \ and the use of\n       shared keys.  Although this design approach does not\
    \ address all\n       possible concerns, it is so far known to be sufficient for\
    \ most\n       practical cases.\n   b.  Data Integrity\n       Meaningful parts\
    \ of a Babel datagram are the contents of the\n       Babel packet (in the definition\
    \ of Section 4.2 of [BABEL]) and\n       the source address of the datagram (Section\
    \ 3.5.3 of [BABEL]).\n       This mechanism authenticates both parts, using the\
    \ HMAC\n       construction, so that making any meaningful change to an\n    \
    \   authenticated packet after it has been emitted by the sender\n       should\
    \ be as hard as attacking the HMAC construction itself or\n       successfully\
    \ recovering the authentication key.\n       Note well that any trailing data\
    \ of the Babel datagram is not\n       meaningful in the scope of the original\
    \ specification and does\n       not belong to the Babel packet.  Integrity of\
    \ the trailing data\n       is thus not protected by this mechanism.  At the same\
    \ time,\n       although any TLV extra data is also not meaningful in the same\n\
    \       scope, its integrity is protected, since this extra data is a\n      \
    \ part of the Babel packet (see Figure 2 in Appendix A).\n   c.  Denial of Service\n\
    \       Proper deployment of this mechanism in a Babel network\n       significantly\
    \ increases the efforts required for an attacker to\n       feed arbitrary Babel\
    \ packets into a protocol exchange (with the\n       intent of attacking a particular\
    \ Babel speaker or disrupting the\n       exchange of regular traffic in a routing\
    \ domain).  It also\n       protects the neighbour table from being flooded with\
    \ forged\n       speaker entries.\n       At the same time, this protection comes\
    \ with a price of CPU time\n       being spent on HMAC computations.  This may\
    \ be a concern for\n       low-performance CPUs combined with high-speed interfaces,\
    \ as\n       sometimes seen in embedded systems and hardware routers.  The\n \
    \      MaxDigestsIn parameter, which is used to limit the maximum amount\n   \
    \    of CPU time spent on a single received Babel packet, addresses\n       this\
    \ concern to some extent.\n   d.  Reflection Attacks\n       Given the approach\
    \ discussed in item (b), the only potential\n       reflection attack on this\
    \ mechanism could be replaying exact\n       copies of Babel packets back to the\
    \ sender from the same source\n       address.  The mitigation in this case is\
    \ straightforward and is\n       discussed in Section 5.4.\n   The following in-scope\
    \ concern is only partially addressed:\n   e.  Replay Attacks\n       This specification\
    \ establishes a basic replay protection measure\n       (see Section 3.6), defines\
    \ a timeout parameter affecting its\n       strength (see Section 3.7), and outlines\
    \ implementation methods\n       also affecting protection strength in several\
    \ ways (see\n       Section 5.1).  The implementor's choice of the timeout value\
    \ and\n       particular implementation methods may be suboptimal due to, for\n\
    \       example, insufficient hardware resources of the Babel speaker.\n     \
    \  Furthermore, it may be possible that an operator configures the\n       timeout\
    \ and the methods to address particular local specifics,\n       and this further\
    \ weakens the protection.  An operator concerned\n       about replay attack protection\
    \ strength should understand these\n       factors and their meaning in a given\
    \ network segment.\n       That said, a particular form of replay attack on this\
    \ mechanism\n       remains possible anyway.  Whether there are two or more network\n\
    \       segments using the same CSA and there is an adversary that\n       captures\
    \ Babel packets on one segment and replays on another (and\n       vice versa,\
    \ due to the bidirectional reachability requirement for\n       neighbourship),\
    \ some of the speakers on one such segment will\n       detect the \"virtual\"\
    \ neighbours from another and may prefer them\n       for some destinations. \
    \ This applies even more so as Babel\n       doesn't require a common pre-configured\
    \ network prefix between\n       neighbours.\n       A reliable solution to this\
    \ particular problem, which Section 4.5\n       of [RFC7186] discusses as well,\
    \ is not currently known.  It is\n       recommended that the operators use distinct\
    \ CSAs for distinct\n       network segments.\n   The following in-scope concerns\
    \ are not addressed:\n   f.  Offline Cryptographic Attacks\n       This mechanism\
    \ is obviously subject to offline cryptographic\n       attacks.  As soon as an\
    \ attacker has obtained a copy of an\n       authenticated Babel packet of interest\
    \ (which gets easier to do\n       in wireless networks), he has all of the parameters\
    \ of the\n       authentication-specific processing performed by the sender,\n\
    \       except for authentication key(s) and the choice of particular\n      \
    \ hash algorithm(s).  Since digest lengths of common hash\n       algorithms are\
    \ well known and can be matched with those seen in\n       the packet, the complexity\
    \ of this attack is essentially that of\n       the authentication key attack.\n\
    \       Viewing the cryptographic strength of particular hash algorithms\n   \
    \    as a concern of its own, the main practical means of resisting\n       offline\
    \ cryptographic attacks on this mechanism are periodic\n       rekeying and the\
    \ use of strong keys with a sufficient number of\n       random bits.\n      \
    \ It is important to understand that in the case of multiple keys\n       being\
    \ used within a single interface (for multi-domain\n       authentication or during\
    \ a key rollover) the strength of the\n       combined configuration would be\
    \ that of the weakest key, since\n       only one successful HMAC test is required\
    \ for an authentic\n       packet.  Operators concerned about offline cryptographic\
    \ attacks\n       should enforce the same strength policy for all keys used for\
    \ a\n       given interface.\n       Note that a special pathological case is\
    \ possible with this\n       mechanism.  Whenever two or more authentication keys\
    \ are\n       configured for a given interface such that all keys share the\n\
    \       same AuthKeyOctets and the same HashAlgo, but LocalKeyID modulo\n    \
    \   2^16 is different for each key, these keys will not be treated as\n      \
    \ duplicate (Section 5.2 item 4), but an HMAC result computed for a\n       given\
    \ packet will be the same for each of these keys.  In the\n       case of the\
    \ sending procedure, this can produce multiple HMAC\n       TLVs with exactly\
    \ the same value of the Digest field but\n       different values of the KeyID\
    \ field.  In this case, the attacker\n       will see that the keys are the same,\
    \ even without knowledge of\n       the key itself.  The reuse of authentication\
    \ keys is not the\n       intended use case of this mechanism and should be strongly\n\
    \       avoided.\n   g.  Non-repudiation\n       This specification relies on\
    \ the use of shared keys.  There is no\n       timestamp infrastructure and no\
    \ key-revocation mechanism defined\n       to address the compromise of a shared\
    \ key.  Establishing the time\n       that a particular authentic Babel packet\
    \ was generated is thus\n       not possible.  Proving that a particular Babel\
    \ speaker had\n       actually sent a given authentic packet is also impossible\
    \ as soon\n       as the shared key is claimed compromised.  Even if the shared\
    \ key\n       is not compromised, reliably identifying the speaker that had\n\
    \       actually sent a given authentic Babel packet is not possible.\n      \
    \ Since any of the speakers sharing a key can impersonate any other\n       speaker\
    \ sharing the same key, it is only possible to prove that\n       the speaker\
    \ belongs to the group sharing the key.\n   h.  Confidentiality Violations\n \
    \      The original Babel protocol does not encrypt any of the\n       information\
    \ contained in its packets.  The contents of a Babel\n       packet are trivial\
    \ to decode and thus can reveal network topology\n       details.  This mechanism\
    \ does not improve this situation in any\n       way.  Since routing protocol\
    \ messages are not the only kind of\n       information subject to confidentiality\
    \ concerns, a complete\n       solution to this problem is likely to include measures\
    \ based on\n       the channel security model, such as IPsec and Wi-Fi Protected\n\
    \       Access 2 (WPA2) at the time of this writing.\n   i.  Key Management\n\
    \       Any authentication key exchange/distribution concerns are out of\n   \
    \    scope.  However, the internal representation of authentication\n       keys\
    \ (see Section 3.8) allows implementations to use such diverse\n       key-management\
    \ techniques as manual configuration, a provisioning\n       system, a key-management\
    \ protocol, or any other means that comply\n       with this specification.\n\
    \   j.  Message Deletion\n       Any message deletion attacks are out of scope.\
    \  Since a datagram\n       deleted by an attacker cannot be distinguished from\
    \ a datagram\n       naturally lost in transmission, and since datagram-based\
    \ routing\n       protocols are designed to withstand a certain loss of packets,\n\
    \       the currently established practice is treating authentication\n      \
    \ purely as a per-packet function, without any added detection of\n       lost\
    \ packets.\n"
- title: 9.  IANA Considerations
  contents:
  - "9.  IANA Considerations\n   At the time of publication of this document, the\
    \ Babel TLV Types\n   namespace did not have an IANA registry.  TLV types 11 and\
    \ 12 were\n   assigned (see Table 1 in Appendix A) to the TS/PC and HMAC TLV types\n\
    \   by Juliusz Chroboczek, designer of the original Babel protocol.\n   Therefore,\
    \ this document has no IANA actions.\n"
- title: 10.  Acknowledgements
  contents:
  - "10.  Acknowledgements\n   Thanks to Randall Atkinson and Matthew Fanto for their\
    \ comprehensive\n   work on [RIP2-AUTH] that initiated a series of publications\
    \ on\n   routing protocol authentication, including this one.  This\n   specification\
    \ adopts many concepts belonging to the whole series.\n   Thanks to Juliusz Chroboczek,\
    \ Gabriel Kerneis, and Matthieu Boutier.\n   This document incorporates many technical\
    \ and editorial corrections\n   based on their feedback.  Thanks to all contributors\
    \ to Babel,\n   because this work would not be possible without the prior works.\n\
    \   Thanks to Dominic Mulligan for editorial proofreading of this\n   document.\
    \  Thanks to Riku Hietamaki for suggesting the test vectors\n   section.\n   Thanks\
    \ to Joel Halpern, Jim Schaad, Randall Atkinson, and Stephen\n   Farrell for providing\
    \ (in chronological order) valuable feedback on\n   earlier versions of this document.\n\
    \   Thanks to Jim Gettys and Dave Taht for developing the CeroWrt\n   wireless\
    \ router project and collaborating on many integration issues.\n   A practical\
    \ need for Babel authentication emerged during research\n   based on CeroWrt that\
    \ eventually became the very first use case of\n   this mechanism.\n   Thanks\
    \ to Kunihiro Ishiguro and Paul Jakma for establishing the GNU\n   Zebra and Quagga\
    \ routing software projects, respectively.  Thanks to\n   Werner Koch, the author\
    \ of Libgcrypt.  The very first implementation\n   of this mechanism was made\
    \ on a base of Quagga and Libgcrypt.\n"
- title: 11.  References
  contents:
  - '11.  References

    '
- title: 11.1.  Normative References
  contents:
  - "11.1.  Normative References\n   [RFC2104]  Krawczyk, H., Bellare, M., and R.\
    \ Canetti, \"HMAC:\n              Keyed-Hashing for Message Authentication\",\
    \ RFC 2104,\n              February 1997.\n   [RFC2119]  Bradner, S., \"Key words\
    \ for use in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC\
    \ 2119, March 1997.\n   [RFC4291]  Hinden, R. and S. Deering, \"IP Version 6 Addressing\n\
    \              Architecture\", RFC 4291, February 2006.\n   [FIPS-198] National\
    \ Institute of Standards and Technology, \"The\n              Keyed-Hash Message\
    \ Authentication Code (HMAC)\", FIPS\n              PUB 198-1, July 2008.\n  \
    \ [BABEL]    Chroboczek, J., \"The Babel Routing Protocol\", RFC 6126,\n     \
    \         April 2011.\n"
- title: 11.2.  Informative References
  contents:
  - "11.2.  Informative References\n   [RFC3315]  Droms, R., Bound, J., Volz, B.,\
    \ Lemon, T., Perkins, C.,\n              and M. Carney, \"Dynamic Host Configuration\
    \ Protocol for\n              IPv6 (DHCPv6)\", RFC 3315, July 2003.\n   [RFC3931]\
    \  Lau, J., Townsley, M., and I. Goyret, \"Layer Two Tunneling\n             \
    \ Protocol - Version 3 (L2TPv3)\", RFC 3931, March 2005.\n   [RFC4030]  Stapp,\
    \ M. and T. Lemon, \"The Authentication Suboption for\n              the Dynamic\
    \ Host Configuration Protocol (DHCP) Relay Agent\n              Option\", RFC\
    \ 4030, March 2005.\n   [RFC4107]  Bellovin, S. and R. Housley, \"Guidelines for\
    \ Cryptographic\n              Key Management\", BCP 107, RFC 4107, June 2005.\n\
    \   [RFC4270]  Hoffman, P. and B. Schneier, \"Attacks on Cryptographic\n     \
    \         Hashes in Internet Protocols\", RFC 4270, November 2005.\n   [RFC4302]\
    \  Kent, S., \"IP Authentication Header\", RFC 4302,\n              December 2005.\n\
    \   [RIP2-AUTH]\n              Atkinson, R. and M. Fanto, \"RIPv2 Cryptographic\n\
    \              Authentication\", RFC 4822, February 2007.\n   [RFC4962]  Housley,\
    \ R. and B. Aboba, \"Guidance for Authentication,\n              Authorization,\
    \ and Accounting (AAA) Key Management\",\n              BCP 132, RFC 4962, July\
    \ 2007.\n   [RFC5176]  Chiba, M., Dommety, G., Eklund, M., Mitton, D., and B.\n\
    \              Aboba, \"Dynamic Authorization Extensions to Remote\n         \
    \     Authentication Dial In User Service (RADIUS)\", RFC 5176,\n            \
    \  January 2008.\n   [ISIS-AUTH-A]\n              Li, T. and R. Atkinson, \"IS-IS\
    \ Cryptographic\n              Authentication\", RFC 5304, October 2008.\n   [ISIS-AUTH-B]\n\
    \              Bhatia, M., Manral, V., Li, T., Atkinson, R., White, R.,\n    \
    \          and M. Fanto, \"IS-IS Generic Cryptographic\n              Authentication\"\
    , RFC 5310, February 2009.\n   [OSPF2-AUTH]\n              Bhatia, M., Manral,\
    \ V., Fanto, M., White, R., Barnes, M.,\n              Li, T., and R. Atkinson,\
    \ \"OSPFv2 HMAC-SHA Cryptographic\n              Authentication\", RFC 5709, October\
    \ 2009.\n   [RFC6039]  Manral, V., Bhatia, M., Jaeggli, J., and R. White, \"Issues\n\
    \              with Existing Cryptographic Protection Methods for Routing\n  \
    \            Protocols\", RFC 6039, October 2010.\n   [RFC6151]  Turner, S. and\
    \ L. Chen, \"Updated Security Considerations\n              for the MD5 Message-Digest\
    \ and the HMAC-MD5 Algorithms\",\n              RFC 6151, March 2011.\n   [RFC6194]\
    \  Polk, T., Chen, L., Turner, S., and P. Hoffman, \"Security\n              Considerations\
    \ for the SHA-0 and SHA-1 Message-Digest\n              Algorithms\", RFC 6194,\
    \ March 2011.\n   [OSPF3-AUTH]\n              Bhatia, M., Manral, V., and A. Lindem,\
    \ \"Supporting\n              Authentication Trailer for OSPFv3\", RFC 6506,\n\
    \              February 2012.\n   [RFC6709]  Carpenter, B., Aboba, B., and S.\
    \ Cheshire, \"Design\n              Considerations for Protocol Extensions\",\
    \ RFC 6709,\n              September 2012.\n   [BABEL-EXTENSION]\n           \
    \   Chroboczek, J., \"Extension Mechanism for the Babel Routing\n            \
    \  Protocol\", Work in Progress, June 2014.\n   [OSPF3-AUTH-BIS]\n           \
    \   Bhatia, M., Manral, V., and A. Lindem, \"Supporting\n              Authentication\
    \ Trailer for OSPFv3\", RFC 7166, March 2014.\n   [RFC7183]  Herberg, U., Dearlove,\
    \ C., and T. Clausen, \"Integrity\n              Protection for the Neighborhood\
    \ Discovery Protocol (NHDP)\n              and Optimized Link State Routing Protocol\
    \ Version 2\n              (OLSRv2)\", RFC 7183, April 2014.\n   [RFC7186]  Yi,\
    \ J., Herberg, U., and T. Clausen, \"Security Threats for\n              the Neighborhood\
    \ Discovery Protocol (NHDP)\", RFC 7186,\n              April 2014.\n"
- title: Appendix A.  Figures and Tables
  contents:
  - "Appendix A.  Figures and Tables\n      +-------------------------------------------------------------+\n\
    \      |              authentication-specific statistics             |\n     \
    \ +-------------------------------------------------------------+\n        ^ \
    \                           |                            ^\n        |        \
    \                    v                            |\n        |    +-----------------------------------------------+\
    \    |\n        |    |                system operator                |    |\n\
    \        |    +-----------------------------------------------+    |\n       \
    \ |        ^ |      ^ |       ^ |       ^ |      ^ |        |\n        |     \
    \   | v      | |       | |       | |      | v        |\n      +---+  +---------+\
    \  | |       | |       | |  +---------+  +---+\n      |   |->|   ANM   |  | |\
    \       | |       | |  | LocalTS |->|   |\n      | R |<-|  table  |  | |     \
    \  | |       | |  | LocalPC |<-| T |\n      | x |  +---------+  | v       | v\
    \       | v  +---------+  | x |\n      |   |  +----------------+ +---------+ +----------------+\
    \  |   |\n      | p |  | MaxDigestsIn   | |         | | MaxDigestsOut  |  | p\
    \ |\n      | r |<-| ANM timeout    | |  CSAs   | |                |->| r |\n \
    \     | o |  | RxAuthRequired | |         | |                |  | o |\n      |\
    \ c |  +----------------+ +---------+ +----------------+  | c |\n      | e | \
    \ +-------------+     |       |     +-------------+  | e |\n      | s |  |   Rx\
    \ ESAs   |     |       |     |   Tx ESAs   |  | s |\n      | s |<-| (temporary)\
    \ |<----+       +---->| (temporary) |->| s |\n      | i |  +-------------+   \
    \                +-------------+  | i |\n      | n |  +------------------------------+----------------+\
    \  | n |\n      | g |  |     instance of              | output buffers |=>| g\
    \ |\n      |   |=>|     the original             +----------------+  |   |\n \
    \     |   |  |     protocol                 | source address |->|   |\n      +---+\
    \  +------------------------------+----------------+  +---+\n       /\\      \
    \                                      |            ||\n       ||            \
    \                                v            \\/\n      +-------------------------------------------------------------+\n\
    \      |                        network stack                        |\n     \
    \ +-------------------------------------------------------------+\n         /\\\
    \ ||       /\\ ||                       /\\ ||       /\\ ||\n         || \\/ \
    \      || \\/                       || \\/       || \\/\n      +---------+ +---------+\
    \                 +---------+ +---------+\n      | speaker | | speaker |     \
    \  ...       | speaker | | speaker |\n      +---------+ +---------+          \
    \       +---------+ +---------+\n      Flow of control data           : --->\n\
    \      Flow of Babel datagrams/packets: ===>\n                       Figure 1:\
    \ Interaction Diagram\n                  P\n   |<---------------------------->|\
    \                                 (D1)\n   |                B             |\n\
    \   |  |<------------------------->|\n   |  |                           |\n  \
    \ +--+-----+-----+...+-----+-----+--+   P: Babel packet\n   |H |some |some | \
    \  |some |some |T |   H: Babel packet header\n   |  |TLV  |TLV  |   |TLV  |TLV\
    \  |  |   B: Babel packet body\n   |  |     |     |   |     |     |  |   T: optional\
    \ trailing data block\n   +--+-----+-----+...+-----+-----+--+\n              \
    \                 P\n   |<----------------------------------------------------->|\
    \        (D2)\n   |                             B                         |\n\
    \   |  |<-------------------------------------------------->|\n   |  |       \
    \                                             |\n   +--+-----+-----+...+-----+-----+------+------+...+------+--+\n\
    \   |H |some |some |   |some |some |TS/PC |HMAC  |   |HMAC  |T |\n   |  |TLV \
    \ |TLV  |   |TLV  |TLV  |TLV   |TLV 1 |   |TLV n |  |\n   |  |     |     |   |\
    \     |     |      |      |   |      |  |\n   +--+-----+-----+...+-----+-----+------+------+...+------+--+\n\
    \                               P\n   |<----------------------------------------------------->|\
    \        (D3)\n   |                             B                         |\n\
    \   |  |<-------------------------------------------------->|\n   |  |       \
    \                                             |\n   +--+------+------+...+------+-----+-----+...+-----+-----+--+\n\
    \   |H |TS/PC |HMAC  |   |HMAC  |some |some |   |some |some |T |\n   |  |TLV \
    \  |TLV 1 |   |TLV n |TLV  |TLV  |   |TLV  |TLV  |  |\n   |  |      |      | \
    \  |      |     |     |   |     |     |  |\n   +--+------+------+...+------+-----+-----+...+-----+-----+--+\n\
    \                                  P\n   |<------------------------------------------------------------>|\
    \ (D4)\n   |                                B                             |\n\
    \   |  |<--------------------------------------------------------->|\n   |  |\
    \                                                           |\n   +--+-----+------+-----+------+...+-----+------+...+------+-----+--+\n\
    \   |H |some |HMAC  |some |HMAC  |   |some |HMAC  |   |TS/PC |some |T |\n   |\
    \  |TLV  |TLV 1 |TLV  |TLV 2 |   |TLV  |TLV n |   |TLV   |TLV  |  |\n   |  | \
    \    |      |     |      |   |     |      |   |      |     |  |\n   +--+-----+------+-----+------+...+-----+------+...+------+-----+--+\n\
    \                    Figure 2: Babel Datagram Structure\n            +-------+-------------------------+---------------+\n\
    \            | Value | Name                    | Reference     |\n           \
    \ +-------+-------------------------+---------------+\n            |     0 | Pad1\
    \                    | [BABEL]       |\n            |     1 | PadN           \
    \         | [BABEL]       |\n            |     2 | Acknowledgement Request | [BABEL]\
    \       |\n            |     3 | Acknowledgement         | [BABEL]       |\n \
    \           |     4 | Hello                   | [BABEL]       |\n            |\
    \     5 | IHU                     | [BABEL]       |\n            |     6 | Router-Id\
    \               | [BABEL]       |\n            |     7 | Next Hop            \
    \    | [BABEL]       |\n            |     8 | Update                  | [BABEL]\
    \       |\n            |     9 | Route Request           | [BABEL]       |\n \
    \           |    10 | Seqno Request           | [BABEL]       |\n            |\
    \    11 | TS/PC                   | this document |\n            |    12 | HMAC\
    \                    | this document |\n            +-------+-------------------------+---------------+\n\
    \                   Table 1: Babel TLV Types 0 through 12\n    +--------------+-----------------------------+-------------------+\n\
    \    | Packet field | Packet octets (hexadecimal) | Meaning (decimal) |\n    +--------------+-----------------------------+-------------------+\n\
    \    | Magic        | 2a                          | 42                |\n    |\
    \ Version      | 02                          | version 2         |\n    | Body\
    \ length  | 00:14                       | 20 octets         |\n    | [TLV] Type\
    \   | 04                          | 4 (Hello)         |\n    | [TLV] Length |\
    \ 06                          | 6 octets          |\n    | Reserved     | 00:00\
    \                       | no meaning        |\n    | Seqno        | 09:25    \
    \                   | 2341              |\n    | Interval     | 01:90        \
    \               | 400 (4.00 s)      |\n    | [TLV] Type   | 08               \
    \           | 8 (Update)        |\n    | [TLV] Length | 0a                   \
    \       | 10 octets         |\n    | AE           | 00                       \
    \   | 0 (wildcard)      |\n    | Flags        | 40                          |\
    \ default router-id |\n    | Plen         | 00                          | 0 bits\
    \            |\n    | Omitted      | 00                          | 0 bits    \
    \        |\n    | Interval     | ff:ff                       | infinity      \
    \    |\n    | Seqno        | 68:21                       | 26657             |\n\
    \    | Metric       | ff:ff                       | infinity          |\n    +--------------+-----------------------------+-------------------+\n\
    \            Table 2: A Babel Packet without Authentication TLVs\n   +---------------+-------------------------------+-------------------+\n\
    \   | Packet field  | Packet octets (hexadecimal)   | Meaning (decimal) |\n  \
    \ +---------------+-------------------------------+-------------------+\n   |\
    \ Magic         | 2a                            | 42                |\n   | Version\
    \       | 02                            | version 2         |\n   | Body length\
    \   | 00:4c                         | 76 octets         |\n   | [TLV] Type   \
    \ | 04                            | 4 (Hello)         |\n   | [TLV] Length  |\
    \ 06                            | 6 octets          |\n   | Reserved      | 00:00\
    \                         | no meaning        |\n   | Seqno         | 09:25  \
    \                       | 2341              |\n   | Interval      | 01:90    \
    \                     | 400 (4.00 s)      |\n   | [TLV] Type    | 08         \
    \                   | 8 (Update)        |\n   | [TLV] Length  | 0a           \
    \                 | 10 octets         |\n   | AE            | 00             \
    \               | 0 (wildcard)      |\n   | Flags         | 40               \
    \             | default router-id |\n   | Plen          | 00                 \
    \           | 0 bits            |\n   | Omitted       | 00                   \
    \         | 0 bits            |\n   | Interval      | ff:ff                  \
    \       | infinity          |\n   | Seqno         | 68:21                    \
    \     | 26657             |\n   | Metric        | ff:ff                      \
    \   | infinity          |\n   | [TLV] Type    | 0b                           \
    \ | 11 (TS/PC)        |\n   | [TLV] Length  | 06                            |\
    \ 6 octets          |\n   | PacketCounter | 00:01                         | 1\
    \                 |\n   | Timestamp     | 52:1d:7e:8b                   | 1377664651\
    \        |\n   | [TLV] Type    | 0c                            | 12 (HMAC)   \
    \      |\n   | [TLV] Length  | 16                            | 22 octets     \
    \    |\n   | KeyID         | 00:c8                         | 200             \
    \  |\n   | Digest        | fe:80:00:00:00:00:00:00:0a:11 | padding           |\n\
    \   |               | 96:ff:fe:1c:10:c8:00:00:00:00 |                   |\n  \
    \ | [TLV] Type    | 0c                            | 12 (HMAC)         |\n   |\
    \ [TLV] Length  | 16                            | 22 octets         |\n   | KeyID\
    \         | 00:64                         | 100               |\n   | Digest \
    \       | fe:80:00:00:00:00:00:00:0a:11 | padding           |\n   |          \
    \     | 96:ff:fe:1c:10:c8:00:00:00:00 |                   |\n   +---------------+-------------------------------+-------------------+\n\
    \   Table 3: A Babel Packet with Each HMAC TLV Padded Using IPv6 Address\n   \
    \                      fe80::0a11:96ff:fe1c:10c8\n   +---------------+-------------------------------+-------------------+\n\
    \   | Packet field  | Packet octets (hexadecimal)   | Meaning (decimal) |\n  \
    \ +---------------+-------------------------------+-------------------+\n   |\
    \ Magic         | 2a                            | 42                |\n   | Version\
    \       | 02                            | version 2         |\n   | Body length\
    \   | 00:4c                         | 76 octets         |\n   | [TLV] Type   \
    \ | 04                            | 4 (Hello)         |\n   | [TLV] Length  |\
    \ 06                            | 6 octets          |\n   | Reserved      | 00:00\
    \                         | no meaning        |\n   | Seqno         | 09:25  \
    \                       | 2341              |\n   | Interval      | 01:90    \
    \                     | 400 (4.00 s)      |\n   | [TLV] Type    | 08         \
    \                   | 8 (Update)        |\n   | [TLV] Length  | 0a           \
    \                 | 10 octets         |\n   | AE            | 00             \
    \               | 0 (wildcard)      |\n   | Flags         | 40               \
    \             | default router-id |\n   | Plen          | 00                 \
    \           | 0 bits            |\n   | Omitted       | 00                   \
    \         | 0 bits            |\n   | Interval      | ff:ff                  \
    \       | infinity          |\n   | Seqno         | 68:21                    \
    \     | 26657             |\n   | Metric        | ff:ff                      \
    \   | infinity          |\n   | [TLV] Type    | 0b                           \
    \ | 11 (TS/PC)        |\n   | [TLV] Length  | 06                            |\
    \ 6 octets          |\n   | PacketCounter | 00:01                         | 1\
    \                 |\n   | Timestamp     | 52:1d:7e:8b                   | 1377664651\
    \        |\n   | [TLV] Type    | 0c                            | 12 (HMAC)   \
    \      |\n   | [TLV] Length  | 16                            | 22 octets     \
    \    |\n   | KeyID         | 00:c8                         | 200             \
    \  |\n   | Digest        | c6:f1:06:13:30:3c:fa:f3:eb:5d | HMAC result       |\n\
    \   |               | 60:3a:ed:fd:06:55:83:f7:ee:79 |                   |\n  \
    \ | [TLV] Type    | 0c                            | 12 (HMAC)         |\n   |\
    \ [TLV] Length  | 16                            | 22 octets         |\n   | KeyID\
    \         | 00:64                         | 100               |\n   | Digest \
    \       | df:32:16:5e:d8:63:16:e5:a6:4d | HMAC result       |\n   |          \
    \     | c7:73:e0:b5:22:82:ce:fe:e2:3c |                   |\n   +---------------+-------------------------------+-------------------+\n\
    \   Table 4: A Babel Packet with Each HMAC TLV Containing an HMAC Result\n"
- title: Appendix B.  Test Vectors
  contents:
  - "Appendix B.  Test Vectors\n   The test vectors below may be used to verify the\
    \ correctness of some\n   procedures performed by an implementation of this mechanism,\
    \ namely:\n   o  appending TS/PC and HMAC TLVs to the Babel packet body,\n   o\
    \  padding the HMAC TLV(s),\n   o  computation of the HMAC result(s), and\n  \
    \ o  placement of the result(s) in the TLV(s).\n   This verification isn't exhaustive.\
    \  There are other important\n   implementation aspects that would require testing\
    \ methods of\n   their own.\n   The test vectors were produced as follows.\n \
    \  1.  A Babel speaker with a network interface with IPv6 link-local\n       address\
    \ fe80::0a11:96ff:fe1c:10c8 was configured to use two CSAs\n       for the interface:\n\
    \       *  CSA1={HashAlgo=RIPEMD-160, KeyChain={{LocalKeyID=200,\n          AuthKeyOctets=Key26}}}\n\
    \       *  CSA2={HashAlgo=SHA-1, KeyChain={{LocalKeyId=100,\n          AuthKeyOctets=Key70}}}\n\
    \       The authentication keys above are:\n       *  Key26 in ASCII:\n      \
    \    ABCDEFGHIJKLMNOPQRSTUVWXYZ\n       *  Key26 in hexadecimal:\n          41:42:43:44:45:46:47:48:49:4a:4b:4c:4d:4e:4f:50\n\
    \          51:52:53:54:55:56:57:58:59:5a\n       *  Key70 in ASCII:\n  This=key=is=exactly=70=octets=long.=ABCDEFGHIJKLMNOPQRSTUVWXYZ01234567\n\
    \       *  Key70 in hexadecimal:\n          54:68:69:73:3d:6b:65:79:3d:69:73:3d:65:78:61:63\n\
    \          74:6c:79:3d:37:30:3d:6f:63:74:65:74:73:3d:6c:6f\n          6e:67:2e:3d:41:42:43:44:45:46:47:48:49:4a:4b:4c\n\
    \          4d:4e:4f:50:51:52:53:54:55:56:57:58:59:5a:30:31\n          32:33:34:35:36:37\n\
    \       The length of each key was picked to relate (using the terms\n       listed\
    \ in Section 2.4) to the properties of its respective hash\n       algorithm as\
    \ follows:\n       *  the digest length (L) of both RIPEMD-160 and SHA-1 is 20\n\
    \          octets,\n       *  the internal block size (B) of both RIPEMD-160 and\
    \ SHA-1 is 64\n          octets,\n       *  the length of Key26 (26) is greater\
    \ than L but less than B,\n          and\n       *  the length of Key70 (70) is\
    \ greater than B (and thus greater\n          than L).\n       KeyStartAccept,\
    \ KeyStopAccept, KeyStartGenerate, and\n       KeyStopGenerate were set to make\
    \ both authentication keys valid.\n   2.  The instance of the original protocol\
    \ of the speaker produced a\n       Babel packet (PktO) to be sent from the interface.\
    \  Table 2\n       provides a decoding of PktO, the contents of which are below:\n\
    \       2a:02:00:14:04:06:00:00:09:25:01:90:08:0a:00:40\n       00:00:ff:ff:68:21:ff:ff\n\
    \   3.  The authentication mechanism appended one TS/PC TLV and two HMAC\n   \
    \    TLVs to the packet body, updated the \"Body length\" packet header\n    \
    \   field, and padded the Digest field of the HMAC TLVs, using the\n       link-local\
    \ IPv6 address of the interface and the necessary amount\n       of zeroes.  Table\
    \ 3 provides a decoding of the resulting\n       temporary packet (PktT), the\
    \ contents of which are below:\n       2a:02:00:4c:04:06:00:00:09:25:01:90:08:0a:00:40\n\
    \       00:00:ff:ff:68:21:ff:ff:0b:06:00:01:52:1d:7e:8b\n       0c:16:00:c8:fe:80:00:00:00:00:00:00:0a:11:96:ff\n\
    \       fe:1c:10:c8:00:00:00:00:0c:16:00:64:fe:80:00:00\n       00:00:00:00:0a:11:96:ff:fe:1c:10:c8:00:00:00:00\n\
    \   4.  The authentication mechanism produced two HMAC results,\n       performing\
    \ the computations as follows:\n       *  For H=RIPEMD-160, K=Key26, and Text=PktT,\
    \ the HMAC result is:\n          c6:f1:06:13:30:3c:fa:f3:eb:5d:60:3a:ed:fd:06:55\n\
    \          83:f7:ee:79\n       *  For H=SHA-1, K=Key70, and Text=PktT, the HMAC\
    \ result is:\n          df:32:16:5e:d8:63:16:e5:a6:4d:c7:73:e0:b5:22:82\n    \
    \      ce:fe:e2:3c\n   5.  The authentication mechanism placed each HMAC result\
    \ into its\n       respective HMAC TLV, producing the final authenticated Babel\n\
    \       packet (PktA), which was eventually sent from the interface.\n       Table\
    \ 4 provides a decoding of PktA, the contents of which are\n       below:\n  \
    \     2a:02:00:4c:04:06:00:00:09:25:01:90:08:0a:00:40\n       00:00:ff:ff:68:21:ff:ff:0b:06:00:01:52:1d:7e:8b\n\
    \       0c:16:00:c8:c6:f1:06:13:30:3c:fa:f3:eb:5d:60:3a\n       ed:fd:06:55:83:f7:ee:79:0c:16:00:64:df:32:16:5e\n\
    \       d8:63:16:e5:a6:4d:c7:73:e0:b5:22:82:ce:fe:e2:3c\n   Interpretation of\
    \ this process is to be done differently for the\n   sending and receiving directions\
    \ (see Figure 1).\n   For the sending direction, given a Babel speaker configured\
    \ using the\n   IPv6 address and the sequence of CSAs as described above, the\n\
    \   implementation SHOULD (see notes in Section 5.3) produce exactly the\n   temporary\
    \ packet PktT if the original protocol instance produces\n   exactly the packet\
    \ PktO to be sent from the interface.  If the\n   temporary packet exactly matches\
    \ PktT, the HMAC results computed\n   afterwards MUST exactly match the respective\
    \ results above, and the\n   final authenticated packet MUST exactly match PktA\
    \ above.\n   For the receiving direction, given a Babel speaker configured using\n\
    \   the sequence of CSAs as described above (but a different IPv6\n   address),\
    \ the implementation MUST (assuming that the TS/PC check\n   didn't fail) produce\
    \ exactly the temporary packet PktT above if its\n   network stack receives through\
    \ the interface exactly the packet PktA\n   above from the source IPv6 address\
    \ above.  The first HMAC result\n   computed afterwards MUST match the first result\
    \ above.  The receiving\n   procedure doesn't compute the second HMAC result in\
    \ this case, but if\n   the implementor decides to compute it anyway for verification\n\
    \   purposes, it MUST exactly match the second result above.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Denis Ovsienko\n   Yandex\n   16, Leo Tolstoy St.\n   Moscow\
    \  119021\n   Russia\n   EMail: infrastation@yandex.ru\n"
