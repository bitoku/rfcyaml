- contents:
  - '              Object-Based Parallel NFS (pNFS) Operations

    '
  title: __initial_text__
- contents:
  - "Abstract\n   Parallel NFS (pNFS) extends Network File System version 4 (NFSv4)
    to\n   allow clients to directly access file data on the storage used by the\n
    \  NFSv4 server.  This ability to bypass the server for data access can\n   increase
    both performance and parallelism, but requires additional\n   client functionality
    for data access, some of which is dependent on\n   the class of storage used,
    a.k.a. the Layout Type.  The main pNFS\n   operations and data types in NFSv4
    Minor version 1 specify a layout-\n   type-independent layer; layout-type-specific
    information is conveyed\n   using opaque data structures whose internal structure
    is further\n   defined by the particular layout type specification.  This document\n
    \  specifies the NFSv4.1 Object-Based pNFS Layout Type as a companion to\n   the
    main NFSv4 Minor version 1 specification.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc5664.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2010 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n
    \     1.1. Requirements Language ......................................4\n   2.
    XDR Description of the Objects-Based Layout Protocol ............4\n      2.1.
    Code Components Licensing Notice ...........................4\n   3. Basic Data
    Type Definitions .....................................6\n      3.1. pnfs_osd_objid4
    ............................................6\n      3.2. pnfs_osd_version4 ..........................................6\n
    \     3.3. pnfs_osd_object_cred4 ......................................7\n      3.4.
    pnfs_osd_raid_algorithm4 ...................................8\n   4. Object Storage
    Device Addressing and Discovery ..................8\n      4.1. pnfs_osd_targetid_type4
    ...................................10\n      4.2. pnfs_osd_deviceaddr4 ......................................10\n
    \          4.2.1. SCSI Target Identifier .............................11\n           4.2.2.
    Device Network Address .............................11\n   5. Object-Based Layout
    ............................................12\n      5.1. pnfs_osd_data_map4
    ........................................13\n      5.2. pnfs_osd_layout4 ..........................................14\n
    \     5.3. Data Mapping Schemes ......................................14\n           5.3.1.
    Simple Striping ....................................15\n           5.3.2. Nested
    Striping ....................................16\n           5.3.3. Mirroring ..........................................17\n
    \     5.4. RAID Algorithms ...........................................18\n           5.4.1.
    PNFS_OSD_RAID_0 ....................................18\n           5.4.2. PNFS_OSD_RAID_4
    ....................................18\n           5.4.3. PNFS_OSD_RAID_5 ....................................18\n
    \          5.4.4. PNFS_OSD_RAID_PQ ...................................19\n           5.4.5.
    RAID Usage and Implementation Notes ................19\n   6. Object-Based Layout
    Update .....................................20\n      6.1. pnfs_osd_deltaspaceused4
    ..................................20\n      6.2. pnfs_osd_layoutupdate4 ....................................21\n
    \  7. Recovering from Client I/O Errors ..............................21\n   8.
    Object-Based Layout Return .....................................22\n      8.1.
    pnfs_osd_errno4 ...........................................23\n      8.2. pnfs_osd_ioerr4
    ...........................................24\n      8.3. pnfs_osd_layoutreturn4
    ....................................24\n   9. Object-Based Creation Layout Hint
    ..............................25\n      9.1. pnfs_osd_layouthint4 ......................................25\n
    \  10. Layout Segments ...............................................26\n      10.1.
    CB_LAYOUTRECALL and LAYOUTRETURN .........................27\n      10.2. LAYOUTCOMMIT
    .............................................27\n   11. Recalling Layouts .............................................27\n
    \     11.1. CB_RECALL_ANY ............................................28\n   12.
    Client Fencing ................................................29\n   13. Security
    Considerations .......................................29\n      13.1. OSD Security
    Data Types ..................................30\n      13.2. The OSD Security
    Protocol ................................30\n      13.3. Protocol Privacy Requirements
    ............................32\n      13.4. Revoking Capabilities ....................................32\n
    \  14. IANA Considerations ...........................................33\n   15.
    References ....................................................33\n      15.1.
    Normative References .....................................33\n      15.2. Informative
    References ...................................34\n   Appendix A.  Acknowledgments
    ......................................35\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   In pNFS, the file server returns typed layout structures
    that\n   describe where file data is located.  There are different layouts for\n
    \  different storage systems and methods of arranging data on storage\n   devices.
    \ This document describes the layouts used with object-based\n   storage devices
    (OSDs) that are accessed according to the OSD storage\n   protocol standard (ANSI
    INCITS 400-2004 [1]).\n   An \"object\" is a container for data and attributes,
    and files are\n   stored in one or more objects.  The OSD protocol specifies several\n
    \  operations on objects, including READ, WRITE, FLUSH, GET ATTRIBUTES,\n   SET
    ATTRIBUTES, CREATE, and DELETE.  However, using the object-based\n   layout the
    client only uses the READ, WRITE, GET ATTRIBUTES, and\n   FLUSH commands.  The
    other commands are only used by the pNFS server.\n   An object-based layout for
    pNFS includes object identifiers,\n   capabilities that allow clients to READ
    or WRITE those objects, and\n   various parameters that control how file data
    is striped across their\n   component objects.  The OSD protocol has a capability-based
    security\n   scheme that allows the pNFS server to control what operations and\n
    \  what objects can be used by clients.  This scheme is described in\n   more
    detail in the \"Security Considerations\" section (Section 13).\n"
  - contents:
    - "1.1.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
      \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",
      and \"OPTIONAL\" in this\n   document are to be interpreted as described in
      RFC 2119 [2].\n"
    title: 1.1.  Requirements Language
  title: 1.  Introduction
- contents:
  - "2.  XDR Description of the Objects-Based Layout Protocol\n   This document contains
    the external data representation (XDR [3])\n   description of the NFSv4.1 objects
    layout protocol.  The XDR\n   description is embedded in this document in a way
    that makes it\n   simple for the reader to extract into a ready-to-compile form.
    \ The\n   reader can feed this document into the following shell script to\n   produce
    the machine readable XDR description of the NFSv4.1 objects\n   layout protocol:\n
    \  #!/bin/sh\n   grep '^ *///' $* | sed 's?^ */// ??' | sed 's?^ *///$??'\n   That
    is, if the above script is stored in a file called \"extract.sh\",\n   and this
    document is in a file called \"spec.txt\", then the reader can\n   do:\n   sh
    extract.sh < spec.txt > pnfs_osd_prot.x\n   The effect of the script is to remove
    leading white space from each\n   line, plus a sentinel sequence of \"///\".\n
    \  The embedded XDR file header follows.  Subsequent XDR descriptions,\n   with
    the sentinel sequence are embedded throughout the document.\n   Note that the
    XDR code contained in this document depends on types\n   from the NFSv4.1 nfs4_prot.x
    file ([4]).  This includes both nfs\n   types that end with a 4, such as offset4,
    length4, etc., as well as\n   more generic types such as uint32_t and uint64_t.\n"
  - contents:
    - "2.1.  Code Components Licensing Notice\n   The XDR description, marked with
      lines beginning with the sequence\n   \"///\", as well as scripts for extracting
      the XDR description are Code\n   Components as described in Section 4 of \"Legal
      Provisions Relating to\n   IETF Documents\" [5].  These Code Components are
      licensed according to\n   the terms of Section 4 of \"Legal Provisions Relating
      to IETF\n   Documents\".\n   /// /*\n   ///  * Copyright (c) 2010 IETF Trust
      and the persons identified\n   ///  * as authors of the code.  All rights reserved.\n
      \  ///  *\n   ///  * Redistribution and use in source and binary forms, with\n
      \  ///  * or without modification, are permitted provided that the\n   ///  *
      following conditions are met:\n   ///  *\n   ///  * o Redistributions of source
      code must retain the above\n   ///  *   copyright notice, this list of conditions
      and the\n   ///  *   following disclaimer.\n   ///  *\n   ///  * o Redistributions
      in binary form must reproduce the above\n   ///  *   copyright notice, this
      list of conditions and the\n   ///  *   following disclaimer in the documentation
      and/or other\n   ///  *   materials provided with the distribution.\n   ///
      \ *\n   ///  * o Neither the name of Internet Society, IETF or IETF\n   ///
      \ *   Trust, nor the names of specific contributors, may be\n   ///  *   used
      to endorse or promote products derived from this\n   ///  *   software without
      specific prior written permission.\n   ///  *\n   ///  *   THIS SOFTWARE IS
      PROVIDED BY THE COPYRIGHT HOLDERS\n   ///  *   AND CONTRIBUTORS \"AS IS\" AND
      ANY EXPRESS OR IMPLIED\n   ///  *   WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
      THE\n   ///  *   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n   ///  *
      \  FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO\n   ///  *   EVENT SHALL
      THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n   ///  *   LIABLE FOR ANY DIRECT, INDIRECT,
      INCIDENTAL, SPECIAL,\n   ///  *   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
      BUT\n   ///  *   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n   ///
      \ *   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n   ///  *   INTERRUPTION)
      HOWEVER CAUSED AND ON ANY THEORY OF\n   ///  *   LIABILITY, WHETHER IN CONTRACT,
      STRICT LIABILITY,\n   ///  *   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n
      \  ///  *   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n   ///  *   ADVISED
      OF THE POSSIBILITY OF SUCH DAMAGE.\n   ///  *\n   ///  * This code was derived
      from RFC 5664.\n   ///  * Please reproduce this note if possible.\n   ///  */\n
      \  ///\n   /// /*\n   ///  * pnfs_osd_prot.x\n   ///  */\n   ///\n   /// %#include
      <nfs4_prot.x>\n   ///\n"
    title: 2.1.  Code Components Licensing Notice
  title: 2.  XDR Description of the Objects-Based Layout Protocol
- contents:
  - "3.  Basic Data Type Definitions\n   The following sections define basic data
    types and constants used by\n   the Object-Based Layout protocol.\n"
  - contents:
    - "3.1.  pnfs_osd_objid4\n   An object is identified by a number, somewhat like
      an inode number.\n   The object storage model has a two-level scheme, where
      the objects\n   within an object storage device are grouped into partitions.\n
      \  /// struct pnfs_osd_objid4 {\n   ///     deviceid4       oid_device_id;\n
      \  ///     uint64_t        oid_partition_id;\n   ///     uint64_t        oid_object_id;\n
      \  /// };\n   ///\n   The pnfs_osd_objid4 type is used to identify an object
      within a\n   partition on a specified object storage device. \"oid_device_id\"\n
      \  selects the object storage device from the set of available storage\n   devices.
      \ The device is identified with the deviceid4 type, which is\n   an index into
      addressing information about that device returned by\n   the GETDEVICELIST and
      GETDEVICEINFO operations.  The deviceid4 data\n   type is defined in NFSv4.1
      [6].  Within an OSD, a partition is\n   identified with a 64-bit number, \"oid_partition_id\".
      \ Within a\n   partition, an object is identified with a 64-bit number,\n   \"oid_object_id\".
      \ Creation and management of partitions is outside\n   the scope of this document,
      and is a facility provided by the object-\n   based storage file system.\n"
    title: 3.1.  pnfs_osd_objid4
  - contents:
    - "3.2.  pnfs_osd_version4\n   /// enum pnfs_osd_version4 {\n   ///     PNFS_OSD_MISSING
      \   = 0,\n   ///     PNFS_OSD_VERSION_1  = 1,\n   ///     PNFS_OSD_VERSION_2
      \ = 2\n   /// };\n   ///\n   pnfs_osd_version4 is used to indicate the OSD protocol
      version or\n   whether an object is missing (i.e., unavailable).  Some of the\n
      \  object-based layout-supported RAID algorithms encode redundant\n   information
      and can compensate for missing components, but the data\n   placement algorithm
      needs to know what parts are missing.\n   At this time, the OSD standard is
      at version 1.0, and we anticipate a\n   version 2.0 of the standard (SNIA T10/1729-D
      [14]).  The second\n   generation OSD protocol has additional proposed features
      to support\n   more robust error recovery, snapshots, and byte-range capabilities.\n
      \  Therefore, the OSD version is explicitly called out in the\n   information
      returned in the layout.  (This information can also be\n   deduced by looking
      inside the capability type at the format field,\n   which is the first byte.
      \ The format value is 0x1 for an OSD v1\n   capability.  However, it seems most
      robust to call out the version\n   explicitly.)\n"
    title: 3.2.  pnfs_osd_version4
  - contents:
    - "3.3.  pnfs_osd_object_cred4\n   /// enum pnfs_osd_cap_key_sec4 {\n   ///     PNFS_OSD_CAP_KEY_SEC_NONE
      = 0,\n   ///     PNFS_OSD_CAP_KEY_SEC_SSV  = 1\n   /// };\n   ///\n   /// struct
      pnfs_osd_object_cred4 {\n   ///     pnfs_osd_objid4         oc_object_id;\n
      \  ///     pnfs_osd_version4       oc_osd_version;\n   ///     pnfs_osd_cap_key_sec4
      \  oc_cap_key_sec;\n   ///     opaque                  oc_capability_key<>;\n
      \  ///     opaque                  oc_capability<>;\n   /// };\n   ///\n   The
      pnfs_osd_object_cred4 structure is used to identify each\n   component comprising
      the file.  The \"oc_object_id\" identifies the\n   component object, the \"oc_osd_version\"
      represents the osd protocol\n   version, or whether that component is unavailable,
      and the\n   \"oc_capability\" and \"oc_capability_key\", along with the\n   \"oda_systemid\"
      from the pnfs_osd_deviceaddr4, provide the OSD\n   security credentials needed
      to access that object.  The\n   \"oc_cap_key_sec\" value denotes the method
      used to secure the\n   oc_capability_key (see Section 13.1 for more details).\n
      \  To comply with the OSD security requirements, the capability key\n   SHOULD
      be transferred securely to prevent eavesdropping (see\n   Section 13).  Therefore,
      a client SHOULD either issue the LAYOUTGET\n   or GETDEVICEINFO operations via
      RPCSEC_GSS with the privacy service\n   or previously establish a secret state
      verifier (SSV) for the\n   sessions via the NFSv4.1 SET_SSV operation.  The\n
      \  pnfs_osd_cap_key_sec4 type is used to identify the method used by the\n   server
      to secure the capability key.\n   o  PNFS_OSD_CAP_KEY_SEC_NONE denotes that
      the oc_capability_key is\n      not encrypted, in which case the client SHOULD
      issue the LAYOUTGET\n      or GETDEVICEINFO operations with RPCSEC_GSS with
      the privacy\n      service or the NFSv4.1 transport should be secured by using\n
      \     methods that are external to NFSv4.1 like the use of IPsec [15]\n      for
      transporting the NFSV4.1 protocol.\n   o  PNFS_OSD_CAP_KEY_SEC_SSV denotes that
      the oc_capability_key\n      contents are encrypted using the SSV GSS context
      and the\n      capability key as inputs to the GSS_Wrap() function (see GSS-API\n
      \     [7]) with the conf_req_flag set to TRUE.  The client MUST use the\n      secret
      SSV key as part of the client's GSS context to decrypt the\n      capability
      key using the value of the oc_capability_key field as\n      the input_message
      to the GSS_unwrap() function.  Note that to\n      prevent eavesdropping of
      the SSV key, the client SHOULD issue\n      SET_SSV via RPCSEC_GSS with the
      privacy service.\n   The actual method chosen depends on whether the client
      established a\n   SSV key with the server and whether it issued the operation
      with the\n   RPCSEC_GSS privacy method.  Naturally, if the client did not\n
      \  establish an SSV key via SET_SSV, the server MUST use the\n   PNFS_OSD_CAP_KEY_SEC_NONE
      method.  Otherwise, if the operation was\n   not issued with the RPCSEC_GSS
      privacy method, the server SHOULD\n   secure the oc_capability_key with the
      PNFS_OSD_CAP_KEY_SEC_SSV\n   method.  The server MAY use the PNFS_OSD_CAP_KEY_SEC_SSV
      method also\n   when the operation was issued with the RPCSEC_GSS privacy method.\n"
    title: 3.3.  pnfs_osd_object_cred4
  - contents:
    - "3.4.  pnfs_osd_raid_algorithm4\n   /// enum pnfs_osd_raid_algorithm4 {\n   ///
      \    PNFS_OSD_RAID_0     = 1,\n   ///     PNFS_OSD_RAID_4     = 2,\n   ///     PNFS_OSD_RAID_5
      \    = 3,\n   ///     PNFS_OSD_RAID_PQ    = 4     /* Reed-Solomon P+Q */\n   ///
      };\n   ///\n   pnfs_osd_raid_algorithm4 represents the data redundancy algorithm\n
      \  used to protect the file's contents.  See Section 5.4 for more\n   details.\n"
    title: 3.4.  pnfs_osd_raid_algorithm4
  title: 3.  Basic Data Type Definitions
- contents:
  - "4.  Object Storage Device Addressing and Discovery\n   Data operations to an
    OSD require the client to know the \"address\" of\n   each OSD's root object.
    \ The root object is synonymous with the Small\n   Computer System Interface (SCSI)
    logical unit.  The client specifies\n   SCSI logical units to its SCSI protocol
    stack using a representation\n   local to the client.  Because these representations
    are local,\n   GETDEVICEINFO must return information that can be used by the client\n
    \  to select the correct local representation.\n   In the block world, a set offset
    (logical block number or track/\n   sector) contains a disk label.  This label
    identifies the disk\n   uniquely.  In contrast, an OSD has a standard set of attributes
    on\n   its root object.  For device identification purposes, the OSD System\n
    \  ID (root information attribute number 3) and the OSD Name (root\n   information
    attribute number 9) are used as the label.  These appear\n   in the pnfs_osd_deviceaddr4
    type below under the \"oda_systemid\" and\n   \"oda_osdname\" fields.\n   In some
    situations, SCSI target discovery may need to be driven based\n   on information
    contained in the GETDEVICEINFO response.  One example\n   of this is Internet
    SCSI (iSCSI) targets that are not known to the\n   client until a layout has been
    requested.  The information provided\n   as the \"oda_targetid\", \"oda_targetaddr\",
    and \"oda_lun\" fields in the\n   pnfs_osd_deviceaddr4 type described below (see
    Section 4.2) allows\n   the client to probe a specific device given its network
    address and\n   optionally its iSCSI Name (see iSCSI [8]), or when the device
    network\n   address is omitted, allows it to discover the object storage device\n
    \  using the provided device name or SCSI Device Identifier (see SPC-3\n   [9].)\n
    \  The oda_systemid is implicitly used by the client, by using the\n   object
    credential signing key to sign each request with the request\n   integrity check
    value.  This method protects the client from\n   unintentionally accessing a device
    if the device address mapping was\n   changed (or revoked).  The server computes
    the capability key using\n   its own view of the systemid associated with the
    respective deviceid\n   present in the credential.  If the client's view of the
    deviceid\n   mapping is stale, the client will use the wrong systemid (which must\n
    \  be system-wide unique) and the I/O request to the OSD will fail to\n   pass
    the integrity check verification.\n   To recover from this condition the client
    should report the error and\n   return the layout using LAYOUTRETURN, and invalidate
    all the device\n   address mappings associated with this layout.  The client can
    then\n   ask for a new layout if it wishes using LAYOUTGET and resolve the\n   referenced
    deviceids using GETDEVICEINFO or GETDEVICELIST.\n   The server MUST provide the
    oda_systemid and SHOULD also provide the\n   oda_osdname.  When the OSD name is
    present, the client SHOULD get the\n   root information attributes whenever it
    establishes communication\n   with the OSD and verify that the OSD name it got
    from the OSD matches\n   the one sent by the metadata server.  To do so, the client
    uses the\n   root_obj_cred credentials.\n"
  - contents:
    - "4.1.  pnfs_osd_targetid_type4\n   The following enum specifies the manner in
      which a SCSI target can be\n   specified.  The target can be specified as a
      SCSI Name, or as an SCSI\n   Device Identifier.\n   /// enum pnfs_osd_targetid_type4
      {\n   ///     OBJ_TARGET_ANON             = 1,\n   ///     OBJ_TARGET_SCSI_NAME
      \       = 2,\n   ///     OBJ_TARGET_SCSI_DEVICE_ID   = 3\n   /// };\n   ///\n"
    title: 4.1.  pnfs_osd_targetid_type4
  - contents:
    - "4.2.  pnfs_osd_deviceaddr4\n   The specification for an object device address
      is as follows:\n"
    - '/// union pnfs_osd_targetid4 switch (pnfs_osd_targetid_type4 oti_type) {

      '
    - '///     case OBJ_TARGET_SCSI_NAME:

      '
    - '///         string              oti_scsi_name<>;

      '
    - '///

      '
    - '///     case OBJ_TARGET_SCSI_DEVICE_ID:

      '
    - '///         opaque              oti_scsi_device_id<>;

      '
    - '///

      '
    - '///     default:

      '
    - '///         void;

      '
    - '/// };

      '
    - '///

      '
    - '/// union pnfs_osd_targetaddr4 switch (bool ota_available) {

      '
    - '///     case TRUE:

      '
    - '///         netaddr4            ota_netaddr;

      '
    - '///     case FALSE:

      '
    - '///         void;

      '
    - '/// };

      '
    - '///

      '
    - '/// struct pnfs_osd_deviceaddr4 {

      '
    - '///     pnfs_osd_targetid4      oda_targetid;

      '
    - '///     pnfs_osd_targetaddr4    oda_targetaddr;

      '
    - '///     opaque                  oda_lun[8];

      '
    - '///     opaque                  oda_systemid<>;

      '
    - '///     pnfs_osd_object_cred4   oda_root_obj_cred;

      '
    - '///     opaque                  oda_osdname<>;

      '
    - '/// };

      '
    - '///

      '
    - contents:
      - "4.2.1.  SCSI Target Identifier\n   When \"oda_targetid\" is specified as
        an OBJ_TARGET_SCSI_NAME, the\n   \"oti_scsi_name\" string MUST be formatted
        as an \"iSCSI Name\" as\n   specified in iSCSI [8] and [10].  Note that the
        specification of the\n   oti_scsi_name string format is outside the scope
        of this document.\n   Parsing the string is based on the string prefix, e.g.,
        \"iqn.\",\n   \"eui.\", or \"naa.\" and more formats MAY be specified in the
        future in\n   accordance with iSCSI Names properties.\n   Currently, the iSCSI
        Name provides for naming the target device using\n   a string formatted as
        an iSCSI Qualified Name (IQN) or as an Extended\n   Unique Identifier (EUI)
        [11] string.  Those are typically used to\n   identify iSCSI or Secure Routing
        Protocol (SRP) [16] devices.  The\n   Network Address Authority (NAA) string
        format (see [10]) provides for\n   naming the device using globally unique
        identifiers, as defined in\n   Fibre Channel Framing and Signaling (FC-FS)
        [17].  These are\n   typically used to identify Fibre Channel or SAS [18]
        (Serial Attached\n   SCSI) devices.  In particular, such devices that are
        dual-attached\n   both over Fibre Channel or SAS and over iSCSI.\n   When
        \"oda_targetid\" is specified as an OBJ_TARGET_SCSI_DEVICE_ID, the\n   \"oti_scsi_device_id\"
        opaque field MUST be formatted as a SCSI Device\n   Identifier as defined
        in SPC-3 [9] VPD Page 83h (Section 7.6.3.\n   \"Device Identification VPD
        Page\").  If the Device Identifier is\n   identical to the OSD System ID,
        as given by oda_systemid, the server\n   SHOULD provide a zero-length oti_scsi_device_id
        opaque value.  Note\n   that similarly to the \"oti_scsi_name\", the specification
        of the\n   oti_scsi_device_id opaque contents is outside the scope of this\n
        \  document and more formats MAY be specified in the future in\n   accordance
        with SPC-3.\n   The OBJ_TARGET_ANON pnfs_osd_targetid_type4 MAY be used for
        providing\n   no target identification.  In this case, only the OSD System
        ID, and\n   optionally the provided network address, are used to locate the\n
        \  device.\n"
      title: 4.2.1.  SCSI Target Identifier
    - contents:
      - "4.2.2.  Device Network Address\n   The optional \"oda_targetaddr\" field
        MAY be provided by the server as\n   a hint to accelerate device discovery
        over, e.g., the iSCSI transport\n   protocol.  The network address is given
        with the netaddr4 type, which\n   specifies a TCP/IP based endpoint (as specified
        in NFSv4.1 [6]).\n   When given, the client SHOULD use it to probe for the
        SCSI device at\n   the given network address.  The client MAY still use other
        discovery\n   mechanisms such as Internet Storage Name Service (iSNS) [12]
        to\n   locate the device using the oda_targetid.  In particular, such an\n
        \  external name service SHOULD be used when the devices may be attached\n
        \  to the network using multiple connections, and/or multiple storage\n   fabrics
        (e.g., Fibre-Channel and iSCSI).\n   The \"oda_lun\" field identifies the
        OSD 64-bit Logical Unit Number,\n   formatted in accordance with SAM-3 [13].
        \ The client uses the Logical\n   Unit Number to communicate with the specific
        OSD Logical Unit.  Its\n   use is defined in detail by the SCSI transport
        protocol, e.g., iSCSI\n   [8].\n"
      title: 4.2.2.  Device Network Address
    title: 4.2.  pnfs_osd_deviceaddr4
  title: 4.  Object Storage Device Addressing and Discovery
- contents:
  - "5.  Object-Based Layout\n   The layout4 type is defined in the NFSv4.1 [6] as
    follows:\n   enum layouttype4 {\n       LAYOUT4_NFSV4_1_FILES   = 1,\n       LAYOUT4_OSD2_OBJECTS
    \   = 2,\n       LAYOUT4_BLOCK_VOLUME    = 3\n   };\n   struct layout_content4
    {\n       layouttype4             loc_type;\n       opaque                  loc_body<>;\n
    \  };\n   struct layout4 {\n       offset4                 lo_offset;\n       length4
    \                lo_length;\n       layoutiomode4           lo_iomode;\n       layout_content4
    \        lo_content;\n   };\n   This document defines structure associated with
    the layouttype4\n   value, LAYOUT4_OSD2_OBJECTS.  The NFSv4.1 [6] specifies the
    loc_body\n   structure as an XDR type \"opaque\".  The opaque layout is\n   uninterpreted
    by the generic pNFS client layers, but obviously must\n   be interpreted by the
    object storage layout driver.  This section\n   defines the structure of this
    opaque value, pnfs_osd_layout4.\n"
  - contents:
    - "5.1.  pnfs_osd_data_map4\n   /// struct pnfs_osd_data_map4 {\n   ///     uint32_t
      \                   odm_num_comps;\n   ///     length4                     odm_stripe_unit;\n
      \  ///     uint32_t                    odm_group_width;\n   ///     uint32_t
      \                   odm_group_depth;\n   ///     uint32_t                    odm_mirror_cnt;\n
      \  ///     pnfs_osd_raid_algorithm4    odm_raid_algorithm;\n   /// };\n   ///\n
      \  The pnfs_osd_data_map4 structure parameterizes the algorithm that\n   maps
      a file's contents over the component objects.  Instead of\n   limiting the system
      to simple striping scheme where loss of a single\n   component object results
      in data loss, the map parameters support\n   mirroring and more complicated
      schemes that protect against loss of a\n   component object.\n   \"odm_num_comps\"
      is the number of component objects the file is\n   striped over.  The server
      MAY grow the file by adding more components\n   to the stripe while clients
      hold valid layouts until the file has\n   reached its final stripe width.  The
      file length in this case MUST be\n   limited to the number of bytes in a full
      stripe.\n   The \"odm_stripe_unit\" is the number of bytes placed on one component\n
      \  before advancing to the next one in the list of components.  The\n   number
      of bytes in a full stripe is odm_stripe_unit times the number\n   of components.
      \ In some RAID schemes, a stripe includes redundant\n   information (i.e., parity)
      that lets the system recover from loss or\n   damage to a component object.\n
      \  The \"odm_group_width\" and \"odm_group_depth\" parameters allow a nested\n
      \  striping pattern (see Section 5.3.2 for details).  If there is no\n   nesting,
      then odm_group_width and odm_group_depth MUST be zero.  The\n   size of the
      components array MUST be a multiple of odm_group_width.\n   The \"odm_mirror_cnt\"
      is used to replicate a file by replicating its\n   component objects.  If there
      is no mirroring, then odm_mirror_cnt\n   MUST be 0.  If odm_mirror_cnt is greater
      than zero, then the size of\n   the component array MUST be a multiple of (odm_mirror_cnt+1).\n
      \  See Section 5.3 for more details.\n"
    title: 5.1.  pnfs_osd_data_map4
  - contents:
    - "5.2.  pnfs_osd_layout4\n   /// struct pnfs_osd_layout4 {\n   ///     pnfs_osd_data_map4
      \     olo_map;\n   ///     uint32_t                olo_comps_index;\n   ///
      \    pnfs_osd_object_cred4   olo_components<>;\n   /// };\n   ///\n   The pnfs_osd_layout4
      structure specifies a layout over a set of\n   component objects.  The \"olo_components\"
      field is an array of object\n   identifiers and security credentials that grant
      access to each\n   object.  The organization of the data is defined by the\n
      \  pnfs_osd_data_map4 type that specifies how the file's data is mapped\n   onto
      the component objects (i.e., the striping pattern).  The data\n   placement
      algorithm that maps file data onto component objects\n   assumes that each component
      object occurs exactly once in the array\n   of components.  Therefore, component
      objects MUST appear in the\n   olo_components array only once.  The components
      array may represent\n   all objects comprising the file, in which case \"olo_comps_index\"
      is\n   set to zero and the number of entries in the olo_components array is\n
      \  equal to olo_map.odm_num_comps.  The server MAY return fewer\n   components
      than odm_num_comps, provided that the returned components\n   are sufficient
      to access any byte in the layout's data range (e.g., a\n   sub-stripe of \"odm_group_width\"
      components).  In this case,\n   olo_comps_index represents the position of the
      returned components\n   array within the full array of components that comprise
      the file.\n   Note that the layout depends on the file size, which the client\n
      \  learns from the generic return parameters of LAYOUTGET, by doing\n   GETATTR
      commands to the metadata server.  The client uses the file\n   size to decide
      if it should fill holes with zeros or return a short\n   read.  Striping patterns
      can cause cases where component objects are\n   shorter than other components
      because a hole happens to correspond to\n   the last part of the component object.\n"
    title: 5.2.  pnfs_osd_layout4
  - contents:
    - "5.3.  Data Mapping Schemes\n   This section describes the different data mapping
      schemes in detail.\n   The object layout always uses a \"dense\" layout as described
      in\n   NFSv4.1 [6].  This means that the second stripe unit of the file\n   starts
      at offset 0 of the second component, rather than at offset\n   stripe_unit bytes.
      \ After a full stripe has been written, the next\n   stripe unit is appended
      to the first component object in the list\n   without any holes in the component
      objects.\n"
    - contents:
      - "5.3.1.  Simple Striping\n   The mapping from the logical offset within a
        file (L) to the\n   component object C and object-specific offset O is defined
        by the\n   following equations:\n   L = logical offset into the file\n   W
        = total number of components\n   S = W * stripe_unit\n   N = L / S\n   C =
        (L-(N*S)) / stripe_unit\n   O = (N*stripe_unit)+(L%stripe_unit)\n   In these
        equations, S is the number of bytes in a full stripe, and N\n   is the stripe
        number.  C is an index into the array of components, so\n   it selects a particular
        object storage device.  Both N and C count\n   from zero.  O is the offset
        within the object that corresponds to the\n   file offset.  Note that this
        computation does not accommodate the\n   same object appearing in the olo_components
        array multiple times.\n   For example, consider an object striped over four
        devices, <D0 D1 D2\n   D3>.  The stripe_unit is 4096 bytes.  The stripe width
        S is thus 4 *\n   4096 = 16384.\n   Offset 0:\n     N = 0 / 16384 = 0\n     C
        = 0-0/4096 = 0 (D0)\n     O = 0*4096 + (0%4096) = 0\n   Offset 4096:\n     N
        = 4096 / 16384 = 0\n     C = (4096-(0*16384)) / 4096 = 1 (D1)\n     O = (0*4096)+(4096%4096)
        = 0\n   Offset 9000:\n     N = 9000 / 16384 = 0\n     C = (9000-(0*16384))
        / 4096 = 2 (D2)\n     O = (0*4096)+(9000%4096) = 808\n   Offset 132000:\n
        \    N = 132000 / 16384 = 8\n     C = (132000-(8*16384)) / 4096 = 0 (D0)\n
        \    O = (8*4096) + (132000%4096) = 33696\n"
      title: 5.3.1.  Simple Striping
    - contents:
      - "5.3.2.  Nested Striping\n   The odm_group_width and odm_group_depth parameters
        allow a nested\n   striping pattern. odm_group_width defines the width of
        a data stripe\n   and odm_group_depth defines how many stripes are written
        before\n   advancing to the next group of components in the list of component\n
        \  objects for the file.  The math used to map from a file offset to a\n   component
        object and offset within that object is shown below.  The\n   computations
        map from the logical offset L to the component index C\n   and offset relative
        O within that component object.\n   L = logical offset into the file\n   W
        = total number of components\n   S = stripe_unit * group_depth * W\n   T =
        stripe_unit * group_depth * group_width\n   U = stripe_unit * group_width\n
        \  M = L / S\n   G = (L - (M * S)) / T\n   H = (L - (M * S)) % T\n   N = H
        / U\n   C = (H - (N * U)) / stripe_unit + G * group_width\n   O = L % stripe_unit
        + N * stripe_unit + M * group_depth * stripe_unit\n   In these equations,
        S is the number of bytes striped across all\n   component objects before the
        pattern repeats.  T is the number of\n   bytes striped within a group of component
        objects before advancing to\n   the next group.  U is the number of bytes
        in a stripe within a group.\n   M is the \"major\" (i.e., across all components)
        stripe number, and N\n   is the \"minor\" (i.e., across the group) stripe
        number.  G counts the\n   groups from the beginning of the major stripe, and
        H is the byte\n   offset within the group.\n   For example, consider an object
        striped over 100 devices with a\n   group_width of 10, a group_depth of 50,
        and a stripe_unit of 1 MB.\n   In this scheme, 500 MB are written to the first
        10 components, and\n   5000 MB are written before the pattern wraps back around
        to the first\n   component in the array.\n   Offset 0:\n     W = 100\n     S
        = 1 MB * 50 * 100 = 5000 MB\n     T = 1 MB * 50 * 10 = 500 MB\n     U = 1
        MB * 10 = 10 MB\n     M = 0 / 5000 MB = 0\n     G = (0 - (0 * 5000 MB)) /
        500 MB = 0\n     H = (0 - (0 * 5000 MB)) % 500 MB = 0\n     N = 0 / 10 MB
        = 0\n     C = (0 - (0 * 10 MB)) / 1 MB + 0 * 10 = 0\n     O = 0 % 1 MB + 0
        * 1 MB + 0 * 50 * 1 MB = 0\n   Offset 27 MB:\n     M = 27 MB / 5000 MB = 0\n
        \    G = (27 MB - (0 * 5000 MB)) / 500 MB = 0\n     H = (27 MB - (0 * 5000
        MB)) % 500 MB = 27 MB\n     N = 27 MB / 10 MB = 2\n     C = (27 MB - (2 *
        10 MB)) / 1 MB + 0 * 10 = 7\n     O = 27 MB % 1 MB + 2 * 1 MB + 0 * 50 * 1
        MB = 2 MB\n   Offset 7232 MB:\n     M = 7232 MB / 5000 MB = 1\n     G = (7232
        MB - (1 * 5000 MB)) / 500 MB = 4\n     H = (7232 MB - (1 * 5000 MB)) % 500
        MB = 232 MB\n     N = 232 MB / 10 MB = 23\n     C = (232 MB - (23 * 10 MB))
        / 1 MB + 4 * 10 = 42\n     O = 7232 MB % 1 MB + 23 * 1 MB + 1 * 50 * 1 MB
        = 73 MB\n"
      title: 5.3.2.  Nested Striping
    - contents:
      - "5.3.3.  Mirroring\n   The odm_mirror_cnt is used to replicate a file by replicating
        its\n   component objects.  If there is no mirroring, then odm_mirror_cnt\n
        \  MUST be 0.  If odm_mirror_cnt is greater than zero, then the size of\n
        \  the olo_components array MUST be a multiple of (odm_mirror_cnt+1).\n   Thus,
        for a classic mirror on two objects, odm_mirror_cnt is one.\n   Note that
        mirroring can be defined over any RAID algorithm and\n   striping pattern
        (either simple or nested).  If odm_group_width is\n   also non-zero, then
        the size of the olo_components array MUST be a\n   multiple of odm_group_width
        * (odm_mirror_cnt+1).  Replicas are\n   adjacent in the olo_components array,
        and the value C produced by the\n   above equations is not a direct index
        into the olo_components array.\n   Instead, the following equations determine
        the replica component\n   index RCi, where i ranges from 0 to odm_mirror_cnt.\n
        \  C = component index for striping or two-level striping\n   i ranges from
        0 to odm_mirror_cnt, inclusive\n   RCi = C * (odm_mirror_cnt+1) + i\n"
      title: 5.3.3.  Mirroring
    title: 5.3.  Data Mapping Schemes
  - contents:
    - "5.4.  RAID Algorithms\n   pnfs_osd_raid_algorithm4 determines the algorithm
      and placement of\n   redundant data.  This section defines the different redundancy\n
      \  algorithms.  Note: The term \"RAID\" (Redundant Array of Independent\n   Disks)
      is used in this document to represent an array of component\n   objects that
      store data for an individual file.  The objects are\n   stored on independent
      object-based storage devices.  File data is\n   encoded and striped across the
      array of component objects using\n   algorithms developed for block-based RAID
      systems.\n"
    - contents:
      - "5.4.1.  PNFS_OSD_RAID_0\n   PNFS_OSD_RAID_0 means there is no parity data,
        so all bytes in the\n   component objects are data bytes located by the above
        equations for C\n   and O.  If a component object is marked as PNFS_OSD_MISSING,
        the pNFS\n   client MUST either return an I/O error if this component is attempted\n
        \  to be read or, alternatively, it can retry the READ against the pNFS\n
        \  server.\n"
      title: 5.4.1.  PNFS_OSD_RAID_0
    - contents:
      - "5.4.2.  PNFS_OSD_RAID_4\n   PNFS_OSD_RAID_4 means that the last component
        object, or the last in\n   each group (if odm_group_width is greater than
        zero), contains parity\n   information computed over the rest of the stripe
        with an XOR\n   operation.  If a component object is unavailable, the client
        can read\n   the rest of the stripe units in the damaged stripe and recompute
        the\n   missing stripe unit by XORing the other stripe units in the stripe.\n
        \  Or the client can replay the READ against the pNFS server that will\n   presumably
        perform the reconstructed read on the client's behalf.\n   When parity is
        present in the file, then there is an additional\n   computation to map from
        the file offset L to the offset that accounts\n   for embedded parity, L'.
        \ First compute L', and then use L' in the\n   above equations for C and O.\n
        \  L = file offset, not accounting for parity\n   P = number of parity devices
        in each stripe\n   W = group_width, if not zero, else size of olo_components
        array\n   N = L / (W-P * stripe_unit)\n   L' = N * (W * stripe_unit) +\n        (L
        % (W-P * stripe_unit))\n"
      title: 5.4.2.  PNFS_OSD_RAID_4
    - contents:
      - "5.4.3.  PNFS_OSD_RAID_5\n   PNFS_OSD_RAID_5 means that the position of the
        parity data is rotated\n   on each stripe or each group (if odm_group_width
        is greater than\n   zero).  In the first stripe, the last component holds
        the parity.  In\n   the second stripe, the next-to-last component holds the
        parity, and\n   so on.  In this scheme, all stripe units are rotated so that
        I/O is\n   evenly spread across objects as the file is read sequentially.
        \ The\n   rotated parity layout is illustrated here, with numbers indicating\n
        \  the stripe unit.\n   0 1 2 P\n   4 5 P 3\n   8 P 6 7\n   P 9 a b\n   To
        compute the component object C, first compute the offset that\n   accounts
        for parity L' and use that to compute C.  Then rotate C to\n   get C'.  Finally,
        increase C' by one if the parity information comes\n   at or before C' within
        that stripe.  The following equations\n   illustrate this by computing I,
        which is the index of the component\n   that contains parity for a given stripe.\n
        \  L = file offset, not accounting for parity\n   W = odm_group_width, if
        not zero, else size of olo_components array\n   N = L / (W-1 * stripe_unit)\n
        \  (Compute L' as describe above)\n   (Compute C based on L' as described
        above)\n   C' = (C - (N%W)) % W\n   I = W - (N%W) - 1\n   if (C' <= I) {\n
        \    C'++\n   }\n"
      title: 5.4.3.  PNFS_OSD_RAID_5
    - contents:
      - "5.4.4.  PNFS_OSD_RAID_PQ\n   PNFS_OSD_RAID_PQ is a double-parity scheme that
        uses the Reed-Solomon\n   P+Q encoding scheme [19].  In this layout, the last
        two component\n   objects hold the P and Q data, respectively.  P is parity
        computed\n   with XOR, and Q is a more complex equation that is not described\n
        \  here.  The equations given above for embedded parity can be used to\n   map
        a file offset to the correct component object by setting the\n   number of
        parity components to 2 instead of 1 for RAID4 or RAID5.\n   Clients may simply
        choose to read data through the metadata server if\n   two components are
        missing or damaged.\n"
      title: 5.4.4.  PNFS_OSD_RAID_PQ
    - contents:
      - "5.4.5.  RAID Usage and Implementation Notes\n   RAID layouts with redundant
        data in their stripes require additional\n   serialization of updates to ensure
        correct operation.  Otherwise, if\n   two clients simultaneously write to
        the same logical range of an\n   object, the result could include different
        data in the same ranges of\n   mirrored tuples, or corrupt parity information.
        \ It is the\n   responsibility of the metadata server to enforce serialization\n
        \  requirements such as this.  For example, the metadata server may do\n   so
        by not granting overlapping write layouts within mirrored objects.\n"
      title: 5.4.5.  RAID Usage and Implementation Notes
    title: 5.4.  RAID Algorithms
  title: 5.  Object-Based Layout
- contents:
  - "6.  Object-Based Layout Update\n   layoutupdate4 is used in the LAYOUTCOMMIT
    operation to convey updates\n   to the layout and additional information to the
    metadata server.  It\n   is defined in the NFSv4.1 [6] as follows:\n   struct
    layoutupdate4 {\n       layouttype4             lou_type;\n       opaque                  lou_body<>;\n
    \  };\n   The layoutupdate4 type is an opaque value at the generic pNFS client\n
    \  level.  If the lou_type layout type is LAYOUT4_OSD2_OBJECTS, then the\n   lou_body
    opaque value is defined by the pnfs_osd_layoutupdate4 type.\n   Object-Based pNFS
    clients are not allowed to modify the layout.\n   Therefore, the information passed
    in pnfs_osd_layoutupdate4 is used\n   only to update the file's attributes.  In
    addition to the generic\n   information the client can pass to the metadata server
    in\n   LAYOUTCOMMIT such as the highest offset the client wrote to and the\n   last
    time it modified the file, the client MAY use\n   pnfs_osd_layoutupdate4 to convey
    the capacity consumed (or released)\n   by writes using the layout, and to indicate
    that I/O errors were\n   encountered by such writes.\n"
  - contents:
    - "6.1.  pnfs_osd_deltaspaceused4\n   /// union pnfs_osd_deltaspaceused4 switch
      (bool dsu_valid) {\n   ///     case TRUE:\n   ///         int64_t     dsu_delta;\n
      \  ///     case FALSE:\n   ///         void;\n   /// };\n   ///\n   pnfs_osd_deltaspaceused4
      is used to convey space utilization\n   information at the time of LAYOUTCOMMIT.
      \ For the file system to\n   properly maintain capacity-used information, it
      needs to track how\n   much capacity was consumed by WRITE operations performed
      by the\n   client.  In this protocol, the OSD returns the capacity consumed
      by a\n   write (*), which can be different than the number of bytes written\n
      \  because of internal overhead like block-level allocation and indirect\n   blocks,
      and the client reflects this back to the pNFS server so it\n   can accurately
      track quota.  The pNFS server can choose to trust this\n   information coming
      from the clients and therefore avoid querying the\n   OSDs at the time of LAYOUTCOMMIT.
      \ If the client is unable to obtain\n   this information from the OSD, it simply
      returns invalid\n   olu_delta_space_used.\n"
    title: 6.1.  pnfs_osd_deltaspaceused4
  - contents:
    - "6.2.  pnfs_osd_layoutupdate4\n   /// struct pnfs_osd_layoutupdate4 {\n   ///
      \    pnfs_osd_deltaspaceused4    olu_delta_space_used;\n   ///     bool                        olu_ioerr_flag;\n
      \  /// };\n   ///\n   \"olu_delta_space_used\" is used to convey capacity usage
      information\n   back to the metadata server.\n   The \"olu_ioerr_flag\" is used
      when I/O errors were encountered while\n   writing the file.  The client MUST
      report the errors using the\n   pnfs_osd_ioerr4 structure (see Section 8.1)
      at LAYOUTRETURN time.\n   If the client updated the file successfully before
      hitting the I/O\n   errors, it MAY use LAYOUTCOMMIT to update the metadata server
      as\n   described above.  Typically, in the error-free case, the server MAY\n
      \  turn around and update the file's attributes on the storage devices.\n   However,
      if I/O errors were encountered, the server better not\n   attempt to write the
      new attributes on the storage devices until it\n   receives the I/O error report;
      therefore, the client MUST set the\n   olu_ioerr_flag to true.  Note that in
      this case, the client SHOULD\n   send both the LAYOUTCOMMIT and LAYOUTRETURN
      operations in the same\n   COMPOUND RPC.\n"
    title: 6.2.  pnfs_osd_layoutupdate4
  title: 6.  Object-Based Layout Update
- contents:
  - "7.  Recovering from Client I/O Errors\n   The pNFS client may encounter errors
    when directly accessing the\n   object storage devices.  However, it is the responsibility
    of the\n   metadata server to handle the I/O errors.  When the\n   LAYOUT4_OSD2_OBJECTS
    layout type is used, the client MUST report the\n   I/O errors to the server at
    LAYOUTRETURN time using the\n   pnfs_osd_ioerr4 structure (see Section 8.1).\n
    \  The metadata server analyzes the error and determines the required\n   recovery
    operations such as repairing any parity inconsistencies,\n   recovering media
    failures, or reconstructing missing objects.\n   The metadata server SHOULD recall
    any outstanding layouts to allow it\n   exclusive write access to the stripes
    being recovered and to prevent\n   other clients from hitting the same error condition.
    \ In these cases,\n   the server MUST complete recovery before handing out any
    new layouts\n   to the affected byte ranges.\n   Although it MAY be acceptable
    for the client to propagate a\n   corresponding error to the application that
    initiated the I/O\n   operation and drop any unwritten data, the client SHOULD
    attempt to\n   retry the original I/O operation by requesting a new layout using\n
    \  LAYOUTGET and retry the I/O operation(s) using the new layout, or the\n   client
    MAY just retry the I/O operation(s) using regular NFS READ or\n   WRITE operations
    via the metadata server.  The client SHOULD attempt\n   to retrieve a new layout
    and retry the I/O operation using OSD\n   commands first and only if the error
    persists, retry the I/O\n   operation via the metadata server.\n"
  title: 7.  Recovering from Client I/O Errors
- contents:
  - "8.  Object-Based Layout Return\n   layoutreturn_file4 is used in the LAYOUTRETURN
    operation to convey\n   layout-type specific information to the server.  It is
    defined in the\n   NFSv4.1 [6] as follows:\n   struct layoutreturn_file4 {\n           offset4
    \        lrf_offset;\n           length4         lrf_length;\n           stateid4
    \       lrf_stateid;\n           /* layouttype4 specific data */\n           opaque
    \         lrf_body<>;\n   };\n   union layoutreturn4 switch(layoutreturn_type4
    lr_returntype) {\n           case LAYOUTRETURN4_FILE:\n                   layoutreturn_file4
    \     lr_layout;\n           default:\n                   void;\n   };\n   struct
    LAYOUTRETURN4args {\n           /* CURRENT_FH: file */\n           bool                    lora_reclaim;\n
    \          layoutreturn_stateid    lora_recallstateid;\n           layouttype4
    \            lora_layout_type;\n           layoutiomode4           lora_iomode;\n
    \          layoutreturn4           lora_layoutreturn;\n   };\n   If the lora_layout_type
    layout type is LAYOUT4_OSD2_OBJECTS, then the\n   lrf_body opaque value is defined
    by the pnfs_osd_layoutreturn4 type.\n   The pnfs_osd_layoutreturn4 type allows
    the client to report I/O error\n   information back to the metadata server as
    defined below.\n"
  - contents:
    - "8.1.  pnfs_osd_errno4\n   /// enum pnfs_osd_errno4 {\n   ///     PNFS_OSD_ERR_EIO
      \           = 1,\n   ///     PNFS_OSD_ERR_NOT_FOUND      = 2,\n   ///     PNFS_OSD_ERR_NO_SPACE
      \      = 3,\n   ///     PNFS_OSD_ERR_BAD_CRED       = 4,\n   ///     PNFS_OSD_ERR_NO_ACCESS
      \     = 5,\n   ///     PNFS_OSD_ERR_UNREACHABLE    = 6,\n   ///     PNFS_OSD_ERR_RESOURCE
      \      = 7\n   /// };\n   ///\n   pnfs_osd_errno4 is used to represent error
      types when read/write\n   errors are reported to the metadata server.  The error
      codes serve as\n   hints to the metadata server that may help it in diagnosing
      the exact\n   reason for the error and in repairing it.\n   o  PNFS_OSD_ERR_EIO
      indicates the operation failed because the object\n      storage device experienced
      a failure trying to access the object.\n      The most common source of these
      errors is media errors, but other\n      internal errors might cause this as
      well.  In this case, the\n      metadata server should go examine the broken
      object more closely;\n      hence, it should be used as the default error code.\n
      \  o  PNFS_OSD_ERR_NOT_FOUND indicates the object ID specifies an object\n      that
      does not exist on the object storage device.\n   o  PNFS_OSD_ERR_NO_SPACE indicates
      the operation failed because the\n      object storage device ran out of free
      capacity during the\n      operation.\n   o  PNFS_OSD_ERR_BAD_CRED indicates
      the security parameters are not\n      valid.  The primary cause of this is
      that the capability has\n      expired, or the access policy tag (a.k.a., capability
      version\n      number) has been changed to revoke capabilities.  The client
      will\n      need to return the layout and get a new one with fresh\n      capabilities.\n
      \  o  PNFS_OSD_ERR_NO_ACCESS indicates the capability does not allow the\n      requested
      operation.  This should not occur in normal operation\n      because the metadata
      server should give out correct capabilities,\n      or none at all.\n   o  PNFS_OSD_ERR_UNREACHABLE
      indicates the client did not complete the\n      I/O operation at the object
      storage device due to a communication\n      failure.  Whether or not the I/O
      operation was executed by the OSD\n      is undetermined.\n   o  PNFS_OSD_ERR_RESOURCE
      indicates the client did not issue the I/O\n      operation due to a local problem
      on the initiator (i.e., client)\n      side, e.g., when running out of memory.
      \ The client MUST guarantee\n      that the OSD command was never dispatched
      to the OSD.\n"
    title: 8.1.  pnfs_osd_errno4
  - contents:
    - "8.2.  pnfs_osd_ioerr4\n   /// struct pnfs_osd_ioerr4 {\n   ///     pnfs_osd_objid4
      \    oer_component;\n   ///     length4             oer_comp_offset;\n   ///
      \    length4             oer_comp_length;\n   ///     bool                oer_iswrite;\n
      \  ///     pnfs_osd_errno4     oer_errno;\n   /// };\n   ///\n   The pnfs_osd_ioerr4
      structure is used to return error indications for\n   objects that generated
      errors during data transfers.  These are hints\n   to the metadata server that
      there are problems with that object.  For\n   each error, \"oer_component\",
      \"oer_comp_offset\", and \"oer_comp_length\"\n   represent the object and byte
      range within the component object in\n   which the error occurred; \"oer_iswrite\"
      is set to \"true\" if the\n   failed OSD operation was data modifying, and \"oer_errno\"
      represents\n   the type of error.\n   Component byte ranges in the optional
      pnfs_osd_ioerr4 structure are\n   used for recovering the object and MUST be
      set by the client to cover\n   all failed I/O operations to the component.\n"
    title: 8.2.  pnfs_osd_ioerr4
  - contents:
    - "8.3.  pnfs_osd_layoutreturn4\n   /// struct pnfs_osd_layoutreturn4 {\n   ///
      \    pnfs_osd_ioerr4             olr_ioerr_report<>;\n   /// };\n   ///\n   When
      OSD I/O operations failed, \"olr_ioerr_report<>\" is used to\n   report these
      errors to the metadata server as an array of elements of\n   type pnfs_osd_ioerr4.
      \ Each element in the array represents an error\n   that occurred on the object
      specified by oer_component.  If no errors\n   are to be reported, the size of
      the olr_ioerr_report<> array is set\n   to zero.\n"
    title: 8.3.  pnfs_osd_layoutreturn4
  title: 8.  Object-Based Layout Return
- contents:
  - "9.  Object-Based Creation Layout Hint\n   The layouthint4 type is defined in
    the NFSv4.1 [6] as follows:\n   struct layouthint4 {\n       layouttype4           loh_type;\n
    \      opaque                loh_body<>;\n   };\n   The layouthint4 structure
    is used by the client to pass a hint about\n   the type of layout it would like
    created for a particular file.  If\n   the loh_type layout type is LAYOUT4_OSD2_OBJECTS,
    then the loh_body\n   opaque value is defined by the pnfs_osd_layouthint4 type.\n"
  - contents:
    - "9.1.  pnfs_osd_layouthint4\n   /// union pnfs_osd_max_comps_hint4 switch (bool
      omx_valid) {\n   ///     case TRUE:\n   ///         uint32_t            omx_max_comps;\n
      \  ///     case FALSE:\n   ///         void;\n   /// };\n   ///\n   /// union
      pnfs_osd_stripe_unit_hint4 switch (bool osu_valid) {\n   ///     case TRUE:\n
      \  ///         length4             osu_stripe_unit;\n   ///     case FALSE:\n
      \  ///         void;\n   /// };\n   ///\n   /// union pnfs_osd_group_width_hint4
      switch (bool ogw_valid) {\n   ///     case TRUE:\n   ///         uint32_t            ogw_group_width;\n
      \  ///     case FALSE:\n   ///         void;\n   /// };\n   ///\n   /// union
      pnfs_osd_group_depth_hint4 switch (bool ogd_valid) {\n   ///     case TRUE:\n
      \  ///         uint32_t            ogd_group_depth;\n   ///     case FALSE:\n
      \  ///         void;\n   /// };\n   ///\n   /// union pnfs_osd_mirror_cnt_hint4
      switch (bool omc_valid) {\n   ///     case TRUE:\n   ///         uint32_t            omc_mirror_cnt;\n
      \  ///     case FALSE:\n   ///         void;\n   /// };\n   ///\n   /// union
      pnfs_osd_raid_algorithm_hint4 switch (bool ora_valid) {\n   ///     case TRUE:\n
      \  ///         pnfs_osd_raid_algorithm4    ora_raid_algorithm;\n   ///     case
      FALSE:\n   ///         void;\n   /// };\n   ///\n   /// struct pnfs_osd_layouthint4
      {\n   ///     pnfs_osd_max_comps_hint4        olh_max_comps_hint;\n   ///     pnfs_osd_stripe_unit_hint4
      \     olh_stripe_unit_hint;\n   ///     pnfs_osd_group_width_hint4      olh_group_width_hint;\n
      \  ///     pnfs_osd_group_depth_hint4      olh_group_depth_hint;\n   ///     pnfs_osd_mirror_cnt_hint4
      \      olh_mirror_cnt_hint;\n   ///     pnfs_osd_raid_algorithm_hint4   olh_raid_algorithm_hint;\n
      \  /// };\n   ///\n   This type conveys hints for the desired data map.  All
      parameters are\n   optional so the client can give values for only the parameters
      it\n   cares about, e.g. it can provide a hint for the desired number of\n   mirrored
      components, regardless of the RAID algorithm selected for\n   the file.  The
      server should make an attempt to honor the hints, but\n   it can ignore any
      or all of them at its own discretion and without\n   failing the respective
      CREATE operation.\n   The \"olh_max_comps_hint\" can be used to limit the total
      number of\n   component objects comprising the file.  All other hints correspond\n
      \  directly to the different fields of pnfs_osd_data_map4.\n"
    title: 9.1.  pnfs_osd_layouthint4
  title: 9.  Object-Based Creation Layout Hint
- contents:
  - "10.  Layout Segments\n   The pnfs layout operations operate on logical byte ranges.
    \ There is\n   no requirement in the protocol for any relationship between byte\n
    \  ranges used in LAYOUTGET to acquire layouts and byte ranges used in\n   CB_LAYOUTRECALL,
    LAYOUTCOMMIT, or LAYOUTRETURN.  However, using OSD\n   byte-range capabilities
    poses limitations on these operations since\n   the capabilities associated with
    layout segments cannot be merged or\n   split.  The following guidelines should
    be followed for proper\n   operation of object-based layouts.\n"
  - contents:
    - "10.1.  CB_LAYOUTRECALL and LAYOUTRETURN\n   In general, the object-based layout
      driver should keep track of each\n   layout segment it got, keeping record of
      the segment's iomode,\n   offset, and length.  The server should allow the client
      to get\n   multiple overlapping layout segments but is free to recall the layout\n
      \  to prevent overlap.\n   In response to CB_LAYOUTRECALL, the client should
      return all layout\n   segments matching the given iomode and overlapping with
      the recalled\n   range.  When returning the layouts for this byte range with\n
      \  LAYOUTRETURN, the client MUST NOT return a sub-range of a layout\n   segment
      it has; each LAYOUTRETURN sent MUST completely cover at least\n   one outstanding
      layout segment.\n   The server, in turn, should release any segment that exactly
      matches\n   the clientid, iomode, and byte range given in LAYOUTRETURN.  If
      no\n   exact match is found, then the server should release all layout\n   segments
      matching the clientid and iomode and that are fully\n   contained in the returned
      byte range.  If none are found and the byte\n   range is a subset of an outstanding
      layout segment with for the same\n   clientid and iomode, then the client can
      be considered malfunctioning\n   and the server SHOULD recall all layouts from
      this client to reset\n   its state.  If this behavior repeats, the server SHOULD
      deny all\n   LAYOUTGETs from this client.\n"
    title: 10.1.  CB_LAYOUTRECALL and LAYOUTRETURN
  - contents:
    - "10.2.  LAYOUTCOMMIT\n   LAYOUTCOMMIT is only used by object-based pNFS to convey
      modified\n   attributes hints and/or to report the presence of I/O errors to
      the\n   metadata server (MDS).  Therefore, the offset and length in\n   LAYOUTCOMMIT4args
      are reserved for future use and should be set to 0.\n"
    title: 10.2.  LAYOUTCOMMIT
  title: 10.  Layout Segments
- contents:
  - "11.  Recalling Layouts\n   The object-based metadata server should recall outstanding
    layouts in\n   the following cases:\n   o  When the file's security policy changes,
    i.e., Access Control\n      Lists (ACLs) or permission mode bits are set.\n   o
    \ When the file's aggregation map changes, rendering outstanding\n      layouts
    invalid.\n   o  When there are sharing conflicts.  For example, the server will\n
    \     issue stripe-aligned layout segments for RAID-5 objects.  To\n      prevent
    corruption of the file's parity, multiple clients must not\n      hold valid write
    layouts for the same stripes.  An outstanding\n      READ/WRITE (RW) layout should
    be recalled when a conflicting\n      LAYOUTGET is received from a different client
    for LAYOUTIOMODE4_RW\n      and for a byte range overlapping with the outstanding
    layout\n      segment.\n"
  - contents:
    - "11.1.  CB_RECALL_ANY\n   The metadata server can use the CB_RECALL_ANY callback
      operation to\n   notify the client to return some or all of its layouts.  The
      NFSv4.1\n   [6] defines the following types:\n   const RCA4_TYPE_MASK_OBJ_LAYOUT_MIN
      \    = 8;\n   const RCA4_TYPE_MASK_OBJ_LAYOUT_MAX     = 9;\n   struct  CB_RECALL_ANY4args
      \     {\n       uint32_t        craa_objects_to_keep;\n       bitmap4         craa_type_mask;\n
      \  };\n   Typically, CB_RECALL_ANY will be used to recall client state when
      the\n   server needs to reclaim resources.  The craa_type_mask bitmap\n   specifies
      the type of resources that are recalled and the\n   craa_objects_to_keep value
      specifies how many of the recalled objects\n   the client is allowed to keep.
      \ The object-based layout type mask\n   flags are defined as follows.  They
      represent the iomode of the\n   recalled layouts.  In response, the client SHOULD
      return layouts of\n   the recalled iomode that it needs the least, keeping at
      most\n   craa_objects_to_keep object-based layouts.\n   /// enum pnfs_osd_cb_recall_any_mask
      {\n   ///     PNFS_OSD_RCA4_TYPE_MASK_READ = 8,\n   ///     PNFS_OSD_RCA4_TYPE_MASK_RW
      \  = 9\n   /// };\n   ///\n   The PNFS_OSD_RCA4_TYPE_MASK_READ flag notifies
      the client to return\n   layouts of iomode LAYOUTIOMODE4_READ.  Similarly, the\n
      \  PNFS_OSD_RCA4_TYPE_MASK_RW flag notifies the client to return layouts\n   of
      iomode LAYOUTIOMODE4_RW.  When both mask flags are set, the client\n   is notified
      to return layouts of either iomode.\n"
    title: 11.1.  CB_RECALL_ANY
  title: 11.  Recalling Layouts
- contents:
  - "12.  Client Fencing\n   In cases where clients are uncommunicative and their
    lease has\n   expired or when clients fail to return recalled layouts within a\n
    \  lease period at the least (see \"Recalling a Layout\"[6]), the server\n   MAY
    revoke client layouts and/or device address mappings and reassign\n   these resources
    to other clients.  To avoid data corruption, the\n   metadata server MUST fence
    off the revoked clients from the\n   respective objects as described in Section
    13.4.\n"
  title: 12.  Client Fencing
- contents:
  - "13.  Security Considerations\n   The pNFS extension partitions the NFSv4 file
    system protocol into two\n   parts, the control path and the data path (storage
    protocol).  The\n   control path contains all the new operations described by
    this\n   extension; all existing NFSv4 security mechanisms and features apply\n
    \  to the control path.  The combination of components in a pNFS system\n   is
    required to preserve the security properties of NFSv4 with respect\n   to an entity
    accessing data via a client, including security\n   countermeasures to defend
    against threats that NFSv4 provides\n   defenses for in environments where these
    threats are considered\n   significant.\n   The metadata server enforces the file
    access-control policy at\n   LAYOUTGET time.  The client should use suitable authorization\n
    \  credentials for getting the layout for the requested iomode (READ or\n   RW)
    and the server verifies the permissions and ACL for these\n   credentials, possibly
    returning NFS4ERR_ACCESS if the client is not\n   allowed the requested iomode.
    \ If the LAYOUTGET operation succeeds\n   the client receives, as part of the
    layout, a set of object\n   capabilities allowing it I/O access to the specified
    objects\n   corresponding to the requested iomode.  When the client acts on I/O\n
    \  operations on behalf of its local users, it MUST authenticate and\n   authorize
    the user by issuing respective OPEN and ACCESS calls to the\n   metadata server,
    similar to having NFSv4 data delegations.  If access\n   is allowed, the client
    uses the corresponding (READ or RW)\n   capabilities to perform the I/O operations
    at the object storage\n   devices.  When the metadata server receives a request
    to change a\n   file's permissions or ACL, it SHOULD recall all layouts for that
    file\n   and it MUST change the capability version attribute on all objects\n
    \  comprising the file to implicitly invalidate any outstanding\n   capabilities
    before committing to the new permissions and ACL.  Doing\n   this will ensure
    that clients re-authorize their layouts according to\n   the modified permissions
    and ACL by requesting new layouts.\n   Recalling the layouts in this case is courtesy
    of the server intended\n   to prevent clients from getting an error on I/Os done
    after the\n   capability version changed.\n   The object storage protocol MUST
    implement the security aspects\n   described in version 1 of the T10 OSD protocol
    definition [1].  The\n   standard defines four security methods: NOSEC, CAPKEY,
    CMDRSP, and\n   ALLDATA.  To provide minimum level of security allowing verification\n
    \  and enforcement of the server access control policy using the layout\n   security
    credentials, the NOSEC security method MUST NOT be used for\n   any I/O operation.
    \ The remainder of this section gives an overview\n   of the security mechanism
    described in that standard.  The goal is to\n   give the reader a basic understanding
    of the object security model.\n   Any discrepancies between this text and the
    actual standard are\n   obviously to be resolved in favor of the OSD standard.\n"
  - contents:
    - "13.1.  OSD Security Data Types\n   There are three main data types associated
      with object security: a\n   capability, a credential, and security parameters.
      \ The capability is\n   a set of fields that specifies an object and what operations
      can be\n   performed on it.  A credential is a signed capability.  Only a\n
      \  security manager that knows the secret device keys can correctly sign\n   a
      capability to form a valid credential.  In pNFS, the file server\n   acts as
      the security manager and returns signed capabilities (i.e.,\n   credentials)
      to the pNFS client.  The security parameters are values\n   computed by the
      issuer of OSD commands (i.e., the client) that prove\n   they hold valid credentials.
      \ The client uses the credential as a\n   signing key to sign the requests it
      makes to OSD, and puts the\n   resulting signatures into the security_parameters
      field of the OSD\n   command.  The object storage device uses the secret keys
      it shares\n   with the security manager to validate the signature values in
      the\n   security parameters.\n   The security types are opaque to the generic
      layers of the pNFS\n   client.  The credential contents are defined as opaque
      within the\n   pnfs_osd_object_cred4 type.  Instead of repeating the definitions\n
      \  here, the reader is referred to Section 4.9.2.2 of the OSD standard.\n"
    title: 13.1.  OSD Security Data Types
  - contents:
    - "13.2.  The OSD Security Protocol\n   The object storage protocol relies on
      a cryptographically secure\n   capability to control accesses at the object
      storage devices.\n   Capabilities are generated by the metadata server, returned
      to the\n   client, and used by the client as described below to authenticate\n
      \  their requests to the object-based storage device.  Capabilities\n   therefore
      achieve the required access and open mode checking.  They\n   allow the file
      server to define and check a policy (e.g., open mode)\n   and the OSD to enforce
      that policy without knowing the details (e.g.,\n   user IDs and ACLs).\n   Since
      capabilities are tied to layouts, and since they are used to\n   enforce access
      control, when the file ACL or mode changes the\n   outstanding capabilities
      MUST be revoked to enforce the new access\n   permissions.  The server SHOULD
      recall layouts to allow clients to\n   gracefully return their capabilities
      before the access permissions\n   change.\n   Each capability is specific to
      a particular object, an operation on\n   that object, a byte range within the
      object (in OSDv2), and has an\n   explicit expiration time.  The capabilities
      are signed with a secret\n   key that is shared by the object storage devices
      and the metadata\n   managers.  Clients do not have device keys so they are
      unable to\n   forge the signatures in the security parameters.  The combination
      of\n   a capability, the OSD System ID, and a signature is called a\n   \"credential\"
      in the OSD specification.\n   The details of the security and privacy model
      for object storage are\n   defined in the T10 OSD standard.  The following sketch
      of the\n   algorithm should help the reader understand the basic model.\n   LAYOUTGET
      returns a CapKey and a Cap, which, together with the OSD\n   System ID, are
      also called a credential.  It is a capability and a\n   signature over that
      capability and the SystemID.  The OSD Standard\n   refers to the CapKey as the
      \"Credential integrity check value\" and to\n   the ReqMAC as the \"Request
      integrity check value\".\n   CapKey = MAC<SecretKey>(Cap, SystemID)\n   Credential
      = {Cap, SystemID, CapKey}\n   The client uses CapKey to sign all the requests
      it issues for that\n   object using the respective Cap.  In other words, the
      Cap appears in\n   the request to the storage device, and that request is signed
      with\n   the CapKey as follows:\n   ReqMAC = MAC<CapKey>(Req, ReqNonce)\n   Request
      = {Cap, Req, ReqNonce, ReqMAC}\n   The following is sent to the OSD: {Cap, Req,
      ReqNonce, ReqMAC}.  The\n   OSD uses the SecretKey it shares with the metadata
      server to compare\n   the ReqMAC the client sent with a locally computed value:\n
      \  LocalCapKey = MAC<SecretKey>(Cap, SystemID)\n   LocalReqMAC = MAC<LocalCapKey>(Req,
      ReqNonce)\n   and if they match the OSD assumes that the capabilities came from
      an\n   authentic metadata server and allows access to the object, as allowed\n
      \  by the Cap.\n"
    title: 13.2.  The OSD Security Protocol
  - contents:
    - "13.3.  Protocol Privacy Requirements\n   Note that if the server LAYOUTGET
      reply, holding CapKey and Cap, is\n   snooped by another client, it can be used
      to generate valid OSD\n   requests (within the Cap access restrictions).\n   To
      provide the required privacy requirements for the capability key\n   returned
      by LAYOUTGET, the GSS-API [7] framework can be used, e.g.,\n   by using the
      RPCSEC_GSS privacy method to send the LAYOUTGET\n   operation or by using the
      SSV key to encrypt the oc_capability_key\n   using the GSS_Wrap() function.
      \ Two general ways to provide privacy\n   in the absence of GSS-API that are
      independent of NFSv4 are either an\n   isolated network such as a VLAN or a
      secure channel provided by IPsec\n   [15].\n"
    title: 13.3.  Protocol Privacy Requirements
  - contents:
    - "13.4.  Revoking Capabilities\n   At any time, the metadata server may invalidate
      all outstanding\n   capabilities on an object by changing its POLICY ACCESS
      TAG\n   attribute.  The value of the POLICY ACCESS TAG is part of a\n   capability,
      and it must match the state of the object attribute.  If\n   they do not match,
      the OSD rejects accesses to the object with the\n   sense key set to ILLEGAL
      REQUEST and an additional sense code set to\n   INVALID FIELD IN CDB.  When
      a client attempts to use a capability and\n   is rejected this way, it should
      issue a LAYOUTCOMMIT for the object\n   and specify PNFS_OSD_BAD_CRED in the
      olr_ioerr_report parameter.  The\n   client may elect to issue a compound LAYOUTRETURN/LAYOUTGET
      (or\n   LAYOUTCOMMIT/LAYOUTRETURN/LAYOUTGET) to attempt to fetch a refreshed\n
      \  set of capabilities.\n   The metadata server may elect to change the access
      policy tag on an\n   object at any time, for any reason (with the understanding
      that there\n   is likely an associated performance penalty, especially if there
      are\n   outstanding layouts for this object).  The metadata server MUST\n   revoke
      outstanding capabilities when any one of the following occurs:\n   o  the permissions
      on the object change,\n   o  a conflicting mandatory byte-range lock is granted,
      or\n   o  a layout is revoked and reassigned to another client.\n   A pNFS client
      will typically hold one layout for each byte range for\n   either READ or READ/WRITE.
      \ The client's credentials are checked by\n   the metadata server at LAYOUTGET
      time and it is the client's\n   responsibility to enforce access control among
      multiple users\n   accessing the same file.  It is neither required nor expected
      that\n   the pNFS client will obtain a separate layout for each user accessing\n
      \  a shared object.  The client SHOULD use OPEN and ACCESS calls to\n   check
      user permissions when performing I/O so that the server's\n   access control
      policies are correctly enforced.  The result of the\n   ACCESS operation may
      be cached while the client holds a valid layout\n   as the server is expected
      to recall layouts when the file's access\n   permissions or ACL change.\n"
    title: 13.4.  Revoking Capabilities
  title: 13.  Security Considerations
- contents:
  - "14.  IANA Considerations\n   As described in NFSv4.1 [6], new layout type numbers
    have been\n   assigned by IANA.  This document defines the protocol associated
    with\n   the existing layout type number, LAYOUT4_OSD2_OBJECTS, and it\n   requires
    no further actions for IANA.\n"
  title: 14.  IANA Considerations
- contents:
  - '15.  References

    '
  - contents:
    - "15.1.  Normative References\n   [1]   Weber, R., \"Information Technology -
      SCSI Object-Based Storage\n         Device Commands (OSD)\", ANSI INCITS 400-2004,
      December 2004.\n   [2]   Bradner, S., \"Key words for use in RFCs to Indicate
      Requirement\n         Levels\", BCP 14, RFC 2119, March 1997.\n   [3]   Eisler,
      M., \"XDR: External Data Representation Standard\",\n         STD 67, RFC 4506,
      May 2006.\n   [4]   Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed., \"Network\n
      \        File System (NFS) Version 4 Minor Version 1 External Data\n         Representation
      Standard (XDR) Description\", RFC 5662,\n         January 2010.\n   [5]   IETF
      Trust, \"Legal Provisions Relating to IETF Documents\",\n         November 2008,\n
      \        <http://trustee.ietf.org/docs/IETF-Trust-License-Policy.pdf>.\n   [6]
      \  Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed., \"Network\n         File
      System (NFS) Version 4 Minor Version 1 Protocol\",\n         RFC 5661, January
      2010.\n   [7]   Linn, J., \"Generic Security Service Application Program\n         Interface
      Version 2, Update 1\", RFC 2743, January 2000.\n   [8]   Satran, J., Meth, K.,
      Sapuntzakis, C., Chadalapaka, M., and E.\n         Zeidner, \"Internet Small
      Computer Systems Interface (iSCSI)\",\n         RFC 3720, April 2004.\n   [9]
      \  Weber, R., \"SCSI Primary Commands - 3 (SPC-3)\", ANSI\n         INCITS 408-2005,
      October 2005.\n   [10]  Krueger, M., Chadalapaka, M., and R. Elliott, \"T11
      Network\n         Address Authority (NAA) Naming Format for iSCSI Node Names\",\n
      \        RFC 3980, February 2005.\n   [11]  IEEE, \"Guidelines for 64-bit Global
      Identifier (EUI-64)\n         Registration Authority\",\n         <http://standards.ieee.org/regauth/oui/tutorials/EUI64.html>.\n
      \  [12]  Tseng, J., Gibbons, K., Travostino, F., Du Laney, C., and J.\n         Souza,
      \"Internet Storage Name Service (iSNS)\", RFC 4171,\n         September 2005.\n
      \  [13]  Weber, R., \"SCSI Architecture Model - 3 (SAM-3)\", ANSI\n         INCITS
      402-2005, February 2005.\n"
    title: 15.1.  Normative References
  - contents:
    - "15.2.  Informative References\n   [14]  Weber, R., \"SCSI Object-Based Storage
      Device Commands -2\n         (OSD-2)\", January 2009,\n         <http://www.t10.org/cgi-bin/ac.pl?t=f&f=osd2r05a.pdf>.\n
      \  [15]  Kent, S. and K. Seo, \"Security Architecture for the Internet\n         Protocol\",
      RFC 4301, December 2005.\n   [16]  T10 1415-D, \"SCSI RDMA Protocol (SRP)\",
      ANSI INCITS 365-2002,\n         December 2002.\n   [17]  T11 1619-D, \"Fibre
      Channel Framing and Signaling - 2\n         (FC-FS-2)\", ANSI INCITS 424-2007,
      February 2007.\n   [18]  T10 1601-D, \"Serial Attached SCSI - 1.1 (SAS-1.1)\",
      ANSI\n         INCITS 417-2006, June 2006.\n   [19]  MacWilliams, F. and N.
      Sloane, \"The Theory of Error-Correcting\n         Codes, Part I\", 1977.\n"
    title: 15.2.  Informative References
  title: 15.  References
- contents:
  - "Appendix A.  Acknowledgments\n   Todd Pisek was a co-editor of the initial versions
    of this document.\n   Daniel E. Messinger, Pete Wyckoff, Mike Eisler, Sean P.
    Turner, Brian\n   E. Carpenter, Jari Arkko, David Black, and Jason Glasgow reviewed
    and\n   commented on this document.\n"
  title: Appendix A.  Acknowledgments
- contents:
  - "Authors' Addresses\n   Benny Halevy\n   Panasas, Inc.\n   1501 Reedsdale St.
    Suite 400\n   Pittsburgh, PA  15233\n   USA\n   Phone: +1-412-323-3500\n   EMail:
    bhalevy@panasas.com\n   URI:   http://www.panasas.com/\n   Brent Welch\n   Panasas,
    Inc.\n   6520 Kaiser Drive\n   Fremont, CA  95444\n   USA\n   Phone: +1-510-608-7770\n
    \  EMail: welch@panasas.com\n   URI:   http://www.panasas.com/\n   Jim Zelenka\n
    \  Panasas, Inc.\n   1501 Reedsdale St. Suite 400\n   Pittsburgh, PA  15233\n
    \  USA\n   Phone: +1-412-323-3500\n   EMail: jimz@panasas.com\n   URI:   http://www.panasas.com/\n"
  title: Authors' Addresses
