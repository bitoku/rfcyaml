- title: __initial_text__
  contents:
  - '             Layered Coding Transport (LCT) Building Block

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo defines an Experimental Protocol for the Internet\n\
    \   community.  It does not specify an Internet standard of any kind.\n   Discussion\
    \ and suggestions for improvement are requested.\n   Distribution of this memo\
    \ is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2002).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   Layered Coding Transport (LCT) provides transport level support\
    \ for\n   reliable content delivery and stream delivery protocols.  LCT is\n \
    \  specifically designed to support protocols using IP multicast, but\n   also\
    \ provides support to protocols that use unicast.  LCT is\n   compatible with\
    \ congestion control that provides multiple rate\n   delivery to receivers and\
    \ is also compatible with coding techniques\n   that provide reliable delivery\
    \ of content.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction...................................................2\n\
    \   2. Rationale......................................................3\n   3.\
    \ Functionality..................................................4\n   4. Applicability..................................................7\n\
    \     4.1 Environmental Requirements and Considerations...............8\n    \
    \ 4.2 Delivery service models....................................10\n     4.3\
    \ Congestion Control.........................................11\n   5. Packet\
    \ Header Fields..........................................12\n     5.1 Default\
    \ LCT header format..................................12\n     5.2 Header-Extension\
    \ Fields....................................17\n   6. Operations....................................................20\n\
    \     6.1 Sender Operation...........................................20\n    \
    \ 6.2 Receiver Operation.........................................22\n   7. Requirements\
    \ from Other Building Blocks.......................23\n   8. Security Considerations.......................................24\n\
    \   9. IANA Considerations...........................................25\n   10.\
    \ Acknowledgments..............................................25\n   11. References...................................................25\n\
    \   Authors' Addresses...............................................28\n   Full\
    \ Copyright Statement.........................................29\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Layered Coding Transport provides transport level support\
    \ for\n   reliable content delivery and stream delivery protocols.  Layered\n\
    \   Coding Transport is specifically designed to support protocols using\n   IP\
    \ multicast, but also provides support to protocols that use\n   unicast.  Layered\
    \ Coding Transport is compatible with congestion\n   control that provides multiple\
    \ rate delivery to receivers and is also\n   compatible with coding techniques\
    \ that provide reliable delivery of\n   content.\n   This document describes a\
    \ building block as defined in RFC 3048 [26].\n   This document is a product of\
    \ the IETF RMT WG  and follows the\n   general guidelines provided in RFC 3269\
    \ [24].\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"\
    SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"\
    OPTIONAL\" in this\n   document are to be interpreted as described in BCP 14,\
    \ RFC 2119 [2].\n   Statement of Intent\n      This memo contains part of the\
    \ definitions necessary to fully\n      specify a Reliable Multicast Transport\
    \ protocol in accordance with\n      RFC 2357.  As per RFC 2357, the use of any\
    \ reliable multicast\n      protocol in the Internet requires an adequate congestion\
    \ control\n      scheme.\n      While waiting for such a scheme to be available,\
    \ or for an\n      existing scheme to be proven adequate, the Reliable Multicast\n\
    \      Transport working group (RMT) publishes this Request for Comments\n   \
    \   in the \"Experimental\" category.\n      It is the intent of RMT to re-submit\
    \ this specification as an IETF\n      Proposed Standard as soon as the above\
    \ condition is met.\n"
- title: 2.  Rationale
  contents:
  - "2.  Rationale\n   LCT provides transport level support for massively scalable\
    \ protocols\n   using the IP multicast network service.  The support that LCT\n\
    \   provides is common to a variety of very important applications,\n   including\
    \ reliable content delivery and streaming applications.\n   An LCT session comprises\
    \ multiple channels originating at a single\n   sender that are used for some\
    \ period of time to carry packets\n   pertaining to the transmission of one or\
    \ more objects that can be of\n   interest to receivers.  The logic behind defining\
    \ a session as\n   originating from a single sender is that this is the right\n\
    \   granularity to regulate packet traffic via congestion control.  One\n   rationale\
    \ for using multiple channels within the same session is that\n   there are massively\
    \ scalable congestion control protocols that use\n   multiple channels per session.\
    \  These congestion control protocols\n   are considered to be layered because\
    \ a receiver joins and leaves\n   channels in a layered order during its participation\
    \ in the session.\n   The use of layered channels is also useful for streaming\n\
    \   applications.\n   There are coding techniques that provide massively scalable\n\
    \   reliability and asynchronous delivery which are compatible with both\n   layered\
    \ congestion control and with LCT.  When all are combined the\n   result is a\
    \ massively scalable reliable asynchronous content delivery\n   protocol that\
    \ is network friendly.  LCT also provides functionality\n   that can be used for\
    \ other applications as well, e.g., layered\n   streaming applications.\n   LCT\
    \ avoids providing functionality that is not massively scalable.\n   For example,\
    \ LCT does not provide any mechanisms for sending\n   information from receivers\
    \ to senders, although this does not rule\n   out protocols that both use LCT\
    \ and do require sending information\n   from receivers to senders.\n   LCT includes\
    \ general support for congestion control that must be\n   used.  It does not,\
    \ however, specify which congestion control should\n   be used.  The rationale\
    \ for this is that congestion control must be\n   provided by any protocol that\
    \ is network friendly, and yet the\n   different applications that can use LCT\
    \ will not have the same\n   requirements for congestion control.  For example,\
    \ a content delivery\n   protocol may strive to use all available bandwidth between\
    \ receivers\n   and the sender.  It must, therefore, drastically back off its\
    \ rate\n   when there is competing traffic.  On the other hand, a streaming\n\
    \   delivery protocol may strive to maintain a constant rate instead of\n   trying\
    \ to use all available bandwidth, and it may not back off its\n   rate as fast\
    \ when there is competing traffic.\n   Beyond support for congestion control,\
    \ LCT provides a number of\n   fields and supports functionality commonly required\
    \ by many\n   protocols.  For example, LCT provides a Transmission Session ID\
    \ that\n   can be used to identify which session each received packet belongs\n\
    \   to.  This is important because a receiver may be joined to many\n   sessions\
    \ concurrently, and thus it is very useful to be able to\n   demultiplex packets\
    \ as they arrive according to which session they\n   belong to.  As another example,\
    \ LCT provides optional support for\n   identifying which object each packet is\
    \ carrying information about.\n   Therefore, LCT provides many of the commonly\
    \ used fields and support\n   for functionality required by many protocols.\n"
- title: 3.  Functionality
  contents:
  - "3.  Functionality\n   An LCT session consists of a set of logically grouped LCT\
    \ channels\n   associated with a single sender carrying packets with LCT headers\
    \ for\n   one or more objects.  An LCT channel is defined by the combination of\n\
    \   a sender and an address associated with the channel by the sender.  A\n  \
    \ receiver joins a channel to start receiving the data packets sent to\n   the\
    \ channel by the sender, and a receiver leaves a channel to stop\n   receiving\
    \ data packets from the channel.\n   LCT is meant to be combined with other building\
    \ blocks so that the\n   resulting overall protocol is massively scalable.  Scalability\
    \ refers\n   to the behavior of the protocol in relation to the number of\n  \
    \ receivers and network paths, their heterogeneity, and the ability to\n   accommodate\
    \ dynamically variable sets of receivers.  Scalability\n   limitations can come\
    \ from memory or processing requirements, or from\n   the amount of feedback control\
    \ and redundant data packet traffic\n   generated by the protocol.  In turn, such\
    \ limitations may be a\n   consequence of the features that a complete reliable\
    \ content delivery\n   or stream delivery protocol is expected to provide.\n \
    \  The LCT header provides a number of fields that are useful for\n   conveying\
    \ in-band session information to receivers.  One of the\n   required fields is\
    \ the Transmission Session ID (TSI), which allows\n   the receiver of a session\
    \ to uniquely identify received packets as\n   part of the session.  Another required\
    \ field is the Congestion\n   Control Information (CCI), which allows the receiver\
    \ to perform the\n   required congestion control on the packets received within\
    \ the\n   session.  Other LCT fields provide optional but often very useful\n\
    \   additional information for the session.  For example, the Transport\n   Object\
    \ Identifier (TOI) identifies which object the packet contains\n   data for. \
    \ As other examples, the Sender Current Time (SCT) conveys\n   the time when the\
    \ packet was sent from the sender to the receiver,\n   the Expected Residual Time\
    \ (ERT) conveys the amount of time the\n   session will be continued for, flags\
    \ for indicating the close of the\n   session and the close of sending packets\
    \ for an object, and header\n   extensions for fields that for example can be\
    \ used for packet\n   authentication.\n   LCT provides support for congestion\
    \ control.  Congestion control MUST\n   be used that conforms to RFC 2357 [13]\
    \ between receivers and the\n   sender for each LCT session.  Congestion control\
    \ refers to the\n   ability to adapt throughput to the available bandwidth on\
    \ the path\n   from the sender to a receiver, and to share bandwidth fairly with\n\
    \   competing flows such as TCP. Thus, the total flow of packets flowing\n   to\
    \ each receiver participating in an LCT session MUST NOT compete\n   unfairly\
    \ with existing flow adaptive protocols such as TCP.\n   A multiple rate or a\
    \ single rate congestion control protocol can be\n   used with LCT.  For multiple\
    \ rate protocols, a session typically\n   consists of more than one channel and\
    \ the sender sends packets to the\n   channels in the session at rates that do\
    \ not depend on the receivers.\n   Each receiver adjusts its reception rate during\
    \ its participation in\n   the session by joining and leaving channels dynamically\
    \ depending on\n   the available bandwidth to the sender independent of all other\n\
    \   receivers.  Thus, for multiple rate protocols, the reception rate of\n   each\
    \ receiver may vary dynamically independent of the other\n   receivers.\n   For\
    \ single rate protocols, a session typically consists of one\n   channel and the\
    \ sender sends packets to the channel at variable rates\n   over time depending\
    \ on feedback from receivers.  Each receiver\n   remains joined to the channel\
    \ during its participation in the\n   session.  Thus, for single rate protocols,\
    \ the reception rate of each\n   receiver may vary dynamically but in coordination\
    \ with all receivers.\n   Generally, a multiple rate protocol is preferable to\
    \ a single rate\n   protocol in a heterogeneous receiver environment, since generally\
    \ it\n   more easily achieves scalability to many receivers and provides\n   higher\
    \ throughput to each individual receiver.  Some possible\n   multiple rate congestion\
    \ control protocols are described in [22],\n   [3], and [25].  A possible single\
    \ rate congestion control protocol is\n   described in [19].\n   Layered coding\
    \ refers to the ability to produce a coded stream of\n   packets that can be partitioned\
    \ into an ordered set of layers.  The\n   coding is meant to provide some form\
    \ of reliability, and the layering\n   is meant to allow the receiver experience\
    \ (in terms of quality of\n   playout, or overall transfer speed) to vary in a\
    \ predictable way\n   depending on how many consecutive layers of packets the\
    \ receiver is\n   receiving.\n   The concept of layered coding was first introduced\
    \ with reference to\n   audio and video streams.  For example, the information\
    \ associated\n   with a TV broadcast could be partitioned into three layers,\n\
    \   corresponding to black and white, color, and HDTV quality.  Receivers\n  \
    \ can experience different quality without the need for the sender to\n   replicate\
    \ information in the different layers.\n   The concept of layered coding can be\
    \ naturally extended to reliable\n   content delivery protocols when Forward Error\
    \ Correction (FEC)\n   techniques are used for coding the data stream.  Descriptions\
    \ of this\n   can be found in [20], [18], [7], [22] and [4].  By using FEC, the\n\
    \   data stream is transformed in such a way that reconstruction of a\n   data\
    \ object does not depend on the reception of specific data\n   packets, but only\
    \ on the number of different packets received.  As a\n   result, by increasing\
    \ the number of layers a receiver is receiving\n   from, the receiver can reduce\
    \ the transfer time accordingly.  Using\n   FEC to provide reliability can increase\
    \ scalability dramatically in\n   comparison to other methods for providing reliability.\
    \  More details\n   on the use of FEC for reliable content delivery can be found\
    \ in [11].\n   Reliable protocols aim at giving guarantees on the reliable delivery\n\
    \   of data from the sender to the intended recipients.  Guarantees vary\n   from\
    \ simple packet data integrity to reliable delivery of a precise\n   copy of an\
    \ object to all intended recipients.  Several reliable\n   content delivery protocols\
    \ have been built on top of IP multicast\n   using methods other than FEC, but\
    \ scalability was not the primary\n   design goal for many of them.\n   Two of\
    \ the key difficulties in scaling reliable content delivery\n   using IP multicast\
    \ are dealing with the amount of data that flows\n   from receivers back to the\
    \ sender, and the associated response\n   (generally data retransmissions) from\
    \ the sender.  Protocols that\n   avoid any such feedback, and minimize the amount\
    \ of retransmissions,\n   can be massively scalable.  LCT can be used in conjunction\
    \ with FEC\n   codes or a layered codec to achieve reliability with little or\
    \ no\n   feedback.\n   Protocol instantiations MAY be built by combining the LCT\
    \ framework\n   with other components.  A complete protocol instantiation that\
    \ uses\n   LCT MUST include a congestion control protocol that is compatible\n\
    \   with LCT and that conforms to RFC 2357 [13].  A complete protocol\n   instantiation\
    \ that uses LCT MAY include a scalable reliability\n   protocol that is compatible\
    \ with LCT, it MAY include an session\n   control protocol that is compatible\
    \ with LCT, and it MAY include\n   other protocols such as security protocols.\n"
- title: 4.  Applicability
  contents:
  - "4.  Applicability\n   An LCT session comprises a logically related set of one\
    \ or more LCT\n   channels originating at a single sender.  The channels are used\
    \ for\n   some period of time to carry packets containing LCT headers, and\n \
    \  these headers pertain to the transmission of one or more objects that\n   can\
    \ be of interest to receivers.\n   LCT is most applicable for delivery of objects\
    \ or streams in a\n   session of substantial length, i.e., objects or streams\
    \ that range in\n   aggregate length from hundreds of kilobytes to many gigabytes,\
    \ and\n   where the duration of the session is on the order of tens of seconds\n\
    \   or more.\n   As an example, an LCT session could be used to deliver a TV program\n\
    \   using three LCT channels.  Receiving packets from the first LCT\n   channel\
    \ could allow black and white reception.  Receiving the first\n   two LCT channels\
    \ could also permit color reception.  Receiving all\n   three channels could allow\
    \ HDTV quality reception.  Objects in this\n   example could correspond to individual\
    \ TV programs being transmitted.\n   As another example, a reliable LCT session\
    \ could be used to reliably\n   deliver hourly-updated weather maps (objects)\
    \ using ten LCT channels\n   at different rates, using FEC coding.  A receiver\
    \ may join and\n   concurrently receive packets from subsets of these channels,\
    \ until it\n   has enough packets in total to recover the object, then leave the\n\
    \   session (or remain connected listening for session description\n   information\
    \ only) until it is time to receive the next object.  In\n   this case, the quality\
    \ metric is the time required to receive each\n   object.\n   Before joining a\
    \ session, the receivers MUST obtain enough of the\n   session description to\
    \ start the session.  This MUST include the\n   relevant session parameters needed\
    \ by a receiver to participate in\n   the session, including all information relevant\
    \ to congestion\n   control.  The session description is determined by the sender,\
    \ and is\n   typically communicated to the receivers out-of-band.  In some cases,\n\
    \   as described later, parts of the session description that are not\n   required\
    \ to initiate a session MAY be included in the LCT header or\n   communicated\
    \ to a receiver out-of-band after the receiver has joined\n   the session.\n \
    \  An encoder MAY be used to generate the data that is placed in the\n   packet\
    \ payload in order to provide reliability.  A suitable decoder\n   is used to\
    \ reproduce the original information from the packet\n   payload.  There MAY be\
    \ a reliability header that follows the LCT\n   header if such an encoder and\
    \ decoder is used.  The reliability\n   header helps to describe the encoding\
    \ data carried in the payload of\n   the packet.  The format of the reliability\
    \ header depends on the\n   coding used, and this is negotiated out-of-band. \
    \ As an example, one\n   of the FEC headers described in [12] could be used.\n\
    \   For LCT, when multiple rate congestion control is used, congestion\n   control\
    \ is achieved by sending packets associated with a given\n   session to several\
    \ LCT channels.  Individual receivers dynamically\n   join one or more of these\
    \ channels, according to the network\n   congestion as seen by the receiver. \
    \ LCT headers include an opaque\n   field which MUST be used to convey congestion\
    \ control information to\n   the receivers.  The actual congestion control scheme\
    \ to use with LCT\n   is negotiated out-of-band.  Some examples of congestion\
    \ control\n   protocols that may be suitable for content delivery are described\
    \ in\n   [22], [3], and [25].  Other congestion controls may be suitable when\n\
    \   LCT is used for a streaming application.\n   This document does not specify\
    \ and restrict the type of exchanges\n   between LCT (or any PI built on top of\
    \ LCT) and an upper application.\n   Some upper APIs may use an object-oriented\
    \ approach, where the only\n   possible unit of data exchanged between LCT (or\
    \ any PI built on top\n   of LCT) and an application, either at a source or at\
    \ a receiver, is\n   an object.  Other APIs may enable a sending or receiving\
    \ application\n   to exchange a subset of an object with LCT (or any PI built\
    \ on top of\n   LCT), or may even follow a streaming model.  These considerations\
    \ are\n   outside the scope of this document.\n"
- title: 4.1  Environmental Requirements and Considerations
  contents:
  - "4.1  Environmental Requirements and Considerations\n   LCT is intended for congestion\
    \ controlled delivery of objects and\n   streams (both reliable content delivery\
    \ and streaming of multimedia\n   information).\n   LCT can be used with both\
    \ multicast and unicast delivery.  LCT\n   requires connectivity between a sender\
    \ and receivers but does not\n   require connectivity from receivers to a sender.\
    \  LCT inherently\n   works with all types of networks, including LANs, WANs,\
    \ Intranets,\n   the Internet, asymmetric networks, wireless networks, and satellite\n\
    \   networks.  Thus, the inherent raw scalability of LCT is unlimited.\n   However,\
    \ when other specific applications are built on top of LCT,\n   then these applications\
    \ by their very nature may limit scalability.\n   For example, if an application\
    \ requires receivers to retrieve out of\n   band information in order to join\
    \ a session, or an application allows\n   receivers to send requests back to the\
    \ sender to report reception\n   statistics, then the scalability of the application\
    \ is limited by the\n   ability to send, receive, and process this additional\
    \ data.\n   LCT requires receivers to be able to uniquely identify and\n   demultiplex\
    \ packets associated with an LCT session.  In particular,\n   there MUST be a\
    \ Transport Session Identifier (TSI) associated with\n   each LCT session.  The\
    \ TSI is scoped by the IP address of the sender,\n   and the IP address of the\
    \ sender together with the TSI MUST uniquely\n   identify the session.  If the\
    \ underlying transport is UDP as\n   described in RFC 768 [16], then the 16 bit\
    \ UDP source port number MAY\n   serve as the TSI for the session.  The TSI value\
    \ MUST be the same in\n   all places it occurs within a packet.  If there is no\
    \ underlying TSI\n   provided by the network, transport or any other layer, then\
    \ the TSI\n   MUST be included in the LCT header.\n   LCT is presumed to be used\
    \ with an underlying network or transport\n   service that is a \"best effort\"\
    \ service that does not guarantee\n   packet reception or packet reception order,\
    \ and which does not have\n   any support for flow or congestion control.  For\
    \ example, the Any-\n   Source Multicast (ASM) model of IP multicast as defined\
    \ in RFC 1112\n   [5] is such a \"best effort\" network service.  While the basic\
    \ service\n   provided by RFC 1112 is largely scalable, providing congestion\n\
    \   control or reliability should be done carefully to avoid severe\n   scalability\
    \ limitations, especially in presence of heterogeneous sets\n   of receivers.\n\
    \   There are currently two models of multicast delivery, the Any-Source\n   Multicast\
    \ (ASM) model as defined in RFC 1112 [5] and the Source-\n   Specific Multicast\
    \ (SSM) model as defined in [10].  LCT works with\n   both multicast models, but\
    \ in a slightly different way with somewhat\n   different environmental concerns.\
    \  When using ASM, a sender S sends\n   packets to a multicast group G, and the\
    \ LCT channel address consists\n   of the pair (S,G), where S is the IP address\
    \ of the sender and G is a\n   multicast group address.  When using SSM, a sender\
    \ S sends packets to\n   an SSM channel (S,G), and the LCT channel address coincides\
    \ with the\n   SSM channel address.\n   A sender can locally allocate unique SSM\
    \ channel addresses, and this\n   makes allocation of LCT channel addresses easy\
    \ with SSM.  To allocate\n   LCT channel addresses using ASM, the sender must\
    \ uniquely chose the\n   ASM multicast group address across the scope of the group,\
    \ and this\n   makes allocation of LCT channel addresses more difficult with ASM.\n\
    \   LCT channels and SSM channels coincide, and thus the receiver will\n   only\
    \ receive packets sent to the requested LCT channel.  With ASM,\n   the receiver\
    \ joins an LCT channel by joining a multicast group G, and\n   all packets sent\
    \ to G, regardless of the sender, may be received by\n   the receiver.  Thus,\
    \ SSM has compelling security advantages over ASM\n   for prevention of denial\
    \ of service attacks.  In either case,\n   receivers SHOULD use mechanisms to\
    \ filter out packets from unwanted\n   sources.\n   Some networks are not amenable\
    \ to some congestion control protocols\n   that could be used with LCT.  In particular,\
    \ for a satellite or\n   wireless network, there may be no mechanism for receivers\
    \ to\n   effectively reduce their reception rate since there may be a fixed\n\
    \   transmission rate allocated to the session.\n"
- title: 4.2  Delivery service models
  contents:
  - "4.2  Delivery service models\n   LCT can support several different delivery service\
    \ models.  Two\n   examples are briefly described here.\n   Push service model.\n\
    \   One way a push service model can be used for reliable content\n   delivery\
    \ is to deliver a series of objects.  For example, a receiver\n   could join the\
    \ session and dynamically adapt the number of LCT\n   channels the receiver is\
    \ joined to until enough packets have been\n   received to reconstruct an object.\
    \  After reconstructing the object\n   the receiver may stay in the session and\
    \ wait for the transmission of\n   the next object.\n   The push model is particularly\
    \ attractive in satellite networks and\n   wireless networks.  In these cases,\
    \ a session may consist of one\n   fixed rate LCT channel.\n   On-demand content\
    \ delivery model.\n   For an on-demand content delivery service model, senders\
    \ typically\n   transmit for some given time period selected to be long enough\
    \ to\n   allow all the intended receivers to join the session and recover the\n\
    \   object.  For example a popular software update might be transmitted\n   using\
    \ LCT for several days, even though a receiver may be able to\n   complete the\
    \ download in one hour total of connection time, perhaps\n   spread over several\
    \ intervals of time.\n   In this case the receivers join the session, and dynamically\
    \ adapt\n   the number of LCT channels they subscribe to according to the\n  \
    \ available bandwidth.  Receivers then drop from the session when they\n   have\
    \ received enough packets to recover the object.\n   As an example, assume that\
    \ an object is 50 MB.  The sender could send\n   1 KB packets to the first LCT\
    \ channel at 50 packets per second, so\n   that receivers using just this LCT\
    \ channel could complete reception\n   of the object in 1,000 seconds in absence\
    \ of loss, and would be able\n   to complete reception even in presence of some\
    \ substantial amount of\n   losses with the use of coding for reliability.  Furthermore,\
    \ the\n   sender could use a number of LCT channels such that the aggregate\n\
    \   rate of 1 KB packets to all LCT channels is 1,000 packets per second,\n  \
    \ so that a receiver could be able to complete reception of the object\n   in\
    \ as little 50 seconds (assuming no loss and that the congestion\n   control mechanism\
    \ immediately converges to the use of all LCT\n   channels).\n   Other service\
    \ models.\n   There are many other delivery service models that LCT can be used\
    \ for\n   that are not covered above.  As examples, a live streaming or an on-\n\
    \   demand archival content streaming service model.  A description of\n   the\
    \ many potential applications, the appropriate delivery service\n   model, and\
    \ the additional mechanisms to support such functionalities\n   when combined\
    \ with LCT is beyond the scope of this document.  This\n   document only attempts\
    \ to describe the minimal common scalable\n   elements to these diverse applications\
    \ using LCT as the delivery\n   transport.\n"
- title: 4.3  Congestion Control
  contents:
  - "4.3  Congestion Control\n   The specific congestion control protocol to be used\
    \ for LCT sessions\n   depends on the type of content to be delivered.  While\
    \ the general\n   behavior of the congestion control protocol is to reduce the\n\
    \   throughput in presence of congestion and gradually increase it in the\n  \
    \ absence of congestion, the actual dynamic behavior (e.g. response to\n   single\
    \ losses) can vary.\n   Some possible congestion control protocols for reliable\
    \ content\n   delivery using LCT are described in [22], [3], and [25].  Different\n\
    \   delivery service models might require different congestion control\n   protocols.\n"
- title: 5.  Packet Header Fields
  contents:
  - "5.  Packet Header Fields\n   Packets sent to an LCT session MUST include an \"\
    LCT header\".  The LCT\n   header format described below is the default format,\
    \ and this is the\n   format that is recommended for use by protocol instantiations\
    \ to\n   ensure a uniform format across different protocol instantiations.\n \
    \  Other LCT header formats MAY be used by protocol instantiations, but\n   if\
    \ the default LCT header format is not used by a protocol\n   instantiation that\
    \ uses LCT, then the protocol instantiation MUST\n   specify the lengths and positions\
    \ within the LCT header it uses of\n   all fields described in the default LCT\
    \ header.\n   Other building blocks MAY describe some of the same fields as\n\
    \   described for the LCT header.  It is RECOMMENDED that protocol\n   instantiations\
    \ using multiple building blocks include shared fields\n   at most once in each\
    \ packet.  Thus, for example, if another building\n   block is used with LCT that\
    \ includes the optional Expected Residual\n   Time field, then the Expected Residual\
    \ Time field SHOULD be carried\n   in each packet at most once.\n   The position\
    \ of the LCT header within a packet MUST be specified by\n   any protocol instantiation\
    \ that uses LCT.\n"
- title: 5.1  Default LCT header format
  contents:
  - "5.1  Default LCT header format\n   The default LCT header is of variable size,\
    \ which is specified by a\n   length field in the third byte of the header.  In\
    \ the LCT header, all\n   integer fields are carried in \"big-endian\" or \"network\
    \ order\" format,\n   that is, most significant byte (octet) first.  Bits designated\
    \ as\n   \"padding\" or \"reserved\" (r) MUST by set to 0 by senders and ignored\n\
    \   by receivers.  Unless otherwise noted, numeric constants in this\n   specification\
    \ are in decimal (base 10).\n   The format of the default LCT header is depicted\
    \ in Figure 1.\n     0                   1                   2               \
    \    3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |\
    \   V   | C | r |S| O |H|T|R|A|B|   HDR_LEN     | Codepoint (CP)|\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    | Congestion Control Information (CCI, length = 32*(C+1) bits)  |\n    |\
    \                          ...                                  |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |  Transport Session Identifier (TSI, length = 32*S+16*H bits)  |\n    |\
    \                          ...                                  |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |   Transport Object Identifier (TOI, length = 32*O+16*H bits)  |\n    |\
    \                          ...                                  |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |               Sender Current Time (SCT, if T = 1)             |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |              Expected Residual Time (ERT, if R = 1)           |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                Header Extensions (if applicable)              |\n    |\
    \                          ...                                  |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                   Figure 1 - Default LCT header format\n   The function and\
    \ length of each field in the default LCT header is\n   the following.  Fields\
    \ marked as \"1\" mean that the corresponding bits\n   MUST be set to \"1\" by\
    \ the sender.  Fields marked as \"r\" or \"0\" mean\n   that the corresponding\
    \ bits MUST be set to \"0\" by the sender.\n     LCT version number (V): 4 bits\n\
    \         Indicates the LCT version number.  The LCT version number for\n    \
    \     this specification is 1.\n     Congestion control flag (C): 2 bits\n   \
    \      C=0 indicates the Congestion Control Information (CCI) field is\n     \
    \    32-bits in length.  C=1 indicates the CCI field is 64-bits in\n         length.\
    \  C=2 indicates the CCI field is 96-bits in length.  C=3\n         indicates\
    \ the CCI field is 128-bits in length.\n     Reserved (r): 2 bits\n         Reserved\
    \ for future use.  A sender MUST set these bits to zero\n         and a receiver\
    \ MUST ignore these bits.\n     Transport Session Identifier flag (S): 1 bit\n\
    \         This is the number of full 32-bit words in the TSI field.  The\n   \
    \      TSI field is 32*S + 16*H bits in length, i.e. the length is\n         either\
    \ 0 bits, 16 bits, 32 bits, or 48 bits.\n     Transport Object Identifier flag\
    \ (O): 2 bits\n         This is the number of full 32-bit words in the TOI field.\
    \  The\n         TOI field is 32*O + 16*H bits in length, i.e., the length is\n\
    \         either 0 bits, 16 bits, 32 bits, 48 bits, 64 bits, 80 bits, 96\n   \
    \      bits, or 112 bits.\n     Half-word flag (H): 1 bit\n         The TSI and\
    \ the TOI fields are both multiples of 32-bits plus\n         16*H bits in length.\
    \  This allows the TSI and TOI field lengths\n         to be multiples of a half-word\
    \ (16 bits), while ensuring that\n         the aggregate length of the TSI and\
    \ TOI fields is a multiple of\n         32-bits.\n     Sender Current Time present\
    \ flag (T): 1 bit\n         T = 0 indicates that the Sender Current Time (SCT)\
    \ field is not\n         present.  T = 1 indicates that the SCT field is present.\
    \  The\n         SCT is inserted by senders to indicate to receivers how long\n\
    \         the session has been in progress.\n     Expected Residual Time present\
    \ flag (R): 1 bit\n         R = 0 indicates that the Expected Residual Time (ERT)\
    \ field is\n         not present.  R = 1 indicates that the ERT field is present.\n\
    \         The ERT is inserted by senders to indicate to receivers how\n      \
    \   much longer the session / object transmission will continue.\n         Senders\
    \ MUST NOT set R = 1 when the ERT for the session is more\n         than 2^32-1\
    \ time units (approximately 49 days), where time is\n         measured in units\
    \ of milliseconds.\n     Close Session flag (A): 1 bit\n         Normally, A is\
    \ set to 0.  The sender MAY set A to 1 when\n         termination of transmission\
    \ of packets for the session is\n         imminent.  A MAY be set to 1 in just\
    \ the last packet\n         transmitted for the session, or A MAY be set to 1\
    \ in the last\n         few seconds of packets transmitted for the session.  Once\
    \ the\n         sender sets A to 1 in one packet, the sender SHOULD set A to 1\n\
    \         in all subsequent packets until termination of transmission of\n   \
    \      packets for the session.  A received packet with A set to 1\n         indicates\
    \ to a receiver that the sender will immediately stop\n         sending packets\
    \ for the session.  When a receiver receives a\n         packet with A set to\
    \ 1 the receiver SHOULD assume that no more\n         packets will be sent to\
    \ the session.\n     Close Object flag (B): 1 bit\n         Normally, B is set\
    \ to 0.  The sender MAY set B to 1 when\n         termination of transmission\
    \ of packets for an object is\n         imminent.  If the TOI field is in use\
    \ and B is set to 1 then\n         termination of transmission for the object\
    \ identified by the\n         TOI field is imminent.  If the TOI field is not\
    \ in use and B is\n         set to 1 then termination of transmission for the\
    \ one object in\n         the session identified by out-of-band information is\
    \ imminent.\n         B MAY be set to 1 in just the last packet transmitted for\
    \ the\n         object, or B MAY be set to 1 in the last few seconds packets\n\
    \         transmitted for the object.  Once the sender sets B to 1 in one\n  \
    \       packet for a particular object, the sender SHOULD set B to 1 in\n    \
    \     all subsequent packets for the object until termination of\n         transmission\
    \ of packets for the object.  A received packet with\n         B set to 1 indicates\
    \ to a receiver that the sender will\n         immediately stop sending packets\
    \ for the object.  When a\n         receiver receives a packet with B set to 1\
    \ then it SHOULD\n         assume that no more packets will be sent for the object\
    \ to the\n         session.\n     LCT header length (HDR_LEN): 8 bits\n      \
    \   Total length of the LCT header in units of 32-bit words.  The\n         length\
    \ of the LCT header MUST be a multiple of 32-bits.  This\n         field can be\
    \ used to directly access the portion of the packet\n         beyond the LCT header,\
    \ i.e., to the first other header if it\n         exists, or to the packet payload\
    \ if it exists and there is no\n         other header, or to the end of the packet\
    \ if there are no other\n         headers or packet payload.\n     Codepoint (CP):\
    \ 8 bits\n         An opaque identifier which is passed to the packet payload\n\
    \         decoder to convey information on the codec being used for the\n    \
    \     packet payload.  The mapping between the codepoint and the\n         actual\
    \ codec is defined on a per session basis and communicated\n         out-of-band\
    \ as part of the session description information.\n         The use of the CP\
    \ field is similar to the Payload Type (PT)\n         field in RTP headers as\
    \ described in RFC 1889 [21].\n     Congestion Control Information (CCI): 32,\
    \ 64, 96 or 128 bits\n         Used to carry congestion control information. \
    \ For example, the\n         congestion control information could include layer\
    \ numbers,\n         logical channel numbers, and sequence numbers.  This field\
    \ is\n         opaque for the purpose of this specification.\n         This field\
    \ MUST be 32 bits if C=0.\n         This field MUST be 64 bits if C=1.\n     \
    \    This field MUST be 96 bits if C=2.\n         This field MUST be 128 bits\
    \ if C=3.\n     Transport Session Identifier (TSI): 0, 16, 32 or 48 bits\n   \
    \      The TSI uniquely identifies a session among all sessions from a\n     \
    \    particular sender.  The TSI is scoped by the IP address of the\n        \
    \ sender, and thus the IP address of the sender and the TSI\n         together\
    \ uniquely identify the session.  Although a TSI in\n         conjunction with\
    \ the IP address of the sender always uniquely\n         identifies a session,\
    \ whether or not the TSI is included in the\n         LCT header depends on what\
    \ is used as the TSI value.  If the\n         underlying transport is UDP, then\
    \ the 16 bit UDP source port\n         number MAY serve as the TSI for the session.\
    \  If the TSI value\n         appears multiple times in a packet then all occurrences\
    \ MUST be\n         the same value.  If there is no underlying TSI provided by\
    \ the\n         network, transport or any other layer, then the TSI MUST be\n\
    \         included in the LCT header.\n         The TSI MUST be unique among all\
    \ sessions served by the sender\n         during the period when the session is\
    \ active, and for a large\n         period of time preceding and following when\
    \ the session is\n         active.  A primary purpose of the TSI is to prevent\
    \ receivers\n         from inadvertently accepting packets from a sender that\
    \ belong\n         to sessions other than the sessions receivers are subscribed\n\
    \         to.  For example, suppose a session is deactivated and then\n      \
    \   another session is activated by a sender and the two sessions\n         use\
    \ an overlapping set of channels.  A receiver that connects\n         and remains\
    \ connected to the first session during this sender\n         activity could possibly\
    \ accept packets from the second session\n         as belonging to the first session\
    \ if the TSI for the two\n         sessions were identical.  The mapping of TSI\
    \ field values to\n         sessions is outside the scope of this document and\
    \ is to be\n         done out-of-band.\n         The length of the TSI field is\
    \ 32*S + 16*H bits.  Note that the\n         aggregate lengths of the TSI field\
    \ plus the TOI field is a\n         multiple of 32 bits.\n     Transport Object\
    \ Identifier (TOI): 0, 16, 32, 48, 64, 80, 96 or 112\n         bits.\n       \
    \  This field indicates which object within the session this\n         packet\
    \ pertains to.  For example, a sender might send a number\n         of files in\
    \ the same session, using TOI=0 for the first file,\n         TOI=1 for the second\
    \ one, etc. As another example, the TOI may\n         be a unique global identifier\
    \ of the object that is being\n         transmitted from several senders concurrently,\
    \ and the TOI\n         value may be the output of a hash function applied to\
    \ the\n         object.  The mapping of TOI field values to objects is outside\n\
    \         the scope of this document and is to be done out-of-band.  The\n   \
    \      TOI field MUST be used in all packets if more than one object\n       \
    \  is to be transmitted in a session, i.e. the TOI field is either\n         present\
    \ in all the packets of a session or is never present.\n         The length of\
    \ the TOI field is 32*O + 16*H bits.  Note that the\n         aggregate lengths\
    \ of the TSI field plus the TOI field is a\n         multiple of 32 bits.\n  \
    \   Sender Current Time (SCT): 0 or 32 bits\n         This field represents the\
    \ current clock at the sender and at\n         the time this packet was transmitted,\
    \ measured in units of 1ms\n         and computed modulo 2^32 units from the start\
    \ of the session.\n         This field MUST NOT be present if T=0 and MUST be\
    \ present if\n         T=1.\n     Expected Residual Time (ERT): 0 or 32 bits\n\
    \         This field represents the sender expected residual transmission\n  \
    \       time for the current session or for the transmission of the\n        \
    \ current object, measured in units of 1ms.  If the packet\n         containing\
    \ the ERT field also contains the TOI field, then ERT\n         refers to the\
    \ object corresponding to the TOI field, otherwise\n         it refers to the\
    \ session.\n         This field MUST NOT be present if R=0 and MUST be present\
    \ if\n         R=1.\n"
- title: 5.2  Header-Extension Fields
  contents:
  - "5.2  Header-Extension Fields\n   Header Extensions are used in LCT to accommodate\
    \ optional header\n   fields that are not always used or have variable size. \
    \ Examples of\n   the use of Header Extensions include:\n     o Extended-size\
    \ versions of already existing header fields.\n     o Sender and Receiver authentication\
    \ information.\n   The presence of Header Extensions can be inferred by the LCT\
    \ header\n   length (HDR_LEN): if HDR_LEN is larger than the length of the\n \
    \  standard header then the remaining header space is taken by Header\n   Extension\
    \ fields.\n   If present, Header Extensions MUST be processed to ensure that they\n\
    \   are recognized before performing any congestion control procedure or\n   otherwise\
    \ accepting a packet.  The default action for unrecognized\n   header extensions\
    \ is to ignore them.  This allows the future\n   introduction of backward-compatible\
    \ enhancements to LCT without\n   changing the LCT version number.  Non backward-compatible\
    \ header\n   extensions CANNOT be introduced without changing the LCT version\n\
    \   number.\n   Protocol instantiation MAY override this default behavior for\
    \ PI-\n   specific extensions (see below).\n   There are two formats for Header\
    \ Extension fields, as depicted below.\n   The first format is used for variable-length\
    \ extensions, with Header\n   Extension Type (HET) values between 0 and 127. \
    \ The second format is\n   used for fixed length (one 32-bit word) extensions,\
    \ using HET values\n   from 127 to 255.\n     0                   1          \
    \         2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |  HET (<=127)  |       HEL     |                               |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               +\n    .                                     \
    \                          .\n    .              Header Extension Content (HEC)\
    \                   .\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     0                   1                   2                   3\n     0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |  HET (>=128)  |       Header Extension Content (HEC)          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                  Figure 2 - Format of additional headers\n   The explanation\
    \ of each sub-field is the following:\n     Header Extension Type (HET): 8 bits\n\
    \         The type of the Header Extension.  This document defines a\n       \
    \  number of possible types.  Additional types may be defined in\n         future\
    \ versions of this specification.  HET values from 0 to\n         127 are used\
    \ for variable-length Header Extensions.  HET values\n         from 128 to 255\
    \ are used for fixed-length 32-bit Header\n         Extensions.\n     Header Extension\
    \ Length (HEL): 8 bits\n         The length of the whole Header Extension field,\
    \ expressed in\n         multiples of 32-bit words.  This field MUST be present\
    \ for\n         variable-length extensions (HET between 0 and 127) and MUST NOT\n\
    \         be present for fixed-length extensions (HET between 128 and\n      \
    \   255).\n     Header Extension Content (HEC): variable length\n         The\
    \ content of the Header Extension.  The format of this sub-\n         field depends\
    \ on the Header Extension type.  For fixed-length\n         Header Extensions,\
    \ the HEC is 24 bits.  For variable-length\n         Header Extensions, the HEC\
    \ field has variable size, as\n         specified by the HEL field.  Note that\
    \ the length of each\n         Header Extension field MUST be a multiple of 32\
    \ bits.  Also\n         note that the total size of the LCT header, including\
    \ all\n         Header Extensions and all optional header fields, cannot exceed\n\
    \         255 32-bit words.\n   Header Extensions are further divided between\
    \ general LCT extensions\n   and Protocol Instantiation specific extensions (PI-specific).\n\
    \   General LCT extensions have HET in the ranges 0:63 and 128:191\n   inclusive.\
    \  PI-specific extensions have HET in the ranges 64:127 and\n   192:255 inclusive.\n\
    \   General LCT extensions are intended to allow the introduction of\n   backward-compatible\
    \ enhancements to LCT without changing the LCT\n   version number.  Non backward-compatible\
    \ header extensions CANNOT be\n   introduced without changing the LCT version\
    \ number.\n   PI-specific extensions are reserved for PI-specific use with semantic\n\
    \   and default parsing actions defined by the PI.\n   The following general LCT\
    \ Header Extension types are defined:\n   EXT_NOP=0     No-Operation extension.\n\
    \                 The information present in this extension field MUST be\n  \
    \               ignored by receivers.\n   EXT_AUTH=1    Packet authentication\
    \ extension\n                 Information used to authenticate the sender of the\n\
    \                 packet.  The format of this Header Extension and its\n     \
    \            processing is outside the scope of this document and is\n       \
    \          to be communicated out-of-band as part of the session\n           \
    \      description.\n                 It is RECOMMENDED that senders provide some\
    \ form of\n                 packet authentication.  If EXT_AUTH is present,\n\
    \                 whatever packet authentication checks that can be\n        \
    \         performed immediately upon reception of the packet\n               \
    \  SHOULD be performed before accepting the packet and\n                 performing\
    \ any congestion control-related action on it.\n                 Some packet authentication\
    \ schemes impose a delay of\n                 several seconds between when a packet\
    \ is received and\n                 when the packet is fully authenticated.  Any\
    \ congestion\n                 control related action that is appropriate MUST\
    \ NOT be\n                 postponed by any such full packet authentication.\n\
    \   All senders and receivers implementing LCT MUST support the EXT_NOP\n   Header\
    \ Extension and MUST recognize EXT_AUTH, but MAY NOT be able to\n   parse its\
    \ content.\n"
- title: 6.  Operations
  contents:
  - '6.  Operations

    '
- title: 6.1  Sender Operation
  contents:
  - "6.1  Sender Operation\n   Before joining an LCT session a receiver MUST obtain\
    \ a session\n   description.  The session description MUST include:\n     o The\
    \ sender IP address;\n     o The number of LCT channels;\n     o The addresses\
    \ and port numbers used for each LCT channel;\n     o The Transport Session ID\
    \ (TSI) to be used for the session;\n     o Enough information to determine the\
    \ congestion control protocol\n       being used;\n     o Enough information to\
    \ determine the packet authentication scheme\n       being used if it is being\
    \ used.\n   The session description could also include, but is not limited to:\n\
    \     o The data rates used for each LCT channel;\n     o The length of the packet\
    \ payload;\n     o The mapping of TOI value(s) to objects for the session;\n \
    \    o Any information that is relevant to each object being\n       transported,\
    \ such as when it will be available within the\n       session, for how long,\
    \ and the length of the object;\n   Protocol instantiations using LCT MAY place\
    \ additional requirements\n   on what must be included in the session description.\
    \  For example, a\n   protocol instantiation might require that the data rates\
    \ for each\n   channel, or the mapping of TOI value(s) to objects for the session,\n\
    \   or other information related to other headers that might be required\n   to\
    \ be included in the session description.\n   The session description could be\
    \ in a form such as SDP as defined in\n   RFC 2327 [8], or XML metadata as defined\
    \ in RFC 3023 [14], or\n   HTTP/Mime headers as defined in RFC 2068 [6], etc.\
    \  It might be\n   carried in a session announcement protocol such as SAP as defined\
    \ in\n   RFC 2974 [9], obtained using a proprietary session control protocol,\n\
    \   located on a Web page with scheduling information, or conveyed via\n   E-mail\
    \ or other out-of-band methods.  Discussion of session\n   description format,\
    \ and distribution of session descriptions is\n   beyond the scope of this document.\n\
    \   Within an LCT session, a sender using LCT transmits a sequence of\n   packets,\
    \ each in the format defined above.  Packets are sent from a\n   sender using\
    \ one or more LCT channels which together constitute a\n   session.  Transmission\
    \ rates may be different in different channels\n   and may vary over time.  The\
    \ specification of the other building\n   block headers and the packet payload\
    \ used by a complete protocol\n   instantiation using LCT is beyond the scope\
    \ of this document.  This\n   document does not specify the order in which packets\
    \ are transmitted,\n   nor the organization of a session into multiple channels.\
    \  Although\n   these issues affect the efficiency of the protocol, they do not\n\
    \   affect the correctness nor the inter-operability of LCT between\n   senders\
    \ and receivers.\n   Several objects can be carried within the same LCT session.\
    \  In this\n   case, each object MUST be identified by a unique TOI.  Objects\
    \ MAY be\n   transmitted sequentially, or they MAY be transmitted concurrently.\n\
    \   It is good practice to only send objects concurrently in the same\n   session\
    \ if the receivers that participate in that portion of the\n   session have interest\
    \ in receiving all the objects.  The reason for\n   this is that it wastes bandwidth\
    \ and networking resources to have\n   receivers receive data for objects that\
    \ they have no interest in.\n   Typically, the sender(s) continues to send packets\
    \ in a session until\n   the transmission is considered complete.  The transmission\
    \ may be\n   considered complete when some time has expired, a certain number\
    \ of\n   packets have been sent, or some out-of-band signal (possibly from a\n\
    \   higher level protocol) has indicated completion by a sufficient\n   number\
    \ of receivers.\n   For the reasons mentioned above, this document does not pose\
    \ any\n   restriction on packet sizes.  However, network efficiency\n   considerations\
    \ recommend that the sender uses an as large as possible\n   packet payload size,\
    \ but in such a way that packets do not exceed the\n   network's maximum transmission\
    \ unit size (MTU), or when fragmentation\n   coupled with packet loss might introduce\
    \ severe inefficiency in the\n   transmission.\n   It is recommended that all\
    \ packets have the same or very similar\n   sizes, as this can have a severe impact\
    \ on the effectiveness of\n   congestion control schemes such as the ones described\
    \ in [22], [3],\n   and [25].  A sender of packets using LCT MUST implement the\
    \ sender-\n   side part of one of the congestion control schemes that is in\n\
    \   accordance with RFC 2357 [13] using the Congestion Control\n   Information\
    \ field provided in the LCT header, and the corresponding\n   receiver congestion\
    \ control scheme is to be communicated out-of-band\n   and MUST be implemented\
    \ by any receivers participating in the\n   session.\n"
- title: 6.2  Receiver Operation
  contents:
  - "6.2  Receiver Operation\n   Receivers can operate differently depending on the\
    \ delivery service\n   model.  For example, for an on demand service model, receivers\
    \ may\n   join a session, obtain the necessary packets to reproduce the object,\n\
    \   and then leave the session.  As another example, for a streaming\n   service\
    \ model, a receiver may be continuously joined to a set of LCT\n   channels to\
    \ download all objects in a session.\n   To be able to participate in a session,\
    \ a receiver MUST obtain the\n   relevant session description information as listed\
    \ in Section 6.1.\n   If packet authentication information is present in an LCT\
    \ header, it\n   SHOULD be used as specified in Section 5.2.  To be able to be\
    \ a\n   receiver in a session, the receiver MUST be able to process the LCT\n\
    \   header.  The receiver MUST be able to discard, forward, store or\n   process\
    \ the other headers and the packet payload.  If a receiver is\n   not able to\
    \ process a LCT header, it MUST drop from the session.\n   To be able to participate\
    \ in a session, a receiver MUST implement the\n   congestion control protocol\
    \ specified in the session description\n   using the Congestion Control Information\
    \ field provided in the LCT\n   header. If a receiver is not able to implement\
    \ the congestion control\n   protocol used in the session, it MUST NOT join the\
    \ session.  When the\n   session is transmitted on multiple LCT channels, receivers\
    \ MUST\n   initially join channels according to the specified startup behavior\n\
    \   of the congestion control protocol.  For a multiple rate congestion\n   control\
    \ protocol that uses multiple channels, this typically means\n   that a receiver\
    \ will initially join only a minimal set of LCT\n   channels, possibly a single\
    \ one, that in aggregate are carrying\n   packets at a low rate.  This rule has\
    \ the purpose of preventing\n   receivers from starting at high data rates.\n\
    \   Several objects can be carried either sequentially or concurrently\n   within\
    \ the same LCT session.  In this case, each object is identified\n   by a unique\
    \ TOI.  Note that even if a server stops sending packets\n   for an old object\
    \ before starting to transmit packets for a new\n   object, both the network and\
    \ the underlying protocol layers can cause\n   some reordering of packets, especially\
    \ when sent over different LCT\n   channels, and thus receivers SHOULD NOT assume\
    \ that the reception of\n   a packet for a new object means that there are no\
    \ more packets in\n   transit for the previous one, at least for some amount of\
    \ time.\n   A receiver MAY be concurrently joined to multiple LCT sessions from\n\
    \   one or more senders.  The receiver MUST perform congestion control on\n  \
    \ each such LCT session.  If the congestion control protocol allows the\n   receiver\
    \ some flexibility in terms of its actions within a session\n   then the receiver\
    \ MAY make choices to optimize the packet flow\n   performance across the multiple\
    \ LCT sessions, as long as the receiver\n   still adheres to the congestion control\
    \ rules for each LCT session\n   individually.\n"
- title: 7.  Requirements from Other Building Blocks
  contents:
  - "7.  Requirements from Other Building Blocks\n   As described in RFC 3048 [23],\
    \ LCT is a building block that is\n   intended to be used, in conjunction with\
    \ other building blocks, to\n   help specify a protocol instantiation.  A congestion\
    \ control building\n   block that uses the Congestion Control information field\
    \ within the\n   LCT header MUST be used by any protocol instantiation that uses\
    \ LCT,\n   and other building blocks MAY also be used, such as a reliability\n\
    \   building block.\n   The congestion control MUST be applied to the LCT session\
    \ as an\n   entity, i.e., over the aggregate of the traffic carried by all of\
    \ the\n   LCT channels associated with the LCT session.  Some possible schemes\n\
    \   are specified in [22], [3], and [25].  The Congestion Control\n   Information\
    \ field in the LCT header is an opaque field that is\n   reserved to carry information\
    \ related to congestion control.  There\n   MAY also be congestion control Header\
    \ Extension fields that carry\n   additional information related to congestion\
    \ control.\n   The particular layered encoder and congestion control protocols\
    \ used\n   with LCT have an impact on the performance and applicability of LCT.\n\
    \   For example, some layered encoders used for video and audio streams\n   can\
    \ produce a very limited number of layers, thus providing a very\n   coarse control\
    \ in the reception rate of packets by receivers in a\n   session.  When LCT is\
    \ used for reliable data transfer, some FEC\n   codecs are inherently limited\
    \ in the size of the object they can\n   encode, and for objects larger than this\
    \ size the reception overhead\n   on the receivers can grow substantially.\n \
    \  A more in-depth description of the use of FEC in Reliable Multicast\n   Transport\
    \ (RMT) protocols is given in [11].  Some of the FEC codecs\n   that MAY be used\
    \ in conjunction with LCT for reliable content\n   delivery are specified in [12].\
    \  The Codepoint field in the LCT\n   header is an opaque field that can be used\
    \ to carry information\n   related to the encoding of the packet payload.\n  \
    \ LCT also requires receivers to obtain a session description, as\n   described\
    \ in Section 6.1.  The session description could be in a form\n   such as SDP\
    \ as defined in RFC 2327 [8], or XML metadata as defined in\n   RFC 3023 [14],\
    \ or HTTP/Mime headers as defined in RFC 2068 [6], and\n   distributed with SAP\
    \ as defined in RFC 2974 [9], using HTTP, or in\n   other ways.  It is RECOMMENDED\
    \ that an authentication protocol such\n   as IPSEC [11] be used to deliver the\
    \ session description to receivers\n   to ensure the correct session description\
    \ arrives.\n   It is recommended that LCT implementors use some packet\n   authentication\
    \ scheme to protect the protocol from attacks.  An\n   example of a possibly suitable\
    \ scheme is described in [15].\n   Some protocol instantiations that use LCT MAY\
    \ use building blocks\n   that require the generation of feedback from the receivers\
    \ to the\n   sender.  However, the mechanism for doing this is outside the scope\n\
    \   of LCT.\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   LCT can be subject to denial-of-service attacks\
    \ by attackers which\n   try to confuse the congestion control mechanism, or send\
    \ forged\n   packets to the session which would prevent successful reconstruction\n\
    \   or cause inaccurate reconstruction of large portions of an object by\n   receivers.\
    \  LCT is particularly affected by such an attack since many\n   receivers may\
    \ receive the same forged packet.  It is therefore\n   RECOMMENDED that an integrity\
    \ check be made on received objects\n   before delivery to an application, e.g.,\
    \ by appending an MD5 hash\n   [17] to an object before it is sent and then computing\
    \ the MD5 hash\n   once the object is reconstructed to ensure it is the same as\
    \ the sent\n   object.  Moreover, in order to obtain strong cryptographic integrity\n\
    \   protection a digital signature verifiable by the receiver SHOULD be\n   computed\
    \ on top of such a hash value.  It is also RECOMMENDED that\n   protocol instantiations\
    \ that use LCT implement some form of packet\n   authentication such as TESLA\
    \ [15] to protect against such attacks.\n   Finally, it is RECOMMENDED that Reverse\
    \ Path Forwarding checks be\n   enabled in all network routers and switches along\
    \ the path from the\n   sender to receivers to limit the possibility of a bad\
    \ agent injecting\n   forged packets into the multicast tree data path.\n   Another\
    \ vulnerability of LCT is the potential of receivers obtaining\n   an incorrect\
    \ session description for the session.  The consequences\n   of this could be\
    \ that legitimate receivers with the wrong session\n   description are unable\
    \ to correctly receive the session content, or\n   that receivers inadvertently\
    \ try to receive at a much higher rate\n   than they are capable of, thereby disrupting\
    \ traffic in portions of\n   the network.  To avoid these problems, it is RECOMMENDED\
    \ that\n   measures be taken to prevent receivers from accepting incorrect\n \
    \  Session Descriptions, e.g., by using source authentication to ensure\n   that\
    \ receivers only accept legitimate Session Descriptions from\n   authorized senders.\n\
    \   A receiver with an incorrect or corrupted implementation of the\n   multiple\
    \ rate congestion control building block may affect health of\n   the network\
    \ in the path between the sender and the receiver, and may\n   also affect the\
    \ reception rates of other receivers joined to the\n   session.  It is therefore\
    \ RECOMMENDED that receivers be required to\n   identify themselves as legitimate\
    \ before they receive the Session\n   Description needed to join the session.\
    \  How receivers identify\n   themselves as legitimate is outside the scope of\
    \ this document.\n"
- title: 9.  IANA Considerations
  contents:
  - "9.  IANA Considerations\n   No information in this specification is subject to\
    \ IANA registration.\n   Building blocks used in conjunction with LCT MAY introduce\
    \ additional\n   IANA considerations.\n"
- title: 10.  Acknowledgments
  contents:
  - "10.  Acknowledgments\n   Thanks to Vincent Roca and Roger Kermode for detailed\
    \ comments and\n   contributions to this document.  Thanks also to Bruce Lueckenhoff,\n\
    \   Hayder Radha and Justin Chapweske for detailed comments on this\n   document.\n"
- title: 11.  References
  contents:
  - "11.  References\n   [1]  Bradner, S., \"The Internet Standards Process -- Revision\
    \ 3\", BCP\n        9, RFC 2026, October 1996.\n   [2]  Bradner, S., \"Key words\
    \ for use in RFCs to Indicate Requirement\n        Levels\", BCP 14, RFC 2119,\
    \ March 1997.\n   [3]  Byers, J.W., Frumin, M., Horn, G., Luby, M., Mitzenmacher,\
    \ M.,\n        Roetter, A. and W. Shaver, \"FLID-DL: Congestion Control for\n\
    \        Layered Multicast\", Proceedings of Second International Workshop\n \
    \       on Networked Group Communications (NGC 2000), Palo Alto, CA,\n       \
    \ November 2000.\n   [4]  Byers, J.W., Luby, M., Mitzenmacher, M. and A. Rege,\
    \ \"A Digital\n        Fountain Approach to Reliable Distribution of Bulk Data\"\
    ,\n        Proceedings ACM SIGCOMM'98, Vancouver, Canada, September 1998.\n  \
    \ [5]  Deering, S., \"Host Extensions for IP Multicasting\", STD 5, RFC\n    \
    \    1112, August 1989.\n   [6]  Fielding, R., Gettys, J., Mogul, J., Frystyk,\
    \ H. and T.\n        Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1\"\
    , RFC\n        2616, January 1997.\n   [7]  Gemmell, J., Schooler, E. and J. Gray,\
    \ \"Fcast Multicast File\n        Distribution\", IEEE Network, Vol. 14, No. 1,\
    \ pp. 58-68, January\n        2000.\n   [8]  Handley, M. and V. Jacobson, \"SDP:\
    \ Session Description\n        Protocol\", RFC 2327, April 1998.\n   [9]  Handley,\
    \ M., Perkins, C. and E. Whelan, \"Session Announcement\n        Protocol\", RFC\
    \ 2974, October 2000.\n   [10] Holbrook, H. W., \"A Channel Model for Multicast\"\
    , Ph.D.\n        Dissertation, Stanford University, Department of Computer\n \
    \       Science, Stanford, California, August 2001.\n   [11] Luby, M., Vicisano,\
    \ L., Gemmell, J., Rizzo, L., Handley, M. and\n        J. Crowcroft, \"The Use\
    \ of Forward Error Correction (FEC) in\n        Reliable Multicast\", RFC 3453,\
    \ December 2002.\n   [12] Luby, M., Vicisano, L., Gemmell, J., Rizzo, L., Handley,\
    \ M. and\n        J. Crowcroft, \"Forward Error Correction (FEC) Building Block\"\
    ,\n        RFC 3452, December 2002.\n   [13] Mankin, A., Romanow, A., Bradner,\
    \ S. and V. Paxson, \"IETF\n        Criteria for Evaluating Reliable Multicast\
    \ Transport and\n        Application Protocols\", RFC 2357, June 1998.\n   [14]\
    \ Murata, M., St. Laurent, S. and D. Kohn, \"XML Media Types\", RFC\n        3023,\
    \ January 2001.\n   [15] Perrig, A., Canetti, R., Song, D. and J.D. Tygar, \"\
    Efficient and\n        Secure Source Authentication for Multicast\", Network and\n\
    \        Distributed System Security Symposium, NDSS 2001, pp. 35-46,\n      \
    \  February 2001.\n   [16] Postel, J., \"User Datagram Protocol\", STD 6, RFC\
    \ 768, August\n        1980.\n   [17] Rivest, R., \"The MD5 Message-Digest Algorithm\"\
    , RFC 1321, April\n        1992.\n   [18] Rizzo, L., \"Effective Erasure Codes\
    \ for Reliable Computer\n        Communication Protocols\", ACM SIGCOMM Computer\
    \ Communication\n        Review, Vol.27, No.2, pp.24-36, Apr 1997.\n   [19] Rizzo,\
    \ L, \"PGMCC: A TCP-friendly single-rate multicast\n        congestion control\
    \ scheme\", Proceedings of SIGCOMM 2000,\n        Stockholm Sweden, August 2000.\n\
    \   [20] Rizzo, L and L. Vicisano, \"Reliable Multicast Data Distribution\n  \
    \      protocol based on software FEC techniques\", Proceedings of the\n     \
    \   Fourth IEEES Workshop on the Architecture and Implementation of\n        High\
    \ Performance Communication Systems, HPCS'97, Chalkidiki\n        Greece, June\
    \ 1997.\n   [21] Schulzrinne, H., Casner, S., Frederick, R. and V. Jacobson,\n\
    \        \"RTP: A Transport Protocol for Real-Time Applications\", RFC\n     \
    \   1889, January 1996.\n   [22] Vicisano, L., Rizzo, L. and J. Crowcroft, \"\
    TCP-like Congestion\n        Control for Layered Multicast Data Transfer\", IEEE\
    \ Infocom'98,\n        San Francisco, CA, Mar.28-Apr.1 1998.\n   [23] Whetten,\
    \ B., Vicisano, L., Kermode, R., Handley, M., Floyd, S.\n        and M. Luby,\
    \ \"Reliable Multicast Transport Building Blocks for\n        One-to-Many Bulk-Data\
    \ Transfer\", RFC 3048, January 2001.\n   [24] Kermode, R., Vicisano, L., \"Author\
    \ Guidelines for Reliable\n        Multicast Transport (RMT) Building Blocks and\
    \ Protocol\n        Instantiation documents\", RFC 3269, April 2002.\n   [25]\
    \ Luby, M., Goyal V. K, Skaria S., Horn, G., \"Wave and Equation\n        Based\
    \ Rate Control using Multicast Round-trip Time\", Proceedings\n        of ACM\
    \ SIGCOMM 2002, Pittsburgh PA, August, 2002.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Michael Luby\n   Digital Fountain\n   39141 Civic Center\
    \ Dr.\n   Suite 300\n   Fremont, CA, USA, 94538\n   EMail: luby@digitalfountain.com\n\
    \   Jim Gemmell\n   Microsoft Research\n   455 Market St. #1690\n   San Francisco,\
    \ CA, 94105\n   EMail: jgemmell@microsoft.com\n   Lorenzo Vicisano\n   cisco Systems,\
    \ Inc.\n   170 West Tasman Dr.\n   San Jose, CA, USA, 95134\n   EMail: lorenzo@cisco.com\n\
    \   Luigi Rizzo\n   Dip. Ing. dell'Informazione,\n   Univ. di Pisa\n   via Diotisalvi\
    \ 2, 56126 Pisa, Italy\n   EMail: luigi@iet.unipi.it\n   Mark Handley\n   ICIR\n\
    \   1947 Center St.\n   Berkeley, CA, USA, 94704\n   EMail: mjh@icir.org\n   Jon\
    \ Crowcroft\n   Marconi Professor of Communications Systems\n   University of\
    \ Cambridge\n   Computer Laboratory\n   William Gates Building\n   J J Thomson\
    \ Avenue\n   Cambridge CB3 0FD, UK\n   EMail: Jon.Crowcroft@cl.cam.ac.uk\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2002).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
