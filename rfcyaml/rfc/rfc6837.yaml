- title: __initial_text__
  contents:
  - ''
- title: Independent Submission                                           E. Lear
  contents:
  - "Independent Submission                                           E. Lear\n  A\
    \ Not-so-novel Endpoint ID (EID) to Routing Locator (RLOC) Database\n"
- title: Abstract
  contents:
  - "Abstract\n   The Locator/ID Separation Protocol (LISP) is a protocol to\n   encapsulate\
    \ IP packets in order to allow end sites to route to one\n   another without injecting\
    \ routes from one end of the Internet to\n   another.  This memo presents an experimental\
    \ database and a\n   discussion of methods to transport the mapping of Endpoint\
    \ IDs (EIDs)\n   to Routing Locators (RLOCs) to routers in a reliable, scalable,\
    \ and\n   secure manner.  Our analysis concludes that transport of all EID-to-\n\
    \   RLOC mappings scales well to at least 10^8 entries.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for examination, experimental implementation, and\n   evaluation.\n\
    \   This document defines an Experimental Protocol for the Internet\n   community.\
    \  This is a contribution to the RFC Series, independently\n   of any other RFC\
    \ stream.  The RFC Editor has chosen to publish this\n   document at its discretion\
    \ and makes no statement about its value for\n   implementation or deployment.\
    \  Documents approved for publication by\n   the RFC Editor are not a candidate\
    \ for any level of Internet\n   Standard; see Section 2 of RFC 5741.\n   Information\
    \ about the current status of this document, any errata,\n   and how to provide\
    \ feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6837.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2013 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  4\n     1.1.  Applicability  . . . . . . . . . . . . . . . . .\
    \ . . . . .  4\n     1.2.  Base Assumptions . . . . . . . . . . . . . . . . .\
    \ . . . .  4\n     1.3.  What is NERD?  . . . . . . . . . . . . . . . . . . .\
    \ . . .  5\n     1.4.  Glossary . . . . . . . . . . . . . . . . . . . . . . .\
    \ . .  6\n   2.  Theory of Operation  . . . . . . . . . . . . . . . . . . . .\
    \ .  7\n     2.1.  Database Updates . . . . . . . . . . . . . . . . . . . . .\
    \  7\n     2.2.  Communications between ITR and ETR . . . . . . . . . . . .  8\n\
    \     2.3.  Who are database authorities?  . . . . . . . . . . . . . .  8\n  \
    \ 3.  NERD Format  . . . . . . . . . . . . . . . . . . . . . . . . .  9\n    \
    \ 3.1.  NERD Record Format . . . . . . . . . . . . . . . . . . . . 11\n     3.2.\
    \  Database Update Format . . . . . . . . . . . . . . . . . . 12\n   4.  NERD\
    \ Distribution Mechanism  . . . . . . . . . . . . . . . . . 12\n     4.1.  Initial\
    \ Bootstrap  . . . . . . . . . . . . . . . . . . . . 12\n     4.2.  Retrieving\
    \ Changes . . . . . . . . . . . . . . . . . . . . 12\n   5.  Analysis . . . .\
    \ . . . . . . . . . . . . . . . . . . . . . . . 14\n     5.1.  Database Size \
    \ . . . . . . . . . . . . . . . . . . . . . . 14\n     5.2.  Router Throughput\
    \ versus Time  . . . . . . . . . . . . . . 16\n     5.3.  Number of Servers Required\
    \ . . . . . . . . . . . . . . . . 16\n     5.4.  Security Considerations  . .\
    \ . . . . . . . . . . . . . . . 18\n       5.4.1.  Use of Public Key Infrastructures\
    \ (PKIs) . . . . . . . 19\n       5.4.2.  Other Risks  . . . . . . . . . . . .\
    \ . . . . . . . . . 21\n   6.  Why not use XML? . . . . . . . . . . . . . . .\
    \ . . . . . . . . 21\n   7.  Other Distribution Mechanisms  . . . . . . . . .\
    \ . . . . . . . 22\n     7.1.  What about DNS as a mapping retrieval model? .\
    \ . . . . . . 22\n     7.2.  Use of BGP and LISP+ALT  . . . . . . . . . . . .\
    \ . . . . . 24\n     7.3.  Perhaps use a hybrid model?  . . . . . . . . . . .\
    \ . . . . 24\n   8.  Deployment Issues  . . . . . . . . . . . . . . . . . . .\
    \ . . . 24\n     8.1.  HTTP . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . 25\n   9.  Open Questions . . . . . . . . . . . . . . . . . . . . . . .\
    \ . 25\n   10. Conclusions  . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ 26\n   11. Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 27\n\
    \   12. References . . . . . . . . . . . . . . . . . . . . . . . . . . 27\n  \
    \   12.1. Normative References . . . . . . . . . . . . . . . . . . . 27\n    \
    \ 12.2. Informative References . . . . . . . . . . . . . . . . . . 27\n   Appendix\
    \ A.  Generating and Verifying the Database Signature\n                with OpenSSL\
    \  . . . . . . . . . . . . . . . . . . . . 30\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The Locator/ID Separation Protocol (LISP) [RFC6830] separates\
    \ an IP\n   address used by a host and local routing system from the Locators\n\
    \   advertised by BGP participants on the Internet in general, and in the\n  \
    \ Default-Free Zone (DFZ) in particular.  It accomplishes this by\n   establishing\
    \ a mapping between globally unique Endpoint IDs (EIDs)\n   and Routing Locators\
    \ (RLOCs).  This reduces the amount of state\n   change that occurs on routers\
    \ within the DFZ on the Internet, while\n   enabling end sites to be multihomed.\n\
    \   In some mapping distribution approaches to LISP, the mapping is\n   learned\
    \ via data-triggered control messages between Ingress Tunnel\n   Routers (ITRs)\
    \ and Egress Tunnel Routers (ETRs) through an alternate\n   routing topology [RFC6836].\
    \  In other approaches of LISP, the mapping\n   from EIDs to RLOCs is instead\
    \ learned through some other means.  This\n   memo addresses different approaches\
    \ to the problem, and specifies a\n   Not-so-novel EID-to-RLOC Database (NERD)\
    \ and methods to both receive\n   the database and to receive updates.\n   NERD\
    \ is offered primarily as a way to avoid dropping packets, the\n   underlying\
    \ assumption being that dropping packets is bad for\n   applications and end users.\
    \  Those who do not agree with this\n   underlying assumption may find that other\
    \ approaches make more sense.\n   NERD is specified in such a way that the methods\
    \ used to distribute\n   or retrieve it may vary over time.  Multiple databases\
    \ are supported\n   in order to allow for multiple data sources.  An effort has\
    \ been made\n   to divorce the database from access methods so that both can evolve\n\
    \   independently through experimentation and operational validation.\n"
- title: 1.1.  Applicability
  contents:
  - "1.1.  Applicability\n   This memo is based on experiments performed in the 2007-2009\
    \ time\n   frame.  At the time of its publication, the author is unaware of\n\
    \   operational use of NERD.  Those wishing to pursue NERD should\n   consider\
    \ the substantial amount of work left for the future.  See\n   Section 10 for\
    \ more details.\n"
- title: 1.2.  Base Assumptions
  contents:
  - "1.2.  Base Assumptions\n   In order to specify a mapping, it is important to\
    \ understand how it\n   will be used, and the nature of the data being mapped.\
    \  In the case\n   of LISP, the following assumptions are pertinent:\n   o  The\
    \ data contained within the mapping changes only on provisioning\n      or configuration\
    \ operations, and is not intended to change when a\n      link either fails or\
    \ is restored.  Some other mechanism, such as\n      the use of LISP Reachability\
    \ Bits with mapping replies, handles\n      healing operations, particularly when\
    \ a tail circuit within a\n      service provider's aggregate goes down.  NERD\
    \ can be used as a\n      verification method to ensure that whatever operational\
    \ mapping\n      changes an ITR receives are authorized.\n   o  While weight and\
    \ priority are defined, these are not hop-by-hop\n      metrics.  Hence, the information\
    \ contained within the mapping does\n      not change based on where one sits\
    \ within the topology.\n   o  Because a purpose of LISP is to reduce control-plane\
    \ overhead by\n      reducing \"rate X state\" complexity, updates to the mapping\
    \ will be\n      relatively rare.\n   o  Because NERD is designed to ease interdomain\
    \ routing, its use is\n      intended within the inter-domain environment.  That\
    \ is, NERD is\n      best implemented at either the customer edge or provider\
    \ edge, and\n      there will be on the order of as many ITRs and EID-Prefixes\
    \ as\n      there are connections to Internet service providers by end\n     \
    \ customers.\n   o  As such, NERD cannot be the sole means to implement host mobility,\n\
    \      although NERD may be in used in conjunction with other mechanisms.\n"
- title: 1.3.  What is NERD?
  contents:
  - "1.3.  What is NERD?\n   NERD is a Not-so-novel EID-to-RLOC Database.  It consists\
    \ of the\n   following components:\n   1.  a network database format;\n   2. \
    \ a change distribution format;\n   3.  a database retrieval/bootstrapping method;\
    \ and\n   4.  a change distribution method.\n   The network database format is\
    \ compressible.  However, at this time,\n   we specify no compression method.\
    \  NERD will make use of potentially\n   several transport methods, but most notably\
    \ HTTP [RFC2616].  HTTP has\n   restart and compression capabilities.  It is also\
    \ widely deployed.\n   There exist many methods to show differences between two\
    \ versions of\n   a database or a file, UNIX's \"diff\" being the classic example.\
    \  In\n   this case, because the data is well structured and easily keyed, we\n\
    \   can make use of a very simple format for version differences that\n   simply\
    \ provides a list of EID-to-RLOC mappings that have changed\n   using the same\
    \ record format as the database, and a list of EIDs that\n   are to be removed.\n"
- title: 1.4.  Glossary
  contents:
  - "1.4.  Glossary\n   The reader is once again referred to [RFC6830] for a general\
    \ glossary\n   of terms related to LISP.  The following terms are specific to\
    \ this\n   memo.\n   Base Distribution URI:  An Absolute-URI as defined in Section\
    \ 4.3 of\n      [RFC3986] from which other references are relative.  The base\n\
    \      distribution URI is used to construct a URI to an EID-to-RLOC\n      mapping\
    \ database.  If more than one NERD is known, then there will\n      be one or\
    \ more base distribution URIs associated with each\n      (although each such\
    \ base distribution URI may have the same\n      value).\n   EID Database Authority:\
    \  The authority that will sign database files\n      and updates.  It is the\
    \ source of both.\n   The Authority:  Shorthand for the EID Database Authority.\n\
    \   NERD:  Not-so-novel EID-to-RLOC Database.\n   AFI  Address Family Identifier.\n\
    \   Pull Model:  An architecture where clients pull only the information\n   \
    \   they need at any given time, such as when a packet arrives for\n      forwarding.\n\
    \   Push Model:  An architecture in which clients receive an entire\n      dataset,\
    \ containing data they may or may not require, such as\n      mappings for EIDs\
    \ that no host served is attempting to send to.\n   Hybrid Model:  An architecture\
    \ in which some information is pushed\n      toward the receiver from a source\
    \ and some information is pulled\n      by the receiver.\n"
- title: 2.  Theory of Operation
  contents:
  - "2.  Theory of Operation\n   Operational functions are split into two components:\
    \ database updates\n   and state exchange between ITR and ETR during a communication.\n"
- title: 2.1.  Database Updates
  contents:
  - "2.1.  Database Updates\n   What follows is a summary of how NERDs are generated\
    \ and updated.\n   Specifics can be found in Section 3.  The general way in which\
    \ NERD\n   works is as follows:\n   1.  A NERD is generated by an authority that\
    \ allocates Provider-\n       Independent (PI) addresses (e.g., IANA or a Regional\
    \ Internet\n       Registry (RIR)) that are used by sites as EIDs.  As part of\
    \ this\n       process, the authority generates a digest for the database and\n\
    \       signs it with a private key whose public key is part of an X.509\n   \
    \    certificate.  [ITU.X509.2000] That signature along with a copy of\n     \
    \  the authority's public key is included in the NERD.\n   2.  The NERD is distributed\
    \ to a group of well-known servers.\n   3.  ITRs retrieve an initial copy of the\
    \ NERD via HTTP when they come\n       into service.\n   4.  ITRs are preconfigured\
    \ with a group of certificates whose private\n       keys are used by database\
    \ authorities to sign the NERD.  This\n       list of certificates should be configurable\
    \ by administrators.\n   5.  ITRs next verify both the validity of the public\
    \ key and the\n       signed digest.  If either fail validation, the ITR attempts\
    \ to\n       retrieve the NERD from a different source.  The process iterates\n\
    \       until either a valid database is found or the list of sources is\n   \
    \    exhausted.\n   6.  Once a valid NERD is retrieved, the ITR installs it into\
    \ both\n       non-volatile and local memory.\n   7.  At some point, the authority\
    \ updates the NERD and increments the\n       database version counter.  At the\
    \ same time, it generates a list\n       of changes, which it also signs, as it\
    \ does with the original\n       database.\n   8.  Periodically, ITRs will poll\
    \ from their list of servers to\n       determine if a new version of the database\
    \ exists.  When a new\n       version is found, an ITR will attempt to retrieve\
    \ a change file,\n       using its list of preconfigured servers.\n   9.  The\
    \ ITR validates a change file just as it does the original\n       database. \
    \ Assuming the change file passes validation, the ITR\n       installs new entries,\
    \ overwrites existing ones, and removes empty\n       entries, based on the content\
    \ of the change file.\n   As time goes on, it is quite possible that an ITR may\
    \ probe a list of\n   configured peers for a database or change file copy.  It\
    \ is equally\n   possible that peers might advertise to each other the version\
    \ number\n   of their database.  Such methods are not explored in depth in this\n\
    \   memo but are mentioned for future consideration.\n"
- title: 2.2.  Communications between ITR and ETR
  contents:
  - "2.2.  Communications between ITR and ETR\n   [RFC6830] describes the basic approach\
    \ to what happens when a packet\n   arrives at an ITR, and what communications\
    \ between the ITR and ETR\n   take place.  NERD provides an optimistic approach\
    \ to establishing\n   communications with an ETR that is responsible for a given\
    \ EID-\n   Prefix.  State must be kept, however, on an ITR to determine whether\n\
    \   that ETR is in fact reachable.  It is expected that this is a common\n   requirement\
    \ across LISP mapping systems, and will be handled in the\n   core LISP architecture.\n"
- title: 2.3.  Who are database authorities?
  contents:
  - "2.3.  Who are database authorities?\n   This memo does not specify who the database\
    \ authority is.  That is\n   because there are several possible operational models.\
    \  In each case,\n   the number of database authorities is meant to be small so\
    \ that ITRs\n   need only keep a small list of authorities, similar to the way\
    \ a name\n   server might cache a list of root servers.\n   o  A single database\
    \ authority exists.  In this case, all entries in\n      the database are registered\
    \ to a single entity, and that entity\n      distributes the database.  Because\
    \ the EID space is provider-\n      independent address space, there is no architectural\
    \ requirement\n      that address space be hierarchically distributed to anyone,\
    \ as\n      there is with provider-assigned address space.  Hence, there is a\n\
    \      natural affinity between the IANA function and the database\n      authority\
    \ function.\n   o  Each region runs a database authority.  In this case, provider-\n\
    \      independent address space is allocated to either RIRs or to\n      affiliates\
    \ of such organizations of network operations guilds\n      (NOGs).  The benefit\
    \ of this approach is that there is no single\n      organization that controls\
    \ the database.  It allows one database\n      authority to back up another. \
    \ One could envision as many as ten\n      database authorities in this scenario.\
    \  One drawback to this\n      approach, however, is that any reference to a region\
    \ imposes a\n      notion of locality, thus potentially diminishing the split\
    \ between\n      Locator and identifier.\n   o  Each country runs a database authority.\
    \  This could occur should\n      countries decide to regulate this function.\
    \  While limiting the\n      scope of any single database authority as the previous\
    \ scenario\n      describes, this approach would introduce some overhead as the\
    \ list\n      of database authorities would grow to as many as 200, and possibly\n\
    \      more if jurisdictions within countries attempted to regulate the\n    \
    \  function.  There are two drawbacks to this approach.  First, as\n      distribution\
    \ of EIDs is driven to more local jurisdictions, an\n      EID-Prefix is tied\
    \ even more tightly to a location.  Second, a\n      large number of database\
    \ authorities will demand some sort of\n      discovery mechanism.\n   o  Independent\
    \ operators manage database authorities.  This has the\n      appeals of being\
    \ location independent and enabling competition for\n      good performance. \
    \ This method has the drawback of potentially\n      requiring a discovery mechanism.\n\
    \   The latter two approaches are not mutually exclusive.  While this\n   specification\
    \ allows for multiple databases, discovery mechanisms are\n   left as future work.\n"
- title: 3.  NERD Format
  contents:
  - "3.  NERD Format\n   The NERD consists of a header that contains a database version\
    \ and a\n   signature that is generated by ignoring the signature field and\n\
    \   setting the authentication block length to 0 (NULL).  The\n   authentication\
    \ block itself consists of a signature and a certificate\n   whose private-key\
    \ counterpart was used to generate the signature.\n   Records are kept sorted\
    \ in numeric order with AFI plus EID as primary\n   key and prefix length as secondary.\
    \  This is so that after a database\n   update it should be possible to reconstruct\
    \ the database to verify\n   the digest signature, which may be retrieved separately\
    \ from the\n   database for verification purposes.\n        0                \
    \   1                   2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       | Schema Vers=1 |  DB Code      |     Database Name Size        |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |                      Database Version                         |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \                   Old Database Version or 0                   |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |                                                               |\n  \
    \     |                        Database Name                          |\n    \
    \   |                                                               |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \       PKCS#7 Block Size       |          Reserved             |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |                                                               |\n  \
    \     |      PKCS#7 Block Containing Certificate and Signature        |\n    \
    \   |                                                               |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n        \
    \                      Database Header\n   The 'DB Code' field indicates 0 if\
    \ what follows is an entire database\n   or 1 if what follows is an update.  The\
    \ 'Database Version' field\n   holds the database file version, which is incremented\
    \ each time the\n   complete database is generated by the authority.  In the case\
    \ of an\n   update, the field indicates the new database file version, and the\n\
    \   old database file version is indicated in the 'Old Database Version'\n   field.\
    \  The database file version is used by routers to determine\n   whether or not\
    \ they have the most current database.\n   The 'Database Name' field holds a DNS-ID,\
    \ as specified in [RFC6125].\n   This is the name that will appear in the Subject\
    \ field of the\n   certificate used to verify the database.  The purpose of the\
    \ database\n   name is to allow for more than one database.  Such databases would\
    \ be\n   merged by the router.  It is important that an EID-to-RLOC mapping be\n\
    \   listed in no more than one database, lest inconsistencies arise.\n   However,\
    \ it may be possible to transition a mapping from one database\n   to another.\
    \  During the transition period, the mappings would be\n   identical.  When they\
    \ are not, the resultant behavior will be\n   undefined.  The database name is\
    \ padded with NULLs to the nearest\n   fourth byte.\n   The PKCS#7 [RFC2315] authentication\
    \ block contains a DER-encoded\n   [ITU.X509.2000] signature and associated public\
    \ key.  For the\n   purposes of this experiment, all implementations will support\
    \ the RSA\n   encryption signature algorithm and SHA1 digest algorithm, and the\n\
    \   standard attributes are expected to be present.\n   N.B., it has been suggested\
    \ that the Cryptographic Message Syntax\n   (CMS) [RFC5652] be used instead of\
    \ PKCS#7.  At the time this\n   experiment was performed, CMS was not yet widely\
    \ deployed.  However,\n   it is certainly the correct direction and should be\
    \ strongly\n   considered in future related work.\n"
- title: 3.1.  NERD Record Format
  contents:
  - "3.1.  NERD Record Format\n   As distributed over the network, NERD records appear\
    \ as follows:\n        0                   1                   2             \
    \      3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       | Num. RLOCs    | EID Pref. Len  |           EID AFI            |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |                       Endpoint identifier                     |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \ Priority 1    |    Weight 1   |             AFI 1             |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |                       Routing Locator 1                       |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   | Priority 2    |    Weight 2   |             AFI 2             |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \                       Routing Locator 2                       |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       | Priority 3    |    Weight 3   |             AFI 3             |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |                       Routing Locator 3...                    |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   EID AFI\
    \ is the AFI of the EID.  Priority N, Weight N, and AFI N are\n   associated with\
    \ Routing Locator N.  There will always be at least one\n   RLOC.  The minimum\
    \ record size for IPv4 is 16 bytes.  Each additional\n   IPv4 RLOC increases the\
    \ record size by 8 bytes.  The purpose of this\n   format is to keep the database\
    \ compact, but somewhat easily read.\n   The meaning of weight and priority are\
    \ described in [RFC6830].  The\n   format of the AFI is specified by IANA in the\
    \ \"Address Family\n   Numbers\" registry, with the exception of how IPv6 EID-Prefixes\
    \ are\n   stored.\n   NERD assumes that EIDs stored in the database are prefixes,\
    \ and\n   therefore are accompanied with prefix lengths.  In order to reduce\n\
    \   storage and transmission amounts for IPv6, only the necessary number\n   of\
    \ bytes of an EID as specified by the prefix length are kept in the\n   record,\
    \ rounded to the nearest 4-byte (word) boundary.  For instance,\n   if the prefix\
    \ length is /49, the nearest 4-byte word boundary would\n   require that 8 bytes\
    \ are stored.  IPv6 RLOCs are represented as\n   normal 128-bit IPv6 addresses.\n"
- title: 3.2.  Database Update Format
  contents:
  - "3.2.  Database Update Format\n   A database update contains a set of changes\
    \ to an existing database.\n   Each {AFI, EID, mask-length} tuple may have zero\
    \ or more RLOCs\n   associated with it.  In the case where there are no RLOCs,\
    \ the EID\n   entry is removed from the database.  Records that contain EIDs and\n\
    \   prefix lengths that were not previously listed are simply added.\n   Otherwise,\
    \ the old record for the EID and prefix length is replaced\n   by the more current\
    \ information.  The record format used by the\n   database update is the same\
    \ as described in Section 3.1.\n"
- title: 4.  NERD Distribution Mechanism
  contents:
  - '4.  NERD Distribution Mechanism

    '
- title: 4.1.  Initial Bootstrap
  contents:
  - "4.1.  Initial Bootstrap\n   Bootstrap occurs when a router needs to retrieve\
    \ the entire database.\n   It knows it needs to retrieve the entire database because\
    \ either it\n   has none or it has an update too substantial to process, as might\
    \ be\n   the case if a router has been out of service for a substantially\n  \
    \ lengthy period of time.\n   To bootstrap, the ITR appends the database name\
    \ plus \"/current/\n   entiredb\" to a base distribution URI and retrieves the\
    \ file via HTTP.\n   More formally (using ABNF from [RFC5234]):\n      entire-db\
    \ =    base-uri dbname \"/current/entiredb\"\n      base-uri  =    uri ; from\
    \ RFC 3986\n      dbname    =    DNS-ID ; from RFC 6125\n   For example, if the\
    \ base distribution URI is\n   \"http://www.example.com/eiddb/\", and assuming\
    \ a database name of\n   \"nerd.arin.net\", the ITR would request\n   \"http://www.example.com/eiddb/nerd.arin.net/current/entiredb\"\
    .\n   Routers check the signature on the database prior to installing it,\n  \
    \ and they check that the database schema matches a schema they\n   understand.\
    \  Once a router has a valid database, it stores that\n   database in some sort\
    \ of non-volatile memory (e.g., disk, flash\n   memory, etc).\n   N.B., the host\
    \ component for such URIs should not resolve to a LISP\n   EID, lest a circular\
    \ dependency be created.\n"
- title: 4.2.  Retrieving Changes
  contents:
  - "4.2.  Retrieving Changes\n   In order to retrieve a set of database changes,\
    \ an ITR will have\n   previously retrieved the entire database.  Hence, it knows\
    \ the\n   current version of the database it has.  Its first step for\n   retrieving\
    \ changes is to retrieve the current version number of the\n   database.  It does\
    \ so by appending \"/current/version\" to the base\n   distribution URI and database\
    \ name and retrieving the file.  Its\n   format is text, and it contains the integer\
    \ value of the current\n   database version.\n   Once an ITR has retrieved the\
    \ current version, it compares the\n   version of its local copy.  If there is\
    \ no difference, then the\n   router is up to date and need take no further actions\
    \ until it next\n   checks.\n   If the versions differ, the router next sends\
    \ a request for the\n   appropriate change file by appending \"current/changes/\"\
    \ and the\n   textual representation of the version of its local copy of the\n\
    \   database to the base distribution URI.  More formally:\n      db-version \
    \   =    base-uri dbname \"/current/version\"\n      db-curupdate  =    base-uri\
    \ dbname \"/current/changes/\" old-version\n      old-version   =    1*DIGIT\n\
    \   For example, if the current version of the database is 1105503, the\n   router's\
    \ version is 1105500, and the base URI and database name are\n   the same as above,\
    \ the router would first request\n   \"http://www.example.com/eiddb/nerd.arin.net/current/version\"\
    \ to\n   determine that it is out of date, and also to learn the current\n   version.\
    \  It would then attempt to retrieve\n   \"http://www.example.com/eiddb/nerd.arin.net/current/changes/1105500\"\
    .\n   The server may not have that change file, either because there are\n   too\
    \ many versions between what the router has and what is current or\n   because\
    \ no such change file was generated.  If the server has changes\n   from the router's\
    \ version to any later version, the server issues an\n   HTTP redirect to that\
    \ change file, and the router retrieves and\n   processes it.  More formally:\n\
    \      db-incupdate    =    base-uri dbname \"/\" newer-version\n            \
    \               \"/changes/\" old-version\n      newer-version   =    1*DIGIT\n\
    \   For example:\n   \"http://www.example.com/eiddb/nerd.arin.net/1105450/changes/1105401\"\
    \n   would update a router from version 1105401 to 1105450.  Once it has\n   done\
    \ so, the router should then repeat the process until it has\n   brought itself\
    \ up to date.\n   This begs the question: how does a router know to retrieve version\n\
    \   1105450 in our example above?  It cannot.  A redirect must be given\n   by\
    \ the server to that URI when the router attempts to retrieve\n   differences\
    \ from the current version, say, 1105503.\n   While it is unlikely that database\
    \ versions would wrap, as they\n   consist of 32-bit integers, should the event\
    \ occur, ITRs should\n   attempt first to retrieve a change file when their current\
    \ version\n   number is within 10,000 of 2^32 and they see a version available\
    \ that\n   is less than 10,000.  Barring the availability of a change file, the\n\
    \   ITR can still assume that the database version has wrapped and\n   retrieve\
    \ a new copy.  It may be safer in future work to include\n   additional wrap information\
    \ or a larger field to avoid having to use\n   any heuristics.\n"
- title: 5.  Analysis
  contents:
  - "5.  Analysis\n   We will start our analysis by looking at how much data will\
    \ be\n   transferred to a router during bootstrap conditions.  We will then\n\
    \   look at the bandwidth required.  Next, we will turn our concerns to\n   servers.\
    \  Finally, we will ponder the effect of providing only\n   changes.\n   In the\
    \ analysis below, we treat the overhead of the database header\n   as insignificant\
    \ (because it is).  The analysis should be similar,\n   whether a single database\
    \ or multiple databases are employed, as we\n   would assume that no entry would\
    \ appear more than once.\n"
- title: 5.1.  Database Size
  contents:
  - "5.1.  Database Size\n   By its very nature, the information to be transported\
    \ is relatively\n   static and is specifically designed to be topologically insensitive.\n\
    \   That is, every ITR is intended to have the same set of RLOCs for a\n   given\
    \ EID.  While some processing power will be necessary to install\n   a table,\
    \ the amount required should be far less than that of a\n   routing information\
    \ database because the level of entropy is intended\n   to be lower.\n   For purposes\
    \ of this analysis, we will assume that the world has\n   migrated to IPv6, as\
    \ this increases the size of the database, which\n   would be our primary concern.\
    \  However, to mitigate the size\n   increase, we have limited the size of the\
    \ prefix transmitted.  For\n   purposes of this analysis, we shall assume an average\
    \ prefix length\n   of 64 bits.\n   Based on that assumption, Section 3.1 states\
    \ that mapping information\n   for each EID/prefix includes a group of RLOCs,\
    \ each with an\n   associated priority and weight, and that a minimum record size\
    \ with\n   IPv6 EIDs with at least one RLOC is 30 bytes uncompressed.  Each\n\
    \   additional IPv6 RLOC costs 20 bytes.\n                 +-----------+--------+--------+---------+\n\
    \                 | 10^n EIDs | 2 RLOC | 4 RLOC |  8 RLOC |\n                \
    \ +-----------+--------+--------+---------+\n                 |         4 | 500\
    \ KB | 900 KB | 1.70 MB |\n                 |         5 | 5.0 MB | 9.0 MB | 17.0\
    \ MB |\n                 |         6 |  50 MB |  90 MB |  170 MB |\n         \
    \        |         7 | 500 MB | 900 MB | 1.70 GB |\n                 |       \
    \  8 | 5.0 GB | 9.0 GB | 17.0 GB |\n                 +-----------+--------+--------+---------+\n\
    \   Table 1: Database size for IPv6 routes with average prefix length of\n   \
    \                               64 bits\n   Entries in the above table are derived\
    \ as follows:\n        E * (30 + 20 * (R - 1 ))\n   where E = number of EIDs (10^n),\
    \ R = number of RLOCs per EID.\n   Our scaling target is to accommodate 10^8 multihomed\
    \ systems, which\n   is one order of magnitude greater than what is discussed\
    \ in [CARP07].\n   At 10^8 entries, a device could be expected to use between\
    \ 5 and 17\n   GB of RAM for the mapping.  No matter the method of distribution,\
    \ any\n   router that sits in the core of the Internet would require near this\n\
    \   amount of memory in order to perform the ITR function.  Large-\n   enterprise\
    \ ETRs would be similarly strained, simply due to the\n   diversity of sites that\
    \ communicate with one another.  The good news\n   is that this is not our starting\
    \ point, but rather our scaling\n   target, a number that we intend to reach by\
    \ the year 2050.  Our\n   starting point is more likely in the neighborhood of\
    \ 10^4 or 10^5\n   EIDs, thus requiring between 500 KB and 17 MB.\n"
- title: 5.2.  Router Throughput versus Time
  contents:
  - "5.2.  Router Throughput versus Time\n       +-------------------+---------+---------+----------+--------+\n\
    \       | Table Size (10^n) |  1 MB/s | 10 MB/s | 100 MB/s | 1 GB/s |\n      \
    \ +-------------------+---------+---------+----------+--------+\n       |    \
    \             6 |       8 |     0.8 |     0.08 |  0.008 |\n       |          \
    \       7 |      80 |       8 |      0.8 |   0.08 |\n       |                \
    \ 8 |     800 |      80 |        8 |    0.8 |\n       |                 9 |  \
    \ 8,000 |     800 |       80 |      8 |\n       |                10 |  80,000\
    \ |   8,000 |      800 |     80 |\n       |                11 | 800,000 |  80,000\
    \ |    8,000 |    800 |\n       +-------------------+---------+---------+----------+--------+\n\
    \                Table 2: Number of seconds to process NERD\n   The length of\
    \ time it takes to receive the database is significant in\n   models where the\
    \ device acquires the entire table.  During this\n   period of time, either the\
    \ router will be unable to route packets\n   using LISP or it must use some sort\
    \ of query mechanism for specific\n   EIDs as it populates the rest of its table\
    \ through the transfer.\n   Table 2 shows us that at our scaling target, the length\
    \ of time it\n   would take for a router using 1 MB/s of bandwidth is about 80\n\
    \   seconds.  We can measure the processing rate in small numbers of\n   hours\
    \ for any transfer speed greater than that.  The fastest\n   processing time shows\
    \ us as taking 8 seconds to process an entire\n   table of 10^9 bytes and 80 seconds\
    \ for 10^10 bytes.\n"
- title: 5.3.  Number of Servers Required
  contents:
  - "5.3.  Number of Servers Required\n   As easy as it may be for a router to retrieve,\
    \ the aggregate\n   information may be difficult for servers to transmit, assuming\
    \ the\n   information is transmitted in aggregate (we'll revisit that\n   assumption\
    \ later).\n   +----------------+------------+-----------+------------+------------+\n\
    \   | # Simultaneous | 10 Servers |       100 |      1,000 |     10,000 |\n  \
    \ |       Requests |            |   Servers |    Servers |    Servers |\n   +----------------+------------+-----------+------------+------------+\n\
    \   |            100 |        720 |        72 |         72 |         72 |\n  \
    \ |          1,000 |      7,200 |       720 |         72 |         72 |\n   |\
    \         10,000 |     72,000 |     7,200 |        720 |         72 |\n   |  \
    \      100,000 |    720,000 |    72,000 |      7,200 |        720 |\n   |    \
    \  1,000,000 |  7,200,000 |   720,000 |     72,000 |      7,200 |\n   |     10,000,000\
    \ | 72,000,000 | 7,200,000 |    720,000 |     72,000 |\n   +----------------+------------+-----------+------------+------------+\n\
    \         Table 3: Retrieval time per number of servers in seconds\n   This assumes\
    \ an average of 10^8 entries with 4 RLOCs per EID and that\n   each server has\
    \ access to 1 GB/s, 100% efficient use of that\n   bandwidth, and no compression.\n\
    \   Entries in the above table were generated using the following method:\n  \
    \ For 10^8 entries with four RLOCs per EID, the table size is 9.0 GB,\n   per\
    \ our previous table.  Assume 1 GB/s transfer rates and 100%\n   utilization.\
    \  Protocol overhead is ignored for this exercise.  Hence,\n   a single transfer\
    \ X takes 48 seconds and can get no faster.\n   With this in mind, each entry\
    \ is as follows:\n            max(1X,N*X/S)\n     where N = number of transfers,\n\
    \           X = 72 seconds, and\n           S = number of servers.\n   If we have\
    \ a distribution model in which every device must retrieve\n   the mapping information\
    \ upon start, Table 3 shows the length of time\n   in seconds it will take for\
    \ a given number of servers to complete a\n   transfer to a given number of devices.\
    \  This table says, as an\n   example, that it would take 72,000 seconds (20 hours)\
    \ for 1,000,000\n   ITRs to simultaneously retrieve the database from 1,000 servers,\n\
    \   assuming equal load distribution.  Should a cold-start scenario\n   occur,\
    \ this number should be of some concern.  Hence, it is important\n   to take some\
    \ measures both to avoid such a scenario and to ease the\n   load should it occur.\
    \  The primary defense should be for ITRs to\n   first attempt to retrieve their\
    \ databases from their peers or\n   upstream providers.  Secondary defenses could\
    \ include data sanity\n   checks within ITRs, with agreed norms for how much the\
    \ database\n   should change in any given update or over any given period of time.\n\
    \   As we will see below, dissemination of changes is considerably less\n   volume.\n\
    \     +----------------+-------------+---------------+----------------+\n    \
    \ | % Daily Change | 100 Servers | 1,000 Servers | 10,000 Servers |\n     +----------------+-------------+---------------+----------------+\n\
    \     |           0.1% |         300 |            30 |              3 |\n    \
    \ |           0.5% |       1,500 |           150 |             15 |\n     |  \
    \           1% |       3,000 |           300 |             30 |\n     |      \
    \       5% |      15,000 |         1,500 |            150 |\n     |          \
    \  10% |      30,000 |         3,000 |            300 |\n     +----------------+-------------+---------------+----------------+\n\
    \       Table 4: Transfer times for hourly updates, shown in seconds\n   Assuming\
    \ 10 million routers and a database size of 9 GB, resulting\n   transfer times\
    \ for hourly updates are shown in seconds, given number\n   of servers and daily\
    \ rate of change.  Note that when insufficient\n   resources are devoted to servers,\
    \ an unsustainable situation arises\n   where updates for the next batch would\
    \ begin prior to the completion\n   of the current batch.\n   This table shows\
    \ us that with 10,000 servers the average transfer\n   time with 1 GB/s links\
    \ for 10,000,000 routers will be 300 seconds\n   with 10% daily change spread\
    \ over 24 hourly updates.  For a 0.1%\n   daily change, that number is 3 seconds\
    \ for a database of size 9.0 GB.\n   The amount of change goes to the purpose\
    \ of LISP.  If its purpose is\n   to provide effective multihoming support to\
    \ end customers, then we\n   might anticipate relatively few changes.  If, on\
    \ the other hand,\n   service providers attempt to make use of LISP to provide\
    \ some form of\n   traffic engineering, we can expect the same data to change\
    \ more\n   often.  We cannot conclude much in this regard without additional\n\
    \   operational experience.  The one thing we can say is that different\n   applications\
    \ of LISP may require new and different distribution\n   mechanisms.  Such optimization\
    \ is left for another day.\n"
- title: 5.4.  Security Considerations
  contents:
  - "5.4.  Security Considerations\n   If an attacker can forge an update or tamper\
    \ with the database, he\n   can in effect redirect traffic to end sites.  Hence,\
    \ integrity and\n   authenticity of the NERD is critical.  In addition, a means\
    \ is\n   required to determine whether a source is authorized to modify a\n  \
    \ given database.  No data privacy is required.  Quite to the contrary,\n   this\
    \ information will be necessary for any ITR.\n   The first question one must ask\
    \ is who to trust to provide the ITR a\n   mapping.  Ultimately, the owner of\
    \ the EID-Prefix is most\n   authoritative for the mapping to RLOCs.  However,\
    \ were all owners to\n   sign all such mappings, ITRs would need to know which\
    \ owner is\n   authorized to modify which mapping, creating a problem of O(N^2)\n\
    \   complexity.\n   We can reduce this problem substantially by investing some\
    \ trust in a\n   small number of entities that are allowed to sign entries.  If\
    \ an\n   authority manages EIDs much the same way a domain name registrar\n  \
    \ handles domains, then the owner of the EID would choose a database\n   authority\
    \ she or he trusts, and ITRs must trust each such authority\n   in order to map\
    \ the EIDs listed by that authority to RLOCs.  This\n   reduces the amount of\
    \ management complexity on the ETR to retaining\n   knowledge of O(# authorities),\
    \ but does require that each authority\n   establish procedures for authenticating\
    \ the owner of an EID.  Those\n   procedures needn't be the same.\n   There are\
    \ two classic methods to ensure integrity of data:\n   o  secure transport of\
    \ the source of the data to the consumer, such\n      as Transport Layer Security\
    \ (TLS) [RFC5246]; and\n   o  provide object-level security.\n   These methods\
    \ are not mutually exclusive, although one can argue\n   about the need for the\
    \ former, given the latter.\n   In the case of TLS, when it is properly implemented,\
    \ the objects\n   being transported cannot easily be modified by interlopers or\
    \ so-\n   called men in the middle.  When data objects are distributed to\n  \
    \ multiple servers, each of those servers must be trusted.  As we have\n   seen\
    \ above, we could have quite a large number of servers, thus\n   providing an\
    \ attacker a large number of targets.  We conclude that\n   some form of object-level\
    \ security is required.\n   Object-level security involves an authority signing\
    \ an object in a\n   way that can easily be verified by a consumer, e.g., a router.\
    \  In\n   this case, we would want the mapping table and any incremental update\n\
    \   to be signed by the originator of the update.  This implies that we\n   cannot\
    \ simply make use of a tool like CVS [CVS].  Instead, the\n   originator will\
    \ want to generate diffs, sign them, and make them\n   available either directly\
    \ or through some sort of content\n   distribution or peer to peer network.\n"
- title: 5.4.1.  Use of Public Key Infrastructures (PKIs)
  contents:
  - "5.4.1.  Use of Public Key Infrastructures (PKIs)\n   X.509 provides a certificate\
    \ hierarchy that has scaled to the size of\n   the Internet.  The system is most\
    \ manageable when there are few\n   certificates to manage.  The model proposed\
    \ in this memo makes use of\n   one current certificate per database authority.\
    \  The two pieces of\n   information necessary to verify a signature, therefore,\
    \ are as\n   follows:\n   o  the certificate of the database authority, which\
    \ can be provided\n      along with the database; and\n   o  the certificate authority's\
    \ certificate.\n   The latter two pieces of information must be very well known\
    \ and must\n   be configured on each ITR.  It is expected that both would change\n\
    \   very rarely, and it would not be unreasonable for such updates to\n   occur\
    \ as part of a normal OS release process.\n   The tools for both signing and verifying\
    \ are readily available.\n   OpenSSL (http://www.openssl.org) provides tools and\
    \ libraries for\n   both signing and verifying.  Other tools commonly exist.\n\
    \   Use of PKIs is not without implementation complexity, operational\n   complexity,\
    \ or risk.  The following risks and mitigations are\n   identified with NERD's\
    \ use of PKIs:\n   The private key of a NERD authority is exposed:\n      In this\
    \ case, an attacker could sign a false database update,\n      either redirecting\
    \ traffic or otherwise causing havoc.  The NERD\n      administrator must revoke\
    \ its existing key and issue a new one.\n      The certificate is added to a certificate\
    \ revocation list (CRL),\n      which may be distributed with both this and other\
    \ databases, as\n      well as through other channels.  Because this event is\
    \ expected to\n      be rare, and the number of database authorities is expected\
    \ to be\n      small, a CRL will be small.  When a router receives a revocation,\n\
    \      it checks it against its existing databases, and attempts to\n      update\
    \ the one that is revoked.  This implies that prior to\n      issuing the revocation,\
    \ the database authority would sign an\n      update with the new key.  Routers\
    \ would discard updates they have\n      already received that were signed after\
    \ the revocation was\n      generated.  If a router cannot confirm whether the\
    \ authority's\n      certificate was revoked before or after a particular update,\
    \ it\n      will retrieve a fresh new copy of the database with a valid\n    \
    \  signature.\n   The private key associated with a CA in the chain of trust of\
    \ the\n      Authority's certificate is compromised:\n      In this case, it becomes\
    \ possible for an attacker to masquerade as\n      the database authority.  To\
    \ ameliorate damage, the database\n      authority revokes its certificate and\
    \ get a new certificate issued\n      from a CA that is not compromised.  Once\
    \ it has done so, the\n      previous procedure is followed.  The compromised\
    \ certificate can\n      be removed during the normal OS upgrade cycle.  In the\
    \ case of the\n      root authority, the situation could be more serious.  Updates\
    \ to\n      the OS in the ITR need to be validated prior to installation.  One\n\
    \      possible method of doing this is provided in [RFC4108].  Trust\n      anchors\
    \ are assumed to be updated as part of an OS update;\n      implementors should\
    \ consider using a key other than the trust\n      anchor for validating OS updates.\n\
    \   An algorithm used if either the certificate or the signature is\n      cracked:\n\
    \      This is a catastrophic failure and the above forms of attack\n      become\
    \ possible.  The only mitigation is to make use of a new\n      algorithm.  In\
    \ theory, this should be possible, but in practice it\n      has proved very difficult.\
    \  For this reason, additional work is\n      recommended to make alternative\
    \ algorithms available.\n   The NERD authority loses its key or disappears:\n\
    \      In this case, nobody can update the existing database.  There are\n   \
    \   few programmatic mitigations.  If the database authority places\n      its\
    \ private keys and suitable amounts of information in escrow,\n      under agreed\
    \ upon circumstances (for example, no updates for three\n      days), the escrow\
    \ agent would release the information to a party\n      competent of generating\
    \ a database update.\n"
- title: 5.4.2.  Other Risks
  contents:
  - "5.4.2.  Other Risks\n   Because this specification does not require secure transport,\
    \ if an\n   attacker prevents updates to an ITR for the purposes of having that\n\
    \   ITR continue to use a compromised ETR, the ITR could continue to use\n   an\
    \ old version of the database without realizing a new version has\n   been made\
    \ available.  If one is worried about such an attack, a\n   secure channel (such\
    \ as SSL) to a secure chain back to the database\n   authority should be used.\
    \  It is possible that, after some\n   operational experience, later versions\
    \ of this format will contain\n   additional semantics to address this attack.\
    \  SSL would also prevent\n   attempts to spoof false database versions on the\
    \ server.\n   As discussed above, substantial risk would be a cold-start scenario.\n\
    \   If an attacker found a bug in a common OS that allowed it to erase an\n  \
    \ ITR's database, and was able to disseminate that bug, the collective\n   ability\
    \ of ITRs to retrieve new copies of the database could be taxed\n   by collective\
    \ demand.  The remedy to this is for devices to share\n   copies of the database\
    \ with their peers, thus making each potential\n   requester a potential service.\n"
- title: 6.  Why not use XML?
  contents:
  - "6.  Why not use XML?\n   Many objects these days are distributed as either XML\
    \ pages or\n   something derived as XML [W3C.REC-xml11-20040204], such as SOAP\n\
    \   [W3C.REC-soap12-part1-20070427] [W3C.REC-soap12-part2-20070427].  Use\n  \
    \ of such well-known standards allows for high-level tools and library\n   reuse.\
    \  XML's strength is extensibility.  Without a doubt XML would\n   be more extensible\
    \ than a fixed field database.  Why not, then, use\n   these standards in this\
    \ case?  The greatest concern the author had\n   was compactness of the data stream.\
    \  In as much as this mechanism is\n   used at all in the future, so long as that\
    \ concern could be\n   addressed, and so long as signatures of the database can\
    \ be verified,\n   XML probably should be considered.\n"
- title: 7.  Other Distribution Mechanisms
  contents:
  - "7.  Other Distribution Mechanisms\n   We now consider various different mechanisms.\
    \  The problem of\n   distributing changes in various databases is as old as databases.\n\
    \   The author is aware of two obvious approaches that have been well\n   used\
    \ in the past.  One approach would be the wide distribution of CVS\n   repositories.\
    \  However, for reasons mentioned in Section 5.4, CVS is\n   insufficient to the\
    \ task.\n   The other tried and true approach is the use of periodic updates in\n\
    \   the form of messages.  The good old Network News Transfer Protocol\n   (NNTP)\
    \ [RFC3977] itself provides two separate mechanisms (one push\n   and another\
    \ pull) to provide a coherent update process.  This was in\n   fact used to update\
    \ molecular biology databases [gb91] in the early\n   1990s.  Netnews offers a\
    \ way to determine whether articles with\n   specified Article-Ids have been received.\
    \  In the case where the\n   mapping file source of authority wishes to transmit\
    \ updates, it can\n   sign a change file and then post it into the network.  Routers\
    \ merely\n   need to keep a record of article ids that it has received.  Netnews\n\
    \   systems have years ago handled far greater volume of traffic than we\n   envision\
    \ [Usenet].  Initially this is probably overkill, but it may\n   not be so later\
    \ in this process.  Some consideration should be given\n   to a mechanism known\
    \ to widely distribute vast amounts of data, as\n   instantaneously as either\
    \ the sender or the receiver wishes.\n   To attain an additional level of hierarchy\
    \ in the distribution\n   network, service providers could retrieve information\
    \ to their own\n   local servers and configure their routers with the host portion\
    \ of\n   the above URI.\n   Another possibility would be for providers to establish\
    \ an agreement\n   on a small set of anycast addresses for use for this purpose.\
    \  There\n   are limitations to the use of anycast, particularly with TCP.  In\
    \ the\n   midst of a routing flap, an anycast address can become all but\n   unusable.\
    \  Careful study of such a use as well as appropriate use of\n   HTTP redirects\
    \ is expected.\n"
- title: 7.1.  What about DNS as a mapping retrieval model?
  contents:
  - "7.1.  What about DNS as a mapping retrieval model?\n   It has been proposed that\
    \ a query/response mechanism be used for this\n   information and specifically\
    \ that the Domain Name System (DNS)\n   [RFC1034] be used.  The previous models\
    \ do not preclude DNS.  DNS has\n   the advantage that the administrative lines\
    \ are well drawn, and that\n   the ID-to-RLOC mapping is likely to appear very\
    \ close to these\n   boundaries.  DNS also has the added benefit that an entire\n\
    \   distribution infrastructure already exists.  There are, however, some\n  \
    \ problems that could impact end hosts when intermediate routers make\n   queries,\
    \ some of which were first pointed out in [RFC1383]:\n   o  Any query mechanism\
    \ offers an opportunity for a resource attack if\n      an attacker can force\
    \ the ITR to query for information.  In this\n      case, all that would be necessary\
    \ would be for a \"botnet\" (a group\n      of computers that have been compromised\
    \ and used as vehicles to\n      attack others) to ping or otherwise contact via\
    \ some normal\n      service hosts that sit behind the ETR.  If the botnet hosts\n\
    \      themselves are behind ETRs, the victim's ITR will need to query\n     \
    \ for each and every one of them, thus becoming part of a classic\n      reflector\
    \ attack.\n   o  Packets will be delayed at the very least, and probably dropped\
    \ in\n      the process of a mapping query.  This could be at the beginning of\n\
    \      a communication, but it will be impossible for a router to\n      conclude\
    \ with certainty that this is the case.\n   o  The DNS has a backoff algorithm\
    \ that presumes that applications\n      are making queries prior to the beginning\
    \ of a communication.\n      This is appropriate for end hosts who know in fact\
    \ when a\n      communication begins.  An end user may not enjoy that a router\
    \ is\n      waiting seconds for a retry.\n   o  While the administrative lines\
    \ may appear to be correct, the\n      location of name servers may not be.  If\
    \ name servers sit within\n      PI address space, thus requiring LISP to reach,\
    \ a circular\n      dependency is created.  This is precisely where many enterprise\n\
    \      name servers sit.  The LISP experiment should not predicate its\n     \
    \ success on relocation of such name servers.\n   Nevertheless, DNS may be able\
    \ to play a role in providing the\n   enterprise control over the mapping of its\
    \ EIDs to RLOCs.  Posit a\n   new DNS record \"EID2RLOC\".  This record is used\
    \ by the authority to\n   collect and aggregate mapping information so that it\
    \ may be\n   distributed through one of the other mechanisms.  As an example:\n\
    \      $ORIGIN 0.10.PI-SPACE.\n       128   EID2RLOC   mask 23 priority 10 weight\
    \ 5 172.16.5.60\n             EID2RLOC   mask 23 priority 15 weight 5 192.168.1.5\n\
    \   In the above figure, network 10.0.128/23 would delegated to some end\n   system,\
    \ say, EXAMPLE.COM.  They would manage the above zone\n   information.  This would\
    \ allow a DNS mechanism to work, but it would\n   also allow someone to aggregate\
    \ the information and distribute a\n   table.\n"
- title: 7.2.  Use of BGP and LISP+ALT
  contents:
  - "7.2.  Use of BGP and LISP+ALT\n   The Border Gateway Protocol (BGP) [RFC4271]\
    \ is currently used to\n   distribute inter-domain routing throughout the Internet.\
    \  Why not,\n   then, use BGP to distribute mapping entries, or provide a rendezvous\n\
    \   mechanism to initialize mapping entries?  In fact, this is precisely\n   what\
    \ LISP Alternative Topology (LISP+ALT) [RFC6836] accomplishes,\n   using a completely\
    \ separate topology from the normal DFZ.  It does so\n   using existing code paths\
    \ and expertise.  The alternative topology\n   also provides an extremely accurate\
    \ control path from ITRs to ETRs,\n   whereas NERD's operational model requires\
    \ an optimistic assumption\n   and control-plane functionality to cycle through\
    \ unresponsive ETRs in\n   an EID-Prefix's mapping entry.  The memory-scaling\
    \ characteristics of\n   LISP+ALT are extremely attractive because of expected\
    \ strong\n   aggregation, whereas NERD makes almost no attempt at aggregation.\n\
    \   A number of key deployment issues are left open.  The principle issue\n  \
    \ is whether it is deemed acceptable for routers to drop packets\n   occasionally\
    \ while mapping information is being gathered.  This\n   should be the subject\
    \ of future research for ALT, as it was a key\n   design goal of NERD to avoid\
    \ such a situation.\n"
- title: 7.3.  Perhaps use a hybrid model?
  contents:
  - "7.3.  Perhaps use a hybrid model?\n   Perhaps it would be useful to use both\
    \ a prepopulated database such\n   as NERD and a query mechanism (perhaps LISP+ALT,\
    \ LISP-CONS\n   [LISP-CONS], or DNS) to determine an EID-to-RLOC mapping.  One\
    \ idea\n   would be to receive a subset of the mappings, say, by taking only the\n\
    \   NERD for certain regions.  This alleviates the need to drop packets\n   for\
    \ some subset of destinations under the assumption that one's\n   business is\
    \ localized to a particular region.  If one did not have a\n   local entry for\
    \ a particular EID, one would then make a query.\n   One approach to using DNS\
    \ to query live would be to periodically walk\n   \"interesting\" portions of\
    \ the network, in search of relevant records,\n   and to cache them to non-volatile\
    \ storage.  While preventing resource\n   attacks, the walk itself could be viewed\
    \ as an attack, if the\n   algorithm was not selective enough about what it thought\
    \ was\n   interesting.  A similar approach could be applied to LISP+ALT or\n \
    \  LISP-CONS by forcing a data-driven Map Reply for certain sites.\n"
- title: 8.  Deployment Issues
  contents:
  - "8.  Deployment Issues\n   While LISP and NERD are intended as experiments at\
    \ this point, it is\n   already obvious one must give serious consideration to\
    \ circular\n   dependencies with regard to the protocols used and the elements\n\
    \   within them.\n"
- title: 8.1.  HTTP
  contents:
  - "8.1.  HTTP\n   In as much as HTTP depends on DNS, either due to the authority\n\
    \   section of a URI or to the configured base distribution URI, these\n   same\
    \ concerns apply.  In addition, any HTTP server that itself makes\n   use of Provider-Independent\
    \ addresses would be a poor choice to\n   distribute the database for these exact\
    \ same reasons.\n   One issue with using HTTP is that it is possible that a middlebox\
    \ of\n   some form, such as a cache, may intercept and process requests.  In\n\
    \   some cases, this might be a good thing.  For instance, if a cache\n   correctly\
    \ returns a database, some amount of bandwidth is conserved.\n   On the other\
    \ hand, if the cache itself fails to function properly for\n   whatever reason,\
    \ end-to-end connectivity could be impaired.  For\n   example, if the cache itself\
    \ depended on the mapping being in place\n   and functional, a cold-start scenario\
    \ might leave the cache\n   functioning improperly, in turn providing routers\
    \ no means to update\n   their databases.  Some care must be given to avoid such\n\
    \   circumstances.\n"
- title: 9.  Open Questions
  contents:
  - "9.  Open Questions\n   Do we need to discuss reachability in more detail?  This\
    \ was clearly\n   an issue at the IST-RING (Information Science Technologies -\
    \ Routing\n   in Next Generation) workshop.  There are two key issues.  First,\
    \ what\n   is the appropriate architectural separation between the data plane\n\
    \   and the control plane?  Second, is there some specific way in which\n   NERD\
    \ impacts the data plane?\n   Should we specify a (perhaps compressed) tarball\
    \ that treads a middle\n   ground for the last question, where each update tarball\
    \ contains both\n   a signature for the update and for the entire database, once\
    \ the\n   update is applied?\n   Should we compress?  In some initial testing\
    \ of databases with 1, 5,\n   and 10 million IPv4 EIDs and a random distribution\
    \ of IPv4 RLOCs, the\n   current format in this document compresses down by a\
    \ factor of\n   between 35% and 36%, using Burrows-Wheeler block sorting text\n\
    \   compression algorithm (bzip2).  The NERD used random EIDs with prefix\n  \
    \ lengths varying from 19-29 bits, with probability weighted toward the\n   smaller\
    \ masks.  This only very roughly reflects reality.  A better\n   test would be\
    \ to start with the existing prefixes found in the DFZ.\n"
- title: 10.  Conclusions
  contents:
  - "10.  Conclusions\n   This memo has specified a database format, an update format,\
    \ a URI\n   convention, an update method, and a validation method for EID-to-RLOC\n\
    \   mappings.  We have shown that beyond the predictions of 10^8 EID-\n   prefix\
    \ entries, the aggregate database size would likely be at most\n   17 GB.  We\
    \ have considered the amount of servers to distribute that\n   information, and\
    \ we have demonstrated the limitations of a simple\n   content distribution network\
    \ and other well-known mechanisms.  The\n   effort required to retrieve a database\
    \ change amounts to between 3\n   and 30 seconds of processing time per hour at\
    \ today's gigabit speeds.\n   We conclude that there is no need for an off-box\
    \ query mechanism\n   today and that there are distinct disadvantages for having\
    \ such a\n   mechanism in the control plane.\n   Beyond this, we have examined\
    \ alternatives that allow for hybrid\n   models that do use query mechanisms,\
    \ should our operating assumptions\n   prove overly optimistic.  Use of NERD today\
    \ does not foreclose use of\n   such models in the future, and in fact both models\
    \ can happily\n   coexist.\n   Since the first draft of this document in 2007,\
    \ portions of this work\n   have been implemented.  Future work should consider\
    \ the size of\n   fields, such as the version field, as well as key roll-over\
    \ and\n   revocation issues.  As previously noted, CMS is now widely deployed.\n\
    \   Current work on DNS-based authentication of named entities [RFC6698]\n   may\
    \ provide a means to test authorization of a NERD provider to carry\n   a specific\
    \ prefix.\n   We leave to future work how the list of databases is distributed,\
    \ how\n   BGP can play a role in distributing knowledge of the databases, and\n\
    \   how DNS can play a role in aggregating information into these\n   databases.\n\
    \   We also leave to future work whether HTTP is the best protocol for\n   the\
    \ job, and whether the scheme described in this document is the\n   most efficient.\
    \  One could easily envision that when applied in high-\n   delay or high-loss\
    \ environments, a broadcast or multicast method may\n   prove more effective.\n\
    \   Speaking of multicast, we also leave to future work how multicast is\n   implemented,\
    \ if at all, either in conjunction or as an extension to\n   this model.\n   Finally,\
    \ perhaps the most interesting future work would be to\n   understand if and how\
    \ NERD could be integrated with the LISP mapping\n   server [RFC6833].\n"
- title: 11.  Acknowledgments
  contents:
  - "11.  Acknowledgments\n   Dino Farinacci, Patrik Faltstrom, Dave Meyer, Joel Halpern,\
    \ Jim\n   Schaad, Dave Thaler, Mohamed Boucadair, Robin Whittle, Max Pritikin,\n\
    \   Scott Brim, S. Moonesamy, and Stephen Farrel were very helpful with\n   their\
    \ reviews of this work.  Thanks also to the participants of the\n   Routing Research\
    \ Group and the IST-RING workshop held in Madrid in\n   December of 2007 for their\
    \ incisive comments.  The astute will notice\n   a lengthy References section.\
    \  This work stands on the shoulders of\n   many others' efforts.\n"
- title: 12.  References
  contents:
  - '12.  References

    '
- title: 12.1.  Normative References
  contents:
  - "12.1.  Normative References\n   [ITU.X509.2000]\n              International\
    \ Telecommunications Union, \"Information\n              technology - Open Systems\
    \ Interconnection - The Directory:\n              Public-key and attribute certificate\
    \ frameworks\",\n              ITU-T Recommendation X.509, ISO Standard 9594-8,\n\
    \              March 2000.\n   [RFC3986]  Berners-Lee, T., Fielding, R., and L.\
    \ Masinter, \"Uniform\n              Resource Identifier (URI): Generic Syntax\"\
    , STD 66,\n              RFC 3986, January 2005.\n   [RFC5234]  Crocker, D. and\
    \ P. Overell, \"Augmented BNF for Syntax\n              Specifications: ABNF\"\
    , STD 68, RFC 5234, January 2008.\n   [RFC6125]  Saint-Andre, P. and J. Hodges,\
    \ \"Representation and\n              Verification of Domain-Based Application\
    \ Service Identity\n              within Internet Public Key Infrastructure Using\
    \ X.509\n              (PKIX) Certificates in the Context of Transport Layer\n\
    \              Security (TLS)\", RFC 6125, March 2011.\n   [RFC6830]  Farinacci,\
    \ D., Fuller, V., Meyer, D., and D. Lewis, \"The\n              Locator/ID Separation\
    \ Protocol (LISP)\", RFC 6830,\n              January 2013.\n"
- title: 12.2.  Informative References
  contents:
  - "12.2.  Informative References\n   [CARP07]   Carpenter, B., \"IETF Plenary Presentation:\
    \ Routing and\n              Addressing: Where we are today\", March 2007.\n \
    \  [CVS]      Grune, R., Baalbergen, E., Waage, M., Berliner, B., and J.\n   \
    \           Polk, \"CVS: Concurrent Versions System\", November 1985.\n   [LISP-CONS]\n\
    \              Farinacci, D., Fuller, V., and D. Meyer, \"LISP-CONS: A\n     \
    \         Content distribution Overlay Network Service for LISP\",\n         \
    \     Work in Progress, April 2008.\n   [RFC1034]  Mockapetris, P., \"Domain names\
    \ - concepts and facilities\",\n              STD 13, RFC 1034, November 1987.\n\
    \   [RFC1383]  Huitema, C., \"An Experiment in DNS Based IP Routing\",\n     \
    \         RFC 1383, December 1992.\n   [RFC2315]  Kaliski, B., \"PKCS #7: Cryptographic\
    \ Message Syntax\n              Version 1.5\", RFC 2315, March 1998.\n   [RFC2616]\
    \  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,\n              Masinter,\
    \ L., Leach, P., and T. Berners-Lee, \"Hypertext\n              Transfer Protocol\
    \ -- HTTP/1.1\", RFC 2616, June 1999.\n   [RFC3977]  Feather, C., \"Network News\
    \ Transfer Protocol (NNTP)\",\n              RFC 3977, October 2006.\n   [RFC4108]\
    \  Housley, R., \"Using Cryptographic Message Syntax (CMS) to\n              Protect\
    \ Firmware Packages\", RFC 4108, August 2005.\n   [RFC4271]  Rekhter, Y., Li,\
    \ T., and S. Hares, \"A Border Gateway\n              Protocol 4 (BGP-4)\", RFC\
    \ 4271, January 2006.\n   [RFC5246]  Dierks, T. and E. Rescorla, \"The Transport\
    \ Layer Security\n              (TLS) Protocol Version 1.2\", RFC 5246, August\
    \ 2008.\n   [RFC5652]  Housley, R., \"Cryptographic Message Syntax (CMS)\", STD\
    \ 70,\n              RFC 5652, September 2009.\n   [RFC6698]  Hoffman, P. and\
    \ J. Schlyter, \"The DNS-Based Authentication\n              of Named Entities\
    \ (DANE) Transport Layer Security (TLS)\n              Protocol: TLSA\", RFC 6698,\
    \ August 2012.\n   [RFC6833]  Farinacci, D. and V. Fuller, \"Locator/ID Separation\n\
    \              Protocol (LISP) Map-Server Interface\", RFC 6833,\n           \
    \   January 2013.\n   [RFC6836]  Farinacci, D., Fuller, V., Meyer, D., and D.\
    \ Lewis,\n              \"Locator/ID Separation Protocol Alternative Logical\n\
    \              Topology (LISP+ALT)\", RFC 6836, January 2013.\n   [Usenet]   Wikipedia,\
    \ \"Usenet\", January 2013,\n              <http://en.wikipedia.org/w/index.php?\n\
    \              title=Usenet&oldid=531545312>.\n   [W3C.REC-soap12-part1-20070427]\n\
    \              Gudgin, M., Lafon, Y., Moreau, J., Hadley, M., Karmarkar,\n   \
    \           A., Mendelsohn, N., and H. Nielsen, \"SOAP Version 1.2 Part\n    \
    \          1: Messaging Framework (Second Edition)\", World Wide Web\n       \
    \       Consortium Recommendation REC-soap12-part1-20070427,\n              April\
    \ 2007,\n              <http://www.w3.org/TR/2007/REC-soap12-part1-20070427>.\n\
    \   [W3C.REC-soap12-part2-20070427]\n              Karmarkar, A., Hadley, M.,\
    \ Mendelsohn, N., Nielsen, H.,\n              Lafon, Y., Gudgin, M., and J. Moreau,\
    \ \"SOAP Version 1.2\n              Part 2: Adjuncts (Second Edition)\", World\
    \ Wide Web\n              Consortium Recommendation REC-soap12-part2-20070427,\n\
    \              April 2007,\n              <http://www.w3.org/TR/2007/REC-soap12-part2-20070427>.\n\
    \   [W3C.REC-xml11-20040204]\n              Cowan, J., Maler, E., Sperberg-McQueen,\
    \ C., Paoli, J.,\n              Bray, T., and F. Yergeau, \"Extensible Markup\
    \ Language\n              (XML) 1.1\", World Wide Web Consortium First\n     \
    \         Edition REC-xml11-20040204, February 2004,\n              <http://www.w3.org/TR/2004/REC-xml11-20040204>.\n\
    \   [gb91]     Smith, R., Gottesman, Y., Hobbs, B., Lear, E.,\n              Kristofferson,\
    \ D., Benton, D., and P. Smith, \"A mechanism\n              for maintaining an\
    \ up-to-date GenBank database via\n              Usenet\", Computer Applications\
    \ in the\n              Biosciences (CABIOS), April 1991.\n"
- title: Appendix A.  Generating and Verifying the Database Signature with
  contents:
  - "Appendix A.  Generating and Verifying the Database Signature with\n         \
    \    OpenSSL\n   As previously mentioned, one goal of NERD was to use off-the-shelf\n\
    \   tools to both generate and retrieve the database.  To many, PKI is\n   magic.\
    \  This section is meant to provide at least some clarification\n   as to both\
    \ the generation and verification process, complete with\n   command-line examples.\
    \  Not included is how you get the entries\n   themselves.  We'll assume they\
    \ exist and that you're just trying to\n   sign the database.\n   To sign the\
    \ database, to start with, you need a database file that\n   has a database header\
    \ described in Section 3.  Block size should be\n   zero, and there should be\
    \ no PKCS#7 block at this point.  You also\n   need a certificate and its private\
    \ key with which you will sign the\n   database.\n   The OpenSSL \"smime\" command\
    \ contains all the functions we need from\n   this point forth.  To sign the database,\
    \ issue the following command:\n         openssl smime -binary -sign -outform\
    \ DER -signer yourcert.crt \\\n                 -inkey yourcert.key -in database-file\
    \ -out signature\n   -binary states that no MIME canonicalization should be performed.\n\
    \   -sign indicates that you are signing the file that was given as the\n   argument\
    \ to -in.  The output format (-outform) is binary DER, and\n   your public certificate\
    \ is provided with -signer along with your key\n   with -inkey.  The signature\
    \ itself is specified with -out.\n   The resulting file \"signature\" is then\
    \ copied into to PKCS#7 block in\n   the database header, its size in bytes is\
    \ recorded in the PKCS#7\n   block size field, and the resulting file is ready\
    \ for distribution to\n   ITRs.\n   To verify a database file, first retrieve\
    \ the PKCS#7 block from the\n   file by copying the appropriate number of bytes\
    \ into another file,\n   say, \"signature\".  Next, zero this field, and set the\
    \ block size\n   field to 0.  Next use the \"smime\" command to verify the signature\
    \ as\n   follows:\n       openssl smime -binary -verify -inform DER -content database-file\n\
    \               -out /dev/null -in signature\n   OpenSSL will return \"Verification\
    \ OK\" if the signature is correct.\n   OpenSSL provides sufficiently rich libraries\
    \ to accomplish the above\n   within the C programming language with a single\
    \ pass.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Eliot Lear\n   Cisco Systems GmbH\n   Richtistrasse 7\n\
    \   Wallisellen  CH-8304\n   Switzerland\n   Phone: +41 44 878 9200\n   EMail:\
    \ lear@cisco.com\n"
