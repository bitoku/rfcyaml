- contents:
  - "      Protecting Internet Key Exchange Protocol Version 2 (IKEv2)\n       Implementations
    from Distributed Denial-of-Service Attacks\n"
  title: __initial_text__
- contents:
  - "Abstract\n   This document recommends implementation and configuration best\n
    \  practices for Internet Key Exchange Protocol version 2 (IKEv2)\n   Responders,
    to allow them to resist Denial-of-Service and Distributed\n   Denial-of-Service
    attacks.  Additionally, the document introduces a\n   new mechanism called \"Client
    Puzzles\" that helps accomplish this\n   task.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    7841.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc8019.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2016 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .
    . . . . .   3\n   2.  Conventions Used in This Document . . . . . . . . . . .
    . . .   3\n   3.  The Vulnerability . . . . . . . . . . . . . . . . . . . . .
    .   3\n   4.  Defense Measures While the IKE SA Is Being Created  . . . . .   6\n
    \    4.1.  Retention Periods for Half-Open SAs . . . . . . . . . . .   6\n     4.2.
    \ Rate Limiting . . . . . . . . . . . . . . . . . . . . . .   7\n     4.3.  The
    Stateless Cookie  . . . . . . . . . . . . . . . . . .   8\n     4.4.  Puzzles
    . . . . . . . . . . . . . . . . . . . . . . . . .   8\n     4.5.  Session Resumption
    \ . . . . . . . . . . . . . . . . . . .  11\n     4.6.  Keeping Computed Shared
    Keys  . . . . . . . . . . . . . .  11\n     4.7.  Preventing \"Hash and URL\"
    Certificate Encoding Attacks  .  11\n     4.8.  IKE Fragmentation . . . . . .
    . . . . . . . . . . . . . .  12\n   5.  Defense Measures after an IKE SA Is Created
    . . . . . . . . .  12\n   6.  Plan for Defending a Responder  . . . . . . . .
    . . . . . . .  14\n   7.  Using Puzzles in the Protocol . . . . . . . . . . .
    . . . . .  16\n     7.1.  Puzzles in IKE_SA_INIT Exchange . . . . . . . . . .
    . . .  16\n       7.1.1.  Presenting a Puzzle . . . . . . . . . . . . . . . .
    .  17\n       7.1.2.  Solving a Puzzle and Returning the Solution . . . . .  19\n
    \      7.1.3.  Computing a Puzzle  . . . . . . . . . . . . . . . . .  20\n       7.1.4.
    \ Analyzing Repeated Request  . . . . . . . . . . . . .  21\n       7.1.5.  Deciding
    Whether to Serve the Request . . . . . . . .  22\n     7.2.  Puzzles in an IKE_AUTH
    Exchange . . . . . . . . . . . . .  23\n       7.2.1.  Presenting the Puzzle .
    . . . . . . . . . . . . . . .  24\n       7.2.2.  Solving the Puzzle and Returning
    the Solution . . . .  24\n       7.2.3.  Computing the Puzzle  . . . . . . . .
    . . . . . . . .  25\n       7.2.4.  Receiving the Puzzle Solution . . . . . .
    . . . . . .  25\n   8.  Payload Formats . . . . . . . . . . . . . . . . . . .
    . . . .  26\n     8.1.  PUZZLE Notification . . . . . . . . . . . . . . . . .
    . .  26\n     8.2.  Puzzle Solution Payload . . . . . . . . . . . . . . . . .
    \ 27\n   9.  Operational Considerations  . . . . . . . . . . . . . . . . .  28\n
    \  10. Security Considerations . . . . . . . . . . . . . . . . . . .  28\n   11.
    IANA Considerations . . . . . . . . . . . . . . . . . . . . .  30\n   12. References
    \ . . . . . . . . . . . . . . . . . . . . . . . . .  30\n     12.1.  Normative
    References . . . . . . . . . . . . . . . . . .  30\n     12.2.  Informative References
    . . . . . . . . . . . . . . . . .  31\n   Acknowledgements  . . . . . . . . .
    . . . . . . . . . . . . . . .  31\n   Authors' Addresses  . . . . . . . . . .
    . . . . . . . . . . . . .  32\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   Denial-of-Service (DoS) attacks have always been considered
    a serious\n   threat.  These attacks are usually difficult to defend against since\n
    \  the amount of resources the victim has is always bounded (regardless\n   of
    how high it is) and because some resources are required for\n   distinguishing
    a legitimate session from an attack.\n   The Internet Key Exchange Protocol version
    2 (IKEv2) described in\n   [RFC7296] includes defense against DoS attacks.  In
    particular, there\n   is a cookie mechanism that allows the IKE Responder to defend
    itself\n   against DoS attacks from spoofed IP addresses.  However, botnets have\n
    \  become widespread, allowing attackers to perform Distributed\n   Denial-of-Service
    (DDoS) attacks, which are more difficult to defend\n   against.  This document
    presents recommendations to help the\n   Responder counter DoS and DDoS attacks.
    \ It also introduces a new\n   mechanism -- \"puzzles\" -- that can help accomplish
    this task.\n"
  title: 1.  Introduction
- contents:
  - "2.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST NOT\",
    \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",
    \"NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be
    interpreted as described in\n   [RFC2119].\n"
  title: 2.  Conventions Used in This Document
- contents:
  - "3.  The Vulnerability\n   The IKE_SA_INIT exchange described in Section 1.2 of
    [RFC7296]\n   involves the Initiator sending a single message.  The Responder\n
    \  replies with a single message and also allocates memory for a\n   structure
    called a half-open IKE Security Association (SA).  This\n   half-open SA is later
    authenticated in the IKE_AUTH exchange.  If\n   that IKE_AUTH request never comes,
    the half-open SA is kept for an\n   unspecified amount of time.  Depending on
    the algorithms used and\n   implementation, such a half-open SA will use from
    around one hundred\n   to several thousand bytes of memory.\n   This creates an
    easy attack vector against an IKE Responder.\n   Generating the IKE_SA_INIT request
    is cheap.  Sending large amounts\n   of IKE_SA_INIT requests can cause a Responder
    to use up all its\n   resources.  If the Responder tries to defend against this
    by\n   throttling new requests, this will also prevent legitimate Initiators\n
    \  from setting up IKE SAs.\n   An obvious defense, which is described in Section
    4.2, is limiting\n   the number of half-open SAs opened by a single peer.  However,
    since\n   all that is required is a single packet, an attacker can use multiple\n
    \  spoofed source IP addresses.\n   If we break down what a Responder has to do
    during an initial\n   exchange, there are three stages:\n   1.  When the IKE_SA_INIT
    request arrives, the Responder:\n       *  Generates or reuses a Diffie-Hellman
    (DH) private part.\n       *  Generates a Responder Security Parameter Index (SPI).\n
    \      *  Stores the private part and peer public part in a half-open SA\n          database.\n
    \  2.  When the IKE_AUTH request arrives, the Responder:\n       *  Derives the
    keys from the half-open SA.\n       *  Decrypts the request.\n   3.  If the IKE_AUTH
    request decrypts properly, the Responder:\n       *  Validates the certificate
    chain (if present) in the IKE_AUTH\n          request.\n   The fourth stage where
    the Responder creates the Child SA is not\n   reached by attackers who cannot
    pass the authentication step.\n   Stage #1 is pretty light on CPU usage, but requires
    some storage, and\n   it's very light for the Initiator as well.  Stage #2 includes\n
    \  private-key operations, so it is much heavier CPU-wise.  Stage #3 may\n   include
    public key operations if certificates are involved.  These\n   operations are
    often more computationally expensive than those\n   performed at stage #2.\n   To
    attack such a Responder, an attacker can attempt to exhaust either\n   memory
    or CPU.  Without any protection, the most efficient attack is\n   to send multiple
    IKE_SA_INIT requests and exhaust memory.  This is\n   easy because IKE_SA_INIT
    requests are cheap.\n   There are obvious ways for the Responder to protect itself
    without\n   changes to the protocol.  It can reduce the time that an entry\n   remains
    in the half-open SA database, and it can limit the amount of\n   concurrent half-open
    SAs from a particular address or prefix.  The\n   attacker can overcome this by
    using spoofed source addresses.\n   The stateless cookie mechanism from Section
    2.6 of [RFC7296] prevents\n   an attack with spoofed source addresses.  This doesn't
    completely\n   solve the issue, but it makes the limiting of half-open SAs by\n
    \  address or prefix work.  Puzzles, introduced in Section 4.4,\n   accomplish
    the same thing -- only more of it.  They make it harder\n   for an attacker to
    reach the goal of getting a half-open SA.  Puzzles\n   do not have to be so hard
    that an attacker cannot afford to solve a\n   single puzzle; it is enough that
    puzzles increase the cost of\n   creating half-open SAs, so the attacker is limited
    in the amount they\n   can create.\n   Reducing the lifetime of an abandoned half-open
    SA also reduces the\n   impact of such attacks.  For example, if a half-open SA
    is kept for 1\n   minute and the capacity is 60,000 half-open SAs, an attacker
    would\n   need to create 1,000 half-open SAs per second.  If the retention time\n
    \  is reduced to 3 seconds, the attacker would need to create 20,000\n   half-open
    SAs per second to get the same result.  By introducing a\n   puzzle, each half-open
    SA becomes more expensive for an attacker,\n   making it more likely to prevent
    an exhaustion attack against\n   Responder memory.\n   At this point, filling
    up the half-open SA database is no longer the\n   most efficient DoS attack.  The
    attacker has two alternative attacks\n   to do better:\n   1.  Go back to spoofed
    addresses and try to overwhelm the CPU that\n       deals with generating cookies,
    or\n   2.  Take the attack to the next level by also sending an IKE_AUTH\n       request.\n
    \  If an attacker is so powerful that it is able to overwhelm the\n   Responder's
    CPU that deals with generating cookies, then the attack\n   cannot be dealt with
    at the IKE level and must be handled by means of\n   the Intrusion Prevention
    System (IPS) technology.\n   On the other hand, the second alternative of sending
    an IKE_AUTH\n   request is very cheap.  It requires generating a proper IKE header\n
    \  with the correct IKE SPIs and a single Encrypted payload.  The\n   content
    of the payload is irrelevant and might be junk.  The\n   Responder has to perform
    the relatively expensive key derivation,\n   only to find that the Message Authentication
    Code (MAC) on the\n   Encrypted payload on the IKE_AUTH request fails the integrity
    check.\n   If a Responder does not hold on to the calculated SKEYSEED and SK_*\n
    \  keys (which it should in case a valid IKE_AUTH comes in later), this\n   attack
    might be repeated on the same half-open SA.  Puzzles make\n   attacks of such
    sort more costly for an attacker.  See Section 7.2\n   for details.\n   Here too,
    the number of half-open SAs that the attacker can achieve\n   is crucial, because
    each one allows the attacker to waste some CPU\n   time.  So making it hard to
    make many half-open SAs is important.\n   A strategy against DDoS has to rely
    on at least 4 components:\n   1.  Hardening the half-open SA database by reducing
    retention time.\n   2.  Hardening the half-open SA database by rate-limiting single\n
    \      IPs/ prefixes.\n   3.  Guidance on what to do when an IKE_AUTH request
    fails to decrypt.\n   4.  Increasing the cost of half-open SAs up to what is tolerable
    for\n       legitimate clients.\n   Puzzles are used as a solution for strategy
    #4.\n"
  title: 3.  The Vulnerability
- contents:
  - '4.  Defense Measures While the IKE SA Is Being Created

    '
  - contents:
    - "4.1.  Retention Periods for Half-Open SAs\n   As a UDP-based protocol, IKEv2
      has to deal with packet loss through\n   retransmissions.  Section 2.4 of [RFC7296]
      recommends \"that messages\n   be retransmitted at least a dozen times over
      a period of at least\n   several minutes before giving up.\"  Many retransmission
      policies in\n   practice wait one or two seconds before retransmitting for the
      first\n   time.\n   Because of this, setting the timeout on a half-open SA too
      low will\n   cause it to expire whenever even one IKE_AUTH request packet is
      lost.\n   When not under attack, the half-open SA timeout SHOULD be set high\n
      \  enough that the Initiator will have enough time to send multiple\n   retransmissions,
      minimizing the chance of transient network\n   congestion causing an IKE failure.\n
      \  When the system is under attack, as measured by the amount of half-\n   open
      SAs, it makes sense to reduce this lifetime.  The Responder\n   should still
      allow enough time for the round-trip, for the Initiator\n   to derive the DH
      shared value, and to derive the IKE SA keys and\n   create the IKE_AUTH request.
      \ Two seconds is probably as low a value\n   as can realistically be used.\n
      \  It could make sense to assign a shorter value to half-open SAs\n   originating
      from IP addresses or prefixes that are considered suspect\n   because of multiple
      concurrent half-open SAs.\n"
    title: 4.1.  Retention Periods for Half-Open SAs
  - contents:
    - "4.2.  Rate Limiting\n   Even with DDoS, the attacker has only a limited amount
      of nodes\n   participating in the attack.  By limiting the amount of half-open
      SAs\n   that are allowed to exist concurrently with each such node, the total\n
      \  amount of half-open SAs is capped, as is the total amount of key\n   derivations
      that the Responder is forced to complete.\n   In IPv4, it makes sense to limit
      the number of half-open SAs based on\n   IP address.  Most IPv4 nodes are either
      directly attached to the\n   Internet using a routable address or hidden behind
      a NAT device with\n   a single IPv4 external address.  For IPv6, ISPs assign
      between a /48\n   and a /64, so it does not make sense for rate limiting to
      work on\n   single IPv6 IPs.  Instead, rate limits should be done based on either\n
      \  the /48 or /64 of the misbehaving IPv6 address observed.\n   The number of
      half-open SAs is easy to measure, but it is also\n   worthwhile to measure the
      number of failed IKE_AUTH exchanges.  If\n   possible, both factors should be
      taken into account when deciding\n   which IP address or prefix is considered
      suspicious.\n   There are two ways to rate limit a peer address or prefix:\n
      \  1.  Hard Limit -- where the number of half-open SAs is capped, and\n       any
      further IKE_SA_INIT requests are rejected.\n   2.  Soft Limit -- where if a
      set number of half-open SAs exist for a\n       particular address or prefix,
      any IKE_SA_INIT request will be\n       required to solve a puzzle.\n   The
      advantage of the hard limit method is that it provides a hard cap\n   on the
      amount of half-open SAs that the attacker is able to create.\n   The disadvantage
      is that it allows the attacker to block IKE\n   initiation from small parts
      of the Internet.  For example, if a\n   network service provider or some establishment
      offers Internet\n   connectivity to its customers or employees through an IPv4
      NAT\n   device, a single malicious customer can create enough half-open SAs\n
      \  to fill the quota for the NAT device external IP address.  Legitimate\n   Initiators
      on the same network will not be able to initiate IKE.\n   The advantage of a
      soft limit is that legitimate clients can always\n   connect.  The disadvantage
      is that an adversary with sufficient CPU\n   resources can still effectively
      DoS the Responder.\n   Regardless of the type of rate limiting used, legitimate
      Initiators\n   that are not on the same network segments as the attackers will
      not\n   be affected.  This is very important as it reduces the adverse impact\n
      \  caused by the measures used to counteract the attack and allows most\n   Initiators
      to keep working even if they do not support puzzles.\n"
    title: 4.2.  Rate Limiting
  - contents:
    - "4.3.  The Stateless Cookie\n   Section 2.6 of [RFC7296] offers a mechanism
      to mitigate DoS attacks:\n   the stateless cookie.  When the server is under
      load, the Responder\n   responds to the IKE_SA_INIT request with a calculated
      \"stateless\n   cookie\" -- a value that can be recalculated based on values
      in the\n   IKE_SA_INIT request without storing Responder-side state.  The\n
      \  Initiator is expected to repeat the IKE_SA_INIT request, this time\n   including
      the stateless cookie.  This mechanism prevents DoS attacks\n   from spoofed
      IP addresses, since an attacker needs to have a routable\n   IP address to return
      the cookie.\n   Attackers that have multiple source IP addresses with return\n
      \  routability, such as in the case of botnets, can fill up a half-open\n   SA
      table anyway.  The cookie mechanism limits the amount of allocated\n   state
      to the number of attackers, multiplied by the number of half-\n   open SAs allowed
      per peer address, multiplied by the amount of state\n   allocated for each half-open
      SA.  With typical values, this can\n   easily reach hundreds of megabytes.\n"
    title: 4.3.  The Stateless Cookie
  - contents:
    - "4.4.  Puzzles\n   The puzzle introduced here extends the cookie mechanism of
      [RFC7296].\n   It is loosely based on the proof-of-work technique used in Bitcoin\n
      \  [BITCOINS].  Puzzles set an upper bound, determined by the attacker's\n   CPU,
      to the number of negotiations the attacker can initiate in a\n   unit of time.\n
      \  A puzzle is sent to the Initiator in two cases:\n   o  The Responder is so
      overloaded that no half-open SAs may be\n      created without solving a puzzle,
      or\n   o  The Responder is not too loaded, but the rate-limiting method\n      described
      in Section 4.2 prevents half-open SAs from being created\n      with this particular
      peer address or prefix without first solving\n      a puzzle.\n   When the Responder
      decides to send the challenge to solve a puzzle in\n   response to an IKE_SA_INIT
      request, the message includes at least\n   three components:\n   1.  Cookie
      -- this is calculated the same as in [RFC7296], i.e., the\n       process of
      generating the cookie is not specified.\n   2.  Algorithm, this is the identifier
      of a Pseudorandom Function\n       (PRF) algorithm, one of those proposed by
      the Initiator in the SA\n       payload.\n   3.  Zero-Bit Count (ZBC).  This
      is a number between 8 and 255 (or a\n       special value - 0; see Section 7.1.1.1)
      that represents the\n       length of the zero-bit run at the end of the output
      of the PRF\n       function calculated over the cookie that the Initiator is
      to\n       send.  The values 1-8 are explicitly excluded, because they\n       create
      a puzzle that is too easy to solve.  Since the mechanism\n       is supposed
      to be stateless for the Responder, either the same\n       ZBC is used for all
      Initiators or the ZBC is somehow encoded in\n       the cookie.  If it is global,
      then it means that this value is\n       the same for all the Initiators who
      are receiving puzzles at any\n       given point of time.  The Responder, however,
      may change this\n       value over time depending on its load.\n   Upon receiving
      this challenge, the Initiator attempts to calculate\n   the PRF output using
      different keys.  When enough keys are found such\n   that the resulting PRF
      output calculated using each of them has a\n   sufficient number of trailing
      zero bits, that result is sent to the\n   Responder.\n   The reason for using
      several keys in the results, rather than just\n   one key, is to reduce the
      variance in the time it takes the Initiator\n   to solve the puzzle.  We have
      chosen the number of keys to be four\n   (4) as a compromise between the conflicting
      goals of reducing\n   variance and reducing the work the Responder needs to
      perform to\n   verify the puzzle solution.\n   When receiving a request with
      a solved puzzle, the Responder verifies\n   two things:\n   o  That the cookie
      is indeed valid.\n   o  That the results of PRF of the transmitted cookie calculated
      with\n      the transmitted keys has a sufficient number of trailing zero\n
      \     bits.\n   Example 1: Suppose the calculated cookie is\n   739ae7492d8a810cf5e8dc0f9626c9dda773c5a3
      (20 octets), the algorithm\n   is PRF-HMAC-SHA256, and the required number of
      zero bits is 18.\n   After successively trying a bunch of keys, the Initiator
      finds the\n   following four 3-octet keys that work:\n      +--------+----------------------------------+----------------+\n
      \     |  Key   | Last 32 Hex PRF Digits           | # of Zero Bits |\n      +--------+----------------------------------+----------------+\n
      \     | 061840 | e4f957b859d7fb1343b7b94a816c0000 |       18       |\n      |
      073324 | 0d4233d6278c96e3369227a075800000 |       23       |\n      | 0c8a2a
      | 952a35d39d5ba06709da43af40700000 |       20       |\n      | 0d94c8 | 5a0452b21571e401a3d00803679c0000
      |       18       |\n      +--------+----------------------------------+----------------+\n
      \              Table 1: Four Solutions for the 18-Bit Puzzle\n   Example 2:
      Same cookie, but modify the required number of zero bits\n   to 22.  The first
      4-octet keys that work to satisfy that requirement\n   are 005d9e57, 010d8959,
      0110778d, and 01187e37.  Finding these\n   requires 18,382,392 invocations of
      the PRF.\n            +----------------+-------------------------------+\n            |
      # of Zero Bits | Time to Find 4 Keys (Seconds) |\n            +----------------+-------------------------------+\n
      \           |       8        |                        0.0025 |\n            |
      \      10       |                        0.0078 |\n            |       12       |
      \                       0.0530 |\n            |       14       |                        0.2521
      |\n            |       16       |                        0.8504 |\n            |
      \      17       |                        1.5938 |\n            |       18       |
      \                       3.3842 |\n            |       19       |                        3.8592
      |\n            |       20       |                       10.8876 |\n            +----------------+-------------------------------+\n
      \  Table 2: The Time Needed to Solve a Puzzle of Various Difficulty for\n            the
      Cookie 39ae7492d8a810cf5e8dc0f9626c9dda773c5a3\n   The figures above were obtained
      on a 2.4 GHz single-core Intel i5\n   processor in a 2013 Apple MacBook Pro.
      \ Run times can be halved or\n   quartered with multi-core code, but they would
      be longer on mobile\n   phone processors, even if those are multi-core as well.
      \ With these\n   figures, 18 bits is believed to be a reasonable choice for
      puzzle\n   level difficulty for all Initiators, and 20 bits is acceptable for\n
      \  specific hosts/prefixes.\n   Using the puzzles mechanism in the IKE_SA_INIT
      exchange is described\n   in Section 7.1.\n"
    title: 4.4.  Puzzles
  - contents:
    - "4.5.  Session Resumption\n   When the Responder is under attack, it SHOULD
      prefer previously\n   authenticated peers who present a Session Resumption ticket\n
      \  [RFC5723].  However, the Responder SHOULD NOT serve resumed\n   Initiators
      exclusively because dropping all IKE_SA_INIT requests\n   would lock out legitimate
      Initiators that have no resumption ticket.\n   When under attack, the Responder
      SHOULD require Initiators presenting\n   Session Resumption tickets to pass
      a return routability check by\n   including the COOKIE notification in the IKE_SESSION_RESUME
      response\n   message, as described in Section 4.3.2. of [RFC5723].  Note that
      the\n   Responder SHOULD cache tickets for a short time to reject reused\n   tickets
      (Section 4.3.1 of [RFC5723]); therefore, there should be no\n   issue of half-open
      SAs resulting from replayed IKE_SESSION_RESUME\n   messages.\n   Several kinds
      of DoS attacks are possible on servers supported by IKE\n   Session Resumption.
      \ See Section 9.3 of [RFC5723] for details.\n"
    title: 4.5.  Session Resumption
  - contents:
    - "4.6.  Keeping Computed Shared Keys\n   Once the IKE_SA_INIT exchange is finished,
      the Responder is waiting\n   for the first message of the IKE_AUTH exchange
      from the Initiator.\n   At this point, the Initiator is not yet authenticated,
      and this fact\n   allows an attacker to perform an attack, described in Section
      3.\n   Instead of sending a properly formed and encrypted IKE_AUTH message,\n
      \  the attacker can just send arbitrary data, forcing the Responder to\n   perform
      costly CPU operations to compute SK_* keys.\n   If the received IKE_AUTH message
      failed to decrypt correctly (or\n   failed to pass the Integrity Check Value
      (ICV) check), then the\n   Responder SHOULD still keep the computed SK_* keys,
      so that if it\n   happened to be an attack, then an attacker cannot get an advantage
      of\n   repeating the attack multiple times on a single IKE SA.  The\n   Responder
      can also use puzzles in the IKE_AUTH exchange as described\n   in Section 7.2.\n"
    title: 4.6.  Keeping Computed Shared Keys
  - contents:
    - "4.7.  Preventing \"Hash and URL\" Certificate Encoding Attacks\n   In IKEv2,
      each side may use the \"Hash and URL\" Certificate Encoding\n   to instruct
      the peer to retrieve certificates from the specified\n   location (see Section
      3.6 of [RFC7296] for details).  Malicious\n   Initiators can use this feature
      to mount a DoS attack on the\n   Responder by providing a URL pointing to a
      large file possibly\n   containing meaningless bits.  While downloading the
      file, the\n   Responder consumes CPU, memory, and network bandwidth.\n   To
      prevent this kind of attack, the Responder should not blindly\n   download the
      whole file.  Instead, it SHOULD first read the initial\n   few bytes, decode
      the length of the ASN.1 structure from these bytes,\n   and then download no
      more than the decoded number of bytes.  Note\n   that it is always possible
      to determine the length of ASN.1\n   structures used in IKEv2, if they are DER-encoded,
      by analyzing the\n   first few bytes.  However, since the content of the file
      being\n   downloaded can be under the attacker's control, implementations\n
      \  should not blindly trust the decoded length and SHOULD check whether\n   it
      makes sense before continuing to download the file.\n   Implementations SHOULD
      also apply a configurable hard limit to the\n   number of pulled bytes and SHOULD
      provide an ability for an\n   administrator to either completely disable this
      feature or limit its\n   use to a configurable list of trusted URLs.\n"
    title: 4.7.  Preventing "Hash and URL" Certificate Encoding Attacks
  - contents:
    - "4.8.  IKE Fragmentation\n   IKE fragmentation described in [RFC7383] allows
      IKE peers to avoid IP\n   fragmentation of large IKE messages.  Attackers can
      mount several\n   kinds of DoS attacks using IKE fragmentation.  See Section
      5 of\n   [RFC7383] for details on how to mitigate these attacks.\n"
    title: 4.8.  IKE Fragmentation
  title: 4.  Defense Measures While the IKE SA Is Being Created
- contents:
  - "5.  Defense Measures after an IKE SA Is Created\n   Once an IKE SA is created,
    there is usually only a limited amount of\n   IKE messages exchanged.  This IKE
    traffic consists of exchanges aimed\n   to create additional Child SAs, IKE rekeys,
    IKE deletions, and IKE\n   liveness tests.  Some of these exchanges require relatively
    little\n   resources (like a liveness check), while others may be resource\n   consuming
    (like creating or rekeying a Child SA with DH exchange).\n   Since any endpoint
    can initiate a new exchange, there is a\n   possibility that a peer would initiate
    too many exchanges that could\n   exhaust host resources.  For example, the peer
    can perform endless\n   continuous Child SA rekeying or create an overwhelming
    number of\n   Child SAs with the same Traffic Selectors, etc.  Such behavior can
    be\n   caused by broken implementations, misconfiguration, or as an\n   intentional
    attack.  The latter becomes more of a real threat if the\n   peer uses NULL Authentication,
    as described in [RFC7619].  In this\n   case, the peer remains anonymous, allowing
    it to escape any\n   responsibility for its behavior.  See Section 3 of [RFC7619]
    for\n   details on how to mitigate attacks when using NULL Authentication.\n   The
    following recommendations apply especially for NULL-authenticated\n   IKE sessions,
    but also apply to authenticated IKE sessions, with the\n   difference that in
    the latter case, the identified peer can be locked\n   out.\n   o  If the IKEv2
    window size is greater than one, peers are able to\n      initiate multiple simultaneous
    exchanges that increase host\n      resource consumption.  Since there is no way
    in IKEv2 to decrease\n      window size once it has been increased (see Section
    2.3 of\n      [RFC7296]), the window size cannot be dynamically adjusted\n      depending
    on the load.  It is NOT RECOMMENDED to allow an IKEv2\n      window size greater
    than one when NULL Authentication has been\n      used.\n   o  If a peer initiates
    an abusive amount of CREATE_CHILD_SA exchanges\n      to rekey IKE SAs or Child
    SAs, the Responder SHOULD reply with\n      TEMPORARY_FAILURE notifications indicating
    the peer must slow down\n      their requests.\n   o  If a peer creates many Child
    SAs with the same or overlapping\n      Traffic Selectors, implementations MAY
    respond with the\n      NO_ADDITIONAL_SAS notification.\n   o  If a peer initiates
    many exchanges of any kind, the Responder MAY\n      introduce an artificial delay
    before responding to each request\n      message.  This delay would decrease the
    rate the Responder needs\n      to process requests from any particular peer and
    frees up\n      resources on the Responder that can be used for answering\n      legitimate
    clients.  If the Responder receives retransmissions of\n      the request message
    during the delay period, the retransmitted\n      messages MUST be silently discarded.
    \ The delay must be short\n      enough to avoid legitimate peers deleting the
    IKE SA due to a\n      timeout.  It is believed that a few seconds is enough.
    \ Note,\n      however, that even a few seconds may be too long when settings\n
    \     rely on an immediate response to the request message, e.g., for\n      the
    purposes of quick detection of a dead peer.\n   o  If these countermeasures are
    inefficient, implementations MAY\n      delete the IKE SA with an offending peer
    by sending Delete\n      Payload.\n   In IKE, a client can request various configuration
    attributes from\n   the server.  Most often, these attributes include internal
    IP\n   addresses.  Malicious clients can try to exhaust a server's IP\n   address
    pool by continuously requesting a large number of internal\n   addresses.  Server
    implementations SHOULD limit the number of IP\n   addresses allocated to any particular
    client.  Note, this is not\n   possible with clients using NULL Authentication,
    since their identity\n   cannot be verified.\n"
  title: 5.  Defense Measures after an IKE SA Is Created
- contents:
  - "6.  Plan for Defending a Responder\n   This section outlines a plan for defending
    a Responder from a DDoS\n   attack based on the techniques described earlier.
    \ The numbers given\n   here are not normative, and their purpose is to illustrate
    the\n   configurable parameters needed for surviving DDoS attacks.\n   Implementations
    are deployed in different environments, so it is\n   RECOMMENDED that the parameters
    be settable.  For example, most\n   commercial products are required to undergo
    benchmarking where the\n   IKE SA establishment rate is measured.  Benchmarking
    is\n   indistinguishable from a DoS attack, and the defenses described in\n   this
    document may defeat the benchmark by causing exchanges to fail\n   or to take
    a long time to complete.  Parameters SHOULD be tunable to\n   allow for benchmarking
    (if only by turning DDoS protection off).\n   Since all countermeasures may cause
    delays and additional work for\n   the Initiators, they SHOULD NOT be deployed
    unless an attack is\n   likely to be in progress.  To minimize the burden imposed
    on\n   Initiators, the Responder should monitor incoming IKE requests for\n   two
    scenarios:\n   1.  A general DDoS attack.  Such an attack is indicated by a high\n
    \      number of concurrent half-open SAs, a high rate of failed\n       IKE_AUTH
    exchanges, or a combination of both.  For example,\n       consider a Responder
    that has 10,000 distinct peers of which at\n       peak, 7,500 concurrently have
    VPN tunnels.  At the start of peak\n       time, 600 peers might establish tunnels
    within any given minute,\n       and tunnel establishment (both IKE_SA_INIT and
    IKE_AUTH) takes\n       anywhere from 0.5 to 2 seconds.  For this Responder, we
    expect\n       there to be less than 20 concurrent half-open SAs, so having 100\n
    \      concurrent half-open SAs can be interpreted as an indication of\n       an
    attack.  Similarly, IKE_AUTH request decryption failures\n       should never
    happen.  Supposing that the tunnels are established\n       using Extensible Authentication
    Protocol (EAP) (see Section 2.16\n       of [RFC7296]), users may be expected
    to enter a wrong password\n       about 20% of the time.  So we'd expect 125 wrong
    password\n       failures a minute.  If we get IKE_AUTH decryption failures from\n
    \      multiple sources more than once per second, or EAP failures more\n       than
    300 times per minute, this can also be an indication of a\n       DDoS attack.\n
    \  2.  An attack from a particular IP address or prefix.  Such an attack\n       is
    indicated by an inordinate amount of half-open SAs from a\n       specific IP
    address or prefix, or an inordinate amount of\n       IKE_AUTH failures.  A DDoS
    attack may be viewed as multiple such\n       attacks.  If these are mitigated
    successfully, there will not be\n       a need to enact countermeasures on all
    Initiators.  For example,\n       measures might be 5 concurrent half-open SAs,
    1 decrypt failure,\n       or 10 EAP failures within a minute.\n   Note that using
    countermeasures against an attack from a particular\n   IP address may be enough
    to avoid the overload on the half-open SA\n   database.  In this case, the number
    of failed IKE_AUTH exchanges will\n   never exceed the threshold of attack detection.\n
    \  When there is no general DDoS attack, it is suggested that no cookie\n   or
    puzzles be used.  At this point, the only defensive measure is to\n   monitor
    the number of half-open SAs, and set a soft limit per peer IP\n   or prefix.  The
    soft limit can be set to 3-5.  If the puzzles are\n   used, the puzzle difficulty
    SHOULD be set to such a level (number of\n   zero bits) that all legitimate clients
    can handle it without degraded\n   user experience.\n   As soon as any kind of
    attack is detected, either a lot of\n   initiations from multiple sources or a
    lot of initiations from a few\n   sources, it is best to begin by requiring stateless
    cookies from all\n   Initiators.  This will mitigate attacks based on IP address
    spoofing\n   and help avoid the need to impose a greater burden in the form of\n
    \  puzzles on the general population of Initiators.  This makes the per-\n   node
    or per-prefix soft limit more effective.\n   When cookies are activated for all
    requests and the attacker is still\n   managing to consume too many resources,
    the Responder MAY start to\n   use puzzles for these requests or increase the
    difficulty of puzzles\n   imposed on IKE_SA_INIT requests coming from suspicious
    nodes/\n   prefixes.  This should still be doable by all legitimate peers, but\n
    \  the use of puzzles at a higher difficulty may degrade the user\n   experience,
    for example, by taking up to 10 seconds to solve the\n   puzzle.\n   If the load
    on the Responder is still too great, and there are many\n   nodes causing multiple
    half-open SAs or IKE_AUTH failures, the\n   Responder MAY impose hard limits on
    those nodes.\n   If it turns out that the attack is very widespread and the hard
    caps\n   are not solving the issue, a puzzle MAY be imposed on all Initiators.\n
    \  Note that this is the last step, and the Responder should avoid this\n   if
    possible.\n"
  title: 6.  Plan for Defending a Responder
- contents:
  - "7.  Using Puzzles in the Protocol\n   This section describes how the puzzle mechanism
    is used in IKEv2.  It\n   is organized as follows.  Section 7.1 describes using
    puzzles in the\n   IKE_SA_INIT exchange and Section 7.2 describes using puzzles
    in the\n   IKE_AUTH exchange.  Both sections are divided into subsections\n   describing
    how puzzles should be presented, solved, and processed by\n   the Initiator and
    the Responder.\n"
  - contents:
    - "7.1.  Puzzles in IKE_SA_INIT Exchange\n   The IKE Initiator indicates the desire
      to create a new IKE SA by\n   sending an IKE_SA_INIT request message.  The message
      may optionally\n   contain a COOKIE notification if this is a repeated request
      performed\n   after the Responder's demand to return a cookie.\n   HDR, [N(COOKIE),]
      SA, KE, Ni, [V+][N+]   -->\n                   Figure 1: Initial IKE_SA_INIT
      Request\n   According to the plan, described in Section 6, the IKE Responder\n
      \  monitors incoming requests to detect whether it is under attack.  If\n   the
      Responder learns that a DoS or DDoS attack is likely to be in\n   progress,
      then its actions depend on the volume of the attack.  If\n   the volume is moderate,
      then the Responder requests the Initiator to\n   return a cookie.  If the volume
      is high to such an extent that\n   puzzles need to be used for defense, then
      the Responder requests the\n   Initiator to solve a puzzle.\n   The Responder
      MAY choose to process some fraction of IKE_SA_INIT\n   requests without presenting
      a puzzle while being under attack to\n   allow legacy clients, that don't support
      puzzles, to have a chance to\n   be served.  The decision whether to process
      any particular request\n   must be probabilistic, with the probability depending
      on the\n   Responder's load (i.e., on the volume of attack).  The requests that\n
      \  don't contain the COOKIE notification MUST NOT participate in this\n   lottery.
      \ In other words, the Responder must first perform a return\n   routability
      check before allowing any legacy client to be served if\n   it is under attack.
      \ See Section 7.1.4 for details.\n"
    - contents:
      - "7.1.1.  Presenting a Puzzle\n   If the Responder makes a decision to use
        puzzles, then it includes\n   two notifications in its response message --
        the COOKIE notification\n   and the PUZZLE notification.  Note that the PUZZLE
        notification MUST\n   always be accompanied with the COOKIE notification,
        since the content\n   of the COOKIE notification is used as an input data
        when solving the\n   puzzle.  The format of the PUZZLE notification is described
        in\n   Section 8.1.\n                             <--   HDR, N(COOKIE), N(PUZZLE),
        [V+][N+]\n             Figure 2: IKE_SA_INIT Response Containing Puzzle\n
        \  The presence of these notifications in an IKE_SA_INIT response\n   message
        indicates to the Initiator that it should solve the puzzle to\n   have a better
        chance to be served.\n"
      - contents:
        - "7.1.1.1.  Selecting the Puzzle Difficulty Level\n   The PUZZLE notification
          contains the difficulty level of the puzzle\n   -- the minimum number of
          trailing zero bits that the result of PRF\n   must contain.  In diverse
          environments, it is nearly impossible for\n   the Responder to set any specific
          difficulty level that will result\n   in roughly the same amount of work
          for all Initiators, because\n   computation power of different Initiators
          may vary by an order of\n   magnitude, or even more.  The Responder may
          set the difficulty level\n   to 0, meaning that the Initiator is requested
          to spend as much power\n   to solve a puzzle as it can afford.  In this
          case, no specific value\n   of ZBC is required from the Initiator; however,
          the larger the ZBC\n   that the Initiator is able to get, the better the
          chance is that it\n   will be served by the Responder.  In diverse environments,
          it is\n   RECOMMENDED that the Initiator set the difficulty level to 0,
          unless\n   the attack volume is very high.\n   If the Responder sets a non-zero
          difficulty level, then the level\n   SHOULD be determined by analyzing the
          volume of the attack.  The\n   Responder MAY set different difficulty levels
          to different requests\n   depending on the IP address the request has come
          from.\n"
        title: 7.1.1.1.  Selecting the Puzzle Difficulty Level
      - contents:
        - "7.1.1.2.  Selecting the Puzzle Algorithm\n   The PUZZLE notification also
          contains an identifier of the algorithm\n   that is used by the Initiator
          to compute the puzzle.\n   Cryptographic algorithm agility is considered
          an important feature\n   for modern protocols [RFC7696].  Algorithm agility
          ensures that a\n   protocol doesn't rely on a single built-in set of cryptographic\n
          \  algorithms but has a means to replace one set with another and\n   negotiate
          new algorithms with the peer.  IKEv2 fully supports\n   cryptographic algorithm
          agility for its core operations.\n   To support crypto-agility in case of
          puzzles, the algorithm that is\n   used to compute a puzzle needs to be
          negotiated during the\n   IKE_SA_INIT exchange.  The negotiation is performed
          as follows.  The\n   initial request message from the Initiator contains
          an SA payload\n   containing a list of transforms of different types.  In
          that manner,\n   the Initiator asserts that it supports all transforms from
          this list\n   and can use any of them in the IKE SA being established.  The\n
          \  Responder parses the received SA payload and finds mutually supported\n
          \  transforms of type PRF.  The Responder selects the preferred PRF from\n
          \  the list of mutually supported ones and includes it into the PUZZLE\n
          \  notification.  There is no requirement that the PRF selected for\n   puzzles
          be the same as the PRF that is negotiated later for use in\n   core IKE
          SA crypto operations.  If there are no mutually supported\n   PRFs, then
          IKE SA negotiation will fail anyway and there is no reason\n   to return
          a puzzle.  In this case, the Responder returns a\n   NO_PROPOSAL_CHOSEN
          notification.  Note that PRF is a mandatory\n   transform type for IKE SA
          (see Sections 3.3.2 and 3.3.3 of\n   [RFC7296]), and at least one transform
          of this type is always present\n   in the SA payload in an IKE_SA_INIT request
          message.\n"
        title: 7.1.1.2.  Selecting the Puzzle Algorithm
      - contents:
        - "7.1.1.3.  Generating a Cookie\n   If the Responder supports puzzles, then
          a cookie should be computed\n   in such a manner that the Responder is able
          to learn some important\n   information from the sole cookie, when it is
          later returned back by\n   the Initiator.  In particular, the Responder
          SHOULD be able to learn\n   the following information:\n   o  Whether the
          puzzle was given to the Initiator or only the cookie\n      was requested.\n
          \  o  The difficulty level of the puzzle given to the Initiator.\n   o  The
          number of consecutive puzzles given to the Initiator.\n   o  The amount
          of time the Initiator spent to solve the puzzles.  This\n      can be calculated
          if the cookie is timestamped.\n   This information helps the Responder to
          make a decision whether to\n   serve this request or demand more work from
          the Initiator.\n   One possible approach to get this information is to encode
          it in the\n   cookie.  The format of such encoding is an implementation
          detail of\n   the Responder, as the cookie would remain an opaque block
          of data to\n   the Initiator.  If this information is encoded in the cookie,
          then\n   the Responder MUST make it integrity protected, so that any intended\n
          \  or accidental alteration of this information in the returned cookie\n
          \  is detectable.  So, the cookie would be generated as:\n   Cookie = <VersionIDofSecret>
          | <AdditionalInfo> |\n                     Hash(Ni | IPi | SPIi | <AdditionalInfo>
          | <secret>)\n   Note that according to Section 2.6 of [RFC7296], the size
          of the\n   cookie cannot exceed 64 bytes.\n   Alternatively, the Responder
          may generate a cookie as suggested in\n   Section 2.6 of [RFC7296], but
          associate the additional information,\n   using local storage identified
          with the particular version of the\n   secret.  In this case, the Responder
          should have different secrets\n   for every combination of difficulty level
          and number of consecutive\n   puzzles, and should change the secrets periodically,
          keeping a few\n   previous versions, to be able to calculate how long ago
          a cookie was\n   generated.\n   The Responder may also combine these approaches.
          \ This document\n   doesn't mandate how the Responder learns this information
          from a\n   cookie.\n   When selecting cookie generation, algorithm implementations
          MUST\n   ensure that an attacker gains no or insignificant benefit from\n
          \  reusing puzzle solutions in several requests.  See Section 10 for\n   details.\n"
        title: 7.1.1.3.  Generating a Cookie
      title: 7.1.1.  Presenting a Puzzle
    - contents:
      - "7.1.2.  Solving a Puzzle and Returning the Solution\n   If the Initiator
        receives a puzzle but it doesn't support puzzles,\n   then it will ignore
        the PUZZLE notification as an unrecognized status\n   notification (in accordance
        with Section 3.10.1 of [RFC7296]).  The\n   Initiator MAY ignore the PUZZLE
        notification if it is not willing to\n   spend resources to solve the puzzle
        of the requested difficulty, even\n   if it supports puzzles.  In both cases,
        the Initiator acts as\n   described in Section 2.6 of [RFC7296] -- it restarts
        the request and\n   includes the received COOKIE notification in it.  The
        Responder\n   should be able to distinguish the situation when it just requested
        a\n   cookie from the situation where the puzzle was given to the\n   Initiator,
        but the Initiator for some reason ignored it.\n   If the received message
        contains a PUZZLE notification and doesn't\n   contain a COOKIE notification,
        then this message is malformed because\n   it requests to solve the puzzle
        but doesn't provide enough\n   information to allow the puzzle to be solved.
        \ In this case, the\n   Initiator MUST ignore the received message and continue
        to wait until\n   either a valid PUZZLE notification is received or the retransmission\n
        \  timer fires.  If it fails to receive a valid message after several\n   retransmissions
        of IKE_SA_INIT requests, then this means that\n   something is wrong and the
        IKE SA cannot be established.\n   If the Initiator supports puzzles and is
        ready to solve them, then it\n   tries to solve the given puzzle.  After the
        puzzle is solved, the\n   Initiator restarts the request and returns back
        to the Responder the\n   puzzle solution in a new payload called a Puzzle
        Solution (PS)\n   payload (see Section 8.2) along with the received COOKIE\n
        \  notification.\n   HDR, N(COOKIE), [PS,] SA, KE, Ni, [V+][N+]   -->\n         Figure
        3: IKE_SA_INIT Request Containing Puzzle Solution\n"
      title: 7.1.2.  Solving a Puzzle and Returning the Solution
    - contents:
      - "7.1.3.  Computing a Puzzle\n   General principles of constructing puzzles
        in IKEv2 are described in\n   Section 4.4.  They can be summarized as follows:
        given unpredictable\n   string S and PRF, find N different keys Ki (where
        i=[1..N]) for that\n   PRF so that the result of PRF(Ki,S) has at least the
        specified number\n   of trailing zero bits.  This specification requires that
        the puzzle\n   solution contains 4 different keys (i.e., N=4).\n   In the
        IKE_SA_INIT exchange, it is the cookie that plays the role of\n   unpredictable
        string S.  In other words, in the IKE_SA_INIT, the task\n   for the IKE Initiator
        is to find the four different, equal-sized keys\n   Ki for the agreed upon
        PRF such that each result of PRF(Ki,cookie)\n   where i = [1..4] has a sufficient
        number of trailing zero bits.  Only\n   the content of the COOKIE notification
        is used in puzzle calculation,\n   i.e., the header of the Notify payload
        is not included.\n   Note that puzzles in the IKE_AUTH exchange are computed
        differently\n   than in the IKE_SA_INIT_EXCHANGE.  See Section 7.2.3 for details.\n"
      title: 7.1.3.  Computing a Puzzle
    - contents:
      - "7.1.4.  Analyzing Repeated Request\n   The received request must at least
        contain a COOKIE notification.\n   Otherwise, it is an initial request and
        in this case, it MUST be\n   processed according to Section 7.1.  First, the
        cookie MUST be\n   checked for validity.  If the cookie is invalid, then the
        request is\n   treated as initial and is processed according to Section 7.1.
        \ It is\n   RECOMMENDED that a new cookie is requested in this case.\n   If
        the cookie is valid, then some important information is learned\n   from it
        or from local state based on the identifier of the cookie's\n   secret (see
        Section 7.1.1.3 for details).  This information helps the\n   Responder to
        sort out incoming requests, giving more priority to\n   those that were created
        by spending more of the Initiator's\n   resources.\n   First, the Responder
        determines if it requested only a cookie or\n   presented a puzzle to the
        Initiator.  If no puzzle was given, this\n   means that at the time the Responder
        requested a cookie, it didn't\n   detect the DoS or DDoS attack, or the attack
        volume was low.  In this\n   case, the received request message must not contain
        the PS payload,\n   and this payload MUST be ignored if the message contains
        a PS payload\n   for any reason.  Since no puzzle was given, the Responder
        marks the\n   request with the lowest priority since the Initiator spent little\n
        \  resources creating it.\n   If the Responder learns from the cookie that
        the puzzle was given to\n   the Initiator, then it looks for the PS payload
        to determine whether\n   its request to solve the puzzle was honored or not.
        \ If the incoming\n   message doesn't contain a PS payload, this means that
        the Initiator\n   either doesn't support puzzles or doesn't want to deal with
        them.  In\n   either case, the request is marked with the lowest priority
        since the\n   Initiator spent little resources creating it.\n   If a PS payload
        is found in the message, then the Responder MUST\n   verify the puzzle solution
        that it contains.  The solution is\n   interpreted as four different keys.
        \ The result of using each of them\n   in the PRF (as described in Section
        7.1.3) must contain at least the\n   requested number of trailing zero bits.
        \ The Responder MUST check all\n   of the four returned keys.\n   If any checked
        result contains fewer bits than were requested, this\n   means that the Initiator
        spent less resources than expected by the\n   Responder.  This request is
        marked with the lowest priority.\n   If the Initiator provided the solution
        to the puzzle satisfying the\n   requested difficulty level, or if the Responder
        didn't indicate any\n   particular difficulty level (by setting the ZBC to
        0) and the\n   Initiator was free to select any difficulty level it can afford,
        then\n   the priority of the request is calculated based on the following\n
        \  considerations:\n   o  The Responder MUST take the smallest number of trailing
        zero bits\n      among the checked results and count it as the number of zero
        bits\n      the Initiator solved for.\n   o  The higher number of zero bits
        the Initiator provides, the higher\n      priority its request should receive.\n
        \  o  The more consecutive puzzles the Initiator solved, the higher\n      priority
        it should receive.\n   o  The more time the Initiator spent solving the puzzles,
        the higher\n      priority it should receive.\n   After the priority of the
        request is determined, the final decision\n   whether to serve it or not is
        made.\n"
      title: 7.1.4.  Analyzing Repeated Request
    - contents:
      - "7.1.5.  Deciding Whether to Serve the Request\n   The Responder decides what
        to do with the request based on the\n   request's priority and the Responder's
        current load.  There are three\n   possible actions:\n   o  Accept request.\n
        \  o  Reject request.\n   o  Demand more work from the Initiator by giving
        it a new puzzle.\n   The Responder SHOULD accept an incoming request if its
        priority is\n   high -- this means that the Initiator spent quite a lot of
        resources.\n   The Responder MAY also accept some low-priority requests where
        the\n   Initiators don't support puzzles.  The percentage of accepted legacy\n
        \  requests depends on the Responder's current load.\n   If the Initiator
        solved the puzzle, but didn't spend much resources\n   for it (the selected
        puzzle difficulty level appeared to be low and\n   the Initiator solved it
        quickly), then the Responder SHOULD give it\n   another puzzle.  The more
        puzzles the Initiator solves the higher its\n   chances are to be served.\n
        \  The details of how the Responder makes a decision for any particular\n
        \  request are implementation dependent.  The Responder can collect all\n
        \  of the incoming requests for some short period of time, sort them out\n
        \  based on their priority, calculate the number of available memory\n   slots
        for half-open IKE SAs, and then serve that number of requests\n   from the
        head of the sorted list.  The remainder of requests can be\n   either discarded
        or responded to with new puzzle requests.\n   Alternatively, the Responder
        may decide whether to accept every\n   incoming request with some kind of
        lottery, taking into account its\n   priority and the available resources.\n"
      title: 7.1.5.  Deciding Whether to Serve the Request
    title: 7.1.  Puzzles in IKE_SA_INIT Exchange
  - contents:
    - "7.2.  Puzzles in an IKE_AUTH Exchange\n   Once the IKE_SA_INIT exchange is
      completed, the Responder has created\n   a state and is waiting for the first
      message of the IKE_AUTH exchange\n   from the Initiator.  At this point, the
      Initiator has already passed\n   the return routability check and has proved
      that it has performed\n   some work to complete the IKE_SA_INIT exchange.  However,
      the\n   Initiator is not yet authenticated, and this allows a malicious\n   Initiator
      to perform an attack, as described in Section 3.  Unlike a\n   DoS attack in
      the IKE_SA_INIT exchange, which is targeted on the\n   Responder's memory resources,
      the goal of this attack is to exhaust a\n   Responder's CPU power.  The attack
      is performed by sending the first\n   IKE_AUTH message containing arbitrary
      data.  This costs nothing to\n   the Initiator, but the Responder has to perform
      relatively costly\n   operations when computing the DH shared secret and deriving
      SK_* keys\n   to be able to verify authenticity of the message.  If the Responder\n
      \  doesn't keep the computed keys after an unsuccessful verification of\n   the
      IKE_AUTH message, then the attack can be repeated several times\n   on the same
      IKE SA.\n   The Responder can use puzzles to make this attack more costly for
      the\n   Initiator.  The idea is that the Responder includes a puzzle in the\n
      \  IKE_SA_INIT response message and the Initiator includes a puzzle\n   solution
      in the first IKE_AUTH request message outside the Encrypted\n   payload, so
      that the Responder is able to verify a puzzle solution\n   before computing
      the DH shared secret.\n   The Responder constantly monitors the amount of the
      half-open IKE SA\n   states that receive IKE_AUTH messages that cannot be decrypted
      due to\n   integrity check failures.  If the percentage of such states is high\n
      \  and it takes an essential fraction of the Responder's computing power\n   to
      calculate keys for them, then the Responder may assume that it is\n   under
      attack and SHOULD use puzzles to make it harder for attackers.\n"
    - contents:
      - "7.2.1.  Presenting the Puzzle\n   The Responder requests the Initiator to
        solve a puzzle by including\n   the PUZZLE notification in the IKE_SA_INIT
        response message.  The\n   Responder MUST NOT use puzzles in the IKE_AUTH
        exchange unless a\n   puzzle has been previously presented and solved in the
        preceding\n   IKE_SA_INIT exchange.\n                             <--   HDR,
        SA, KE, Nr, N(PUZZLE), [V+][N+]\n         Figure 4: IKE_SA_INIT Response Containing
        IKE_AUTH Puzzle\n"
      - contents:
        - "7.2.1.1.  Selecting Puzzle Difficulty Level\n   The difficulty level of
          the puzzle in the IKE_AUTH exchange should be\n   chosen so that the Initiator
          would spend more time to solve the\n   puzzle than the Responder to compute
          the DH shared secret and the\n   keys needed to decrypt and verify the IKE_AUTH
          request message.  On\n   the other hand, the difficulty level should not
          be too high,\n   otherwise legitimate clients will experience an additional
          delay\n   while establishing the IKE SA.\n   Note that since puzzles in
          the IKE_AUTH exchange are only allowed to\n   be used if they were used
          in the preceding IKE_SA_INIT exchange, the\n   Responder would be able to
          roughly estimate the computational power\n   of the Initiator and select
          the difficulty level accordingly.  Unlike\n   puzzles in the IKE_SA_INIT,
          the requested difficulty level for\n   IKE_AUTH puzzles MUST NOT be 0.  In
          other words, the Responder must\n   always set a specific difficulty level
          and must not let the Initiator\n   choose it on its own.\n"
        title: 7.2.1.1.  Selecting Puzzle Difficulty Level
      - contents:
        - "7.2.1.2.  Selecting the Puzzle Algorithm\n   The algorithm for the puzzle
          is selected as described in\n   Section 7.1.1.2.  There is no requirement
          that the algorithm for the\n   puzzle in the IKE_SA INIT exchange be the
          same as the algorithm for\n   the puzzle in the IKE_AUTH exchange; however,
          it is expected that in\n   most cases they will be the same.\n"
        title: 7.2.1.2.  Selecting the Puzzle Algorithm
      title: 7.2.1.  Presenting the Puzzle
    - contents:
      - "7.2.2.  Solving the Puzzle and Returning the Solution\n   If the IKE_SA_INIT
        regular response message (i.e., the message\n   containing SA, KE, NONCE payloads)
        contains the PUZZLE notification\n   and the Initiator supports puzzles, it
        MUST solve the puzzle.  Note\n   that puzzle construction in the IKE_AUTH
        exchange differs from the\n   puzzle construction in the IKE_SA_INIT exchange
        and is described in\n   Section 7.2.3.  Once the puzzle is solved, the Initiator
        sends the\n   IKE_AUTH request message containing the PS payload.\n   HDR,
        PS, SK {IDi, [CERT,] [CERTREQ,]\n               [IDr,] AUTH, SA, TSi, TSr}
        \  -->\n      Figure 5: IKE_AUTH Request Containing IKE_AUTH Puzzle Solution\n
        \  The PS payload MUST be placed outside the Encrypted payload, so that\n
        \  the Responder is able to verify the puzzle before calculating the DH\n
        \  shared secret and the SK_* keys.\n   If IKE fragmentation [RFC7383] is
        used in the IKE_AUTH exchange, then\n   the PS payload MUST be present only
        in the first IKE Fragment\n   message, in accordance with Section 2.5.3 of
        [RFC7383].  Note that\n   calculation of the puzzle in the IKE_AUTH exchange
        doesn't depend on\n   the content of the IKE_AUTH message (see Section 7.2.3).
        \ Thus, the\n   Initiator has to solve the puzzle only once, and the solution
        is\n   valid for both unfragmented and fragmented IKE messages.\n"
      title: 7.2.2.  Solving the Puzzle and Returning the Solution
    - contents:
      - "7.2.3.  Computing the Puzzle\n   A puzzle in the IKE_AUTH exchange is computed
        differently than in the\n   IKE_SA_INIT exchange (see Section 7.1.3).  The
        general principle is\n   the same; the difference is in the construction of
        the string S.\n   Unlike the IKE_SA_INIT exchange, where S is the cookie,
        in the\n   IKE_AUTH exchange, S is a concatenation of Nr and SPIr.  In other\n
        \  words, the task for the IKE Initiator is to find the four different\n   keys
        Ki for the agreed upon PRF such that each result of PRF(Ki,Nr |\n   SPIr)
        where i=[1..4] has a sufficient number of trailing zero bits.\n   Nr is a
        nonce used by the Responder in the IKE_SA_INIT exchange,\n   stripped of any
        headers.  SPIr is the IKE Responder's SPI from the\n   IKE header of the SA
        being established.\n"
      title: 7.2.3.  Computing the Puzzle
    - contents:
      - "7.2.4.  Receiving the Puzzle Solution\n   If the Responder requested the
        Initiator to solve a puzzle in the\n   IKE_AUTH exchange, then it MUST silently
        discard all the IKE_AUTH\n   request messages without the PS payload.\n   Once
        the message containing a solution to the puzzle is received, the\n   Responder
        MUST verify the solution before performing computationally\n   intensive operations,
        i.e., computing the DH shared secret and the\n   SK_* keys.  The Responder
        MUST verify all four of the returned keys.\n   The Responder MUST silently
        discard the received message if any\n   checked verification result is not
        correct (contains insufficient\n   number of trailing zero bits).  If the
        Responder successfully\n   verifies the puzzle and calculates the SK_* key,
        but the message\n   authenticity check fails, then it SHOULD save the calculated
        keys in\n   the IKE SA state while waiting for the retransmissions from the\n
        \  Initiator.  In this case, the Responder may skip verification of the\n
        \  puzzle solution and ignore the PS payload in the retransmitted\n   messages.\n
        \  If the Initiator uses IKE fragmentation, then it sends all fragments\n
        \  of a message simultaneously.  Due to packets loss and/or reordering,\n
        \  it is possible that the Responder receives subsequent fragments\n   before
        receiving the first one that contains the PS payload.  In this\n   case, the
        Responder MAY choose to keep the received fragments until\n   the first fragment
        containing the solution to the puzzle is received.\n   In this case, the Responder
        SHOULD NOT try to verify authenticity of\n   the kept fragments until the
        first fragment with the PS payload is\n   received, and the solution to the
        puzzle is verified.  After\n   successful verification of the puzzle, the
        Responder can then\n   calculate the SK_* key and verify authenticity of the
        collected\n   fragments.\n"
      title: 7.2.4.  Receiving the Puzzle Solution
    title: 7.2.  Puzzles in an IKE_AUTH Exchange
  title: 7.  Using Puzzles in the Protocol
- contents:
  - '8.  Payload Formats

    '
  - contents:
    - "8.1.  PUZZLE Notification\n   The PUZZLE notification is used by the IKE Responder
      to inform the\n   Initiator about the need to solve the puzzle.  It contains
      the\n   difficulty level of the puzzle and the PRF the Initiator should use.\n
      \                       1                   2                   3\n    0 1 2
      3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  | Next Payload  |C|  RESERVED   |         Payload Length        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |Protocol ID(=0)| SPI Size (=0) |      Notify Message Type      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |              PRF              |  Difficulty   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  o  Protocol ID (1 octet) -- MUST be 0.\n   o  SPI Size (1 octet) -- MUST
      be 0, meaning no SPI is present.\n   o  Notify Message Type (2 octets) -- MUST
      be 16434, the value\n      assigned for the PUZZLE notification.\n   o  PRF
      (2 octets) -- Transform ID of the PRF algorithm that MUST be\n      used to
      solve the puzzle.  Readers should refer to the \"Transform\n      Type 2 - Pseudorandom
      Function Transform IDs\" subregistry on\n      [IKEV2-IANA] for the list of
      possible values.\n   o  Difficulty (1 octet) -- Difficulty level of the puzzle.
      \ Specifies\n      the minimum number of trailing zero bits (ZBC) that each
      of the\n      results of PRF must contain.  Value 0 means that the Responder\n
      \     doesn't request any specific difficulty level, and the Initiator\n      is
      free to select an appropriate difficulty level on its own (see\n      Section
      7.1.1.1 for details).\n   This notification contains no data.\n"
    title: 8.1.  PUZZLE Notification
  - contents:
    - "8.2.  Puzzle Solution Payload\n   The solution to the puzzle is returned back
      to the Responder in a\n   dedicated payload, called the PS payload.\n                        1
      \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  | Next Payload  |C|  RESERVED   |         Payload Length        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                                                               |\n   ~                     Puzzle
      Solution Data                      ~\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   o  Puzzle
      Solution Data (variable length) -- Contains the solution to\n      the puzzle
      -- four different keys for the selected PRF.  This\n      field MUST NOT be
      empty.  All of the keys MUST have the same size;\n      therefore, the size
      of this field is always a multiple of 4 bytes.\n      If the selected PRF accepts
      only fixed-size keys, then the size of\n      each key MUST be of that fixed
      size.  If the agreed upon PRF\n      accepts keys of any size, then the size
      of each key MUST be\n      between 1 octet and the preferred key length of the
      PRF\n      (inclusive).  It is expected that in most cases, the keys will be\n
      \     4 (or even less) octets in length; however, it depends on puzzle\n      difficulty
      and on the Initiator's strategy to find solutions, and\n      thus the size
      is not mandated by this specification.  The\n      Responder determines the
      size of each key by dividing the size of\n      the Puzzle Solution Data by
      4 (the number of keys).  Note that the\n      size of Puzzle Solution Data is
      the size of the Payload (as\n      indicated in the Payload Length field) minus
      4 -- the size of the\n      Payload header.\n   The payload type for the PS
      payload is 54.\n"
    title: 8.2.  Puzzle Solution Payload
  title: 8.  Payload Formats
- contents:
  - "9.  Operational Considerations\n   The puzzle difficulty level should be set
    by balancing the\n   requirement to minimize the latency for legitimate Initiators
    with\n   making things difficult for attackers.  A good rule of thumb is\n   taking
    about 1 second to solve the puzzle.  At the time this document\n   was written,
    a typical Initiator or botnet member can perform\n   slightly less than a million
    hashes per second per core, so setting\n   the number of zero bits to 20 is a
    good compromise.  It should be\n   noted that mobile Initiators, especially phones,
    are considerably\n   weaker than that.  Implementations should allow administrators
    to set\n   the difficulty level and/or be able to set the difficulty level\n   dynamically
    in response to load.\n   Initiators SHOULD set a maximum difficulty level beyond
    which they\n   won't try to solve the puzzle and log or display a failure message
    to\n   the administrator or user.\n   Until the widespread adoption of puzzles
    happens, most Initiators\n   will ignore them, as will all attackers.  For puzzles
    to become a\n   really powerful defense measure against DDoS attacks, they must
    be\n   supported by the majority of legitimate clients.\n"
  title: 9.  Operational Considerations
- contents:
  - "10.  Security Considerations\n   Care must be taken when selecting parameters
    for the puzzles, in\n   particular the puzzle difficulty.  If the puzzles are
    too easy for\n   the majority of attackers, then the puzzle mechanism wouldn't
    be able\n   to prevent DoS or DDoS attacks and would only impose an additional\n
    \  burden on legitimate Initiators.  On the other hand, if the puzzles\n   are
    too hard for the majority of Initiators, then many legitimate\n   users would
    experience unacceptable delays in IKE SA setup (and\n   unacceptable power consumption
    on mobile devices) that might cause\n   them to cancel the connection attempt.
    \ In this case, the resources\n   of the Responder are preserved; however, the
    DoS attack can be\n   considered successful.  Thus, a sensible balance should
    be kept by\n   the Responder while choosing the puzzle difficulty -- to defend\n
    \  itself and to not over-defend itself.  It is RECOMMENDED that the\n   puzzle
    difficulty be chosen, so that the Responder's load remains\n   close to the maximum
    it can tolerate.  It is also RECOMMENDED to\n   dynamically adjust the puzzle
    difficulty in accordance to the current\n   Responder's load.\n   If the cookie
    is generated as suggested in Section 2.6 of [RFC7296],\n   then an attacker can
    use the same SPIi and the same Ni for several\n   requests from the same IPi.
    \ This will result in generating the same\n   cookies for these requests until
    the Responder changes the value of\n   its cookie generation secret.  Since the
    cookies are used as an input\n   data for puzzles in the IKE_SA_INIT exchange,
    generating the same\n   cookies allows the attacker to reuse puzzle solutions,
    thus bypassing\n   the proof-of-work requirement.  Note that the attacker can
    get only\n   limited benefit from this situation -- once the half-open SA is\n
    \  created by the Responder, all the subsequent initial requests with\n   the
    same IPi and SPIi will be treated as retransmissions and\n   discarded by the
    Responder.  However, once this half-open SA is\n   expired and deleted, the attacker
    can create a new one for free if\n   the Responder hasn't changed its cookie generation
    secret yet.\n   The Responder can use various countermeasures to completely eliminate\n
    \  or mitigate this scenario.  First, the Responder can change its\n   cookie
    generation secret frequently especially if under attack, as\n   recommended in
    Section 2.6 of [RFC7296].  For example, if the\n   Responder keeps two values
    of the secret (current and previous) and\n   the secret lifetime is no more than
    a half of the current half-open\n   SA retention time (see Section 4.1), then
    the attacker cannot get\n   benefit from reusing a puzzle solution.  However,
    short cookie\n   generation secret lifetime could have a negative consequence
    on weak\n   legitimate Initiators, since it could take too long for them to solve\n
    \  puzzles, and their solutions would be discarded if the cookie\n   generation
    secret has been already changed few times.\n   Another approach for the Responder
    is to modify the cookie generation\n   algorithm in such a way that the generated
    cookies are always\n   different or are repeated only within a short time period.
    \ If the\n   Responder includes a timestamp in <AdditionalInfo> as suggested in\n
    \  Section 7.1.1.3, then the cookies will repeat only within a short\n   time
    interval equal to timestamp resolution.  Another approach for\n   the Responder
    is to maintain a global counter that is incremented\n   every time a cookie is
    generated and include this counter in\n   <AdditionalInfo>.  This will make every
    cookie unique.\n   Implementations MUST use one of the above (or some other)\n
    \  countermeasures to completely eliminate or make insignificant the\n   possible
    benefit an attacker can get from reusing puzzle solutions.\n   Note that this
    issue doesn't exist in IKE_AUTH puzzles (Section 7.2)\n   since the puzzles in
    IKE_AUTH are always unique if the Responder\n   generates SPIr and Nr randomly
    in accordance with [RFC7296].\n   Solving puzzles requires a lot of CPU usage
    that increases power\n   consumption.  This additional power consumption can negatively
    affect\n   battery-powered Initiators, e.g., mobile phones or some Internet of\n
    \  Things (IoT) devices.  If puzzles are too hard, then the required\n   additional
    power consumption may appear to be unacceptable for some\n   Initiators.  The
    Responder SHOULD take this possibility into\n   consideration while choosing the
    puzzle difficulty and while\n   selecting which percentage of Initiators are allowed
    to reject\n   solving puzzles.  See Section 7.1.4 for details.\n   If the Initiator
    uses NULL Authentication [RFC7619], then its\n   identity is never verified.  This
    condition may be used by attackers\n   to perform a DoS attack after the IKE SA
    is established.  Responders\n   that allow unauthenticated Initiators to connect
    must be prepared to\n   deal with various kinds of DoS attacks even after the
    IKE SA is\n   created.  See Section 5 for details.\n   To prevent amplification
    attacks, implementations must strictly\n   follow the retransmission rules described
    in Section 2.1 of\n   [RFC7296].\n"
  title: 10.  Security Considerations
- contents:
  - "11.  IANA Considerations\n   This document defines a new payload in the \"IKEv2
    Payload Types\"\n   registry:\n     54       Puzzle Solution                   PS\n
    \  This document also defines a new Notify Message Type in the \"IKEv2\n   Notify
    Message Types - Status Types\" registry:\n     16434    PUZZLE\n"
  title: 11.  IANA Considerations
- contents:
  - '12.  References

    '
  - contents:
    - "12.1.  Normative References\n   [IKEV2-IANA]\n              IANA, \"Internet
      Key Exchange Version 2 (IKEv2)\n              Parameters\",\n              <http://www.iana.org/assignments/ikev2-parameters>.\n
      \  [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement
      Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n
      \             <http://www.rfc-editor.org/info/rfc2119>.\n   [RFC5723]  Sheffer,
      Y. and H. Tschofenig, \"Internet Key Exchange\n              Protocol Version
      2 (IKEv2) Session Resumption\", RFC 5723,\n              DOI 10.17487/RFC5723,
      January 2010,\n              <http://www.rfc-editor.org/info/rfc5723>.\n   [RFC7296]
      \ Kaufman, C., Hoffman, P., Nir, Y., Eronen, P., and T.\n              Kivinen,
      \"Internet Key Exchange Protocol Version 2\n              (IKEv2)\", STD 79,
      RFC 7296, DOI 10.17487/RFC7296, October\n              2014, <http://www.rfc-editor.org/info/rfc7296>.\n
      \  [RFC7383]  Smyslov, V., \"Internet Key Exchange Protocol Version 2\n              (IKEv2)
      Message Fragmentation\", RFC 7383,\n              DOI 10.17487/RFC7383, November
      2014,\n              <http://www.rfc-editor.org/info/rfc7383>.\n"
    title: 12.1.  Normative References
  - contents:
    - "12.2.  Informative References\n   [BITCOINS] Nakamoto, S., \"Bitcoin: A Peer-to-Peer
      Electronic Cash\n              System\", October 2008, <https://bitcoin.org/bitcoin.pdf>.\n
      \  [RFC7619]  Smyslov, V. and P. Wouters, \"The NULL Authentication\n              Method
      in the Internet Key Exchange Protocol Version 2\n              (IKEv2)\", RFC
      7619, DOI 10.17487/RFC7619, August 2015,\n              <http://www.rfc-editor.org/info/rfc7619>.\n
      \  [RFC7696]  Housley, R., \"Guidelines for Cryptographic Algorithm\n              Agility
      and Selecting Mandatory-to-Implement Algorithms\",\n              BCP 201, RFC
      7696, DOI 10.17487/RFC7696, November 2015,\n              <http://www.rfc-editor.org/info/rfc7696>.\n"
    title: 12.2.  Informative References
  title: 12.  References
- contents:
  - "Acknowledgements\n   The authors thank Tero Kivinen, Yaron Sheffer, and Scott
    Fluhrer for\n   their contributions to the design of the protocol.  In particular,\n
    \  Tero Kivinen suggested the kind of puzzle where the task is to find a\n   solution
    with a requested number of zero trailing bits.  Yaron\n   Sheffer and Scott Fluhrer
    suggested a way to make puzzle difficulty\n   less erratic by solving several
    weaker puzzles.  The authors also\n   thank David Waltermire and Paul Wouters
    for their careful reviews of\n   the document, Graham Bartlett for pointing out
    the possibility of an\n   attack related to \"Hash & URL\", Stephen Farrell for
    catching the\n   repeated cookie issue, and all others who commented on the document.\n"
  title: Acknowledgements
- contents:
  - "Authors' Addresses\n   Yoav Nir\n   Check Point Software Technologies Ltd.\n
    \  5 Hasolelim st.\n   Tel Aviv  6789735\n   Israel\n   Email: ynir.ietf@gmail.com\n
    \  Valery Smyslov\n   ELVIS-PLUS\n   PO Box 81\n   Moscow (Zelenograd)  124460\n
    \  Russian Federation\n   Phone: +7 495 276 0211\n   Email: svan@elvis.ru\n"
  title: Authors' Addresses
