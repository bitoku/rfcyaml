- contents:
  - "         Generalized MPLS (GMPLS) RSVP-TE Signaling Extensions\n                          in
    Support of Calls\n"
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The IETF Trust (2007).\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   In certain networking topologies, it may be advantageous to maintain\n
    \  associations between endpoints and key transit points to support an\n   instance
    of a service.  Such associations are known as Calls.\n   A Call does not provide
    the actual connectivity for transmitting user\n   traffic, but only builds a relationship
    by which subsequent\n   Connections may be made.  In Generalized MPLS (GMPLS)
    such\n   Connections are known as Label Switched Paths (LSPs).\n   This document
    specifies how GMPLS Resource Reservation Protocol -\n   Traffic Engineering (RSVP-TE)
    signaling may be used and extended to\n   support Calls.  These mechanisms provide
    full and logical\n   Call/Connection separation.\n   The mechanisms proposed in
    this document are applicable to any\n   environment (including multi-area), and
    for any type of interface:\n   packet, layer-2, time-division multiplexed, lambda,
    or fiber\n   switching.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n
    \     1.1. Applicability to ASON ......................................4\n   2.
    Conventions Used in This document ...............................4\n   3. Requirements
    ....................................................4\n      3.1. Basic Call Function
    ........................................4\n      3.2. Call/Connection Separation
    .................................5\n      3.3. Call Segments ..............................................5\n
    \  4. Concepts and Terms ..............................................5\n      4.1.
    What Is a Call? ............................................5\n      4.2. A Hierarchy
    of Calls, Connections, Tunnels, and LSPs .......6\n      4.3. Exchanging Access
    Link Capabilities ........................6\n           4.3.1. Network-Initiated
    Calls .............................7\n           4.3.2. User-Initiated Calls ................................7\n
    \          4.3.3. Utilizing Call Setup ................................8\n   5.
    Protocol Extensions for Calls and Connections ...................8\n      5.1.
    Call Setup and Teardown ....................................8\n      5.2. Call
    Identification ........................................9\n           5.2.1. Long
    Form Call Identification .......................9\n           5.2.2. Short Form
    Call Identification ......................9\n           5.2.3. Short Form Call
    ID Encoding ........................10\n      5.3. LINK_CAPABILITY Object ....................................11\n
    \     5.4. Revised Message Formats ...................................12\n           5.4.1.
    Notify Message .....................................12\n      5.5. ADMIN_STATUS
    Object .......................................13\n   6. Procedures in Support
    of Calls and Connections .................14\n      6.1. Call/Connection Setup
    Procedures ..........................14\n      6.2. Call Setup ................................................14\n
    \          6.2.1. Accepting Call Setup ...............................16\n           6.2.2.
    Call Setup Failure and Rejection ...................16\n      6.3. Adding a Connections
    to a Call ............................17\n           6.3.1. Adding a Reverse Direction
    LSP to a Call ...........18\n      6.4. Call-Free Connection Setup ................................18\n
    \     6.5. Call Collision ............................................18\n      6.6.
    Call/Connection Teardown ..................................19\n           6.6.1.
    Removal of a Connection from a Call ................20\n           6.6.2. Removal
    of the Last Connection from a Call .........20\n           6.6.3. Teardown of
    an \"Empty\" Call ........................20\n           6.6.4. Attempted Teardown
    of a Call with Existing\n                  Connections ........................................20\n
    \          6.6.5. Teardown of a Call from the Egress .................21\n      6.7.
    Control Plane Survivability ...............................21\n   7. Applicability
    of Call and Connection Procedures ................22\n      7.1. Network-Initiated
    Calls ...................................22\n      7.2. User-Initiated Calls ......................................23\n
    \     7.3. External Call Managers ....................................23\n           7.3.1.
    Call Segments ......................................23\n   8. Non-Support of Call
    ID .........................................24\n      8.1. Non-Support by External
    Call Managers .....................24\n      8.2. Non-Support by Transit Node
    ...............................24\n      8.3. Non-Support by Egress Node ................................25\n
    \  9. Security Considerations ........................................25\n      9.1.
    Call and Connection Security Considerations ...............25\n   10. IANA Considerations
    ...........................................26\n      10.1. RSVP Objects .............................................26\n
    \     10.2. RSVP Error Codes and Error Values ........................27\n      10.3.
    RSVP ADMIN_STATUS Object Bits ............................27\n   11. Acknowledgements
    ..............................................27\n   12. References ....................................................28\n
    \     12.1. Normative References .....................................28\n      12.2.
    Informative References ...................................29\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   This document defines protocol procedures and extensions
    to support\n   Calls within Generalized MPLS (GMPLS).\n   A Call is an association
    between endpoints and possibly between key\n   transit points (such as network
    boundaries) in support of an instance\n   of a service.  The end-to-end association
    is termed a \"Call\", and the\n   association between two transit points or between
    an endpoint and a\n   transit point is termed a \"Call Segment\".  An entity that
    processes a\n   Call or Call Segment is called a \"Call Manager\".\n   A Call
    does not provide the actual connectivity for transmitting user\n   traffic, but
    only builds a relationship by which subsequent\n   Connections may be made.  In
    GMPLS, such Connections are known as\n   Label Switched Paths (LSPs).  This document
    does not modify\n   Connection setup procedures defined in [RFC3473], [RFC4208],
    and\n   [STITCH].  Connections set up as part of a Call follow the rules\n   defined
    in these documents.\n   A Call may be associated with zero, one, or more than
    one Connection,\n   and a Connection may be associated with zero or one Call.
    \ Thus, full\n   and logical Call/Connection separation is needed.\n   An example
    of the requirements for Calls can be found in the ITU-T's\n   Automatically Switched
    Optical Network (ASON) architecture [G.8080]\n   and specific requirements for
    support of Calls in this context can be\n   found in [RFC4139].  Note, however,
    that while the mechanisms\n   described in this document meet the requirements
    stated in [RFC4139],\n   they have wider applicability.\n   The mechanisms defined
    in this document are equally applicable to any\n   packet (PSC) interface, layer-2
    interfaces (L2SC), TDM capable\n   interfaces, LSC interfaces, or FSC interfaces.
    \ The mechanisms and\n   protocol extensions are backward compatible, and can
    be used for Call\n   management where only the Call Managers need to be aware
    of the\n   protocol extensions.\n"
  - contents:
    - "1.1.  Applicability to ASON\n   [RFC4139] details the requirements on GMPLS
      signaling to satisfy the\n   ASON architecture described in [G.8080].  The mechanisms
      described in\n   this document meet the requirements for Calls as described
      in\n   Sections 4.2 and 4.3 of [RFC4139] and the additional Call-related\n   requirements
      in Sections 4.4, 4.7, 5, and 6 of [RFC4139].\n   [ASON-APPL] describes the applicability
      of GMPLS protocols to the\n   ASON architecture.\n"
    title: 1.1.  Applicability to ASON
  title: 1.  Introduction
- contents:
  - "2.  Conventions Used in This document\n   The key words \"MUST\", \"MUST NOT\",
    \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",
    \ \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described
    in [RFC2119].\n   In addition, the reader is assumed to be familiar with the\n
    \  terminology used in [RFC3471], [RFC3473], [RFC3477], and [RFC3945].\n"
  title: 2.  Conventions Used in This document
- contents:
  - '3.  Requirements

    '
  - contents:
    - "3.1.  Basic Call Function\n   The Call concept is used to deliver the following
      capabilities:\n   -  Verification and identification of the Call initiator (prior
      to\n      LSP setup).\n   -  Support of virtual concatenation with diverse path
      component LSPs.\n   -  Association of multiple LSPs with a single Call (note
      aspects\n      related to recovery are detailed in [RFC4426] and [GMPLS-E2E]).\n
      \  -  Facilitation of control plane operations by allowing an\n      operational
      status change of the associated LSP.\n   Procedures and protocol extensions
      to support Call setup, and the\n   association of Calls with Connections are
      described in Section 5 and\n   onwards of this document.\n"
    title: 3.1.  Basic Call Function
  - contents:
    - "3.2.  Call/Connection Separation\n   Full and logical Call and Connection separation
      is required.  That\n   is:\n   -  It MUST be possible to establish a Connection
      without dependence\n      on a Call.\n   -  It MUST be possible to establish
      a Call without any associated\n      Connections.\n   -  It MUST be possible
      to associate more than one Connection with a\n      Call.\n   -  Removal of
      the last Connection associated with a Call SHOULD NOT\n      result in the automatic
      removal of the Call except as a matter of\n      local policy at the ingress
      of the Call.\n   -  Signaling of a Connection associated with a Call MUST NOT
      require\n      the distribution or retention of Call-related information (state)\n
      \     within the network.\n"
    title: 3.2.  Call/Connection Separation
  - contents:
    - "3.3.  Call Segments\n   Call Segment capabilities MUST be supported.\n   Procedures
      and (GMPLS) RSVP-TE signaling protocol extensions to\n   support Call Segments
      are described in Section 7.3.1 of this\n   document.\n"
    title: 3.3.  Call Segments
  title: 3.  Requirements
- contents:
  - "4. Concepts and Terms\n   The concept of a Call and a Connection are also discussed
    in the ASON\n   architecture [G.8080] and [RFC4139].  This section is not intended
    as\n   a substitute for those documents, but is a brief summary of the key\n   terms
    and concepts.\n"
  - contents:
    - "4.1.  What Is a Call?\n   A Call is an agreement between endpoints possibly
      in cooperation with\n   the nodes that provide access to the network.  Call
      setup may include\n   capability exchange, policy, authorization, and security.\n
      \  A Call is used to facilitate and manage a set of Connections that\n   provide
      end-to-end data services.  While Connections require state to\n   be maintained
      at nodes along the data path within the network, Calls\n   do not involve the
      participation of transit nodes except to forward\n   the Call management requests
      as transparent messages.\n   A Call may be established and maintained independently
      of the\n   Connections that it supports.\n"
    title: 4.1.  What Is a Call?
  - contents:
    - "4.2.  A Hierarchy of Calls, Connections, Tunnels, and LSPs\n   Clearly, there
      is a hierarchical relationship between Calls and\n   Connections.  One or more
      Connections may be associated with a Call.\n   A Connection may not be part
      of more than one Call.  A Connection\n   may, however, exist without a Call.\n
      \  In GMPLS RSVP-TE [RFC3473], a Connection is identified with a GMPLS\n   TE
      Tunnel.  Commonly, a Tunnel is identified with a single LSP, but\n   it should
      be noted that for protection, load balancing, and many\n   other functions,
      a Tunnel may be supported by multiple parallel LSPs.\n   The following identification
      reproduces this hierarchy.\n   -  Call IDs are unique within the context of
      the pair of addresses\n      that are the source and destination of the Call.\n
      \  -  Tunnel IDs are unique within the context of the Session (that is\n      the
      destination of the Tunnel).  Applications may also find it\n      convenient
      to keep the Tunnel ID unique within the context of a\n      Call.\n   -  LSP
      IDs are unique within the context of a Tunnel.\n   Note that the Call_ID value
      of zero is reserved and MUST NOT be used\n   during LSP-independent Call establishment.\n
      \  Throughout the remainder of this document, the terms LSP and Tunnel\n   are
      used interchangeably with the term Connection.  The case of a\n   Tunnel that
      is supported by more than one LSP is covered implicitly.\n"
    title: 4.2.  A Hierarchy of Calls, Connections, Tunnels, and LSPs
  - contents:
    - "4.3.  Exchanging Access Link Capabilities\n   In an overlay model, it is useful
      for the ingress node of an LSP to\n   know the link capabilities of the link
      between the network and the\n   remote overlay network.  In the language of
      [RFC4208], the ingress\n   node can make use of information about the link between
      the egress\n   core node (CN) and the remote edge node (EN).  We call this link
      the\n   egress network link.  This information may allow the ingress node to\n
      \  tailor its LSP request to fit those capabilities and to better\n   utilize
      network resources with regard to those capabilities.\n   For example, this might
      be used in transparent optical networks to\n   supply information on lambda
      availability on egress network links,\n   or, where the egress CN is capable
      of signal regeneration, it might\n   provide a mechanism for negotiating signal
      quality attributes (such\n   as bit error rate).  Similarly, in multi-domain
      routing environments,\n   it could be used to provide end-to-end selection of
      component links\n   (i.e., spatial attribute negotiation) where TE links have
      been\n   bundled based on technology specific attributes.\n   In some circumstances,
      the Traffic Engineering Database (TED) may\n   contain sufficient information
      for decisions to be made about which\n   egress network link to use.  In other
      circumstances, the TED might\n   not contain this information and Call setup
      may provide a suitable\n   mechanism to exchange information for this purpose.
      \ The Call-\n   responder may use the Call parameters to select a subset of
      the\n   available egress network links between the egress CN and the remote\n
      \  EN, and may report these links and their capabilities on the Call\n   response
      so that the Call-initiator may select a suitable link.\n   The sections that
      follow indicate the cases where the TED may be\n   used, and those where Call
      parameter exchange may be appropriate.\n"
    - contents:
      - "4.3.1.  Network-Initiated Calls\n   Network-initiated Calls arise when the
        ingress (and correspondingly\n   the egress) lie within the network and there
        may be no need to\n   distribute additional link capability information over
        and above the\n   information distributed by the TE and GMPLS extensions to
        the IGP.\n   Further, it is possible that future extensions to these IGPs
        will\n   allow the distribution of more detailed information including optical\n
        \  impairments.\n"
      title: 4.3.1.  Network-Initiated Calls
    - contents:
      - "4.3.2.  User-Initiated Calls\n   User-initiated Calls arise when the ingress
        (and correspondingly the\n   egress) lie outside the network.  Edge link information
        may not be\n   visible within the core network, nor (and specifically) at
        other edge\n   nodes.  This may prevent an ingress from requesting suitable
        LSP\n   characteristics to ensure successful LSP setup.\n   Various solutions
        to this problem exist, including the definition of\n   static TE links (that
        is, not advertised by a routing protocol)\n   between the CNs and ENs.  Nevertheless,
        special procedures may be\n   necessary to advertise to the edge nodes outside
        of the network\n   information about egress network links without also advertising
        the\n   information specific to the contents of the network.\n   In the future,
        when the requirements on the information that needs to\n   be supported are
        better understood, TE extensions to EGPs may be\n   defined to provide this
        function, and new rules for leaking TE\n   information between routing instances
        may be used.\n"
      title: 4.3.2.  User-Initiated Calls
    - contents:
      - "4.3.3.  Utilizing Call Setup\n   When IGP and EGP solutions are not available
        at the User-to-Network\n   Interface (UNI), there is still a requirement to
        have the knowledge\n   of the remote edge link capabilities at the local edge
        nodes.\n   The Call setup procedure provides an opportunity to discover edge\n
        \  link capabilities of remote edge nodes before LSP setup is attempted.\n
        \  -  The Call-responder can return information on one or more egress\n      network
        links.  The Call-responder could return a full list of the\n      available
        links with information about the link capabilities, or\n      it could filter
        the list to return information about only those\n      links that might be
        appropriate to support the Connections needed\n      by the Call.  To do this
        second option, the Call-responder must\n      determine such appropriate links
        from information carried in the\n      Call request including destination
        of the Call, and the level of\n      service (bandwidth, protection, etc.)
        required.\n   -  On receiving a Call response, the Call-initiator must determine\n
        \     paths for the Connections (LSPs) that it will set up.  The way\n      that
        it does this is out of scope for this document since it is an\n      implementation-specific,
        algorithmic process.  However, it can\n      take as input the information
        about the available egress network\n      links as supplied in the Call response.\n
        \  The LINK_CAPABILITY object is defined to allow this information to be\n
        \  exchanged.  The information that is included in this object is\n   similar
        to that distributed by GMPLS-capable IGPs (see [RFC4202]).\n"
      title: 4.3.3.  Utilizing Call Setup
    title: 4.3.  Exchanging Access Link Capabilities
  title: 4. Concepts and Terms
- contents:
  - "5.  Protocol Extensions for Calls and Connections\n   This section describes
    the protocol extensions needed in support of\n   Call identification and management
    of Calls and Connections.\n   Procedures for the use of these protocol extensions
    are described in\n   Section 6.\n"
  - contents:
    - "5.1.  Call Setup and Teardown\n   Calls are established independently of Connections
      through the use of\n   the Notify message.  The Notify message is a targeted
      message and\n   does not need to follow the path of LSPs through the network.\n
      \  Simultaneous Call and Connection establishment (sometimes referred to\n   as
      piggybacking) is not supported.\n"
    title: 5.1.  Call Setup and Teardown
  - contents:
    - "5.2.  Call Identification\n   As soon as the concept of a Call is introduced,
      it is necessary to\n   support some means of identifying the Call.  This becomes\n
      \  particularly important when Calls and Connections are separated and\n   Connections
      must contain some reference to the Call.\n   A Call may be identified by a sequence
      of bytes that may have\n   considerable (but not arbitrary) length.  A Call
      ID of 40 bytes would\n   not be unreasonable.  It is not the place of this document
      to supply\n   rules for encoding or parsing Call IDs, but it must provide a\n
      \  suitable means to communicate Call IDs within the protocol.  The full\n   Call
      identification is referred to as the long Call ID.\n   The Call_ID is only relevant
      at the sender and receiver nodes.\n   Maintenance of this information in the
      signaling state is not\n   mandated at any intermediate node.  Thus, no change
      in [RFC3473]\n   transit implementations is required and there are no backward\n
      \  compatibility issues.  Forward compatibility is maintained by using\n   the
      existing default values to indicate that no Call processing is\n   required.\n
      \  Further, the long Call ID is not required as part of the Connection\n   (LSP)
      state even at the sender and receiver nodes so long as some\n   form of correlation
      is available.  This correlation is provided\n   through the short Call ID.\n"
    - contents:
      - "5.2.1.  Long Form Call Identification\n   The long Call ID is only required
        on the Notify message used to\n   establish the Call.  It is carried in the
        \"Session Name\" field of the\n   SESSION_ATTRIBUTE object on the Notify message.\n
        \  A unique value per Call is inserted in the \"Session Name\" field by\n
        \  the initiator of the Call.  Subsequent core nodes MAY inspect this\n   object
        and MUST forward this object transparently across network\n   interfaces until
        reaching the egress node.  Note that the structure\n   of this field MAY be
        the object of further formatting depending on\n   the naming convention(s).
        \ However, [RFC3209] defines the \"Session\n   Name\" field as a Null padded
        display string, so any formatting\n   conventions for the Call ID must be
        limited to this scope.\n"
      title: 5.2.1.  Long Form Call Identification
    - contents:
      - "5.2.2.  Short Form Call Identification\n   The Connections (LSPs) associated
        with a Call need to carry a\n   reference to the Call - the short Call ID.
        \ A new field is added to\n   the signaling protocol to identify an individual
        LSP with the Call to\n   which it belongs.\n   The new field is a 16-bit identifier
        (unique within the context of\n   the address pairing provided by the Tunnel_End_Point_Address
        and the\n   Sender_Address of the SENDER_TEMPLATE object) that MUST be exchanged\n
        \  on the Notify message during Call initialization and is used on all\n   subsequent
        LSP messages that are associated with the Call.  This\n   identifier is known
        as the short Call ID and is encoded as described\n   in Section 5.2.3.  The
        Call ID MUST NOT be used as part of the\n   processing to determine the session
        to which an RSVP signaling\n   message applies.  This does not generate any
        backward compatibility\n   issue since the reserved field of the SESSION object
        defined in\n   [RFC3209] MUST NOT be examined on receipt.\n   In the unlikely
        case of short Call_ID exhaustion, local node policy\n   decides upon specific
        actions to be taken, but might include the use\n   of second Sender_Address.
        \ Local policy details are outside of the\n   scope of this document.\n"
      title: 5.2.2.  Short Form Call Identification
    - contents:
      - "5.2.3.  Short Form Call ID Encoding\n   The short Call ID is carried in a
        16-bit field in the SESSION object\n   carried on the Notify message used
        during Call setup, and on all\n   messages during LSP setup and management.
        \ The field used was\n   previously reserved (MUST be set to zero on transmission
        and ignored\n   on receipt).  This ensures backward compatibility with nodes
        that do\n   not utilize Calls.\n   The figure below shows the new version
        of the object.\n   Class = SESSION, Class-Num = 1, C-Type = 7(IPv4)/8(IPv6)\n
        \      0                   1                   2                   3\n       0
        1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     ~               IPv4/IPv6 Tunnel End Point Address              ~\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |            Call_ID            |           Tunnel ID           |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |                       Extended Tunnel ID                      |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  IPv4/IPv6 Tunnel End Point Address: 32 bits/128 bits (see [RFC3209])\n
        \  Call_ID: 16 bits\n      A 16-bit identifier used in the SESSION object
        that remains\n      constant over the life of the Call.  The Call_ID value
        MUST be set\n      to zero when there is no corresponding Call.\n   Tunnel
        ID: 16 bits (see [RFC3209])\n   Extended Tunnel ID: 32 bits/128 bits (see
        [RFC3209])\n"
      title: 5.2.3.  Short Form Call ID Encoding
    title: 5.2.  Call Identification
  - contents:
    - "5.3.  LINK_CAPABILITY Object\n   The LINK_CAPABILITY object is introduced to
      support link capability\n   exchange during Call setup and MAY be included in
      a Notify message\n   used for Call setup.  This optional object includes the
      link-local\n   capabilities of a link joining the Call-initiating node (or Call-\n
      \  terminating node) to the network.  The specific node is indicated by\n   the
      source address of the Notify message.\n   The link reported can be a single
      link or can be a bundled link\n   [RFC4201].\n   The Class Number is selected
      so that the nodes that do not recognize\n   this object drop it silently.  That
      is, the top bit is set and the\n   next bit is clear.\n   This object has the
      following format:\n   Class-Num = 133 (form 10bbbbbb), C_Type = 1\n       0
      \                  1                   2                   3\n       0 1 2 3
      4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |                                                               |\n      //
      \                       (Subobjects)                         //\n      |                                                               |\n
      \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   The
      contents of the LINK_CAPABILITY object is defined as a series of\n   variable-length
      data items called subobjects.  The subobject format\n   is defined in [RFC3209].\n
      \  The following subobjects are currently defined.\n   -  Type 1: the link local
      IPv4 address of a link or a numbered bundle\n      using the format defined
      in [RFC3209].\n   -  Type 2: the link local IPv6 address of a link or a numbered
      bundle\n      using the format defined in [RFC3209].\n   -  Type 4: the link
      local identifier of an unnumbered link or bundle\n      using the format defined
      in [RFC3477].\n   -  Type 64: the Maximum Reservable Bandwidth corresponding
      to this\n      link or bundle (see [RFC4201]).\n   -  Type 65: the interface
      switching capability descriptor (see\n      [RFC4202]) corresponding to this
      link or bundle (see also\n      [RFC4201]).\n   Note: future revisions of this
      document may extend the above list.\n   A single instance of this object MAY
      be used to exchange capability\n   information relating to more than one link
      or bundled link.  In this\n   case, the following ordering MUST be used:\n   -
      \ each link MUST be identified by an identifier subobject (Type 1,\n      2,
      or 4)\n   -  capability subobjects (Type 64 or 65, and future subobjects) MUST\n
      \     be placed after the identifier subobject for the link or bundle to\n      which
      they refer.\n   Multiple instances of the LINK_CAPABILITY object within the
      same\n   Notify message are not supported by this specification.  In the event\n
      \  that a Notify message contains multiple LINK_CAPABILITY objects, the\n   receiver
      SHOULD process the first one as normal and SHOULD ignore\n   subsequent instances
      of the object.\n"
    title: 5.3.  LINK_CAPABILITY Object
  - contents:
    - "5.4.  Revised Message Formats\n   The Notify message is enhanced to support
      Call establishment and\n   teardown of Calls.  See Section 6 for a description
      of the\n   procedures.\n"
    - contents:
      - "5.4.1.  Notify Message\n   The Notify message is modified in support of Call
        establishment by\n   the optional addition of the LINK_CAPABILITY object.
        \ Further, the\n   SESSION_ATTRIBUTE object is added to the <notify session>
        sequence to\n   carry the long Call ID.  The presence of the SESSION_ATTRIBUTE
        object\n   MAY be used to distinguish a Notify message used for Call management,\n
        \  but see Section 5.5 for another mechanism.  The <notify session list>\n
        \  MAY be used to simultaneously set up multiple Calls.\n   The format of
        the Notify Message is as follows:\n   <Notify message>  ::= <Common Header>
        [ <INTEGRITY> ]\n                         [[ <MESSAGE_ID_ACK> | <MESSAGE_ID_NACK>]...]\n
        \                        [ <MESSAGE_ID> ]\n                         <ERROR_SPEC>\n
        \                        <notify session list>\n   <notify session list> ::=
        [ <notify session list> ] <notify session>\n   <notify session>  ::= <SESSION>
        [ <ADMIN_STATUS> ]\n                         [ <POLICY_DATA>...]\n                         [
        <LINK_CAPABILITY> ]\n                         [ <SESSION_ATTRIBUTE> ]\n                         [
        <sender descriptor> | <flow descriptor> ]\n   <sender descriptor> ::= see
        [RFC3473]\n   <flow descriptor> ::= see [RFC3473]\n"
      title: 5.4.1.  Notify Message
    title: 5.4.  Revised Message Formats
  - contents:
    - "5.5.  ADMIN_STATUS Object\n   Notify messages exchanged for Call control and
      management purposes\n   carry a specific new bit (the Call Management or C bit)
      in the\n   ADMIN_STATUS object.\n   [RFC3473] indicates that the format and
      contents of the ADMIN_STATUS\n   object are as defined in [RFC3471].  The new
      \"C\" bit is added for\n   Call control as shown below.\n       0                   1
      \                  2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3
      4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |R|                        Reserved                     |C|T|A|D|\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \        Reflect (R): 1 bit - see [RFC3471]\n         Testing (T): 1 bit - see
      [RFC3471]\n         Administratively down (A): 1 bit - see [RFC3471]\n         Deletion
      in progress (D): 1 bit - see [RFC3471]\n         Call Management (C): 1 bit\n
      \           This bit is set when the message is being used to control\n            and
      manage a Call.\n   The procedures for the use of the C bit are described in
      Section 6.\n"
    title: 5.5.  ADMIN_STATUS Object
  title: 5.  Protocol Extensions for Calls and Connections
- contents:
  - '6.  Procedures in Support of Calls and Connections

    '
  - contents:
    - "6.1.  Call/Connection Setup Procedures\n   This section describes the processing
      steps for Call and Connection\n   setup.\n   There are three cases considered:\n
      \  -  A Call is set up without any associated Connection.  It is assumed\n      that
      Connections will be added to the Call at a later time, but\n      this is neither
      a requirement nor a constraint.\n   -  A Connection may be added to an existing
      Call.  This may happen if\n      the Call was set up without any associated
      Connections, or if\n      another Connection is added to a Call that already
      has one or more\n      associated Connections.\n   -  A Connection may be established
      without any reference to a Call\n      (see Section 6.4).  This encompasses
      the previous LSP setup\n      procedure.\n   Note that a Call MUST NOT be imposed
      upon a Connection that is\n   already established.  To do so would require changing
      the short Call\n   ID in the SESSION object of the existing LSPs and this would\n
      \  constitute a change in the Session Identifier.  This is not allowed\n   by
      existing protocol specifications.\n   Call and Connection teardown procedures
      are described later in\n   Section 6.6.\n"
    title: 6.1.  Call/Connection Setup Procedures
  - contents:
    - "6.2.  Call Setup\n   A Call is set up before, and independent of, LSP (i.e.,
      Connection)\n   setup.\n   Call setup MAY necessitate verification of the link
      status and link\n   capability negotiation between the Call ingress node and
      the Call\n   egress node.  The procedure described below is applied only once
      for\n   a Call and hence only once for the set of LSPs associated with a\n   Call.\n
      \  The Notify message (see [RFC3473]) is used to signal the Call setup\n   request
      and response.  The new Call Management (C) bit in the\n   ADMIN_STATUS object
      is used to indicate that this Notify is managing\n   a Call.  The Notify message
      is sent with source and destination\n   IPv4/IPv6 addresses set to any of the
      routable ingress/egress node\n   addresses respectively.\n   At least one session
      MUST be listed in the <notify session list> of\n   the Notify message.  In order
      to allow for long identification of the\n   Call, the SESSION_ATTRIBUTE object
      is added as part of the <notify\n   session list>.  Note that the ERROR_SPEC
      object is not relevant in\n   Call setup and MUST carry the Error Code zero
      (\"Confirmation\") to\n   indicate that there is no error.\n   During Call setup,
      the ADMIN_STATUS object is sent with the following\n   bits set.  Bits not listed
      MUST be set to zero.\n   R - to cause the egress to respond\n   C - to indicate
      that the Notify message is managing a Call.\n   The SESSION, SESSION_ATTRIBUTE,
      SENDER_TEMPLATE, SENDER_TSPEC objects\n   included in the <notify session> of
      the Notify message are built as\n   follows.\n   -  The SESSION object includes
      as Tunnel_End_Point_Address any of the\n      Call-terminating (egress) node's
      IPv4/IPv6 routable addresses.\n      The Call_ID is set to a non-zero value
      unique within the context\n      of the address pairing provided by the Tunnel_End_Point_Address\n
      \     and the Sender_Address from the SENDER_TEMPLATE object (see\n      below).
      \ This value will be used as the short Call ID carried on\n      all messages
      for LSPs associated with this Call.\n      Note that the Call_ID value of zero
      is reserved and MUST NOT be\n      used since it will be present in SESSION
      objects of LSPs that are\n      not associated with Calls.  The Tunnel_ID of
      the SESSION object is\n      not relevant for this procedure and SHOULD be set
      to zero.  The\n      Extended_Tunnel_ID of the SESSION object is not relevant
      for this\n      procedure and MAY be set to zero or to an address of the ingress\n
      \     node.\n   -  The SESSION_ATTRIBUTE object contains priority flags.  Currently\n
      \     no use of these flags is envisioned, however, future work may\n      identify
      value in assigning priorities to Calls; accordingly the\n      Priority fields
      MAY be set to non-zero values.  None of the Flags\n      in the SESSION_ATTRIBUTE
      object is relevant to this process and\n      this field SHOULD be set to zero.
      \ The Session Name field is used\n      to carry the long Call Id as described
      in Section 5.\n   -  The SENDER_TEMPLATE object includes as Sender Address any
      of the\n      Call-initiating (ingress) node's IPv4/IPv6 routable addresses.\n
      \     The LSP_ID is not relevant and SHOULD be set to zero.\n   -  The bandwidth
      value inserted in the SENDER_TSPEC and FLOWSPEC\n      objects MUST be ignored
      upon receipt and SHOULD be set to zero\n      when sent.\n   Additionally, ingress/egress
      nodes that need to communicate their\n   respective link local capabilities
      may include a LINK_CAPABILITY\n   object in the Notify message.\n   The receiver
      of a Notify message may identify whether it is part of\n   Call management or
      reporting an error by the presence or absence of\n   the SESSION_ATTRIBUTE object
      in the <notify session list>.  Full\n   clarity, however, may be achieved by
      inspection of the new Call\n   Management (C) bit in the ADMIN_STATUS object.\n
      \  Note that the POLICY_DATA object may be included in the <notify\n   session
      list> and MAY be used to identify requestor credentials,\n   account numbers,
      limits, quotas, etc.  This object is opaque to RSVP,\n   which simply passes
      it to policy control when required.\n   Message IDs MUST be used during Call
      setup.\n"
    - contents:
      - "6.2.1.  Accepting Call Setup\n   A node that receives a Notify message carrying
        the ADMIN_STATUS\n   object with the R and C bits set is being requested to
        set up a Call.\n   The receiver MAY perform authorization and policy according
        to local\n   requirements.\n   If the Call is acceptable, the receiver responds
        with a Notify\n   message reflecting the information from the Call request
        with two\n   exceptions.\n   -  The responder removes any LINK_CAPABLITY object
        that was received\n      and MAY insert a LINK_CAPABILITY object that describes
        its own\n      access link.\n   -  The ADMIN_STATUS object is sent with only
        the C bit set.  All\n      other bits MUST be set to zero.\n   The responder
        MUST use the Message ID object to ensure reliable\n   delivery of the response.
        \ If no Message ID Acknowledgement is\n   received after the configured number
        of retries, the responder SHOULD\n   continue to assume that the Call was
        successfully established.  Call\n   liveliness procedures are covered in Section
        6.7.\n"
      title: 6.2.1.  Accepting Call Setup
    - contents:
      - "6.2.2.  Call Setup Failure and Rejection\n   Call setup may fail or be rejected.\n
        \  If the Notify message can not be delivered, no Message ID\n   acknowledgement
        will be received by the sender.  In the event that\n   the sender has retransmitted
        the Notify message a configurable number\n   of times without receiving a
        Message ID Acknowledgement (as described\n   in [RFC2961]), the initiator
        SHOULD declare the Call failed and\n   SHOULD send a Call teardown request
        (see Section 6.6).\n   It is also possible that a Message ID Acknowledgement
        is received but\n   no Call response Notify message is received.  In this
        case, the\n   initiator MAY re-send the Call setup request a configurable
        number of\n   times (see Section 6.7) before declaring that the Call has failed.\n
        \  At this point, the initiator MUST send a Call teardown request (see\n   Section
        6.6).\n   If the Notify message cannot be parsed or is in error, it MAY be\n
        \  responded to with a Notify message carrying the error code 13\n   (\"Unknown
        object class\") or 14 (\"Unknown object C-Type\") if\n   appropriate to the
        error detected.\n   The Call setup MAY be rejected by the receiver because
        of security,\n   authorization, or policy reasons.  Suitable error codes already
        exist\n   [RFC2205] and can be used in the ERROR_SPEC object included in the\n
        \  Notify message sent in response.\n   Error response Notify messages SHOULD
        also use the Message ID object\n   to achieve reliable delivery.  No action
        should be taken on the\n   failure to receive a Message ID Acknowledgement
        after the configured\n   number of retries.\n"
      title: 6.2.2.  Call Setup Failure and Rejection
    title: 6.2.  Call Setup
  - contents:
    - "6.3.  Adding a Connections to a Call\n   Once a Call has been established,
      LSPs can be added to the Call.\n   Since the short Call ID is part of the SESSION
      object, any LSP that\n   has the same Call ID value in the SESSION object belongs
      to the same\n   Call, and the Notify message used to establish the Call carried
      the\n   same Call ID in its SESSION object.\n   There will be no confusion between
      LSPs that are associated with a\n   Call and those which are not, since the
      Call ID value MUST be equal\n   to zero for LSPs that are not associated with
      a Call, and MUST NOT be\n   equal to zero for a valid Call ID.\n   LSPs for
      different Calls can be distinguished because the Call ID is\n   unique within
      the context of the source address (in the\n   SENDER_TEMPLATE object) and the
      destination address (in the SESSION\n   object).\n   Ingress and egress nodes
      MAY group together LSPs associated with the\n   same Call and process them as
      a group according to implementation\n   requirements.  Transit nodes need not
      be aware of the association of\n   multiple LSPs with the same Call.\n   The
      ingress node MAY choose to set the \"Session Name\" of an LSP to\n   match the
      long Call ID of the associated Call.\n   The C bit of the ADMIN_STATUS object
      MUST NOT be set on LSP messages\n   including on Notify messages that pertain
      to the LSP and MUST be\n   ignored.\n"
    - contents:
      - "6.3.1.  Adding a Reverse Direction LSP to a Call\n   Note that once a Call
        has been established, it is symmetric.  That\n   is, either end of the Call
        may add LSPs to the Call.\n   Special care is needed when managing LSPs in
        the reverse direction\n   since the addresses in the SESSION and SENDER_TEMPLATE
        are reversed.\n   However, since the short Call ID is unique in the context
        of a given\n   ingress-egress address pair, it may safely be used to associate
        the\n   LSP with the Call.\n   Note that since Calls are defined here to be
        symmetrical, the issue\n   of potential Call ID collision arises.  This is
        discussed in Section\n   6.5.\n"
      title: 6.3.1.  Adding a Reverse Direction LSP to a Call
    title: 6.3.  Adding a Connections to a Call
  - contents:
    - "6.4.  Call-Free Connection Setup\n   It continues to be possible to set up
      LSPs as per [RFC3473] without\n   associating them with a Call.  If the short
      Call ID in the SESSION\n   object is set to zero, there is no associated Call
      and the Session\n   Name field in the SESSION_ATTRIBUTE object MUST be interpreted
      simply\n   as the name of the session (see [RFC3209]).\n   The C bit of the
      ADMIN_STATUS object MUST NOT be set on messages for\n   LSP control, including
      on Notify messages that pertain to LSPs, and\n   MUST be ignored when received
      on such messages.\n"
    title: 6.4.  Call-Free Connection Setup
  - contents:
    - "6.5.  Call Collision\n   Since Calls are symmetrical, it is possible that both
      ends of a Call\n   will attempt to establish Calls with the same long Call IDs
      at the\n   same time.  This is only an issue if the source and destination\n
      \  address pairs match.  This situation can be avoided by applying some\n   rules
      to the contents of the long Call ID, but such mechanisms are\n   outside the
      scope of this document.\n   If a node that has sent a Call setup request and
      has not yet received\n   a response itself receives a Call setup request with
      the same long\n   Call ID and matching source/destination addresses, it SHOULD
      process\n   as follows:\n   -  If its source address is numerically greater
      than the remote\n      source address, it MUST discard the received message
      and continue\n      to wait for a response to its setup request.\n   -  If its
      source address is numerically smaller than the remote\n      source address,
      it MUST discard state associated with the Call\n      setup that it initiated,
      and MUST respond to the received Call\n      setup.\n   If a node receives a
      Call setup request carrying an address pair and\n   long Call ID that match
      an existing Call, the node MUST return an\n   error message (Notify message)
      with the new Error Code \"Call\n   Management\" and the new Error Value \"Duplicate
      Call\" in response to\n   the new Call request, and MUST NOT make any changes
      to the existing\n   Call.\n   A further possibility for contention arises when
      short Call IDs are\n   assigned by a pair of nodes for two distinct Calls that
      are set up\n   simultaneously using different long Call IDs.  In this event,
      a node\n   receives a Call setup request carrying a short Call ID that matches\n
      \  one that it previously sent for the same address pair.  The following\n   processing
      MUST be followed:\n   -  If the receiver's source address is numerically greater
      than the\n      remote source address, the receiver returns an error (Notify\n
      \     message) with the new Error Code \"Call Management\" and the new\n      Error
      Value \"Call ID Contention\".\n   -  If the receiver's source address is numerically
      less than the\n      remote source address, the receiver accepts and processes
      the Call\n      request.  It will receive an error message sent as described\n
      \     above, and at that point, it selects a new short Call ID and re-\n      sends
      the Call setup request.\n"
    title: 6.5.  Call Collision
  - contents:
    - "6.6.  Call/Connection Teardown\n   As with Call/Connection setup, there are
      several cases to consider.\n   -  Removal of a Connection from a Call\n   -
      \ Removal of the last Connection from a Call\n   -  Teardown of an \"empty\"
      Call\n   The case of tearing down an LSP that is not associated with a Call\n
      \  does not need to be examined as it follows exactly the procedures\n   described
      in [RFC3473].\n"
    - contents:
      - "6.6.1.  Removal of a Connection from a Call\n   An LSP that is associated
        with a Call may be deleted using the\n   standard procedures described in
        [RFC3473].  No special procedures\n   are required.\n   Note that it is not
        possible to remove an LSP from a Call without\n   deleting the LSP.  It is
        not valid to change the short Call ID from\n   non-zero to zero since this
        involves a change to the SESSION object,\n   which is not allowed.\n"
      title: 6.6.1.  Removal of a Connection from a Call
    - contents:
      - "6.6.2.  Removal of the Last Connection from a Call\n   When the last LSP
        associated with a Call is deleted, the question\n   arises as to what happens
        to the Call.  Since a Call may exist\n   independently of Connections, it
        is not always acceptable to say that\n   the removal of the last LSP from
        a Call removes the Call.\n   The removal of the last LSP does not remove the
        Call and the\n   procedures described in the next Section MUST be used to
        delete the\n   Call.\n"
      title: 6.6.2.  Removal of the Last Connection from a Call
    - contents:
      - "6.6.3.  Teardown of an \"Empty\" Call\n   When all LSPs have been removed
        from a Call, the Call may be torn\n   down or left for use by future LSPs.\n
        \  Deletion of Calls is achieved by sending a Notify message just as for\n
        \  Call setup, but the ADMIN_STATUS object carries the R, D, and C bits\n
        \  on the teardown request and the D and C bits on the teardown\n   response.
        \ Other bits MUST be set to zero.\n   When a Notify message is sent for deleting
        a Call and the initiator\n   does not receive the corresponding reflected
        Notify message (or\n   possibly even the Message ID Ack), the initiator MAY
        retry the\n   deletion request using the same retry procedures as used during
        Call\n   establishment.  If no response is received after full retry, the
        node\n   deleting the Call MAY declare the Call deleted, but under such\n
        \  circumstances the node SHOULD avoid re-using the long or short Call\n   IDs
        for at least five times the Notify refresh period.\n"
      title: 6.6.3.  Teardown of an "Empty" Call
    - contents:
      - "6.6.4.  Attempted Teardown of a Call with Existing Connections\n   If a Notify
        request with the D bit of the ADMIN_STATUS object set is\n   received for
        a Call for which LSPs still exist, the request MUST be\n   rejected with the
        Error Code \"Call Management\" and Error Value\n   \"Connections Still Exist\".
        \ The state of the Call MUST NOT be\n   changed.\n"
      title: 6.6.4.  Attempted Teardown of a Call with Existing Connections
    - contents:
      - "6.6.5.  Teardown of a Call from the Egress\n   Since Calls are symmetric,
        they may be torn down from the ingress or\n   egress.\n   When the Call is
        \"empty\" (has no associated LSPs), it may be deleted\n   by the egress sending
        a Notify message just as described above.\n   Note that there is a possibility
        that both ends of a Call initiate\n   Call deletion at the same time.  In
        this case, the Notify message\n   acting as teardown request MAY be interpreted
        by its recipient as a\n   teardown response.  But since the Notify messages
        acting as teardown\n   requests carry the R bit in the ADMIN_STATUS object,
        they MUST be\n   responded to anyway.  If a teardown request Notify message
        is\n   received for an unknown Call ID, it is, nevertheless, responded to
        in\n   the affirmative.\n"
      title: 6.6.5.  Teardown of a Call from the Egress
    title: 6.6.  Call/Connection Teardown
  - contents:
    - "6.7.  Control Plane Survivability\n   Delivery of Notify messages is secured
      using Message ID\n   Acknowledgements as described in previous sections.\n   Notify
      messages provide end-to-end communication that does not rely\n   on constant
      paths through the network.  Notify messages are routed\n   according to IGP
      routing information.  No consideration is,\n   therefore, required for network
      resilience (for example, make-\n   before-break, protection, fast re-route),
      although end-to-end\n   resilience is of interest for node restart and completely
      disjoint\n   networks.\n   Periodic Notify messages SHOULD be sent by the initiator
      and\n   terminator of the Call to keep the Call alive and to handle ingress\n
      \  or egress node restart.  The time period for these retransmissions is\n   a
      local matter, but it is RECOMMENDED that this period should be\n   twice the
      shortest refresh period of any LSP associated with the\n   Call.  When there
      are no LSPs associated with a Call, an LSR is\n   RECOMMENDED to use a refresh
      period of no less than one minute.  The\n   Notify messages are identical to
      those sent as if establishing the\n   Call for the first time, except for the
      LINK_CAPABILITY object, which\n   may have changed since the Call was first
      established, due to, e.g.,\n   the establishment of Connections, link failures,
      or the addition of\n   new component links.  The current link information is
      useful for the\n   establishment of subsequent Connections.  A node that receives
      a\n   refresh Notify message carrying the R bit in the ADMIN_STATUS object\n
      \  MUST respond with a Notify response.  A node that receives a refresh\n   Notify
      message (response or request) MAY reset its timer - thus, in\n   normal processing,
      Notify refreshes involve a single exchange once\n   per time period.\n   A node
      (sender or receiver) that is unsure of the status of a Call\n   MAY immediately
      send a Notify message as if establishing the Call for\n   the first time.\n
      \  Failure to receive a refresh Notify request has no specific meaning.\n   A
      node that fails to receive a refresh Notify request MAY send its\n   own refresh
      Notify request to establish the status of the Call.  If a\n   node receives
      no response to a refresh Notify request (including no\n   Message ID Acknowledgement),
      a node MAY assume that the remote node\n   is unreachable or unavailable.  It
      is a local policy matter whether\n   this causes the local node to teardown
      associated LSPs and delete the\n   Call.\n   In the event that an edge node
      restarts without preserved state, it\n   MAY relearn LSP state from adjacent
      nodes and Call state from remote\n   nodes.  If a Path or Resv message is received
      with a non-zero Call ID\n   but without the C bit in the ADMIN_STATUS, and for
      a Call ID that is\n   not recognized, the receiver is RECOMMENDED to assume
      that the Call\n   establishment is delayed and ignore the received message.
      \ If the\n   Call setup never materializes, the failure by the restarting node
      to\n   refresh state will cause the LSPs to be torn down.  Optionally, the\n
      \  receiver of such an LSP message for an unknown Call ID may return an\n   error
      (PathErr or ResvErr message) with the error code \"Call\n   Management\" and
      Error Value \"Unknown Call ID\".\n"
    title: 6.7.  Control Plane Survivability
  title: 6.  Procedures in Support of Calls and Connections
- contents:
  - "7.  Applicability of Call and Connection Procedures\n   This section considers
    the applicability of the different Call\n   establishment procedures at the NNI
    and UNI reference points.  This\n   section is informative and is not intended
    to prescribe or prevent\n   other options.\n"
  - contents:
    - "7.1.  Network-Initiated Calls\n   Since the link properties and other traffic-engineering
      attributes\n   are likely known through the IGP, the LINK_CAPABILITY object
      is not\n   usually required.\n   In multi-domain networks, it is possible that
      access link properties\n   and other traffic-engineering attributes are not
      known since the\n   domains do not share this sort of information.  In this
      case, the\n   Call setup mechanism may include the LINK_CAPABILITY object.\n"
    title: 7.1.  Network-Initiated Calls
  - contents:
    - "7.2.  User-Initiated Calls\n   It is possible that the access link properties
      and other traffic-\n   engineering attributes are not shared across the core
      network.  In\n   this case, the Call setup mechanism may include the LINK_CAPABILITY\n
      \  object.\n   Further, the first node within the network may be responsible
      for\n   managing the Call.  In this case, the Notify message that is used to\n
      \  set up the Call is addressed by the user network edge node to the\n   first
      node of the core network.  Moreover, neither the long Call ID\n   nor the short
      Call ID is supplied (the Session Name Length is set to\n   zero and the Call
      ID value is set to zero).  The Notify message is\n   passed to the first core
      node, which is responsible for generating\n   the long and short Call IDs before
      dispatching the message to the\n   remote Call end point (which is known from
      the SESSION object).\n   Further, when used in an overlay context, the first
      core node is\n   allowed (see [RFC4208]) to replace the Session Name assigned
      by the\n   ingress node and passed in the Path message.  In the case of Call\n
      \  management, the first core node:\n      1) MAY insert a long Call ID in the
      Session Name of a Path\n         message.\n      2) MUST replace the Session
      Name with that originally issued by\n         the user edge node when it returns
      the Resv message to the\n         ingress node.\n"
    title: 7.2.  User-Initiated Calls
  - contents:
    - "7.3.  External Call Managers\n   Third party Call management agents may be
      used to apply policy and\n   authorization at a point that is neither the initiator
      nor terminator\n   of the Call.  The previous example is a particular case of
      this, but\n   the process and procedures are identical.\n"
    - contents:
      - "7.3.1.  Call Segments\n   Call Segments exist between a set of default and
        configured External\n   Call Managers along a path between the ingress and
        egress nodes, and\n   use the protocols described in this document.\n   The
        techniques that are used by a given service provider to identify\n   which
        External Call Managers within its network should process a\n   given Call
        are beyond the scope of this document.\n   An External Call Manager uses normal
        IP routing to route the Notify\n   message to the next External Call Manager.
        \ Notify messages (requests\n   and responses) are therefore encapsulated
        in IP packets that identify\n   the sending and receiving External Call Managers,
        but the addresses\n   used to identify the Call (the Sender Address in the
        SENDER_TEMPLATE\n   object and the Tunnel Endpoint Address in the SESSION
        object)\n   continue to identify the endpoints of the Call.\n"
      title: 7.3.1.  Call Segments
    title: 7.3.  External Call Managers
  title: 7.  Applicability of Call and Connection Procedures
- contents:
  - "8.  Non-Support of Call ID\n   It is important that the procedures described
    above operate as\n   seamlessly as possible with legacy nodes that do not support
    the\n   extensions described.\n   Clearly, there is no need to consider the case
    where the Call\n   initiator does not support Call setup initiation.\n"
  - contents:
    - "8.1.  Non-Support by External Call Managers\n   It is unlikely that a Call
      initiator will be configured to send Call\n   establishment Notify requests
      to an external Call manager, including\n   the first core node, if that node
      does not support Call setup.\n   A node that receives an unexpected Call setup
      request will fall into\n   one of the following categories.\n   -  Node does
      not support RSVP.  The message will fail to be delivered\n      or responded
      to.  No Message ID Acknowledgement will be sent.  The\n      initiator will
      retry and then give up.\n   -  Node supports RSVP or RSVP-TE but not GMPLS.
      \ The message will be\n      delivered but not understood.  It will be discarded.
      \ No Message\n      ID Acknowledgement will be sent.  The initiator will retry
      and\n      then give up.\n   -  Node supports GMPLS but not Call management.
      \ The message will be\n      delivered, but parsing will fail because of the
      presence of the\n      SESSION_ATTRIBUTE object.  A Message ID Acknowledgement
      may be\n      sent before the parse fails.  When the parse fails, the Notify\n
      \     message may be discarded in which case the initiator will retry\n      and
      then give up; alternatively, a parse error may be generated\n      and returned
      in a Notify message which will indicate to the\n      initiator that Call management
      is not supported.\n"
    title: 8.1.  Non-Support by External Call Managers
  - contents:
    - "8.2.  Non-Support by Transit Node\n   Transit nodes SHOULD NOT examine Notify
      messages that are not\n   addressed to them.  However, they will see short Call
      IDs in all\n   messages for all LSPs associated with Calls.\n   Previous specifications
      state that these fields SHOULD be ignored on\n   receipt and MUST be transmitted
      as zero.  This might be interpreted\n   by some implementations as meaning that
      the fields should be zeroed\n   before the objects are forwarded.  If this happens,
      LSP setup will\n   not be possible.  If either of the fields is zeroed either
      on the\n   Path or the Resv message, the Resv message will reach the initiator\n
      \  with the field set to zero - this is an indication to the initiator\n   that
      some node in the network is preventing Call management.  Use of\n   Explicit
      Routes may help to mitigate this issue by avoiding such\n   nodes.  Ultimately,
      however, it may be necessary to upgrade the\n   offending nodes to handle these
      protocol extensions.\n"
    title: 8.2.  Non-Support by Transit Node
  - contents:
    - "8.3.  Non-Support by Egress Node\n   It is unlikely that an attempt will be
      made to set up a Call to a\n   remote node that does not support Calls.\n   If
      the egress node does not support Call management through the\n   Notify message,
      it will react (as described in Section 8.1) in the\n   same way as an External
      Call Manager.\n"
    title: 8.3.  Non-Support by Egress Node
  title: 8.  Non-Support of Call ID
- contents:
  - "9.  Security Considerations\n   Please refer to each of the documents referenced
    in the following\n   sections for a description of the security considerations
    applicable\n   to the features that they provide.\n"
  - contents:
    - "9.1.  Call and Connection Security Considerations\n   Call setup is vulnerable
      to attacks both of spoofing and denial of\n   service.  Since Call setup uses
      Notify messages, the process can be\n   protected by the use of the INTEGRITY
      object to secure those messages\n   as described in [RFC2205] and [RFC3473].
      \ Deployments where security\n   is a concern SHOULD use this mechanism.\n   Implementations
      and deployments MAY additionally protect the Call\n   setup exchange using end-to-end
      security mechanisms such as those\n   provided by IPsec (see [RFC4302] and [RFC4303]),
      or using RSVP\n   security [RFC2747].\n   Note, additionally, that it would
      be desirable to use the process of\n   independent Call establishment, where
      the Call is set up separately\n   from the LSPs, to apply an extra level of
      authentication and policy\n   for the end-to-end LSPs above that which is available
      with Call-less,\n   hop-by-hop LSP setup.  However doing so will require additional
      work\n   to set up security associations between the peer and the call manager\n
      \  that meet the requirements of [RFC4107].  The mechanism described in\n   this
      document is expected to meet this use case when combined with\n   this additional
      work.  Application of this mechanism to the\n   authentication and policy use
      case prior to standardization of a\n   security solution is inappropriate and
      outside the current\n   applicability of the mechanism.\n   The frequency of
      Call establishment is application dependent and hard\n   to generalize.  Key
      exchange for Call-related message exchanges is\n   therefore something that
      should be configured or arranged dynamically\n   in different deployments according
      to the advice in [RFC4107].  Note\n   that the remote RSVP-TE signaling relationship
      between Call endpoints\n   is no different from the signaling relationship between
      LSRs that\n   establish an LSP.  That is, the LSRs are not necessarily IP-adjacent\n
      \  in the control plane in either case.  Thus, key exchange should be\n   regarded
      as a remote procedure, not a single hop procedure.  There\n   are several procedures
      for automatic remote exchange of keys, and\n   IKEv2 [RFC4306] is particularly
      suggested in [RFC3473].\n"
    title: 9.1.  Call and Connection Security Considerations
  title: 9.  Security Considerations
- contents:
  - '10.  IANA Considerations

    '
  - contents:
    - "10.1.  RSVP Objects\n   A new RSVP object is introduced.  IANA has made an
      assignment from\n   the \"RSVP Parameters\" registry using the sub-registry
      \"Class Names,\n   Class Numbers, and Class Types\".\n   o  LINK_CAPABILITY
      object\n      Class-Num = 133 (form 10bbbbbb)\n      The Class Number is selected
      so that nodes not recognizing this\n      object drop it silently.  That is,
      the top bit is set and the next\n      bit is cleared.\n      C-Type = 1 (TE
      Link Capabilities)\n      The LINK_CAPABILITY object is only defined for inclusion
      on Notify\n      messages.\n      Refer to Section 5.3 of this document.\n      IANA
      maintains a list of subobjects that may be carried in this\n      object.  This
      list is maintained in the registry entry for the\n      LINK_CAPABILITY object
      as is common practice for the subobjects of\n      other RSVP objects.  For
      each subobject, IANA lists:\n         - subobject type number\n         - subobject
      name\n         - reference indicating where subobject is defined.\n      The
      initial list of subobjects is provided in Section 5.3 of this\n      document.\n"
    title: 10.1.  RSVP Objects
  - contents:
    - "10.2.  RSVP Error Codes and Error Values\n   A new RSVP Error Code and new
      Error Values are introduced.  IANA has\n   made assignments from the \"RSVP
      Parameters\" registry using the sub-\n   registry \"Error Codes and Globally-Defined
      Error Value Sub-Codes\".\n   o  Error Codes:\n      - Call Management (value
      32)\n   o  Error Values:\n      - Call Management/Call ID Contention      (value
      1)\n      - Call Management/Connections Still Exist (value 2)\n      - Call
      Management/Unknown Call ID         (value 3)\n      - Call Management/Duplicate
      Call          (value 4)\n"
    title: 10.2.  RSVP Error Codes and Error Values
  - contents:
    - "10.3.  RSVP ADMIN_STATUS Object Bits\n   [GMPLS-E2E] requested that IANA manage
      the bits of the RSVP\n   ADMIN_STATUS object.  A new \"Administrative Status
      Information Flags\"\n   sub-registry of the \"GMPLS Signaling Parameters\" registry
      was\n   created.\n   This document defines one new bit, the C bit, to be tracked
      in that\n   sub-registry.  Bit number 28 has been assigned.  See Section 5.5
      of\n   this document.\n"
    title: 10.3.  RSVP ADMIN_STATUS Object Bits
  title: 10.  IANA Considerations
- contents:
  - "11.  Acknowledgements\n   The authors would like to thank George Swallow, Yakov
    Rekhter, Lou\n   Berger, Jerry Ash, and Kireeti Kompella for their very useful
    input\n   to, and comments on, an earlier revision of this document.\n   Thanks
    to Lyndon Ong and Ben Mack-Crane for lengthy discussions\n   during and after
    working group last call, and to Deborah Brungard for\n   a final, detailed review.\n
    \  Thanks to Suresh Krishnan for the GenArt review, and to Magnus\n   Nystrom
    for discussions about security.\n   Useful comments were received during IESG
    review from Brian\n   Carpenter, Lars Eggert, Ted Hardie, Sam Hartman, and Russ
    Housley.\n"
  title: 11.  Acknowledgements
- contents:
  - '12.  References

    '
  - contents:
    - "12.1.  Normative References\n   [GMPLS-E2E] Lang, J., Ed., Rekhter, Y., Ed.,
      and D. Papadimitriou,\n               Ed., \"RSVP-TE Extensions in Support of
      End-to-End\n               Generalized Multi-Protocol Label Switching (GMPLS)\n
      \              Recovery\", RFC 4872, May 2007.\n   [RFC2119]   Bradner, S.,
      \"Key words for use in RFCs to Indicate\n               Requirement Levels\",
      BCP 14, RFC 2119, March 1997.\n   [RFC2205]   Braden, R., Ed., Zhang, L., Berson,
      S., Herzog, S., and\n               S. Jamin, \"Resource ReSerVation Protocol
      (RSVP) --\n               Version 1 Functional Specification\", RFC 2205, September\n
      \              1997.\n   [RFC2747]   Baker, F., Lindell, B., and M. Talwar,
      \"RSVP\n               Cryptographic Authentication\", RFC 2747, January 2000.\n
      \  [RFC2961]   Berger, L., Gan, D., Swallow, G., Pan, P., Tommasi, F.,\n               and
      S. Molendini, \"RSVP Refresh Overhead Reduction\n               Extensions\",
      RFC 2961, April 2001.\n   [RFC3209]   Awduche, D., Berger, L., Gan, D., Li,
      T., Srinivasan, V.,\n               and G. Swallow, \"RSVP-TE: Extensions to
      RSVP for LSP\n               Tunnels\", RFC 3209, December 2001.\n   [RFC3471]
      \  Berger, L., Ed., \"Generalized Multi-Protocol Label\n               Switching
      (GMPLS) Signaling Functional Description\", RFC\n               3471, January
      2003.\n   [RFC3473]   Berger, L., Ed., \"Generalized Multi-Protocol Label\n
      \              Switching (GMPLS) Signaling Resource ReserVation\n               Protocol-Traffic
      Engineering (RSVP-TE) Extensions\", RFC\n               3473, January 2003.\n
      \  [RFC3477]   Kompella, K. and Y. Rekhter, \"Signalling Unnumbered Links\n
      \              in Resource ReSerVation Protocol - Traffic Engineering\n               (RSVP-TE)\",
      RFC 3477, January 2003.\n   [RFC3945]   Mannie, E., Ed., \"Generalized Multi-Protocol
      Label\n               Switching (GMPLS) Architecture\", RFC 3945, October 2004.\n
      \  [RFC4201]   Kompella, K., Rekhter, Y., and L. Berger, \"Link Bundling\n               in
      MPLS Traffic Engineering (TE)\", RFC 4201, October\n               2005.\n   [RFC4202]
      \  Kompella, K., Ed., and Y. Rekhter, Ed., \"Routing\n               Extensions
      in Support of Generalized Multi-Protocol Label\n               Switching (GMPLS)\",
      RFC 4202, October 2005.\n   [RFC4208]   Swallow, G., Drake, J., Ishimatsu, H.,
      and Y. Rekhter,\n               \"Generalized Multiprotocol Label Switching
      (GMPLS) User-\n               Network Interface (UNI): Resource ReserVation
      Protocol-\n               Traffic Engineering (RSVP-TE) Support for the Overlay\n
      \              Model\", RFC 4208, October 2005.\n   [RFC4302]   Kent, S., \"IP
      Authentication Header\", RFC 4302, December\n               2005.\n   [RFC4303]
      \  Kent, S., \"IP Encapsulating Security Payload (ESP)\", RFC\n               4303,
      December 2005.\n   [RFC4306]   Kaufman, C., Ed., \"Internet Key Exchange (IKEv2)\n
      \              Protocol\", RFC 4306, December 2005.\n   [RFC4426]   Lang, J.,
      Ed., Rajagopalan, B., Ed., and D.\n               Papadimitriou, Ed., \"Generalized
      Multi-Protocol Label\n               Switching (GMPLS) Recovery Functional Specification\",
      RFC\n               4426, March 2006.\n"
    title: 12.1.  Normative References
  - contents:
    - "12.2.  Informative References\n   [ASON-APPL] Drake, J., Papadimitriou, D.,
      Farrel, A., Brungard, D.,\n               Ali, Z., Ayyangar, A., Ould-Brahim,
      H., and D. Fedyk,\n               \"Generalized MPLS (GMPLS) RSVP-TE Signalling
      in support\n               of Automatically Switched Optical Network (ASON),
      Work in\n               Progress, July 2005.\n   [RFC4107]   Bellovin, S. and
      R. Housley, \"Guidelines for\n               Cryptographic Key Management\",
      BCP 107, RFC 4107, June\n               2005.\n   [RFC4139]   Papadimitriou,
      D., Drake, J., Ash, J., Farrel, A., and L.\n               Ong, \"Requirements
      for Generalized MPLS (GMPLS) Signaling\n               Usage and Extensions
      for Automatically Switched Optical\n               Network (ASON)\", RFC 4139,
      July 2005.\n   [STITCH]    Ayyangar, A., Kompella, K., Vasseur, JP., and A.
      Farrel,\n               \"Label Switched Path Stitching with Generalized\n               Multiprotocol
      Label Switching Traffic Engineering (GMPLS\n               TE)\", Work in Progress,
      April 2007.\n   For information on the availability of the following document,
      please\n   see http://www.itu.int.\n   [G.8080]      ITU-T, \"Architecture for
      the Automatically Switched\n               Optical Network (ASON),\" Recommendation
      G.8080/ Y.1304,\n               November 2001 (and Revision, January 2003).\n"
    title: 12.2.  Informative References
  title: 12.  References
- contents:
  - "Authors' Addresses\n   John Drake\n   Boeing Satellite Systems\n   2300 East
    Imperial Highway\n   El Segundo, CA 90245\n   EMail: John.E.Drake2@boeing.com\n
    \  Deborah Brungard (AT&T)\n   Rm. D1-3C22 - 200 S. Laurel Ave.\n   Middletown,
    NJ 07748, USA\n   EMail: dbrungard@att.com\n   Zafar Ali (Cisco)\n   100 South
    Main St. #200\n   Ann Arbor, MI 48104, USA\n   EMail: zali@cisco.com\n   Arthi
    Ayyangar (Nuova Systems)\n   2600 San Tomas Expressway\n   Santa Clara, CA 95051\n
    \  EMail: arthi@nuovasystems.com\n   Don Fedyk (Nortel Networks)\n   600 Technology
    Park Drive\n   Billerica, MA, 01821, USA\n   EMail: dwfedyk@nortel.com\n"
  title: Authors' Addresses
- contents:
  - "Contact Addresses\n   Dimitri Papadimitriou\n   Alcatel-Lucent,\n   Fr. Wellesplein
    1,\n   B-2018 Antwerpen, Belgium\n   Phone: +32 3 240-8491\n   EMail: dimitri.papadimitriou@alcatel-lucent.be\n
    \  Adrian Farrel\n   Old Dog Consulting\n   Phone: +44 (0) 1978 860944\n   EMail:
    adrian@olddog.co.uk\n"
  title: Contact Addresses
- contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2007).\n   This document
    is subject to the rights, licenses and restrictions\n   contained in BCP 78, and
    except as set forth therein, the authors\n   retain all their rights.\n   This
    document and the information contained herein are provided on an\n   \"AS IS\"
    basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE INTERNET ENGINEERING
    TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT
    LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION HEREIN WILL NOT INFRINGE
    ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the procedures with respect to
    rights in RFC documents can be\n   found in BCP 78 and BCP 79.\n   Copies of IPR
    disclosures made to the IETF Secretariat and any\n   assurances of licenses to
    be made available, or the result of an\n   attempt made to obtain a general license
    or permission for the use of\n   such proprietary rights by implementers or users
    of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at\n   ietf-ipr@ietf.org.\n"
  title: Intellectual Property
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
