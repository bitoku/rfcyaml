- contents:
  - "           Internet Protocol on Network Systems HYPERchannel\n                         Protocol
    Specification\n"
  title: __initial_text__
- contents:
  - "STATUS OF THIS MEMO\n   The intent of this document is to provide a complete
    discussion of\n   the protocols and techniques used to embed DoD standard Internet\n
    \  Protocol datagrams (and its associated higher level protocols) on\n   Network
    Systems Corporation's HYPERchannel [1] equipment.\n   Distribution of this memo
    is unlimited.\n   This document is intended for network planners and implementors
    who\n   are already familiar with the TCP/IP protocol suite and the\n   techniques
    used to carry TCP/IP traffic on common networks such as\n   the DDN or Ethernet.
    \ No great familiarity with NSC products is\n   assumed; an appendix is devoted
    to a review of NSC technologies and\n   protocols.\n   At the time of this first
    RFC edition, the contents of this document\n   has already been reviewed by about
    a dozen vendors and users active\n   in the use of TCP/IP on HYPERchannel media.
    \ Comments and suggestions\n   are still welcome (and implementable,) however.\n
    \  Any comments or questions on this specification may be directed to:\n      Ken
    Hardwick\n      Director, Software Technology\n      Network Systems Corporation
    MS029\n      7600 Boone Avenue North\n      Brooklyn Park, MN 55428\n      Phone:
    (612) 424-1607\n      John Lekashman\n      Nasa Ames Research Center. NAS/GE\n
    \     MS 258-6\n      Moffett Field, CA, 94035\n      lekash@orville.nas.nasa.gov\n
    \     Phone: (415) 694-4359\n"
  title: STATUS OF THIS MEMO
- contents:
  - "TABLE OF CONTENTS\n    Status of this memo  . . . . . . . . . .  . . . . . .
    . . . . . .  1\n    Goals of this document   . . . . . . . .  . . . . . . . .
    . . . .  3\n    Basic HYPERchannel network messages  . .  . . . . . . . . . .
    . .  4\n      Basic (16-bit address) Message Proper header  . . . . . . . . .
    \ 5\n      TO addresses and open driver architecture   . . . . . . . . . .  7\n
    \     Extended (32-bit address) Message Proper header . . . . . . . .  8\n      Address
    Recognition and message forwarding .  . . . . . . . . . 10\n      32-bit message
    fields   . . . . . . . . . . . . . . . . . . . . 12\n    Broadcasting   . . .
    . . . . . . . . . . . . . . .  . . . . . . . 14\n    PROTOCOL SPECIFICATION .
    \ .  .  . . . . . . . . . . . . . . . . . 17\n      Basic (16-bit) Message Encapsulation
    \   . . . . . . . . . . . . 18\n      Compatibility with existing implementations
    . . . . . . . . . . 21\n      Extended (32-bit) Message Encapsulation   . . .
    . . . . . . . . 24\n      Address Resolution Protocol   . . . . . . . . . . .
    . . . . . . 27\n      Maximum Transmission Unit . . . . . . . . . . . . . . .
    . . . . 31\n    ADDRESS RESOLUTION    . . . . . . . . . . . . . . . . . . . .
    . . 32\n      Local Address Resolution  . . . . . . . . . . . . . . . . . . .
    33\n      Configuration file format   . . . . . . . . . . . . . . . . . . 34\n
    \     ARP servers   . . . . . . . . . . . . . . . . . . . . . . . . . 35\n      Broadcast
    ARP   . . . . . . . . . . . . . . . . . . . . . . . . 36\n    Appendix A.\n    NSC
    Product Architecture and Addressing   . . . . . . . . . . . . 38\n    Appendix
    B.\n    Network Systems HYPERchannel protocols    . . . . . . . . . . . . 42\n"
  title: TABLE OF CONTENTS
- contents:
  - "GOALS OF THIS DOCUMENT\n   In this document, there are four major technical objectives:\n
    \  1.  To bless a \"de facto\" standard for IP on HYPERchannel that  has\n       been
    implemented by Tektronix, Cray, NASA Ames, and others.\n       We are attempting
    to resolve some interoperability problems with\n       this standard so as to
    minimize the changes to existing IP on\n       HYPERchannel software.  If any
    ambiguities remain in the de facto\n       standard, we wish to assist in their
    resolution.\n   2.  To address larger networks, NSC's newer network products are\n
    \      moving to a 32-bit address from the current 16-bit TO address.\n       This
    document would introduce the addressing extension to the\n       user community
    and specify how IP datagrams would work in the\n       new addressing mode.\n
    \  3.  To define an Address Resolution Protocol for HYPERchannel and\n       other
    NSC products.  It is probably well known that current NSC\n       products do
    not support the broadcast modes that make ARP\n       particularly useful.  However,
    many have expressed interest in\n       \"ARP  servers\" at a known network address.
    \ These servers could\n       fade away as NSC products with broadcast capability
    come into\n       existence.  Host drivers that can generate and recognize this\n
    \      ARP protocol would be prepared to take advantage of it as the\n       pieces
    fall into place.\n   4.  Part of this effort is to standardize the unofficial
    \"message\n       type\" field that reserves byte 8 of the HYPERchannel network\n
    \      message.  To permit better interoperability, NSC will initiate a\n       \"network
    protocol registry\" where any interested party may\n       obtain a unique value
    in byte 8 (or bytes 8 and 9) for their own\n       public, private, commercial
    or proprietary protocol.  Lists of\n       assigned protocol type numbers and
    their \"owners\" will be\n       periodically published by NSC and would be available
    to\n       interested parties.\n"
  title: GOALS OF THIS DOCUMENT
- contents:
  - "BASIC HYPERCHANNEL NETWORK MESSAGES\n   Unlike most datagram delivery systems,
    the HYPERchannel network\n   message consists of two parts:\n             Message
    Proper\n            +--------------------+\n            |                    |\n
    \           |                    |\n            |     10-64 bytes    |\n            |
    \                   |\n            |                    |\n            +--------------------+\n
    \            Associated Data\n            +----------------------------------------------------+\n
    \           |                                                    |\n            |
    \                                                   |\n            |                                                    |\n
    \           |                                                    |\n            |
    \          Unlimited length                         |\n            |                                                    |\n
    \           |                                                    |\n            |
    \                                                   |\n            |                                                    |\n
    \           +----------------------------------------------------+\n   The first
    part is a message header that can be up to 64 bytes in\n   length.  The first
    10 bytes contain information required for the\n   delivery of the entire message,
    and the remainder can be used by\n   higher level protocols.  The second part
    of the message, the\n   \"Associated Data,\" can be optionally included with the
    message\n   proper.  In most cases (transmission over HYPERchannel A trunks),
    the\n   length of the associated data is literally unlimited.  Others (such\n
    \  as HYPERchannel B or transmission within a local HYPERchannel A A400\n   adapter)
    limit the size of the Associated Data to 4K bytes.  If the\n   information sent
    can be contained within the Message Proper, then the\n   Associated Data need
    not be sent.\n   HYPERchannel lower link protocols treat messages with and without\n
    \  Associated Data quite differently; \"Message only\" transmissions are\n   sent
    using abbreviated protocols and can be queued in the receiving\n   network adapter,
    thus minimizing the elapsed time needed to send and\n   receive the messages.
    \ When associated data is provided, the\n   HYPERchannel A adapters free their
    logical resources towards driving\n   the host interface and coaxial trunks.\n"
  - "BASIC (16-BIT ADDRESS) MESSAGE PROPER HEADER\n   The first 10 bytes of the network
    Message Proper are examined by the\n   network adapters to control delivery of
    the network message.  Its\n   format is as follows:\n    byte   Message Proper\n
    \        +------------------------------+-----------------------------+\n      0
    \ |      Trunks to Try           |        Message Flags        |\n         |   TO
    trunks  |  FROM trunks  |                 |EXC|BST|A/D|\n         +--------------+---------------+-----------------+---+---+---+\n
    \     2  |                        Access code                         |\n         |
    \                                                           |\n         +------------------------------+-----------------------------+\n
    \     4  |       Physical addr of       |                   | TO Port |\n         |
    \    destination adapter (TO) |                   | number  |\n         +------------------------------+-----------------------------+\n
    \     6  |  Physical addr of source     |                   |FROM port|\n         |
    \       adapter (FROM)        |                   |  number |\n         +------------------------------+-----------------------------+\n
    \     8  |                        Message type                        |\n         |
    \                                                           |\n         +------------------------------+-----------------------------+\n
    \    10  |                                                            |\n         |
    \           Available for higher level protocols            |\n         |                                                            |\n
    \        |                                                            |\n         +------------------------------+-----------------------------+\n"
  - "TRUNKS TO TRY\n   Consists of two four bit masks indicating which of four possible\n
    \  HYPERchannel A coaxial data trunks are to be used to transmit the\n   message
    and to return it.  If a bit in the mask is ON, then the\n   adapter firmware will
    logically AND it with the mask of installed\n   trunk interfaces and use the result
    as a candidate list of\n   interfaces.  Whenever one of the internal \"frames\"
    are sent to\n   communicate with the destination adapter, the transmission hardware\n
    \  electronically selects the first non-busy trunk out of the list of\n   candidates.
    \ Thus, selection of a data trunk is best performed by the\n   adapter itself
    rather than by the host.  \"Dedicating\" trunks to\n   specific applications only
    makes sense in very critical real time\n   applications such as streaming data
    directly from high speed\n   overrunnable peripherals.\n   A second Trunk mask
    is provided for the receiving adapter when it\n   sends frames back to the transmitter,
    as it is possible to build\n   \"asymmetric\" configurations of data trunks where
    trunk 1 on one box\n   is connected to the trunk 3 interface of a second.  Such\n
    \  configurations are strongly discouraged, but the addressing structure\n   supports
    it if needed.\n   The \"trunks to try\" field is only used by HYPERchannel A.
    \ To assure\n   maximum interoperability, a value of 0xFF should be placed in
    this\n   field to assure delivery over any technology.  Other values should\n
    \  only be used if the particular site hardware is so configured to not\n   be
    physically connected via those trunks.\n"
  - "MESSAGE FLAGS\n   Contains options in message delivery.  In the basic type of
    message,\n   three bits are used:\n   ASSOCIATED DATA PRESENT (A/D) is ON if an
    Associated Data block\n   follows the Message Proper.  0 if only a message proper
    is present in\n   the network message.  The value of this bit is enforced by the\n
    \  network adapter firmware.\n   BURST MODE (BST) Enables a special mode for time
    critical transfers\n   where a single HYPERchannel A coaxial trunk is dedicated
    during\n   transmission of the network message.  Not recommended for anything\n
    \  that won't cause peripheral device overruns if data isn't delivered\n   once
    message transmission starts.\n   EXCEPTION (EXC) Indicates to some channel programmed
    host interfaces\n   that the message is \"out of band\" in some way and requires
    special\n   processing.\n"
  - "ACCESS CODE\n   A feature to permit adapters to share use of a cable yet still
    permit\n   an \"access matrix\" of which adapter boxes and physically talk to\n
    \  which others.  Not currently in use by anyone, support is being\n   discontinued.\n"
  - "TO ADDRESS\n   Consists of three parts.  The high order 8-bits contains the physical\n
    \  address of the network adapter box which is to receive the message.\n   The
    low order 8-bits are interpreted in different ways depending on\n   the nature
    of the receiving network adapter.  If the receiving\n   adapter has different
    host \"ports,\" then the low order bits of the TO\n   field are used to designate
    which interface is to receive the\n   message.  On IBM data channels, the entire
    \"logical\" TO field is\n   interpreted as the subchannel on which the incoming
    data is to be\n   presented.  Parts of the logical TO field that are not interpreted
    by\n   the network adapter are passed to the host for further\n   interpretation.\n"
  - "FROM ADDRESS\n   The FROM address is not physically used during the process of\n
    \  transmitting a network message, but is passed through to the\n   receiving
    host so that a response can be returned to the point of\n   origin.  In general,
    reversing the TO and FROM 16-bit address fields\n   and the TO and FROM trunk
    masks can reliably return a message to its\n   destination.\n"
  - "MESSAGE TYPE\n   The following two bytes are reserved for NSC.  Users have been\n
    \  encouraged to put a zero in byte 8 and anything at all in byte 9 so\n   as
    to not conflict with internal processing of messages by NSC\n   firmware.  In
    the past, this field has been loosely defined as\n   carrying information of interest
    to NSC equipment carrying the\n   message and not as a formal protocol type field.
    \ For example, 0xFF00\n   in bytes 8 and 9 of the message will cause the receiving
    adapter to\n   \"loop back\" the message without delivering it to the attached
    host.\n   Concurrent with this document, it is NSC's intent to use both bytes
    8\n   and 9 as a formal \"protocol type\" designator.  Major protocols will\n
    \  be assigned a unique value in byte 8 that will (among good citizens)\n   not
    duplicate a value generated by a different protocol.  Minor\n   protocols will
    have 16-bit values assigned to them so that we won't\n   run out when 256 protocols
    turn up.  Any interested party could\n   obtain a protocol number or numbers by
    application to NSC.  In this\n   document, protocol types specific to IP protocols
    are assigned.\n"
  - "TO ADDRESSES AND OPEN DRIVER ARCHITECTURE\n   Since not all 16-bits of the TO
    address are used for the physical\n   delivery of the network message, the remainder
    are considered\n   \"logical\" in that their meaning is physically determined
    by host\n   computer software or (in cases such as the FIPS data channel) by\n
    \  hardware in the host interface.\n   Since HYPERchannel is and will be used
    to support a large variety of\n   general and special purpose protocols, it is
    desirable that several\n   independent protocol servers be able to independently
    share the\n   HYPERchannel network interface.  The implementation of many of NSC's\n
    \  device drivers as well as those of other parties (such as Cray\n   Research)
    support this service.  Each protocol server that wishes to\n   send or receive
    HYPERchannel network messages logically \"connects\" to\n   a HYPERchannel device
    driver by specifying the complete 16-bit TO\n   address it will \"own\" in the
    sense that any network message with that\n   TO address will be delivered to that
    protocol server.\n   The logical TO field serves a function similar to the TYPE
    byte in\n   the Ethernet 802.2 message header, but differs from it in that the\n
    \  width of the logical TO field varies from host to host, and that no\n   values
    of the logical TO address are reserved for particular\n   protocols.  On the other
    hand, it is possible to have several\n   \"identical\" protocols (such as two
    independent copies of IP with\n   different HYPERchannel addresses) sharing the
    same physical\n   HYPERchannel interface.  This makes NSC's addressing approach\n
    \  identical to the OSI concept that the protocol server to reach is\n   embedded
    within the address, rather than the IP notion of addressing\n   a \"host\" and
    identifying a server through a message type.\n   Since the HYPERchannel header
    also has a \"message type\" field, there\n   is some ambiguity concerning the
    respective roles of the message type\n   and logical TO fields:\n    o   The logical
    TO field is always used to identify the protocol\n        server which will receive
    the message.  Once a server has\n        specified the complete TO address for
    the messages it wishes to\n        receive, the message will not be delivered
    to a different\n        protocol server regardless of the contents of the message
    type\n        field.\n    o   Although the \"type\" field cannot change the protocol
    server at\n        the final destination of the message, the type field can be
    used\n        by intermediate processes on the network to process the message\n
    \       before it reaches the server destination.  An obvious example is\n        the
    0xFF00 message loopback type function, where network\n        processing to loop
    back the message results in nondelivery to\n        the TO address.  In the future,
    intermediate nodes may process\n        \"in transit\" messages based on the message
    type only for\n        purposes such as security validation, aging of certain\n
    \       datagrams, and network management.\n"
  - "EXTENDED (32-BIT ADDRESS) MESSAGE PROPER HEADER\n   In the original days of HYPERchannel,
    the limitation of 256 adapter\n   \"boxes\" that could be addressed in a network
    message was deemed\n   sufficient as 40 or so adapters was considered a \"large\"
    network.  As\n   with the Ethernet, more recent networks have resulted in a need
    to\n   address larger networks.  Although a few ad hoc modes have existed to\n
    \  address larger HYPERchannel networks for some years, newer\n   technologies
    of HYPERchannel equipment have logically extended the\n   network message to support
    32-bits of addressing, with 24 of those\n   bits to designate a physical network
    adapter.\n   This 32-bit header has been designed so that existing network\n   adapters
    are capable of sending and receiving these messages.  Only\n   the network bridges
    need the intelligence to select messages\n   designated for them.\n        +------------------------------+-----------------------------+\n
    \    0  |      Trunks to Try           |        Message Flags        |\n        |
    \  TO trunks  |  FROM trunks  |GNA|CRC|     |SRC|EXC|BST|A/D|\n        +--------------+---------------+---+---+--+--+---+---+---+---+\n
    \    2  |         TO Domain #          |         TO Network #        |\n        |
    \                             |                             |\n        +------------------------------+-----------------------------+\n
    \    4  |O|    Physical addr of        |                   | TO Port |\n        |N|
    \ destination adapter (TO)  |                   | number  |\n        +------------------------------+-----------------------------+\n
    \    6  |O| Physical addr of source    |                   |FROM port|\n        |N|
    \    adapter (FROM)         |                   |  number |\n        +------------------------------+-----------------------------+\n
    \    8  |                         Message type                       |\n        |
    \                                                           |\n        +------------------------------+-----------------------------+\n
    \    10 |          FROM Domain #       |       FROM Network #        |\n        |
    \                             |                             |\n        +------------------------------+-----------------------------+\n
    \    12 |          - reserved -        |         age count           |\n        |
    \                             |                             |\n        +------------------------------+-----------------------------+\n
    \    14 |      Next Header Offset      |      Header End Offset      |\n        |
    \       (normally 16)         |        (normally 16)        |\n        +------------------------------+-----------------------------+\n
    \    16 |                  Start of user protocol                    |\n        |
    \             bytes 16 - 64 of message proper               |\n        |                                                            |\n
    \       +------------------------------+-----------------------------+\n          Associated
    Data\n   +-----------------------------------------------------------------+\n
    \  |                                                                 |\n   |     As
    with basic format network messages                       |\n   |                                                                 |\n
    \  +-----------------------------------------------------------------+\n"
  - "ADDRESS RECOGNITION AND MESSAGE FORWARDING\n   With the 32-bit form of addressing,
    NSC is keeping with the premise\n   that the native HYPERchannel address bears
    a direct relation to the\n   position of the equipment in an extended HYPERchannel
    network.\n   Each collection of \"locally\" attached NSC network adapters that
    are\n   connected by coax or fiber optic cable (with the possible addition of\n
    \  nonselective repeaters such as the ATRn series) is considered a\n   \"network\".
    \ Each network can have up to 256 directly addressable\n   adapters attached to
    it which can be reached by the basic format\n   network message.\n   Existing
    bridges or \"link adapters\" can be programmed to become\n   \"selective repeaters\"
    in that they can receive network messages\n   containing a subset of network addresses
    send them over the bridge\n   medium (if present) and reintroduce them on the
    other network.  Such\n   interconnected local area networks are considered a single
    network\n   from an addressing point of view.\n   A large NSC network can have
    up to 64K networks which can be\n   complexly interconnected by network bridges
    and/or \"backbone\"\n   networks which distribute data between other networks.
    \ To simplify\n   the mechanics of message forwarding, the 16-bit network field
    is\n   divided into two eight quantities, a \"network number\" identifying\n   which
    network is to receive the message and a \"domain number\" which\n   specifies
    which network of networks is the recipient.\n   The bridge technology adapters
    which move messages between networks\n   have address recognition hardware which
    examines all the 24-bits in\n   bytes 2-5 of the network message header to determine
    if the bridge\n   should accept the message for forwarding.  At any given instant
    of\n   time in the network, each bridge will have a list of networks and\n   domains
    that it should accept for forwarding to a network at the\n   other end of the
    bridge.  Each Adapter (Including Newer Technology\n   host adapters) contains
    in address recognition hardware:\n    o   domainmask -- a 256-bit mask of domain
    numbers that should  be\n        accepted for forwarding (not local processing)
    by this adapter.\n    o   MyDomain  --  the  value  of the domain on which this
    host\n        adapter or bridge end is installed.\n    o   NetworkMask -- a 256-bit
    mask of network numbers that should be\n        accepted for forwarding by this
    adapter.\n    o   MyNetwork  -  the  value of the network on which this host\n
    \       adapter or bridge end is installed.\n    o   AddressMask -- A 256-bit
    mask of the local network addresses\n        that should be accepted by the adapter.\n
    \   o   MyAddress -- the \"base address\" of the box, which must be\n        supplied
    in any message that is directed to control processes\n        within the adapter,
    such as a loopback message.\n   Address recognition takes place using the algorithm:\n
    \          IF Domain IN DomainMask OR\n              IF (Domain = MyDomain AND
    Network IN NetworkMask) OR\n                 IF (Domain = MyDomain AND Network
    = MyNetwork AND\n                    Address IN AddressMask) THEN accept-message\n
    \                                           ELSE ignore-message.\n   This algorithm
    means that an adapter's hardware address recognition\n   logic will accept any
    messages to the box itself, any secondary or\n   aliased local addresses owned
    by the adapter, and any message\n   directed to a remote network or domain that
    that particular adapter\n   is prepared to forward.\n"
  - '32-BIT MESSAGE FIELDS

    '
  - "TRUNK MASK\n   Is as in the basic network message.  Messages that are to be\n
    \  delivered outside the immediate network should have 0xFF in this byte\n   so
    that all possible trunks in intermediate networks should be tried.\n   Locally
    delivered 32-bit messages may still contain specially\n   tailored trunk masks
    to satisfy local delivery needs.\n"
  - "MESSAGE FLAGS\n   The currently defined bits remain as before.  Three new bits
    have\n   been defined since that time.\n   CRC (END-END MESSAGE INTEGRITY).  Newer
    technology host adapters are\n   capable of generating a 32-bit CRC for the entire
    network message as\n   soon as it is received over the channel or bus interface
    from the\n   host.  This 32-bit CRC is appended to the end of the associated data\n
    \  block and is preserved through the entire delivery process until it\n   is
    checked by the host adapter that is the ultimate recipient of the\n   message,
    which removes it.  This end to end integrity checking is\n   designed to provide
    a high degree of assurance that data has been\n   correctly moved through all
    intermediate LAN's, geographic links, and\n   internal adapter hardware and processes.\n
    \  SRC (SOURCE FROM ADDRESS CORRECT).  This bit is provided to take\n   advantage
    of the physical nature of the network address to optionally\n   verify that the
    32-bit FROM address provided in the network message\n   is in fact the location
    that the message originated.  If the bit is\n   not set by the transmitting host,
    no particular processing occurs on\n   the message.  If the bit is set, then all
    intermediate adapters\n   involved in the delivery of the message have the privilege
    of turning\n   the bit off if the received message FROM address is not a TO address\n
    \  that would be delivered to the originator if the message were going\n   the
    opposite direction.\n   If the message is received by a host computer with this
    bit still\n   set, then the FROM address is guaranteed correct in the sense that\n
    \  returning a message with TO and FROM information reversed will result\n   in
    delivery of the message to the process that actually originated\n   it.  By careful
    attention to the physical security of adapters and\n   intermediate links between
    networks, a high degree of security can be\n   built into systems that simply
    examine the FROM address of a message\n   to determine the legitimacy of its associated
    request.\n   GNA (GLOBAL NETWORK ADDRESSING).  This bit ON indicates that 32-bit\n
    \  addressing is present in the message.  When this bit is on, bytes 2-3\n   (Domain
    and Network numbers) should also be nonzero.\n"
  - "TO ADDRESS\n   Four bytes contain the TO address, which is used to deliver the\n
    \  network message as described in \"Address Recognition and Message\n   Forwarding\"
    on page 8.  The \"logical\" part of the TO address is used\n   to designate a
    protocol server exactly as in the basic format network\n   message header.\n   The
    existing \"address\" field has its high order bit reserved as an\n   outnet bit
    for compatibility with existing A-series network adapter\n   equipment.  Were
    it not for this bit, the A-series adapters would\n   attempt to accept messages
    that were \"passing through\" the local\n   network on their way elsewhere simply
    because the address field\n   matched while the the Domain and Network numbers
    (ignored by the A-\n   series adapters) were quite different.\n   This \"outnet\"
    bit is used in the following way:\n    o   All network adapters (of  any type)
    in an extended set of\n        networks containing A-Series adapters that will
    ever use 32-bit\n        addressing must have their addresses in the range 00-7F
    (hex.)\n    o   If a message is to be sent to a destination on a nonlocal\n        network
    and domain on such an extended network, then the\n        high order bit of the
    address field is turned on.\n    o   When the last bridge in the chain realizes
    that it is about to\n        forward the message to its final destination (the
    Domain and\n        Network numbers are local), then it turns the Outnet bit off.\n
    \       This will result in local delivery to the destination adapter.\n"
  - "FROM ADDRESS\n   The FROM address follows the same logic as the TO address in
    that any\n   message can be returned to its source by reversing the FROM and TO\n
    \  fields of the message.  Since so many protocols examine byte 8 of the\n   message
    to determine its type, the FROM field has been split so that\n   the Domain and
    Network numbers extend into bytes 10-11.\n"
  - "MESSAGE TYPE\n   This field (informally defined in the past) has been extended
    to 16-\n   bits so that a unique value can be assigned to any present or future\n
    \  protocol which is layer on HYPERchannel messages for either private\n   or
    public use.\n"
  - "AGE COUNT\n   This field serves the same purpose as the IP \"time to live\" in
    that\n   it prevents datagrams from endlessly circulating about in an\n   improperly
    configured network.  Each time a 32-bit message passes\n   through a bridge, the
    Age Count is decremented by one.  When the\n   result is zero, the message is
    discarded by the bridge.\n"
  - "NEXT HEADER OFFSET AND HEADER END OFFSET\n   These are used as fields to optionally
    provide \"loose source\n   routing\", where a list of 32-bit TO addresses can
    be provided by the\n   transmitter to explicitly determine the path of a message
    through the\n   network.  If this feature is not used, both these fields would\n
    \  contain the value 16 (decimal) to both indicate extra TO addresses\n   are
    absent and that the beginning of protocol data following the\n   HYPERchannel
    header is in byte 16.\n   Although it is conceivable that a HYPERchannel IP process
    could use\n   this source routing capability to direct messages to hosts or\n
    \  gateways, this capability is not felt to be of sufficient value to IP\n   to
    build it into a HYPERchannel IP protocol.\n   In the future, all higher level
    protocols should be able to examine\n   Header End Offset to determine the start
    of the higher level protocol\n   information.\n"
  title: BASIC HYPERCHANNEL NETWORK MESSAGES
- contents:
  - "BROADCASTING\n   NSC message forwarding protocols use low level link protocols
    to\n   negotiate transmission of a message to its next destination on the\n   network.
    \ Furthermore, NSC network boxes often \"fan out\" so that\n   several hosts share
    the same network transmission equipment as in the\n   A400 adapter.  Both these
    characteristics mean that providing a\n   genuine broadcast capability is not
    a trivial task, and in fact no\n   current implementations of NSC technology support
    a broadcast\n   capability.\n   The last several years have seen broadcast applications
    mature to the\n   point where they have virtually unquestioned utility on a local
    and\n   sometimes campuswide basis.  Accordingly, new NSC technologies will\n
    \  support a broadcast capability.  Information on the use of this\n   capability
    is included here as it is essential to the discussion of\n   the Address Resolution
    Protocol later in this document.\n   Broadcast capability will be supported only
    with the extended (32-bit\n   address) message format.  A broadcast message will
    have the following\n   general appearance:\n    byte   Message Proper\n         +------------------------------+-----------------------------+\n
    \     0  |      Trunks to Try           |        Message Flags        |\n         |
    \  TO trunks  |  FROM trunks  |GNA|CRC|     |SRC|EXC|BST|A/D|\n         +--------------+---------------+---+---+--+--+---+---+---+---+\n
    \     2  |       TO Domain Number       |      TO Network Number      |\n         |
    \         or 0xFF             |          or 0xFF            |\n         +------------------------------+-----------------------------+\n
    \     4  |           0xFF               |   Broadcast channel number  |\n         |
    \                             |                             |\n         +------------------------------+-----------------------------+\n
    \     6  |O| Physical addr of source    |                   |FROM port|\n         |N|
    \    adapter (FROM)         |                   |  number |\n         +------------------------------+-----------------------------+\n
    \     8  |                         Message type                       |\n         |
    \                                                           |\n         +------------------------------+-----------------------------+\n
    \     10 |     FROM Domain Number       |    FROM Network Number      |\n         |
    \                             |                             |\n         +------------------------------+-----------------------------+\n
    \     12 |          - reserved -        |         age count           |\n         |
    \                             |                             |\n         +------------------------------+-----------------------------+\n
    \     14 |      Next Header Offset      |      Header End Offset      |\n         |
    \       (normally 16)         |        (normally 16)        |\n         +------------------------------+-----------------------------+\n
    \     16 |                  Start of user protocol                    |\n         |
    \             bytes 16 - 64 of message proper               |\n         |                                                            |\n
    \        +------------------------------+-----------------------------+\n          Associated
    Data\n    +-----------------------------------------------------------------+\n
    \   |                                                                 |\n    |
    \    As with basic format network messages                       |\n    |     Maximum
    associated data size 1K bytes.                      |\n    |                                                                 |\n
    \   +-----------------------------------------------------------------+\n"
  - "TRUNKS TO TRY AND MESSAGE FLAGS\n   These fields are defined just as with a normal
    32-bit message.  All\n   bits in the Message Flags field are valid with broadcast
    modes.\n"
  - "BROADCAST ADDRESS\n   For Domain, Network and Adapter Address fields, the value
    0xFF is\n   reserved for use by the broadcast mechanism.  A value of 0xFF in the\n
    \  adapter address field indicates to the local network hardware that\n   this
    message is to be sent to all connected network equipment on the\n   individual
    network.\n   A value of 0xFF in the network or domain fields, respectively\n   indicates
    a request that the scope of the broadcast exceed the local\n   network.  The bridging
    link adapters will receive the broadcast\n   message along with everyone else
    and will examine the \"Broadcast\n   Channel\" field and their internal switches
    to determine if the\n   message should be forwarded to other remote networks.\n
    \  If the Network and Domain fields contain the local network and\n   domain,
    then the broadcast message will only be broadcast within the\n   local network.
    \ If a remote Network and Domain is specified, then the\n   message will be delivered
    as a single message to the remote network\n   and broadcast there.\n"
  - "BROADCAST CHANNEL\n   Since individual hosts and protocol servers generally are
    not\n   interested in all broadcast messages that float about the network, a\n
    \  filtering mechanism is provided in the header and network adapter\n   equipment
    so that only proper classes of broadcast messages are\n   delivered to the end
    point.\n   Broadcast channel numbers in the range 00-0xFF will be assigned by\n
    \  NSC much like the \"message type\" field.  Host protocol servers\n   specify
    a specific TO address containing a channel number (such as\n   0xFF04) when they
    bind themselves to the HYPERchannel device driver.\n   The driver and the underlying
    equipment will deliver only broadcast\n   messages with the correct channel number
    to the protocol server.  If\n   a protocol server wishes to receive several different
    broadcast\n   messages, it must bind itself to the driver several times with the\n
    \  desired addresses.\n   Link adapters that are prepared to handle multinetwork
    broadcast\n   messages may be equipped with switches to determine which broadcast\n
    \  channels will be propagated into the next network.  Since\n   multinetwork
    broadcast is an arrangement that must be configured with\n   care, these switches
    are off by default.\n"
  - "FROM ADDRESS\n   The FROM address is constructed just as with a normal 32-bit
    network\n   message.  The Source Address Correct bit is processed just as with
    a\n   normal message.\n"
  - "MESSAGE TYPE\n   Message type is defined as with normal messages.  Presumably\n
    \  broadcast applications will have unique message types that are not\n   generally
    found in normal messages.\n"
  - "AGE COUNT\n   Age count is vitally important in a multinetwork broadcast as \"loops\"\n
    \  in the network can cause a great deal of activity until all the\n   progeny
    of the original broadcast message die out.\n"
  title: BROADCASTING
- contents:
  - "PROTOCOL SPECIFICATION\n   This section contains information on the technique
    used to\n   encapsulate IP datagrams on the HYPERchannel network message.  It\n
    \  contains three sections to describe three protocol packagings:\n    o   The
    technique used to encapsulate IP datagrams on the basic\n        16-bit network
    message.  This is a de facto standard that has\n        been in use for several
    years and is documented here to make it\n        official.\n    o   The encapsulation
    technique for IP datagrams on 32 bit network\n        messages.\n    o   The definition
    of an Address Resolution Protocol on\n        HYPERchannel.\n"
  - "BASIC (16-BIT) MESSAGE ENCAPSULATION\n           Message Proper\n         +------------------------------+-----------------------------+\n
    \     0  |      Trunks to Try           |        Message Flags        |\n         |
    \  TO trunks  |  FROM trunks  |GNA|CRC|     |SRC|EXC|BST|A/D|\n         +------------------------------+-----------------------------+\n
    \     2  |                      Access code 0000                      |\n         |
    \                  (no longer supported)                    |\n         +------------------------------+-----------------------------+\n
    \     4  |       Physical addr of       |  Protocol server  |Dest Port|\n         |
    \    destination adapter      |  logical address  | number  |\n         +------------------------------+-----------------------------+\n
    \     6  |       Physical addr of       |    Originating    | Src Port|\n         |
    \      source  adapter        |  server address   |  number |\n         +------------------------------+-----------------------------+\n
    \     8  |    IP on HYPERchannel        |   Offset to start of IP     |\n         |
    \   type code  0x05           |  header from message start  |\n         +------------------------------+-----------------------------+\n
    \    10  |      IP type designator      |   Offset to start of IP     |\n         |
    \          0x34               |    header from byte 12      |\n         +------------------------------+-----------------------------+\n
    \    12  |          Padding (variable length incl. zero bytes)        |\n         |
    \                                                           |\n         +------------------------------+-----------------------------+\n
    \    Off |          First (64-Offset) bytes of IP datagram            |\n         |
    \                                                           |\n         |                                                            |\n
    \        |                                                            |\n         +------------------------------+-----------------------------+\n
    \          Associated Data\n         +------------------------------+-----------------------------+\n
    \        |                                                            |\n         |
    \               Remainder of IP datagram                    |\n         |                                                            |\n
    \        |            No associated data is present if IP             |\n         |
    \           datagram fits in the Message Proper             |\n         |                                                            |\n
    \        +------------------------------+-----------------------------+\n"
  - "TRUNK MASK\n   From the vantage of an IP driver, any trunk mask is valid so long
    as\n   it results in successful delivery of the HYPERchannel network message\n
    \  to its destination.  There is no reason to check this field for\n   validity
    on reception of the message.  Specification of the Trunk\n   Mask on output is
    a local affair that could be specified by the\n   transmitting driver's address
    resolution tables.\n"
  - "MESSAGE FLAGS\n   No use is made of the Flags field (byte 1) other than to\n
    \  appropriately set the Associated Data bit.  Burst Mode and the\n   Exception
    bit should not be used with IP.\n"
  - "ACCESS CODE\n   Although some current implementations of IP on HYPERchannel support\n
    \  the access code, no one appears to be using it at the current time.\n   Since
    this field is currently reserved for the use of 32-bit\n   addresses, no value
    other than 0000 should be placed in this field.\n"
  - "TO ADDRESS\n   The TO field is generally obtained by a local IP driver through
    a\n   table lookup algorithm where a 16-bit TO address is found that\n   corresponds
    to the IP address of a local host or gateway.  The high\n   order bits of the
    TO address of course refer to the adapter number\n   the adapter attached to the
    destination host.\n   The logical TO field should contain the protocol server
    address of\n   the HYPERchannel IP driver for that host as determined by the host's\n
    \  system administrator.  Many HYPERchannel TCP/IP drivers in the field\n   today
    are not \"open\" in that any network message delivered to that\n   host will be
    presumed to be an IP datagram regardless of the logical\n   TO field; however
    any transmitting IP process should be capable of\n   generating the entire 16-bit
    TO field in order to generate a message\n   capable of reaching a destination
    IP process.\n   The process of determining which HYPERchannel address will receive
    an\n   IP datagram based on its IP address is a major topic that is covered\n
    \  in \"Address Resolution\".\n"
  - "FROM ADDRESS\n   The FROM address is filled in with the address that the local
    driver\n   expects to receive from the network, but no particular use is make
    of\n   the FROM address.\n"
  - "MESSAGE TYPE\n   Network Systems requests that a value of 5 (decimal) be placed
    in\n   this byte to uniquely indicate that the network message is being used\n
    \  to carry IP traffic.  No other well-behaved protocol using\n   HYPERchannel
    should duplicate this value of 5.\n   Many current implementations of IP on HYPERchannel
    place a zero or\n   other values in this field simply because no value was reserved
    for\n   IP usage.  Transmitting versions of IP should always place a 5 in\n   this
    field; receiving IP's should presume a delivered message to be\n   an IP datagram
    until proven otherwise regardless of the contents of\n   the Message Type field.\n
    \  Developers should note that it is often convenient to permit\n   reception
    of the value 0xFF00 in bytes 8 and 9 of the IP datagram.\n   Transmitting a message
    with this value will cause it to be looped\n   back at the destination adapter
    and returned to the protocol server\n   designate in the FROM address.  This permits
    the developer have host\n   applications talk to others on the same host for purposes
    of network\n   interface or other protocol debugging.\n"
  - "IP HEADER OFFSET\n   Byte 9 contains the offset to the start of the IP header
    within the\n   message proper, such that the Message Proper address plus the IP\n
    \  header offset generates the address of the first byte of the IP\n   header
    (at least on byte addressable machines.)\n   This field is redundant with the
    offset field in byte 11, and is\n   present for cosmetic compatibility with 32-bit
    implementations.  On\n   reception, the value in byte 11 should take precedence.\n
    \  As part of the migration to larger HYPERchannel headers, this field\n   will
    become significant with the 32-bit addressing format, as the\n   length of the
    header is no longer 10 bytes and byte 11 is used for\n   other purposes.\n"
  - "IP TYPE DESIGNATOR\n   Early implementations of IP drivers on HYPERchannel wanted
    to leave\n   bytes 8 and 9 alone for NSC use and place a \"message type\" field
    in\n   later in the message.  A value of 0x34 had been selected by earlier\n   developers
    for reasons that are now of only historical interest.\n   Once again, implementations
    should generate this value on\n   transmission, but not check it on input, assuming
    that an IP datagram\n   is present in the message.\n"
  - "IP HEADER OFFSET\n   This value is used by a number of commercial implementations
    of IP on\n   HYPERchannel to align the start of the IP header within the network\n
    \  message.  This offset is relative to byte 12 of the network message\n   so
    that a value of zero indicates that the IP header begins in byte\n   12.  This
    value should be both correctly generated on transmission,\n   and always respected
    on input processing.\n   The maximum permissible offset in this field is 52 indicating
    that\n   the IP header begins at the start of the associated data block.\n"
  - "IP DATAGRAM CONTENTS\n   Beginning at the offset designated in byte 11, the IP
    datagram is\n   treated as a contiguous block of data that flows from byte 63
    of the\n   message proper into the first byte of associated data, so that the\n
    \  entire message plus data is treated as a single contiguous block.\n   If the
    IP header is small enough to fit within the entire network\n   message, then only
    the message proper is transmitted.  The length of\n   the message proper sent
    should always be 64 bytes, even if the IP\n   datagram and HYPERchannel header
    do not occupy all 64 bytes of the\n   message proper.\n   If the datagram flows
    over into the associated data, then both\n   message and data are sent.  Since
    a number of machines cannot send a\n   length of data to the HYPERchannel that
    is an exact number of bytes\n   (due to 16-64 bits on the channel bus,) the length
    of the associated\n   data received should not be used as a guide to the length
    of the IP\n   datagram -- this should be extracted from the IP header.  A driver\n
    \  should verify, of course, that the associated data received is at\n   least
    as long as is needed to hold the entire IP datagram.\n"
  - "COMPATIBILITY WITH EXISTING IMPLEMENTATIONS\n   The basic format described here
    is clearly a compromise between\n   several implementations of IP on HYPERchannel.
    \ Not all existing\n   implementations are interoperable with the standard described
    above.\n   Currently there are two known \"families\" of IP HYPERchannel drivers\n
    \  in existence:\n"
  - "THE \"CRAY-NASA AMES\" PROTOCOL\n   This protocol is in the widest production
    use and has the largest\n   number of supported drivers in existence.  It is interoperable
    and\n   identical with the standard described above with the sole exception\n
    \  that bytes 8 and 9 are set to zero by these drivers.  As these bytes\n   are
    ignored by most implementations of this driver, they have been\n   assigned values
    to formalize the use of the message type field and to\n   make it consistent with
    the 32-bit protocol.\n"
  - "THE \"TEKTRONIX-BERKELEY\" PROTOCOL\n   This protocol was historically the first
    IP on HYPERchannel\n   implementation developed (at Tektronix) and subsequently
    made its way\n   to Berkeley and BSD UNIX.  This protocol is not interoperable
    with\n   the standard described above due to several distinct differences.\n   First,
    bytes 8 through 11 are always zero.  The IP header always\n   starts on byte 12.
    \ Comments in some of these drivers designate byte\n   11 as an \"IP header offset\"
    field, but apparently this value is never\n   processed.\n   The major difference
    (and the incompatibility) concerns the packaging\n   of the IP datagram into the
    network message.  Due to historical\n   difficulties in the early 80's with the
    sending and receiving of very\n   small blocks of associated data on VAXes, this
    protocol the takes a\n   curious approach to the placement of the IP header and
    the headers of\n   higher level protocols (such as TCP or UDP.)\n    o   If the
    entire length of the IP datagram is 54 bytes or less,\n        it is possible
    to fit the entire datagram and the HYPERchannel\n        header in the 64 byte
    message proper.  In this case, no\n        associated data is sent; only a message
    proper is used to carry\n        the data.  The length of the message proper transmitted
    is the\n        exact length needed to enclose the IP datagram; no padding bytes\n
    \       are sent at the end of the message.\n    o   If the length of the IP header
    is greater than 54 bytes, then:\n        -   All higher level protocol information
    (TCP/UDP header and\n            their associated  data fields) are placed in
    the associated\n            data block, with the TCP/UDP header beginning at the
    start\n            of the associated data block.\n        -   On transmission,
    the length of the message proper\n            transmitted is set to the length
    of the HYPERchannel header\n            plus the IP header --  it is not padded
    out to 64 bytes.\n            The length of the associated data sent should be
    sufficient\n            to accommodate the TCP/UDP header and its data fields.\n"
  - "WHICH PROTOCOL IS BEST?\n   In choosing which to follow, the \"Cray-Ames\" approach
    was taken for\n   several reasons:\n    1.  Cray Research has performed exemplary
    work in dealing with other\n        vendors to provide IP on HYPERchannel from
    the Cray computers to\n        other hosts.  As a result, there are 4 or 5 vendor
    supported\n        implementations of IP on HYPERchannel that use this approach.\n
    \   2.  The two part structure of the message proper has its uses when a\n        machine
    wishes to make protocol decisions before staging the\n        transfer of an immense
    block of associated data into memory.\n        Many network coprocessors and intelligent
    I/O subsystems find it\n        simpler to read in the entire network message
    before deciding\n        what to do with it.  Arbitrarily catenating the two components\n
    \       does this best and permits streaming of messages from future\n        technology
    network adapters.\n    3.  Some TCP users (mostly  secure  DoD  sites) intend
    to load up IP\n        datagrams with optional fields in the future.  The\n        Tektronix-Berkeley
    implementation has problems if the IP header\n        length exceeds 54 bytes.\n"
  - "EXTENDED (32-BIT) MESSAGE ENCAPSULATION\n           Message Proper\n         +------------------------------+-----------------------------+\n
    \     0  |      Trunks to Try           |1|       Message Flags       |\n         |
    \  TO trunks  |  FROM trunks  |GNA|CRC|     |SRC|EXC|BST|A/D|\n         +------------------------------+-----------------------------+\n
    \     2  |    Destination  Domain       |    Destination  Network     |\n         |
    \        Number               |           Number            |\n         +------------------------------+-----------------------------+\n
    \     4  |O|     Physical addr of       |  Protocol server  |Dest Port|\n         |N|
    \ destination adapter       |  logical address  | number  |\n         +------------------------------+-----------------------------+\n
    \     6  |O|     Physical addr of       |    Originating    | Src Port|\n         |N|
    \    source  adapter        |  server address   |  number |\n         +------------------------------+-----------------------------+\n
    \     8  |    IP on HYPERchannel        |   Offset to start of IP     |\n         |
    \   type code  0x06           |      datagram header        |\n         +------------------------------+-----------------------------+\n
    \     10 |    Source Domain Number      |   Source Network Number     |\n         |
    \                             |                             |\n         +------------------------------+-----------------------------+\n
    \     12 |          - reserved -        |         Age Count           |\n         +------------------------------+-----------------------------+\n
    \     14 |      Next Header Offset      |      Header End Offset      |\n         |
    \                             |       (usually 16)          |\n         +------------------------------+-----------------------------+\n
    \     16 |         Padding to IP header start (usually 0 bytes)       |\n         |
    \                                                           |\n         +------------------------------+-----------------------------+\n
    \     Off|     Entire IP datagram if datagram length <= (64-Offset)   |\n         |
    \                                                           |\n         |        else
    first (64-Offset) bytes of IP datagram         |\n         +------------------------------+-----------------------------+\n
    \          Associated Data\n         +------------------------------+-----------------------------+\n
    \        |                                                            |\n         |
    \                  Remainder of IP datagram                 |\n         |                                                            |\n
    \        |            No associated data is present if IP             |\n         |
    \           datagram fits in the Message Proper             |\n         |                                                            |\n
    \        +------------------------------+-----------------------------+\n"
  - "TRUNK MASK\n   From the vantage of an IP driver, any trunk mask is valid so long
    as\n   it results in successful delivery of the HYPERchannel network message\n
    \  to its destination.  There is no reason to check this field for\n   validity
    on reception of the message.  Specification of the Trunk\n   Mask on output is
    a local affair that can be specified by the\n   transmitting driver's address
    resolution tables.\n   The use of 0xFF in this value is strongly encouraged for
    any message\n   other than those using exotic trunk configurations on a single
    local\n   network.\n"
  - "MESSAGE FLAGS\n   Several new bits have been defined here.\n   EXTENDED ADDRESSING.
    \ This bit should be set ON whenever a 32-bit\n   address (Network and/or Domain
    numbers nonzero) is present in the\n   message.  It should always be OFF with
    the 16-bit message header.  If\n   this bit is improperly set, delivery of the
    message to the (apparent)\n   destination is unlikely.\n   END-TO-END CRC.  Some
    newer technology adapters are equipped to place\n   a 32-bit CRC of the associated
    data at the end of the associated data\n   block when this bit is on.  Similarly
    equipped adapters will examine\n   the trailing 32-bits of associated data (when
    the bit is on) to\n   determine if the message contents have been corrupted at
    any stage of\n   the transmission.\n   Transmitting device drivers should include
    the ability to set this\n   bit on transmission as a configuration option similar
    to the specific\n   HYPERchannel device interface used.  The bit should be generated
    to\n   be turned ON if the HYPERchannel IP driver is attached to an adapter\n
    \  equipped to generated CRC information -- it should be left OFF in all\n   other
    circumstances.\n   If a message arrives at the host with the CRC bit still on,
    this\n   indicates that the CRC information was placed at the end of\n   associated
    data by the transmitting adapter and not removed by the\n   receiving adapter;
    thus the associated data will be four bytes longer\n   than otherwise expected.
    \ Since the IP datagram length is self\n   contained in the network message, this
    should not impact IP drivers.\n   It is possible for host computers to both generate
    and check this CRC\n   information to match the hardware assisted generation and
    checking\n   logic in newer network adapters.  Contact NSC if there are particular\n
    \  applications requiring exceptional data integrity that could benefit\n   from
    host generation and checking.\n   FROM ADDRESS CORRECT.  This bit should be set
    by all transmitting IP\n   drivers who have endeavored to provide a completely
    correct FROM\n   address that properly reflects the adapter interface used.  No
    action\n   should be taken on this bit by the receiving IP driver at this time.\n
    \  Additional work needs to be done to determine the action an IP driver\n   should
    take if it detects a real or imagined \"security violation\"\n   should a message
    arrive with this bit absent.\n"
  - "TO ADDRESS\n   The TO address logically constitutes bytes 2-5 of the network\n
    \  message.\n   NETWORK AND DOMAIN NUMBERS.  The Network and Domain numbers should\n
    \  both be nonzero when 32-bit addressing is used.  If the message is\n   local
    in nature, then the local Network and Domain numbers should be\n   placed in this
    field.\n   ADAPTER ADDRESS.  Contains the adapter address as in the basic\n   message.
    \ The high order bit of this eight bit field (the \"outnet\"\n   bit) should be
    set to zero if the destination network and domain are\n   the same as the transmitting
    host's.  The high order bit should be\n   set to one if the destination host is
    not in the local network or\n   domain.\n   LOGICAL TO AND SUBADDRESS.  The logical
    TO field should contain the\n   protocol server address of the HYPERchannel IP
    driver for that host\n   as determined by the host's system administrator.\n"
  - "FROM ADDRESS\n   The FROM address is filled in with the address that the local
    driver\n   expects to receive from the network, but no particular use is made
    of\n   the FROM address.\n"
  - "MESSAGE TYPE\n   The value 6 must be placed in this byte to uniquely indicate
    that the\n   network message is being used to carry IP traffic.  No other well-\n
    \  behaved protocol using HYPERchannel should duplicate this value of 6.\n   Note
    that all IP drivers should be prepared to send and receive the\n   basic format
    network messages using the 16-bit HYPERchannel\n   addresses.  The driver can
    distinguish an incoming network message by\n   the value of byte 8 -- 32-bit messages
    will always have a 6 in byte\n   8, while 16-bit messages should have a 5 here.
    \ For interoperability\n   with older drivers, a value of 0 here should be treated
    as 16 address\n   bit messages.\n"
  - "IP HEADER OFFSET\n   Byte 9 contains the offset to the start of the IP header
    within the\n   message proper, such that the Message Proper address plus the IP\n
    \  header offset generates the address of the first byte of the IP\n   header
    (at least on byte addressable machines.)\n   Unlike the 16-bit header, receiving
    IP drivers should assume that\n   this field contains a correct offset to the
    IP header and examine the\n   information at that offset for conformance to an
    IP datagram header.\n   Valid offsets are in the range of 16 through 44 bytes,
    inclusive.\n   The limitation of 44 bytes is imposed so that routing decisions
    on\n   the vast majority of IP datagrams can be made by examining only the\n   message
    proper, as the basic IP datagram will fit into the message\n   proper if it begins
    at an offset of 44.\n"
  - "IP DATAGRAM CONTENTS\n   The message and data are treated as logically contiguous
    entities\n   where the first byte of associated data immediately follows the 64th\n
    \  byte of the message proper.\n   If the entire IP datagram is less than or equal
    to (64-offset) bytes\n   in length it will fit into the Message Proper.  If so,
    only a message\n   proper containing the HYPERchannel header and IP datagram is
    sent on\n   the network.\n   If the IP datagram is greater than this length, the
    IP datagram\n   spills over into the associated data.  On transmission, a 64 byte\n
    \  message proper is sent followed by as many bytes of associated data\n   as
    are needed to send the entire datagram.\n   On reception, the message proper can
    be read into the start of an IP\n   input buffer and the associated data read
    into memory 64 bytes from\n   the start of the message.  If the received message
    is in fact a 32-\n   bit address message, no \"shuffling\" of the message will
    be required\n   to build a contiguous IP datagram -- it's right there at buffer+16.\n"
  title: PROTOCOL SPECIFICATION
- contents:
  - "ADDRESS RESOLUTION PROTOCOL\n   Address Resolution Protocol has achieved a great
    deal of success on\n   the Ethernet as it permits a local IP network to configure
    itself\n   simply by having each node know its own IP address.  Those unfamiliar\n
    \  with the intent, protocol, and logic of the Address Resolution\n   Protocol
    should refer to RFC-826, \"An Ethernet Address Resolution\n   Protocol\" [2].\n
    \  A later section of this document describes four techniques where a\n   target
    HYPERchannel address is to obtained given the destination's IP\n   address.  The
    protocol is defined in this section for completeness.\n           Message Proper\n
    \        +------------------------------+-----------------------------+\n      0
    \ |      Trunks to Try           |1|       Message Flags       |\n         |   TO
    trunks  |  FROM trunks  |GNA|CRC|     |SRC|EXC|BST|A/D|\n         +------------------------------+-----------------------------+\n
    \     2  |      Server Domain or        |      Server Network or      |\n         |
    \         0xFF                |           0xFF              |\n         +------------------------------+-----------------------------+\n
    \     4  |   Server Adapter Address or  | Server logical addr/port or |\n         |
    \          0xFF               |             07              |\n         +------------------------------+-----------------------------+\n
    \     6  |O|     Physical addr of       |    Originating    | Src Port|\n         |N|
    \    source  adapter        |  server address   |  number |\n         +------------------------------+-----------------------------+\n
    \     8  |                      NSC ARP type code                     |\n         |
    \            07               |             00              |\n         +------------------------------+-----------------------------+\n
    \     10 |         Source Domain        |       Source Network        |\n         +------------------------------+-----------------------------+\n
    \     12 |          - reserved -        |         Age Count           |\n         +------------------------------+-----------------------------+\n
    \     14 |      Next Header Offset      |      Header End Offset      |\n         |
    \       (usually 16)          |       (usually 16)          |\n         +------------------------------+-----------------------------+\n
    \     16 |        Padding to start of IP info (usually 0 bytes)       |\n         +------------------------------+-----------------------------+\n
    \        +------------------------------+-----------------------------+\n     Off
    |          ARP hardware address type for HYPERchannel        |\n         |                              8
    \                            |\n         +------------------------------+-----------------------------+\n
    \     +2 |                 HYPERchannel protocol type                 |\n         |
    \            06                           00                |\n         +------------------------------+-----------------------------+\n
    \     +4 | HYPERchannel address length  |     IP address length       |\n         |
    \            6                |           4                 |\n         +------------------------------+-----------------------------+\n
    \     +6 |               ARP opcode (request or reply)                |\n         +------------------------------+-----------------------------+\n
    \     +8 |          Domain              |           Network           |\n         +-
    \          Sender's 32-bit HYPERchannel address           -+\n     +10 |       Adapter
    address        |     Logical addr/port       |\n         +------------------------------+-----------------------------+\n
    \    +12 |                      Source's MTU size                     |\n         +------------------------------+-----------------------------+\n
    \    +14 |                              |                             |\n         +-
    \               Sender's 32-bit IP address                -+\n     +16 |                                                            |\n
    \        +------------------------------+-----------------------------+\n     +18
    |          Domain              |           Network           |\n         +-        Destination's
    32-bit HYPERchannel address         -+\n     +20 |                (to be determined
    on request)               |\n         |       Adapter address        |     Logical
    addr/port       |\n         +------------------------------+-----------------------------+\n
    \    +22 |                  Destination's MTU size                    |\n         |
    \              (to be determined on request)                |\n         +------------------------------+-----------------------------+\n
    \    +24 |                              |                             |\n         +-
    \            Destination's 32-bit IP address              -+\n     +26 |                                                            |\n
    \        +------------------------------+-----------------------------+\n   Layout
    of the fields of this ARP message is a fairly straightforward\n   exercise given
    the standards of ARP and the 32-bit message header.  A\n   few fields are worth
    remarking upon:\n"
  title: ADDRESS RESOLUTION PROTOCOL
- contents:
  - "TO ADDRESS\n   The TO address of an ARP message will be one of two classes of\n
    \  address.  A \"normal\" address indicates that the message is an ARP\n   response,
    or that it is an ARP request directed at an ARP server at a\n   well known address
    on the local network.  For those HYPERchannel\n   networks which are equipped
    to broadcast, a value of 0xFFFFFF07 in\n   the TO address will (by convention)
    be picked up only by those\n   protocol servers prepared to interpret and respond
    to ARP messages.\n   The issue of which address to use in an ARP request is discussed
    in\n   the Address Resolution section.\n"
  title: TO ADDRESS
- contents:
  - "FROM ADDRESS\n   Must be the correct FROM address of the user protocol server
    issuing\n   an ARP request.  The Source Correct bit in the Message Flags byte\n
    \  should be set by this requesting server, as some ARP servers may\n   someday
    choose to issue ARP information on an \"need to know\" basis in\n   secure environments.
    \ With an ARP response, the FROM address will\n   contain the \"normal\" HYPERchannel
    address of the protocol server\n   responding to the ARP address, even if that
    server was reached via\n   broadcast mechanisms.\n   ARP responses are returned
    to the party specified in the FROM address\n   specified in the message header,
    rather than the address in the\n   \"Source HYPERchannel Address\" field within
    the body of the ARP\n   message.\n"
  title: FROM ADDRESS
- contents:
  - "MESSAGE TYPE\n   The 16-bit value 0x0700 is reserved for the exclusive use of
    ARP.\n   Unlike IP messages, no provision is made for the ARP message to begin\n
    \  at an arbitrary offset within the message proper, so the value in\n   byte
    9 is an extension of the message type.\n"
  title: MESSAGE TYPE
- contents:
  - "HEADER END OFFSET\n   ARP uses the 32-bit addressing convention that byte 15
    contains the\n   offset to the start of user protocol (and hence the end of user\n
    \  protocol information).  Note that this is not a substitute for the IP\n   offset
    fields, as this field also serves as the end of HYPERchannel\n   header information
    -- future NSC message processing code may well\n   take exception to \"garbage\"
    between the actual header end and the\n   start of user data.\n"
  title: HEADER END OFFSET
- contents:
  - "HYPERCHANNEL HARDWARE TYPE CODE\n   This 16-bit number is assigned a formal ARP
    hardware type of 8.\n"
  title: HYPERCHANNEL HARDWARE TYPE CODE
- contents:
  - "HYPERCHANNEL PROTOCOL TYPE\n   On the Ethernet, this field is used to distinguish
    IP from all other\n   protocols that may require address resolution.  To be logically\n
    \  consistent, this field is identical to bytes 8 and 9 0x0600 in a 32-\n   bit
    address HYPERchannel message carrying an IP datagram.\n"
  title: HYPERCHANNEL PROTOCOL TYPE
- contents:
  - "HYPERCHANNEL ADDRESS LENGTH\n   This contains the value 6, a sufficient number
    of bytes to\n   accommodate the four byte HYPERchannel address and 2 bytes to\n
    \  indicate the largest IP datagram size that source and destination can\n   handle.\n"
  title: HYPERCHANNEL ADDRESS LENGTH
- contents:
  - "SOURCE AND DESTINATION HYPERCHANNEL ADDRESS\n   This field contains the Domain,
    Network, and Adapter/port address of\n   source and destination, respectively.
    \ A value of 0000 in the Domain\n   and Network fields has special significance
    as this is interpreted as\n   a request to send and receive 16-bit HYPERchannel
    headers rather than\n   32-bit headers.  If 32-bit headers are to be used within
    a single\n   HYPERchannel network, then the local domain and network numbers may\n
    \  be specified.\n"
  title: SOURCE AND DESTINATION HYPERCHANNEL ADDRESS
- contents:
  - "MAXIMUM TRANSMISSION UNIT\n   HYPERchannel LAN technology is such that messages
    of unlimited length\n   may be sent between hosts.  Since host throughput on a
    network is\n   generally limited by the rate the network equipment can be\n   functioned,
    larger transmission sizes result in higher bulk transfer\n   performance.  Since
    not every host will be able to handle the maximum\n   size IP datagram, a more
    flexible means of MTU (maximum transmission\n   unit) size negotiation than simply
    wiring the same value into every\n   network host is needed.  With this field,
    each host declares the\n   maximum IP datagram size (not the associated data block
    size) it is\n   prepared to receive.  Transmitting IP drivers should be prepared
    to\n   send the minimum of the source and destination IP sizes negotiated at\n
    \  ARP time.\n   The MTU size sent refers to the maximum size of IP header + data.
    \ It\n   does not include the length of the HYPERchannel Hardware header or\n
    \  any offset between the header and the start of the IP datagram.\n   Since it
    is the option of the transmitting hosts to use an offset of\n   up to 44 bytes
    a receiving host must in any event be prepared to\n   receive a 64 byte Message
    Proper and an Associated Data block of\n   MTU-20 (that is 64 - 44, or the length
    of the basic IP header).\n        An example of a typical 16-bit packet is:\n
    \           12 bytes hardware header.\n            12 bytes offset.\n            40
    bytes IP/TCP header.\n          4096 bytes of data.\n       This gives an MTU
    of 4136.\n       An example of a typical 32-bit packet is:\n            16 bytes
    hardware header.\n             8 bytes offset.\n            40 bytes  IP/TCP header.\n
    \         4096 bytes of associated data,\n       This also gives an MTU of 4136.\n
    \  The offset values are chosen so that the typical packet causes user\n   data
    to be page aligned at the start of the associated data area.\n   This is an implementation
    decision, which can certainly be modified\n   as required.\n   The maximum maximum
    transmission unit is 65536, the current largest\n   size IP datagram.  In order
    to allow this value to fit into a 16-bit\n   field, the offset length is not included
    in the MTU.  This MTU size\n   is not a requirement that a local host be equipped
    to send or receive\n   datagrams of that size; it simply indicates the maximum
    capacity of\n   the receiving host.\n   A note on trunk masks:\n   There is no
    field for specifying trunk masks.  This is intentional,\n   as new NSC hardware
    will contain trunk reachability information,\n   eliminating the need for the
    host to maintain hardware configuration\n   layouts.  All HYPERchannel messages
    generated as a result of an ARP\n   response should use 0xFF in the trunk mask.\n"
  title: MAXIMUM TRANSMISSION UNIT
- contents:
  - "ADDRESS RESOLUTION\n   This section describes techniques used by an IP driver
    to determine\n   the HYPERchannel address and header that a message should contain\n
    \  given an IP datagram containing an IP address.  It describes\n   techniques
    that are local to specific hosts (and hence can be\n   modified without regard
    to the activities or techniques of other\n   hosts) as well as techniques to use
    the Address Resolution Protocol\n   on existing HYPERchannel equipment to better
    manage IP addresses.\n   It also discusses the migration of name resolution on
    one of four\n   steps.\n    1.  Truncation of the IP address to form a HYPERchannel
    address.\n    2.  Local resolution of HYPERchannel addresses through configuration\n
    \       files.\n    3.  Centralized resolution of HYPERchannel addresses through
    an \"ARP\n        server\" driven by a configuration file.\n    4.  Distributed
    resolution of HYPERchannel addresses using a \"real\"\n        address Resolution
    Protocol on future HYPERchannel media\n        supporting a broadcast mode.\n"
  title: ADDRESS RESOLUTION
- contents:
  - "IP ADDRESS TRUNCATION\n   A number of IP on HYPERchannel implementations support
    modes where\n   the HYPERchannel address is generated by placing the low order
    16-\n   bits of the IP address in the TO address of the message proper.  This\n
    \  more or less treats a set of HYPERchannel boxes addressable through\n   16-bit
    HYPERchannel addresses as a Class B IP network.\n   This approach certainly offers
    simplicity:  IP addresses are simply\n   chosen to match HYPERchannel addresses
    and no IP address\n   \"configuration files\" need be kept.  Although this approach
    works in\n   an environment where the HYPERchannel completely constitutes a Class\n
    \  B network, or where connection to a larger IP network is not a\n   concern,
    its long term use is discouraged for several reasons:\n    o   It simply will
    not work with any Class C address (the physical\n        TO address is not controllable)
    or a Class A address (where host\n        addresses are generally carefully administered.)
    \ In addition,\n        it will not support subnetworks.  It is quite incompatible
    with\n        32-bit HYPERchannel addresses.\n    o   By decoupling the IP and
    HYPERchannel addresses through more\n        complex address resolution, the characters
    of the two addresses\n        allow greater site flexibility:  the IP address
    becomes\n        \"logical\" in character so that an address can move about a
    site\n        with the user or host; the HYPERchannel address maintains its\n
    \       physical character so that a HYPERchannel address carefully\n        identifies
    the physical location of the source and destination\n        within the extended
    HYPERchannel network.\n"
  title: IP ADDRESS TRUNCATION
- contents:
  - "LOCAL ADDRESS RESOLUTION\n   The current state of address resolution art with
    IP on HYPERchannel\n   works as follows:  given an arbitrary IP address, the IP
    HYPERchannel\n   driver looks up an entry with that address in a (generally hashed)\n
    \  table.  If found, the table entry contains the first 6 bytes of the\n   HYPERchannel
    header that is used to send the IP datagram to the next\n   IP node on the internet.
    \ Since implementations such as the 4.3BSD\n   UNIX IP are clever enough to provide
    its lower level drivers with the\n   IP address of the next gateway as well as
    the destination address on\n   the internet (assuming the message is not delivered
    locally on the\n   HYPERchannel,) the number of entries in this table is more
    or less\n   manageable, as it must only contain the IP hosts and gateway\n   addresses
    that are directly accessible on the HYPERchannel.\n"
  title: LOCAL ADDRESS RESOLUTION
- contents:
  - "CONFIGURATION FILE FORMAT\n   So long as this technique of address resolution
    is used, the\n   techniques used are exclusively local to the host in the sense
    that\n   the techniques used to generate and store the information in the\n   table
    are irrelevant to other hosts.\n   Shown here is a typical file format.  This
    file should probably be\n   program generated from a database, as asymmetric trunk
    configurations\n   and multiply homed hosts can cause differences in physical
    routing\n   and trunk usage.  This format is documented here to illustrate what\n
    \  sort of information must be kept at the link layer.\n   The file consists of
    source lines each with the form:\n      <type> <hostname> <trunks/flags> <domain/net>
    <addr> <MTU>\n      an example:\n           <type>  <hostname>             <t/f>
    <dom/net> <addr>  <MTU>\n           # Random front end\n           host    hyper.nsco.com
    \         FF88    0103    3702    4148\n           # because we want to show the
    4 byte format\n           host    192.12.102.1            FF00    0000    2203
    \   1024\n           # Small packets, interactive traffic.\n           host    cray-b.nas.nasa.gov
    \    FF88    0103    4401    4148\n           # The other interface, for big packets.\n
    \          ahost   cray-b.nas.nasa.gov     FF88    0103    4501    32768\n           #
    A loopback interface, (What else)\n           loop    loop37.nsco.com         FF00
    \   0000    3700    4148\n           # And of course an example of arp service.\n
    \          arpserver hcgate.nsco.com       FF88    0103    7F07\n    Comments
    may begin with  either # or ;.\n    Case is not significant in any field.\n    <type>
    indicates the type of entity to be defined.\n      Currently defined types are
    \"host,\" \"ahost\", \"loop,\" \"address,\"\n      and \"arpserver\".\n      host
    \   This token indicates an IP  host.  The following field  is\n              expected
    to be a name that can be resolved to an IP\n              address.\n      ahost
    \  This field indicates an additional network interface to\n              the
    same host.  This may be used for performance\n              enhancements.\n      loop
    \   Sets a flag in the entry for that host so that  0xFF00 is\n              placed
    in bytes 8 and 9 of the message.  This will cause\n              the IP datagram
    \ to be directed towards the specified host\n              (which must still be
    a valid host name) and looped back\n              within the remote adapter.  This
    facility serves both as a\n              debugging aid and as a crude probe of
    the availability of\n              the remote network adapter.\n      arpserver
    This indicates an address to use for directing ARP\n              requests to
    the network.  If several arpserver addresses\n              are specified, they
    will be tried in turn until a response\n              is received (or we run out
    of servers.)  An arpserver with\n              the  appropriate  broadcast address
    of FFFF FF07 would\n              cause an ARP broadcast to take place when broadcasting\n
    \             becomes available.  Broadcast and specific addresses may\n              be
    used in combination.\n   <hostname> This field is the logical name of the destination.
    \ For a\n   host it is the logical name to be given to the local naming service\n
    \  to determine the associated IP address.  This field may contain four\n   decimal
    numbers separated by dots, in which case it is assumed to be\n   the explicit
    IP address.\n   <trunks/flags> This field is the value to be placed in bytes 0
    and 1\n   of the message header when sending to this host.  The associated data\n
    \  bit need not be supplied as the driver must control it.  All other\n   bits
    are sent as provided.  This field is a hexidecimal number.\n   <domain/net> This
    field is the value to be placed in the Domain and\n   Network number field of
    the message.  A value of 0000 in this field\n   indicates that the destination
    should be reached by constructing a\n   16-bit HYPERchannel header, rather than
    a 32-bit header.\n   <address> This field is the value to be placed in the 16-bit
    TO field\n   to reach <hostname>.  This field is a hexidecimal number.\n   <MTU>
    This field contains the largest size IP datagram that the\n   destination host
    is prepared to receive.  This field is a decimal\n   number.  This field is optional.
    \ If not present, a value of 4148 is\n   assumed.  See the earlier discussion
    on Maximum Transmission Unit for\n   more detail.\n"
  title: CONFIGURATION FILE FORMAT
- contents:
  - "ARP SERVERS\n   The primary problem with local host address resolution is that\n
    \  changes or additions to hosts on the local net must be replicated to\n   every
    HYPERchannel host in that network.  While this is manageable\n   for up to half
    a dozen hosts, it becomes quite unmanageable for\n   larger networks.  An approach
    that can be implemented using existing\n   HYPERchannel technology is to have
    a server on the HYPERchannel\n   network provide the HYPERchannel destination
    address that is\n   associated with an IP address.\n   Although this is strictly
    a point-to-point request/response dialogue\n   between two network nodes, the
    Address Resolution Protocol which was\n   originally designed for Ethernet (but
    thoughtfully constructed to\n   work with any pair of link and network addresses)
    performs an\n   excellent job.\n   ARP servers can be reached simply by placing
    the address of the\n   server in the 32-bit TO address of the network message.
    \ ARP servers\n   only \"listen\" to messages that arrive on their well known
    normal\n   address; they do not respond to ARP broadcast messages.  Properly\n
    \  equipped IP drivers should respond to the broadcast messages when\n   they
    appear.\n   If an ARP server receives a message containing an IP address it does\n
    \  not know how to resolve, it ignores the message so that another ARP\n   server
    might be addressed at the source's next attempt.\n   If the address is resolvable,
    it places the known HYPERchannel\n   address and MTU size in the response and
    returns it to the location\n   in the HYPERchannel header FROM address.\n   Unlike
    a broadcast ARP, the ARP server will be required to service\n   two requests when
    two hosts that are initially unknown to one another\n   attempt to get in touch.
    \ Since the destination did not receive the\n   ARP request, it must contact the
    ARP server when its higher level\n   protocols first generate a datagram to respond
    to the the source's\n   first IP datagram to go through to the destination.\n
    \  The source configuration file described in the previous section was\n   explicitly
    designed so that it could be sufficient as a data base for\n   an ARP server as
    well as an individual host.\n"
  title: ARP SERVERS
- contents:
  - "BROADCAST ARP\n   When a local HYPERchannel network contains a broadcast capability,\n
    \  any IP driver wishing to perform HYPERchannel address resolution may\n   be
    configured to emit the ARP message on a broadcast instead of a\n   well known
    address.  IP drivers on other hosts are presumed to know\n   if their local HYPERchannel
    interface can send broadcast messages; if\n   so, they arrange to \"listen\" on
    the FF07 broadcast TO address for\n   ARP.\n   Processing of a received ARP broadcast
    message is otherwise identical\n   to RFC-826:\n    o   Messages are responded
    to if and only if the destination IP\n        driver is authoritative for the
    designated IP address.\n    o   Whenever an ARP message is processed, the IP driver
    takes the\n        source HYPERchannel address and MTU size and adds it to its\n
    \       address resolution tables.  Thus the driver is equipped to\n        turn
    around the IP datagram that arrives from the destination\n        host when contact
    is made.\n   Each IP driver may have address resolutions that are set through
    a\n   static routing table (the configuration file specified above).  If\n   ARP
    information arrives that contradicts a static entry (as opposed\n   to previously
    set dynamic ARP information) then the ARP information\n   should be ignored.  This
    decision is made on the premise that the\n   only useful purpose of static routing
    in a broadcast ARP environment\n   is to add authentication, as it's easy to lie
    with ARP.\n"
  title: BROADCAST ARP
- contents:
  - "APPENDIX A.  NSC PRODUCT ARCHITECTURE AND ADDRESSING\n   This section is intended
    to be a concise review of the state of the\n   art in NSC networks and the techniques
    they provide for the delivery\n   of messages.  Those who are thoroughly familiar
    with HYPERchannel may\n   wish to only skim this section; however, there is material
    on new\n   technologies and addressing formats that are not yet generally known\n
    \  to most of NSC's customers.\n"
  title: APPENDIX A.  NSC PRODUCT ARCHITECTURE AND ADDRESSING
- contents:
  - "NETWORK SYSTEMS HYPERCHANNEL TECHNOLOGIES\n   Network Systems manufactures several
    different network technologies\n   that use very different media and link controls,
    but still provide a\n   common host interface in both the protocol and hardware
    sense of the\n   term.  These four technologies are:\n    o   HYPERchannel A --
    A 50-megabit, baseband, CSMA with collision\n        avoidance  network using
    a coaxial cable bus.  Individual\n        HYPERchannel \"network adapters\" can
    control up to 4 of these\n        coaxial cable \"trunks,\"  providing up to 200
    megabits of\n        capacity on a fully interconnected network.  HYPERchannel
    A\n        is NSC's earliest product and has been in production since\n        1977.
    \ It is principally used to interconnect larger\n        mainframe computers and
    high speed mainframe peripherals such\n        as tape drives and laser printers.\n
    \   o   HYPERchannel  B -- a 10-megabit, baseband, CSMA with collision\n        avoidance
    network using a single coaxial cable bus.  This\n        technology is used for
    direct host to host communications under\n        the name HYPERchannel B, and
    for terminal connections under the\n        name HYPERbus.  It is currently used
    for three major\n        applications -- local networks of ASCII terminals, networks\n
    \       of IBM 3270 terminals, and host to host communications of\n        smaller
    computers.\n    o   DATAPIPE[3]  --  a 275-megabit fiber optic \"backbone\" network\n
    \       that interconnects lower speed local area networks within a 20\n        mile
    range, and to provide an ultra-high-performance network for\n        the next
    generation of supercomputers and optical storage\n        systems.  A prototype
    version of DATApipe is currently under\n        development at a customer site.\n
    \   o   Bridges and Network Distance Extensions -- NSC quickly\n        discovered
    that its customers wanted very high speeds over\n        geographic areas, not
    just within the range of several miles\n        that is conceivable with a coaxial
    cable network.  Starting\n        in 1978, NSC began to build a series of \"link
    adapters\" that\n        are integral bridges between local area networks.  These
    link\n        adapters support common high speed communications media such\n        as
    Telco T1 circuits, private microwave, high speed\n        satellite links, and
    fiber optic point to point connections.\n"
  title: NETWORK SYSTEMS HYPERCHANNEL TECHNOLOGIES
- contents:
  - "ATTACHMENT TO HOST COMPUTERS\n   Network Systems' high speed interfaces use the
    attachment techniques\n   of the manufacturer's highest speed peripheral controllers
    in order\n   to achieve burst transfer rates of tens of megabits per second.\n
    \  These attachment techniques fall into three categories:\n"
  title: ATTACHMENT TO HOST COMPUTERS
- contents:
  - "\"MAINFRAME\" DATA CHANNEL ATTACHMENT\n      +-----------+-------+                   +------------+
    \ | | | |\n      |           |       |                   |HYPERchannel+--+ | |
    |\n      |           |       +-------------------+  Network   +--|-+ | |\n      |
    Host      |  I/O  +-------------------+  Adapter   +--|-|-+ |\n      |           |
    \      |   Standard host   |            +--|-|-|-+\n      | Computer  |Control|
    \   data channel   +------------+  | | | |\n      |           |       |\n      |
    \          |       |\n      |           |       |\n      |           |       |\n
    \     +-----------+-------+\n   The network adapter contains interface boards
    and firmware to be\n   cabled to the manufacturer's data channel, such as would
    be done with\n   a disk or tape controller.  Mainframe network adapters do not
    emulate\n   an existing manufacturer's device (such as a tape drive) but are\n
    \  supported by software which functions the channel and adapter to send\n   and
    receive network messages.\n   Models of HYPERchannel adapters are available for
    essentially all\n   large scale computers worldwide.\n"
  title: '"MAINFRAME" DATA CHANNEL ATTACHMENT'
- contents:
  - "MINICOMPUTER AND WORKSTATION ATTACHMENT\n   Since the network adapter contains
    lots of expensive, high speed\n   logic, a different technique is used to provide
    attachment to\n   minicomputers and workstations.\n      +-------------+        +---------------+
    \      +--------------+\n      |             |        |               |       |
    \             |\n      | Minicomputer|        |  Supermini    |       | Workstation
    \ |\n      |             |        |               |       |              |\n      +-----+-------+
    \       +-------+-------+       +-------+------+\n      |     |  DMA  |        |
    \      |  DMA  |       |  DMA  |      |\n      |     |control|        |       |control|
    \      |control|      |\n      +-----+---++--+        +-------+--++---+       +--++---+------+\n
    \               ||                      ||              ||\n                ||
    \                     ||              ||\n                |+----------+           ||
    \   +---------+|\n                +----------+|           ||    |+---------+\n
    \                          ||           ||    ||\n                         +-++--+-----+--++-+--++-+\n
    \                        |     |     |     |     |\n                         +-----+-----+-----+-----+\n
    \                        |         x400          |\n                         |
    \   Network Adapter    |\n                         |                       |\n
    \                        +-------+-+-+-+---------+\n                                 |
    | | |\n               ------------------|-|-|-+----------------\n               ------------------|-|-+------------------\n
    \              ------------------|-+--------------------\n               ------------------+----------------------\n
    \  In this case, NSC provides a DMA controller designed for direct\n   connection
    to that minicomputer's backplane bus.  These DMA\n   controllers accept functions
    and burst blocks of data from host\n   memory to a channel cable that is connected
    to one of four ports on a\n   \"general purpose computer adapter.\"  This adapter
    multiplexes\n   transmissions to and from the HYPERchannel trunks from up to four\n
    \  attached processors.\n"
  title: MINICOMPUTER AND WORKSTATION ATTACHMENT
- contents:
  - "NETWORK COPROCESSORS\n   For about 10 different bus systems, Network systems
    provides a\n   \"smart\" DMA controller containing onboard memory and a Motorola
    68010\n   protocol processor.\n       +------------+-----+---------------+-------+\n
    \      |            |     |   Coprocessor |       |        +--------+\n       |
    \           |Host |    MC 68010   |Adapter+--------+  x400  |\n       |    HOST
    \   |DMA  |   256K memory |  DMA  +--------+ Adapter|\n       |            |     |
    \              |       |        +--------+\n       |    Memory  +-----+---------------+-------+\n
    \      |            |\n       +------------+\n   This class of interface works
    through the network coprocessor's\n   direct access to host memory.  Network transmit
    and receive request\n   packets are placed in a common \"mailbox\" area and extracted
    by the\n   coprocessor.  The coprocessor reads and writes system memory as\n   required
    to service network requests in the proper order.  The\n   coprocessors currently
    provide a service to read or write network\n   messages (called Driver service
    as it is more or less identical to\n   HYPERchannel dumb DMA drivers) and a service
    for NETEX, which is\n   NSC's OSI-like communications protocol.\n"
  title: NETWORK COPROCESSORS
- contents:
  - "APPENDIX B. NETWORK SYSTEMS HYPERCHANNEL PROTOCOLS\n   The protocols implemented
    by NSC within its own boxes are designed\n   for the needs of the different technologies.
    \ A compact summation of\n   these protocols is:\n      HYPERchannel B         HYPERchannel
    A            DATApipe\n     10 Mbits/second       50-200 Mbits/second     275
    Mbits/second\n +----------------------+----------------------+---------------------+\n
    |                                                                   |\n |                  HYPERchannel
    network message                     |\n |                 connectionless datagram
    protocol                  |\n |                                                                   |\n
    +----------------------+----------------------+---------------------+\n |    \"HYPERchannel
    \    |                      |                     |\n |  compatibility mode\"
    |    HYPERchannel A    |     DATApipe        |\n |   Virtual circuit    |   reservation
    and    |   acknowledgment    |\n |   estab. & control   |    flow control      |
    \   & flow control   |\n +----------------------+      protocol        |      protocol
    \      |\n |                      |                      |                     |\n
    |  Virtual Circuits    |                      |                     |\n |    Flow
    Control      |                      |                     |\n +----------------------+----------------------+---------------------+\n
    |    CSMA / VT         |      CSMA / CA       |                     |\n |  frame
    (datagram)    |  frame (datagram)    | TDMA packet delivery|\n |    delivery and
    \     |   delivery and       |                     |\n |   acknowledgment     |
    \ acknowledgment      |                     |\n +----------------------+----------------------+---------------------+\n
    |                      |                      |    Fiber optics     |\n |     75
    ohm coax      |  1-4 75 ohm coax     | (various cable sizes|\n |       cable          |
    \     cables          |  and xmission modes)|\n +----------------------+----------------------+---------------------+\n
    \  Without getting into great detail on these internal protocols, a few\n   points
    are particularly interesting to system designers:\n    o   All three technologies
    supply the same interface to the host\n        computer or network coprocessor,
    a service to send and receive\n        network messages that are datagrams from
    the host's vantage in\n        that each contains sufficient information to deliver
    the message\n        in and of itself.  Since this datagram and its header fields
    are\n        of paramount interest to the host implementor, it is discussed\n
    \       in detail below.\n    o   All technologies use acknowledgments at a very
    low level to\n        determine if packets  have been successfully delivered.
    \ In\n        addition to permitting  a highly tuned contention mechanism for\n
    \       the coax medium, it also permits HYPERchannel A to balance the\n        load
    over several coax cables -- a feat that has proven very\n        difficult on,
    for example, Ethernet.\n    o   All boxes go to some lengths to assure that resources
    exist\n        in the receiving box before actual transmission takes place.\n
    \       HYPERchannel B uses a virtual circuit that endures for several\n        seconds
    of inactivity after one host first attempts to send a\n        message to the
    other.  Traffic over this \"working virtual\n        circuit\" is flow controlled
    from source to destination and\n        buffer resources are reserved for the
    path.\n   HYPERchannel A exchanges frames at very high rates to determine that\n
    \  the receiver is ready to receive data and to control its flow as data\n   moves
    through the network.\n   DATApipe propagation time is relatively long compared
    to the time\n   needed to send an internal packet of 2K-4K bytes.  As a result,\n
    \  DATApipe controllers use a streamlined TP4-like transport protocol to\n   assure
    delivery of frames between DATApipe boxes.\n"
  title: APPENDIX B. NETWORK SYSTEMS HYPERCHANNEL PROTOCOLS
- contents:
  - "REFERENCES\n      [1]   HYPERchannel is a trademark of Network Systems Corporation.\n
    \     [2]   Plummer, D., \"An Ethernet Address Resolution Protocol\",\n            RFC-826,
    Symbolics, September 1982.\n      [3]   DATApipe is a registered trademark of
    Network Systems\n            Corporation.\n"
  title: REFERENCES
