- title: __initial_text__
  contents:
  - '              Self-Clocked Rate Adaptation for Multimedia

    '
- title: Abstract
  contents:
  - "Abstract\n   This memo describes a rate adaptation algorithm for conversational\n\
    \   media services such as interactive video.  The solution conforms to\n   the\
    \ packet conservation principle and uses a hybrid loss-and-delay-\n   based congestion\
    \ control algorithm.  The algorithm is evaluated over\n   both simulated Internet\
    \ bottleneck scenarios as well as in a Long\n   Term Evolution (LTE) system simulator\
    \ and is shown to achieve both\n   low latency and high video throughput in these\
    \ scenarios.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for examination, experimental implementation, and\n   evaluation.\n\
    \   This document defines an Experimental Protocol for the Internet\n   community.\
    \  This document is a product of the Internet Engineering\n   Task Force (IETF).\
    \  It represents the consensus of the IETF\n   community.  It has received public\
    \ review and has been approved for\n   publication by the Internet Engineering\
    \ Steering Group (IESG).  Not\n   all documents approved by the IESG are a candidate\
    \ for any level of\n   Internet Standard; see Section 2 of RFC 7841.\n   Information\
    \ about the current status of this document, any errata,\n   and how to provide\
    \ feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8298.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2017 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   4\n     1.1.  Wireless (LTE) Access Properties  . . . . . . . .\
    \ . . . .   4\n     1.2.  Why is it a self-clocked algorithm? . . . . . . . .\
    \ . . .   5\n   2.  Requirements Language . . . . . . . . . . . . . . . . . .\
    \ . .   5\n   3.  Overview of SCReAM Algorithm  . . . . . . . . . . . . . . .\
    \ .   6\n     3.1.  Network Congestion Control  . . . . . . . . . . . . . . .\
    \   8\n     3.2.  Sender Transmission Control . . . . . . . . . . . . . . .  \
    \ 9\n     3.3.  Media Rate Control  . . . . . . . . . . . . . . . . . . .   9\n\
    \   4.  Detailed Description of SCReAM  . . . . . . . . . . . . . . .  10\n  \
    \   4.1.  SCReAM Sender . . . . . . . . . . . . . . . . . . . . . .  10\n    \
    \   4.1.1.  Constants and Parameter Values  . . . . . . . . . . .  10\n      \
    \   4.1.1.1.  Constants . . . . . . . . . . . . . . . . . . . .  11\n        \
    \ 4.1.1.2.  State Variables . . . . . . . . . . . . . . . . .  12\n       4.1.2.\
    \  Network Congestion Control  . . . . . . . . . . . . .  14\n         4.1.2.1.\
    \  Reaction to Packet Loss and ECN . . . . . . . . .  17\n         4.1.2.2.  Congestion\
    \ Window Update  . . . . . . . . . . . .  17\n         4.1.2.3.  Competing Flows\
    \ Compensation  . . . . . . . . . .  20\n         4.1.2.4.  Lost Packet Detection\
    \ . . . . . . . . . . . . . .  22\n         4.1.2.5.  Send Window Calculation\
    \ . . . . . . . . . . . . .  23\n         4.1.2.6.  Packet Pacing . . . . . .\
    \ . . . . . . . . . . . .  24\n         4.1.2.7.  Resuming Fast Increase Mode\
    \ . . . . . . . . . . .  24\n         4.1.2.8.  Stream Prioritization . . . .\
    \ . . . . . . . . . .  24\n       4.1.3.  Media Rate Control  . . . . . . . .\
    \ . . . . . . . . .  25\n     4.2.  SCReAM Receiver . . . . . . . . . . . . .\
    \ . . . . . . . .  28\n       4.2.1.  Requirements on Feedback Elements . . .\
    \ . . . . . . .  28\n       4.2.2.  Requirements on Feedback Intensity  . . .\
    \ . . . . . .  30\n   5.  Discussion  . . . . . . . . . . . . . . . . . . . .\
    \ . . . . .  31\n   6.  Suggested Experiments . . . . . . . . . . . . . . . .\
    \ . . . .  31\n   7.  IANA Considerations . . . . . . . . . . . . . . . . . .\
    \ . . .  32\n   8.  Security Considerations . . . . . . . . . . . . . . . . .\
    \ . .  32\n   9.  References  . . . . . . . . . . . . . . . . . . . . . . . .\
    \ .  33\n     9.1.  Normative References  . . . . . . . . . . . . . . . . . .\
    \  33\n     9.2.  Informative References  . . . . . . . . . . . . . . . . .  34\n\
    \   Acknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  36\n  \
    \ Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  36\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Congestion in the Internet occurs when the transmitted bitrate\
    \ is\n   higher than the available capacity over a given transmission path.\n\
    \   Applications that are deployed in the Internet have to employ\n   congestion\
    \ control to achieve robust performance and to avoid\n   congestion collapse in\
    \ the Internet.  Interactive real-time\n   communication imposes a lot of requirements\
    \ on the transport;\n   therefore, a robust, efficient rate adaptation for all\
    \ access types\n   is an important part of interactive real-time communications,\
    \ as the\n   transmission channel bandwidth can vary over time.  Wireless access\n\
    \   such as LTE, which is an integral part of the current Internet,\n   increases\
    \ the importance of rate adaptation as the channel bandwidth\n   of a default\
    \ LTE bearer [QoS-3GPP] can change considerably in a very\n   short time frame.\
    \  Thus, a rate adaptation solution for interactive\n   real-time media, such\
    \ as WebRTC [RFC7478], should be both quick and\n   be able to operate over a\
    \ large range in channel capacity.  This memo\n   describes Self-Clocked Rate\
    \ Adaptation for Multimedia (SCReAM), a\n   solution that implements congestion\
    \ control for RTP streams\n   [RFC3550].  While SCReAM was originally devised\
    \ for WebRTC, it can\n   also be used for other applications where congestion\
    \ control of RTP\n   streams is necessary.  SCReAM is based on the self-clocking\
    \ principle\n   of TCP and uses techniques similar to what is used in the rate\n\
    \   adaptation algorithm based on Low Extra Delay Background Transport\n   (LEDBAT)\
    \ [RFC6817].  SCReAM is not entirely self-clocked as it\n   augments self-clocking\
    \ with pacing and a minimum send rate.  SCReAM\n   can take advantage of Explicit\
    \ Congestion Notification (ECN) in cases\n   where ECN is supported by the network\
    \ and the hosts.  However, ECN is\n   not required for the basic congestion control\
    \ functionality in\n   SCReAM.\n"
- title: 1.1.  Wireless (LTE) Access Properties
  contents:
  - "1.1.  Wireless (LTE) Access Properties\n   [WIRELESS-TESTS] describes the complications\
    \ that can be observed in\n   wireless environments.  Wireless access such as\
    \ LTE typically cannot\n   guarantee a given bandwidth; this is true especially\
    \ for default\n   bearers.  The network throughput can vary considerably, for\
    \ instance,\n   in cases where the wireless terminal is moving around.  Even though\n\
    \   LTE can support bitrates well above 100 Mbps, there are cases when\n   the\
    \ available bitrate can be much lower; examples are situations with\n   high network\
    \ load and poor coverage.  An additional complication is\n   that the network\
    \ throughput can drop for short time intervals (e.g.,\n   at handover); these\
    \ short glitches are initially very difficult to\n   distinguish from more permanent\
    \ reductions in throughput.\n   Unlike wireline bottlenecks with large statistical\
    \ multiplexing, it\n   is not possible to try to maintain a given bitrate when\
    \ congestion is\n   detected with the hope that other flows will yield.  This\
    \ is because\n   there are generally few other flows competing for the same\n\
    \   bottleneck.  Each user gets its own variable throughput bottleneck,\n   where\
    \ the throughput depends on factors like channel quality, network\n   load, and\
    \ historical throughput.  The bottom line is, if the\n   throughput drops, the\
    \ sender has no other option than to reduce the\n   bitrate.  Once the radio scheduler\
    \ has reduced the resource\n   allocation for a bearer, a flow (which is using\
    \ RTP Media Congestion\n   Avoidance Techniques (RMCAT)) in that bearer aims to\
    \ reduce the\n   sending rate quite quickly (within one RTT) in order to avoid\n\
    \   excessive queuing delay or packet loss.\n"
- title: 1.2.  Why is it a self-clocked algorithm?
  contents:
  - "1.2.  Why is it a self-clocked algorithm?\n   Self-clocked congestion control\
    \ algorithms provide a benefit over\n   their rate-based counterparts in that\
    \ the former consists of two\n   adaptation mechanisms:\n   o  A congestion window\
    \ computation that evolves over a longer\n      timescale (several RTTs) especially\
    \ when the congestion window\n      evolution is dictated by estimated delay (to\
    \ minimize\n      vulnerability to, e.g., short-term delay variations).\n   o\
    \  A fine-grained congestion control given by the self-clocking; it\n      operates\
    \ on a shorter time scale (1 RTT).  The benefits of self-\n      clocking are\
    \ also elaborated upon in [TFWC].\n   A rate-based congestion control algorithm\
    \ typically adjusts the rate\n   based on delay and loss.  The congestion detection\
    \ needs to be done\n   with a certain time lag to avoid overreaction to spurious\
    \ congestion\n   events such as delay spikes.  Despite the fact that there are\
    \ two or\n   more congestion indications, the outcome is that there is still only\n\
    \   one mechanism to adjust the sending rate.  This makes it difficult to\n  \
    \ reach the goals of high throughput and prompt reaction to congestion.\n"
- title: 2.  Requirements Language
  contents:
  - "2.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted\
    \ as described in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear\
    \ in all\n   capitals, as shown here.\n"
- title: 3.  Overview of SCReAM Algorithm
  contents:
  - "3.  Overview of SCReAM Algorithm\n   The core SCReAM algorithm has similarities\
    \ to the concepts of self-\n   clocking used in TCP-friendly window-based congestion\
    \ control [TFWC]\n   and follows the packet conservation principle.  The packet\n\
    \   conservation principle is described as a key factor behind the\n   protection\
    \ of networks from congestion [Packet-conservation].\n   In SCReAM, the receiver\
    \ of the media echoes a list of received RTP\n   packets and the timestamp of\
    \ the RTP packet with the highest sequence\n   number back to the sender in feedback\
    \ packets.  The sender keeps a\n   list of transmitted packets, their respective\
    \ sizes, and the time\n   they were transmitted.  This information is used to\
    \ determine the\n   number of bytes that can be transmitted at any given time\
    \ instant.  A\n   congestion window puts an upper limit on how many bytes can\
    \ be in\n   flight, i.e., transmitted but not yet acknowledged.\n   The congestion\
    \ window is determined in a way similar to LEDBAT\n   [RFC6817].  LEDBAT is a\
    \ congestion control algorithm that uses send\n   and receive timestamps to estimate\
    \ the queuing delay (from now on\n   denoted \"qdelay\") along the transmission\
    \ path.  This information is\n   used to adjust the congestion window.  The use\
    \ of LEDBAT ensures that\n   the end-to-end latency is kept low.  [LEDBAT-delay-impact]\
    \ shows that\n   LEDBAT has certain inherent issues that make it counteract its\n\
    \   purpose of achieving low delay.  The general problem described in the\n  \
    \ paper is that the base delay is offset by LEDBAT's own queue buildup.\n   The\
    \ big difference with using LEDBAT in the SCReAM context lies in\n   the facts\
    \ that the source is rate limited and that the RTP queue must\n   be kept short\
    \ (preferably empty).  In addition, the output from a\n   video encoder is rarely\
    \ constant bitrate; static content (talking\n   heads, for instance) gives almost\
    \ zero video bitrate.  This yields\n   two useful properties when LEDBAT is used\
    \ with SCReAM; they help to\n   avoid the issues described in [LEDBAT-delay-impact]:\n\
    \   1.  There is always a certain probability that SCReAM is short of\n      \
    \ data to transmit; this means that the network queue will become\n       empty\
    \ every once in a while.\n   2.  The max video bitrate can be lower than the link\
    \ capacity.  If\n       the max video bitrate is 5 Mbps and the capacity is 10\
    \ Mbps, then\n       the network queue will become empty.\n   It is sufficient\
    \ that any of the two conditions above is fulfilled to\n   make the base delay\
    \ update properly.  Furthermore,\n   [LEDBAT-delay-impact] describes an issue\
    \ with short-lived competing\n   flows.  In SCReAM, these short-lived flows will\
    \ cause the self-\n   clocking to slow down, thereby building up the RTP queue;\
    \ in turn,\n   this results in a reduced media video bitrate.  Thus, SCReAM slows\n\
    \   the bitrate more when there are competing short-lived flows than the\n   traditional\
    \ use of LEDBAT does.  The basic functionality in the use\n   of LEDBAT in SCReAM\
    \ is quite simple; however, there are a few steps\n   in order to make the concept\
    \ work with conversational media:\n   o  Congestion window validation techniques.\
    \  These are similar to the\n      method described in [RFC7661].  Congestion\
    \ window validation\n      ensures that the congestion window is limited by the\
    \ actual number\n      bytes in flight; this is important especially in the context\
    \ of\n      rate-limited sources such as video.  Lack of congestion window\n \
    \     validation would lead to a slow reaction to congestion as the\n      congestion\
    \ window does not properly reflect the congestion state\n      in the network.\
    \  The allowed idle period in this memo is shorter\n      than in [RFC7661]; this\
    \ to avoid excessive delays in the cases\n      where, e.g., wireless throughput\
    \ has decreased during a period\n      where the output bitrate from the media\
    \ coder has been low (for\n      instance, due to inactivity).  Furthermore, this\
    \ memo allows for\n      more relaxed rules for when the congestion window is\
    \ allowed to\n      grow; this is necessary as the variable output bitrate generally\n\
    \      means that the congestion window is often underutilized.\n   o  Fast increase\
    \ mode makes the bitrate increase faster when no\n      congestion is detected.\
    \  It makes the media bitrate ramp up within\n      5 to 10 seconds.  The behavior\
    \ is similar to TCP slowstart.  Fast\n      increase mode is exited when congestion\
    \ is detected.  However,\n      fast increase mode can resume if the congestion\
    \ level is low; this\n      enables a reasonably quick rate increase in case link\
    \ throughput\n      increases.\n   o  A qdelay trend is computed for earlier detection\
    \ of incipient\n      congestion; as a result, it reduces jitter.\n   o  Addition\
    \ of a media rate control function.\n   o  Use of inflection points in the media\
    \ rate calculation to achieve\n      reduced jitter.\n   o  Adjustment of qdelay\
    \ target for better performance when competing\n      with other loss-based congestion-controlled\
    \ flows.\n   The above-mentioned features will be described in more detail in\n\
    \   Sections 3.1 to 3.3.  The full details are described in Section 4.\n     \
    \               +---------------------------+\n                    |        Media\
    \ encoder      |\n                    +---------------------------+\n        \
    \                ^                  |\n                        |             \
    \     |(1)\n                        |(3)              RTP\n                  \
    \      |                  V\n                        |            +-----------+\n\
    \                   +---------+       |           |\n                   | Media\
    \   |  (2)  |   Queue   |\n                   | rate    |<------|           |\n\
    \                   | control |       |RTP packets|\n                   +---------+\
    \       |           |\n                                     +-----------+\n  \
    \                                         |\n                                \
    \           |(4)\n                                          RTP\n            \
    \                               |\n                                          \
    \ v\n              +------------+       +--------------+\n              |  Network\
    \   |  (7)  |    Sender    |\n          +-->| congestion |------>| Transmission\
    \ |\n          |   |  control   |       |   Control    |\n          |   +------------+\
    \       +--------------+\n          |                                |\n     \
    \     |-------------RTCP----------|    |(5)\n              (6)               \
    \      |   RTP\n                                      |    v\n               \
    \                   +------------+\n                                  |     UDP\
    \    |\n                                  |   socket   |\n                   \
    \               +------------+\n                  Figure 1: SCReAM Sender Functional\
    \ View\n   The SCReAM algorithm consists of three main parts: network congestion\n\
    \   control, sender transmission control, and media rate control.  All of\n  \
    \ these parts reside at the sender side.  Figure 1 shows the functional\n   overview\
    \ of a SCReAM sender.  The receiver-side algorithm is very\n   simple in comparison,\
    \ as it only generates feedback containing\n   acknowledgements of received RTP\
    \ packets and an ECN count.\n"
- title: 3.1.  Network Congestion Control
  contents:
  - "3.1.  Network Congestion Control\n   The network congestion control sets an upper\
    \ limit on how much data\n   can be in the network (bytes in flight); this limit\
    \ is called CWND\n   (congestion window) and is used in the sender transmission\
    \ control.\n   The SCReAM congestion control method uses techniques similar to\n\
    \   LEDBAT [RFC6817] to measure the qdelay.  As is the case with LEDBAT,\n   it\
    \ is not necessary to use synchronized clocks in the sender and\n   receiver in\
    \ order to compute the qdelay.  However, it is necessary\n   that they use the\
    \ same clock frequency, or that the clock frequency\n   at the receiver can be\
    \ inferred reliably by the sender.  Failure to\n   meet this requirement leads\
    \ to malfunction in the SCReAM congestion\n   control algorithm due to incorrect\
    \ estimation of the network queue\n   delay.\n   The SCReAM sender calculates\
    \ the congestion window based on the\n   feedback from the SCReAM receiver.  The\
    \ congestion window is allowed\n   to increase if the qdelay is below a predefined\
    \ qdelay target;\n   otherwise, the congestion window decreases.  The qdelay target\
    \ is\n   typically set to 50-100 ms.  This ensures that the queuing delay is\n\
    \   kept low.  The reaction to loss or ECN events leads to an instant\n   reduction\
    \ of CWND.  Note that the source rate-limited nature of real-\n   time media,\
    \ such as video, typically means that the queuing delay\n   will mostly be below\
    \ the given delay target.  This is contrary to the\n   case where large files\
    \ are transmitted using LEDBAT congestion\n   control and the queuing delay will\
    \ stay close to the delay target.\n"
- title: 3.2.  Sender Transmission Control
  contents:
  - "3.2.  Sender Transmission Control\n   The sender transmission control limits\
    \ the output of data, given by\n   the relation between the number of bytes in\
    \ flight and the congestion\n   window.  Packet pacing is used to mitigate issues\
    \ with ACK\n   compression that MAY cause increased jitter and/or packet loss\
    \ in the\n   media traffic.  Packet pacing limits the packet transmission rate\n\
    \   given by the estimated link throughput.  Even if the send window\n   allows\
    \ for the transmission of a number of packets, these packets are\n   not transmitted\
    \ immediately; rather, they are transmitted in\n   intervals given by the packet\
    \ size and the estimated link throughput.\n"
- title: 3.3.  Media Rate Control
  contents:
  - "3.3.  Media Rate Control\n   The media rate control serves to adjust the media\
    \ bitrate to ramp up\n   quickly enough to get a fair share of the system resources\
    \ when link\n   throughput increases.\n   The reaction to reduced throughput MUST\
    \ be prompt in order to avoid\n   getting too much data queued in the RTP packet\
    \ queue(s) in the\n   sender.  The media bitrate is decreased if the RTP queue\
    \ size exceeds\n   a threshold.\n   In cases where the sender's frame queues increase\
    \ rapidly, such as in\n   the case of a Radio Access Type (RAT) handover, the\
    \ SCReAM sender MAY\n   implement additional actions, such as discarding of encoded\
    \ media\n   frames or frame skipping in order to ensure that the RTP queues are\n\
    \   drained quickly.  Frame skipping results in the frame rate being\n   temporarily\
    \ reduced.  Which method to use is a design choice and is\n   outside the scope\
    \ of this algorithm description.\n"
- title: 4.  Detailed Description of SCReAM
  contents:
  - '4.  Detailed Description of SCReAM

    '
- title: 4.1.  SCReAM Sender
  contents:
  - "4.1.  SCReAM Sender\n   This section describes the sender-side algorithm in more\
    \ detail.  It\n   is split between the network congestion control, sender transmission\n\
    \   control, and media rate control.\n   A SCReAM sender implements media rate\
    \ control and an RTP queue for\n   each media type or source, where RTP packets\
    \ containing encoded media\n   frames are temporarily stored for transmission.\
    \  Figure 1 shows the\n   details when a single media source (or stream) is used.\
    \  A\n   transmission scheduler (not shown in the figure) is added to support\n\
    \   multiple streams.  The transmission scheduler can enforce differing\n   priorities\
    \ between the streams and act like a coupled congestion\n   controller for multiple\
    \ flows.  Support for multiple streams is\n   implemented in [SCReAM-CPP-implementation].\n\
    \   Media frames are encoded and forwarded to the RTP queue (1) in\n   Figure\
    \ 1.  The media rate adaptation adapts to the size of the RTP\n   queue (2) and\
    \ provides a target rate for the media encoder (3).  The\n   RTP packets are picked\
    \ from the RTP queue (4), for multiple flows\n   from each RTP queue based on\
    \ some defined priority order or simply in\n   a round-robin fashion, by the sender\
    \ transmission controller.  The\n   sender transmission controller (in case of\
    \ multiple flows a\n   transmission scheduler) sends the RTP packets to the UDP\
    \ socket (5).\n   In the general case, all media SHOULD go through the sender\n\
    \   transmission controller and is limited so that the number of bytes in\n  \
    \ flight is less than the congestion window.  RTCP packets are received\n   (6)\
    \ and the information about the bytes in flight and congestion\n   window is exchanged\
    \ between the network congestion control and the\n   sender transmission control\
    \ (7).\n"
- title: 4.1.1.  Constants and Parameter Values
  contents:
  - "4.1.1.  Constants and Parameter Values\n   Constants and state variables are\
    \ listed in this section.  Temporary\n   variables are not listed; instead, they\
    \ are appended with '_t' in the\n   pseudocode to indicate their local scope.\n"
- title: 4.1.1.1.  Constants
  contents:
  - "4.1.1.1.  Constants\n   The RECOMMENDED values, within parentheses \"()\", for\
    \ the constants\n   are deduced from experiments.\n   QDELAY_TARGET_LO (0.1 s)\n\
    \     Target value for the minimum qdelay.\n   QDELAY_TARGET_HI (0.4 s)\n    \
    \ Target value for the maximum qdelay.  This parameter provides an\n     upper\
    \ limit to how much the target qdelay (qdelay_target) can be\n     increased in\
    \ order to cope with competing loss-based flows.\n     However, the target qdelay\
    \ does not have to be initialized to this\n     high value, as it would increase\
    \ end-to-end delay and also make the\n     rate control and congestion control\
    \ loops sluggish.\n   QDELAY_WEIGHT (0.1)\n     Averaging factor for qdelay_fraction_avg.\n\
    \   QDELAY_TREND_TH (0.2)\n     Threshold for the detection of incipient congestion.\n\
    \   MIN_CWND (3000 bytes)\n     Minimum congestion window.\n   MAX_BYTES_IN_FLIGHT_HEAD_ROOM\
    \ (1.1)\n     Headroom for the limitation of CWND.\n   GAIN (1.0)\n     Gain factor\
    \ for congestion window adjustment.\n   BETA_LOSS (0.8)\n     CWND scale factor\
    \ due to loss event.\n   BETA_ECN (0.9)\n     CWND scale factor due to ECN event.\n\
    \   BETA_R (0.9)\n     Scale factor for target rate due to loss event.\n   MSS\
    \ (1000 byte)\n     Maximum segment size = Max RTP packet size.\n   RATE_ADJUST_INTERVAL\
    \ (0.2 s)\n     Interval between media bitrate adjustments.\n   TARGET_BITRATE_MIN\n\
    \     Minimum target bitrate in bps (bits per second).\n   TARGET_BITRATE_MAX\n\
    \     Maximum target bitrate in bps.\n   RAMP_UP_SPEED (200000 bps/s)\n     Maximum\
    \ allowed rate increase speed.\n   PRE_CONGESTION_GUARD  (0.0..1.0)\n     Guard\
    \ factor against early congestion onset.  A higher value gives\n     less jitter,\
    \ possibly at the expense of a lower link utilization.\n     This value MAY be\
    \ subject to tuning depending on e.g., media coder\n     characteristics.  Experiments\
    \ with H264 and VP8 indicate that 0.1\n     is a suitable value.  See [SCReAM-CPP-implementation]\
    \ and\n     [SCReAM-implementation-experience] for evaluation of a real\n    \
    \ implementation.\n   TX_QUEUE_SIZE_FACTOR (0.0..2.0)\n     Guard factor against\
    \ RTP queue buildup.  This value MAY be subject\n     to tuning depending on,\
    \ e.g., media coder characteristics.\n     Experiments with H264 and VP8 indicate\
    \ that 1.0 is a suitable\n     value.  See [SCReAM-CPP-implementation] and\n \
    \    [SCReAM-implementation-experience] for evaluation of a real\n     implementation.\n\
    \   RTP_QDELAY_TH (0.02 s)  RTP queue delay threshold for a target rate\n    \
    \ reduction.\n   TARGET_RATE_SCALE_RTP_QDELAY (0.95)  Scale factor for target\
    \ rate\n     when RTP qdelay threshold exceeds RTP_QDELAY_TH.\n   QDELAY_TREND_LO\
    \ (0.2)  Threshold value for qdelay_trend.\n   T_RESUME_FAST_INCREASE (5 s)  Time\
    \ span until fast increase mode can\n     be resumed, given that the qdelay_trend\
    \ is below QDELAY_TREND_LO.\n   RATE_PACE_MIN (50000 bps)  Minimum pacing rate.\n"
- title: 4.1.1.2.  State Variables
  contents:
  - "4.1.1.2.  State Variables\n   The values within parentheses \"()\" indicate initial\
    \ values.\n   qdelay_target (QDELAY_TARGET_LO)\n     qdelay target, a variable\
    \ qdelay target is introduced to manage\n     cases where a fixed qdelay target\
    \ would otherwise starve the RMCAT\n     flow under such circumstances (e.g.,\
    \ FTP competes for the bandwidth\n     over the same bottleneck).  The qdelay\
    \ target is allowed to vary\n     between QDELAY_TARGET_LO and QDELAY_TARGET_HI.\n\
    \   qdelay_fraction_avg (0.0)\n     Fractional qdelay filtered by the Exponentially\
    \ Weighted Moving\n     Average (EWMA).\n   qdelay_fraction_hist[20] ({0,..,0})\n\
    \     Vector of the last 20 fractional qdelay samples.\n   qdelay_trend (0.0)\n\
    \     qdelay trend; indicates incipient congestion.\n   qdelay_trend_mem (0.0)\n\
    \     Low-pass filtered version of qdelay_trend.\n   qdelay_norm_hist[100] ({0,..,0})\n\
    \     Vector of the last 100 normalized qdelay samples.\n   in_fast_increase (true)\n\
    \     True if in fast increase mode.\n   cwnd (MIN_CWND)\n     Congestion window.\n\
    \   bytes_newly_acked (0)\n     The number of bytes that was acknowledged with\
    \ the last received\n     acknowledgement, i.e., bytes acknowledged since the\
    \ last CWND\n     update.\n   max_bytes_in_flight (0)\n     The maximum number\
    \ of bytes in flight over a sliding time window,\n     i.e., transmitted but not\
    \ yet acknowledged bytes.\n   send_wnd (0)\n     Upper limit to how many bytes\
    \ can currently be transmitted.\n     Updated when cwnd is updated and when RTP\
    \ packet is transmitted.\n   target_bitrate (0 bps)\n     Media target bitrate.\n\
    \   target_bitrate_last_max (1 bps)\n     Inflection point of the media target\
    \ bitrate, i.e., the last known\n     highest target_bitrate.  Used to limit bitrate\
    \ increase speed close\n     to the last known congestion point.\n   rate_transmit\
    \ (0.0 bps)\n     Measured transmit bitrate.\n   rate_ack (0.0 bps)\n     Measured\
    \ throughput based on received acknowledgements.\n   rate_media (0.0 bps)\n  \
    \   Measured bitrate from the media encoder.\n   rate_media_median (0.0 bps)\n\
    \     Median value of rate_media, computed over more than 10 s.\n   s_rtt (0.0s)\n\
    \     Smoothed RTT (in seconds), computed with a similar method to that\n    \
    \ described in [RFC6298].\n   rtp_queue_size (0 bits)\n     Sum of the sizes of\
    \ RTP packets in queue.\n   rtp_size (0 byte)\n     Size of the last transmitted\
    \ RTP packet.\n   loss_event_rate (0.0)\n     The estimated fraction of RTTs with\
    \ lost packets detected.\n"
- title: 4.1.2.  Network Congestion Control
  contents:
  - "4.1.2.  Network Congestion Control\n   This section explains the network congestion\
    \ control, which performs\n   two main functions:\n   o  Computation of congestion\
    \ window at the sender: This gives an\n      upper limit to the number of bytes\
    \ in flight.\n   o  Calculation of send window at the sender: RTP packets are\n\
    \      transmitted if allowed by the relation between the number of bytes\n  \
    \    in flight and the congestion window.  This is controlled by the\n      send\
    \ window.\n   SCReAM is a window-based and byte-oriented congestion control\n\
    \   protocol, where the number of bytes transmitted is inferred from the\n   size\
    \ of the transmitted RTP packets.  Thus, a list of transmitted RTP\n   packets\
    \ and their respective transmission times (wall-clock time)\n   MUST be kept for\
    \ further calculation.\n   The number of bytes in flight (bytes_in_flight) is\
    \ computed as the\n   sum of the sizes of the RTP packets ranging from the RTP\
    \ packet most\n   recently transmitted, down to but not including the acknowledged\n\
    \   packet with the highest sequence number.  This can be translated to\n   the\
    \ difference between the highest transmitted byte sequence number\n   and the\
    \ highest acknowledged byte sequence number.  As an example: If\n   an RTP packet\
    \ with sequence number SN is transmitted and the last\n   acknowledgement indicates\
    \ SN-5 as the highest received sequence\n   number, then bytes_in_flight is computed\
    \ as the sum of the size of\n   RTP packets with sequence number SN-4, SN-3, SN-2,\
    \ SN-1, and SN.  It\n   does not matter if, for instance, the packet with sequence\
    \ number\n   SN-3 was lost -- the size of RTP packet with sequence number SN-3\n\
    \   will still be considered in the computation of bytes_in_flight.\n   Furthermore,\
    \ a variable bytes_newly_acked is incremented with a value\n   corresponding to\
    \ how much the highest sequence number has increased\n   since the last feedback.\
    \  As an example: If the previous\n   acknowledgement indicated the highest sequence\
    \ number N and the new\n   acknowledgement indicated N+3, then bytes_newly_acked\
    \ is incremented\n   by a value equal to the sum of the sizes of RTP packets with\
    \ sequence\n   number N+1, N+2, and N+3.  Packets that are lost are also included,\n\
    \   which means that even though, e.g., packet N+2 was lost, its size is\n   still\
    \ included in the update of bytes_newly_acked.  The\n   bytes_newly_acked variable\
    \ is reset to zero after a CWND update.\n   The feedback from the receiver is\
    \ assumed to consist of the following\n   elements.\n   o  A list of received\
    \ RTP packets' sequence numbers.\n   o  The wall-clock timestamp corresponding\
    \ to the received RTP packet\n      with the highest sequence number.\n   o  The\
    \ accumulated number of ECN-CE-marked packets (n_ECN).  Here,\n      \"CE\" refers\
    \ to \"Congestion Experienced\".\n   When the sender receives RTCP feedback, the\
    \ qdelay is calculated as\n   outlined in [RFC6817].  A qdelay sample is obtained\
    \ for each received\n   acknowledgement.  No smoothing of the qdelay is performed;\
    \ however,\n   some smoothing occurs anyway because the CWND computation is a\
    \ low-\n   pass filter function.  A number of variables are updated as\n   illustrated\
    \ by the pseudocode below; temporary variables are appended\n   with '_t'.  As\
    \ mentioned in Section 6, calculation of the proper\n   congestion window and\
    \ media bitrate may benefit from additional\n   optimizations to handle very high\
    \ and very low bitrates, and from\n   additional damping to handle periodic packet\
    \ bursts.  Some such\n   optimizations are implemented in [SCReAM-CPP-implementation],\
    \ but\n   they do not form part of the specification of SCReAM at this time.\n\
    \     <CODE BEGINS>\n     update_variables(qdelay):\n       qdelay_fraction_t\
    \ = qdelay / qdelay_target\n       # Calculate moving average\n       qdelay_fraction_avg\
    \ = (1 - QDELAY_WEIGHT) * qdelay_fraction_avg +\n          QDELAY_WEIGHT * qdelay_fraction_t\n\
    \       update_qdelay_fraction_hist(qdelay_fraction_t)\n       # Compute the average\
    \ of the values in qdelay_fraction_hist\n       avg_t = average(qdelay_fraction_hist)\n\
    \       # R is an autocorrelation function of qdelay_fraction_hist,\n       #\
    \  with the mean (DC component) removed, at lag K\n       # The subtraction of\
    \ the scalar avg_t from\n       #  qdelay_fraction_hist is performed element-wise\n\
    \       a_t = R(qdelay_fraction_hist-avg_t, 1) /\n             R(qdelay_fraction_hist-avg_t,\
    \ 0)\n       # Calculate qdelay trend\n       qdelay_trend = min(1.0, max(0.0,\
    \ a_t * qdelay_fraction_avg))\n       # Calculate a 'peak-hold' qdelay_trend;\
    \ this gives a memory\n       #  of congestion in the past\n       qdelay_trend_mem\
    \ = max(0.99 * qdelay_trend_mem, qdelay_trend)\n      <CODE ENDS>\n   The qdelay\
    \ fraction is sampled every 50 ms, and the last 20 samples\n   are stored in a\
    \ vector (qdelay_fraction_hist).  This vector is used\n   in the computation of\
    \ a qdelay trend that gives a value between 0.0\n   and 1.0 depending on the estimated\
    \ congestion level.  The prediction\n   coefficient 'a_t' has positive values\
    \ if qdelay shows an increasing\n   or decreasing trend; thus, an indication of\
    \ congestion is obtained\n   before the qdelay target is reached.  As a side effect,\
    \ if qdelay\n   decreases, it's taken as a sign of congestion; however, experiments\n\
    \   have shown that this is beneficial, as increasing or decreasing queue\n  \
    \ delay is an indication that the transmit rate is very close to the\n   path\
    \ capacity.\n   The autocorrelation function 'R' is defined as follows.  Let x\
    \ be a\n   vector constituting N values, the biased autocorrelation function for\n\
    \   a given lag=k for the vector x is given by.\n                 n=N-k\n    \
    \     R(x,k) = SUM x(n) * x(n + k)\n                 n=1\n   The prediction coefficient\
    \ is further multiplied with\n   qdelay_fraction_avg to reduce sensitivity to\
    \ increasing qdelay when\n   it is very small.  The 50 ms sampling is a simplification\
    \ that could\n   have the effect that the same qdelay is sampled several times;\n\
    \   however, this does not pose any problem, as the vector is only used\n   to\
    \ determine if the qdelay is increasing or decreasing.  The\n   qdelay_trend is\
    \ utilized in the media rate control to indicate\n   incipient congestion and\
    \ to determine when to exit from fast increase\n   mode. qdelay_trend_mem is used\
    \ to enforce a less aggressive rate\n   increase after congestion events.  The\
    \ function\n   update_qdelay_fraction_hist(..) removes the oldest element and\
    \ adds\n   the latest qdelay_fraction element to the qdelay_fraction_hist\n  \
    \ vector.\n"
- title: 4.1.2.1.  Reaction to Packet Loss and ECN
  contents:
  - "4.1.2.1.  Reaction to Packet Loss and ECN\n   A loss event is indicated if one\
    \ or more RTP packets are declared\n   missing.  The loss detection is described\
    \ in Section 4.1.2.4.  Once a\n   loss event is detected, further detected lost\
    \ RTP packets SHOULD be\n   ignored for a full smoothed round-trip time; the intention\
    \ is to\n   limit the congestion window decrease to at most once per round trip.\n\
    \   The congestion window back-off due to loss events is deliberately a\n   bit\
    \ less than is the case with TCP Reno, for example.  TCP is\n   generally used\
    \ to transmit whole files; the file is then like a\n   source with an infinite\
    \ bitrate until the whole file has been\n   transmitted.  SCReAM, on the other\
    \ hand, has a source whose rate is\n   limited to a value close to the available\
    \ transmit rate and often\n   below that value; the effect is that SCReAM has\
    \ less opportunity to\n   grab free capacity than a TCP-based file transfer. \
    \ To compensate for\n   this, it is RECOMMENDED to let SCReAM reduce the congestion\
    \ window\n   less than what is the case with TCP when loss events occur.\n   An\
    \ ECN event is detected if the n_ECN counter in the feedback report\n   has increased\
    \ since the previous received feedback.  Once an ECN\n   event is detected, the\
    \ n_ECN counter is ignored for a full smoothed\n   round-trip time; the intention\
    \ is to limit the congestion window\n   decrease to at most once per round trip.\
    \  The congestion window back-\n   off due to an ECN event MAY be smaller than\
    \ if a loss event occurs.\n   This is in line with the idea outlined in [ALT-BACKOFF]\
    \ to enable ECN\n   marking thresholds lower than the corresponding packet drop\n\
    \   thresholds.\n"
- title: 4.1.2.2.  Congestion Window Update
  contents:
  - "4.1.2.2.  Congestion Window Update\n   The update of the congestion window depends\
    \ on if loss, ECN-marking,\n   or neither of the two occurs.  The pseudocode below\
    \ describes the\n   actions for each case.\n     <CODE BEGINS>\n     on congestion\
    \ event(qdelay):\n       # Either loss or ECN mark is detected\n       in_fast_increase\
    \ = false\n       if (is loss)\n         # Loss is detected\n         cwnd = max(MIN_CWND,\
    \ cwnd * BETA_LOSS)\n       else\n         # No loss, so it is then an ECN mark\n\
    \         cwnd = max(MIN_CWND, cwnd * BETA_ECN)\n       end\n       adjust_qdelay_target(qdelay)\
    \ #compensating for competing flows\n       calculate_send_window(qdelay, qdelay_target)\n\
    \     # When no congestion event\n     on acknowledgement(qdelay):\n       update_bytes_newly_acked()\n\
    \       update_cwnd(bytes_newly_acked)\n       adjust_qdelay_target(qdelay) #\
    \ compensating for competing flows\n       calculate_send_window(qdelay, qdelay_target)\n\
    \       check_to_resume_fast_increase()\n     <CODE ENDS>\n   The methods are\
    \ described in detail below.\n   The congestion window update is based on qdelay,\
    \ except for the\n   occurrence of loss events (one or more lost RTP packets in\
    \ one RTT)\n   or ECN events, which were described earlier.\n   Pseudocode for\
    \ the update of the congestion window is found below.\n   <CODE BEGINS>\n   update_cwnd(bytes_newly_acked):\n\
    \     # In fast increase mode?\n     if (in_fast_increase)\n       if (qdelay_trend\
    \ >= QDELAY_TREND_TH)\n         # Incipient congestion detected; exit fast increase\
    \ mode\n         in_fast_increase = false\n       else\n         # No congestion\
    \ yet; increase cwnd if it\n         #  is sufficiently used\n         # Additional\
    \ slack of bytes_newly_acked is\n         #  added to ensure that CWND growth\
    \ occurs\n         #  even when feedback is sparse\n         if (bytes_in_flight\
    \ * 1.5 + bytes_newly_acked > cwnd)\n           cwnd = cwnd + bytes_newly_acked\n\
    \         end\n         return\n       end\n     end\n     # Not in fast increase\
    \ mode\n     # off_target calculated as with LEDBAT\n     off_target_t = (qdelay_target\
    \ - qdelay) / qdelay_target\n     gain_t = GAIN\n     # Adjust congestion window\n\
    \     cwnd_delta_t =\n       gain_t * off_target_t * bytes_newly_acked * MSS /\
    \ cwnd\n     if (off_target_t > 0 &&\n         bytes_in_flight * 1.25 + bytes_newly_acked\
    \ <= cwnd)\n       # No cwnd increase if window is underutilized\n       # Additional\
    \ slack of bytes_newly_acked is\n       #  added to ensure that CWND growth occurs\n\
    \       #  even when feedback is sparse\n       cwnd_delta_t = 0;\n     end\n\
    \     # Apply delta\n     cwnd += cwnd_delta_t\n     # limit cwnd to the maximum\
    \ number of bytes in flight\n     cwnd = min(cwnd, max_bytes_in_flight *\n   \
    \             MAX_BYTES_IN_FLIGHT_HEAD_ROOM)\n     cwnd = max(cwnd, MIN_CWND)\n\
    \   <CODE ENDS>\n   CWND is updated differently depending on whether or not the\n\
    \   congestion control is in fast increase mode, as controlled by the\n   variable\
    \ in_fast_increase.\n   When in fast increase mode, the congestion window is increased\
    \ with\n   the number of newly acknowledged bytes as long as the window is\n \
    \  sufficiently used.  Sparse feedback can potentially limit congestion\n   window\
    \ growth; therefore, additional slack is added, given by the\n   number of newly\
    \ acknowledged bytes.\n   The congestion window growth when in_fast_increase is\
    \ false is\n   dictated by the relation between qdelay and qdelay_target; congestion\n\
    \   window growth is limited if the window is not used sufficiently.\n   SCReAM\
    \ calculates the GAIN in a similar way to what is specified in\n   [RFC6817].\
    \  However, [RFC6817] specifies that the CWND increase is\n   limited by an additional\
    \ function controlled by a constant\n   ALLOWED_INCREASE.  This additional limitation\
    \ is removed in this\n   specification.\n   Further, the CWND is limited by max_bytes_in_flight\
    \ and MIN_CWND.\n   The limitation of the congestion window by the maximum number\
    \ of\n   bytes in flight over the last 5 seconds (max_bytes_in_flight) avoids\n\
    \   possible overestimation of the throughput after, for example, idle\n   periods.\
    \  An additional MAX_BYTES_IN_FLIGHT_HEAD_ROOM provides slack\n   to allow for\
    \ a certain amount of variability in the media coder\n   output rate.\n"
- title: 4.1.2.3.  Competing Flows Compensation
  contents:
  - "4.1.2.3.  Competing Flows Compensation\n   It is likely that a flow using the\
    \ SCReAM algorithm will have to\n   share congested bottlenecks with other flows\
    \ that use a more\n   aggressive congestion control algorithm (for example, large\
    \ FTP flows\n   using loss-based congestion control).  The worst condition occurs\n\
    \   when the bottleneck queues are of tail-drop type with a large buffer\n   size.\
    \  SCReAM takes care of such situations by adjusting the\n   qdelay_target when\
    \ loss-based flows are detected, as shown in the\n   pseudocode below.\n     <CODE\
    \ BEGINS>\n     adjust_qdelay_target(qdelay)\n       qdelay_norm_t = qdelay /\
    \ QDELAY_TARGET_LOW\n       update_qdelay_norm_history(qdelay_norm_t)\n      \
    \ # Compute variance\n       qdelay_norm_var_t = VARIANCE(qdelay_norm_history(200))\n\
    \       # Compensation for competing traffic\n       # Compute average\n     \
    \  qdelay_norm_avg_t = AVERAGE(qdelay_norm_history(50))\n       # Compute upper\
    \ limit to target delay\n       new_target_t = qdelay_norm_avg_t + sqrt(qdelay_norm_var_t)\n\
    \       new_target_t *= QDELAY_TARGET_LO\n       if (loss_event_rate > 0.002)\n\
    \         # Packet losses detected\n         qdelay_target = 1.5 * new_target_t\n\
    \       else\n         if (qdelay_norm_var_t < 0.2)\n           # Reasonably safe\
    \ to set target qdelay\n           qdelay_target = new_target_t\n         else\n\
    \           # Check if target delay can be reduced; this helps prevent\n     \
    \      #  the target delay from being locked to high values forever\n        \
    \   if (new_target_t < QDELAY_TARGET_LO)\n             # Decrease target delay\
    \ quickly, as measured queuing\n             #  delay is lower than target\n \
    \            qdelay_target = max(qdelay_target * 0.5, new_target_t)\n        \
    \   else\n             # Decrease target delay slowly\n             qdelay_target\
    \ *= 0.9\n           end\n         end\n       end\n       # Apply limits\n  \
    \     qdelay_target = min(QDELAY_TARGET_HI, qdelay_target)\n       qdelay_target\
    \ = max(QDELAY_TARGET_LO, qdelay_target)\n     <CODE ENDS>\n   Two temporary variables\
    \ are calculated. qdelay_norm_avg_t is the\n   long-term average queue delay,\
    \ qdelay_norm_var_t is the long-term\n   variance of the queue delay.  A high\
    \ qdelay_norm_var_t indicates that\n   the queue delay changes; this can be an\
    \ indication that bottleneck\n   bandwidth is reduced or that a competing flow\
    \ has just entered.\n   Thus, it indicates that it is not safe to adjust the queue\
    \ delay\n   target.\n   A low qdelay_norm_var_t indicates that the queue delay\
    \ is relatively\n   stable.  The reason could be that the queue delay is low,\
    \ but it\n   could also be that a competing flow is causing the bottleneck to\n\
    \   reach the point that packet losses start to occur, in which case the\n   queue\
    \ delay will stay relatively high for a longer time.\n   The queue delay target\
    \ is allowed to be increased if either the loss\n   event rate is above a given\
    \ threshold or qdelay_norm_var_t is low.\n   Both these conditions indicate that\
    \ a competing flow may be present.\n   In all other cases, the queue delay target\
    \ is decreased.\n   The function that adjusts the qdelay_target is simple and\
    \ could\n   produce false positives and false negatives.  The case that self-\n\
    \   inflicted congestion by the SCReAM algorithm may be falsely\n   interpreted\
    \ as the presence of competing loss-based FTP flows is a\n   false positive. \
    \ The opposite case -- where the algorithm fails to\n   detect the presence of\
    \ a competing FTP flow -- is a false negative.\n   Extensive simulations have\
    \ shown that the algorithm performs well in\n   LTE test cases and that it also\
    \ performs well in simple bandwidth-\n   limited bottleneck test cases with competing\
    \ FTP flows.  However, the\n   potential failure of the algorithm cannot be completely\
    \ ruled out.  A\n   false positive (i.e., when self-inflicted congestion is mistakenly\n\
    \   identified as competing flows) is especially problematic when it\n   leads\
    \ to increasing the target queue delay, which can cause the end-\n   to-end delay\
    \ to increase dramatically.\n   If it is deemed unlikely that competing flows\
    \ occur over the same\n   bottleneck, the algorithm described in this section\
    \ MAY be turned\n   off.  One such case is QoS-enabled bearers in 3GPP-based access\
    \ such\n   as LTE.  However, when sending over the Internet, often the network\n\
    \   conditions are not known for sure, so in general it is not possible\n   to\
    \ make safe assumptions on how a network is used and whether or not\n   competing\
    \ flows share the same bottleneck.  Therefore, turning this\n   algorithm off\
    \ must be considered with caution, as it can lead to\n   basically zero throughput\
    \ if competing with loss-based traffic.\n"
- title: 4.1.2.4.  Lost Packet Detection
  contents:
  - "4.1.2.4.  Lost Packet Detection\n   Lost packet detection is based on the received\
    \ sequence number list.\n   A reordering window SHOULD be applied to prevent packet\
    \ reordering\n   from triggering loss events.  The reordering window is specified\
    \ as a\n   time unit, similar to the ideas behind Recent ACKnowledgement (RACK)\n\
    \   [RACK].  The computation of the reordering window is made possible by\n  \
    \ means of a lost flag in the list of transmitted RTP packets.  This\n   flag\
    \ is set if the received sequence number list indicates that the\n   given RTP\
    \ packet is missing.  If later feedback indicates that a\n   previously lost marked\
    \ packet was indeed received, then the\n   reordering window is updated to reflect\
    \ the reordering delay.  The\n   reordering window is given by the difference\
    \ in time between the\n   event that the packet was marked as lost and the event\
    \ that it was\n   indicated as successfully received.  Loss is detected if a given\
    \ RTP\n   packet is not acknowledged within a time window (indicated by the\n\
    \   reordering window) after an RTP packet with a higher sequence number\n   was\
    \ acknowledged.\n"
- title: 4.1.2.5.  Send Window Calculation
  contents:
  - "4.1.2.5.  Send Window Calculation\n   The basic design principle behind packet\
    \ transmission in SCReAM is to\n   allow transmission only if the number of bytes\
    \ in flight is less than\n   the congestion window.  There are, however, two reasons\
    \ why this\n   strict rule will not work optimally:\n   o  Bitrate variations:\
    \ Media sources such as video encoders generally\n      produce frames whose size\
    \ always vary to a larger or smaller\n      extent.  The RTP queue absorbs the\
    \ natural variations in frame\n      sizes.  However, the RTP queue should be\
    \ as short as possible to\n      prevent the end-to-end delay from increasing.\
    \  To achieve that,\n      the media rate control takes the RTP queue size into\
    \ account when\n      the target bitrate for the media is computed.  A strict\
    \ 'send only\n      when bytes in flight is less than the congestion window' rule\
    \ can\n      cause the RTP queue to grow simply because the send window is\n \
    \     limited; in turn, this can cause the target bitrate to be pushed\n     \
    \ down.  The consequence is that the congestion window will not\n      increase,\
    \ or will increase very slowly, because the congestion\n      window is only allowed\
    \ to increase when there is a sufficient\n      amount of data in flight.  The\
    \ final effect is that the media\n      bitrate increases very slowly or not at\
    \ all.\n   o  Reverse (feedback) path congestion: Especially in transport over\n\
    \      buffer-bloated networks, the one-way delay in the reverse\n      direction\
    \ can jump due to congestion.  The effect is that the\n      acknowledgements\
    \ are delayed, and the self-clocking is temporarily\n      halted, even though\
    \ the forward path is not congested.\n   The send window is adjusted depending\
    \ on qdelay, its relation to the\n   qdelay target, and the relation between the\
    \ congestion window and the\n   number of bytes in flight.  A strict rule is applied\
    \ when qdelay is\n   higher than qdelay_target, to avoid further queue buildup\
    \ in the\n   network.  For cases when qdelay is lower than the qdelay_target,\
    \ a\n   more relaxed rule is applied.  This allows the bitrate to increase\n \
    \  quickly when no congestion is detected while still being able to\n   exhibit\
    \ stable behavior in congested situations.\n   The send window is given by the\
    \ relation between the adjusted\n   congestion window and the amount of bytes\
    \ in flight according to the\n   pseudocode below.\n   <CODE BEGINS>\n   calculate_send_window(qdelay,\
    \ qdelay_target)\n     # send window is computed differently depending on congestion\
    \ level\n     if (qdelay <= qdelay_target)\n       send_wnd = cwnd + MSS - bytes_in_flight\n\
    \     else\n       send_wnd = cwnd - bytes_in_flight\n     end\n   <CODE ENDS>\n\
    \   The send window is updated whenever an RTP packet is transmitted or\n   an\
    \ RTCP feedback messaged is received.\n"
- title: 4.1.2.6.  Packet Pacing
  contents:
  - "4.1.2.6.  Packet Pacing\n   Packet pacing is used in order to mitigate coalescing,\
    \ i.e., when\n   packets are transmitted in bursts, with the risks of increased\
    \ jitter\n   and potentially increased packet loss.  Packet pacing also mitigates\n\
    \   possible issues with queue overflow due to key-frame generation in\n   video\
    \ coders.  The time interval between consecutive packet\n   transmissions is greater\
    \ than or equal to t_pace, where t_pace is\n   given by the equations below :\n\
    \      <CODE BEGINS>\n      pace_bitrate = max (RATE_PACE_MIN, cwnd * 8 / s_rtt)\n\
    \      t_pace = rtp_size * 8 / pace_bitrate\n      <CODE ENDS>\n   rtp_size is\
    \ the size of the last transmitted RTP packet, and s_rtt is\n   the smoothed round\
    \ trip time.  RATE_PACE_MIN is the minimum pacing\n   rate.\n"
- title: 4.1.2.7.  Resuming Fast Increase Mode
  contents:
  - "4.1.2.7.  Resuming Fast Increase Mode\n   Fast increase mode can resume in order\
    \ to speed up the bitrate\n   increase if congestion abates.  The condition to\
    \ resume fast increase\n   mode (in_fast_increase = true) is that qdelay_trend\
    \ is less than\n   QDELAY_TREND_LO for T_RESUME_FAST_INCREASE seconds or more.\n"
- title: 4.1.2.8.  Stream Prioritization
  contents:
  - "4.1.2.8.  Stream Prioritization\n   The SCReAM algorithm makes a good distinction\
    \ between network\n   congestion control and media rate control.  This is easily\
    \ extended\n   to many streams -- RTP packets from two or more RTP queues are\n\
    \   scheduled at the rate permitted by the network congestion control.\n   The\
    \ scheduling can be done by means of a few different scheduling\n   regimes. \
    \ For example, the method for coupled congestion control\n   specified in [COUPLED-CC]\
    \ can be used.  One implementation of SCReAM\n   [SCReAM-CPP-implementation] uses\
    \ credit-based scheduling.  In credit-\n   based scheduling, credit is accumulated\
    \ by queues as they wait for\n   service and is spent while the queues are being\
    \ serviced.  For\n   instance, if one queue is allowed to transmit 1000 bytes,\
    \ then a\n   credit of 1000 bytes is allocated to the other unscheduled queues.\n\
    \   This principle can be extended to weighted scheduling, where the\n   credit\
    \ allocated to unscheduled queues depends on the relative\n   weights.  The latter\
    \ is also implemented in\n   [SCReAM-CPP-implementation].\n"
- title: 4.1.3.  Media Rate Control
  contents:
  - "4.1.3.  Media Rate Control\n   The media rate control algorithm is executed at\
    \ regular intervals,\n   indicated by RATE_ADJUSTMENT_INTERVAL, with the exception\
    \ of a prompt\n   reaction to loss events.  The media rate control operates based\
    \ on\n   the size of the RTP packet send queue and observed loss events.  In\n\
    \   addition, qdelay_trend is also considered in the media rate control\n   in\
    \ order to reduce the amount of induced network jitter.\n   The role of the media\
    \ rate control is to strike a reasonable balance\n   between a low amount of queuing\
    \ in the RTP queue(s) and a sufficient\n   amount of data to send in order to\
    \ keep the data path busy.  Setting\n   the media rate control too cautiously\
    \ leads to possible\n   underutilization of network capacity; this can cause the\
    \ flow to\n   become starved out by other more opportunistic traffic.  On the\
    \ other\n   hand, setting it too aggressively leads to increased jitter.\n   The\
    \ target_bitrate is adjusted depending on the congestion state.\n   The target\
    \ bitrate can vary between a minimum value\n   (TARGET_BITRATE_MIN) and a maximum\
    \ value (TARGET_BITRATE_MAX).\n   TARGET_BITRATE_MIN SHOULD be set to a low enough\
    \ value to prevent RTP\n   packets from becoming queued up when the network throughput\
    \ is\n   reduced.  The sender SHOULD also be equipped with a mechanism that\n\
    \   discards RTP packets when the network throughput becomes very low and\n  \
    \ RTP packets are excessively delayed.\n   For the overall bitrate adjustment,\
    \ two network throughput estimates\n   are computed :\n   o  rate_transmit: The\
    \ measured transmit bitrate.\n   o  rate_ack: The ACKed bitrate, i.e., the volume\
    \ of ACKed bits per\n      second.\n   Both estimates are updated every 200 ms.\n\
    \   The current throughput, current_rate, is computed as the maximum\n   value\
    \ of rate_transmit and rate_ack.  The rationale behind the use of\n   rate_ack\
    \ in addition to rate_transmit is that rate_transmit is\n   affected also by the\
    \ amount of data that is available to transmit,\n   thus a lack of data to transmit\
    \ can be seen as reduced throughput\n   that can cause an unnecessary rate reduction.\
    \  To overcome this\n   shortcoming, rate_ack is used as well.  This gives a more\
    \ stable\n   throughput estimate.\n   The rate change behavior depends on whether\
    \ a loss or ECN event has\n   occurred and whether the congestion control is in\
    \ fast increase mode.\n   <CODE BEGINS>\n   # The target_bitrate is updated at\
    \ a regular interval according\n   # to RATE_ADJUST_INTERVAL\n   on loss:\n  \
    \    # Loss event detected\n      target_bitrate = max(BETA_R * target_bitrate,\n\
    \                           TARGET_BITRATE_MIN)\n      exit\n   on ecn_mark:\n\
    \      # ECN event detected\n      target_bitrate = max(BETA_ECN * target_bitrate,\n\
    \                           TARGET_BITRATE_MIN)\n      exit\n   ramp_up_speed_t\
    \ = min(RAMP_UP_SPEED, target_bitrate / 2.0)\n   scale_t = (target_bitrate - target_bitrate_last_max)\
    \ /\n        target_bitrate_last_max\n   scale_t = max(0.2, min(1.0, (scale_t\
    \ * 4)^2))\n   # min scale_t value 0.2, as the bitrate should be allowed to\n\
    \   #  increase slowly. This prevents locking the rate to\n   #  target_bitrate_last_max\n\
    \   if (in_fast_increase = true)\n      increment_t = ramp_up_speed_t * RATE_ADJUST_INTERVAL\n\
    \      increment_t *= scale_t\n      target_bitrate += increment_t\n   else\n\
    \      current_rate_t = max(rate_transmit, rate_ack)\n      # Compute a bitrate\
    \ change\n      delta_rate_t = current_rate_t * (1.0 - PRE_CONGESTION_GUARD *\n\
    \           queue_delay_trend) - TX_QUEUE_SIZE_FACTOR * rtp_queue_size\n     \
    \ # Limit a positive increase if close to target_bitrate_last_max\n      if (delta_rate_t\
    \ > 0)\n        delta_rate_t *= scale_t\n        delta_rate_t =\n          min(delta_rate_t,\
    \ ramp_up_speed_t * RATE_ADJUST_INTERVAL)\n      end\n      target_bitrate +=\
    \ delta_rate_t\n      # Force a slight reduction in bitrate if RTP queue\n   \
    \   #  builds up\n      rtp_queue_delay_t = rtp_queue_size / current_rate_t\n\
    \      if (rtp_queue_delay_t > RTP_QDELAY_TH)\n        target_bitrate *= TARGET_RATE_SCALE_RTP_QDELAY\n\
    \      end\n   end\n   rate_media_limit_t =\n      max(current_rate_t, max(rate_media,\
    \ rtp_rate_median))\n   rate_media_limit_t *= (2.0 - qdelay_trend_mem)\n   target_bitrate\
    \ = min(target_bitrate, rate_media_limit_t)\n   target_bitrate = min(TARGET_BITRATE_MAX,\n\
    \      max(TARGET_BITRATE_MIN, target_bitrate))\n   <CODE ENDS>\n   In case of\
    \ a loss event, the target_bitrate is updated and the rate\n   change procedure\
    \ is exited.  Otherwise, the rate change procedure\n   continues.  The rationale\
    \ behind the rate reduction due to loss is\n   that a congestion window reduction\
    \ will take effect, and a rate\n   reduction proactively prevents RTP packets\
    \ from being queued up when\n   the transmit rate decreases due to the reduced\
    \ congestion window.  A\n   similar rate reduction happens when ECN events are\
    \ detected.\n   The rate update frequency is limited by RATE_ADJUST_INTERVAL,\
    \ unless\n   a loss event occurs.  The value is based on experimentation with\n\
    \   real-life limitations in video coders taken into account\n   [SCReAM-CPP-implementation].\
    \  A too short interval is shown to make\n   the rate control loop in video coders\
    \ more unstable; a too long\n   interval makes the overall congestion control\
    \ sluggish.\n   When in fast increase mode (in_fast_increase = true), the bitrate\n\
    \   increase is given by the desired ramp-up speed (RAMP_UP_SPEED).  The\n   ramp-up\
    \ speed is limited when the target bitrate is low to avoid rate\n   oscillation\
    \ at low bottleneck bitrates.  The setting of RAMP_UP_SPEED\n   depends on preferences.\
    \  A high setting such as 1000 kbps/s makes it\n   possible to quickly get high-quality\
    \ media; however, this is at the\n   expense of increased jitter, which can manifest\
    \ itself as choppy\n   video rendering, for example.\n   When in_fast_increase\
    \ is false, the bitrate increase is given by the\n   current bitrate and is also\
    \ controlled by the estimated RTP queue and\n   the qdelay trend, thus it is sufficient\
    \ that an increased congestion\n   level is sensed by the network congestion control\
    \ to limit the\n   bitrate.  The target_bitrate_last_max is updated when congestion\
    \ is\n   detected.\n   Finally, the target_bitrate is within the defined min and\
    \ max values.\n   The aware reader may notice the dependency on the qdelay in\
    \ the\n   computation of the target bitrate; this manifests itself in the use\n\
    \   of the qdelay_trend.  As these parameters are used also in the\n   network\
    \ congestion control, one may suspect some odd interaction\n   between the media\
    \ rate control and the network congestion control.\n   This is in fact the case\
    \ if the parameter PRE_CONGESTION_GUARD is set\n   to a high value.  The use of\
    \ qdelay_trend in the media rate control\n   is solely to reduce jitter; the dependency\
    \ can be removed by setting\n   PRE_CONGESTION_GUARD=0.  The effect is a somewhat\
    \ larger rate\n   increase after congestion, at the expense of increased jitter\
    \ in\n   congested situations.\n"
- title: 4.2.  SCReAM Receiver
  contents:
  - "4.2.  SCReAM Receiver\n   The simple task of the SCReAM receiver is to feed back\n\
    \   acknowledgements of received packets and total ECN count to the\n   SCReAM\
    \ sender.  In addition, the receive time of the RTP packet with\n   the highest\
    \ sequence number is echoed back.  Upon reception of each\n   RTP packet, the\
    \ receiver MUST maintain enough information to send the\n   aforementioned values\
    \ to the SCReAM sender via an RTCP transport-\n   layer feedback message.  The\
    \ frequency of the feedback message\n   depends on the available RTCP bandwidth.\
    \  The requirements on the\n   feedback elements and the feedback interval are\
    \ described below.\n"
- title: 4.2.1.  Requirements on Feedback Elements
  contents:
  - "4.2.1.  Requirements on Feedback Elements\n   The following feedback elements\
    \ are REQUIRED for basic functionality\n   in SCReAM.\n   o  A list of received\
    \ RTP packets.  This list SHOULD be sufficiently\n      long to cover all received\
    \ RTP packets.  This list can be realized\n      with the Loss RLE (Run Length\
    \ Encoding) Report Block in [RFC3611].\n   o  A wall-clock timestamp corresponding\
    \ to the received RTP packet\n      with the highest sequence number is required\
    \ in order to compute\n      the qdelay.  This can be realized by means of the\
    \ Packet Receipt\n      Times Report Block in [RFC3611].  begin_seq MUST be set\
    \ to the\n      highest received sequence number (which has possibly wrapped\n\
    \      around); end_seq MUST be set to begin_seq+1 modulo 65536.  The\n      timestamp\
    \ clock MAY be set according to [RFC3611], i.e., equal to\n      the RTP timestamp\
    \ clock.  Detailed individual packet receive times\n      are not necessary, as\
    \ SCReAM does currently not describe how they\n      can be used.\n   The basic\
    \ feedback needed for SCReAM involves the use of the Loss RLE\n   Report Block\
    \ and the Packet Receipt Times Report Block as shown in\n   Figure 2.\n      \
    \  0                   1                   2                   3\n        0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |V=2|P|reserved |   PT=XR=207   |             length            |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |                              SSRC                             |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \     BT=2      | rsvd. |  T=0  |         block length          |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |                        SSRC of source                         |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |          begin_seq            |             end_seq           |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \          chunk 1              |             chunk 2           |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       :                              ...                              :\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |          chunk n-1            |             chunk n           |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \     BT=3      | rsvd. |  T=0  |         block length          |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |                        SSRC of source                         |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |          begin_seq            |             end_seq           |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \       Receipt time of packet begin_seq                        |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Figure 2: Basic Feedback Message for SCReAM, Based on RFC 3611\n   In a\
    \ typical use case, no more than four Loss RLE chunks are needed,\n   thus the\
    \ feedback message will be 44 bytes.  It is obvious from\n   Figure 2 that there\
    \ is a lot of redundant information in the feedback\n   message.  A more optimized\
    \ feedback format, including the additional\n   feedback elements listed below,\
    \ could reduce the feedback message\n   size a bit.\n   An additional feedback\
    \ element that can improve the performance of\n   SCReAM is:\n   o  Accumulated\
    \ number of ECN-CE-marked packets (n_ECN).  For\n      instance, this can be realized\
    \ with the ECN Feedback Report Format\n      in [RFC6679].  The given feedback\
    \ report format is slightly\n      overkill, as SCReAM would do quite well with\
    \ only a counter that\n      increments by one for each received packet with the\
    \ ECN-CE\n      codepoint set.  The more bulky format could nevertheless be useful\n\
    \      for, e.g., ECN black-hole detection.\n"
- title: 4.2.2.  Requirements on Feedback Intensity
  contents:
  - "4.2.2.  Requirements on Feedback Intensity\n   SCReAM benefits from relatively\
    \ frequent feedback.  It is RECOMMENDED\n   that a SCReAM implementation follows\
    \ the guidelines below.\n   The feedback interval depends on the media bitrate.\
    \  At low bitrates,\n   it is sufficient with a feedback interval of 100 to 400\
    \ ms; while at\n   high bitrates, a feedback interval of roughly 20 ms is preferred.\
    \  At\n   very high bitrates, even shorter feedback intervals MAY be needed in\n\
    \   order to keep the self-clocking in SCReAM working well.  One\n   indication\
    \ that feedback is too sparse is that the SCReAM\n   implementation cannot reach\
    \ high bitrates, even in uncongested links.\n   More frequent feedback might solve\
    \ this issue.\n   The numbers above can be formulated as a feedback interval function\n\
    \   that can be useful for the computation of the desired RTCP bandwidth.\n  \
    \ The following equation expresses the feedback rate:\n      rate_fb = min(50,\
    \ max(2.5, rate_media / 10000))\n   rate_media is the RTP media bitrate expressed\
    \ in bps; rate_fb is the\n   feedback rate expressed in packets/s.  Converting\
    \ to feedback\n   interval, we get:\n      fb_int = 1.0 / min(50, max(2.5, rate_media\
    \ / 10000))\n   The transmission interval is not critical.  So, in the case of\
    \ multi-\n   stream handling between two hosts, the feedback for two or more\n\
    \   synchronization sources (SSRCs) can be bundled to save UDP/IP\n   overhead.\
    \  However, the final realized feedback interval SHOULD not\n   exceed 2*fb_int\
    \ in such cases, meaning that a scheduled feedback\n   transmission event should\
    \ not be delayed more than fb_int.\n   SCReAM works with AVPF regular mode; immediate\
    \ or early mode is not\n   required by SCReAM but can nonetheless be useful for\
    \ RTCP messages\n   not directly related to SCReAM, such as those specified in\
    \ [RFC4585].\n   It is RECOMMENDED to use reduced-size RTCP [RFC5506], where regular\n\
    \   full compound RTCP transmission is controlled by trr-int as described\n  \
    \ in [RFC4585].\n"
- title: 5.  Discussion
  contents:
  - "5.  Discussion\n   This section covers a few discussion points.\n   o  Clock\
    \ drift: SCReAM can suffer from the same issues with clock\n      drift as is\
    \ the case with LEDBAT [RFC6817].  However, Appendix A.2\n      in [RFC6817] describes\
    \ ways to mitigate issues with clock drift.\n   o  Support for alternate ECN semantics:\
    \ This specification adopts the\n      proposal in [ALT-BACKOFF] to reduce the\
    \ congestion window less\n      when ECN-based congestion events are detected.\
    \  Future work on Low\n      Loss, Low Latency for Scalable throughput (L4S) may\
    \ lead to\n      updates in a future document that describes SCReAM support for\n\
    \      L4S.\n   o  A new transport-layer feedback message (as specified in RFC\
    \ 4585)\n      could be standardized if the use of the already existing RTCP\n\
    \      extensions as described in Section 4.2 is not deemed sufficient.\n   o\
    \  The target bitrate given by SCReAM is the bitrate including the\n      RTP\
    \ and Forward Error Correction (FEC) overhead.  The media\n      encoder SHOULD\
    \ take this overhead into account when the media\n      bitrate is set.  This\
    \ means that the media coder bitrate SHOULD be\n      computed as\n      media_rate\
    \ = target_bitrate - rtp_plus_fec_overhead_bitrate\n      It is not necessary\
    \ to make a 100% perfect compensation for the\n      overhead, as the SCReAM algorithm\
    \ will inherently compensate for\n      moderate errors.  Under-compensating for\
    \ the overhead has the\n      effect of increasing jitter, while overcompensating\
    \ will cause the\n      bottleneck link to become underutilized.\n"
- title: 6.  Suggested Experiments
  contents:
  - "6.  Suggested Experiments\n   SCReAM has been evaluated in a number of different\
    \ ways, mostly in a\n   simulator.  The OpenWebRTC implementation work ([OpenWebRTC]\
    \ and\n   [SCReAM-implementation]) involved extensive testing with artificial\n\
    \   bottlenecks with varying bandwidths and using two different video\n   coders\
    \ (OpenH264 and VP9).\n   Preferably, further experiments will be done by means\
    \ of\n   implementation in real clients and web browsers.  RECOMMENDED\n   experiments\
    \ are:\n   o  Trials with various access technologies: EDGE/3G/4G, Wi-Fi, DSL.\n\
    \      Some experiments have already been carried out with LTE access;\n     \
    \ see [SCReAM-CPP-implementation] and\n      [SCReAM-implementation-experience].\n\
    \   o  Trials with different kinds of media: Audio, video, slideshow\n      content.\
    \  Evaluation of multi-stream handling in SCReAM.\n   o  Evaluation of functionality\
    \ of the compensation mechanism when\n      there are competing flows: Evaluate\
    \ how SCReAM performs with\n      competing TCP-like traffic and to what extent\
    \ the compensation for\n      competing flows causes self-inflicted congestion.\n\
    \   o  Determine proper parameters: A set of default parameters are given\n  \
    \    that makes SCReAM work over a reasonably large operation range.\n      However,\
    \ for very low or very high bitrates, it may be necessary\n      to use different\
    \ values for the RAMP_UP_SPEED, for instance.\n   o  Experimentation with further\
    \ improvements to the congestion window\n      and media bitrate calculation.\
    \  [SCReAM-CPP-implementation]\n      implements some optimizations, not described\
    \ in this memo, that\n      improve performance slightly.  Further experiments\
    \ are likely to\n      lead to more optimizations of the algorithm.\n"
- title: 7.  IANA Considerations
  contents:
  - "7.  IANA Considerations\n   This document does not require any IANA actions.\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   The feedback can be vulnerable to attacks similar\
    \ to those that can\n   affect TCP.  It is therefore RECOMMENDED that the RTCP\
    \ feedback is at\n   least integrity protected.  Furthermore, as SCReAM is self-clocked,\
    \ a\n   malicious middlebox can drop RTCP feedback packets and thus cause the\n\
    \   self-clocking in SCReAM to stall.  However, this attack is mitigated\n   by\
    \ the minimum send rate maintained by SCReAM when no feedback is\n   received.\n"
- title: 9.  References
  contents:
  - '9.  References

    '
- title: 9.1.  Normative References
  contents:
  - "9.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n  \
    \            DOI 10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n\
    \   [RFC3550]  Schulzrinne, H., Casner, S., Frederick, R., and V.\n          \
    \    Jacobson, \"RTP: A Transport Protocol for Real-Time\n              Applications\"\
    , STD 64, RFC 3550, DOI 10.17487/RFC3550,\n              July 2003, <https://www.rfc-editor.org/info/rfc3550>.\n\
    \   [RFC3611]  Friedman, T., Ed., Caceres, R., Ed., and A. Clark, Ed.,\n     \
    \         \"RTP Control Protocol Extended Reports (RTCP XR)\",\n             \
    \ RFC 3611, DOI 10.17487/RFC3611, November 2003,\n              <https://www.rfc-editor.org/info/rfc3611>.\n\
    \   [RFC4585]  Ott, J., Wenger, S., Sato, N., Burmeister, C., and J. Rey,\n  \
    \            \"Extended RTP Profile for Real-time Transport Control\n        \
    \      Protocol (RTCP)-Based Feedback (RTP/AVPF)\", RFC 4585,\n              DOI\
    \ 10.17487/RFC4585, July 2006,\n              <https://www.rfc-editor.org/info/rfc4585>.\n\
    \   [RFC5506]  Johansson, I. and M. Westerlund, \"Support for Reduced-Size\n \
    \             Real-Time Transport Control Protocol (RTCP): Opportunities\n   \
    \           and Consequences\", RFC 5506, DOI 10.17487/RFC5506, April\n      \
    \        2009, <https://www.rfc-editor.org/info/rfc5506>.\n   [RFC6298]  Paxson,\
    \ V., Allman, M., Chu, J., and M. Sargent,\n              \"Computing TCP's Retransmission\
    \ Timer\", RFC 6298,\n              DOI 10.17487/RFC6298, June 2011,\n       \
    \       <https://www.rfc-editor.org/info/rfc6298>.\n   [RFC6817]  Shalunov, S.,\
    \ Hazel, G., Iyengar, J., and M. Kuehlewind,\n              \"Low Extra Delay\
    \ Background Transport (LEDBAT)\", RFC 6817,\n              DOI 10.17487/RFC6817,\
    \ December 2012,\n              <https://www.rfc-editor.org/info/rfc6817>.\n \
    \  [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n      \
    \        2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n         \
    \     May 2017, <https://www.rfc-editor.org/info/rfc8174>.\n"
- title: 9.2.  Informative References
  contents:
  - "9.2.  Informative References\n   [ALT-BACKOFF]\n              Khademi, N., Welzl,\
    \ M., Armitage, G., and G. Fairhurst,\n              \"TCP Alternative Backoff\
    \ with ECN (ABE)\", Work in\n              Progress, draft-ietf-tcpm-alternativebackoff-ecn-04,\n\
    \              November 2017.\n   [COUPLED-CC]\n              Islam, S., Welzl,\
    \ M., and S. Gjessing, \"Coupled congestion\n              control for RTP media\"\
    , Work in Progress, draft-ietf-\n              rmcat-coupled-cc-07, September\
    \ 2017.\n   [LEDBAT-delay-impact]\n              Ros, D. and M. Welzl, \"Assessing\
    \ LEDBAT's Delay Impact\",\n              IEEE Communications Letters, Vol. 17,\
    \ No. 5,\n              DOI 10.1109/LCOMM.2013.040213.130137, May 2013,\n    \
    \          <http://home.ifi.uio.no/michawe/research/publications/\n          \
    \    ledbat-impact-letters.pdf>.\n   [OpenWebRTC]\n              Ericsson Research,\
    \ \"OpenWebRTC\",\n              <http://www.openwebrtc.org>.\n   [Packet-conservation]\n\
    \              Jacobson, V., \"Congestion Avoidance and Control\", ACM\n     \
    \         SIGCOMM Computer Communication Review,\n              DOI 10.1145/52325.52356,\
    \ August 1988.\n   [QoS-3GPP] 3GPP, \"Policy and charging control architecture\"\
    , 3GPP TS\n              23.203, July 2017,\n              <http://www.3gpp.org/ftp/specs/archive/23_series/23.203/>.\n\
    \   [RACK]     Cheng, Y., Cardwell, N., and N. Dukkipati, \"RACK: a time-\n  \
    \            based fast loss detection algorithm for TCP\", Work in\n        \
    \      Progress, draft-ietf-tcpm-rack-02, March 2017.\n   [RFC6679]  Westerlund,\
    \ M., Johansson, I., Perkins, C., O'Hanlon, P.,\n              and K. Carlberg,\
    \ \"Explicit Congestion Notification (ECN)\n              for RTP over UDP\",\
    \ RFC 6679, DOI 10.17487/RFC6679, August\n              2012, <https://www.rfc-editor.org/info/rfc6679>.\n\
    \   [RFC7478]  Holmberg, C., Hakansson, S., and G. Eriksson, \"Web Real-\n   \
    \           Time Communication Use Cases and Requirements\", RFC 7478,\n     \
    \         DOI 10.17487/RFC7478, March 2015,\n              <https://www.rfc-editor.org/info/rfc7478>.\n\
    \   [RFC7661]  Fairhurst, G., Sathiaseelan, A., and R. Secchi, \"Updating\n  \
    \            TCP to Support Rate-Limited Traffic\", RFC 7661,\n              DOI\
    \ 10.17487/RFC7661, October 2015,\n              <https://www.rfc-editor.org/info/rfc7661>.\n\
    \   [SCReAM-CPP-implementation]\n              Ericsson Research, \"SCReAM - Mobile\
    \ optimised congestion\n              control algorithm\",\n              <https://github.com/EricssonResearch/scream>.\n\
    \   [SCReAM-implementation]\n              Ericsson Research, \"OpenWebRTC specific\
    \ GStreamer\n              plugins\", <https://github.com/EricssonResearch/\n\
    \              openwebrtc-gst-plugins>.\n   [SCReAM-implementation-experience]\n\
    \              Sarker, Z. and I. Johansson, \"Updates on SCReAM: An\n        \
    \      implementation experience\", November 2015,\n              <https://www.ietf.org/proceedings/94/slides/\n\
    \              slides-94-rmcat-8.pdf>.\n   [TFWC]     Choi, S. and M. Handley,\
    \ \"Fairer TCP-Friendly Congestion\n              Control Protocol for Multimedia\
    \ Streaming Applications\",\n              DOI 10.1145/1364654.1364717, December\
    \ 2007,\n              <http://www-dept.cs.ucl.ac.uk/staff/M.Handley/papers/\n\
    \              tfwc-conext.pdf>.\n   [WIRELESS-TESTS]\n              Sarker, Z.,\
    \ Johansson, I., Zhu, X., Fu, J., Tan, W., and\n              M. Ramalho, \"Evaluation\
    \ Test Cases for Interactive Real-\n              Time Media over Wireless Networks\"\
    , Work in Progress,\n              draft-ietf-rmcat-wireless-tests-04, May 2017.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   We would like to thank the following people for their comments,\n\
    \   questions, and support during the work that led to this memo: Markus\n   Andersson,\
    \ Bo Burman, Tomas Frankkila, Frederic Gabin, Laurits Hamm,\n   Hans Hannu, Nikolas\
    \ Hermanns, Stefan Haakansson, Erlendur Karlsson,\n   Daniel Lindstroem, Mats\
    \ Nordberg, Jonathan Samuelsson, Rickard\n   Sjoeberg, Robert Swain, Magnus Westerlund,\
    \ and Stefan Aalund.  Many\n   additional thanks to RMCAT chairs Karen E. E. Nielsen\
    \ and Mirja\n   Kuehlewind for patiently reading, suggesting improvements and\
    \ also\n   for asking all the difficult but necessary questions.  Thanks to\n\
    \   Stefan Holmer, Xiaoqing Zhu, Safiqul Islam, and David Hayes for the\n   additional\
    \ review of this document.  Thanks to Ralf Globisch for\n   taking time to try\
    \ out SCReAM in his challenging low-bitrate use\n   cases, Robert Hedman for finding\
    \ a few additional flaws in the\n   running code, and Gustavo Garcia and 'miseri'\
    \ for code contributions.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Ingemar Johansson\n   Ericsson AB\n   Laboratoriegraend\
    \ 11\n   Luleaa  977 53\n   Sweden\n   Phone: +46 730783289\n   Email: ingemar.s.johansson@ericsson.com\n\
    \   Zaheduzzaman Sarker\n   Ericsson AB\n   Laboratoriegraend 11\n   Luleaa  977\
    \ 53\n   Sweden\n   Phone: +46 761153743\n   Email: zaheduzzaman.sarker@ericsson.com\n"
