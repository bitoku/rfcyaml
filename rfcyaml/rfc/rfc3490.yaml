- title: __initial_text__
  contents:
  - '         Internationalizing Domain Names in Applications (IDNA)

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2003).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   Until now, there has been no standard method for domain names to\
    \ use\n   characters outside the ASCII repertoire.  This document defines\n  \
    \ internationalized domain names (IDNs) and a mechanism called\n   Internationalizing\
    \ Domain Names in Applications (IDNA) for handling\n   them in a standard fashion.\
    \  IDNs use characters drawn from a large\n   repertoire (Unicode), but IDNA allows\
    \ the non-ASCII characters to be\n   represented using only the ASCII characters\
    \ already allowed in so-\n   called host names today.  This backward-compatible\
    \ representation is\n   required in existing protocols like DNS, so that IDNs\
    \ can be\n   introduced with no changes to the existing infrastructure.  IDNA\
    \ is\n   only meant for processing domain names, not free text.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction..................................................\
    \  2\n      1.1 Problem Statement.........................................  3\n\
    \      1.2 Limitations of IDNA.......................................  3\n   \
    \   1.3 Brief overview for application developers.................  4\n   2. Terminology...................................................\
    \  5\n   3. Requirements and applicability................................  7\n\
    \      3.1 Requirements..............................................  7\n   \
    \   3.2 Applicability.............................................  8\n      \
    \   3.2.1. DNS resource records................................  8\n         3.2.2.\
    \ Non-domain-name data types stored in domain names...  9\n   4. Conversion operations.........................................\
    \  9\n      4.1 ToASCII................................................... 10\n\
    \      4.2 ToUnicode................................................. 11\n   5.\
    \ ACE prefix.................................................... 12\n   6. Implications\
    \ for typical applications using DNS............... 13\n      6.1 Entry and display\
    \ in applications......................... 14\n      6.2 Applications and resolver\
    \ libraries....................... 15\n      6.3 DNS servers...............................................\
    \ 15\n      6.4 Avoiding exposing users to the raw ACE encoding........... 16\n\
    \      6.5  DNSSEC authentication of IDN domain names................ 16\n   7.\
    \ Name server considerations.................................... 17\n   8. Root\
    \ server considerations.................................... 17\n   9. References....................................................\
    \ 18\n      9.1 Normative References...................................... 18\n\
    \      9.2 Informative References.................................... 18\n   10.\
    \ Security Considerations...................................... 19\n   11. IANA\
    \ Considerations.......................................... 20\n   12. Authors'\
    \ Addresses........................................... 21\n   13. Full Copyright\
    \ Statement..................................... 22\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   IDNA works by allowing applications to use certain ASCII\
    \ name labels\n   (beginning with a special prefix) to represent non-ASCII name\
    \ labels.\n   Lower-layer protocols need not be aware of this; therefore IDNA\
    \ does\n   not depend on changes to any infrastructure.  In particular, IDNA\n\
    \   does not depend on any changes to DNS servers, resolvers, or protocol\n  \
    \ elements, because the ASCII name service provided by the existing DNS\n   is\
    \ entirely sufficient for IDNA.\n   This document does not require any applications\
    \ to conform to IDNA,\n   but applications can elect to use IDNA in order to support\
    \ IDN while\n   maintaining interoperability with existing infrastructure.  If\
    \ an\n   application wants to use non-ASCII characters in domain names, IDNA\n\
    \   is the only currently-defined option.  Adding IDNA support to an\n   existing\
    \ application entails changes to the application only, and\n   leaves room for\
    \ flexibility in the user interface.\n   A great deal of the discussion of IDN\
    \ solutions has focused on\n   transition issues and how IDN will work in a world\
    \ where not all of\n   the components have been updated.  Proposals that were\
    \ not chosen by\n   the IDN Working Group would depend on user applications, resolvers,\n\
    \   and DNS servers being updated in order for a user to use an\n   internationalized\
    \ domain name.  Rather than rely on widespread\n   updating of all components,\
    \ IDNA depends on updates to user\n   applications only; no changes are needed\
    \ to the DNS protocol or any\n   DNS servers or the resolvers on user's computers.\n"
- title: 1.1 Problem Statement
  contents:
  - "1.1 Problem Statement\n   The IDNA specification solves the problem of extending\
    \ the repertoire\n   of characters that can be used in domain names to include\
    \ the Unicode\n   repertoire (with some restrictions).\n   IDNA does not extend\
    \ the service offered by DNS to the applications.\n   Instead, the applications\
    \ (and, by implication, the users) continue\n   to see an exact-match lookup service.\
    \  Either there is a single\n   exactly-matching name or there is no match.  This\
    \ model has served\n   the existing applications well, but it requires, with or\
    \ without\n   internationalized domain names, that users know the exact spelling\
    \ of\n   the domain names that the users type into applications such as web\n\
    \   browsers and mail user agents.  The introduction of the larger\n   repertoire\
    \ of characters potentially makes the set of misspellings\n   larger, especially\
    \ given that in some cases the same appearance, for\n   example on a business\
    \ card, might visually match several Unicode code\n   points or several sequences\
    \ of code points.\n   IDNA allows the graceful introduction of IDNs not only by\
    \ avoiding\n   upgrades to existing infrastructure (such as DNS servers and mail\n\
    \   transport agents), but also by allowing some rudimentary use of IDNs\n   in\
    \ applications by using the ASCII representation of the non-ASCII\n   name labels.\
    \  While such names are very user-unfriendly to read and\n   type, and hence are\
    \ not suitable for user input, they allow (for\n   instance) replying to email\
    \ and clicking on URLs even though the\n   domain name displayed is incomprehensible\
    \ to the user.  In order to\n   allow user-friendly input and output of the IDNs,\
    \ the applications\n   need to be modified to conform to this specification.\n\
    \   IDNA uses the Unicode character repertoire, which avoids the\n   significant\
    \ delays that would be inherent in waiting for a different\n   and specific character\
    \ set be defined for IDN purposes by some other\n   standards developing organization.\n"
- title: 1.2 Limitations of IDNA
  contents:
  - "1.2 Limitations of IDNA\n   The IDNA protocol does not solve all linguistic issues\
    \ with users\n   inputting names in different scripts.  Many important language-based\n\
    \   and script-based mappings are not covered in IDNA and need to be\n   handled\
    \ outside the protocol.  For example, names that are entered in\n   a mix of traditional\
    \ and simplified Chinese characters will not be\n   mapped to a single canonical\
    \ name.  Another example is Scandinavian\n   names that are entered with U+00F6\
    \ (LATIN SMALL LETTER O WITH\n   DIAERESIS) will not be mapped to U+00F8 (LATIN\
    \ SMALL LETTER O WITH\n   STROKE).\n   An example of an important issue that is\
    \ not considered in detail in\n   IDNA is how to provide a high probability that\
    \ a user who is entering\n   a domain name based on visual information (such as\
    \ from a business\n   card or billboard) or aural information (such as from a\
    \ telephone or\n   radio) would correctly enter the IDN.  Similar issues exist\
    \ for ASCII\n   domain names, for example the possible visual confusion between\
    \ the\n   letter 'O' and the digit zero, but the introduction of the larger\n\
    \   repertoire of characters creates more opportunities of similar\n   looking\
    \ and similar sounding names.  Note that this is a complex\n   issue relating\
    \ to languages, input methods on computers, and so on.\n   Furthermore, the kind\
    \ of matching and searching necessary for a high\n   probability of success would\
    \ not fit the role of the DNS and its\n   exact matching function.\n"
- title: 1.3 Brief overview for application developers
  contents:
  - "1.3 Brief overview for application developers\n   Applications can use IDNA to\
    \ support internationalized domain names\n   anywhere that ASCII domain names\
    \ are already supported, including DNS\n   master files and resolver interfaces.\
    \  (Applications can also define\n   protocols and interfaces that support IDNs\
    \ directly using non-ASCII\n   representations.  IDNA does not prescribe any particular\n\
    \   representation for new protocols, but it still defines which names\n   are\
    \ valid and how they are compared.)\n   The IDNA protocol is contained completely\
    \ within applications.  It is\n   not a client-server or peer-to-peer protocol:\
    \ everything is done\n   inside the application itself.  When used with a DNS\
    \ resolver\n   library, IDNA is inserted as a \"shim\" between the application\
    \ and the\n   resolver library.  When used for writing names into a DNS zone,\
    \ IDNA\n   is used just before the name is committed to the zone.\n   There are\
    \ two operations described in section 4 of this document:\n   -  The ToASCII operation\
    \ is used before sending an IDN to something\n      that expects ASCII names (such\
    \ as a resolver) or writing an IDN\n      into a place that expects ASCII names\
    \ (such as a DNS master file).\n   -  The ToUnicode operation is used when displaying\
    \ names to users,\n      for example names obtained from a DNS zone.\n   It is\
    \ important to note that the ToASCII operation can fail.  If it\n   fails when\
    \ processing a domain name, that domain name cannot be used\n   as an internationalized\
    \ domain name and the application has to have\n   some method of dealing with\
    \ this failure.\n   IDNA requires that implementations process input strings with\n\
    \   Nameprep [NAMEPREP], which is a profile of Stringprep [STRINGPREP],\n   and\
    \ then with Punycode [PUNYCODE].  Implementations of IDNA MUST\n   fully implement\
    \ Nameprep and Punycode; neither Nameprep nor Punycode\n   are optional.\n"
- title: 2. Terminology
  contents:
  - "2. Terminology\n   The key words \"MUST\", \"SHALL\", \"REQUIRED\", \"SHOULD\"\
    , \"RECOMMENDED\",\n   and \"MAY\" in this document are to be interpreted as described\
    \ in BCP\n   14, RFC 2119 [RFC2119].\n   A code point is an integer value associated\
    \ with a character in a\n   coded character set.\n   Unicode [UNICODE] is a coded\
    \ character set containing tens of\n   thousands of characters.  A single Unicode\
    \ code point is denoted by\n   \"U+\" followed by four to six hexadecimal digits,\
    \ while a range of\n   Unicode code points is denoted by two hexadecimal numbers\
    \ separated\n   by \"..\", with no prefixes.\n   ASCII means US-ASCII [USASCII],\
    \ a coded character set containing 128\n   characters associated with code points\
    \ in the range 0..7F.  Unicode\n   is an extension of ASCII: it includes all the\
    \ ASCII characters and\n   associates them with the same code points.\n   The\
    \ term \"LDH code points\" is defined in this document to mean the\n   code points\
    \ associated with ASCII letters, digits, and the hyphen-\n   minus; that is, U+002D,\
    \ 30..39, 41..5A, and 61..7A. \"LDH\" is an\n   abbreviation for \"letters, digits,\
    \ hyphen\".\n   [STD13] talks about \"domain names\" and \"host names\", but many\
    \ people\n   use the terms interchangeably.  Further, because [STD13] was not\n\
    \   terribly clear, many people who are sure they know the exact\n   definitions\
    \ of each of these terms disagree on the definitions.  In\n   this document the\
    \ term \"domain name\" is used in general.  This\n   document explicitly cites\
    \ [STD3] whenever referring to the host name\n   syntax restrictions defined therein.\n\
    \   A label is an individual part of a domain name.  Labels are usually\n   shown\
    \ separated by dots; for example, the domain name\n   \"www.example.com\" is composed\
    \ of three labels: \"www\", \"example\", and\n   \"com\".  (The zero-length root\
    \ label described in [STD13], which can\n   be explicit as in \"www.example.com.\"\
    \ or implicit as in\n   \"www.example.com\", is not considered a label in this\
    \ specification.)\n   IDNA extends the set of usable characters in labels that\
    \ are text.\n   For the rest of this document, the term \"label\" is shorthand\
    \ for\n   \"text label\", and \"every label\" means \"every text label\".\n  \
    \ An \"internationalized label\" is a label to which the ToASCII\n   operation\
    \ (see section 4) can be applied without failing (with the\n   UseSTD3ASCIIRules\
    \ flag unset).  This implies that every ASCII label\n   that satisfies the [STD13]\
    \ length restriction is an internationalized\n   label.  Therefore the term \"\
    internationalized label\" is a\n   generalization, embracing both old ASCII labels\
    \ and new non-ASCII\n   labels.  Although most Unicode characters can appear in\n\
    \   internationalized labels, ToASCII will fail for some input strings,\n   and\
    \ such strings are not valid internationalized labels.\n   An \"internationalized\
    \ domain name\" (IDN) is a domain name in which\n   every label is an internationalized\
    \ label.  This implies that every\n   ASCII domain name is an IDN (which implies\
    \ that it is possible for a\n   name to be an IDN without it containing any non-ASCII\
    \ characters).\n   This document does not attempt to define an \"internationalized\
    \ host\n   name\".  Just as has been the case with ASCII names, some DNS zone\n\
    \   administrators may impose restrictions, beyond those imposed by DNS\n   or\
    \ IDNA, on the characters or strings that may be registered as\n   labels in their\
    \ zones.  Such restrictions have no impact on the\n   syntax or semantics of DNS\
    \ protocol messages; a query for a name that\n   matches no records will yield\
    \ the same response regardless of the\n   reason why it is not in the zone.  Clients\
    \ issuing queries or\n   interpreting responses cannot be assumed to have any\
    \ knowledge of\n   zone-specific restrictions or conventions.\n   In IDNA, equivalence\
    \ of labels is defined in terms of the ToASCII\n   operation, which constructs\
    \ an ASCII form for a given label, whether\n   or not the label was already an\
    \ ASCII label.  Labels are defined to\n   be equivalent if and only if their ASCII\
    \ forms produced by ToASCII\n   match using a case-insensitive ASCII comparison.\
    \  ASCII labels\n   already have a notion of equivalence: upper case and lower\
    \ case are\n   considered equivalent.  The IDNA notion of equivalence is an\n\
    \   extension of that older notion.  Equivalent labels in IDNA are\n   treated\
    \ as alternate forms of the same label, just as \"foo\" and \"Foo\"\n   are treated\
    \ as alternate forms of the same label.\n   To allow internationalized labels\
    \ to be handled by existing\n   applications, IDNA uses an \"ACE label\" (ACE\
    \ stands for ASCII\n   Compatible Encoding).  An ACE label is an internationalized\
    \ label\n   that can be rendered in ASCII and is equivalent to an\n   internationalized\
    \ label that cannot be rendered in ASCII.  Given any\n   internationalized label\
    \ that cannot be rendered in ASCII, the ToASCII\n   operation will convert it\
    \ to an equivalent ACE label (whereas an\n   ASCII label will be left unaltered\
    \ by ToASCII).  ACE labels are\n   unsuitable for display to users.  The ToUnicode\
    \ operation will\n   convert any label to an equivalent non-ACE label.  In fact,\
    \ an ACE\n   label is formally defined to be any label that the ToUnicode\n  \
    \ operation would alter (whereas non-ACE labels are left unaltered by\n   ToUnicode).\
    \  Every ACE label begins with the ACE prefix specified in\n   section 5.  The\
    \ ToASCII and ToUnicode operations are specified in\n   section 4.\n   The \"\
    ACE prefix\" is defined in this document to be a string of ASCII\n   characters\
    \ that appears at the beginning of every ACE label.  It is\n   specified in section\
    \ 5.\n   A \"domain name slot\" is defined in this document to be a protocol\n\
    \   element or a function argument or a return value (and so on)\n   explicitly\
    \ designated for carrying a domain name.  Examples of domain\n   name slots include:\
    \ the QNAME field of a DNS query; the name argument\n   of the gethostbyname()\
    \ library function; the part of an email address\n   following the at-sign (@)\
    \ in the From: field of an email message\n   header; and the host portion of the\
    \ URI in the src attribute of an\n   HTML <IMG> tag.  General text that just happens\
    \ to contain a domain\n   name is not a domain name slot; for example, a domain\
    \ name appearing\n   in the plain text body of an email message is not occupying\
    \ a domain\n   name slot.\n   An \"IDN-aware domain name slot\" is defined in\
    \ this document to be a\n   domain name slot explicitly designated for carrying\
    \ an\n   internationalized domain name as defined in this document.  The\n   designation\
    \ may be static (for example, in the specification of the\n   protocol or interface)\
    \ or dynamic (for example, as a result of\n   negotiation in an interactive session).\n\
    \   An \"IDN-unaware domain name slot\" is defined in this document to be\n  \
    \ any domain name slot that is not an IDN-aware domain name slot.\n   Obviously,\
    \ this includes any domain name slot whose specification\n   predates IDNA.\n"
- title: 3. Requirements and applicability
  contents:
  - '3. Requirements and applicability

    '
- title: 3.1 Requirements
  contents:
  - "3.1 Requirements\n   IDNA conformance means adherence to the following four requirements:\n\
    \   1) Whenever dots are used as label separators, the following\n      characters\
    \ MUST be recognized as dots: U+002E (full stop), U+3002\n      (ideographic full\
    \ stop), U+FF0E (fullwidth full stop), U+FF61\n      (halfwidth ideographic full\
    \ stop).\n   2) Whenever a domain name is put into an IDN-unaware domain name\
    \ slot\n      (see section 2), it MUST contain only ASCII characters.  Given an\n\
    \      internationalized domain name (IDN), an equivalent domain name\n      satisfying\
    \ this requirement can be obtained by applying the\n      ToASCII operation (see\
    \ section 4) to each label and, if dots are\n      used as label separators, changing\
    \ all the label separators to\n      U+002E.\n   3) ACE labels obtained from domain\
    \ name slots SHOULD be hidden from\n      users when it is known that the environment\
    \ can handle the non-ACE\n      form, except when the ACE form is explicitly requested.\
    \  When it\n      is not known whether or not the environment can handle the non-ACE\n\
    \      form, the application MAY use the non-ACE form (which might fail,\n   \
    \   such as by not being displayed properly), or it MAY use the ACE\n      form\
    \ (which will look unintelligle to the user).  Given an\n      internationalized\
    \ domain name, an equivalent domain name\n      containing no ACE labels can be\
    \ obtained by applying the ToUnicode\n      operation (see section 4) to each\
    \ label.  When requirements 2 and\n      3 both apply, requirement 2 takes precedence.\n\
    \   4) Whenever two labels are compared, they MUST be considered to match\n  \
    \    if and only if they are equivalent, that is, their ASCII forms\n      (obtained\
    \ by applying ToASCII) match using a case-insensitive\n      ASCII comparison.\
    \  Whenever two names are compared, they MUST be\n      considered to match if\
    \ and only if their corresponding labels\n      match, regardless of whether the\
    \ names use the same forms of label\n      separators.\n"
- title: 3.2 Applicability
  contents:
  - "3.2 Applicability\n   IDNA is applicable to all domain names in all domain name\
    \ slots\n   except where it is explicitly excluded.\n   This implies that IDNA\
    \ is applicable to many protocols that predate\n   IDNA.  Note that IDNs occupying\
    \ domain name slots in those protocols\n   MUST be in ASCII form (see section\
    \ 3.1, requirement 2).\n"
- title: 3.2.1. DNS resource records
  contents:
  - "3.2.1. DNS resource records\n   IDNA does not apply to domain names in the NAME\
    \ and RDATA fields of\n   DNS resource records whose CLASS is not IN.  This exclusion\
    \ applies\n   to every non-IN class, present and future, except where future\n\
    \   standards override this exclusion by explicitly inviting the use of\n   IDNA.\n\
    \   There are currently no other exclusions on the applicability of IDNA\n   to\
    \ DNS resource records; it depends entirely on the CLASS, and not on\n   the TYPE.\
    \  This will remain true, even as new types are defined,\n   unless there is a\
    \ compelling reason for a new type to complicate\n   matters by imposing type-specific\
    \ rules.\n"
- title: 3.2.2. Non-domain-name data types stored in domain names
  contents:
  - "3.2.2. Non-domain-name data types stored in domain names\n   Although IDNA enables\
    \ the representation of non-ASCII characters in\n   domain names, that does not\
    \ imply that IDNA enables the\n   representation of non-ASCII characters in other\
    \ data types that are\n   stored in domain names.  For example, an email address\
    \ local part is\n   sometimes stored in a domain label (hostmaster@example.com\
    \ would be\n   represented as hostmaster.example.com in the RDATA field of an\
    \ SOA\n   record).  IDNA does not update the existing email standards, which\n\
    \   allow only ASCII characters in local parts.  Therefore, unless the\n   email\
    \ standards are revised to invite the use of IDNA for local\n   parts, a domain\
    \ label that holds the local part of an email address\n   SHOULD NOT begin with\
    \ the ACE prefix, and even if it does, it is to\n   be interpreted literally as\
    \ a local part that happens to begin with\n   the ACE prefix.\n"
- title: 4. Conversion operations
  contents:
  - "4. Conversion operations\n   An application converts a domain name put into an\
    \ IDN-unaware slot or\n   displayed to a user.  This section specifies the steps\
    \ to perform in\n   the conversion, and the ToASCII and ToUnicode operations.\n\
    \   The input to ToASCII or ToUnicode is a single label that is a\n   sequence\
    \ of Unicode code points (remember that all ASCII code points\n   are also Unicode\
    \ code points).  If a domain name is represented using\n   a character set other\
    \ than Unicode or US-ASCII, it will first need to\n   be transcoded to Unicode.\n\
    \   Starting from a whole domain name, the steps that an application\n   takes\
    \ to do the conversions are:\n   1) Decide whether the domain name is a \"stored\
    \ string\" or a \"query\n      string\" as described in [STRINGPREP].  If this\
    \ conversion follows\n      the \"queries\" rule from [STRINGPREP], set the flag\
    \ called\n      \"AllowUnassigned\".\n   2) Split the domain name into individual\
    \ labels as described in\n      section 3.1.  The labels do not include the separator.\n\
    \   3) For each label, decide whether or not to enforce the restrictions\n   \
    \   on ASCII characters in host names [STD3].  (Applications already\n      faced\
    \ this choice before the introduction of IDNA, and can\n      continue to make\
    \ the decision the same way they always have; IDNA\n      makes no new recommendations\
    \ regarding this choice.)  If the\n      restrictions are to be enforced, set\
    \ the flag called\n      \"UseSTD3ASCIIRules\" for that label.\n   4) Process\
    \ each label with either the ToASCII or the ToUnicode\n      operation as appropriate.\
    \  Typically, you use the ToASCII\n      operation if you are about to put the\
    \ name into an IDN-unaware\n      slot, and you use the ToUnicode operation if\
    \ you are displaying\n      the name to a user; section 3.1 gives greater detail\
    \ on the\n      applicable requirements.\n   5) If ToASCII was applied in step\
    \ 4 and dots are used as label\n      separators, change all the label separators\
    \ to U+002E (full stop).\n   The following two subsections define the ToASCII\
    \ and ToUnicode\n   operations that are used in step 4.\n   This description of\
    \ the protocol uses specific procedure names, names\n   of flags, and so on, in\
    \ order to facilitate the specification of the\n   protocol.  These names, as\
    \ well as the actual steps of the\n   procedures, are not required of an implementation.\
    \  In fact, any\n   implementation which has the same external behavior as specified\
    \ in\n   this document conforms to this specification.\n"
- title: 4.1 ToASCII
  contents:
  - "4.1 ToASCII\n   The ToASCII operation takes a sequence of Unicode code points\
    \ that\n   make up one label and transforms it into a sequence of code points\
    \ in\n   the ASCII range (0..7F).  If ToASCII succeeds, the original sequence\n\
    \   and the resulting sequence are equivalent labels.\n   It is important to note\
    \ that the ToASCII operation can fail.  ToASCII\n   fails if any step of it fails.\
    \  If any step of the ToASCII operation\n   fails on any label in a domain name,\
    \ that domain name MUST NOT be\n   used as an internationalized domain name. \
    \ The method for dealing\n   with this failure is application-specific.\n   The\
    \ inputs to ToASCII are a sequence of code points, the\n   AllowUnassigned flag,\
    \ and the UseSTD3ASCIIRules flag.  The output of\n   ToASCII is either a sequence\
    \ of ASCII code points or a failure\n   condition.\n   ToASCII never alters a\
    \ sequence of code points that are all in the\n   ASCII range to begin with (although\
    \ it could fail).  Applying the\n   ToASCII operation multiple times has exactly\
    \ the same effect as\n   applying it just once.\n   ToASCII consists of the following\
    \ steps:\n   1. If the sequence contains any code points outside the ASCII range\n\
    \      (0..7F) then proceed to step 2, otherwise skip to step 3.\n   2. Perform\
    \ the steps specified in [NAMEPREP] and fail if there is an\n      error.  The\
    \ AllowUnassigned flag is used in [NAMEPREP].\n   3. If the UseSTD3ASCIIRules\
    \ flag is set, then perform these checks:\n     (a) Verify the absence of non-LDH\
    \ ASCII code points; that is, the\n         absence of 0..2C, 2E..2F, 3A..40,\
    \ 5B..60, and 7B..7F.\n     (b) Verify the absence of leading and trailing hyphen-minus;\
    \ that\n         is, the absence of U+002D at the beginning and end of the\n \
    \        sequence.\n   4. If the sequence contains any code points outside the\
    \ ASCII range\n      (0..7F) then proceed to step 5, otherwise skip to step 8.\n\
    \   5. Verify that the sequence does NOT begin with the ACE prefix.\n   6. Encode\
    \ the sequence using the encoding algorithm in [PUNYCODE] and\n      fail if there\
    \ is an error.\n   7. Prepend the ACE prefix.\n   8. Verify that the number of\
    \ code points is in the range 1 to 63\n      inclusive.\n"
- title: 4.2 ToUnicode
  contents:
  - "4.2 ToUnicode\n   The ToUnicode operation takes a sequence of Unicode code points\
    \ that\n   make up one label and returns a sequence of Unicode code points.  If\n\
    \   the input sequence is a label in ACE form, then the result is an\n   equivalent\
    \ internationalized label that is not in ACE form, otherwise\n   the original\
    \ sequence is returned unaltered.\n   ToUnicode never fails.  If any step fails,\
    \ then the original input\n   sequence is returned immediately in that step.\n\
    \   The ToUnicode output never contains more code points than its input.\n   Note\
    \ that the number of octets needed to represent a sequence of code\n   points\
    \ depends on the particular character encoding used.\n   The inputs to ToUnicode\
    \ are a sequence of code points, the\n   AllowUnassigned flag, and the UseSTD3ASCIIRules\
    \ flag.  The output of\n   ToUnicode is always a sequence of Unicode code points.\n\
    \   1. If all code points in the sequence are in the ASCII range (0..7F)\n   \
    \   then skip to step 3.\n   2. Perform the steps specified in [NAMEPREP] and\
    \ fail if there is an\n      error.  (If step 3 of ToASCII is also performed here,\
    \ it will not\n      affect the overall behavior of ToUnicode, but it is not\n\
    \      necessary.)  The AllowUnassigned flag is used in [NAMEPREP].\n   3. Verify\
    \ that the sequence begins with the ACE prefix, and save a\n      copy of the\
    \ sequence.\n   4. Remove the ACE prefix.\n   5. Decode the sequence using the\
    \ decoding algorithm in [PUNYCODE] and\n      fail if there is an error.  Save\
    \ a copy of the result of this\n      step.\n   6. Apply ToASCII.\n   7. Verify\
    \ that the result of step 6 matches the saved copy from step\n      3, using a\
    \ case-insensitive ASCII comparison.\n   8. Return the saved copy from step 5.\n"
- title: 5. ACE prefix
  contents:
  - "5. ACE prefix\n   The ACE prefix, used in the conversion operations (section\
    \ 4), is two\n   alphanumeric ASCII characters followed by two hyphen-minuses.\
    \  It\n   cannot be any of the prefixes already used in earlier documents,\n \
    \  which includes the following: \"bl--\", \"bq--\", \"dq--\", \"lq--\", \"mq--\"\
    ,\n   \"ra--\", \"wq--\" and \"zq--\".  The ToASCII and ToUnicode operations MUST\n\
    \   recognize the ACE prefix in a case-insensitive manner.\n   The ACE prefix\
    \ for IDNA is \"xn--\" or any capitalization thereof.\n   This means that an ACE\
    \ label might be \"xn--de-jg4avhby1noc0d\", where\n   \"de-jg4avhby1noc0d\" is\
    \ the part of the ACE label that is generated by\n   the encoding steps in [PUNYCODE].\n\
    \   While all ACE labels begin with the ACE prefix, not all labels\n   beginning\
    \ with the ACE prefix are necessarily ACE labels.  Non-ACE\n   labels that begin\
    \ with the ACE prefix will confuse users and SHOULD\n   NOT be allowed in DNS\
    \ zones.\n"
- title: 6. Implications for typical applications using DNS
  contents:
  - "6. Implications for typical applications using DNS\n   In IDNA, applications\
    \ perform the processing needed to input\n   internationalized domain names from\
    \ users, display internationalized\n   domain names to users, and process the\
    \ inputs and outputs from DNS\n   and other protocols that carry domain names.\n\
    \   The components and interfaces between them can be represented\n   pictorially\
    \ as:\n                    +------+\n                    | User |\n          \
    \          +------+\n                       ^\n                       | Input\
    \ and display: local interface methods\n                       | (pen, keyboard,\
    \ glowing phosphorus, ...)\n   +-------------------|-------------------------------+\n\
    \   |                   v                               |\n   |          +-----------------------------+\
    \          |\n   |          |        Application          |          |\n   | \
    \         |   (ToASCII and ToUnicode    |          |\n   |          |      operations\
    \ may be      |          |\n   |          |        called here)         |    \
    \      |\n   |          +-----------------------------+          |\n   |     \
    \              ^        ^                      | End system\n   |            \
    \       |        |                      |\n   | Call to resolver: |        | Application-specific\
    \ |\n   |              ACE  |        | protocol:            |\n   |          \
    \         v        | ACE unless the       |\n   |           +----------+     |\
    \ protocol is updated  |\n   |           | Resolver |     | to handle other  \
    \    |\n   |           +----------+     | encodings            |\n   |       \
    \          ^          |                      |\n   +-----------------|----------|----------------------+\n\
    \       DNS protocol: |          |\n                 ACE |          |\n      \
    \               v          v\n          +-------------+    +---------------------+\n\
    \          | DNS servers |    | Application servers |\n          +-------------+\
    \    +---------------------+\n   The box labeled \"Application\" is where the\
    \ application splits a\n   domain name into labels, sets the appropriate flags,\
    \ and performs the\n   ToASCII and ToUnicode operations.  This is described in\
    \ section 4.\n"
- title: 6.1 Entry and display in applications
  contents:
  - "6.1 Entry and display in applications\n   Applications can accept domain names\
    \ using any character set or sets\n   desired by the application developer, and\
    \ can display domain names in\n   any charset.  That is, the IDNA protocol does\
    \ not affect the\n   interface between users and applications.\n   An IDNA-aware\
    \ application can accept and display internationalized\n   domain names in two\
    \ formats: the internationalized character set(s)\n   supported by the application,\
    \ and as an ACE label.  ACE labels that\n   are displayed or input MUST always\
    \ include the ACE prefix.\n   Applications MAY allow input and display of ACE\
    \ labels, but are not\n   encouraged to do so except as an interface for special\
    \ purposes,\n   possibly for debugging, or to cope with display limitations as\n\
    \   described in section 6.4..  ACE encoding is opaque and ugly, and\n   should\
    \ thus only be exposed to users who absolutely need it.  Because\n   name labels\
    \ encoded as ACE name labels can be rendered either as the\n   encoded ASCII characters\
    \ or the proper decoded characters, the\n   application MAY have an option for\
    \ the user to select the preferred\n   method of display; if it does, rendering\
    \ the ACE SHOULD NOT be the\n   default.\n   Domain names are often stored and\
    \ transported in many places.  For\n   example, they are part of documents such\
    \ as mail messages and web\n   pages.  They are transported in many parts of many\
    \ protocols, such as\n   both the control commands and the RFC 2822 body parts\
    \ of SMTP, and\n   the headers and the body content in HTTP.  It is important\
    \ to\n   remember that domain names appear both in domain name slots and in\n\
    \   the content that is passed over protocols.\n   In protocols and document formats\
    \ that define how to handle\n   specification or negotiation of charsets, labels\
    \ can be encoded in\n   any charset allowed by the protocol or document format.\
    \  If a\n   protocol or document format only allows one charset, the labels MUST\n\
    \   be given in that charset.\n   In any place where a protocol or document format\
    \ allows transmission\n   of the characters in internationalized labels, internationalized\n\
    \   labels SHOULD be transmitted using whatever character encoding and\n   escape\
    \ mechanism that the protocol or document format uses at that\n   place.\n   All\
    \ protocols that use domain name slots already have the capacity\n   for handling\
    \ domain names in the ASCII charset.  Thus, ACE labels\n   (internationalized\
    \ labels that have been processed with the ToASCII\n   operation) can inherently\
    \ be handled by those protocols.\n"
- title: 6.2 Applications and resolver libraries
  contents:
  - "6.2 Applications and resolver libraries\n   Applications normally use functions\
    \ in the operating system when they\n   resolve DNS queries.  Those functions\
    \ in the operating system are\n   often called \"the resolver library\", and the\
    \ applications communicate\n   with the resolver libraries through a programming\
    \ interface (API).\n   Because these resolver libraries today expect only domain\
    \ names in\n   ASCII, applications MUST prepare labels that are passed to the\n\
    \   resolver library using the ToASCII operation.  Labels received from\n   the\
    \ resolver library contain only ASCII characters; internationalized\n   labels\
    \ that cannot be represented directly in ASCII use the ACE form.\n   ACE labels\
    \ always include the ACE prefix.\n   An operating system might have a set of libraries\
    \ for performing the\n   ToASCII operation.  The input to such a library might\
    \ be in one or\n   more charsets that are used in applications (UTF-8 and UTF-16\
    \ are\n   likely candidates for almost any operating system, and script-\n   specific\
    \ charsets are likely for localized operating systems).\n   IDNA-aware applications\
    \ MUST be able to work with both non-\n   internationalized labels (those that\
    \ conform to [STD13] and [STD3])\n   and internationalized labels.\n   It is expected\
    \ that new versions of the resolver libraries in the\n   future will be able to\
    \ accept domain names in other charsets than\n   ASCII, and application developers\
    \ might one day pass not only domain\n   names in Unicode, but also in local script\
    \ to a new API for the\n   resolver libraries in the operating system.  Thus the\
    \ ToASCII and\n   ToUnicode operations might be performed inside these new versions\
    \ of\n   the resolver libraries.\n   Domain names passed to resolvers or put into\
    \ the question section of\n   DNS requests follow the rules for \"queries\" from\
    \ [STRINGPREP].\n"
- title: 6.3 DNS servers
  contents:
  - "6.3 DNS servers\n   Domain names stored in zones follow the rules for \"stored\
    \ strings\"\n   from [STRINGPREP].\n   For internationalized labels that cannot\
    \ be represented directly in\n   ASCII, DNS servers MUST use the ACE form produced\
    \ by the ToASCII\n   operation.  All IDNs served by DNS servers MUST contain only\
    \ ASCII\n   characters.\n   If a signaling system which makes negotiation possible\
    \ between old\n   and new DNS clients and servers is standardized in the future,\
    \ the\n   encoding of the query in the DNS protocol itself can be changed from\n\
    \   ACE to something else, such as UTF-8.  The question whether or not\n   this\
    \ should be used is, however, a separate problem and is not\n   discussed in this\
    \ memo.\n"
- title: 6.4 Avoiding exposing users to the raw ACE encoding
  contents:
  - "6.4 Avoiding exposing users to the raw ACE encoding\n   Any application that\
    \ might show the user a domain name obtained from\n   a domain name slot, such\
    \ as from gethostbyaddr or part of a mail\n   header, will need to be updated\
    \ if it is to prevent users from seeing\n   the ACE.\n   If an application decodes\
    \ an ACE name using ToUnicode but cannot show\n   all of the characters in the\
    \ decoded name, such as if the name\n   contains characters that the output system\
    \ cannot display, the\n   application SHOULD show the name in ACE format (which\
    \ always includes\n   the ACE prefix) instead of displaying the name with the\
    \ replacement\n   character (U+FFFD).  This is to make it easier for the user\
    \ to\n   transfer the name correctly to other programs.  Programs that by\n  \
    \ default show the ACE form when they cannot show all the characters in\n   a\
    \ name label SHOULD also have a mechanism to show the name that is\n   produced\
    \ by the ToUnicode operation with as many characters as\n   possible and replacement\
    \ characters in the positions where characters\n   cannot be displayed.\n   The\
    \ ToUnicode operation does not alter labels that are not valid ACE\n   labels,\
    \ even if they begin with the ACE prefix.  After ToUnicode has\n   been applied,\
    \ if a label still begins with the ACE prefix, then it is\n   not a valid ACE\
    \ label, and is not equivalent to any of the\n   intermediate Unicode strings\
    \ constructed by ToUnicode.\n"
- title: 6.5  DNSSEC authentication of IDN domain names
  contents:
  - "6.5  DNSSEC authentication of IDN domain names\n   DNS Security [RFC2535] is\
    \ a method for supplying cryptographic\n   verification information along with\
    \ DNS messages.  Public Key\n   Cryptography is used in conjunction with digital\
    \ signatures to\n   provide a means for a requester of domain information to authenticate\n\
    \   the source of the data.  This ensures that it can be traced back to a\n  \
    \ trusted source, either directly, or via a chain of trust linking the\n   source\
    \ of the information to the top of the DNS hierarchy.\n   IDNA specifies that\
    \ all internationalized domain names served by DNS\n   servers that cannot be\
    \ represented directly in ASCII must use the ACE\n   form produced by the ToASCII\
    \ operation.  This operation must be\n   performed prior to a zone being signed\
    \ by the private key for that\n   zone.  Because of this ordering, it is important\
    \ to recognize that\n   DNSSEC authenticates the ASCII domain name, not the Unicode\
    \ form or\n   the mapping between the Unicode form and the ASCII form.  In the\n\
    \   presence of DNSSEC, this is the name that MUST be signed in the zone\n   and\
    \ MUST be validated against.\n   One consequence of this for sites deploying IDNA\
    \ in the presence of\n   DNSSEC is that any special purpose proxies or forwarders\
    \ used to\n   transform user input into IDNs must be earlier in the resolution\
    \ flow\n   than DNSSEC authenticating nameservers for DNSSEC to work.\n"
- title: 7. Name server considerations
  contents:
  - "7. Name server considerations\n   Existing DNS servers do not know the IDNA rules\
    \ for handling non-\n   ASCII forms of IDNs, and therefore need to be shielded\
    \ from them.\n   All existing channels through which names can enter a DNS server\n\
    \   database (for example, master files [STD13] and DNS update messages\n   [RFC2136])\
    \ are IDN-unaware because they predate IDNA, and therefore\n   requirement 2 of\
    \ section 3.1 of this document provides the needed\n   shielding, by ensuring\
    \ that internationalized domain names entering\n   DNS server databases through\
    \ such channels have already been\n   converted to their equivalent ASCII forms.\n\
    \   It is imperative that there be only one ASCII encoding for a\n   particular\
    \ domain name.  Because of the design of the ToASCII and\n   ToUnicode operations,\
    \ there are no ACE labels that decode to ASCII\n   labels, and therefore name\
    \ servers cannot contain multiple ASCII\n   encodings of the same domain name.\n\
    \   [RFC2181] explicitly allows domain labels to contain octets beyond\n   the\
    \ ASCII range (0..7F), and this document does not change that.\n   Note, however,\
    \ that there is no defined interpretation of octets\n   80..FF as characters.\
    \  If labels containing these octets are returned\n   to applications, unpredictable\
    \ behavior could result.  The ASCII form\n   defined by ToASCII is the only standard\
    \ representation for\n   internationalized labels in the current DNS protocol.\n"
- title: 8. Root server considerations
  contents:
  - "8. Root server considerations\n   IDNs are likely to be somewhat longer than\
    \ current domain names, so\n   the bandwidth needed by the root servers is likely\
    \ to go up by a\n   small amount.  Also, queries and responses for IDNs will probably\
    \ be\n   somewhat longer than typical queries today, so more queries and\n   responses\
    \ may be forced to go to TCP instead of UDP.\n"
- title: 9. References
  contents:
  - '9. References

    '
- title: 9.1 Normative References
  contents:
  - "9.1 Normative References\n   [RFC2119]    Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n                Requirement Levels\", BCP 14, RFC 2119, March\
    \ 1997.\n   [STRINGPREP] Hoffman, P. and M. Blanchet, \"Preparation of\n     \
    \           Internationalized Strings (\"stringprep\")\", RFC 3454,\n        \
    \        December 2002.\n   [NAMEPREP]   Hoffman, P. and M. Blanchet, \"Nameprep:\
    \ A Stringprep\n                Profile for Internationalized Domain Names (IDN)\"\
    , RFC\n                3491, March 2003.\n   [PUNYCODE]   Costello, A., \"Punycode:\
    \ A Bootstring encoding of\n                Unicode for use with Internationalized\
    \ Domain Names in\n                Applications (IDNA)\", RFC 3492, March 2003.\n\
    \   [STD3]       Braden, R., \"Requirements for Internet Hosts --\n          \
    \      Communication Layers\", STD 3, RFC 1122, and\n                \"Requirements\
    \ for Internet Hosts -- Application and\n                Support\", STD 3, RFC\
    \ 1123, October 1989.\n   [STD13]      Mockapetris, P., \"Domain names - concepts\
    \ and\n                facilities\", STD 13, RFC 1034 and \"Domain names -\n \
    \               implementation and specification\", STD 13, RFC 1035,\n      \
    \          November 1987.\n"
- title: 9.2 Informative References
  contents:
  - "9.2 Informative References\n   [RFC2535]    Eastlake, D., \"Domain Name System\
    \ Security Extensions\",\n                RFC 2535, March 1999.\n   [RFC2181]\
    \    Elz, R. and R. Bush, \"Clarifications to the DNS\n                Specification\"\
    , RFC 2181, July 1997.\n   [UAX9]       Unicode Standard Annex #9, The Bidirectional\
    \ Algorithm,\n                <http://www.unicode.org/unicode/reports/tr9/>.\n\
    \   [UNICODE]    The Unicode Consortium. The Unicode Standard, Version\n     \
    \           3.2.0 is defined by The Unicode Standard, Version 3.0\n          \
    \      (Reading, MA, Addison-Wesley, 2000. ISBN 0-201-61633-5),\n            \
    \    as amended by the Unicode Standard Annex #27: Unicode\n                3.1\
    \ (http://www.unicode.org/reports/tr27/) and by the\n                Unicode Standard\
    \ Annex #28: Unicode 3.2\n                (http://www.unicode.org/reports/tr28/).\n\
    \   [USASCII]    Cerf, V., \"ASCII format for Network Interchange\", RFC\n   \
    \             20, October 1969.\n"
- title: 10. Security Considerations
  contents:
  - "10. Security Considerations\n   Security on the Internet partly relies on the\
    \ DNS.  Thus, any change\n   to the characteristics of the DNS can change the\
    \ security of much of\n   the Internet.\n   This memo describes an algorithm which\
    \ encodes characters that are\n   not valid according to STD3 and STD13 into octet\
    \ values that are\n   valid.  No security issues such as string length increases\
    \ or new\n   allowed values are introduced by the encoding process or the use\
    \ of\n   these encoded values, apart from those introduced by the ACE encoding\n\
    \   itself.\n   Domain names are used by users to identify and connect to Internet\n\
    \   servers.  The security of the Internet is compromised if a user\n   entering\
    \ a single internationalized name is connected to different\n   servers based\
    \ on different interpretations of the internationalized\n   domain name.\n   When\
    \ systems use local character sets other than ASCII and Unicode,\n   this specification\
    \ leaves the the problem of transcoding between the\n   local character set and\
    \ Unicode up to the application.  If different\n   applications (or different\
    \ versions of one application) implement\n   different transcoding rules, they\
    \ could interpret the same name\n   differently and contact different servers.\
    \  This problem is not\n   solved by security protocols like TLS that do not take\
    \ local\n   character sets into account.\n   Because this document normatively\
    \ refers to [NAMEPREP], [PUNYCODE],\n   and [STRINGPREP], it includes the security\
    \ considerations from those\n   documents as well.\n   If or when this specification\
    \ is updated to use a more recent Unicode\n   normalization table, the new normalization\
    \ table will need to be\n   compared with the old to spot backwards incompatible\
    \ changes.  If\n   there are such changes, they will need to be handled somehow,\
    \ or\n   there will be security as well as operational implications.  Methods\n\
    \   to handle the conflicts could include keeping the old normalization,\n   or\
    \ taking care of the conflicting characters by operational means, or\n   some\
    \ other method.\n   Implementations MUST NOT use more recent normalization tables\
    \ than\n   the one referenced from this document, even though more recent tables\n\
    \   may be provided by operating systems.  If an application is unsure of\n  \
    \ which version of the normalization tables are in the operating\n   system, the\
    \ application needs to include the normalization tables\n   itself.  Using normalization\
    \ tables other than the one referenced\n   from this specification could have\
    \ security and operational\n   implications.\n   To help prevent confusion between\
    \ characters that are visually\n   similar, it is suggested that implementations\
    \ provide visual\n   indications where a domain name contains multiple scripts.\
    \  Such\n   mechanisms can also be used to show when a name contains a mixture\
    \ of\n   simplified and traditional Chinese characters, or to distinguish zero\n\
    \   and one from O and l.  DNS zone adminstrators may impose restrictions\n  \
    \ (subject to the limitations in section 2) that try to minimize\n   homographs.\n\
    \   Domain names (or portions of them) are sometimes compared against a\n   set\
    \ of privileged or anti-privileged domains.  In such situations it\n   is especially\
    \ important that the comparisons be done properly, as\n   specified in section\
    \ 3.1 requirement 4.  For labels already in ASCII\n   form, the proper comparison\
    \ reduces to the same case-insensitive\n   ASCII comparison that has always been\
    \ used for ASCII labels.\n   The introduction of IDNA means that any existing\
    \ labels that start\n   with the ACE prefix and would be altered by ToUnicode\
    \ will\n   automatically be ACE labels, and will be considered equivalent to\n\
    \   non-ASCII labels, whether or not that was the intent of the zone\n   adminstrator\
    \ or registrant.\n"
- title: 11. IANA Considerations
  contents:
  - "11. IANA Considerations\n   IANA has assigned the ACE prefix in consultation\
    \ with the IESG.\n"
- title: 12. Authors' Addresses
  contents:
  - "12. Authors' Addresses\n   Patrik Faltstrom\n   Cisco Systems\n   Arstaangsvagen\
    \ 31 J\n   S-117 43 Stockholm  Sweden\n   EMail: paf@cisco.com\n   Paul Hoffman\n\
    \   Internet Mail Consortium and VPN Consortium\n   127 Segre Place\n   Santa\
    \ Cruz, CA  95060  USA\n   EMail: phoffman@imc.org\n   Adam M. Costello\n   University\
    \ of California, Berkeley\n   URL: http://www.nicemice.net/amc/\n"
- title: 13. Full Copyright Statement
  contents:
  - "13. Full Copyright Statement\n   Copyright (C) The Internet Society (2003). \
    \ All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
