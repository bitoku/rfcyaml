- title: __initial_text__
  contents:
  - "         Protocol Independent Multicast - Sparse Mode (PIM-SM):\n           \
    \         Protocol Specification (Revised)\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2006).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document specifies Protocol Independent Multicast - Sparse\
    \ Mode\n   (PIM-SM).  PIM-SM is a multicast routing protocol that can use the\n\
    \   underlying unicast routing information base or a separate multicast-\n   capable\
    \ routing information base.  It builds unidirectional shared\n   trees rooted\
    \ at a Rendezvous Point (RP) per group, and optionally\n   creates shortest-path\
    \ trees per source.\n   This document obsoletes RFC 2362, an Experimental version\
    \ of PIM-SM.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................5\n\
    \   2. Terminology .....................................................5\n  \
    \    2.1. Definitions ................................................5\n    \
    \  2.2. Pseudocode Notation ........................................7\n   3. PIM-SM\
    \ Protocol Overview ........................................7\n      3.1. Phase\
    \ One: RP Tree .........................................8\n      3.2. Phase Two:\
    \ Register-Stop ...................................8\n      3.3. Phase Three:\
    \ Shortest-Path Tree ............................9\n      3.4. Source-Specific\
    \ Joins .....................................10\n      3.5. Source-Specific Prunes\
    \ ....................................11\n      3.6. Multi-Access Transit LANs\
    \ .................................11\n      3.7. RP Discovery ..............................................12\n\
    \   4. Protocol Specification .........................................12\n  \
    \    4.1. PIM Protocol State ........................................13\n    \
    \       4.1.1. General Purpose State ..............................14\n      \
    \     4.1.2. (*,*,RP) State .....................................15\n        \
    \   4.1.3. (*,G) State ........................................16\n          \
    \ 4.1.4. (S,G) State ........................................17\n           4.1.5.\
    \ (S,G,rpt) State ....................................20\n           4.1.6. State\
    \ Summarization Macros .........................21\n      4.2. Data Packet Forwarding\
    \ Rules ..............................26\n           4.2.1. Last-Hop Switchover\
    \ to the SPT .....................28\n           4.2.2. Setting and Clearing the\
    \ (S,G) SPTbit ..............29\n      4.3. Designated Routers (DR) and Hello\
    \ Messages ................30\n           4.3.1. Sending Hello Messages .............................30\n\
    \           4.3.2. DR Election ........................................32\n  \
    \         4.3.3. Reducing Prune Propagation Delay on LANs ...........34\n    \
    \       4.3.4. Maintaining Secondary Address Lists ................37\n      4.4.\
    \ PIM Register Messages .....................................38\n           4.4.1.\
    \ Sending Register Messages from the DR ..............38\n           4.4.2. Receiving\
    \ Register Messages at the RP ..............43\n      4.5. PIM Join/Prune Messages\
    \ ...................................45\n           4.5.1. Receiving (*,*,RP)\
    \ Join/Prune Messages .............45\n           4.5.2. Receiving (*,G) Join/Prune\
    \ Messages ................49\n           4.5.3. Receiving (S,G) Join/Prune Messages\
    \ ................53\n           4.5.4. Receiving (S,G,rpt) Join/Prune Messages\
    \ ............56\n           4.5.5. Sending (*,*,RP) Join/Prune Messages ...............62\n\
    \           4.5.6. Sending (*,G) Join/Prune Messages ..................66\n  \
    \         4.5.7. Sending (S,G) Join/Prune Messages ..................71\n    \
    \       4.5.8. (S,G,rpt) Periodic Messages ........................76\n      \
    \     4.5.9. State Machine for (S,G,rpt) Triggered Messages .....77\n        \
    \   4.5.10. Background: (*,*,RP) and (S,G,rpt) Interaction ....82\n      4.6.\
    \ PIM Assert Messages .......................................83\n           4.6.1.\
    \ (S,G) Assert Message State Machine .................83\n           4.6.2. (*,G)\
    \ Assert Message State Machine .................91\n           4.6.3. Assert Metrics\
    \ .....................................98\n           4.6.4. AssertCancel Messages\
    \ ..............................99\n           4.6.5. Assert State Macros ...............................100\n\
    \      4.7. PIM Bootstrap and RP Discovery ...........................103\n  \
    \         4.7.1. Group-to-RP Mapping ...............................104\n    \
    \       4.7.2. Hash Function .....................................105\n      4.8.\
    \ Source-Specific Multicast ................................106\n           4.8.1.\
    \ Protocol Modifications for SSM Destination\n                  Addresses .........................................106\n\
    \           4.8.2. PIM-SSM-Only Routers ..............................107\n  \
    \    4.9. PIM Packet Formats .......................................108\n    \
    \       4.9.1. Encoded Source and Group Address Formats ..........110\n      \
    \     4.9.2. Hello Message Format ..............................113\n        \
    \   4.9.3. Register Message Format ...........................116\n          \
    \ 4.9.4. Register-Stop Message Format ......................119\n           4.9.5.\
    \ Join/Prune Message Format .........................119\n                  4.9.5.1.\
    \ Group Set Source List Rules ..............122\n                  4.9.5.2. Group\
    \ Set Fragmentation ..................126\n           4.9.6. Assert Message Format\
    \ .............................126\n      4.10. PIM Timers ..............................................128\n\
    \      4.11. Timer Values ............................................129\n  \
    \ 5. IANA Considerations ...........................................135\n    \
    \  5.1. PIM Address Family .......................................135\n      5.2.\
    \ PIM Hello Options ........................................136\n   6. Security\
    \ Considerations .......................................136\n      6.1. Attacks\
    \ Based on Forged Messages .........................136\n           6.1.1. Forged\
    \ Link-Local Messages ........................136\n           6.1.2. Forged Unicast\
    \ Messages ...........................137\n      6.2. Non-Cryptographic Authentication\
    \ Mechanisms ..............137\n      6.3. Authentication Using IPsec ...............................138\n\
    \           6.3.1. Protecting Link-Local Multicast Messages ..........138\n  \
    \         6.3.2. Protecting Unicast Messages .......................139\n    \
    \              6.3.2.1. Register Messages ........................139\n      \
    \            6.3.2.2. Register-Stop Messages ...................139\n      6.4.\
    \ Denial-of-Service Attacks ................................140\n   7. Acknowledgements\
    \ ..............................................140\n   8. Normative References\
    \ ..........................................141\n   9. Informative References\
    \ ........................................141\n   Appendix A. PIM Multicast Border\
    \ Router Behavior .................143\n      A.1. Sources External to the PIM-SM\
    \ Domain ....................143\n      A.2.  Sources Internal to the PIM-SM Domain\
    \ ...................144\n   Appendix B. Index ................................................146\n"
- title: List of Figures
  contents:
  - "List of Figures\n   Figure 1. Per-(S,G) register state machine at a DR ................38\n\
    \   Figure 2. Downstream per-interface (*,*,RP) state machine .........46\n  \
    \ Figure 3. Downstream per-interface (*,G) state machine ............50\n   Figure\
    \ 4. Downstream per-interface (S,G) state machine ............53\n   Figure 5.\
    \ Downstream per-interface (S,G,rpt) state machine ........57\n   Figure 6. Upstream\
    \ (*,*,RP) state machine .........................62\n   Figure 7. Upstream (*,G)\
    \ state machine ............................67\n   Figure 8. Upstream (S,G) state\
    \ machine ............................71\n   Figure 9. Upstream (S,G,rpt) state\
    \ machine for triggered\n             messages ................................................77\n\
    \   Figure 10. Per-interface (S,G) Assert State machine ...............84\n  \
    \ Figure 11. Per-interface (*,G) Assert State machine ...............92\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document specifies a protocol for efficiently routing\
    \ multicast\n   groups that may span wide-area (and inter-domain) internets. \
    \ This\n   protocol is called Protocol Independent Multicast - Sparse Mode\n \
    \  (PIM-SM) because, although it may use the underlying unicast routing\n   to\
    \ provide reverse-path information for multicast tree building, it\n   is not\
    \ dependent on any particular unicast routing protocol.\n   PIM-SM version 2 was\
    \ originally specified in RFC 2117 and was revised\n   in RFC 2362, both Experimental\
    \ RFCs.  This document is intended to\n   obsolete RFC 2362, to correct a number\
    \ of deficiencies that have been\n   identified with the way PIM-SM was previously\
    \ specified, and to bring\n   PIM-SM onto the IETF Standards Track.  As far as\
    \ possible, this\n   document specifies the same protocol as RFC 2362 and only\
    \ diverges\n   from the behavior intended by RFC 2362 when the previously specified\n\
    \   behavior was clearly incorrect.  Routers implemented according to the\n  \
    \ specification in this document will be able to interoperate\n   successfully\
    \ with routers implemented according to RFC 2362.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   In this document, the key words \"MUST\", \"MUST NOT\", \"\
    REQUIRED\",\n   \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\",\n   and \"OPTIONAL\" are to be interpreted as described in RFC 2119\
    \ [1] and\n   indicate requirement levels for compliant PIM-SM implementations.\n"
- title: 2.1.  Definitions
  contents:
  - "2.1.  Definitions\n   The following terms have special significance for PIM-SM:\n\
    \   Rendezvous Point (RP):\n         An RP is a router that has been configured\
    \ to be used as the\n         root of the non-source-specific distribution tree\
    \ for a\n         multicast group.  Join messages from receivers for a group are\n\
    \         sent towards the RP, and data from senders is sent to the RP so\n  \
    \       that receivers can discover who the senders are and start to\n       \
    \  receive traffic destined for the group.\n   Designated Router (DR):\n     \
    \    A shared-media LAN like Ethernet may have multiple PIM-SM\n         routers\
    \ connected to it.  A single one of these routers, the\n         DR, will act\
    \ on behalf of directly connected hosts with respect\n         to the PIM-SM protocol.\
    \  A single DR is elected per interface\n         (LAN or otherwise) using a simple\
    \ election process.\n   MRIB  Multicast Routing Information Base.  This is the\
    \ multicast\n         topology table, which is typically derived from the unicast\n\
    \         routing table, or routing protocols such as Multiprotocol BGP\n    \
    \     (MBGP) that carry multicast-specific topology information.  In\n       \
    \  PIM-SM, the MRIB is used to decide where to send Join/Prune\n         messages.\
    \  A secondary function of the MRIB is to provide\n         routing metrics for\
    \ destination addresses; these metrics are\n         used when sending and processing\
    \ Assert messages.\n   RPF Neighbor\n         RPF stands for \"Reverse Path Forwarding\"\
    .  The RPF Neighbor of\n         a router with respect to an address is the neighbor\
    \ that the\n         MRIB indicates should be used to forward packets to that\n\
    \         address.  In the case of a PIM-SM multicast group, the RPF\n       \
    \  neighbor is the router that a Join message for that group would\n         be\
    \ directed to, in the absence of modifying Assert state.\n   TIB   Tree Information\
    \ Base.  This is the collection of state at a\n         PIM router that has been\
    \ created by receiving PIM Join/Prune\n         messages, PIM Assert messages,\
    \ and Internet Group Management\n         Protocol (IGMP) or Multicast Listener\
    \ Discovery (MLD)\n         information from local hosts.  It essentially stores\
    \ the state\n         of all multicast distribution trees at that router.\n  \
    \ MFIB  Multicast Forwarding Information Base.  The TIB holds all the\n      \
    \   state that is necessary to forward multicast packets at a\n         router.\
    \  However, although this specification defines\n         forwarding in terms\
    \ of the TIB, to actually forward packets\n         using the TIB is very inefficient.\
    \  Instead, a real router\n         implementation will normally build an efficient\
    \ MFIB from the\n         TIB state to perform forwarding.  How this is done is\n\
    \         implementation-specific and is not discussed in this document.\n   Upstream\n\
    \         Towards the root of the tree.  The root of tree may be either\n    \
    \     the source or the RP, depending on the context.\n   Downstream\n       \
    \  Away from the root of the tree.\n   GenID Generation Identifier, used to detect\
    \ reboots.\n   PMBR  PIM Multicast Border Router, joining a PIM domain with another\n\
    \         multicast domain.\n"
- title: 2.2.  Pseudocode Notation
  contents:
  - "2.2.  Pseudocode Notation\n   We use set notation in several places in this specification.\n\
    \   A (+) B is the union of two sets, A and B.\n   A (-) B is the elements of\
    \ set A that are not in set B.\n   NULL    is the empty set or list.\n   In addition,\
    \ we use C-like syntax:\n   =       denotes assignment of a variable.\n   == \
    \     denotes a comparison for equality.\n   !=      denotes a comparison for\
    \ inequality.\n   Braces { and } are used for grouping.\n"
- title: 3.  PIM-SM Protocol Overview
  contents:
  - "3.  PIM-SM Protocol Overview\n   This section provides an overview of PIM-SM\
    \ behavior.  It is intended\n   as an introduction to how PIM-SM works, and it\
    \ is NOT definitive.\n   For the definitive specification, see Section 4.\n  \
    \ PIM relies on an underlying topology-gathering protocol to populate a\n   routing\
    \ table with routes.  This routing table is called the\n   Multicast Routing Information\
    \ Base (MRIB).  The routes in this table\n   may be taken directly from the unicast\
    \ routing table, or they may be\n   different and provided by a separate routing\
    \ protocol such as MBGP\n   [10].  Regardless of how it is created, the primary\
    \ role of the MRIB\n   in the PIM protocol is to provide the next-hop router along\
    \ a\n   multicast-capable path to each destination subnet.  The MRIB is used\n\
    \   to determine the next-hop neighbor to which any PIM Join/Prune\n   message\
    \ is sent.  Data flows along the reverse path of the Join\n   messages.  Thus,\
    \ in contrast to the unicast RIB, which specifies the\n   next hop that a data\
    \ packet would take to get to some subnet, the\n   MRIB gives reverse-path information\
    \ and indicates the path that a\n   multicast data packet would take from its\
    \ origin subnet to the router\n   that has the MRIB.\n   Like all multicast routing\
    \ protocols that implement the service model\n   from RFC 1112 [3], PIM-SM must\
    \ be able to route data packets from\n   sources to receivers without either the\
    \ sources or receivers knowing\n   a priori of the existence of the others.  This\
    \ is essentially done in\n   three phases, although as senders and receivers may\
    \ come and go at\n   any time, all three phases may occur simultaneously.\n"
- title: '3.1.  Phase One: RP Tree'
  contents:
  - "3.1.  Phase One: RP Tree\n   In phase one, a multicast receiver expresses its\
    \ interest in\n   receiving traffic destined for a multicast group.  Typically,\
    \ it does\n   this using IGMP [2] or MLD [4], but other mechanisms might also\
    \ serve\n   this purpose.  One of the receiver's local routers is elected as the\n\
    \   Designated Router (DR) for that subnet.  On receiving the receiver's\n   expression\
    \ of interest, the DR then sends a PIM Join message towards\n   the RP for that\
    \ multicast group.  This Join message is known as a\n   (*,G) Join because it\
    \ joins group G for all sources to that group.\n   The (*,G) Join travels hop-by-hop\
    \ towards the RP for the group, and\n   in each router it passes through, multicast\
    \ tree state for group G is\n   instantiated.  Eventually, the (*,G) Join either\
    \ reaches the RP or\n   reaches a router that already has (*,G) Join state for\
    \ that group.\n   When many receivers join the group, their Join messages converge\
    \ on\n   the RP and form a distribution tree for group G that is rooted at the\n\
    \   RP.  This is known as the RP Tree (RPT), and is also known as the\n   shared\
    \ tree because it is shared by all sources sending to that\n   group.  Join messages\
    \ are resent periodically so long as the receiver\n   remains in the group.  When\
    \ all receivers on a leaf-network leave the\n   group, the DR will send a PIM\
    \ (*,G) Prune message towards the RP for\n   that multicast group.  However, if\
    \ the Prune message is not sent for\n   any reason, the state will eventually\
    \ time out.\n   A multicast data sender just starts sending data destined for\
    \ a\n   multicast group.  The sender's local router (DR) takes those data\n  \
    \ packets, unicast-encapsulates them, and sends them directly to the\n   RP. \
    \ The RP receives these encapsulated data packets, decapsulates\n   them, and\
    \ forwards them onto the shared tree.  The packets then\n   follow the (*,G) multicast\
    \ tree state in the routers on the RP Tree,\n   being replicated wherever the\
    \ RP Tree branches, and eventually\n   reaching all the receivers for that multicast\
    \ group.  The process of\n   encapsulating data packets to the RP is called registering,\
    \ and the\n   encapsulation packets are known as PIM Register packets.\n   At\
    \ the end of phase one, multicast traffic is flowing encapsulated to\n   the RP,\
    \ and then natively over the RP tree to the multicast\n   receivers.\n"
- title: '3.2.  Phase Two: Register-Stop'
  contents:
  - "3.2.  Phase Two: Register-Stop\n   Register-encapsulation of data packets is\
    \ inefficient for two\n   reasons:\n   o Encapsulation and decapsulation may be\
    \ relatively expensive\n     operations for a router to perform, depending on\
    \ whether or not the\n     router has appropriate hardware for these tasks.\n\
    \   o Traveling all the way to the RP, and then back down the shared tree\n  \
    \   may result in the packets traveling a relatively long distance to\n     reach\
    \ receivers that are close to the sender.  For some\n     applications, this increased\
    \ latency or bandwidth consumption is\n     undesirable.\n   Although Register-encapsulation\
    \ may continue indefinitely, for these\n   reasons, the RP will normally choose\
    \ to switch to native forwarding.\n   To do this, when the RP receives a register-encapsulated\
    \ data packet\n   from source S on group G, it will normally initiate an (S,G)\
    \ source-\n   specific Join towards S.  This Join message travels hop-by-hop\n\
    \   towards S, instantiating (S,G) multicast tree state in the routers\n   along\
    \ the path.  (S,G) multicast tree state is used only to forward\n   packets for\
    \ group G if those packets come from source S.  Eventually\n   the Join message\
    \ reaches S's subnet or a router that already has\n   (S,G) multicast tree state,\
    \ and then packets from S start to flow\n   following the (S,G) tree state towards\
    \ the RP.  These data packets\n   may also reach routers with (*,G) state along\
    \ the path towards the\n   RP; if they do, they can shortcut onto the RP tree\
    \ at this point.\n   While the RP is in the process of joining the source-specific\
    \ tree\n   for S, the data packets will continue being encapsulated to the RP.\n\
    \   When packets from S also start to arrive natively at the RP, the RP\n   will\
    \ be receiving two copies of each of these packets.  At this\n   point, the RP\
    \ starts to discard the encapsulated copy of these\n   packets, and it sends a\
    \ Register-Stop message back to S's DR to\n   prevent the DR from unnecessarily\
    \ encapsulating the packets.\n   At the end of phase 2, traffic will be flowing\
    \ natively from S along\n   a source-specific tree to the RP, and from there along\
    \ the shared\n   tree to the receivers.  Where the two trees intersect, traffic\
    \ may\n   transfer from the source-specific tree to the RP tree and thus avoid\n\
    \   taking a long detour via the RP.\n   Note that a sender may start sending\
    \ before or after a receiver joins\n   the group, and thus phase two may happen\
    \ before the shared tree to\n   the receiver is built.\n"
- title: '3.3.  Phase Three: Shortest-Path Tree'
  contents:
  - "3.3.  Phase Three: Shortest-Path Tree\n   Although having the RP join back towards\
    \ the source removes the\n   encapsulation overhead, it does not completely optimize\
    \ the\n   forwarding paths.  For many receivers, the route via the RP may\n  \
    \ involve a significant detour when compared with the shortest path\n   from the\
    \ source to the receiver.\n   To obtain lower latencies or more efficient bandwidth\
    \ utilization, a\n   router on the receiver's LAN, typically the DR, may optionally\n\
    \   initiate a transfer from the shared tree to a source-specific\n   shortest-path\
    \ tree (SPT).  To do this, it issues an (S,G) Join\n   towards S.  This instantiates\
    \ state in the routers along the path to\n   S.  Eventually, this join either\
    \ reaches S's subnet or reaches a\n   router that already has (S,G) state.  When\
    \ this happens, data packets\n   from S start to flow following the (S,G) state\
    \ until they reach the\n   receiver.\n   At this point, the receiver (or a router\
    \ upstream of the receiver)\n   will be receiving two copies of the data: one\
    \ from the SPT and one\n   from the RPT.  When the first traffic starts to arrive\
    \ from the SPT,\n   the DR or upstream router starts to drop the packets for G\
    \ from S\n   that arrive via the RP tree.  In addition, it sends an (S,G) Prune\n\
    \   message towards the RP.  This is known as an (S,G,rpt) Prune.  The\n   Prune\
    \ message travels hop-by-hop, instantiating state along the path\n   towards the\
    \ RP indicating that traffic from S for G should NOT be\n   forwarded in this\
    \ direction.  The prune is propagated until it\n   reaches the RP or a router\
    \ that still needs the traffic from S for\n   other receivers.\n   By now, the\
    \ receiver will be receiving traffic from S along the\n   shortest-path tree between\
    \ the receiver and S.  In addition, the RP\n   is receiving the traffic from S,\
    \ but this traffic is no longer\n   reaching the receiver along the RP tree. \
    \ As far as the receiver is\n   concerned, this is the final distribution tree.\n"
- title: 3.4.  Source-Specific Joins
  contents:
  - "3.4.  Source-Specific Joins\n   IGMPv3 permits a receiver to join a group and\
    \ specify that it only\n   wants to receive traffic for a group if that traffic\
    \ comes from a\n   particular source.  If a receiver does this, and no other receiver\
    \ on\n   the LAN requires all the traffic for the group, then the DR may omit\n\
    \   performing a (*,G) join to set up the shared tree, and instead issue\n   a\
    \ source-specific (S,G) join only.\n   The range of multicast addresses from 232.0.0.0\
    \ to 232.255.255.255 is\n   currently set aside for source-specific multicast\
    \ in IPv4.  For\n   groups in this range, receivers should only issue source-specific\n\
    \   IGMPv3 joins.  If a PIM router receives a non-source-specific join\n   for\
    \ a group in this range, it should ignore it, as described in\n   Section 4.8.\n"
- title: 3.5.  Source-Specific Prunes
  contents:
  - "3.5.  Source-Specific Prunes\n   IGMPv3 also permits a receiver to join a group\
    \ and to specify that it\n   only wants to receive traffic for a group if that\
    \ traffic does not\n   come from a specific source or sources.  In this case,\
    \ the DR will\n   perform a (*,G) join as normal, but may combine this with an\n\
    \   (S,G,rpt) prune for each of the sources the receiver does not wish to\n  \
    \ receive.\n"
- title: 3.6.  Multi-Access Transit LANs
  contents:
  - "3.6.  Multi-Access Transit LANs\n   The overview so far has concerned itself\
    \ with point-to-point transit\n   links.  However, using multi-access LANs such\
    \ as Ethernet for transit\n   is not uncommon.  This can cause complications for\
    \ three reasons:\n   o Two or more routers on the LAN may issue (*,G) Joins to\
    \ different\n     upstream routers on the LAN because they have inconsistent MRIB\n\
    \     entries regarding how to reach the RP.  Both paths on the RP tree\n    \
    \ will be set up, causing two copies of all the shared tree traffic\n     to appear\
    \ on the LAN.\n   o Two or more routers on the LAN may issue (S,G) Joins to different\n\
    \     upstream routers on the LAN because they have inconsistent MRIB\n     entries\
    \ regarding how to reach source S.  Both paths on the source-\n     specific tree\
    \ will be set up, causing two copies of all the traffic\n     from S to appear\
    \ on the LAN.\n   o A router on the LAN may issue a (*,G) Join to one upstream\
    \ router\n     on the LAN, and another router on the LAN may issue an (S,G) Join\n\
    \     to a different upstream router on the same LAN.  Traffic from S may\n  \
    \   reach the LAN over both the RPT and the SPT.  If the receiver\n     behind\
    \ the downstream (*,G) router doesn't issue an (S,G,rpt)\n     prune, then this\
    \ condition would persist.\n   All of these problems are caused by there being\
    \ more than one\n   upstream router with join state for the group or source-group\
    \ pair.\n   PIM does not prevent such duplicate joins from occurring; instead,\n\
    \   when duplicate data packets appear on the LAN from different routers,\n  \
    \ these routers notice this and then elect a single forwarder.  This\n   election\
    \ is performed using PIM Assert messages, which resolve the\n   problem in favor\
    \ of the upstream router that has (S,G) state; or, if\n   neither or both router\
    \ has (S,G) state, then the problem is resolved\n   in favor of the router with\
    \ the best metric to the RP for RP trees,\n   or the best metric to the source\
    \ to source-specific trees.\n   These Assert messages are also received by the\
    \ downstream routers on\n   the LAN, and these cause subsequent Join messages\
    \ to be sent to the\n   upstream router that won the Assert.\n"
- title: 3.7.  RP Discovery
  contents:
  - "3.7.  RP Discovery\n   PIM-SM routers need to know the address of the RP for\
    \ each group for\n   which they have (*,G) state.  This address is obtained automatically\n\
    \   (e.g., embedded-RP), through a bootstrap mechanism, or through static\n  \
    \ configuration.\n   One dynamic way to do this is to use the Bootstrap Router\
    \ (BSR)\n   mechanism [11].  One router in each PIM domain is elected the\n  \
    \ Bootstrap Router through a simple election process.  All the routers\n   in\
    \ the domain that are configured to be candidates to be RPs\n   periodically unicast\
    \ their candidacy to the BSR.  From the\n   candidates, the BSR picks an RP-set,\
    \ and periodically announces this\n   set in a Bootstrap message.  Bootstrap messages\
    \ are flooded hop-by-\n   hop throughout the domain until all routers in the domain\
    \ know the\n   RP-Set.\n   To map a group to an RP, a router hashes the group\
    \ address into the\n   RP-set using an order-preserving hash function (one that\
    \ minimizes\n   changes if the RP-Set changes).  The resulting RP is the one that\
    \ it\n   uses as the RP for that group.\n"
- title: 4.  Protocol Specification
  contents:
  - "4.  Protocol Specification\n   The specification of PIM-SM is broken into several\
    \ parts:\n   o Section 4.1 details the protocol state stored.\n   o Section 4.2\
    \ specifies the data packet forwarding rules.\n   o Section 4.3 specifies Designated\
    \ Router (DR) election and the rules\n     for sending and processing Hello messages.\n\
    \   o Section 4.4 specifies the PIM Register generation and processing\n     rules.\n\
    \   o Section 4.5 specifies the PIM Join/Prune generation and processing\n   \
    \  rules.\n   o Section 4.6 specifies the PIM Assert generation and processing\n\
    \     rules.\n   o Section 4.7 specifies the RP discovery mechanisms.\n   o The\
    \ subset of PIM required to support Source-Specific Multicast,\n     PIM-SSM,\
    \ is described in Section 4.8.\n   o PIM packet formats are specified in Section\
    \ 4.9.\n   o A summary of PIM-SM timers and their default values is given in\n\
    \     Section 4.10.\n   o Appendix A specifies the PIM Multicast Border Router\
    \ behavior.\n"
- title: 4.1.  PIM Protocol State
  contents:
  - "4.1.  PIM Protocol State\n   This section specifies all the protocol state that\
    \ a PIM\n   implementation should maintain in order to function correctly.  We\n\
    \   term this state the Tree Information Base (TIB), as it holds the\n   state\
    \ of all the multicast distribution trees at this router.  In\n   this specification,\
    \ we define PIM mechanisms in terms of the TIB.\n   However, only a very simple\
    \ implementation would actually implement\n   packet forwarding operations in\
    \ terms of this state.  Most\n   implementations will use this state to build\
    \ a multicast forwarding\n   table, which would then be updated when the relevant\
    \ state in the TIB\n   changes.\n   Although we specify precisely the state to\
    \ be kept, this does not\n   mean that an implementation of PIM-SM needs to hold\
    \ the state in this\n   form.  This is actually an abstract state definition,\
    \ which is needed\n   in order to specify the router's behavior.  A PIM-SM implementation\n\
    \   is free to hold whatever internal state it requires and will still be\n  \
    \ conformant with this specification so long as it results in the same\n   externally\
    \ visible protocol behavior as an abstract router that holds\n   the following\
    \ state.\n   We divide TIB state into four sections:\n   (*,*,RP) state\n    \
    \    State that maintains per-RP trees, for all groups served by a\n        given\
    \ RP.\n   (*,G) state\n        State that maintains the RP tree for G.\n   (S,G)\
    \ state\n        State that maintains a source-specific tree for source S and\n\
    \        group G.\n   (S,G,rpt) state\n        State that maintains source-specific\
    \ information about source S\n        on the RP tree for G.  For example, if a\
    \ source is being\n        received on the source-specific tree, it will normally\
    \ have been\n        pruned off the RP tree.  This prune state is (S,G,rpt) state.\n\
    \   The state that should be kept is described below.  Of course,\n   implementations\
    \ will only maintain state when it is relevant to\n   forwarding operations; for\
    \ example, the \"NoInfo\" state might be\n   assumed from the lack of other state\
    \ information rather than being\n   held explicitly.\n"
- title: 4.1.1.  General Purpose State
  contents:
  - "4.1.1.  General Purpose State\n   A router holds the following non-group-specific\
    \ state:\n   For each interface:\n        o Effective Override Interval\n    \
    \    o Effective Propagation Delay\n        o Suppression state: One of {\"Enable\"\
    , \"Disable\"}\n        Neighbor State:\n          For each neighbor:\n      \
    \         o Information from neighbor's Hello\n               o Neighbor's GenID.\n\
    \               o Neighbor Liveness Timer (NLT)\n        Designated Router (DR)\
    \ State:\n          o Designated Router's IP Address\n          o DR's DR Priority\n\
    \   The Effective Override Interval, the Effective Propagation Delay and\n   the\
    \ Interface suppression state are described in Section 4.3.3.\n   Designated Router\
    \ state is described in Section 4.3.\n"
- title: 4.1.2.  (*,*,RP) State
  contents:
  - "4.1.2.  (*,*,RP) State\n   For every RP, a router keeps the following state:\n\
    \   (*,*,RP) state:\n        For each interface:\n             PIM (*,*,RP) Join/Prune\
    \ State:\n                  o State: One of {\"NoInfo\" (NI), \"Join\" (J), \"\
    Prune-\n                    Pending\" (PP)}\n                  o Prune-Pending\
    \ Timer (PPT)\n                  o Join/Prune Expiry Timer (ET)\n        Not interface\
    \ specific:\n             Upstream (*,*,RP) Join/Prune State:\n              \
    \    o State: One of {\"NotJoined(*,*,RP)\",\n                    \"Joined(*,*,RP)\"\
    }\n             o Upstream Join/Prune Timer (JT)\n             o Last RPF Neighbor\
    \ towards RP that was used\n   PIM (*,*,RP) Join/Prune state is the result of\
    \ receiving PIM (*,*,RP)\n   Join/Prune messages on this interface and is specified\
    \ in Section\n   4.5.1.\n   The upstream (*,*,RP) Join/Prune State reflects the\
    \ state of the\n   upstream (*,*,RP) state machine described in Section 4.5.5.\n\
    \   The upstream (*,*,RP) Join/Prune Timer is used to send out periodic\n   Join(*,*,RP)\
    \ messages, and to override Prune(*,*,RP) messages from\n   peers on an upstream\
    \ LAN interface.\n   The last RPF neighbor towards the RP is stored because if\
    \ the MRIB\n   changes, then the RPF neighbor towards the RP may change.  If it\
    \ does\n   so, then we need to trigger a new Join(*,*,RP) to the new upstream\n\
    \   neighbor and a Prune(*,*,RP) to the old upstream neighbor.\n   Similarly,\
    \ if a router detects through a changed GenID in a Hello\n   message that the\
    \ upstream neighbor towards the RP has rebooted, then\n   it should re-instantiate\
    \ state by sending a Join(*,*,RP).  These\n   mechanisms are specified in Section\
    \ 4.5.5.\n"
- title: 4.1.3.  (*,G) State
  contents:
  - "4.1.3.  (*,G) State\n   For every group G, a router keeps the following state:\n\
    \   (*,G) state:\n        For each interface:\n             Local Membership:\n\
    \                  State: One of {\"NoInfo\", \"Include\"}\n             PIM (*,G)\
    \ Join/Prune State:\n                  o State: One of {\"NoInfo\" (NI), \"Join\"\
    \ (J), \"Prune-\n                    Pending\" (PP)}\n                  o Prune-Pending\
    \ Timer (PPT)\n                  o Join/Prune Expiry Timer (ET)\n            \
    \ (*,G) Assert Winner State\n                  o State: One of {\"NoInfo\" (NI),\
    \ \"I lost Assert\" (L),\n                    \"I won Assert\" (W)}\n        \
    \          o Assert Timer (AT)\n                  o Assert winner's IP Address\
    \ (AssertWinner)\n                  o Assert winner's Assert Metric (AssertWinnerMetric)\n\
    \        Not interface specific:\n             Upstream (*,G) Join/Prune State:\n\
    \                  o State: One of {\"NotJoined(*,G)\", \"Joined(*,G)\"}\n   \
    \          o Upstream Join/Prune Timer (JT)\n             o Last RP Used\n   \
    \          o Last RPF Neighbor towards RP that was used\n   Local membership is\
    \ the result of the local membership mechanism\n   (such as IGMP or MLD) running\
    \ on that interface.  It need not be kept\n   if this router is not the DR on\
    \ that interface unless this router won\n   a (*,G) assert on this interface for\
    \ this group, although\n   implementations may optionally keep this state in case\
    \ they become\n   the DR or assert winner.  We recommend storing this information\
    \ if\n   possible, as it reduces latency converging to stable operating\n   conditions\
    \ after a failure causing a change of DR.  This information\n   is used by the\
    \ pim_include(*,G) macro described in Section 4.1.6.\n   PIM (*,G) Join/Prune\
    \ state is the result of receiving PIM (*,G)\n   Join/Prune messages on this interface\
    \ and is specified in Section\n   4.5.2.  The state is used by the macros that\
    \ calculate the outgoing\n   interface list in Section 4.1.6, and in the JoinDesired(*,G)\
    \ macro\n   (defined in Section 4.5.6) that is used in deciding whether a\n  \
    \ Join(*,G) should be sent upstream.\n   (*,G) Assert Winner state is the result\
    \ of sending or receiving (*,G)\n   Assert messages on this interface.  It is\
    \ specified in Section 4.6.2.\n   The upstream (*,G) Join/Prune State reflects\
    \ the state of the\n   upstream (*,G) state machine described in Section 4.5.6.\n\
    \   The upstream (*,G) Join/Prune Timer is used to send out periodic\n   Join(*,G)\
    \ messages, and to override Prune(*,G) messages from peers on\n   an upstream\
    \ LAN interface.\n   The last RP used must be stored because if the RP-Set changes\n\
    \   (Section 4.7), then state must be torn down and rebuilt for groups\n   whose\
    \ RP changes.\n   The last RPF neighbor towards the RP is stored because if the\
    \ MRIB\n   changes, then the RPF neighbor towards the RP may change.  If it does\n\
    \   so, then we need to trigger a new Join(*,G) to the new upstream\n   neighbor\
    \ and a Prune(*,G) to the old upstream neighbor.  Similarly,\n   if a router detects\
    \ through a changed GenID in a Hello message that\n   the upstream neighbor towards\
    \ the RP has rebooted, then it should\n   re-instantiate state by sending a Join(*,G).\
    \  These mechanisms are\n   specified in Section 4.5.6.\n"
- title: 4.1.4.  (S,G) State
  contents:
  - "4.1.4.  (S,G) State\n   For every source/group pair (S,G), a router keeps the\
    \ following\n   state:\n   (S,G) state:\n        For each interface:\n       \
    \      Local Membership:\n                  State: One of {\"NoInfo\", \"Include\"\
    }\n             PIM (S,G) Join/Prune State:\n                  o State: One of\
    \ {\"NoInfo\" (NI), \"Join\" (J), \"Prune-\n                    Pending\" (PP)}\n\
    \                  o Prune-Pending Timer (PPT)\n                  o Join/Prune\
    \ Expiry Timer (ET)\n             (S,G) Assert Winner State\n                \
    \  o State: One of {\"NoInfo\" (NI), \"I lost Assert\" (L),\n                \
    \    \"I won Assert\" (W)}\n                  o Assert Timer (AT)\n          \
    \        o Assert winner's IP Address (AssertWinner)\n                  o Assert\
    \ winner's Assert Metric (AssertWinnerMetric)\n        Not interface specific:\n\
    \             Upstream (S,G) Join/Prune State:\n                  o State: One\
    \ of {\"NotJoined(S,G)\", \"Joined(S,G)\"}\n             o Upstream (S,G) Join/Prune\
    \ Timer (JT)\n             o Last RPF Neighbor towards S that was used\n     \
    \        o SPTbit (indicates (S,G) state is active)\n             o (S,G) Keepalive\
    \ Timer (KAT)\n             Additional (S,G) state at the DR:\n              \
    \    o Register state: One of {\"Join\" (J), \"Prune\" (P),\n                \
    \    \"Join-Pending\" (JP), \"NoInfo\" (NI)}\n                  o Register-Stop\
    \ timer\n             Additional (S,G) state at the RP:\n                  o PMBR:\
    \ the first PMBR to send a Register for this\n                    source with\
    \ the Border bit set.\n   Local membership is the result of the local source-specific\n\
    \   membership mechanism (such as IGMP version 3) running on that\n   interface\
    \ and specifying that this particular source should be\n   included.  As stored\
    \ here, this state is the resulting state after\n   any IGMPv3 inconsistencies\
    \ have been resolved.  It need not be kept\n   if this router is not the DR on\
    \ that interface unless this router won\n   a (S,G) assert on this interface for\
    \ this group.  However, we\n   recommend storing this information if possible,\
    \ as it reduces latency\n   converging to stable operating conditions after a\
    \ failure causing a\n   change of DR.  This information is used by the pim_include(S,G)\
    \ macro\n   described in Section 4.1.6.\n   PIM (S,G) Join/Prune state is the\
    \ result of receiving PIM (S,G)\n   Join/Prune messages on this interface and\
    \ is specified in Section\n   4.5.2.  The state is used by the macros that calculate\
    \ the outgoing\n   interface list in Section 4.1.6, and in the JoinDesired(S,G)\
    \ macro\n   (defined in Section 4.5.7) that is used in deciding whether a\n  \
    \ Join(S,G) should be sent upstream.\n   (S,G) Assert Winner state is the result\
    \ of sending or receiving (S,G)\n   Assert messages on this interface.  It is\
    \ specified in Section 4.6.1.\n   The upstream (S,G) Join/Prune State reflects\
    \ the state of the\n   upstream (S,G) state machine described in Section 4.5.7.\n\
    \   The upstream (S,G) Join/Prune Timer is used to send out periodic\n   Join(S,G)\
    \ messages, and to override Prune(S,G) messages from peers on\n   an upstream\
    \ LAN interface.\n   The last RPF neighbor towards S is stored because if the\
    \ MRIB\n   changes, then the RPF neighbor towards S may change.  If it does so,\n\
    \   then we need to trigger a new Join(S,G) to the new upstream neighbor\n   and\
    \ a Prune(S,G) to the old upstream neighbor.  Similarly, if the\n   router detects\
    \ through a changed GenID in a Hello message that the\n   upstream neighbor towards\
    \ S has rebooted, then it should re-\n   instantiate state by sending a Join(S,G).\
    \  These mechanisms are\n   specified in Section 4.5.7.\n   The SPTbit is used\
    \ to indicate whether forwarding is taking place on\n   the (S,G) Shortest Path\
    \ Tree (SPT) or on the (*,G) tree.  A router\n   can have (S,G) state and still\
    \ be forwarding on (*,G) state during\n   the interval when the source-specific\
    \ tree is being constructed.\n   When SPTbit is FALSE, only (*,G) forwarding state\
    \ is used to forward\n   packets from S to G.  When SPTbit is TRUE, both (*,G)\
    \ and (S,G)\n   forwarding state are used.\n   The (S,G) Keepalive Timer is updated\
    \ by data being forwarded using\n   this (S,G) forwarding state.  It is used to\
    \ keep (S,G) state alive in\n   the absence of explicit (S,G) Joins.  Amongst\
    \ other things, this is\n   necessary for the so-called \"turnaround rules\" --\
    \ when the RP uses\n   (S,G) joins to stop encapsulation, and then (S,G) prunes\
    \ to prevent\n   traffic from unnecessarily reaching the RP.\n   On a DR, the\
    \ (S,G) Register State is used to keep track of whether to\n   encapsulate data\
    \ to the RP on the Register Tunnel; the (S,G)\n   Register-Stop timer tracks how\
    \ long before encapsulation begins again\n   for a given (S,G).\n   On an RP,\
    \ the PMBR value must be cleared when the Keepalive Timer\n   expires.\n"
- title: 4.1.5.  (S,G,rpt) State
  contents:
  - "4.1.5.  (S,G,rpt) State\n   For every source/group pair (S,G) for which a router\
    \ also has (*,G)\n   state, it also keeps the following state:\n   (S,G,rpt) state:\n\
    \        For each interface:\n             Local Membership:\n               \
    \   State: One of {\"NoInfo\", \"Exclude\"}\n             PIM (S,G,rpt) Join/Prune\
    \ State:\n                  o State: One of {\"NoInfo\", \"Pruned\", \"Prune-\n\
    \                    Pending\"}\n                  o Prune-Pending Timer (PPT)\n\
    \                  o Join/Prune Expiry Timer (ET)\n        Not interface specific:\n\
    \             Upstream (S,G,rpt) Join/Prune State:\n                  o State:\
    \ One of {\"RPTNotJoined(G)\",\n                    \"NotPruned(S,G,rpt)\", \"\
    Pruned(S,G,rpt)\"}\n                  o Override Timer (OT)\n   Local membership\
    \ is the result of the local source-specific\n   membership mechanism (such as\
    \ IGMPv3) running on that interface and\n   specifying that although there is\
    \ (*,G) Include state, this\n   particular source should be excluded.  As stored\
    \ here, this state is\n   the resulting state after any IGMPv3 inconsistencies\
    \ between LAN\n   members have been resolved.  It need not be kept if this router\
    \ is\n   not the DR on that interface unless this router won a (*,G) assert on\n\
    \   this interface for this group.  However, we recommend storing this\n   information\
    \ if possible, as it reduces latency converging to stable\n   operating conditions\
    \ after a failure causing a change of DR.  This\n   information is used by the\
    \ pim_exclude(S,G) macro described in\n   Section 4.1.6.\n   PIM (S,G,rpt) Join/Prune\
    \ state is the result of receiving PIM\n   (S,G,rpt) Join/Prune messages on this\
    \ interface and is specified in\n   Section 4.5.4.  The state is used by the macros\
    \ that calculate the\n   outgoing interface list in Section 4.1.6, and in the\
    \ rules for adding\n   Prune(S,G,rpt) messages to Join(*,G) messages specified\
    \ in Section\n   4.5.8.\n   The upstream (S,G,rpt) Join/Prune state is used along\
    \ with the\n   Override Timer to send the correct override messages in response\
    \ to\n   Join/Prune messages sent by upstream peers on a LAN.  This state and\n\
    \   behavior are specified in Section 4.5.9.\n"
- title: 4.1.6.  State Summarization Macros
  contents:
  - "4.1.6.  State Summarization Macros\n   Using this state, we define the following\
    \ \"macro\" definitions, which\n   we will use in the descriptions of the state\
    \ machines and pseudocode\n   in the following sections.\n   The most important\
    \ macros are those that define the outgoing\n   interface list (or \"olist\")\
    \ for the relevant state.  An olist can be\n   \"immediate\" if it is built directly\
    \ from the state of the relevant\n   type.  For example, the immediate_olist(S,G)\
    \ is the olist that would\n   be built if the router only had (S,G) state and\
    \ no (*,G) or (S,G,rpt)\n   state.  In contrast, the \"inherited\" olist inherits\
    \ state from other\n   types.  For example, the inherited_olist(S,G) is the olist\
    \ that is\n   relevant for forwarding a packet from S to G using both source-\n\
    \   specific and group-specific state.\n   There is no immediate_olist(S,G,rpt)\
    \ as (S,G,rpt) state is negative\n   state; it removes interfaces in the (*,G)\
    \ olist from the olist that\n   is actually used to forward traffic.  The inherited_olist(S,G,rpt)\
    \ is\n   therefore the olist that would be used for a packet from S to G\n   forwarding\
    \ on the RP tree.  It is a strict subset of\n   (immediate_olist(*,*,RP) (+) immediate_olist(*,G)).\n\
    \   Generally speaking, the inherited olists are used for forwarding, and\n  \
    \ the immediate_olists are used to make decisions about state\n   maintenance.\n\
    \   immediate_olist(*,*,RP) =\n       joins(*,*,RP)\n   immediate_olist(*,G) =\n\
    \       joins(*,G) (+) pim_include(*,G) (-) lost_assert(*,G)\n   immediate_olist(S,G)\
    \ =\n       joins(S,G) (+) pim_include(S,G) (-) lost_assert(S,G)\n   inherited_olist(S,G,rpt)\
    \ =\n           ( joins(*,*,RP(G)) (+) joins(*,G) (-) prunes(S,G,rpt) )\n    \
    \   (+) ( pim_include(*,G) (-) pim_exclude(S,G))\n       (-) ( lost_assert(*,G)\
    \ (+) lost_assert(S,G,rpt) )\n   inherited_olist(S,G) =\n       inherited_olist(S,G,rpt)\
    \ (+)\n       joins(S,G) (+) pim_include(S,G) (-) lost_assert(S,G)\n   The macros\
    \ pim_include(*,G) and pim_include(S,G) indicate the\n   interfaces to which traffic\
    \ might be forwarded because of hosts that\n   are local members on that interface.\
    \  Note that normally only the DR\n   cares about local membership, but when an\
    \ assert happens, the assert\n   winner takes over responsibility for forwarding\
    \ traffic to local\n   members that have requested traffic on a group or source/group\
    \ pair.\n   pim_include(*,G) =\n      { all interfaces I such that:\n        (\
    \ ( I_am_DR( I ) AND lost_assert(*,G,I) == FALSE )\n          OR AssertWinner(*,G,I)\
    \ == me )\n        AND  local_receiver_include(*,G,I) }\n   pim_include(S,G) =\n\
    \       { all interfaces I such that:\n         ( (I_am_DR( I ) AND lost_assert(S,G,I)\
    \ == FALSE )\n           OR AssertWinner(S,G,I) == me )\n          AND  local_receiver_include(S,G,I)\
    \ }\n   pim_exclude(S,G) =\n       { all interfaces I such that:\n         ( (I_am_DR(\
    \ I ) AND lost_assert(*,G,I) == FALSE )\n           OR AssertWinner(*,G,I) ==\
    \ me )\n          AND  local_receiver_exclude(S,G,I) }\n   The clause \"local_receiver_include(S,G,I)\"\
    \ is true if the IGMP/MLD\n   module or other local membership mechanism has determined\
    \ that local\n   members on interface I desire to receive traffic sent specifically\
    \ by\n   S to G.  \"local_receiver_include(*,G,I)\" is true if the IGMP/MLD\n\
    \   module or other local membership mechanism has determined that local\n   members\
    \ on interface I desire to receive all traffic sent to G\n   (possibly excluding\
    \ traffic from a specific set of sources).\n   \"local_receiver_exclude(S,G,I)\
    \ is true if\n   \"local_receiver_include(*,G,I)\" is true but none of the local\
    \ members\n   desire to receive traffic from S.\n   The set \"joins(*,*,RP)\"\
    \ is the set of all interfaces on which the\n   router has received (*,*,RP) Joins:\n\
    \   joins(*,*,RP) =\n       { all interfaces I such that\n         DownstreamJPState(*,*,RP,I)\
    \ is either Join or\n             Prune-Pending }\n   DownstreamJPState(*,*,RP,I)\
    \ is the state of the finite state machine\n   in Section 4.5.1.\n   The set \"\
    joins(*,G)\" is the set of all interfaces on which the router\n   has received\
    \ (*,G) Joins:\n   joins(*,G) =\n       { all interfaces I such that\n       \
    \  DownstreamJPState(*,G,I) is either Join or Prune-Pending }\n   DownstreamJPState(*,G,I)\
    \ is the state of the finite state machine in\n   Section 4.5.2.\n   The set \"\
    joins(S,G)\" is the set of all interfaces on which the router\n   has received\
    \ (S,G) Joins:\n   joins(S,G) =\n       { all interfaces I such that\n       \
    \  DownstreamJPState(S,G,I) is either Join or Prune-Pending }\n   DownstreamJPState(S,G,I)\
    \ is the state of the finite state machine in\n   Section 4.5.3.\n   The set \"\
    prunes(S,G,rpt)\" is the set of all interfaces on which the\n   router has received\
    \ (*,G) joins and (S,G,rpt) prunes.\n   prunes(S,G,rpt) =\n       { all interfaces\
    \ I such that\n         DownstreamJPState(S,G,rpt,I) is Prune or PruneTmp }\n\
    \   DownstreamJPState(S,G,rpt,I) is the state of the finite state machine\n  \
    \ in Section 4.5.4.\n   The set \"lost_assert(*,G)\" is the set of all interfaces\
    \ on which the\n   router has received (*,G) joins but has lost a (*,G) assert.\
    \  The\n   macro lost_assert(*,G,I) is defined in Section 4.6.5.\n   lost_assert(*,G)\
    \ =\n       { all interfaces I such that\n         lost_assert(*,G,I) == TRUE\
    \ }\n   The set \"lost_assert(S,G,rpt)\" is the set of all interfaces on which\n\
    \   the router has received (*,G) joins but has lost an (S,G) assert.\n   The\
    \ macro lost_assert(S,G,rpt,I) is defined in Section 4.6.5.\n   lost_assert(S,G,rpt)\
    \ =\n       { all interfaces I such that\n         lost_assert(S,G,rpt,I) == TRUE\
    \ }\n   The set \"lost_assert(S,G)\" is the set of all interfaces on which the\n\
    \   router has received (S,G) joins but has lost an (S,G) assert.  The\n   macro\
    \ lost_assert(S,G,I) is defined in Section 4.6.5.\n   lost_assert(S,G) =\n   \
    \    { all interfaces I such that\n         lost_assert(S,G,I) == TRUE }\n   The\
    \ following pseudocode macro definitions are also used in many\n   places in the\
    \ specification.  Basically, RPF' is the RPF neighbor\n   towards an RP or source\
    \ unless a PIM-Assert has overridden the normal\n   choice of neighbor.\n    \
    \ neighbor RPF'(*,G) {\n         if ( I_Am_Assert_Loser(*, G, RPF_interface(RP(G)))\
    \ ) {\n              return AssertWinner(*, G, RPF_interface(RP(G)) )\n      \
    \   } else {\n              return NBR( RPF_interface(RP(G)), MRIB.next_hop( RP(G)\
    \ ) )\n         }\n     }\n     neighbor RPF'(S,G,rpt) {\n         if( I_Am_Assert_Loser(S,\
    \ G, RPF_interface(RP(G)) ) ) {\n              return AssertWinner(S, G, RPF_interface(RP(G))\
    \ )\n         } else {\n              return RPF'(*,G)\n         }\n     }\n \
    \    neighbor RPF'(S,G) {\n         if ( I_Am_Assert_Loser(S, G, RPF_interface(S)\
    \ )) {\n              return AssertWinner(S, G, RPF_interface(S) )\n         }\
    \ else {\n              return NBR( RPF_interface(S), MRIB.next_hop( S ) )\n \
    \        }\n     }\n   RPF'(*,G) and RPF'(S,G) indicate the neighbor from which\
    \ data packets\n   should be coming and to which joins should be sent on the RP\
    \ tree and\n   SPT, respectively.\n   RPF'(S,G,rpt) is basically RPF'(*,G) modified\
    \ by the result of an\n   Assert(S,G) on RPF_interface(RP(G)).  In such a case,\
    \ packets from S\n   will be originating from a different router than RPF'(*,G).\
    \  If we\n   only have active (*,G) Join state, we need to accept packets from\n\
    \   RPF'(S,G,rpt) and add a Prune(S,G,rpt) to the periodic Join(*,G)\n   messages\
    \ that we send to RPF'(*,G) (see Section 4.5.8).\n   The function MRIB.next_hop(\
    \ S ) returns an address of the next-hop\n   PIM neighbor toward the host S, as\
    \ indicated by the current MRIB.  If\n   S is directly adjacent, then MRIB.next_hop(\
    \ S ) returns NULL.  At the\n   RP for G, MRIB.next_hop( RP(G)) returns NULL.\n\
    \   The function NBR( I, A ) uses information gathered through PIM Hello\n   messages\
    \ to map the IP address A of a directly connected PIM neighbor\n   router on interface\
    \ I to the primary IP address of the same router\n   (Section 4.3.4).  The primary\
    \ IP address of a neighbor is the address\n   that it uses as the source of its\
    \ PIM Hello messages.  Note that a\n   neighbor's IP address may be non-unique\
    \ within the PIM neighbor\n   database due to scope issues.  The address must,\
    \ however, be unique\n   amongst the addresses of all the PIM neighbors on a specific\n\
    \   interface.\n   I_Am_Assert_Loser(S, G, I) is true if the Assert state machine\
    \ (in\n   Section 4.6.1) for (S,G) on Interface I is in \"I am Assert Loser\"\n\
    \   state.\n   I_Am_Assert_Loser(*, G, I) is true if the Assert state machine\
    \ (in\n   Section 4.6.2) for (*,G) on Interface I is in \"I am Assert Loser\"\n\
    \   state.\n"
- title: 4.2.  Data Packet Forwarding Rules
  contents:
  - "4.2.  Data Packet Forwarding Rules\n   The PIM-SM packet forwarding rules are\
    \ defined below in pseudocode.\n      iif is the incoming interface of the packet.\n\
    \      S is the source address of the packet.\n      G is the destination address\
    \ of the packet (group address).\n      RP is the address of the Rendezvous Point\
    \ for this group.\n      RPF_interface(S) is the interface the MRIB indicates\
    \ would be used\n      to route packets to S.\n      RPF_interface(RP) is the\
    \ interface the MRIB indicates would be\n      used to route packets to RP, except\
    \ at the RP when it is the\n      decapsulation interface (the \"virtual\" interface\
    \ on which register\n      packets are received).\n   First, we restart (or start)\
    \ the Keepalive Timer if the source is on\n   a directly connected subnet.\n \
    \  Second, we check to see if the SPTbit should be set because we've now\n   switched\
    \ from the RP tree to the SPT.\n   Next, we check to see whether the packet should\
    \ be accepted based on\n   TIB state and the interface that the packet arrived\
    \ on.\n   If the packet should be forwarded using (S,G) state, we then build an\n\
    \   outgoing interface list for the packet.  If this list is not empty,\n   then\
    \ we restart the (S,G) state Keepalive Timer.\n   If the packet should be forwarded\
    \ using (*,*,RP) or (*,G) state, then\n   we just build an outgoing interface\
    \ list for the packet.  We also\n   check if we should initiate a switch to start\
    \ receiving this source\n   on a shortest path tree.\n   Finally we remove the\
    \ incoming interface from the outgoing interface\n   list we've created, and if\
    \ the resulting outgoing interface list is\n   not empty, we forward the packet\
    \ out of those interfaces.\n   On receipt of data from S to G on interface iif:\n\
    \    if( DirectlyConnected(S) == TRUE AND iif == RPF_interface(S) ) {\n      \
    \   set KeepaliveTimer(S,G) to Keepalive_Period\n         # Note: a register state\
    \ transition or UpstreamJPState(S,G)\n         # transition may happen as a result\
    \ of restarting\n         # KeepaliveTimer, and must be dealt with here.\n   \
    \ }\n   if( iif == RPF_interface(S) AND UpstreamJPState(S,G) == Joined AND\n \
    \     inherited_olist(S,G) != NULL ) {\n          set KeepaliveTimer(S,G) to Keepalive_Period\n\
    \   }\n   Update_SPTbit(S,G,iif)\n   oiflist = NULL\n   if( iif == RPF_interface(S)\
    \ AND SPTbit(S,G) == TRUE ) {\n      oiflist = inherited_olist(S,G)\n   } else\
    \ if( iif == RPF_interface(RP(G)) AND SPTbit(S,G) == FALSE) {\n     oiflist =\
    \ inherited_olist(S,G,rpt)\n     CheckSwitchToSpt(S,G)\n   } else {\n      # Note:\
    \ RPF check failed\n      # A transition in an Assert FSM may cause an Assert(S,G)\n\
    \      # or Assert(*,G) message to be sent out interface iif.\n      # See section\
    \ 4.6 for details.\n      if ( SPTbit(S,G) == TRUE AND iif is in inherited_olist(S,G)\
    \ ) {\n         send Assert(S,G) on iif\n      } else if ( SPTbit(S,G) == FALSE\
    \ AND\n                  iif is in inherited_olist(S,G,rpt) {\n         send Assert(*,G)\
    \ on iif\n      }\n   }\n   oiflist = oiflist (-) iif\n   forward packet on all\
    \ interfaces in oiflist\n   This pseudocode employs several \"macro\" definitions:\n\
    \   DirectlyConnected(S) is TRUE if the source S is on any subnet that is\n  \
    \ directly connected to this router (or for packets originating on this\n   router).\n\
    \   inherited_olist(S,G) and inherited_olist(S,G,rpt) are defined in\n   Section\
    \ 4.1.\n   Basically, inherited_olist(S,G) is the outgoing interface list for\n\
    \   packets forwarded on (S,G) state, taking into account (*,*,RP) state,\n  \
    \ (*,G) state, asserts, etc.\n   inherited_olist(S,G,rpt) is the outgoing interface\
    \ list for packets\n   forwarded on (*,*,RP) or (*,G) state, taking into account\
    \ (S,G,rpt)\n   prune state, asserts, etc.\n   Update_SPTbit(S,G,iif) is defined\
    \ in Section 4.2.2.\n   CheckSwitchToSpt(S,G) is defined in Section 4.2.1.\n \
    \  UpstreamJPState(S,G) is the state of the finite state machine in\n   Section\
    \ 4.5.7.\n   Keepalive_Period is defined in Section 4.10.\n   Data-triggered PIM-Assert\
    \ messages sent from the above forwarding\n   code should be rate-limited in a\
    \ implementation-dependent manner.\n"
- title: 4.2.1.  Last-Hop Switchover to the SPT
  contents:
  - "4.2.1.  Last-Hop Switchover to the SPT\n   In Sparse-Mode PIM, last-hop routers\
    \ join the shared tree towards the\n   RP.  Once traffic from sources to joined\
    \ groups arrives at a last-hop\n   router, it has the option of switching to receive\
    \ the traffic on a\n   shortest path tree (SPT).\n   The decision for a router\
    \ to switch to the SPT is controlled as\n   follows:\n     void\n     CheckSwitchToSpt(S,G)\
    \ {\n       if ( ( pim_include(*,G) (-) pim_exclude(S,G)\n              (+) pim_include(S,G)\
    \ != NULL )\n            AND SwitchToSptDesired(S,G) ) {\n              # Note:\
    \ Restarting the KAT will result in the SPT switch\n              set KeepaliveTimer(S,G)\
    \ to Keepalive_Period\n       }\n     }\n   SwitchToSptDesired(S,G) is a policy\
    \ function that is implementation\n   defined.  An \"infinite threshold\" policy\
    \ can be implemented by making\n   SwitchToSptDesired(S,G) return false all the\
    \ time.  A \"switch on\n   first packet\" policy can be implemented by making\n\
    \   SwitchToSptDesired(S,G) return true once a single packet has been\n   received\
    \ for the source and group.\n"
- title: 4.2.2.  Setting and Clearing the (S,G) SPTbit
  contents:
  - "4.2.2.  Setting and Clearing the (S,G) SPTbit\n   The (S,G) SPTbit is used to\
    \ distinguish whether to forward on\n   (*,*,RP)/(*,G) or on (S,G) state.  When\
    \ switching from the RP tree to\n   the source tree, there is a transition period\
    \ when data is arriving\n   due to upstream (*,*,RP)/(*,G) state while upstream\
    \ (S,G) state is\n   being established, during which time a router should continue\
    \ to\n   forward only on (*,*,RP)/(*,G) state.  This prevents temporary\n   black-holes\
    \ that would be caused by sending a Prune(S,G,rpt) before\n   the upstream (S,G)\
    \ state has finished being established.\n   Thus, when a packet arrives, the (S,G)\
    \ SPTbit is updated as follows:\n     void\n     Update_SPTbit(S,G,iif) {\n  \
    \     if ( iif == RPF_interface(S)\n             AND JoinDesired(S,G) == TRUE\n\
    \             AND ( DirectlyConnected(S) == TRUE\n                   OR RPF_interface(S)\
    \ != RPF_interface(RP(G))\n                   OR inherited_olist(S,G,rpt) == NULL\n\
    \                   OR ( ( RPF'(S,G) == RPF'(*,G) ) AND\n                    \
    \    ( RPF'(S,G) != NULL ) )\n                   OR ( I_Am_Assert_Loser(S,G,iif)\
    \ ) {\n          Set SPTbit(S,G) to TRUE\n       }\n     }\n   Additionally, a\
    \ router can set SPTbit(S,G) to TRUE in other cases,\n   such as when it receives\
    \ an Assert(S,G) on RPF_interface(S) (see\n   Section 4.6.1).\n   JoinDesired(S,G)\
    \ is defined in Section 4.5.7 and indicates whether we\n   have the appropriate\
    \ (S,G) Join state to wish to send a Join(S,G)\n   upstream.\n   Basically, Update_SPTbit\
    \ will set the SPTbit if we have the\n   appropriate (S,G) join state, and if\
    \ the packet arrived on the\n   correct upstream interface for S, and if one or\
    \ more of the following\n   conditions applies:\n   1.  The source is directly\
    \ connected, in which case the switch to the\n       SPT is a no-op.\n   2.  The\
    \ RPF interface to S is different from the RPF interface to the\n       RP.  The\
    \ packet arrived on RPF_interface(S), and so the SPT must\n       have been completed.\n\
    \   3.  Noone wants the packet on the RP tree.\n   4.  RPF'(S,G) == RPF'(*,G).\
    \  In this case, the router will never be\n       able to tell if the SPT has\
    \ been completed, so it should just\n       switch immediately.\n   In the case\
    \ where the RPF interface is the same for the RP and for S,\n   but RPF'(S,G)\
    \ and RPF'(*,G) differ, we wait for an Assert(S,G), which\n   indicates that the\
    \ upstream router with (S,G) state believes the SPT\n   has been completed.  However,\
    \ item (3) above is needed because there\n   may not be any (*,G) state to trigger\
    \ an Assert(S,G) to happen.\n   The SPTbit is cleared in the (S,G) upstream state\
    \ machine (see\n   Section 4.5.7) when JoinDesired(S,G) becomes FALSE.\n"
- title: 4.3.  Designated Routers (DR) and Hello Messages
  contents:
  - "4.3.  Designated Routers (DR) and Hello Messages\n   A shared-media LAN like\
    \ Ethernet may have multiple PIM-SM routers\n   connected to it.  A single one\
    \ of these routers, the DR, will act on\n   behalf of directly connected hosts\
    \ with respect to the PIM-SM\n   protocol.  Because the distinction between LANs\
    \ and point-to-point\n   interfaces can sometimes be blurred, and because routers\
    \ may also\n   have multicast host functionality, the PIM-SM specification makes\
    \ no\n   distinction between the two.  Thus, DR election will happen on all\n\
    \   interfaces, LAN or otherwise.\n   DR election is performed using Hello messages.\
    \  Hello messages are\n   also the way that option negotiation takes place in\
    \ PIM, so that\n   additional functionality can be enabled, or parameters tuned.\n"
- title: 4.3.1.  Sending Hello Messages
  contents:
  - "4.3.1.  Sending Hello Messages\n   PIM Hello messages are sent periodically on\
    \ each PIM-enabled\n   interface.  They allow a router to learn about the neighboring\
    \ PIM\n   routers on each interface.  Hello messages are also the mechanism\n\
    \   used to elect a Designated Router (DR), and to negotiate additional\n   capabilities.\
    \  A router must record the Hello information received\n   from each PIM neighbor.\n\
    \   Hello messages MUST be sent on all active interfaces, including\n   physical\
    \ point-to-point links, and are multicast to the 'ALL-PIM-\n   ROUTERS' group\
    \ address ('224.0.0.13' for IPv4 and 'ff02::d' for\n   IPv6).\n     We note that\
    \ some implementations do not send Hello messages on\n     point-to-point interfaces.\
    \  This is non-compliant behavior.  A\n     compliant PIM router MUST send Hello\
    \ messages, even on point-to-\n     point interfaces.\n   A per-interface Hello\
    \ Timer (HT(I)) is used to trigger sending Hello\n   messages on each active interface.\
    \  When PIM is enabled on an\n   interface or a router first starts, the Hello\
    \ Timer of that interface\n   is set to a random value between 0 and Triggered_Hello_Delay.\
    \  This\n   prevents synchronization of Hello messages if multiple routers are\n\
    \   powered on simultaneously.  After the initial randomized interval,\n   Hello\
    \ messages must be sent every Hello_Period seconds.  The Hello\n   Timer should\
    \ not be reset except when it expires.\n   Note that neighbors will not accept\
    \ Join/Prune or Assert messages\n   from a router unless they have first heard\
    \ a Hello message from that\n   router.  Thus, if a router needs to send a Join/Prune\
    \ or Assert\n   message on an interface on which it has not yet sent a Hello message\n\
    \   with the currently configured IP address, then it MUST immediately\n   send\
    \ the relevant Hello message without waiting for the Hello Timer\n   to expire,\
    \ followed by the Join/Prune or Assert message.\n   The DR_Priority Option allows\
    \ a network administrator to give\n   preference to a particular router in the\
    \ DR election process by\n   giving it a numerically larger DR Priority.  The\
    \ DR_Priority Option\n   SHOULD be included in every Hello message, even if no\
    \ DR Priority is\n   explicitly configured on that interface.  This is necessary\
    \ because\n   priority-based DR election is only enabled when all neighbors on\
    \ an\n   interface advertise that they are capable of using the DR_Priority\n\
    \   Option.  The default priority is 1.\n   The Generation_Identifier (GenID)\
    \ Option SHOULD be included in all\n   Hello messages.  The GenID option contains\
    \ a randomly generated\n   32-bit value that is regenerated each time PIM forwarding\
    \ is started\n   or restarted on the interface, including when the router itself\n\
    \   restarts.  When a Hello message with a new GenID is received from a\n   neighbor,\
    \ any old Hello information about that neighbor SHOULD be\n   discarded and superseded\
    \ by the information from the new Hello\n   message.  This may cause a new DR\
    \ to be chosen on that interface.\n   The LAN Prune Delay Option SHOULD be included\
    \ in all Hello messages\n   sent on multi-access LANs.  This option advertises\
    \ a router's\n   capability to use values other than the defaults for the\n  \
    \ Propagation_Delay and Override_Interval, which affect the setting of\n   the\
    \ Prune-Pending, Upstream Join, and Override Timers (defined in\n   Section 4.10).\n\
    \   The Address List Option advertises all the secondary addresses\n   associated\
    \ with the source interface of the router originating the\n   message.  The option\
    \ MUST be included in all Hello messages if there\n   are secondary addresses\
    \ associated with the source interface and MAY\n   be omitted if no secondary\
    \ addresses exist.\n   To allow new or rebooting routers to learn of PIM neighbors\
    \ quickly,\n   when a Hello message is received from a new neighbor, or a Hello\n\
    \   message with a new GenID is received from an existing neighbor, a new\n  \
    \ Hello message should be sent on this interface after a randomized\n   delay\
    \ between 0 and Triggered_Hello_Delay.  This triggered message\n   need not change\
    \ the timing of the scheduled periodic message.  If a\n   router needs to send\
    \ a Join/Prune to the new neighbor or send an\n   Assert message in response to\
    \ an Assert message from the new neighbor\n   before this randomized delay has\
    \ expired, then it MUST immediately\n   send the relevant Hello message without\
    \ waiting for the Hello Timer\n   to expire, followed by the Join/Prune or Assert\
    \ message.  If it does\n   not do this, then the new neighbor will discard the\
    \ Join/Prune or\n   Assert message.\n   Before an interface goes down or changes\
    \ primary IP address, a Hello\n   message with a zero HoldTime should be sent\
    \ immediately (with the old\n   IP address if the IP address changed).  This will\
    \ cause PIM neighbors\n   to remove this neighbor (or its old IP address) immediately.\
    \  After\n   an interface has changed its IP address, it MUST send a Hello message\n\
    \   with its new IP address.  If an interface changes one of its\n   secondary\
    \ IP addresses, a Hello message with an updated Address_List\n   option and a\
    \ non-zero HoldTime should be sent immediately.  This will\n   cause PIM neighbors\
    \ to update this neighbor's list of secondary\n   addresses immediately.\n"
- title: 4.3.2.  DR Election
  contents:
  - "4.3.2.  DR Election\n   When a PIM Hello message is received on interface I,\
    \ the following\n   information about the sending neighbor is recorded:\n    \
    \ neighbor.interface\n          The interface on which the Hello message arrived.\n\
    \     neighbor.primary_ip_address\n          The IP address that the PIM neighbor\
    \ used as the source\n          address of the Hello message.\n     neighbor.genid\n\
    \          The Generation ID of the PIM neighbor.\n     neighbor.dr_priority\n\
    \          The DR Priority field of the PIM neighbor, if it is present in\n  \
    \        the Hello message.\n     neighbor.dr_priority_present\n          A flag\
    \ indicating if the DR Priority field was present in the\n          Hello message.\n\
    \     neighbor.timeout\n          A timer value to time out the neighbor state\
    \ when it becomes\n          stale, also known as the Neighbor Liveness Timer.\n\
    \          The Neighbor Liveness Timer (NLT(N,I)) is reset to\n          Hello_Holdtime\
    \ (from the Hello Holdtime option) whenever a\n          Hello message is received\
    \ containing a Holdtime option, or to\n          Default_Hello_Holdtime if the\
    \ Hello message does not contain\n          the Holdtime option.\n          Neighbor\
    \ state is deleted when the neighbor timeout expires.\n   The function for computing\
    \ the DR on interface I is:\n     host\n     DR(I) {\n         dr = me\n     \
    \    for each neighbor on interface I {\n             if ( dr_is_better( neighbor,\
    \ dr, I ) == TRUE ) {\n                 dr = neighbor\n             }\n      \
    \   }\n         return dr\n     }\n   The function used for comparing DR \"metrics\"\
    \ on interface I is:\n     bool\n     dr_is_better(a,b,I) {\n         if( there\
    \ is a neighbor n on I for which n.dr_priority_present\n                 is false\
    \ ) {\n             return a.primary_ip_address > b.primary_ip_address\n     \
    \    } else {\n             return ( a.dr_priority > b.dr_priority ) OR\n    \
    \                ( a.dr_priority == b.dr_priority AND\n                      a.primary_ip_address\
    \ > b.primary_ip_address )\n         }\n     }\n   The trivial function I_am_DR(I)\
    \ is defined to aid readability:\n     bool\n     I_am_DR(I) {\n        return\
    \ DR(I) == me\n     }\n   The DR Priority is a 32-bit unsigned number, and the\
    \ numerically\n   larger priority is always preferred.  A router's idea of the\
    \ current\n   DR on an interface can change when a PIM Hello message is received,\n\
    \   when a neighbor times out, or when a router's own DR Priority\n   changes.\
    \  If the router becomes the DR or ceases to be the DR, this\n   will normally\
    \ cause the DR Register state machine to change state.\n   Subsequent actions\
    \ are determined by that state machine.\n     We note that some PIM implementations\
    \ do not send Hello messages on\n     point-to-point interfaces and thus cannot\
    \ perform DR election on\n     such interfaces.  This is non-compliant behavior.\
    \  DR election MUST\n     be performed on ALL active PIM-SM interfaces.\n"
- title: 4.3.3.  Reducing Prune Propagation Delay on LANs
  contents:
  - "4.3.3.  Reducing Prune Propagation Delay on LANs\n   In addition to the information\
    \ recorded for the DR Election, the\n   following per neighbor information is\
    \ obtained from the LAN Prune\n   Delay Hello option:\n     neighbor.lan_prune_delay_present\n\
    \          A flag indicating if the LAN Prune Delay option was present in\n  \
    \        the Hello message.\n     neighbor.tracking_support\n          A flag\
    \ storing the value of the T bit in the LAN Prune Delay\n          option if it\
    \ is present in the Hello message.  This indicates\n          the neighbor's capability\
    \ to disable Join message suppression.\n     neighbor.propagation_delay\n    \
    \      The Propagation Delay field of the LAN Prune Delay option (if\n       \
    \   present) in the Hello message.\n     neighbor.override_interval\n        \
    \  The Override_Interval field of the LAN Prune Delay option (if\n          present)\
    \ in the Hello message.\n   The additional state described above is deleted along\
    \ with the DR\n   neighbor state when the neighbor timeout expires.\n   Just like\
    \ the DR_Priority option, the information provided in the LAN\n   Prune Delay\
    \ option is not used unless all neighbors on a link\n   advertise the option.\
    \  The function below computes this state:\n     bool\n     lan_delay_enabled(I)\
    \ {\n         for each neighbor on interface I {\n             if ( neighbor.lan_prune_delay_present\
    \ == false ) {\n                 return false\n             }\n         }\n  \
    \       return true\n     }\n   The Propagation Delay inserted by a router in\
    \ the LAN Prune Delay\n   option expresses the expected message propagation delay\
    \ on the link\n   and should be configurable by the system administrator.  It\
    \ is used\n   by upstream routers to figure out how long they should wait for\
    \ a\n   Join override message before pruning an interface.\n   PIM implementers\
    \ should enforce a lower bound on the permitted values\n   for this delay to allow\
    \ for scheduling and processing delays within\n   their router.  Such delays may\
    \ cause received messages to be\n   processed later as well as triggered messages\
    \ to be sent later than\n   intended.  Setting this Propagation Delay to too low\
    \ a value may\n   result in temporary forwarding outages because a downstream\
    \ router\n   will not be able to override a neighbor's Prune message before the\n\
    \   upstream neighbor stops forwarding.\n   When all routers on a link are in\
    \ a position to negotiate a\n   Propagation Delay different from the default,\
    \ the largest value from\n   those advertised by each neighbor is chosen.  The\
    \ function for\n   computing the Effective_Propagation_Delay of interface I is:\n\
    \     time_interval\n     Effective_Propagation_Delay(I) {\n         if ( lan_delay_enabled(I)\
    \ == false ) {\n             return Propagation_delay_default\n         }\n  \
    \       delay = Propagation_Delay(I)\n         for each neighbor on interface\
    \ I {\n             if ( neighbor.propagation_delay > delay ) {\n            \
    \     delay = neighbor.propagation_delay\n             }\n         }\n       \
    \  return delay\n     }\n   To avoid synchronization of override messages when\
    \ multiple\n   downstream routers share a multi-access link, sending of such\n\
    \   messages is delayed by a small random amount of time.  The period of\n   randomization\
    \ should represent the size of the PIM router population\n   on the link.  Each\
    \ router expresses its view of the amount of\n   randomization necessary in the\
    \ Override Interval field of the LAN\n   Prune Delay option.\n   When all routers\
    \ on a link are in a position to negotiate an Override\n   Interval different\
    \ from the default, the largest value from those\n   advertised by each neighbor\
    \ is chosen.  The function for computing\n   the Effective Override Interval of\
    \ interface I is:\n     time_interval\n     Effective_Override_Interval(I) {\n\
    \         if ( lan_delay_enabled(I) == false ) {\n             return t_override_default\n\
    \         }\n         delay = Override_Interval(I)\n         for each neighbor\
    \ on interface I {\n             if ( neighbor.override_interval > delay ) {\n\
    \                 delay = neighbor.override_interval\n             }\n       \
    \  }\n         return delay\n     }\n   Although the mechanisms are not specified\
    \ in this document, it is\n   possible for upstream routers to explicitly track\
    \ the join membership\n   of individual downstream routers if Join suppression\
    \ is disabled.  A\n   router can advertise its willingness to disable Join suppression\
    \ by\n   using the T bit in the LAN Prune Delay Hello option.  Unless all PIM\n\
    \   routers on a link negotiate this capability, explicit tracking and\n   the\
    \ disabling of the Join suppression mechanism are not possible.\n   The function\
    \ for computing the state of Suppression on interface I\n   is:\n     bool\n \
    \    Suppression_Enabled(I) {\n         if ( lan_delay_enabled(I) == false ) {\n\
    \             return true\n         }\n         for each neighbor on interface\
    \ I {\n             if ( neighbor.tracking_support == false ) {\n            \
    \     return true\n             }\n         }\n         return false\n     }\n\
    \   Note that the setting of Suppression_Enabled(I) affects the value of\n   t_suppressed\
    \ (see Section 4.10).\n"
- title: 4.3.4.  Maintaining Secondary Address Lists
  contents:
  - "4.3.4.  Maintaining Secondary Address Lists\n   Communication of a router's interface\
    \ secondary addresses to its PIM\n   neighbors is necessary to provide the neighbors\
    \ with a mechanism for\n   mapping next_hop information obtained through their\
    \ MRIB to a primary\n   address that can be used as a destination for Join/Prune\
    \ messages.\n   The mapping is performed through the NBR macro.  The primary address\n\
    \   of a PIM neighbor is obtained from the source IP address used in its\n   PIM\
    \ Hello messages.  Secondary addresses are carried within the Hello\n   message\
    \ in an Address List Hello option.  The primary address of the\n   source interface\
    \ of the router MUST NOT be listed within the Address\n   List Hello option.\n\
    \   In addition to the information recorded for the DR Election, the\n   following\
    \ per neighbor information is obtained from the Address List\n   Hello option:\n\
    \     neighbor.secondary_address_list\n          The list of secondary addresses\
    \ used by the PIM neighbor on\n          the interface through which the Hello\
    \ message was transmitted.\n   When processing a received PIM Hello message containing\
    \ an Address\n   List Hello option, the list of secondary addresses in the message\n\
    \   completely replaces any previously associated secondary addresses for\n  \
    \ that neighbor.  If a received PIM Hello message does not contain an\n   Address\
    \ List Hello option, then all secondary addresses associated\n   with the neighbor\
    \ must be deleted.  If a received PIM Hello message\n   contains an Address List\
    \ Hello option that includes the primary\n   address of the sending router in\
    \ the list of secondary addresses\n   (although this is not expected), then the\
    \ addresses listed in the\n   message, excluding the primary address, are used\
    \ to update the\n   associated secondary addresses for that neighbor.\n   All\
    \ the advertised secondary addresses in received Hello messages\n   must be checked\
    \ against those previously advertised by all other PIM\n   neighbors on that interface.\
    \  If there is a conflict and the same\n   secondary address was previously advertised\
    \ by another neighbor, then\n   only the most recently received mapping MUST be\
    \ maintained, and an\n   error message SHOULD be logged to the administrator in\
    \ a rate-limited\n   manner.\n   Within one Address List Hello option, all the\
    \ addresses MUST be of\n   the same address family.  It is not permitted to mix\
    \ IPv4 and IPv6\n   addresses within the same message.  In addition, the address\
    \ family\n   of the fields in the message SHOULD be the same as the IP source\
    \ and\n   destination addresses of the packet header.\n"
- title: 4.4.  PIM Register Messages
  contents:
  - "4.4.  PIM Register Messages\n   The Designated Router (DR) on a LAN or point-to-point\
    \ link\n   encapsulates multicast packets from local sources to the RP for the\n\
    \   relevant group unless it recently received a Register-Stop message\n   for\
    \ that (S,G) or (*,G) from the RP.  When the DR receives a\n   Register-Stop message\
    \ from the RP, it starts a Register-Stop Timer to\n   maintain this state.  Just\
    \ before the Register-Stop Timer expires,\n   the DR sends a Null-Register Message\
    \ to the RP to allow the RP to\n   refresh the Register-Stop information at the\
    \ DR.  If the Register-\n   Stop Timer actually expires, the DR will resume encapsulating\
    \ packets\n   from the source to the RP.\n"
- title: 4.4.1.  Sending Register Messages from the DR
  contents:
  - "4.4.1.  Sending Register Messages from the DR\n   Every PIM-SM router has the\
    \ capability to be a DR.  The state machine\n   below is used to implement Register\
    \ functionality.  For the purposes\n   of specification, we represent the mechanism\
    \ to encapsulate packets\n   to the RP as a Register-Tunnel interface, which is\
    \ added to or\n   removed from the (S,G) olist.  The tunnel interface then takes\
    \ part\n   in the normal packet forwarding rules as specified in Section 4.2.\n\
    \   If register state is maintained, it is maintained only for directly\n   connected\
    \ sources and is per-(S,G).  There are four states in the\n   DR's per-(S,G) Register\
    \ state machine:\n   Join (J)\n        The register tunnel is \"joined\" (the\
    \ join is actually implicit,\n        but the DR acts as if the RP has joined\
    \ the DR on the tunnel\n        interface).\n   Prune (P)\n        The register\
    \ tunnel is \"pruned\" (this occurs when a Register-\n        Stop is received).\n\
    \   Join-Pending (JP)\n        The register tunnel is pruned but the DR is contemplating\
    \ adding\n        it back.\n   NoInfo (NI)\n        No information.  This is the\
    \ initial state, and the state when\n        the router is not the DR.\n   In\
    \ addition, a Register-Stop Timer (RST) is kept if the state machine\n   is not\
    \ in the NoInfo state.\n   Figure 1: Per-(S,G) register state machine at a DR\
    \ in tabular form\n"
- title: +----------++----------------------------------------------------------+
  contents:
  - '+----------++----------------------------------------------------------+

    '
- title: '|          ||                          Event                           |'
  contents:
  - '|          ||                          Event                           |

    '
- title: '|          ++----------+-----------+-----------+-----------+-----------+'
  contents:
  - '|          ++----------+-----------+-----------+-----------+-----------+

    '
- title: '|Prev State||Register- | Could     | Could     | Register- | RP changed|'
  contents:
  - '|Prev State||Register- | Could     | Could     | Register- | RP changed|

    '
- title: '|          ||Stop Timer| Register  | Register  | Stop      |           |'
  contents:
  - '|          ||Stop Timer| Register  | Register  | Stop      |           |

    '
- title: '|          ||expires   | ->True    | ->False   | received  |           |'
  contents:
  - '|          ||expires   | ->True    | ->False   | received  |           |

    '
- title: +----------++----------+-----------+-----------+-----------+-----------+
  contents:
  - '+----------++----------+-----------+-----------+-----------+-----------+

    '
- title: '|NoInfo    ||-         | -> J state| -         | -         | -         |'
  contents:
  - '|NoInfo    ||-         | -> J state| -         | -         | -         |

    '
- title: '|(NI)      ||          | add reg   |           |           |           |'
  contents:
  - '|(NI)      ||          | add reg   |           |           |           |

    '
- title: '|          ||          | tunnel    |           |           |           |'
  contents:
  - '|          ||          | tunnel    |           |           |           |

    '
- title: +----------++----------+-----------+-----------+-----------+-----------+
  contents:
  - '+----------++----------+-----------+-----------+-----------+-----------+

    '
- title: '|          ||-         | -         | -> NI     | -> P state| -> J state|'
  contents:
  - '|          ||-         | -         | -> NI     | -> P state| -> J state|

    '
- title: '|          ||          |           | state     |           |           |'
  contents:
  - '|          ||          |           | state     |           |           |

    '
- title: '|          ||          |           | remove reg| remove reg| update reg|'
  contents:
  - '|          ||          |           | remove reg| remove reg| update reg|

    '
- title: '|Join (J)  ||          |           | tunnel    | tunnel;   | tunnel    |'
  contents:
  - '|Join (J)  ||          |           | tunnel    | tunnel;   | tunnel    |

    '
- title: '|          ||          |           |           | set       |           |'
  contents:
  - '|          ||          |           |           | set       |           |

    '
- title: '|          ||          |           |           | Register- |           |'
  contents:
  - '|          ||          |           |           | Register- |           |

    '
- title: '|          ||          |           |           | Stop      |           |'
  contents:
  - '|          ||          |           |           | Stop      |           |

    '
- title: '|          ||          |           |           | Timer(*)  |           |'
  contents:
  - '|          ||          |           |           | Timer(*)  |           |

    '
- title: +----------++----------+-----------+-----------+-----------+-----------+
  contents:
  - '+----------++----------+-----------+-----------+-----------+-----------+

    '
- title: '|          ||-> J state| -         | -> NI     | -> P state| -> J state|'
  contents:
  - '|          ||-> J state| -         | -> NI     | -> P state| -> J state|

    '
- title: '|          ||          |           | state     |           |           |'
  contents:
  - '|          ||          |           | state     |           |           |

    '
- title: '|Join-     ||add reg   |           |           | set       | add reg   |'
  contents:
  - '|Join-     ||add reg   |           |           | set       | add reg   |

    '
- title: '|Pending   ||tunnel    |           |           | Register- | tunnel;   |'
  contents:
  - '|Pending   ||tunnel    |           |           | Register- | tunnel;   |

    '
- title: '|(JP)      ||          |           |           | Stop      | cancel    |'
  contents:
  - '|(JP)      ||          |           |           | Stop      | cancel    |

    '
- title: '|          ||          |           |           | Timer(*)  | Register- |'
  contents:
  - '|          ||          |           |           | Timer(*)  | Register- |

    '
- title: '|          ||          |           |           |           | Stop Timer|'
  contents:
  - '|          ||          |           |           |           | Stop Timer|

    '
- title: +----------++----------+-----------+-----------+-----------+-----------+
  contents:
  - '+----------++----------+-----------+-----------+-----------+-----------+

    '
- title: '|          ||-> JP     | -         | -> NI     | -         | -> J state|'
  contents:
  - '|          ||-> JP     | -         | -> NI     | -         | -> J state|

    '
- title: '|          ||state     |           | state     |           |           |'
  contents:
  - '|          ||state     |           | state     |           |           |

    '
- title: '|          ||set       |           |           |           | add reg   |'
  contents:
  - '|          ||set       |           |           |           | add reg   |

    '
- title: '|Prune (P) ||Register- |           |           |           | tunnel;   |'
  contents:
  - '|Prune (P) ||Register- |           |           |           | tunnel;   |

    '
- title: '|          ||Stop      |           |           |           | cancel    |'
  contents:
  - '|          ||Stop      |           |           |           | cancel    |

    '
- title: '|          ||Timer(**);|           |           |           | Register- |'
  contents:
  - '|          ||Timer(**);|           |           |           | Register- |

    '
- title: '|          ||send Null-|           |           |           | Stop Timer|'
  contents:
  - '|          ||send Null-|           |           |           | Stop Timer|

    '
- title: '|          ||Register  |           |           |           |           |'
  contents:
  - '|          ||Register  |           |           |           |           |

    '
- title: +----------++----------+-----------+-----------+-----------+-----------+
  contents:
  - "+----------++----------+-----------+-----------+-----------+-----------+\n  \
    \ Notes:\n   (*)  The Register-Stop Timer is set to a random value chosen\n  \
    \      uniformly from the interval ( 0.5 * Register_Suppression_Time,\n      \
    \  1.5 * Register_Suppression_Time) minus Register_Probe_Time.\n        Subtracting\
    \ off Register_Probe_Time is a bit unnecessary because\n        it is really small\
    \ compared to Register_Suppression_Time, but\n        this was in the old spec\
    \ and is kept for compatibility.\n   (**) The Register-Stop Timer is set to Register_Probe_Time.\n\
    \   The following three actions are defined:\n   Add Register Tunnel\n      A\
    \ Register-Tunnel virtual interface, VI, is created (if it doesn't\n      already\
    \ exist) with its encapsulation target being RP(G).\n      DownstreamJPState(S,G,VI)\
    \ is set to Join state, causing the tunnel\n      interface to be added to immediate_olist(S,G)\
    \ and\n      inherited_olist(S,G).\n   Remove Register Tunnel\n      VI is the\
    \ Register-Tunnel virtual interface with encapsulation\n      target of RP(G).\
    \  DownstreamJPState(S,G,VI) is set to NoInfo\n      state, causing the tunnel\
    \ interface to be removed from\n      immediate_olist(S,G) and inherited_olist(S,G).\
    \  If\n      DownstreamJPState(S,G,VI) is NoInfo for all (S,G), then VI can be\n\
    \      deleted.\n   Update Register Tunnel\n      This action occurs when RP(G)\
    \ changes.\n      VI_old is the Register-Tunnel virtual interface with encapsulation\n\
    \      target old_RP(G).  A Register-Tunnel virtual interface, VI_new, is\n  \
    \    created (if it doesn't already exist) with its encapsulation\n      target\
    \ being new_RP(G).  DownstreamJPState(S,G,VI_old) is set to\n      NoInfo state\
    \ and DownstreamJPState(S,G,VI_new) is set to Join\n      state.  If DownstreamJPState(S,G,VI_old)\
    \ is NoInfo for all (S,G),\n      then VI_old can be deleted.\n      Note that\
    \ we cannot simply change the encapsulation target of\n      VI_old because not\
    \ all groups using that encapsulation tunnel will\n      have moved to the same\
    \ new RP.\n   CouldRegister(S,G)\n      The macro \"CouldRegister\" in the state\
    \ machine is defined as:\n      bool CouldRegister(S,G) {\n         return ( I_am_DR(\
    \ RPF_interface(S) ) AND\n                  KeepaliveTimer(S,G) is running AND\n\
    \                  DirectlyConnected(S) == TRUE )\n      }\n      Note that on\
    \ reception of a packet at the DR from a directly\n      connected source, KeepaliveTimer(S,G)\
    \ needs to be set by the\n      packet forwarding rules before computing CouldRegister(S,G)\
    \ in the\n      register state machine, or the first packet from a source won't\
    \ be\n      registered.\n   Encapsulating Data Packets in the Register Tunnel\n\
    \      Conceptually, the Register Tunnel is an interface with a smaller\n    \
    \  MTU than the underlying IP interface towards the RP.  IP\n      fragmentation\
    \ on packets forwarded on the Register Tunnel is\n      performed based upon this\
    \ smaller MTU.  The encapsulating DR may\n      perform Path MTU Discovery to\
    \ the RP to determine the effective\n      MTU of the tunnel.  Fragmentation for\
    \ the smaller MTU should take\n      both the outer IP header and the PIM register\
    \ header overhead into\n      account.  If a multicast packet is fragmented on\
    \ the way into the\n      Register Tunnel, each fragment is encapsulated individually\
    \ so it\n      contains IP, PIM, and inner IP headers.\n      In IPv6, the DR\
    \ MUST perform Path MTU discovery, and an ICMP\n      Packet Too Big message MUST\
    \ be sent by the encapsulating DR if it\n      receives a packet that will not\
    \ fit in the effective MTU of the\n      tunnel.  If the MTU between the DR and\
    \ the RP results in the\n      effective tunnel MTU being smaller than 1280 (the\
    \ IPv6 minimum\n      MTU), the DR MUST send Fragmentation Required messages with\
    \ an MTU\n      value of 1280 and MUST fragment its PIM register messages as\n\
    \      required, using an IPv6 fragmentation header between the outer\n      IPv6\
    \ header and the PIM Register header.\n      The TTL of a forwarded data packet\
    \ is decremented before it is\n      encapsulated in the Register Tunnel.  The\
    \ encapsulating packet\n      uses the normal TTL that the router would use for\
    \ any locally-\n      generated IP packet.\n      The IP ECN bits should be copied\
    \ from the original packet to the\n      IP header of the encapsulating packet.\
    \  They SHOULD NOT be set\n      independently by the encapsulating router.\n\
    \      The Diffserv Code Point (DSCP) should be copied from the original\n   \
    \   packet to the IP header of the encapsulating packet.  It MAY be\n      set\
    \ independently by the encapsulating router, based upon static\n      configuration\
    \ or traffic classification.  See [12] for more\n      discussion on setting the\
    \ DSCP on tunnels.\n   Handling Register-Stop(*,G) Messages at the DR\n      An\
    \ old RP might send a Register-Stop message with the source\n      address set\
    \ to all zeros.  This was the normal course of action in\n      RFC 2362 when\
    \ the Register message matched against (*,G) state at\n      the RP, and it was\
    \ defined as meaning \"stop encapsulating all\n      sources for this group\"\
    .  However, the behavior of such a\n      Register-Stop(*,G) is ambiguous or incorrect\
    \ in some\n      circumstances.\n      We specify that an RP should not send Register-Stop(*,G)\
    \ messages,\n      but for compatibility, a DR should be able to accept one if\
    \ it is\n      received.\n      A Register-Stop(*,G) should be treated as a Register-Stop(S,G)\
    \ for\n      all (S,G) Register state machines that are not in the NoInfo\n  \
    \    state.  A router should not apply a Register-Stop(*,G) to sources\n     \
    \ that become active after the Register-Stop(*,G) was received.\n"
- title: 4.4.2.  Receiving Register Messages at the RP
  contents:
  - "4.4.2.  Receiving Register Messages at the RP\n   When an RP receives a Register\
    \ message, the course of action is\n   decided according to the following pseudocode:\n\
    \   packet_arrives_on_rp_tunnel( pkt ) {\n       if( outer.dst is not one of my\
    \ addresses ) {\n           drop the packet silently.\n           # Note: this\
    \ may be a spoofing attempt\n       }\n       if( I_am_RP(G) AND outer.dst ==\
    \ RP(G) ) {\n             sentRegisterStop = FALSE;\n             if ( register.borderbit\
    \ == TRUE ) {\n                  if ( PMBR(S,G) == unknown ) {\n             \
    \          PMBR(S,G) = outer.src\n                  } else if ( outer.src != PMBR(S,G)\
    \ ) {\n                       send Register-Stop(S,G) to outer.src\n         \
    \              drop the packet silently.\n                  }\n             }\n\
    \             if ( SPTbit(S,G) OR\n              ( SwitchToSptDesired(S,G) AND\n\
    \                ( inherited_olist(S,G) == NULL ))) {\n               send Register-Stop(S,G)\
    \ to outer.src\n               sentRegisterStop = TRUE;\n             }\n    \
    \         if ( SPTbit(S,G) OR SwitchToSptDesired(S,G) ) {\n                  if\
    \ ( sentRegisterStop == TRUE ) {\n                       set KeepaliveTimer(S,G)\
    \ to RP_Keepalive_Period;\n                  } else {\n                      \
    \ set KeepaliveTimer(S,G) to Keepalive_Period;\n                  }\n        \
    \     }\n             if( !SPTbit(S,G) AND ! pkt.NullRegisterBit ) {\n       \
    \           decapsulate and forward the inner packet to\n                  inherited_olist(S,G,rpt)\
    \ # Note (+)\n             }\n       } else {\n           send Register-Stop(S,G)\
    \ to outer.src\n           # Note (*)\n       }\n   }\n   outer.dst is the IP\
    \ destination address of the encapsulating header.\n   outer.src is the IP source\
    \ address of the encapsulating header, i.e.,\n   the DR's address.\n   I_am_RP(G)\
    \ is true if the group-to-RP mapping indicates that this\n   router is the RP\
    \ for the group.\n   Note (*): This may block traffic from S for Register_Suppression_Time\n\
    \      if the DR learned about a new group-to-RP mapping before the RP\n     \
    \ did.  However, this doesn't matter unless we figure out some way\n      for\
    \ the RP also to accept (*,G) joins when it doesn't yet realize\n      that it\
    \ is about to become the RP for G.  This will all get sorted\n      out once the\
    \ RP learns the new group-to-rp mapping.  We decided to\n      do nothing about\
    \ this and just accept the fact that PIM may suffer\n      interrupted (*,G) connectivity\
    \ following an RP change.\n   Note (+): Implementations are advised not to make\
    \ this a special\n      case, but to arrange that this path rejoin the normal\
    \ packet\n      forwarding path.  All of the appropriate actions from the \"On\n\
    \      receipt of data from S to G on interface iif\" pseudocode in\n      Section\
    \ 4.2 should be performed.\n   KeepaliveTimer(S,G) is restarted at the RP when\
    \ packets arrive on the\n   proper tunnel interface and the RP desires to switch\
    \ to the SPT or\n   the SPTbit is already set.  This may cause the upstream (S,G)\
    \ state\n   machine to trigger a join if the inherited_olist(S,G) is not NULL.\n\
    \   An RP should preserve (S,G) state that was created in response to a\n   Register\
    \ message for at least ( 3 * Register_Suppression_Time );\n   otherwise, the RP\
    \ may stop joining (S,G) before the DR for S has\n   restarted sending registers.\
    \  Traffic would then be interrupted until\n   the Register-Stop Timer expires\
    \ at the DR.\n   Thus, at the RP, KeepaliveTimer(S,G) should be restarted to (\
    \ 3 *\n   Register_Suppression_Time + Register_Probe_Time ).\n   When forwarding\
    \ a packet from the Register Tunnel, the TTL of the\n   original data packet is\
    \ decremented after it is decapsulated.\n   The IP ECN bits should be copied from\
    \ the IP header of the Register\n   packet to the decapsulated packet.\n   The\
    \ Diffserv Code Point (DSCP) should be copied from the IP header of\n   the Register\
    \ packet to the decapsulated packet.  The RP MAY retain\n   the DSCP of the inner\
    \ packet or re-classify the packet and apply a\n   different DSCP.  Scenarios\
    \ where each of these might be useful are\n   discussed in [12].\n"
- title: 4.5.  PIM Join/Prune Messages
  contents:
  - "4.5.  PIM Join/Prune Messages\n   A PIM Join/Prune message consists of a list\
    \ of groups and a list of\n   Joined and Pruned sources for each group.  When\
    \ processing a received\n   Join/Prune message, each Joined or Pruned source for\
    \ a Group is\n   effectively considered individually, and applies to one or more\
    \ of\n   the following state machines.  When considering a Join/Prune message\n\
    \   whose Upstream Neighbor Address field addresses this router, (*,G)\n   Joins\
    \ and Prunes can affect both the (*,G) and (S,G,rpt) downstream\n   state machines,\
    \ while (*,*,RP), (S,G), and (S,G,rpt) Joins and Prunes\n   can only affect their\
    \ respective downstream state machines.  When\n   considering a Join/Prune message\
    \ whose Upstream Neighbor Address\n   field addresses another router, most Join\
    \ or Prune messages could\n   affect each upstream state machine.\n   In general,\
    \ a PIM Join/Prune message should only be accepted for\n   processing if it comes\
    \ from a known PIM neighbor.  A PIM router hears\n   about PIM neighbors through\
    \ PIM Hello messages.  If a router receives\n   a Join/Prune message from a particular\
    \ IP source address and it has\n   not seen a PIM Hello message from that source\
    \ address, then the\n   Join/Prune message SHOULD be discarded without further\
    \ processing.\n   In addition, if the Hello message from a neighbor was authenticated\n\
    \   using IPsec AH (see Section 6.3), then all Join/Prune messages from\n   that\
    \ neighbor MUST also be authenticated using IPsec AH.\n   We note that some older\
    \ PIM implementations incorrectly fail to send\n   Hello messages on point-to-point\
    \ interfaces, so we also RECOMMEND\n   that a configuration option be provided\
    \ to allow interoperation with\n   such older routers, but that this configuration\
    \ option SHOULD NOT be\n   enabled by default.\n"
- title: 4.5.1.  Receiving (*,*,RP) Join/Prune Messages
  contents:
  - "4.5.1.  Receiving (*,*,RP) Join/Prune Messages\n   The per-interface state machine\
    \ for receiving (*,*,RP) Join/Prune\n   Messages is given below.  There are three\
    \ states:\n     NoInfo (NI)\n          The interface has no (*,*,RP) Join state\
    \ and no timers\n          running.\n     Join (J)\n          The interface has\
    \ (*,*,RP) Join state, which will cause the\n          router to forward packets\
    \ destined for any group handled by RP\n          from this interface except if\
    \ there is also (S,G,rpt) prune\n          information (see Section 4.5.4) or\
    \ the router lost an assert\n          on this interface.\n     Prune-Pending\
    \ (PP)\n          The router has received a Prune(*,*,RP) on this interface from\n\
    \          a downstream neighbor and is waiting to see whether the prune\n   \
    \       will be overridden by another downstream router.  For\n          forwarding\
    \ purposes, the Prune-Pending state functions exactly\n          like the Join\
    \ state.\n   In addition, the state machine uses two timers:\n     ExpiryTimer\
    \ (ET)\n          This timer is restarted when a valid Join(*,*,RP) is received.\n\
    \          Expiry of the ExpiryTimer causes the interface state to revert\n  \
    \        to NoInfo for this RP.\n     Prune-Pending Timer (PPT)\n          This\
    \ timer is set when a valid Prune(*,*,RP) is received.\n          Expiry of the\
    \ Prune-Pending Timer causes the interface state\n          to revert to NoInfo\
    \ for this RP.\n       Figure 2: Downstream per-interface (*,*,RP) state machine\n\
    \                            in tabular form\n"
- title: +------------++--------------------------------------------------------+
  contents:
  - '+------------++--------------------------------------------------------+

    '
- title: '|            ||                          Event                         |'
  contents:
  - '|            ||                          Event                         |

    '
- title: '|            ++-------------+-------------+--------------+-------------+'
  contents:
  - '|            ++-------------+-------------+--------------+-------------+

    '
- title: '|Prev State  ||Receive      | Receive     | Prune-       | Expiry Timer|'
  contents:
  - '|Prev State  ||Receive      | Receive     | Prune-       | Expiry Timer|

    '
- title: '|            ||Join(*,*,RP) | Prune       | Pending      | Expires     |'
  contents:
  - '|            ||Join(*,*,RP) | Prune       | Pending      | Expires     |

    '
- title: '|            ||             | (*,*,RP)    | Timer        |             |'
  contents:
  - '|            ||             | (*,*,RP)    | Timer        |             |

    '
- title: '|            ||             |             | Expires      |             |'
  contents:
  - '|            ||             |             | Expires      |             |

    '
- title: +------------++-------------+-------------+--------------+-------------+
  contents:
  - '+------------++-------------+-------------+--------------+-------------+

    '
- title: '|            ||-> J state   | -> NI state | -            | -           |'
  contents:
  - '|            ||-> J state   | -> NI state | -            | -           |

    '
- title: '|NoInfo (NI) ||start Expiry |             |              |             |'
  contents:
  - '|NoInfo (NI) ||start Expiry |             |              |             |

    '
- title: '|            ||Timer        |             |              |             |'
  contents:
  - '|            ||Timer        |             |              |             |

    '
- title: +------------++-------------+-------------+--------------+-------------+
  contents:
  - '+------------++-------------+-------------+--------------+-------------+

    '
- title: '|            ||-> J state   | -> PP state | -            | -> NI state |'
  contents:
  - '|            ||-> J state   | -> PP state | -            | -> NI state |

    '
- title: '|Join (J)    ||restart      | start Prune-|              |             |'
  contents:
  - '|Join (J)    ||restart      | start Prune-|              |             |

    '
- title: '|            ||Expiry Timer | Pending     |              |             |'
  contents:
  - '|            ||Expiry Timer | Pending     |              |             |

    '
- title: '|            ||             | Timer       |              |             |'
  contents:
  - '|            ||             | Timer       |              |             |

    '
- title: +------------++-------------+-------------+--------------+-------------+
  contents:
  - '+------------++-------------+-------------+--------------+-------------+

    '
- title: '|Prune-      ||-> J state   | -> PP state | -> NI state  | -> NI state |'
  contents:
  - '|Prune-      ||-> J state   | -> PP state | -> NI state  | -> NI state |

    '
- title: '|Pending (PP)||restart      |             | Send Prune-  |             |'
  contents:
  - '|Pending (PP)||restart      |             | Send Prune-  |             |

    '
- title: '|            ||Expiry Timer |             | Echo(*,*,RP) |             |'
  contents:
  - '|            ||Expiry Timer |             | Echo(*,*,RP) |             |

    '
- title: +------------++-------------+-------------+--------------+-------------+
  contents:
  - "+------------++-------------+-------------+--------------+-------------+\n  \
    \ The transition events \"Receive Join(*,*,RP)\" and \"Receive\n   Prune(*,*,RP)\"\
    \ imply receiving a Join or Prune targeted to this\n   router's primary IP address\
    \ on the received interface.  If the\n   upstream neighbor address field is not\
    \ correct, these state\n   transitions in this state machine must not occur, although\
    \ seeing\n   such a packet may cause state transitions in other state machines.\n\
    \   On unnumbered interfaces on point-to-point links, the router's\n   address\
    \ should be the same as the source address it chose for the\n   Hello message\
    \ it sent over that interface.  However, on point-to-\n   point links we also\
    \ recommend that for backwards compatibility PIM\n   Join/Prune messages with\
    \ an upstream neighbor address field of all\n   zeros are also accepted.\n   Transitions\
    \ from NoInfo State\n   When in NoInfo state, the following event may trigger\
    \ a transition:\n     Receive Join(*,*,RP)\n          A Join(*,*,RP) is received\
    \ on interface I with its Upstream\n          Neighbor Address set to the router's\
    \ primary IP address on I.\n          The (*,*,RP) downstream state machine on\
    \ interface I\n          transitions to the Join state.  The Expiry Timer (ET)\
    \ is\n          started and set to the HoldTime from the triggering Join/Prune\n\
    \          message.\n          Note that it is possible to receive a Join(*,*,RP)\
    \ message for\n          an RP for which we do not have information telling us\
    \ that it\n          is an RP.  In the case of (*,*,RP) state, so long as we have\
    \ a\n          route to the RP, this will not cause a problem, and the\n     \
    \     transition should still take place.\n   Transitions from Join State\n  \
    \ When in Join state, the following events may trigger a transition:\n     Receive\
    \ Join(*,*,RP)\n          A Join(*,*,RP) is received on interface I with its Upstream\n\
    \          Neighbor Address set to the router's primary IP address on I.\n   \
    \       The (*,*,RP) downstream state machine on interface I remains\n       \
    \   in Join state, and the Expiry Timer (ET) is restarted, set to\n          maximum\
    \ of its current value and the HoldTime from the\n          triggering Join/Prune\
    \ message.\n     Receive Prune(*,*,RP)\n          A Prune(*,*,RP) is received\
    \ on interface I with its Upstream\n          Neighbor Address set to the router's\
    \ primary IP address on I.\n          The (*,*,RP) downstream state machine on\
    \ interface I\n          transitions to the Prune-Pending state.  The Prune-Pending\n\
    \          Timer is started.  It is set to the J/P_Override_Interval(I)\n    \
    \      if the router has more than one neighbor on that interface;\n         \
    \ otherwise, it is set to zero, causing it to expire\n          immediately.\n\
    \     Expiry Timer Expires\n          The Expiry Timer for the (*,*,RP) downstream\
    \ state machine on\n          interface I expires.\n          The (*,*,RP) downstream\
    \ state machine on interface I\n          transitions to the NoInfo state.\n \
    \  Transitions from Prune-Pending State\n   When in Prune-Pending state, the following\
    \ events may trigger a\n   transition:\n     Receive Join(*,*,RP)\n          A\
    \ Join(*,*,RP) is received on interface I with its Upstream\n          Neighbor\
    \ Address set to the router's primary IP address on I.\n          The (*,*,RP)\
    \ downstream state machine on interface I\n          transitions to the Join state.\
    \  The Prune-Pending Timer is\n          canceled (without triggering an expiry\
    \ event).  The Expiry\n          Timer is restarted, set to maximum of its current\
    \ value and\n          the HoldTime from the triggering Join/Prune message.\n\
    \     Expiry Timer Expires\n          The Expiry Timer for the (*,*,RP) downstream\
    \ state machine on\n          interface I expires.\n          The (*,*,RP) downstream\
    \ state machine on interface I\n          transitions to the NoInfo state.\n \
    \    Prune-Pending Timer Expires\n          The Prune-Pending Timer for the (*,*,RP)\
    \ downstream state\n          machine on interface I expires.\n          The (*,*,RP)\
    \ downstream state machine on interface I\n          transitions to the NoInfo\
    \ state.  A PruneEcho(*,*,RP) is sent\n          onto the subnet connected to\
    \ interface I.\n          The action \"Send PruneEcho(*,*,RP)\" is triggered when\
    \ the\n          router stops forwarding on an interface as a result of a\n  \
    \        prune.  A PruneEcho(*,*,RP) is simply a Prune(*,*,RP) message\n     \
    \     sent by the upstream router on a LAN with its own address in\n         \
    \ the Upstream Neighbor Address field.  Its purpose is to add\n          additional\
    \ reliability so that if a Prune that should have\n          been overridden by\
    \ another router is lost locally on the LAN,\n          then the PruneEcho may\
    \ be received and cause the override to\n          happen.  A PruneEcho(*,*,RP)\
    \ need not be sent on an interface\n          that contains only a single PIM\
    \ neighbor during the time this\n          state machine was in Prune-Pending\
    \ state.\n"
- title: 4.5.2.  Receiving (*,G) Join/Prune Messages
  contents:
  - "4.5.2.  Receiving (*,G) Join/Prune Messages\n   When a router receives a Join(*,G),\
    \ it must first check to see\n   whether the RP in the message matches RP(G) (the\
    \ router's idea of who\n   the RP is).  If the RP in the message does not match\
    \ RP(G), the\n   Join(*,G) should be silently dropped.  (Note that other source\
    \ list\n   entries, such as (S,G,rpt) or (S,G), in the same Group-Specific Set\n\
    \   should still be processed.)  If a router has no RP information (e.g.,\n  \
    \ has not recently received a BSR message), then it may choose to\n   accept Join(*,G)\
    \ and treat the RP in the message as RP(G).  Received\n   Prune(*,G) messages\
    \ are processed even if the RP in the message does\n   not match RP(G).\n   The\
    \ per-interface state machine for receiving (*,G) Join/Prune\n   Messages is given\
    \ below.  There are three states:\n     NoInfo (NI)\n          The interface has\
    \ no (*,G) Join state and no timers running.\n     Join (J)\n          The interface\
    \ has (*,G) Join state, which will cause the\n          router to forward packets\
    \ destined for G from this interface\n          except if there is also (S,G,rpt)\
    \ prune information (see\n          Section 4.5.4) or the router lost an assert\
    \ on this interface.\n     Prune-Pending (PP)\n          The router has received\
    \ a Prune(*,G) on this interface from a\n          downstream neighbor and is\
    \ waiting to see whether the prune\n          will be overridden by another downstream\
    \ router.  For\n          forwarding purposes, the Prune-Pending state functions\
    \ exactly\n          like the Join state.\n   In addition, the state machine uses\
    \ two timers:\n     Expiry Timer (ET)\n          This timer is restarted when\
    \ a valid Join(*,G) is received.\n          Expiry of the Expiry Timer causes\
    \ the interface state to\n          revert to NoInfo for this group.\n     Prune-Pending\
    \ Timer (PPT)\n          This timer is set when a valid Prune(*,G) is received.\
    \  Expiry\n          of the Prune-Pending Timer causes the interface state to\n\
    \          revert to NoInfo for this group.\n Figure 3: Downstream per-interface\
    \ (*,G) state machine in tabular form\n"
- title: +------------++--------------------------------------------------------+
  contents:
  - '+------------++--------------------------------------------------------+

    '
- title: '|            ||                         Event                          |'
  contents:
  - '|            ||                         Event                          |

    '
- title: '|            ++-------------+--------------+-------------+-------------+'
  contents:
  - '|            ++-------------+--------------+-------------+-------------+

    '
- title: '|Prev State  ||Receive      | Receive      | Prune-      | Expiry Timer|'
  contents:
  - '|Prev State  ||Receive      | Receive      | Prune-      | Expiry Timer|

    '
- title: '|            ||Join(*,G)    | Prune(*,G)   | Pending     | Expires     |'
  contents:
  - '|            ||Join(*,G)    | Prune(*,G)   | Pending     | Expires     |

    '
- title: '|            ||             |              | Timer       |             |'
  contents:
  - '|            ||             |              | Timer       |             |

    '
- title: '|            ||             |              | Expires     |             |'
  contents:
  - '|            ||             |              | Expires     |             |

    '
- title: +------------++-------------+--------------+-------------+-------------+
  contents:
  - '+------------++-------------+--------------+-------------+-------------+

    '
- title: '|            ||-> J state   | -> NI state  | -           | -           |'
  contents:
  - '|            ||-> J state   | -> NI state  | -           | -           |

    '
- title: '|NoInfo (NI) ||start Expiry |              |             |             |'
  contents:
  - '|NoInfo (NI) ||start Expiry |              |             |             |

    '
- title: '|            ||Timer        |              |             |             |'
  contents:
  - '|            ||Timer        |              |             |             |

    '
- title: +------------++-------------+--------------+-------------+-------------+
  contents:
  - '+------------++-------------+--------------+-------------+-------------+

    '
- title: '|            ||-> J state   | -> PP state  | -           | -> NI state |'
  contents:
  - '|            ||-> J state   | -> PP state  | -           | -> NI state |

    '
- title: '|Join (J)    ||restart      | start Prune- |             |             |'
  contents:
  - '|Join (J)    ||restart      | start Prune- |             |             |

    '
- title: '|            ||Expiry Timer | Pending      |             |             |'
  contents:
  - '|            ||Expiry Timer | Pending      |             |             |

    '
- title: '|            ||             | Timer        |             |             |'
  contents:
  - '|            ||             | Timer        |             |             |

    '
- title: +------------++-------------+--------------+-------------+-------------+
  contents:
  - '+------------++-------------+--------------+-------------+-------------+

    '
- title: '|Prune-      ||-> J state   | -> PP state  | -> NI state | -> NI state |'
  contents:
  - '|Prune-      ||-> J state   | -> PP state  | -> NI state | -> NI state |

    '
- title: '|Pending (PP)||restart      |              | Send Prune- |             |'
  contents:
  - '|Pending (PP)||restart      |              | Send Prune- |             |

    '
- title: '|            ||Expiry Timer |              | Echo(*,G)   |             |'
  contents:
  - '|            ||Expiry Timer |              | Echo(*,G)   |             |

    '
- title: +------------++-------------+--------------+-------------+-------------+
  contents:
  - "+------------++-------------+--------------+-------------+-------------+\n  \
    \ The transition events \"Receive Join(*,G)\" and \"Receive Prune(*,G)\"\n   imply\
    \ receiving a Join or Prune targeted to this router's primary IP\n   address on\
    \ the received interface.  If the upstream neighbor address\n   field is not correct,\
    \ these state transitions in this state machine\n   must not occur, although seeing\
    \ such a packet may cause state\n   transitions in other state machines.\n   On\
    \ unnumbered interfaces on point-to-point links, the router's\n   address should\
    \ be the same as the source address it chose for the\n   Hello message it sent\
    \ over that interface.  However, on point-to-\n   point links we also recommend\
    \ that for backwards compatibility PIM\n   Join/Prune messages with an upstream\
    \ neighbor address field of all\n   zeros are also accepted.\n   Transitions from\
    \ NoInfo State\n   When in NoInfo state, the following event may trigger a transition:\n\
    \     Receive Join(*,G)\n          A Join(*,G) is received on interface I with\
    \ its Upstream\n          Neighbor Address set to the router's primary IP address\
    \ on I.\n          The (*,G) downstream state machine on interface I transitions\n\
    \          to the Join state.  The Expiry Timer (ET) is started and set\n    \
    \      to the HoldTime from the triggering Join/Prune message.\n   Transitions\
    \ from Join State\n   When in Join state, the following events may trigger a transition:\n\
    \     Receive Join(*,G)\n          A Join(*,G) is received on interface I with\
    \ its Upstream\n          Neighbor Address set to the router's primary IP address\
    \ on I.\n          The (*,G) downstream state machine on interface I remains in\n\
    \          Join state, and the Expiry Timer (ET) is restarted, set to\n      \
    \    maximum of its current value and the HoldTime from the\n          triggering\
    \ Join/Prune message.\n     Receive Prune(*,G)\n          A Prune(*,G) is received\
    \ on interface I with its Upstream\n          Neighbor Address set to the router's\
    \ primary IP address on I.\n          The (*,G) downstream state machine on interface\
    \ I transitions\n          to the Prune-Pending state.  The Prune-Pending Timer\
    \ is\n          started.  It is set to the J/P_Override_Interval(I) if the\n \
    \         router has more than one neighbor on that interface;\n          otherwise,\
    \ it is set to zero, causing it to expire\n          immediately.\n     Expiry\
    \ Timer Expires\n          The Expiry Timer for the (*,G) downstream state machine\
    \ on\n          interface I expires.\n          The (*,G) downstream state machine\
    \ on interface I transitions\n          to the NoInfo state.\n   Transitions from\
    \ Prune-Pending State\n   When in Prune-Pending state, the following events may\
    \ trigger a\n   transition:\n     Receive Join(*,G)\n          A Join(*,G) is\
    \ received on interface I with its Upstream\n          Neighbor Address set to\
    \ the router's primary IP address on I.\n          The (*,G) downstream state\
    \ machine on interface I transitions\n          to the Join state.  The Prune-Pending\
    \ Timer is canceled\n          (without triggering an expiry event).  The Expiry\
    \ Timer is\n          restarted, set to maximum of its current value and the\n\
    \          HoldTime from the triggering Join/Prune message.\n     Expiry Timer\
    \ Expires\n          The Expiry Timer for the (*,G) downstream state machine on\n\
    \          interface I expires.\n          The (*,G) downstream state machine\
    \ on interface I transitions\n          to the NoInfo state.\n     Prune-Pending\
    \ Timer Expires\n          The Prune-Pending Timer for the (*,G) downstream state\
    \ machine\n          on interface I expires.\n          The (*,G) downstream state\
    \ machine on interface I transitions\n          to the NoInfo state.  A PruneEcho(*,G)\
    \ is sent onto the subnet\n          connected to interface I.\n          The\
    \ action \"Send PruneEcho(*,G)\" is triggered when the router\n          stops\
    \ forwarding on an interface as a result of a prune.  A\n          PruneEcho(*,G)\
    \ is simply a Prune(*,G) message sent by the\n          upstream router on a LAN\
    \ with its own address in the Upstream\n          Neighbor Address field.  Its\
    \ purpose is to add additional\n          reliability so that if a Prune that\
    \ should have been\n          overridden by another router is lost locally on\
    \ the LAN, then\n          the PruneEcho may be received and cause the override\
    \ to\n          happen.  A PruneEcho(*,G) need not be sent on an interface\n \
    \         that contains only a single PIM neighbor during the time this\n    \
    \      state machine was in Prune-Pending state.\n"
- title: 4.5.3.  Receiving (S,G) Join/Prune Messages
  contents:
  - "4.5.3.  Receiving (S,G) Join/Prune Messages\n   The per-interface state machine\
    \ for receiving (S,G) Join/Prune\n   messages is given below and is almost identical\
    \ to that for (*,G)\n   messages.  There are three states:\n     NoInfo (NI)\n\
    \          The interface has no (S,G) Join state and no (S,G) timers\n       \
    \   running.\n     Join (J)\n          The interface has (S,G) Join state, which\
    \ will cause the\n          router to forward packets from S destined for G from\
    \ this\n          interface if the (S,G) state is active (the SPTbit is set)\n\
    \          except if the router lost an assert on this interface.\n     Prune-Pending\
    \ (PP)\n          The router has received a Prune(S,G) on this interface from\
    \ a\n          downstream neighbor and is waiting to see whether the prune\n \
    \         will be overridden by another downstream router.  For\n          forwarding\
    \ purposes, the Prune-Pending state functions exactly\n          like the Join\
    \ state.\n   In addition, there are two timers:\n     Expiry Timer (ET)\n    \
    \      This timer is set when a valid Join(S,G) is received.  Expiry\n       \
    \   of the Expiry Timer causes this state machine to revert to\n          NoInfo\
    \ state.\n     Prune-Pending Timer (PPT)\n          This timer is set when a valid\
    \ Prune(S,G) is received.  Expiry\n          of the Prune-Pending Timer causes\
    \ this state machine to revert\n          to NoInfo state.\n Figure 4: Downstream\
    \ per-interface (S,G) state machine in tabular form\n"
- title: +------------++--------------------------------------------------------+
  contents:
  - '+------------++--------------------------------------------------------+

    '
- title: '|            ||                         Event                          |'
  contents:
  - '|            ||                         Event                          |

    '
- title: '|            ++-------------+--------------+-------------+-------------+'
  contents:
  - '|            ++-------------+--------------+-------------+-------------+

    '
- title: '|Prev State  ||Receive      | Receive      | Prune-      | Expiry Timer|'
  contents:
  - '|Prev State  ||Receive      | Receive      | Prune-      | Expiry Timer|

    '
- title: '|            ||Join(S,G)    | Prune(S,G)   | Pending     | Expires     |'
  contents:
  - '|            ||Join(S,G)    | Prune(S,G)   | Pending     | Expires     |

    '
- title: '|            ||             |              | Timer       |             |'
  contents:
  - '|            ||             |              | Timer       |             |

    '
- title: '|            ||             |              | Expires     |             |'
  contents:
  - '|            ||             |              | Expires     |             |

    '
- title: +------------++-------------+--------------+-------------+-------------+
  contents:
  - '+------------++-------------+--------------+-------------+-------------+

    '
- title: '|            ||-> J state   | -> NI state  | -           | -           |'
  contents:
  - '|            ||-> J state   | -> NI state  | -           | -           |

    '
- title: '|NoInfo (NI) ||start Expiry |              |             |             |'
  contents:
  - '|NoInfo (NI) ||start Expiry |              |             |             |

    '
- title: '|            ||Timer        |              |             |             |'
  contents:
  - '|            ||Timer        |              |             |             |

    '
- title: +------------++-------------+--------------+-------------+-------------+
  contents:
  - '+------------++-------------+--------------+-------------+-------------+

    '
- title: '|            ||-> J state   | -> PP state  | -           | -> NI state |'
  contents:
  - '|            ||-> J state   | -> PP state  | -           | -> NI state |

    '
- title: '|Join (J)    ||restart      | start Prune- |             |             |'
  contents:
  - '|Join (J)    ||restart      | start Prune- |             |             |

    '
- title: '|            ||Expiry Timer | Pending      |             |             |'
  contents:
  - '|            ||Expiry Timer | Pending      |             |             |

    '
- title: '|            ||             | Timer        |             |             |'
  contents:
  - '|            ||             | Timer        |             |             |

    '
- title: +------------++-------------+--------------+-------------+-------------+
  contents:
  - '+------------++-------------+--------------+-------------+-------------+

    '
- title: '|Prune-      ||-> J state   | -> PP state  | -> NI state | -> NI state |'
  contents:
  - '|Prune-      ||-> J state   | -> PP state  | -> NI state | -> NI state |

    '
- title: '|Pending (PP)||restart      |              | Send Prune- |             |'
  contents:
  - '|Pending (PP)||restart      |              | Send Prune- |             |

    '
- title: '|            ||Expiry Timer |              | Echo(S,G)   |             |'
  contents:
  - '|            ||Expiry Timer |              | Echo(S,G)   |             |

    '
- title: +------------++-------------+--------------+-------------+-------------+
  contents:
  - "+------------++-------------+--------------+-------------+-------------+\n  \
    \ The transition events \"Receive Join(S,G)\" and \"Receive Prune(S,G)\"\n   imply\
    \ receiving a Join or Prune targeted to this router's primary IP\n   address on\
    \ the received interface.  If the upstream neighbor address\n   field is not correct,\
    \ these state transitions in this state machine\n   must not occur, although seeing\
    \ such a packet may cause state\n   transitions in other state machines.\n   On\
    \ unnumbered interfaces on point-to-point links, the router's\n   address should\
    \ be the same as the source address it chose for the\n   Hello message it sent\
    \ over that interface.  However, on point-to-\n   point links we also recommend\
    \ that for backwards compatibility PIM\n   Join/Prune messages with an upstream\
    \ neighbor address field of all\n   zeros are also accepted.\n   Transitions from\
    \ NoInfo State\n   When in NoInfo state, the following event may trigger a transition:\n\
    \     Receive Join(S,G)\n          A Join(S,G) is received on interface I with\
    \ its Upstream\n          Neighbor Address set to the router's primary IP address\
    \ on I.\n          The (S,G) downstream state machine on interface I transitions\n\
    \          to the Join state.  The Expiry Timer (ET) is started and set\n    \
    \      to the HoldTime from the triggering Join/Prune message.\n   Transitions\
    \ from Join State\n   When in Join state, the following events may trigger a transition:\n\
    \     Receive Join(S,G)\n          A Join(S,G) is received on interface I with\
    \ its Upstream\n          Neighbor Address set to the router's primary IP address\
    \ on I.\n          The (S,G) downstream state machine on interface I remains in\n\
    \          Join state, and the Expiry Timer (ET) is restarted, set to\n      \
    \    maximum of its current value and the HoldTime from the\n          triggering\
    \ Join/Prune message.\n     Receive Prune(S,G)\n          A Prune(S,G) is received\
    \ on interface I with its Upstream\n          Neighbor Address set to the router's\
    \ primary IP address on I.\n          The (S,G) downstream state machine on interface\
    \ I transitions\n          to the Prune-Pending state.  The Prune-Pending Timer\
    \ is\n          started.  It is set to the J/P_Override_Interval(I) if the\n \
    \         router has more than one neighbor on that interface;\n          otherwise,\
    \ it is set to zero, causing it to expire\n          immediately.\n     Expiry\
    \ Timer Expires\n          The Expiry Timer for the (S,G) downstream state machine\
    \ on\n          interface I expires.\n          The (S,G) downstream state machine\
    \ on interface I transitions\n          to the NoInfo state.\n   Transitions from\
    \ Prune-Pending State\n   When in Prune-Pending state, the following events may\
    \ trigger a\n   transition:\n     Receive Join(S,G)\n          A Join(S,G) is\
    \ received on interface I with its Upstream\n          Neighbor Address set to\
    \ the router's primary IP address on I.\n          The (S,G) downstream state\
    \ machine on interface I transitions\n          to the Join state.  The Prune-Pending\
    \ Timer is canceled\n          (without triggering an expiry event).  The Expiry\
    \ Timer is\n          restarted, set to maximum of its current value and the\n\
    \          HoldTime from the triggering Join/Prune message.\n     Expiry Timer\
    \ Expires\n          The Expiry Timer for the (S,G) downstream state machine on\n\
    \          interface I expires.\n          The (S,G) downstream state machine\
    \ on interface I transitions\n          to the NoInfo state.\n     Prune-Pending\
    \ Timer Expires\n          The Prune-Pending Timer for the (S,G) downstream state\
    \ machine\n          on interface I expires.\n          The (S,G) downstream state\
    \ machine on interface I transitions\n          to the NoInfo state.  A PruneEcho(S,G)\
    \ is sent onto the subnet\n          connected to interface I.\n          The\
    \ action \"Send PruneEcho(S,G)\" is triggered when the router\n          stops\
    \ forwarding on an interface as a result of a prune.  A\n          PruneEcho(S,G)\
    \ is simply a Prune(S,G) message sent by the\n          upstream router on a LAN\
    \ with its own address in the Upstream\n          Neighbor Address field.  Its\
    \ purpose is to add additional\n          reliability so that if a Prune that\
    \ should have been\n          overridden by another router is lost locally on\
    \ the LAN, then\n          the PruneEcho may be received and cause the override\
    \ to\n          happen.  A PruneEcho(S,G) need not be sent on an interface\n \
    \         that contains only a single PIM neighbor during the time this\n    \
    \      state machine was in Prune-Pending state.\n"
- title: 4.5.4.  Receiving (S,G,rpt) Join/Prune Messages
  contents:
  - "4.5.4.  Receiving (S,G,rpt) Join/Prune Messages\n   The per-interface state machine\
    \ for receiving (S,G,rpt) Join/Prune\n   messages is given below.  There are five\
    \ states:\n     NoInfo (NI)\n          The interface has no (S,G,rpt) Prune state\
    \ and no (S,G,rpt)\n          timers running.\n     Prune (P)\n          The interface\
    \ has (S,G,rpt) Prune state, which will cause the\n          router not to forward\
    \ packets from S destined for G from this\n          interface even though the\
    \ interface has active (*,G) Join\n          state.\n     Prune-Pending (PP)\n\
    \          The router has received a Prune(S,G,rpt) on this interface\n      \
    \    from a downstream neighbor and is waiting to see whether the\n          prune\
    \ will be overridden by another downstream router.  For\n          forwarding\
    \ purposes, the Prune-Pending state functions exactly\n          like the NoInfo\
    \ state.\n     PruneTmp (P')\n          This state is a transient state that for\
    \ forwarding purposes\n          behaves exactly like the Prune state.  A (*,G)\
    \ Join has been\n          received (which may cancel the (S,G,rpt) Prune).  As\
    \ we parse\n          the Join/Prune message from top to bottom, we first enter\
    \ this\n          state if the message contains a (*,G) Join.  Later in the\n\
    \          message, we will normally encounter an (S,G,rpt) prune to\n       \
    \   reinstate the Prune state.  However, if we reach the end of\n          the\
    \ message without encountering such a (S,G,rpt) prune, then\n          we will\
    \ revert to NoInfo state in this state machine.\n          As no time is spent\
    \ in this state, no timers can expire.\n     Prune-Pending-Tmp (PP')\n       \
    \   This state is a transient state that is identical to P' except\n         \
    \ that it is associated with the PP state rather than the P\n          state.\
    \  For forwarding purposes, PP' behaves exactly like PP\n          state.\n  \
    \ In addition, there are two timers:\n     Expiry Timer (ET)\n          This timer\
    \ is set when a valid Prune(S,G,rpt) is received.\n          Expiry of the Expiry\
    \ Timer causes this state machine to revert\n          to NoInfo state.\n    \
    \ Prune-Pending Timer (PPT)\n          This timer is set when a valid Prune(S,G,rpt)\
    \ is received.\n          Expiry of the Prune-Pending Timer causes this state\
    \ machine to\n          move on to Prune state.\n      Figure 5: Downstream per-interface\
    \ (S,G,rpt) state machine\n                            in tabular form\n"
- title: +----------++----------------------------------------------------------+
  contents:
  - '+----------++----------------------------------------------------------+

    '
- title: '|          ||                          Event                           |'
  contents:
  - '|          ||                          Event                           |

    '
- title: '|          ++---------+----------+----------+--------+--------+--------+'
  contents:
  - '|          ++---------+----------+----------+--------+--------+--------+

    '
- title: '|Prev      ||Receive  | Receive  | Receive  | End of | Prune- | Expiry |'
  contents:
  - '|Prev      ||Receive  | Receive  | Receive  | End of | Prune- | Expiry |

    '
- title: '|State     ||Join(*,G)| Join     | Prune    | Message| Pending| Timer  |'
  contents:
  - '|State     ||Join(*,G)| Join     | Prune    | Message| Pending| Timer  |

    '
- title: '|          ||         | (S,G,rpt)| (S,G,rpt)|        | Timer  | Expires|'
  contents:
  - '|          ||         | (S,G,rpt)| (S,G,rpt)|        | Timer  | Expires|

    '
- title: '|          ||         |          |          |        | Expires|        |'
  contents:
  - '|          ||         |          |          |        | Expires|        |

    '
- title: +----------++---------+----------+----------+--------+--------+--------+
  contents:
  - '+----------++---------+----------+----------+--------+--------+--------+

    '
- title: '|          ||-        | -        | -> PP    | -      | -      | -      |'
  contents:
  - '|          ||-        | -        | -> PP    | -      | -      | -      |

    '
- title: '|          ||         |          | state    |        |        |        |'
  contents:
  - '|          ||         |          | state    |        |        |        |

    '
- title: '|          ||         |          | start    |        |        |        |'
  contents:
  - '|          ||         |          | start    |        |        |        |

    '
- title: '|NoInfo    ||         |          | Prune-   |        |        |        |'
  contents:
  - '|NoInfo    ||         |          | Prune-   |        |        |        |

    '
- title: '|(NI)      ||         |          | Pending  |        |        |        |'
  contents:
  - '|(NI)      ||         |          | Pending  |        |        |        |

    '
- title: '|          ||         |          | Timer;   |        |        |        |'
  contents:
  - '|          ||         |          | Timer;   |        |        |        |

    '
- title: '|          ||         |          | start    |        |        |        |'
  contents:
  - '|          ||         |          | start    |        |        |        |

    '
- title: '|          ||         |          | Expiry   |        |        |        |'
  contents:
  - '|          ||         |          | Expiry   |        |        |        |

    '
- title: '|          ||         |          | Timer    |        |        |        |'
  contents:
  - '|          ||         |          | Timer    |        |        |        |

    '
- title: +----------++---------+----------+----------+--------+--------+--------+
  contents:
  - '+----------++---------+----------+----------+--------+--------+--------+

    '
- title: '|          ||-> P''    | -> NI    | -> P     | -      | -      | -> NI  |'
  contents:
  - '|          ||-> P''    | -> NI    | -> P     | -      | -      | -> NI  |

    '
- title: '|          ||state    | state    | state    |        |        | state  |'
  contents:
  - '|          ||state    | state    | state    |        |        | state  |

    '
- title: '|Prune (P) ||         |          | restart  |        |        |        |'
  contents:
  - '|Prune (P) ||         |          | restart  |        |        |        |

    '
- title: '|          ||         |          | Expiry   |        |        |        |'
  contents:
  - '|          ||         |          | Expiry   |        |        |        |

    '
- title: '|          ||         |          | Timer    |        |        |        |'
  contents:
  - '|          ||         |          | Timer    |        |        |        |

    '
- title: +----------++---------+----------+----------+--------+--------+--------+
  contents:
  - '+----------++---------+----------+----------+--------+--------+--------+

    '
- title: '|Prune-    ||-> PP''   | -> NI    | -        | -      | -> P   | -      |'
  contents:
  - '|Prune-    ||-> PP''   | -> NI    | -        | -      | -> P   | -      |

    '
- title: '|Pending   ||state    | state    |          |        | state  |        |'
  contents:
  - '|Pending   ||state    | state    |          |        | state  |        |

    '
- title: '|(PP)      ||         |          |          |        |        |        |'
  contents:
  - '|(PP)      ||         |          |          |        |        |        |

    '
- title: +----------++---------+----------+----------+--------+--------+--------+
  contents:
  - '+----------++---------+----------+----------+--------+--------+--------+

    '
- title: '|          ||-        | -        | -> P     | -> NI  | -      | -      |'
  contents:
  - '|          ||-        | -        | -> P     | -> NI  | -      | -      |

    '
- title: '|PruneTmp  ||         |          | state    | state  |        |        |'
  contents:
  - '|PruneTmp  ||         |          | state    | state  |        |        |

    '
- title: '|(P'')      ||         |          | restart  |        |        |        |'
  contents:
  - '|(P'')      ||         |          | restart  |        |        |        |

    '
- title: '|          ||         |          | Expiry   |        |        |        |'
  contents:
  - '|          ||         |          | Expiry   |        |        |        |

    '
- title: '|          ||         |          | Timer    |        |        |        |'
  contents:
  - '|          ||         |          | Timer    |        |        |        |

    '
- title: +----------++---------+----------+----------+--------+--------+--------+
  contents:
  - '+----------++---------+----------+----------+--------+--------+--------+

    '
- title: '|          ||-        | -        | -> PP    | -> NI  | -      | -      |'
  contents:
  - '|          ||-        | -        | -> PP    | -> NI  | -      | -      |

    '
- title: '|Prune-    ||         |          | state    | state  |        |        |'
  contents:
  - '|Prune-    ||         |          | state    | state  |        |        |

    '
- title: '|Pending-  ||         |          | restart  |        |        |        |'
  contents:
  - '|Pending-  ||         |          | restart  |        |        |        |

    '
- title: '|Tmp (PP'') ||         |          | Expiry   |        |        |        |'
  contents:
  - '|Tmp (PP'') ||         |          | Expiry   |        |        |        |

    '
- title: '|          ||         |          | Timer    |        |        |        |'
  contents:
  - '|          ||         |          | Timer    |        |        |        |

    '
- title: +----------++---------+----------+----------+--------+--------+--------+
  contents:
  - "+----------++---------+----------+----------+--------+--------+--------+\n  \
    \ The transition events \"Receive Join(S,G,rpt)\", \"Receive\n   Prune(S,G,rpt)\"\
    , and \"Receive Join(*,G)\" imply receiving a Join or\n   Prune targeted to this\
    \ router's primary IP address on the received\n   interface.  If the upstream\
    \ neighbor address field is not correct,\n   these state transitions in this state\
    \ machine must not occur,\n   although seeing such a packet may cause state transitions\
    \ in other\n   state machines.\n   On unnumbered interfaces on point-to-point\
    \ links, the router's\n   address should be the same as the source address it\
    \ chose for the\n   Hello message it sent over that interface.  However, on point-to-\n\
    \   point links we also recommend that PIM Join/Prune messages with an\n   upstream\
    \ neighbor address field of all zeros are also accepted.\n   Transitions from\
    \ NoInfo State\n   When in NoInfo (NI) state, the following event may trigger\
    \ a\n   transition:\n     Receive Prune(S,G,rpt)\n          A Prune(S,G,rpt) is\
    \ received on interface I with its Upstream\n          Neighbor Address set to\
    \ the router's primary IP address on I.\n          The (S,G,rpt) downstream state\
    \ machine on interface I\n          transitions to the Prune-Pending state.  The\
    \ Expiry Timer (ET)\n          is started and set to the HoldTime from the triggering\n\
    \          Join/Prune message.  The Prune-Pending Timer is started.  It\n    \
    \      is set to the J/P_Override_Interval(I) if the router has more\n       \
    \   than one neighbor on that interface; otherwise, it is set to\n          zero,\
    \ causing it to expire immediately.\n   Transitions from Prune-Pending State\n\
    \   When in Prune-Pending (PP) state, the following events may trigger a\n   transition:\n\
    \     Receive Join(*,G)\n          A Join(*,G) is received on interface I with\
    \ its Upstream\n          Neighbor Address set to the router's primary IP address\
    \ on I.\n          The (S,G,rpt) downstream state machine on interface I\n   \
    \       transitions to Prune-Pending-Tmp state whilst the remainder of\n     \
    \     the compound Join/Prune message containing the Join(*,G) is\n          processed.\n\
    \     Receive Join(S,G,rpt)\n          A Join(S,G,rpt) is received on interface\
    \ I with its Upstream\n          Neighbor Address set to the router's primary\
    \ IP address on I.\n          The (S,G,rpt) downstream state machine on interface\
    \ I\n          transitions to NoInfo state.  ET and PPT are canceled.\n     Prune-Pending\
    \ Timer Expires\n          The Prune-Pending Timer for the (S,G,rpt) downstream\
    \ state\n          machine on interface I expires.\n          The (S,G,rpt) downstream\
    \ state machine on interface I\n          transitions to the Prune state.\n  \
    \ Transitions from Prune State\n   When in Prune (P) state, the following events\
    \ may trigger a\n   transition:\n     Receive Join(*,G)\n          A Join(*,G)\
    \ is received on interface I with its Upstream\n          Neighbor Address set\
    \ to the router's primary IP address on I.\n          The (S,G,rpt) downstream\
    \ state machine on interface I\n          transitions to PruneTmp state whilst\
    \ the remainder of the\n          compound Join/Prune message containing the Join(*,G)\
    \ is\n          processed.\n     Receive Join(S,G,rpt)\n          A Join(S,G,rpt)\
    \ is received on interface I with its Upstream\n          Neighbor Address set\
    \ to the router's primary IP address on I.\n          The (S,G,rpt) downstream\
    \ state machine on interface I\n          transitions to NoInfo state.  ET and\
    \ PPT are canceled.\n     Receive Prune(S,G,rpt)\n          A Prune(S,G,rpt) is\
    \ received on interface I with its Upstream\n          Neighbor Address set to\
    \ the router's primary IP address on I.\n          The (S,G,rpt) downstream state\
    \ machine on interface I remains\n          in Prune state.  The Expiry Timer\
    \ (ET) is restarted, set to\n          maximum of its current value and the HoldTime\
    \ from the\n          triggering Join/Prune message.\n     Expiry Timer Expires\n\
    \          The Expiry Timer for the (S,G,rpt) downstream state machine on\n  \
    \        interface I expires.\n          The (S,G,rpt) downstream state machine\
    \ on interface I\n          transitions to the NoInfo state.\n   Transitions from\
    \ Prune-Pending-Tmp State\n   When in Prune-Pending-Tmp (PP') state and processing\
    \ a compound\n   Join/Prune message, the following events may trigger a transition:\n\
    \     Receive Prune(S,G,rpt)\n          The compound Join/Prune message contains\
    \ a Prune(S,G,rpt).\n          The (S,G,rpt) downstream state machine on interface\
    \ I\n          transitions back to the Prune-Pending state.  The Expiry Timer\n\
    \          (ET) is restarted, set to maximum of its current value and the\n  \
    \        HoldTime from the triggering Join/Prune message.\n     End of Message\n\
    \          The end of the compound Join/Prune message is reached.\n          The\
    \ (S,G,rpt) downstream state machine on interface I\n          transitions to\
    \ the NoInfo state.  ET and PPT are canceled.\n   Transitions from PruneTmp State\n\
    \   When in PruneTmp (P') state and processing a compound Join/Prune\n   message,\
    \ the following events may trigger a transition:\n     Receive Prune(S,G,rpt)\n\
    \          The compound Join/Prune message contains a Prune(S,G,rpt).\n      \
    \    The (S,G,rpt) downstream state machine on interface I\n          transitions\
    \ back to the Prune state.  The Expiry Timer (ET) is\n          restarted, set\
    \ to maximum of its current value and the\n          HoldTime from the triggering\
    \ Join/Prune message.\n     End of Message\n          The end of the compound\
    \ Join/Prune message is reached.\n          The (S,G,rpt) downstream state machine\
    \ on interface I\n          transitions to the NoInfo state.  ET is canceled.\n\
    \   Notes:\n   Receiving a Prune(*,G) does not affect the (S,G,rpt) downstream\
    \ state\n   machine.\n   Receiving a Join(*,*,RP) does not affect the (S,G,rpt)\
    \ downstream\n   state machine.  If a router has originated Join(*,*,RP) and pruned\
    \ a\n   source off it using Prune(S,G,rpt), then to receive that source again\n\
    \   it should explicitly re-join using Join(S,G,rpt) or Join(*,G).  In\n   some\
    \ LAN topologies it is possible for a router sending a new\n   Join(*,*,RP) to\
    \ have to wait as much as a Join/Prune Interval before\n   noticing that it needs\
    \ to override a neighbor's preexisting\n   Prune(S,G,rpt).  This is considered\
    \ acceptable, as (*,*,RP) state is\n   intended to be used only in long-lived\
    \ and persistent scenarios.\n"
- title: 4.5.5.  Sending (*,*,RP) Join/Prune Messages
  contents:
  - "4.5.5.  Sending (*,*,RP) Join/Prune Messages\n   The per-interface state machines\
    \ for (*,*,RP) hold join state from\n   downstream PIM routers.  This state then\
    \ determines whether a router\n   needs to propagate a Join(*,*,RP) upstream towards\
    \ the RP.\n   If a router wishes to propagate a Join(*,*,RP) upstream, it must\
    \ also\n   watch for messages on its upstream interface from other routers on\n\
    \   that subnet, and these may modify its behavior.  If it sees a\n   Join(*,*,RP)\
    \ to the correct upstream neighbor, it should suppress its\n   own Join(*,*,RP).\
    \  If it sees a Prune(*,*,RP) to the correct upstream\n   neighbor, it should\
    \ be prepared to override that prune by sending a\n   Join(*,*,RP) almost immediately.\
    \  Finally, if it sees the Generation\n   ID (see Section 4.3) of the correct\
    \ upstream neighbor change, it\n   knows that the upstream neighbor has lost state,\
    \ and it should be\n   prepared to refresh the state by sending a Join(*,*,RP)\
    \ almost\n   immediately.\n   In addition, if the MRIB changes to indicate that\
    \ the next hop\n   towards the RP has changed, the router should prune off from\
    \ the old\n   next hop and join towards the new next hop.\n   The upstream (*,*,RP)\
    \ state machine contains only two states:\n   Not Joined\n      The downstream\
    \ state machines and local membership information do\n      not indicate that\
    \ the router needs to join the (*,*,RP) tree for\n      this RP.\n   Joined\n\
    \      The downstream state machines and local membership information\n      indicate\
    \ that the router should join the (*,*,RP) tree for this\n      RP.\n   In addition,\
    \ one timer JT(*,*,RP) is kept that is used to trigger the\n   sending of a Join(*,*,RP)\
    \ to the upstream next hop towards the RP,\n   NBR(RPF_interface(RP), MRIB.next_hop(RP)).\n\
    \       Figure 6: Upstream (*,*,RP) state machine in tabular form\n"
- title: +-------------------++-------------------------------------------------+
  contents:
  - '+-------------------++-------------------------------------------------+

    '
- title: '|                   ||                      Event                      |'
  contents:
  - '|                   ||                      Event                      |

    '
- title: '|  Prev State       ++-------------------------+-----------------------+'
  contents:
  - '|  Prev State       ++-------------------------+-----------------------+

    '
- title: '|                   ||   JoinDesired           |    JoinDesired        |'
  contents:
  - '|                   ||   JoinDesired           |    JoinDesired        |

    '
- title: '|                   ||   (*,*,RP) ->True       |    (*,*,RP) ->False   |'
  contents:
  - '|                   ||   (*,*,RP) ->True       |    (*,*,RP) ->False   |

    '
- title: +-------------------++-------------------------+-----------------------+
  contents:
  - '+-------------------++-------------------------+-----------------------+

    '
- title: '|                   ||   -> J state            |    -                  |'
  contents:
  - '|                   ||   -> J state            |    -                  |

    '
- title: '|  NotJoined (NJ)   ||   Send Join(*,*,RP);    |                       |'
  contents:
  - '|  NotJoined (NJ)   ||   Send Join(*,*,RP);    |                       |

    '
- title: '|                   ||   Set Join Timer to     |                       |'
  contents:
  - '|                   ||   Set Join Timer to     |                       |

    '
- title: '|                   ||   t_periodic            |                       |'
  contents:
  - '|                   ||   t_periodic            |                       |

    '
- title: +-------------------++-------------------------+-----------------------+
  contents:
  - '+-------------------++-------------------------+-----------------------+

    '
- title: '|  Joined (J)       ||   -                     |    -> NJ state        |'
  contents:
  - '|  Joined (J)       ||   -                     |    -> NJ state        |

    '
- title: '|                   ||                         |    Send Prune         |'
  contents:
  - '|                   ||                         |    Send Prune         |

    '
- title: '|                   ||                         |    (*,*,RP); Cancel   |'
  contents:
  - '|                   ||                         |    (*,*,RP); Cancel   |

    '
- title: '|                   ||                         |    Join Timer         |'
  contents:
  - '|                   ||                         |    Join Timer         |

    '
- title: +-------------------++-------------------------+-----------------------+
  contents:
  - "+-------------------++-------------------------+-----------------------+\n  \
    \ In addition, we have the following transitions, which occur within\n   the Joined\
    \ state:\n"
- title: +----------------------------------------------------------------------+
  contents:
  - '+----------------------------------------------------------------------+

    '
- title: '|                         In Joined (J) State                          |'
  contents:
  - '|                         In Joined (J) State                          |

    '
- title: +-------------------+--------------------+-----------------------------+
  contents:
  - '+-------------------+--------------------+-----------------------------+

    '
- title: '| Timer Expires     |  See               |   See                       |'
  contents:
  - '| Timer Expires     |  See               |   See                       |

    '
- title: '|                   |  Join(*,*,RP)      |   Prune(*,*,RP)             |'
  contents:
  - '|                   |  Join(*,*,RP)      |   Prune(*,*,RP)             |

    '
- title: '|                   |  to MRIB.          |   to MRIB.                  |'
  contents:
  - '|                   |  to MRIB.          |   to MRIB.                  |

    '
- title: '|                   |  next_hop(RP)      |   next_hop(RP)              |'
  contents:
  - '|                   |  next_hop(RP)      |   next_hop(RP)              |

    '
- title: +-------------------+--------------------+-----------------------------+
  contents:
  - '+-------------------+--------------------+-----------------------------+

    '
- title: '| Send              |  Increase Join     |   Decrease Join             |'
  contents:
  - '| Send              |  Increase Join     |   Decrease Join             |

    '
- title: '| Join(*,*,RP);     |  Timer to          |   Timer to                  |'
  contents:
  - '| Join(*,*,RP);     |  Timer to          |   Timer to                  |

    '
- title: '| Set Join Timer    |  t_joinsuppress    |   t_override                |'
  contents:
  - '| Set Join Timer    |  t_joinsuppress    |   t_override                |

    '
- title: '| to t_periodic     |                    |                             |'
  contents:
  - '| to t_periodic     |                    |                             |

    '
- title: +-------------------+--------------------+-----------------------------+
  contents:
  - '+-------------------+--------------------+-----------------------------+

    '
- title: +----------------------------------------------------------------------+
  contents:
  - '+----------------------------------------------------------------------+

    '
- title: '|                         In Joined (J) State                          |'
  contents:
  - '|                         In Joined (J) State                          |

    '
- title: +-----------------------------------+----------------------------------+
  contents:
  - '+-----------------------------------+----------------------------------+

    '
- title: '|    NBR(RPF_interface(RP),         |       MRIB.next_hop(RP) GenID    |'
  contents:
  - '|    NBR(RPF_interface(RP),         |       MRIB.next_hop(RP) GenID    |

    '
- title: '|    MRIB.next_hop(RP))             |       changes                    |'
  contents:
  - '|    MRIB.next_hop(RP))             |       changes                    |

    '
- title: '|    changes                        |                                  |'
  contents:
  - '|    changes                        |                                  |

    '
- title: +-----------------------------------+----------------------------------+
  contents:
  - '+-----------------------------------+----------------------------------+

    '
- title: '|    Send Join(*,*,RP) to new       |       Decrease Join Timer to     |'
  contents:
  - '|    Send Join(*,*,RP) to new       |       Decrease Join Timer to     |

    '
- title: '|    next hop; Send                 |       t_override                 |'
  contents:
  - '|    next hop; Send                 |       t_override                 |

    '
- title: '|    Prune(*,*,RP) to old           |                                  |'
  contents:
  - '|    Prune(*,*,RP) to old           |                                  |

    '
- title: '|    next hop; set Join Timer       |                                  |'
  contents:
  - '|    next hop; set Join Timer       |                                  |

    '
- title: '|    to t_periodic                  |                                  |'
  contents:
  - '|    to t_periodic                  |                                  |

    '
- title: +-----------------------------------+----------------------------------+
  contents:
  - "+-----------------------------------+----------------------------------+\n  \
    \ This state machine uses the following macro:\n     bool JoinDesired(*,*,RP)\
    \ {\n        if immediate_olist(*,*,RP) != NULL\n            return TRUE\n   \
    \     else\n            return FALSE\n     }\n   JoinDesired(*,*,RP) is true when\
    \ the router has received (*,*,RP)\n   Joins from any downstream interface.  Note\
    \ that although JoinDesired\n   is true, the router's sending of a Join(*,*,RP)\
    \ message may be\n   suppressed by another router sending a Join(*,*,RP) onto\
    \ the upstream\n   interface.\n   Transitions from NotJoined State\n   When the\
    \ upstream (*,*,RP) state machine is in NotJoined state, the\n   following event\
    \ may trigger a state transition:\n     JoinDesired(*,*,RP) becomes True\n   \
    \       The downstream state for (*,*,RP) has changed so that at least\n     \
    \     one interface is in immediate_olist(*,*,RP), making\n          JoinDesired(*,*,RP)\
    \ become True.\n          The upstream (*,*,RP) state machine transitions to Joined\n\
    \          state.  Send Join(*,*,RP) to the appropriate upstream\n          neighbor,\
    \ which is NBR(RPF_interface(RP), MRIB.next_hop(RP)).\n          Set the Join\
    \ Timer (JT) to expire after t_periodic seconds.\n   Transitions from Joined State\n\
    \   When the upstream (*,*,RP) state machine is in Joined state, the\n   following\
    \ events may trigger state transitions:\n     JoinDesired(*,*,RP) becomes False\n\
    \          The downstream state for (*,*,RP) has changed so no interface\n   \
    \       is in immediate_olist(*,*,RP), making JoinDesired(*,*,RP)\n          become\
    \ False.\n          The upstream (*,*,RP) state machine transitions to NotJoined\n\
    \          state.  Send Prune(*,*,RP) to the appropriate upstream\n          neighbor,\
    \ which is NBR(RPF_interface(RP), MRIB.next_hop(RP)).\n          Cancel the Join\
    \ Timer (JT).\n     Join Timer Expires\n          The Join Timer (JT) expires,\
    \ indicating time to send a\n          Join(*,*,RP)\n          Send Join(*,*,RP)\
    \ to the appropriate upstream neighbor, which\n          is NBR(RPF_interface(RP),\
    \ MRIB.next_hop(RP)).  Restart the\n          Join Timer (JT) to expire after\
    \ t_periodic seconds.\n     See Join(*,*,RP) to MRIB.next_hop(RP)\n          This\
    \ event is only relevant if RPF_interface(RP) is a shared\n          medium. \
    \ This router sees another router on RPF_interface(RP)\n          send a Join(*,*,RP)\
    \ to NBR(RPF_interface(RP),\n          MRIB.next_hop(RP)).  This causes this router\
    \ to suppress its\n          own Join.\n          The upstream (*,*,RP) state\
    \ machine remains in Joined state.\n          Let t_joinsuppress be the minimum\
    \ of t_suppressed and the\n          HoldTime from the Join/Prune message triggering\
    \ this event.\n          If the Join Timer is set to expire in less than t_joinsuppress\n\
    \          seconds, reset it so that it expires after t_joinsuppress\n       \
    \   seconds.  If the Join Timer is set to expire in more than\n          t_joinsuppress\
    \ seconds, leave it unchanged.\n     See Prune(*,*,RP) to MRIB.next_hop(RP)\n\
    \          This event is only relevant if RPF_interface(RP) is a shared\n    \
    \      medium.  This router sees another router on RPF_interface(RP)\n       \
    \   send a Prune(*,*,RP) to NBR(RPF_interface(RP),\n          MRIB.next_hop(RP)).\
    \  As this router is in Joined state, it\n          must override the Prune after\
    \ a short random interval.\n          The upstream (*,*,RP) state machine remains\
    \ in Joined state.\n          If the Join Timer is set to expire in more than\
    \ t_override\n          seconds, reset it so that it expires after t_override\
    \ seconds.\n          If the Join Timer is set to expire in less than t_override\n\
    \          seconds, leave it unchanged.\n     NBR(RPF_interface(RP), MRIB.next_hop(RP))\
    \ changes\n          A change in the MRIB routing base causes the next hop towards\n\
    \          the RP to change.\n          The upstream (*,*,RP) state machine remains\
    \ in Joined state.\n          Send Join(*,*,RP) to the new upstream neighbor,\
    \ which is the\n          new value of NBR(RPF_interface(RP), MRIB.next_hop(RP)).\
    \  Send\n          Prune(*,*,RP) to the old upstream neighbor, which is the old\n\
    \          value of NBR(RPF_interface(RP), MRIB.next_hop(RP)).  Set the\n    \
    \      Join Timer (JT) to expire after t_periodic seconds.\n     MRIB.next_hop(RP)\
    \ GenID changes\n          The Generation ID of the router that is MRIB.next_hop(RP)\n\
    \          changes.  This normally means that this neighbor has lost\n       \
    \   state, and so the state must be refreshed.\n          The upstream (*,*,RP)\
    \ state machine remains in Joined state.\n          If the Join Timer is set to\
    \ expire in more than t_override\n          seconds, reset it so that it expires\
    \ after t_override seconds.\n"
- title: 4.5.6.  Sending (*,G) Join/Prune Messages
  contents:
  - "4.5.6.  Sending (*,G) Join/Prune Messages\n   The per-interface state machines\
    \ for (*,G) hold join state from\n   downstream PIM routers.  This state then\
    \ determines whether a router\n   needs to propagate a Join(*,G) upstream towards\
    \ the RP.\n   If a router wishes to propagate a Join(*,G) upstream, it must also\n\
    \   watch for messages on its upstream interface from other routers on\n   that\
    \ subnet, and these may modify its behavior.  If it sees a\n   Join(*,G) to the\
    \ correct upstream neighbor, it should suppress its\n   own Join(*,G).  If it\
    \ sees a Prune(*,G) to the correct upstream\n   neighbor, it should be prepared\
    \ to override that prune by sending a\n   Join(*,G) almost immediately.  Finally,\
    \ if it sees the Generation ID\n   (see Section 4.3) of the correct upstream neighbor\
    \ change, it knows\n   that the upstream neighbor has lost state, and it should\
    \ be prepared\n   to refresh the state by sending a Join(*,G) almost immediately.\n\
    \   If a (*,G) Assert occurs on the upstream interface, and this changes\n   this\
    \ router's idea of the upstream neighbor, it should be prepared to\n   ensure\
    \ that the Assert winner is aware of downstream routers by\n   sending a Join(*,G)\
    \ almost immediately.\n   In addition, if the MRIB changes to indicate that the\
    \ next hop\n   towards the RP has changed, and either the upstream interface changes\n\
    \   or there is no Assert winner on the upstream interface, the router\n   should\
    \ prune off from the old next hop and join towards the new next\n   hop.\n   The\
    \ upstream (*,G) state machine only contains two states:\n   Not Joined\n    \
    \  The downstream state machines indicate that the router does not\n      need\
    \ to join the RP tree for this group.\n   Joined\n      The downstream state machines\
    \ indicate that the router should join\n      the RP tree for this group.\n  \
    \ In addition, one timer JT(*,G) is kept that is used to trigger the\n   sending\
    \ of a Join(*,G) to the upstream next hop towards the RP,\n   RPF'(*,G).\n   \
    \      Figure 7: Upstream (*,G) state machine in tabular form\n"
- title: +-------------------++-------------------------------------------------+
  contents:
  - '+-------------------++-------------------------------------------------+

    '
- title: '|                   ||                      Event                      |'
  contents:
  - '|                   ||                      Event                      |

    '
- title: '|  Prev State       ++------------------------+------------------------+'
  contents:
  - '|  Prev State       ++------------------------+------------------------+

    '
- title: '|                   ||   JoinDesired(*,G)     |    JoinDesired(*,G)    |'
  contents:
  - '|                   ||   JoinDesired(*,G)     |    JoinDesired(*,G)    |

    '
- title: '|                   ||   ->True               |    ->False             |'
  contents:
  - '|                   ||   ->True               |    ->False             |

    '
- title: +-------------------++------------------------+------------------------+
  contents:
  - '+-------------------++------------------------+------------------------+

    '
- title: '|                   ||   -> J state           |    -                   |'
  contents:
  - '|                   ||   -> J state           |    -                   |

    '
- title: '|  NotJoined (NJ)   ||   Send Join(*,G);      |                        |'
  contents:
  - '|  NotJoined (NJ)   ||   Send Join(*,G);      |                        |

    '
- title: '|                   ||   Set Join Timer to    |                        |'
  contents:
  - '|                   ||   Set Join Timer to    |                        |

    '
- title: '|                   ||   t_periodic           |                        |'
  contents:
  - '|                   ||   t_periodic           |                        |

    '
- title: +-------------------++------------------------+------------------------+
  contents:
  - '+-------------------++------------------------+------------------------+

    '
- title: '|  Joined (J)       ||   -                    |    -> NJ state         |'
  contents:
  - '|  Joined (J)       ||   -                    |    -> NJ state         |

    '
- title: '|                   ||                        |    Send Prune(*,G);    |'
  contents:
  - '|                   ||                        |    Send Prune(*,G);    |

    '
- title: '|                   ||                        |    Cancel Join Timer   |'
  contents:
  - '|                   ||                        |    Cancel Join Timer   |

    '
- title: +-------------------++------------------------+------------------------+
  contents:
  - "+-------------------++------------------------+------------------------+\n  \
    \ In addition, we have the following transitions, which occur within\n   the Joined\
    \ state:\n"
- title: +----------------------------------------------------------------------+
  contents:
  - '+----------------------------------------------------------------------+

    '
- title: '|                        In Joined (J) State                           |'
  contents:
  - '|                        In Joined (J) State                           |

    '
- title: +----------------+-----------------+-----------------+-----------------+
  contents:
  - '+----------------+-----------------+-----------------+-----------------+

    '
- title: '|Timer Expires   | See Join(*,G)   | See Prune(*,G)  | RPF''(*,G)       |'
  contents:
  - '|Timer Expires   | See Join(*,G)   | See Prune(*,G)  | RPF''(*,G)       |

    '
- title: '|                | to RPF''(*,G)    | to RPF''(*,G)    | changes due to  |'
  contents:
  - '|                | to RPF''(*,G)    | to RPF''(*,G)    | changes due to  |

    '
- title: '|                |                 |                 | an Assert       |'
  contents:
  - '|                |                 |                 | an Assert       |

    '
- title: +----------------+-----------------+-----------------+-----------------+
  contents:
  - '+----------------+-----------------+-----------------+-----------------+

    '
- title: '|Send            | Increase Join   | Decrease Join   | Decrease Join   |'
  contents:
  - '|Send            | Increase Join   | Decrease Join   | Decrease Join   |

    '
- title: '|Join(*,G); Set  | Timer to        | Timer to        | Timer to        |'
  contents:
  - '|Join(*,G); Set  | Timer to        | Timer to        | Timer to        |

    '
- title: '|Join Timer to   | t_joinsuppress  | t_override      | t_override      |'
  contents:
  - '|Join Timer to   | t_joinsuppress  | t_override      | t_override      |

    '
- title: '|t_periodic      |                 |                 |                 |'
  contents:
  - '|t_periodic      |                 |                 |                 |

    '
- title: +----------------+-----------------+-----------------+-----------------+
  contents:
  - '+----------------+-----------------+-----------------+-----------------+

    '
- title: +----------------------------------------------------------------------+
  contents:
  - '+----------------------------------------------------------------------+

    '
- title: '|                         In Joined (J) State                          |'
  contents:
  - '|                         In Joined (J) State                          |

    '
- title: +----------------------------------+-----------------------------------+
  contents:
  - '+----------------------------------+-----------------------------------+

    '
- title: '|    RPF''(*,G) changes not         |       RPF''(*,G) GenID changes     |'
  contents:
  - '|    RPF''(*,G) changes not         |       RPF''(*,G) GenID changes     |

    '
- title: '|    due to an Assert              |                                   |'
  contents:
  - '|    due to an Assert              |                                   |

    '
- title: +----------------------------------+-----------------------------------+
  contents:
  - '+----------------------------------+-----------------------------------+

    '
- title: '|    Send Join(*,G) to new         |       Decrease Join Timer to      |'
  contents:
  - '|    Send Join(*,G) to new         |       Decrease Join Timer to      |

    '
- title: '|    next hop; Send                |       t_override                  |'
  contents:
  - '|    next hop; Send                |       t_override                  |

    '
- title: '|    Prune(*,G) to old next        |                                   |'
  contents:
  - '|    Prune(*,G) to old next        |                                   |

    '
- title: '|    hop; Set Join Timer to        |                                   |'
  contents:
  - '|    hop; Set Join Timer to        |                                   |

    '
- title: '|    t_periodic                    |                                   |'
  contents:
  - '|    t_periodic                    |                                   |

    '
- title: +----------------------------------+-----------------------------------+
  contents:
  - "+----------------------------------+-----------------------------------+\n  \
    \ This state machine uses the following macro:\n     bool JoinDesired(*,G) {\n\
    \        if (immediate_olist(*,G) != NULL OR\n            (JoinDesired(*,*,RP(G))\
    \ AND\n             AssertWinner(*, G, RPF_interface(RP(G))) != NULL))\n     \
    \       return TRUE\n        else\n            return FALSE\n     }\n   JoinDesired(*,G)\
    \ is true when the router has forwarding state that\n   would cause it to forward\
    \ traffic for G using shared tree state.\n   Note that although JoinDesired is\
    \ true, the router's sending of a\n   Join(*,G) message may be suppressed by another\
    \ router sending a\n   Join(*,G) onto the upstream interface.\n   Transitions\
    \ from NotJoined State\n   When the upstream (*,G) state machine is in NotJoined\
    \ state, the\n   following event may trigger a state transition:\n     JoinDesired(*,G)\
    \ becomes True\n          The macro JoinDesired(*,G) becomes True, e.g., because\
    \ the\n          downstream state for (*,G) has changed so that at least one\n\
    \          interface is in immediate_olist(*,G).\n          The upstream (*,G)\
    \ state machine transitions to Joined state.\n          Send Join(*,G) to the\
    \ appropriate upstream neighbor, which is\n          RPF'(*,G).  Set the Join\
    \ Timer (JT) to expire after t_periodic\n          seconds.\n   Transitions from\
    \ Joined State\n   When the upstream (*,G) state machine is in Joined state, the\n\
    \   following events may trigger state transitions:\n     JoinDesired(*,G) becomes\
    \ False\n          The macro JoinDesired(*,G) becomes False, e.g., because the\n\
    \          downstream state for (*,G) has changed so no interface is in\n    \
    \      immediate_olist(*,G).\n          The upstream (*,G) state machine transitions\
    \ to NotJoined\n          state.  Send Prune(*,G) to the appropriate upstream\
    \ neighbor,\n          which is RPF'(*,G).  Cancel the Join Timer (JT).\n    \
    \ Join Timer Expires\n          The Join Timer (JT) expires, indicating time to\
    \ send a\n          Join(*,G)\n          Send Join(*,G) to the appropriate upstream\
    \ neighbor, which is\n          RPF'(*,G).  Restart the Join Timer (JT) to expire\
    \ after\n          t_periodic seconds.\n     See Join(*,G) to RPF'(*,G)\n    \
    \      This event is only relevant if RPF_interface(RP(G)) is a\n          shared\
    \ medium.  This router sees another router on\n          RPF_interface(RP(G))\
    \ send a Join(*,G) to RPF'(*,G).  This\n          causes this router to suppress\
    \ its own Join.\n          The upstream (*,G) state machine remains in Joined\
    \ state.\n          Let t_joinsuppress be the minimum of t_suppressed and the\n\
    \          HoldTime from the Join/Prune message triggering this event.\n     \
    \     If the Join Timer is set to expire in less than t_joinsuppress\n       \
    \   seconds, reset it so that it expires after t_joinsuppress\n          seconds.\
    \  If the Join Timer is set to expire in more than\n          t_joinsuppress seconds,\
    \ leave it unchanged.\n     See Prune(*,G) to RPF'(*,G)\n          This event\
    \ is only relevant if RPF_interface(RP(G)) is a\n          shared medium.  This\
    \ router sees another router on\n          RPF_interface(RP(G)) send a Prune(*,G)\
    \ to RPF'(*,G).  As this\n          router is in Joined state, it must override\
    \ the Prune after a\n          short random interval.\n          The upstream\
    \ (*,G) state machine remains in Joined state.  If\n          the Join Timer is\
    \ set to expire in more than t_override\n          seconds, reset it so that it\
    \ expires after t_override seconds.\n          If the Join Timer is set to expire\
    \ in less than t_override\n          seconds, leave it unchanged.\n     RPF'(*,G)\
    \ changes due to an Assert\n          The current next hop towards the RP changes\
    \ due to an\n          Assert(*,G) on the RPF_interface(RP(G)).\n          The\
    \ upstream (*,G) state machine remains in Joined state.  If\n          the Join\
    \ Timer is set to expire in more than t_override\n          seconds, reset it\
    \ so that it expires after t_override seconds.\n          If the Join Timer is\
    \ set to expire in less than t_override\n          seconds, leave it unchanged.\n\
    \     RPF'(*,G) changes not due to an Assert\n          An event occurred that\
    \ caused the next hop towards the RP for\n          G to change.  This may be\
    \ caused by a change in the MRIB\n          routing database or the group-to-RP\
    \ mapping.  Note that this\n          transition does not occur if an Assert is\
    \ active and the\n          upstream interface does not change.\n          The\
    \ upstream (*,G) state machine remains in Joined state.\n          Send Join(*,G)\
    \ to the new upstream neighbor, which is the new\n          value of RPF'(*,G).\
    \  Send Prune(*,G) to the old upstream\n          neighbor, which is the old value\
    \ of RPF'(*,G).  Use the new\n          value of RP(G) in the Prune(*,G) message\
    \ or all zeros if RP(G)\n          becomes unknown (old value of RP(G) may be\
    \ used instead to\n          improve behavior in routers implementing older versions\
    \ of\n          this spec).  Set the Join Timer (JT) to expire after\n       \
    \   t_periodic seconds.\n     RPF'(*,G) GenID changes\n          The Generation\
    \ ID of the router that is RPF'(*,G) changes.\n          This normally means that\
    \ this neighbor has lost state, and so\n          the state must be refreshed.\n\
    \          The upstream (*,G) state machine remains in Joined state.  If\n   \
    \       the Join Timer is set to expire in more than t_override\n          seconds,\
    \ reset it so that it expires after t_override seconds.\n"
- title: 4.5.7.  Sending (S,G) Join/Prune Messages
  contents:
  - "4.5.7.  Sending (S,G) Join/Prune Messages\n   The per-interface state machines\
    \ for (S,G) hold join state from\n   downstream PIM routers.  This state then\
    \ determines whether a router\n   needs to propagate a Join(S,G) upstream towards\
    \ the source.\n   If a router wishes to propagate a Join(S,G) upstream, it must\
    \ also\n   watch for messages on its upstream interface from other routers on\n\
    \   that subnet, and these may modify its behavior.  If it sees a\n   Join(S,G)\
    \ to the correct upstream neighbor, it should suppress its\n   own Join(S,G).\
    \  If it sees a Prune(S,G), Prune(S,G,rpt), or\n   Prune(*,G) to the correct upstream\
    \ neighbor towards S, it should be\n   prepared to override that prune by scheduling\
    \ a Join(S,G) to be sent\n   almost immediately.  Finally, if it sees the Generation\
    \ ID of its\n   upstream neighbor change, it knows that the upstream neighbor\
    \ has\n   lost state, and it should refresh the state by scheduling a Join(S,G)\n\
    \   to be sent almost immediately.\n   If a (S,G) Assert occurs on the upstream\
    \ interface, and this changes\n   the this router's idea of the upstream neighbor,\
    \ it should be\n   prepared to ensure that the Assert winner is aware of downstream\n\
    \   routers by scheduling a Join(S,G) to be sent almost immediately.\n   In addition,\
    \ if MRIB changes cause the next hop towards the source to\n   change, and either\
    \ the upstream interface changes or there is no\n   Assert winner on the upstream\
    \ interface, the router should send a\n   prune to the old next hop and a join\
    \ to the new next hop.\n   The upstream (S,G) state machine only contains two\
    \ states:\n   Not Joined\n      The downstream state machines and local membership\
    \ information do\n      not indicate that the router needs to join the shortest-path\
    \ tree\n      for this (S,G).\n   Joined\n      The downstream state machines\
    \ and local membership information\n      indicate that the router should join\
    \ the shortest-path tree for\n      this (S,G).\n   In addition, one timer JT(S,G)\
    \ is kept that is used to trigger the\n   sending of a Join(S,G) to the upstream\
    \ next hop towards S, RPF'(S,G).\n         Figure 8: Upstream (S,G) state machine\
    \ in tabular form\n"
- title: +-------------------+--------------------------------------------------+
  contents:
  - '+-------------------+--------------------------------------------------+

    '
- title: '|                   |                      Event                       |'
  contents:
  - '|                   |                      Event                       |

    '
- title: '|  Prev State       +-------------------------+------------------------+'
  contents:
  - '|  Prev State       +-------------------------+------------------------+

    '
- title: '|                   |   JoinDesired(S,G)      |   JoinDesired(S,G)     |'
  contents:
  - '|                   |   JoinDesired(S,G)      |   JoinDesired(S,G)     |

    '
- title: '|                   |   ->True                |   ->False              |'
  contents:
  - '|                   |   ->True                |   ->False              |

    '
- title: +-------------------+-------------------------+------------------------+
  contents:
  - '+-------------------+-------------------------+------------------------+

    '
- title: '|  NotJoined (NJ)   |   -> J state            |   -                    |'
  contents:
  - '|  NotJoined (NJ)   |   -> J state            |   -                    |

    '
- title: '|                   |   Send Join(S,G);       |                        |'
  contents:
  - '|                   |   Send Join(S,G);       |                        |

    '
- title: '|                   |   Set Join Timer to     |                        |'
  contents:
  - '|                   |   Set Join Timer to     |                        |

    '
- title: '|                   |   t_periodic            |                        |'
  contents:
  - '|                   |   t_periodic            |                        |

    '
- title: +-------------------+-------------------------+------------------------+
  contents:
  - '+-------------------+-------------------------+------------------------+

    '
- title: '|  Joined (J)       |   -                     |   -> NJ state          |'
  contents:
  - '|  Joined (J)       |   -                     |   -> NJ state          |

    '
- title: '|                   |                         |   Send Prune(S,G);     |'
  contents:
  - '|                   |                         |   Send Prune(S,G);     |

    '
- title: '|                   |                         |   Set SPTbit(S,G) to   |'
  contents:
  - '|                   |                         |   Set SPTbit(S,G) to   |

    '
- title: '|                   |                         |   FALSE; Cancel Join   |'
  contents:
  - '|                   |                         |   FALSE; Cancel Join   |

    '
- title: '|                   |                         |   Timer                |'
  contents:
  - '|                   |                         |   Timer                |

    '
- title: +-------------------+-------------------------+------------------------+
  contents:
  - "+-------------------+-------------------------+------------------------+\n  \
    \ In addition, we have the following transitions, which occur within\n   the Joined\
    \ state:\n"
- title: +----------------------------------------------------------------------+
  contents:
  - '+----------------------------------------------------------------------+

    '
- title: '|                         In Joined (J) State                          |'
  contents:
  - '|                         In Joined (J) State                          |

    '
- title: +-----------------+-----------------+-----------------+----------------+
  contents:
  - '+-----------------+-----------------+-----------------+----------------+

    '
- title: '| Timer Expires   | See Join(S,G)   | See Prune(S,G)  | See Prune      |'
  contents:
  - '| Timer Expires   | See Join(S,G)   | See Prune(S,G)  | See Prune      |

    '
- title: '|                 | to RPF''(S,G)    | to RPF''(S,G)    | (S,G,rpt) to   |'
  contents:
  - '|                 | to RPF''(S,G)    | to RPF''(S,G)    | (S,G,rpt) to   |

    '
- title: '|                 |                 |                 | RPF''(S,G)      |'
  contents:
  - '|                 |                 |                 | RPF''(S,G)      |

    '
- title: +-----------------+-----------------+-----------------+----------------+
  contents:
  - '+-----------------+-----------------+-----------------+----------------+

    '
- title: '| Send            | Increase Join   | Decrease Join   | Decrease Join  |'
  contents:
  - '| Send            | Increase Join   | Decrease Join   | Decrease Join  |

    '
- title: '| Join(S,G); Set  | Timer to        | Timer to        | Timer to       |'
  contents:
  - '| Join(S,G); Set  | Timer to        | Timer to        | Timer to       |

    '
- title: '| Join Timer to   | t_joinsuppress  | t_override      | t_override     |'
  contents:
  - '| Join Timer to   | t_joinsuppress  | t_override      | t_override     |

    '
- title: '| t_periodic      |                 |                 |                |'
  contents:
  - '| t_periodic      |                 |                 |                |

    '
- title: +-----------------+-----------------+-----------------+----------------+
  contents:
  - '+-----------------+-----------------+-----------------+----------------+

    '
- title: +----------------------------------------------------------------------+
  contents:
  - '+----------------------------------------------------------------------+

    '
- title: '|                        In Joined (J) State                           |'
  contents:
  - '|                        In Joined (J) State                           |

    '
- title: +-----------------+-----------------+----------------+-----------------+
  contents:
  - '+-----------------+-----------------+----------------+-----------------+

    '
- title: '| See Prune(*,G)  | RPF''(S,G)       | RPF''(S,G)      | RPF''(S,G)       |'
  contents:
  - '| See Prune(*,G)  | RPF''(S,G)       | RPF''(S,G)      | RPF''(S,G)       |

    '
- title: '| to RPF''(S,G)    | changes not     | GenID changes  | changes due to  |'
  contents:
  - '| to RPF''(S,G)    | changes not     | GenID changes  | changes due to  |

    '
- title: '|                 | due to an       |                | an Assert       |'
  contents:
  - '|                 | due to an       |                | an Assert       |

    '
- title: '|                 | Assert          |                |                 |'
  contents:
  - '|                 | Assert          |                |                 |

    '
- title: +-----------------+-----------------+----------------+-----------------+
  contents:
  - '+-----------------+-----------------+----------------+-----------------+

    '
- title: '| Decrease Join   | Send Join(S,G)  | Decrease Join  | Decrease Join   |'
  contents:
  - '| Decrease Join   | Send Join(S,G)  | Decrease Join  | Decrease Join   |

    '
- title: '| Timer to        | to new next     | Timer to       | Timer to        |'
  contents:
  - '| Timer to        | to new next     | Timer to       | Timer to        |

    '
- title: '| t_override      | hop; Send       | t_override     | t_override      |'
  contents:
  - '| t_override      | hop; Send       | t_override     | t_override      |

    '
- title: '|                 | Prune(S,G) to   |                |                 |'
  contents:
  - '|                 | Prune(S,G) to   |                |                 |

    '
- title: '|                 | old next hop;   |                |                 |'
  contents:
  - '|                 | old next hop;   |                |                 |

    '
- title: '|                 | Set Join Timer  |                |                 |'
  contents:
  - '|                 | Set Join Timer  |                |                 |

    '
- title: '|                 | to t_periodic   |                |                 |'
  contents:
  - '|                 | to t_periodic   |                |                 |

    '
- title: +-----------------+-----------------+----------------+-----------------+
  contents:
  - "+-----------------+-----------------+----------------+-----------------+\n  \
    \ This state machine uses the following macro:\n     bool JoinDesired(S,G) {\n\
    \         return( immediate_olist(S,G) != NULL\n                 OR ( KeepaliveTimer(S,G)\
    \ is running\n                      AND inherited_olist(S,G) != NULL ) )\n   \
    \  }\n   JoinDesired(S,G) is true when the router has forwarding state that\n\
    \   would cause it to forward traffic for G using source tree state.  The\n  \
    \ source tree state can be as a result of either active source-specific\n   join\
    \ state, or the (S,G) Keepalive Timer and active non-source-\n   specific state.\
    \  Note that although JoinDesired is true, the router's\n   sending of a Join(S,G)\
    \ message may be suppressed by another router\n   sending a Join(S,G) onto the\
    \ upstream interface.\n   Transitions from NotJoined State\n   When the upstream\
    \ (S,G) state machine is in NotJoined state, the\n   following event may trigger\
    \ a state transition:\n     JoinDesired(S,G) becomes True\n          The macro\
    \ JoinDesired(S,G) becomes True, e.g., because the\n          downstream state\
    \ for (S,G) has changed so that at least one\n          interface is in inherited_olist(S,G).\n\
    \          The upstream (S,G) state machine transitions to Joined state.\n   \
    \       Send Join(S,G) to the appropriate upstream neighbor, which is\n      \
    \    RPF'(S,G).  Set the Join Timer (JT) to expire after t_periodic\n        \
    \  seconds.\n   Transitions from Joined State\n   When the upstream (S,G) state\
    \ machine is in Joined state, the\n   following events may trigger state transitions:\n\
    \     JoinDesired(S,G) becomes False\n          The macro JoinDesired(S,G) becomes\
    \ False, e.g., because the\n          downstream state for (S,G) has changed so\
    \ no interface is in\n          inherited_olist(S,G).\n          The upstream\
    \ (S,G) state machine transitions to NotJoined\n          state.  Send Prune(S,G)\
    \ to the appropriate upstream neighbor,\n          which is RPF'(S,G).  Cancel\
    \ the Join Timer (JT), and set\n          SPTbit(S,G) to FALSE.\n     Join Timer\
    \ Expires\n          The Join Timer (JT) expires, indicating time to send a\n\
    \          Join(S,G)\n          Send Join(S,G) to the appropriate upstream neighbor,\
    \ which is\n          RPF'(S,G).  Restart the Join Timer (JT) to expire after\n\
    \          t_periodic seconds.\n     See Join(S,G) to RPF'(S,G)\n          This\
    \ event is only relevant if RPF_interface(S) is a shared\n          medium.  This\
    \ router sees another router on RPF_interface(S)\n          send a Join(S,G) to\
    \ RPF'(S,G).  This causes this router to\n          suppress its own Join.\n \
    \         The upstream (S,G) state machine remains in Joined state.\n        \
    \  Let t_joinsuppress be the minimum of t_suppressed and the\n          HoldTime\
    \ from the Join/Prune message triggering this event.\n          If the Join Timer\
    \ is set to expire in less than t_joinsuppress\n          seconds, reset it so\
    \ that it expires after t_joinsuppress\n          seconds.  If the Join Timer\
    \ is set to expire in more than\n          t_joinsuppress seconds, leave it unchanged.\n\
    \     See Prune(S,G) to RPF'(S,G)\n          This event is only relevant if RPF_interface(S)\
    \ is a shared\n          medium.  This router sees another router on RPF_interface(S)\n\
    \          send a Prune(S,G) to RPF'(S,G).  As this router is in Joined\n    \
    \      state, it must override the Prune after a short random\n          interval.\n\
    \          The upstream (S,G) state machine remains in Joined state.  If\n   \
    \       the Join Timer is set to expire in more than t_override\n          seconds,\
    \ reset it so that it expires after t_override seconds.\n     See Prune(S,G,rpt)\
    \ to RPF'(S,G)\n          This event is only relevant if RPF_interface(S) is a\
    \ shared\n          medium.  This router sees another router on RPF_interface(S)\n\
    \          send a Prune(S,G,rpt) to RPF'(S,G).  If the upstream router is\n  \
    \        an RFC-2362-compliant PIM router, then the Prune(S,G,rpt) will\n    \
    \      cause it to stop forwarding.  For backwards compatibility,\n          this\
    \ router should override the prune so that forwarding\n          continues.\n\
    \          The upstream (S,G) state machine remains in Joined state.  If\n   \
    \       the Join Timer is set to expire in more than t_override\n          seconds,\
    \ reset it so that it expires after t_override seconds.\n     See Prune(*,G) to\
    \ RPF'(S,G)\n          This event is only relevant if RPF_interface(S) is a shared\n\
    \          medium.  This router sees another router on RPF_interface(S)\n    \
    \      send a Prune(*,G) to RPF'(S,G).  If the upstream router is an\n       \
    \   RFC-2362-compliant PIM router, then the Prune(*,G) will cause\n          it\
    \ to stop forwarding.  For backwards compatibility, this\n          router should\
    \ override the prune so that forwarding continues.\n          The upstream (S,G)\
    \ state machine remains in Joined state.  If\n          the Join Timer is set\
    \ to expire in more than t_override\n          seconds, reset it so that it expires\
    \ after t_override seconds.\n     RPF'(S,G) changes due to an Assert\n       \
    \   The current next hop towards S changes due to an Assert(S,G)\n          on\
    \ the RPF_interface(S).\n          The upstream (S,G) state machine remains in\
    \ Joined state.  If\n          the Join Timer is set to expire in more than t_override\n\
    \          seconds, reset it so that it expires after t_override seconds.\n  \
    \        If the Join Timer is set to expire in less than t_override\n        \
    \  seconds, leave it unchanged.\n     RPF'(S,G) changes not due to an Assert\n\
    \          An event occurred that caused the next hop towards S to\n         \
    \ change.  Note that this transition does not occur if an Assert\n          is\
    \ active and the upstream interface does not change.\n          The upstream (S,G)\
    \ state machine remains in Joined state.\n          Send Join(S,G) to the new\
    \ upstream neighbor, which is the new\n          value of RPF'(S,G).  Send Prune(S,G)\
    \ to the old upstream\n          neighbor, which is the old value of RPF'(S,G).\
    \  Set the Join\n          Timer (JT) to expire after t_periodic seconds.\n  \
    \   RPF'(S,G) GenID changes\n          The Generation ID of the router that is\
    \ RPF'(S,G) changes.\n          This normally means that this neighbor has lost\
    \ state, and so\n          the state must be refreshed.\n          The upstream\
    \ (S,G) state machine remains in Joined state.  If\n          the Join Timer is\
    \ set to expire in more than t_override\n          seconds, reset it so that it\
    \ expires after t_override seconds.\n"
- title: 4.5.8.  (S,G,rpt) Periodic Messages
  contents:
  - "4.5.8.  (S,G,rpt) Periodic Messages\n   (S,G,rpt) Joins and Prunes are (S,G)\
    \ Joins or Prunes sent on the RP\n   tree with the RPT bit set, either to modify\
    \ the results of (*,G)\n   Joins, or to override the behavior of other upstream\
    \ LAN peers.  The\n   next section describes the rules for sending triggered messages.\n\
    \   This section describes the rules for including a Prune(S,G,rpt)\n   message\
    \ with a Join(*,G).\n   When a router is going to send a Join(*,G), it should\
    \ use the\n   following pseudocode, for each (S,G) for which it has state, to\n\
    \   decide whether to include a Prune(S,G,rpt) in the compound Join/Prune\n  \
    \ message:\n     if( SPTbit(S,G) == TRUE ) {\n         # Note: If receiving (S,G)\
    \ on the SPT, we only prune off the\n         # shared tree if the RPF neighbors\
    \ differ.\n          if( RPF'(*,G) != RPF'(S,G) ) {\n              add Prune(S,G,rpt)\
    \ to compound message\n          }\n     } else if ( inherited_olist(S,G,rpt)\
    \ == NULL ) {\n       # Note: all (*,G) olist interfaces received RPT prunes for\
    \ (S,G).\n       add Prune(S,G,rpt) to compound message\n     } else if ( RPF'(*,G)\
    \ != RPF'(S,G,rpt) {\n       # Note: we joined the shared tree, but there was\
    \ an (S,G) assert\n       # and the source tree RPF neighbor is different.\n \
    \      add Prune(S,G,rpt) to compound message\n     }\n   Note that Join(S,G,rpt)\
    \ is normally sent not as a periodic message,\n   but only as a triggered message.\n"
- title: 4.5.9.  State Machine for (S,G,rpt) Triggered Messages
  contents:
  - "4.5.9.  State Machine for (S,G,rpt) Triggered Messages\n   The state machine\
    \ for (S,G,rpt) triggered messages is required per-\n   (S,G) when there is (*,G)\
    \ or (*,*,RP) join state at a router, and the\n   router or any of its upstream\
    \ LAN peers wishes to prune S off the RP\n   tree.\n   There are three states\
    \ in the state machine.  One of the states is\n   when there is neither (*,G)\
    \ nor (*,*,RP(G)) join state at this\n   router.  If there is (*,G) or (*,*,RP(G))\
    \ join state at the router,\n   then the state machine must be at one of the other\
    \ two states.  The\n   three states are:\n   Pruned(S,G,rpt)\n      (*,G) or (*,*,RP(G))\
    \ Joined, but (S,G,rpt) pruned\n   NotPruned(S,G,rpt)\n      (*,G) or (*,*,RP(G))\
    \ Joined, and (S,G,rpt) not pruned\n   RPTNotJoined(G)\n      neither (*,G) nor\
    \ (*,*,RP(G)) has been joined.\n   In addition, there is an (S,G,rpt) Override\
    \ Timer, OT(S,G,rpt), which\n   is used to delay triggered Join(S,G,rpt) messages\
    \ to prevent\n   implosions of triggered messages.\n   Figure 9: Upstream (S,G,rpt)\
    \ state machine for triggered messages\n                            in tabular\
    \ form\n"
- title: +------------++--------------------------------------------------------+
  contents:
  - '+------------++--------------------------------------------------------+

    '
- title: '|            ||                           Event                        |'
  contents:
  - '|            ||                           Event                        |

    '
- title: '|            ++--------------+--------------+-------------+------------+'
  contents:
  - '|            ++--------------+--------------+-------------+------------+

    '
- title: '|Prev State  || PruneDesired | PruneDesired | RPTJoin     | inherited_ |'
  contents:
  - '|Prev State  || PruneDesired | PruneDesired | RPTJoin     | inherited_ |

    '
- title: '|            || (S,G,rpt)    | (S,G,rpt)    | Desired(G)  | olist      |'
  contents:
  - '|            || (S,G,rpt)    | (S,G,rpt)    | Desired(G)  | olist      |

    '
- title: '|            || ->True       | ->False      | ->False     | (S,G,rpt)  |'
  contents:
  - '|            || ->True       | ->False      | ->False     | (S,G,rpt)  |

    '
- title: '|            ||              |              |             | ->non-NULL |'
  contents:
  - '|            ||              |              |             | ->non-NULL |

    '
- title: +------------++--------------+--------------+-------------+------------+
  contents:
  - '+------------++--------------+--------------+-------------+------------+

    '
- title: '|RPTNotJoined|| -> P state   | -            | -           | -> NP state|'
  contents:
  - '|RPTNotJoined|| -> P state   | -            | -           | -> NP state|

    '
- title: '|(G) (NJ)    ||              |              |             |            |'
  contents:
  - '|(G) (NJ)    ||              |              |             |            |

    '
- title: +------------++--------------+--------------+-------------+------------+
  contents:
  - '+------------++--------------+--------------+-------------+------------+

    '
- title: '|Pruned      || -            | -> NP state  | -> NJ state | -          |'
  contents:
  - '|Pruned      || -            | -> NP state  | -> NJ state | -          |

    '
- title: '|(S,G,rpt)   ||              | Send Join    |             |            |'
  contents:
  - '|(S,G,rpt)   ||              | Send Join    |             |            |

    '
- title: '|(P)         ||              | (S,G,rpt)    |             |            |'
  contents:
  - '|(P)         ||              | (S,G,rpt)    |             |            |

    '
- title: +------------++--------------+--------------+-------------+------------+
  contents:
  - '+------------++--------------+--------------+-------------+------------+

    '
- title: '|NotPruned   || -> P state   | -            | -> NJ state | -          |'
  contents:
  - '|NotPruned   || -> P state   | -            | -> NJ state | -          |

    '
- title: '|(S,G,rpt)   || Send Prune   |              | Cancel OT   |            |'
  contents:
  - '|(S,G,rpt)   || Send Prune   |              | Cancel OT   |            |

    '
- title: '|(NP)        || (S,G,rpt);   |              |             |            |'
  contents:
  - '|(NP)        || (S,G,rpt);   |              |             |            |

    '
- title: '|            || Cancel OT    |              |             |            |'
  contents:
  - '|            || Cancel OT    |              |             |            |

    '
- title: +------------++--------------+--------------+-------------+------------+
  contents:
  - "+------------++--------------+--------------+-------------+------------+\n  \
    \ Additionally, we have the following transitions within the\n   NotPruned(S,G,rpt)\
    \ state, which are all used for prune override\n   behavior.\n"
- title: +----------------------------------------------------------------------+
  contents:
  - '+----------------------------------------------------------------------+

    '
- title: '|                    In NotPruned(S,G,rpt) State                       |'
  contents:
  - '|                    In NotPruned(S,G,rpt) State                       |

    '
- title: +----------+--------------+--------------+--------------+--------------+
  contents:
  - '+----------+--------------+--------------+--------------+--------------+

    '
- title: '|Override  | See Prune    | See Join     | See Prune    | RPF''         |'
  contents:
  - '|Override  | See Prune    | See Join     | See Prune    | RPF''         |

    '
- title: '|Timer     | (S,G,rpt) to | (S,G,rpt) to | (S,G) to     | (S,G,rpt) -> |'
  contents:
  - '|Timer     | (S,G,rpt) to | (S,G,rpt) to | (S,G) to     | (S,G,rpt) -> |

    '
- title: '|expires   | RPF''         | RPF''         | RPF''         | RPF'' (*,G)   |'
  contents:
  - '|expires   | RPF''         | RPF''         | RPF''         | RPF'' (*,G)   |

    '
- title: '|          | (S,G,rpt)    | (S,G,rpt)    | (S,G,rpt)    |              |'
  contents:
  - '|          | (S,G,rpt)    | (S,G,rpt)    | (S,G,rpt)    |              |

    '
- title: +----------+--------------+--------------+--------------+--------------+
  contents:
  - '+----------+--------------+--------------+--------------+--------------+

    '
- title: '|Send Join | OT = min(OT, | Cancel OT    | OT = min(OT, | OT = min(OT, |'
  contents:
  - '|Send Join | OT = min(OT, | Cancel OT    | OT = min(OT, | OT = min(OT, |

    '
- title: '|(S,G,rpt);| t_override)  |              | t_override)  | t_override)  |'
  contents:
  - '|(S,G,rpt);| t_override)  |              | t_override)  | t_override)  |

    '
- title: '|Leave OT  |              |              |              |              |'
  contents:
  - '|Leave OT  |              |              |              |              |

    '
- title: '|unset     |              |              |              |              |'
  contents:
  - '|unset     |              |              |              |              |

    '
- title: +----------+--------------+--------------+--------------+--------------+
  contents:
  - "+----------+--------------+--------------+--------------+--------------+\n  \
    \ Note that the min function in the above state machine considers a\n   non-running\
    \ timer to have an infinite value (e.g., min(not-running,\n   t_override) = t_override).\n\
    \   This state machine uses the following macros:\n     bool RPTJoinDesired(G)\
    \ {\n       return (JoinDesired(*,G) OR JoinDesired(*,*,RP(G)))\n     }\n   RPTJoinDesired(G)\
    \ is true when the router has forwarding state that\n   would cause it to forward\
    \ traffic for G using either (*,G) or\n   (*,*,RP) shared tree state.\n     bool\
    \ PruneDesired(S,G,rpt) {\n          return ( RPTJoinDesired(G) AND\n        \
    \           ( inherited_olist(S,G,rpt) == NULL\n                     OR (SPTbit(S,G)==TRUE\n\
    \                         AND (RPF'(*,G) != RPF'(S,G)) )))\n     }\n   PruneDesired(S,G,rpt)\
    \ can only be true if RPTJoinDesired(G) is true.\n   If RPTJoinDesired(G) is true,\
    \ then PruneDesired(S,G,rpt) is true\n   either if there are no outgoing interfaces\
    \ that S would be forwarded\n   on, or if the router has active (S,G) forwarding\
    \ state but RPF'(*,G)\n   != RPF'(S,G).\n   The state machine contains the following\
    \ transition events:\n   See Join(S,G,rpt) to RPF'(S,G,rpt)\n      This event\
    \ is only relevant in the \"Not Pruned\" state.\n      The router sees a Join(S,G,rpt)\
    \ from someone else to\n      RPF'(S,G,rpt), which is the correct upstream neighbor.\
    \  If we're\n      in \"NotPruned\" state and the (S,G,rpt) Override Timer is\
    \ running,\n      then this is because we have been triggered to send our own\n\
    \      Join(S,G,rpt) to RPF'(S,G,rpt).  Someone else beat us to it, so\n     \
    \ there's no need to send our own Join.\n      The action is to cancel the Override\
    \ Timer.\n   See Prune(S,G,rpt) to RPF'(S,G,rpt)\n      This event is only relevant\
    \ in the \"NotPruned\" state.\n      The router sees a Prune(S,G,rpt) from someone\
    \ else to\n      RPF'(S,G,rpt), which is the correct upstream neighbor.  If we're\n\
    \      in the \"NotPruned\" state, then we want to continue to receive\n     \
    \ traffic from S destined for G, and that traffic is being supplied\n      by\
    \ RPF'(S,G,rpt).  Thus, we need to override the Prune.\n      The action is to\
    \ set the (S,G,rpt) Override Timer to the\n      randomized prune-override interval,\
    \ t_override.  However, if the\n      Override Timer is already running, we only\
    \ set the timer if doing\n      so would set it to a lower value.  At the end\
    \ of this interval, if\n      noone else has sent a Join, then we will do so.\n\
    \   See Prune(S,G) to RPF'(S,G,rpt)\n      This event is only relevant in the\
    \ \"NotPruned\" state.\n      This transition and action are the same as the above\
    \ transition\n      and action, except that the Prune does not have the RPT bit\
    \ set.\n      This transition is necessary to be compatible with routers\n   \
    \   implemented from RFC2362 that don't maintain separate (S,G) and\n      (S,G,rpt)\
    \ state.\n   The (S,G,rpt) prune Override Timer expires\n      This event is only\
    \ relevant in the \"NotPruned\" state.\n      When the Override Timer expires,\
    \ we must send a Join(S,G,rpt) to\n      RPF'(S,G,rpt) to override the Prune message\
    \ that caused the timer\n      to be running.  We only send this if RPF'(S,G,rpt)\
    \ equals\n      RPF'(*,G); if this were not the case, then the Join might be sent\n\
    \      to a router that does not have (*,G) or (*,*,RP(G)) Join state,\n     \
    \ and so the behavior would not be well defined.  If RPF'(S,G,rpt)\n      is not\
    \ the same as RPF'(*,G), then it may stop forwarding S.\n      However, if this\
    \ happens, then the router will send an\n      AssertCancel(S,G), which would\
    \ then cause RPF'(S,G,rpt) to become\n      equal to RPF'(*,G) (see below).\n\
    \   RPF'(S,G,rpt) changes to become equal to RPF'(*,G)\n      This event is only\
    \ relevant in the \"NotPruned\" state.\n      RPF'(S,G,rpt) can only be different\
    \ from RPF'(*,G) if an (S,G)\n      Assert has happened, which means that traffic\
    \ from S is arriving\n      on the SPT, and so Prune(S,G,rpt) will have been sent\
    \ to\n      RPF'(*,G).  When RPF'(S,G,rpt) changes to become equal to\n      RPF'(*,G),\
    \ we need to trigger a Join(S,G,rpt) to RPF'(*,G) to\n      cause that router\
    \ to start forwarding S again.\n      The action is to set the (S,G,rpt) Override\
    \ Timer to the\n      randomized prune-override interval t_override.  However,\
    \ if the\n      timer is already running, we only set the timer if doing so would\n\
    \      set it to a lower value.  At the end of this interval, if noone\n     \
    \ else has sent a Join, then we will do so.\n   PruneDesired(S,G,rpt)->TRUE\n\
    \      See macro above.  This event is relevant in the \"NotPruned\" and\n   \
    \   \"RPTNotJoined(G)\" states.\n      The router wishes to receive traffic for\
    \ G, but does not wish to\n      receive traffic from S destined for G.  This\
    \ causes the router to\n      transition into the Pruned state.\n      If the\
    \ router was previously in NotPruned state, then the action\n      is to send\
    \ a Prune(S,G,rpt) to RPF'(S,G,rpt), and to cancel the\n      Override Timer.\
    \  If the router was previously in RPTNotJoined(G)\n      state, then there is\
    \ no need to trigger an action in this state\n      machine because sending a\
    \ Prune(S,G,rpt) is handled by the rules\n      for sending the Join(*,G) or Join(*,*,RP).\n\
    \   PruneDesired(S,G,rpt)->FALSE\n      See macro above.  This transition is only\
    \ relevant in the \"Pruned\"\n      state.\n      If the router is in the Pruned(S,G,rpt)\
    \ state, and\n      PruneDesired(S,G,rpt) changes to FALSE, this could be because\
    \ the\n      router no longer has RPTJoinDesired(G) true, or it now wishes to\n\
    \      receive traffic from S again.  If it is the former, then this\n      transition\
    \ should not happen, but instead the\n      \"RPTJoinDesired(G)->FALSE\" transition\
    \ should happen.  Thus, this\n      transition should be interpreted as \"PruneDesired(S,G,rpt)->FALSE\n\
    \      AND RPTJoinDesired(G)==TRUE\".\n      The action is to send a Join(S,G,rpt)\
    \ to RPF'(S,G,rpt).\n   RPTJoinDesired(G)->FALSE\n      This event is relevant\
    \ in the \"Pruned\" and \"NotPruned\" states.\n      The router no longer wishes\
    \ to receive any traffic destined for G\n      on the RP Tree.  This causes a\
    \ transition to the RPTNotJoined(G)\n      state, and the Override Timer is canceled\
    \ if it was running.  Any\n      further actions are handled by the appropriate\
    \ upstream state\n      machine for (*,G) or (*,*,RP).\n   inherited_olist(S,G,rpt)\
    \ becomes non-NULL\n      This transition is only relevant in the RPTNotJoined(G)\
    \ state.\n      The router has joined the RP tree (handled by the (*,G) or\n \
    \     (*,*,RP) upstream state machine as appropriate) and wants to\n      receive\
    \ traffic from S.  This does not trigger any events in this\n      state machine,\
    \ but causes a transition to the NotPruned(S,G,rpt)\n      state.\n"
- title: '4.5.10.  Background: (*,*,RP) and (S,G,rpt) Interaction'
  contents:
  - "4.5.10.  Background: (*,*,RP) and (S,G,rpt) Interaction\n   In Sections 4.5.8\
    \ and 4.5.9, the mechanisms for sending periodic and\n   triggered (S,G,rpt) messages\
    \ are described.  The astute reader will\n   note that periodic Prune(S,G,rpt)\
    \ messages are only sent in PIM\n   Join/Prune messages containing a Join(*,G),\
    \ whereas it is possible\n   for a triggered Prune(S,G,rpt) message to be sent\
    \ when the router has\n   no (*,G) join state.  This may seem like a contradiction,\
    \ but in fact\n   it is intentional and is a side effect of not optimizing (*,*,RP)\n\
    \   behavior.\n   We first note that reception of a Join(*,*,RP) by itself does\
    \ not\n   cancel (S,G,rpt) prune state on that interface, whereas receiving a\n\
    \   Join(*,G) by itself does cancel (S,G,rpt) prune state on that\n   interface.\
    \  Similarly, reception of a Prune(*,G) on an interface with\n   (*,*,RP) join\
    \ state does not by itself prevent forwarding of G using\n   the (*,*,RP) state;\
    \ this is because a Prune(*,G) only serves to\n   cancel (*,G) join state.  Conceptually\
    \ (*,*,RP) state functions\n   \"above\" the normal (*,G) and (S,G) mechanisms,\
    \ and so neither\n   Join(*,*,RP) nor Prune(*,*,RP) messages affect any other\
    \ state.\n   The upshot of this is that to prevent forwarding (S,G) on (*,*,RP)\n\
    \   state, a Prune(S,G,rpt) must be used.\n   We also note that for historical\
    \ reasons there is no Assert(*,*,RP)\n   message, so any forwarding contention\
    \ is resolved using Assert(*,G)\n   messages.\n   We now need to consider the\
    \ interaction between (*,*,RP) state and\n   (*,G) state.  If there is a need\
    \ for an assert between two upstream\n   routers on a LAN, we need to ensure that\
    \ the correct thing happens\n   for all combinations of (*,*,RP) and (*,G) forwarding\
    \ state.  As\n   there is no Assert(*,*,RP) message, no router can tell whether\
    \ the\n   assert winner has (*,*,RP) state or (*,G) state.  Thus, a downstream\n\
    \   router has to treat the two the same and send its periodic\n   Prune(S,G,rpt)\
    \ messages to RPF'(*,G).\n   To avoid needing to specify all the complex override\
    \ rules between\n   (*,*,RP), (*,G), and (S,G,rpt), we simply require that to\
    \ prune (S,G)\n   off the (*,*,RP) tree, a Join(*,G) must also be sent.\n   If\
    \ a router is receiving on (*,*,RP) state and has not yet had (*,G)\n   state\
    \ instantiated, it may still need to send a triggered\n   Join(S,G,rpt) to override\
    \ a Prune(S,G,rpt) that it sees directed to\n   RPF'(*,G) on its upstream interface.\
    \  Hence, triggered (S,G,rpt)\n   messages may be sent when JoinDesired(*,G) is\
    \ false but\n   JoinDesired(*,*,RP) is true.\n   Finally, we note that there is\
    \ an unoptimized case when the upstream\n   router on a LAN already has (*,G)\
    \ join and (S,G,rpt) prune state\n   caused by an existing downstream router.\
    \  If at this time a new\n   Join(*,*,RP) is sent to the upstream router from\
    \ a different\n   downstream router, this will not override the (S,G,rpt) prune\
    \ state\n   at the upstream router.  The override will not occur until the next\n\
    \   time the original downstream router resends its Prune(S,G,rpt).  This\n  \
    \ case was not considered worth optimizing, as (*,*,RP) state is\n   generally\
    \ very long lived, and so any minor delays in getting traffic\n   to a new PMBR\
    \ seem unimportant.\n"
- title: 4.6.  PIM Assert Messages
  contents:
  - "4.6.  PIM Assert Messages\n   Where multiple PIM routers peer over a shared LAN,\
    \ it is possible for\n   more than one upstream router to have valid forwarding\
    \ state for a\n   packet, which can lead to packet duplication (see Section 3.6).\
    \  PIM\n   does not attempt to prevent this from occurring.  Instead, it detects\n\
    \   when this has happened and elects a single forwarder amongst the\n   upstream\
    \ routers to prevent further duplication.  This election is\n   performed using\
    \ PIM Assert messages.  Assert messages are also\n   received by downstream routers\
    \ on the LAN, and these cause subsequent\n   Join/Prune messages to be sent to\
    \ the upstream router that won the\n   Assert.\n   In general, a PIM Assert message\
    \ should only be accepted for\n   processing if it comes from a known PIM neighbor.\
    \  A PIM router hears\n   about PIM neighbors through PIM Hello messages.  If\
    \ a router receives\n   an Assert message from a particular IP source address\
    \ and it has not\n   seen a PIM Hello message from that source address, then the\
    \ Assert\n   message SHOULD be discarded without further processing.  In addition,\n\
    \   if the Hello message from a neighbor was authenticated using the\n   IPsec\
    \ Authentication Header (AH) (see Section 6.3), then all Assert\n   messages from\
    \ that neighbor MUST also be authenticated using IPsec\n   AH.\n   We note that\
    \ some older PIM implementations incorrectly fail to send\n   Hello messages on\
    \ point-to-point interfaces, so we also RECOMMEND\n   that a configuration option\
    \ be provided to allow interoperation with\n   such older routers, but that this\
    \ configuration option SHOULD NOT be\n   enabled by default.\n"
- title: 4.6.1.  (S,G) Assert Message State Machine
  contents:
  - "4.6.1.  (S,G) Assert Message State Machine\n   The (S,G) Assert state machine\
    \ for interface I is shown in Figure 10.\n   There are three states:\n   NoInfo\
    \ (NI)\n      This router has no (S,G) assert state on interface I.\n   I am Assert\
    \ Winner (W)\n      This router has won an (S,G) assert on interface I.  It is\
    \ now\n      responsible for forwarding traffic from S destined for G out of\n\
    \      interface I.  Irrespective of whether it is the DR for I, while a\n   \
    \   router is the assert winner, it is also responsible for forwarding\n     \
    \ traffic onto I on behalf of local hosts on I that have made\n      membership\
    \ requests that specifically refer to S (and G).\n   I am Assert Loser (L)\n \
    \     This router has lost an (S,G) assert on interface I.  It must not\n    \
    \  forward packets from S destined for G onto interface I.  If it is\n      the\
    \ DR on I, it is no longer responsible for forwarding traffic\n      onto I to\
    \ satisfy local hosts with membership requests that\n      specifically refer\
    \ to S and G.\n   In addition, there is also an Assert Timer (AT) that is used\
    \ to time\n   out asserts on the assert losers and to resend asserts on the assert\n\
    \   winner.\n  Figure 10: Per-interface (S,G) Assert State machine in tabular\
    \ form\n"
- title: +----------------------------------------------------------------------+
  contents:
  - '+----------------------------------------------------------------------+

    '
- title: '|                         In NoInfo (NI) State                         |'
  contents:
  - '|                         In NoInfo (NI) State                         |

    '
- title: +---------------+-------------------+------------------+---------------+
  contents:
  - '+---------------+-------------------+------------------+---------------+

    '
- title: '| Receive       |  Receive Assert   |  Data arrives    |  Receive      |'
  contents:
  - '| Receive       |  Receive Assert   |  Data arrives    |  Receive      |

    '
- title: '| Inferior      |  with RPTbit      |  from S to G on  |  Acceptable   |'
  contents:
  - '| Inferior      |  with RPTbit      |  from S to G on  |  Acceptable   |

    '
- title: '| Assert with   |  set and          |  I and           |  Assert with  |'
  contents:
  - '| Assert with   |  set and          |  I and           |  Assert with  |

    '
- title: '| RPTbit clear  |  CouldAssert      |  CouldAssert     |  RPTbit clear |'
  contents:
  - '| RPTbit clear  |  CouldAssert      |  CouldAssert     |  RPTbit clear |

    '
- title: '| and           |  (S,G,I)          |  (S,G,I)         |  and AssTrDes |'
  contents:
  - '| and           |  (S,G,I)          |  (S,G,I)         |  and AssTrDes |

    '
- title: '| CouldAssert   |                   |                  |  (S,G,I)      |'
  contents:
  - '| CouldAssert   |                   |                  |  (S,G,I)      |

    '
- title: '| (S,G,I)       |                   |                  |               |'
  contents:
  - '| (S,G,I)       |                   |                  |               |

    '
- title: +---------------+-------------------+------------------+---------------+
  contents:
  - '+---------------+-------------------+------------------+---------------+

    '
- title: '| -> W state    |  -> W state       |  -> W state      |  -> L state   |'
  contents:
  - '| -> W state    |  -> W state       |  -> W state      |  -> L state   |

    '
- title: '| [Actions A1]  |  [Actions A1]     |  [Actions A1]    |  [Actions A6] |'
  contents:
  - '| [Actions A1]  |  [Actions A1]     |  [Actions A1]    |  [Actions A6] |

    '
- title: +---------------+-------------------+------------------+---------------+
  contents:
  - '+---------------+-------------------+------------------+---------------+

    '
- title: +----------------------------------------------------------------------+
  contents:
  - '+----------------------------------------------------------------------+

    '
- title: '|                   In I Am Assert Winner (W) State                    |'
  contents:
  - '|                   In I Am Assert Winner (W) State                    |

    '
- title: +----------------+------------------+-----------------+----------------+
  contents:
  - '+----------------+------------------+-----------------+----------------+

    '
- title: '| Assert Timer   |   Receive        |  Receive        |  CouldAssert   |'
  contents:
  - '| Assert Timer   |   Receive        |  Receive        |  CouldAssert   |

    '
- title: '| Expires        |   Inferior       |  Preferred      |  (S,G,I) ->    |'
  contents:
  - '| Expires        |   Inferior       |  Preferred      |  (S,G,I) ->    |

    '
- title: '|                |   Assert         |  Assert         |  FALSE         |'
  contents:
  - '|                |   Assert         |  Assert         |  FALSE         |

    '
- title: +----------------+------------------+-----------------+----------------+
  contents:
  - '+----------------+------------------+-----------------+----------------+

    '
- title: '| -> W state     |   -> W state     |  -> L state     |  -> NI state   |'
  contents:
  - '| -> W state     |   -> W state     |  -> L state     |  -> NI state   |

    '
- title: '| [Actions A3]   |   [Actions A3]   |  [Actions A2]   |  [Actions A4]  |'
  contents:
  - '| [Actions A3]   |   [Actions A3]   |  [Actions A2]   |  [Actions A4]  |

    '
- title: +----------------+------------------+-----------------+----------------+
  contents:
  - '+----------------+------------------+-----------------+----------------+

    '
- title: +---------------------------------------------------------------------+
  contents:
  - '+---------------------------------------------------------------------+

    '
- title: '|                   In I Am Assert Loser (L) State                    |'
  contents:
  - '|                   In I Am Assert Loser (L) State                    |

    '
- title: +-------------+-------------+-------------+-------------+-------------+
  contents:
  - '+-------------+-------------+-------------+-------------+-------------+

    '
- title: '|Receive      |Receive      |Receive      |Assert Timer |Current      |'
  contents:
  - '|Receive      |Receive      |Receive      |Assert Timer |Current      |

    '
- title: '|Preferred    |Acceptable   |Inferior     |Expires      |Winner''s     |'
  contents:
  - '|Preferred    |Acceptable   |Inferior     |Expires      |Winner''s     |

    '
- title: '|Assert       |Assert with  |Assert or    |             |GenID        |'
  contents:
  - '|Assert       |Assert with  |Assert or    |             |GenID        |

    '
- title: '|             |RPTbit clear |Assert       |             |Changes or   |'
  contents:
  - '|             |RPTbit clear |Assert       |             |Changes or   |

    '
- title: '|             |from Current |Cancel from  |             |NLT Expires  |'
  contents:
  - '|             |from Current |Cancel from  |             |NLT Expires  |

    '
- title: '|             |Winner       |Current      |             |             |'
  contents:
  - '|             |Winner       |Current      |             |             |

    '
- title: '|             |             |Winner       |             |             |'
  contents:
  - '|             |             |Winner       |             |             |

    '
- title: +-------------+-------------+-------------+-------------+-------------+
  contents:
  - '+-------------+-------------+-------------+-------------+-------------+

    '
- title: '|-> L state   |-> L state   |-> NI state  |-> NI state  |-> NI state  |'
  contents:
  - '|-> L state   |-> L state   |-> NI state  |-> NI state  |-> NI state  |

    '
- title: '|[Actions A2] |[Actions A2] |[Actions A5] |[Actions A5] |[Actions A5] |'
  contents:
  - '|[Actions A2] |[Actions A2] |[Actions A5] |[Actions A5] |[Actions A5] |

    '
- title: +-------------+-------------+-------------+-------------+-------------+
  contents:
  - '+-------------+-------------+-------------+-------------+-------------+

    '
- title: +----------------------------------------------------------------------+
  contents:
  - '+----------------------------------------------------------------------+

    '
- title: '|                    In I Am Assert Loser (L) State                    |'
  contents:
  - '|                    In I Am Assert Loser (L) State                    |

    '
- title: +----------------+-----------------+------------------+----------------+
  contents:
  - '+----------------+-----------------+------------------+----------------+

    '
- title: '| AssTrDes       |  my_metric ->   |  RPF_interface   |  Receive       |'
  contents:
  - '| AssTrDes       |  my_metric ->   |  RPF_interface   |  Receive       |

    '
- title: '| (S,G,I) ->     |  better than    |  (S) stops       |  Join(S,G) on  |'
  contents:
  - '| (S,G,I) ->     |  better than    |  (S) stops       |  Join(S,G) on  |

    '
- title: '| FALSE          |  winner''s       |  being I         |  interface I   |'
  contents:
  - '| FALSE          |  winner''s       |  being I         |  interface I   |

    '
- title: '|                |  metric         |                  |                |'
  contents:
  - '|                |  metric         |                  |                |

    '
- title: +----------------+-----------------+------------------+----------------+
  contents:
  - '+----------------+-----------------+------------------+----------------+

    '
- title: '| -> NI state    |  -> NI state    |  -> NI state     |  -> NI State   |'
  contents:
  - '| -> NI state    |  -> NI state    |  -> NI state     |  -> NI State   |

    '
- title: '| [Actions A5]   |  [Actions A5]   |  [Actions A5]    |  [Actions A5]  |'
  contents:
  - '| [Actions A5]   |  [Actions A5]   |  [Actions A5]    |  [Actions A5]  |

    '
- title: +----------------+-----------------+------------------+----------------+
  contents:
  - "+----------------+-----------------+------------------+----------------+\n  \
    \ Note that for reasons of compactness, \"AssTrDes(S,G,I)\" is used in\n   the\
    \ state machine table to refer to AssertTrackingDesired(S,G,I).\n   Terminology:\n\
    \      A \"preferred assert\" is one with a better metric than the current\n \
    \     winner.\n      An \"acceptable assert\" is one that has a better metric\
    \ than\n      my_assert_metric(S,G,I).  An assert is never considered acceptable\n\
    \      if its metric is infinite.\n      An \"inferior assert\" is one with a\
    \ worse metric than\n      my_assert_metric(S,G,I).  An assert is never considered\
    \ inferior\n      if my_assert_metric(S,G,I) is infinite.\n   The state machine\
    \ uses the following macros:\n"
- title: CouldAssert(S,G,I) =
  contents:
  - "CouldAssert(S,G,I) =\n     SPTbit(S,G)==TRUE\n     AND (RPF_interface(S) != I)\n\
    \     AND (I in ( ( joins(*,*,RP(G)) (+) joins(*,G) (-) prunes(S,G,rpt) )\n  \
    \               (+) ( pim_include(*,G) (-) pim_exclude(S,G) )\n              \
    \   (-) lost_assert(*,G)\n                 (+) joins(S,G) (+) pim_include(S,G)\
    \ ) )\n   CouldAssert(S,G,I) is true for downstream interfaces that would be in\n\
    \   the inherited_olist(S,G) if (S,G) assert information was not taken\n   into\
    \ account.\n   AssertTrackingDesired(S,G,I) =\n        (I in ( ( joins(*,*,RP(G))\
    \ (+) joins(*,G) (-) prunes(S,G,rpt) )\n                (+) ( pim_include(*,G)\
    \ (-) pim_exclude(S,G) )\n                (-) lost_assert(*,G)\n             \
    \   (+) joins(S,G) ) )\n        OR (local_receiver_include(S,G,I) == TRUE\n  \
    \          AND (I_am_DR(I) OR (AssertWinner(S,G,I) == me)))\n        OR ((RPF_interface(S)\
    \ == I) AND (JoinDesired(S,G) == TRUE))\n        OR ((RPF_interface(RP(G)) ==\
    \ I) AND (JoinDesired(*,G) == TRUE)\n            AND (SPTbit(S,G) == FALSE))\n\
    \   AssertTrackingDesired(S,G,I) is true on any interface in which an\n   (S,G)\
    \ assert might affect our behavior.\n   The first three lines of AssertTrackingDesired\
    \ account for (*,G) join\n   and local membership information received on I that\
    \ might cause the\n   router to be interested in asserts on I.\n   The 4th line\
    \ accounts for (S,G) join information received on I that\n   might cause the router\
    \ to be interested in asserts on I.\n   The 5th and 6th lines account for (S,G)\
    \ local membership information\n   on I.  Note that we can't use the pim_include(S,G)\
    \ macro since it\n   uses lost_assert(S,G,I) and would result in the router forgetting\n\
    \   that it lost an assert if the only reason it was interested was local\n  \
    \ membership.  The AssertWinner(S,G,I) check forces an assert winner to\n   keep\
    \ on being responsible for forwarding as long as local receivers\n   are present.\
    \  Removing this check would make the assert winner give\n   up forwarding as\
    \ soon as the information that originally caused it to\n   forward went away,\
    \ and the task of forwarding for local receivers\n   would revert back to the\
    \ DR.\n   The last three lines account for the fact that a router must keep\n\
    \   track of assert information on upstream interfaces in order to send\n   joins\
    \ and prunes to the proper neighbor.\n   Transitions from NoInfo State\n   When\
    \ in NoInfo state, the following events may trigger transitions:\n     Receive\
    \ Inferior Assert with RPTbit cleared AND\n          CouldAssert(S,G,I)==TRUE\n\
    \          An assert is received for (S,G) with the RPT bit cleared that\n   \
    \       is inferior to our own assert metric.  The RPT bit cleared\n         \
    \ indicates that the sender of the assert had (S,G) forwarding\n          state\
    \ on this interface.  If the assert is inferior to our\n          metric, then\
    \ we must also have (S,G) forwarding state (i.e.,\n          CouldAssert(S,G,I)==TRUE)\
    \ as (S,G) asserts beat (*,G) asserts,\n          and so we should be the assert\
    \ winner.  We transition to the\n          \"I am Assert Winner\" state and perform\
    \ Actions A1 (below).\n     Receive Assert with RPTbit set AND CouldAssert(S,G,I)==TRUE\n\
    \          An assert is received for (S,G) on I with the RPT bit set\n       \
    \   (it's a (*,G) assert).  CouldAssert(S,G,I) is TRUE only if we\n          have\
    \ (S,G) forwarding state on this interface, so we should be\n          the assert\
    \ winner.  We transition to the \"I am Assert Winner\"\n          state and perform\
    \ Actions A1 (below).\n     An (S,G) data packet arrives on interface I, AND\n\
    \          CouldAssert(S,G,I)==TRUE\n          An (S,G) data packet arrived on\
    \ an downstream interface that\n          is in our (S,G) outgoing interface list.\
    \  We optimistically\n          assume that we will be the assert winner for this\
    \ (S,G), and\n          so we transition to the \"I am Assert Winner\" state and\
    \ perform\n          Actions A1 (below), which will initiate the assert negotiation\n\
    \          for (S,G).\n     Receive Acceptable Assert with RPT bit clear AND\n\
    \          AssertTrackingDesired(S,G,I)==TRUE\n          We're interested in (S,G)\
    \ Asserts, either because I is a\n          downstream interface for which we\
    \ have (S,G) or (*,G)\n          forwarding state, or because I is the upstream\
    \ interface for S\n          and we have (S,G) forwarding state.  The received\
    \ assert has a\n          better metric than our own, so we do not win the Assert.\
    \  We\n          transition to \"I am Assert Loser\" and perform Actions A6\n\
    \          (below).\n   Transitions from \"I am Assert Winner\" State\n   When\
    \ in \"I am Assert Winner\" state, the following events trigger\n   transitions:\n\
    \     Assert Timer Expires\n          The (S,G) Assert Timer expires.  As we're\
    \ in the Winner state,\n          we must still have (S,G) forwarding state that\
    \ is actively\n          being kept alive.  We resend the (S,G) Assert and restart\
    \ the\n          Assert Timer (Actions A3 below).  Note that the assert\n    \
    \      winner's Assert Timer is engineered to expire shortly before\n        \
    \  timers on assert losers; this prevents unnecessary thrashing\n          of\
    \ the forwarder and periodic flooding of duplicate packets.\n     Receive Inferior\
    \ Assert\n          We receive an (S,G) assert or (*,G) assert mentioning S that\n\
    \          has a worse metric than our own.  Whoever sent the assert is\n    \
    \      in error, and so we resend an (S,G) Assert and restart the\n          Assert\
    \ Timer (Actions A3 below).\n     Receive Preferred Assert\n          We receive\
    \ an (S,G) assert that has a better metric than our\n          own.  We transition\
    \ to \"I am Assert Loser\" state and perform\n          Actions A2 (below).  Note\
    \ that this may affect the value of\n          JoinDesired(S,G) and PruneDesired(S,G,rpt),\
    \ which could cause\n          transitions in the upstream (S,G) or (S,G,rpt)\
    \ state machines.\n     CouldAssert(S,G,I) -> FALSE\n          Our (S,G) forwarding\
    \ state or RPF interface changed so as to\n          make CouldAssert(S,G,I) become\
    \ false.  We can no longer\n          perform the actions of the assert winner,\
    \ and so we transition\n          to NoInfo state and perform Actions A4 (below).\
    \  This includes\n          sending a \"canceling assert\" with an infinite metric.\n\
    \   Transitions from \"I am Assert Loser\" State\n   When in \"I am Assert Loser\"\
    \ state, the following transitions can\n   occur:\n     Receive Preferred Assert\n\
    \          We receive an assert that is better than that of the current\n    \
    \      assert winner.  We stay in Loser state and perform Actions A2\n       \
    \   below.\n     Receive Acceptable Assert with RPTbit clear from Current Winner\n\
    \          We receive an assert from the current assert winner that is\n     \
    \     better than our own metric for this (S,G) (although the metric\n       \
    \   may be worse than the winner's previous metric).  We stay in\n          Loser\
    \ state and perform Actions A2 below.\n     Receive Inferior Assert or Assert\
    \ Cancel from Current Winner\n          We receive an assert from the current\
    \ assert winner that is\n          worse than our own metric for this group (typically,\
    \ because\n          the winner's metric became worse or because it is an assert\n\
    \          cancel).  We transition to NoInfo state, deleting the (S,G)\n     \
    \     assert information and allowing the normal PIM Join/Prune\n          mechanisms\
    \ to operate.  Usually, we will eventually re-assert\n          and win when data\
    \ packets from S have started flowing again.\n     Assert Timer Expires\n    \
    \      The (S,G) Assert Timer expires.  We transition to NoInfo\n          state,\
    \ deleting the (S,G) assert information (Actions A5\n          below).\n     Current\
    \ Winner's GenID Changes or NLT Expires\n          The Neighbor Liveness Timer\
    \ associated with the current winner\n          expires or we receive a Hello\
    \ message from the current winner\n          reporting a different GenID from\
    \ the one it previously\n          reported.  This indicates that the current\
    \ winner's interface\n          or router has gone down (and may have come back\
    \ up), and so we\n          must assume it no longer knows it was the winner.\
    \  We\n          transition to the NoInfo state, deleting this (S,G) assert\n\
    \          information (Actions A5 below).\n     AssertTrackingDesired(S,G,I)->FALSE\n\
    \          AssertTrackingDesired(S,G,I) becomes FALSE.  Our forwarding\n     \
    \     state has changed so that (S,G) Asserts on interface I are no\n        \
    \  longer of interest to us.  We transition to the NoInfo state,\n          deleting\
    \ the (S,G) assert information.\n     My metric becomes better than the assert\
    \ winner's metric\n          my_assert_metric(S,G,I) has changed so that now my\
    \ assert\n          metric for (S,G) is better than the metric we have stored\
    \ for\n          current assert winner.  This might happen when the underlying\n\
    \          routing metric changes, or when CouldAssert(S,G,I) becomes\n      \
    \    true; for example, when SPTbit(S,G) becomes true.  We\n          transition\
    \ to NoInfo state, delete this (S,G) assert state\n          (Actions A5 below),\
    \ and allow the normal PIM Join/Prune\n          mechanisms to operate.  Usually,\
    \ we will eventually re-assert\n          and win when data packets from S have\
    \ started flowing again.\n     RPF_interface(S) stops being interface I\n    \
    \      Interface I used to be the RPF interface for S, and now it is\n       \
    \   not.  We transition to NoInfo state, deleting this (S,G)\n          assert\
    \ state (Actions A5 below).\n     Receive Join(S,G) on Interface I\n         \
    \ We receive a Join(S,G) that has the Upstream Neighbor Address\n          field\
    \ set to my primary IP address on interface I.  The action\n          is to transition\
    \ to NoInfo state, delete this (S,G) assert\n          state (Actions A5 below),\
    \ and allow the normal PIM Join/Prune\n          mechanisms to operate.  If whoever\
    \ sent the Join was in error,\n          then the normal assert mechanism will\
    \ eventually re-apply, and\n          we will lose the assert again.  However,\
    \ whoever sent the\n          assert may know that the previous assert winner\
    \ has died, and\n          so we may end up being the new forwarder.\n   (S,G)\
    \ Assert State machine Actions\n     A1:  Send Assert(S,G).\n          Set Assert\
    \ Timer to (Assert_Time - Assert_Override_Interval).\n          Store self as\
    \ AssertWinner(S,G,I).\n          Store spt_assert_metric(S,I) as AssertWinnerMetric(S,G,I).\n\
    \     A2:  Store new assert winner as AssertWinner(S,G,I) and assert\n       \
    \   winner metric as AssertWinnerMetric(S,G,I).\n          Set Assert Timer to\
    \ Assert_Time.\n     A3:  Send Assert(S,G).\n          Set Assert Timer to (Assert_Time\
    \ - Assert_Override_Interval).\n     A4:  Send AssertCancel(S,G).\n          Delete\
    \ assert info (AssertWinner(S,G,I) and\n          AssertWinnerMetric(S,G,I) will\
    \ then return their default\n          values).\n     A5:  Delete assert info\
    \ (AssertWinner(S,G,I) and\n          AssertWinnerMetric(S,G,I) will then return\
    \ their default\n          values).\n     A6:  Store new assert winner as AssertWinner(S,G,I)\
    \ and assert\n          winner metric as AssertWinnerMetric(S,G,I).\n        \
    \  Set Assert Timer to Assert_Time.\n          If (I is RPF_interface(S)) AND\
    \ (UpstreamJPState(S,G) == true)\n          set SPTbit(S,G) to TRUE.\n   Note\
    \ that some of these actions may cause the value of\n   JoinDesired(S,G), PruneDesired(S,G,rpt),\
    \ or RPF'(S,G) to change,\n   which could cause further transitions in other state\
    \ machines.\n"
- title: 4.6.2.  (*,G) Assert Message State Machine
  contents:
  - "4.6.2.  (*,G) Assert Message State Machine\n   The (*,G) Assert state machine\
    \ for interface I is shown in Figure 11.\n   There are three states:\n   NoInfo\
    \ (NI)\n      This router has no (*,G) assert state on interface I.\n   I am Assert\
    \ Winner (W)\n      This router has won an (*,G) assert on interface I.  It is\
    \ now\n      responsible for forwarding traffic destined for G onto interface\
    \ I\n      with the exception of traffic for which it has (S,G) \"I am Assert\n\
    \      Loser\" state.  Irrespective of whether it is the DR for I, it is\n   \
    \   also responsible for handling the membership requests for G from\n      local\
    \ hosts on I.\n   I am Assert Loser (L)\n      This router has lost an (*,G) assert\
    \ on interface I.  It must not\n      forward packets for G onto interface I with\
    \ the exception of\n      traffic from sources for which is has (S,G) \"I am Assert\
    \ Winner\"\n      state.  If it is the DR, it is no longer responsible for handling\n\
    \      the membership requests for group G from local hosts on I.\n   In addition,\
    \ there is also an Assert Timer (AT) that is used to time\n   out asserts on the\
    \ assert losers and to resend asserts on the assert\n   winner.\n   When an Assert\
    \ message is received with a source address other than\n   zero, a PIM implementation\
    \ must first match it against the possible\n   events in the (S,G) assert state\
    \ machine and process any transitions\n   and actions, before considering whether\
    \ the Assert message matches\n   against the (*,G) assert state machine.\n   It\
    \ is important to note that NO TRANSITION CAN OCCUR in the (*,G)\n   state machine\
    \ as a result of receiving an Assert message unless the\n   (S,G) assert state\
    \ machine for the relevant S and G is in the\n   \"NoInfo\" state after the (S,G)\
    \ state machine has processed the\n   message.  Also, NO TRANSITION CAN OCCUR\
    \ in the (*,G) state machine as\n   a result of receiving an assert message if\
    \ that message triggers any\n   change of state in the (S,G) state machine.  Obviously,\
    \ when the\n   source address in the received message is set to zero, an (S,G)\
    \ state\n   machine for the S and G does not exist and can be assumed to be in\n\
    \   the \"NoInfo\" state.\n   For example, if both the (S,G) and (*,G) assert\
    \ state machines are in\n   the NoInfo state when an Assert message arrives, and\
    \ the message\n   causes the (S,G) state machine to transition to either \"W\"\
    \ or \"L\"\n   state, then the assert will not be processed by the (*,G) assert\n\
    \   state machine.\n   Another example: if the (S,G) assert state machine is in\
    \ \"L\" state\n   when an assert message is received, and the assert metric in\
    \ the\n   message is worse than my_assert_metric(S,G,I), then the (S,G) assert\n\
    \   state machine will transition to NoInfo state.  In such a case, if\n   the\
    \ (*,G) assert state machine were in NoInfo state, it might appear\n   that it\
    \ would transition to \"W\" state, but this is not the case\n   because this message\
    \ already triggered a transition in the (S,G)\n   assert state machine.\n  Figure\
    \ 11: Per-interface (*,G) Assert State machine in tabular form\n"
- title: +----------------------------------------------------------------------+
  contents:
  - '+----------------------------------------------------------------------+

    '
- title: '|                         In NoInfo (NI) State                         |'
  contents:
  - '|                         In NoInfo (NI) State                         |

    '
- title: +-----------------------+-----------------------+----------------------+
  contents:
  - '+-----------------------+-----------------------+----------------------+

    '
- title: '| Receive Inferior      |  Data arrives for G   |  Receive Acceptable  |'
  contents:
  - '| Receive Inferior      |  Data arrives for G   |  Receive Acceptable  |

    '
- title: '| Assert with RPTbit    |  on I and             |  Assert with RPTbit  |'
  contents:
  - '| Assert with RPTbit    |  on I and             |  Assert with RPTbit  |

    '
- title: '| set and               |  CouldAssert          |  set and AssTrDes    |'
  contents:
  - '| set and               |  CouldAssert          |  set and AssTrDes    |

    '
- title: '| CouldAssert(*,G,I)    |  (*,G,I)              |  (*,G,I)             |'
  contents:
  - '| CouldAssert(*,G,I)    |  (*,G,I)              |  (*,G,I)             |

    '
- title: +-----------------------+-----------------------+----------------------+
  contents:
  - '+-----------------------+-----------------------+----------------------+

    '
- title: '| -> W state            |  -> W state           |  -> L state          |'
  contents:
  - '| -> W state            |  -> W state           |  -> L state          |

    '
- title: '| [Actions A1]          |  [Actions A1]         |  [Actions A2]        |'
  contents:
  - '| [Actions A1]          |  [Actions A1]         |  [Actions A2]        |

    '
- title: +-----------------------+-----------------------+----------------------+
  contents:
  - '+-----------------------+-----------------------+----------------------+

    '
- title: +---------------------------------------------------------------------+
  contents:
  - '+---------------------------------------------------------------------+

    '
- title: '|                    In I Am Assert Winner (W) State                  |'
  contents:
  - '|                    In I Am Assert Winner (W) State                  |

    '
- title: +----------------+-----------------+-----------------+----------------+
  contents:
  - '+----------------+-----------------+-----------------+----------------+

    '
- title: '| Assert Timer   |  Receive        |  Receive        |  CouldAssert   |'
  contents:
  - '| Assert Timer   |  Receive        |  Receive        |  CouldAssert   |

    '
- title: '| Expires        |  Inferior       |  Preferred      |  (*,G,I) ->    |'
  contents:
  - '| Expires        |  Inferior       |  Preferred      |  (*,G,I) ->    |

    '
- title: '|                |  Assert         |  Assert         |  FALSE         |'
  contents:
  - '|                |  Assert         |  Assert         |  FALSE         |

    '
- title: +----------------+-----------------+-----------------+----------------+
  contents:
  - '+----------------+-----------------+-----------------+----------------+

    '
- title: '| -> W state     |  -> W state     |  -> L state     |  -> NI state   |'
  contents:
  - '| -> W state     |  -> W state     |  -> L state     |  -> NI state   |

    '
- title: '| [Actions A3]   |  [Actions A3]   |  [Actions A2]   |  [Actions A4]  |'
  contents:
  - '| [Actions A3]   |  [Actions A3]   |  [Actions A2]   |  [Actions A4]  |

    '
- title: +----------------+-----------------+-----------------+----------------+
  contents:
  - '+----------------+-----------------+-----------------+----------------+

    '
- title: +---------------------------------------------------------------------+
  contents:
  - '+---------------------------------------------------------------------+

    '
- title: '|                    In I Am Assert Loser (L) State                   |'
  contents:
  - '|                    In I Am Assert Loser (L) State                   |

    '
- title: +-------------+-------------+-------------+-------------+-------------+
  contents:
  - '+-------------+-------------+-------------+-------------+-------------+

    '
- title: '|Receive      |Receive      |Receive      |Assert Timer |Current      |'
  contents:
  - '|Receive      |Receive      |Receive      |Assert Timer |Current      |

    '
- title: '|Preferred    |Acceptable   |Inferior     |Expires      |Winner''s     |'
  contents:
  - '|Preferred    |Acceptable   |Inferior     |Expires      |Winner''s     |

    '
- title: '|Assert with  |Assert from  |Assert or    |             |GenID        |'
  contents:
  - '|Assert with  |Assert from  |Assert or    |             |GenID        |

    '
- title: '|RPTbit set   |Current      |Assert       |             |Changes or   |'
  contents:
  - '|RPTbit set   |Current      |Assert       |             |Changes or   |

    '
- title: '|             |Winner with  |Cancel from  |             |NLT Expires  |'
  contents:
  - '|             |Winner with  |Cancel from  |             |NLT Expires  |

    '
- title: '|             |RPTbit set   |Current      |             |             |'
  contents:
  - '|             |RPTbit set   |Current      |             |             |

    '
- title: '|             |             |Winner       |             |             |'
  contents:
  - '|             |             |Winner       |             |             |

    '
- title: +-------------+-------------+-------------+-------------+-------------+
  contents:
  - '+-------------+-------------+-------------+-------------+-------------+

    '
- title: '|-> L state   |-> L state   |-> NI state  |-> NI state  |-> NI state  |'
  contents:
  - '|-> L state   |-> L state   |-> NI state  |-> NI state  |-> NI state  |

    '
- title: '|[Actions A2] |[Actions A2] |[Actions A5] |[Actions A5] |[Actions A5] |'
  contents:
  - '|[Actions A2] |[Actions A2] |[Actions A5] |[Actions A5] |[Actions A5] |

    '
- title: +-------------+-------------+-------------+-------------+-------------+
  contents:
  - '+-------------+-------------+-------------+-------------+-------------+

    '
- title: +----------------------------------------------------------------------+
  contents:
  - '+----------------------------------------------------------------------+

    '
- title: '|                    In I Am Assert Loser (L) State                    |'
  contents:
  - '|                    In I Am Assert Loser (L) State                    |

    '
- title: +----------------+----------------+-----------------+------------------+
  contents:
  - '+----------------+----------------+-----------------+------------------+

    '
- title: '| AssTrDes       | my_metric ->   |  RPF_interface  |  Receive         |'
  contents:
  - '| AssTrDes       | my_metric ->   |  RPF_interface  |  Receive         |

    '
- title: '| (*,G,I) ->     | better than    |  (RP(G)) stops  |  Join(*,G) or    |'
  contents:
  - '| (*,G,I) ->     | better than    |  (RP(G)) stops  |  Join(*,G) or    |

    '
- title: '| FALSE          | Winner''s       |  being I        |  Join            |'
  contents:
  - '| FALSE          | Winner''s       |  being I        |  Join            |

    '
- title: '|                | metric         |                 |  (*,*,RP(G)) on  |'
  contents:
  - '|                | metric         |                 |  (*,*,RP(G)) on  |

    '
- title: '|                |                |                 |  Interface I     |'
  contents:
  - '|                |                |                 |  Interface I     |

    '
- title: +----------------+----------------+-----------------+------------------+
  contents:
  - '+----------------+----------------+-----------------+------------------+

    '
- title: '| -> NI state    | -> NI state    |  -> NI state    |  -> NI State     |'
  contents:
  - '| -> NI state    | -> NI state    |  -> NI state    |  -> NI State     |

    '
- title: '| [Actions A5]   | [Actions A5]   |  [Actions A5]   |  [Actions A5]    |'
  contents:
  - '| [Actions A5]   | [Actions A5]   |  [Actions A5]   |  [Actions A5]    |

    '
- title: +----------------+----------------+-----------------+------------------+
  contents:
  - "+----------------+----------------+-----------------+------------------+\n  \
    \ The state machine uses the following macros:\n   CouldAssert(*,G,I) =\n    \
    \   ( I in ( joins(*,*,RP(G)) (+) joins(*,G)\n                (+) pim_include(*,G))\
    \ )\n       AND (RPF_interface(RP(G)) != I)\n   CouldAssert(*,G,I) is true on\
    \ downstream interfaces for which we have\n   (*,*,RP(G)) or (*,G) join state,\
    \ or local members that requested any\n   traffic destined for G.\n   AssertTrackingDesired(*,G,I)\
    \ =\n       CouldAssert(*,G,I)\n       OR (local_receiver_include(*,G,I)==TRUE\n\
    \           AND (I_am_DR(I) OR AssertWinner(*,G,I) == me))\n       OR (RPF_interface(RP(G))\
    \ == I AND RPTJoinDesired(G))\n   AssertTrackingDesired(*,G,I) is true on any\
    \ interface on which an\n   (*,G) assert might affect our behavior.\n   Note that\
    \ for reasons of compactness, \"AssTrDes(*,G,I)\" is used in\n   the state machine\
    \ table to refer to AssertTrackingDesired(*,G,I).\n   Terminology:\n      A \"\
    preferred assert\" is one with a better metric than the current\n      winner.\n\
    \      An \"acceptable assert\" is one that has a better metric than\n      my_assert_metric(*,G,I).\
    \  An assert is never considered acceptable\n      if its metric is infinite.\n\
    \      An \"inferior assert\" is one with a worse metric than\n      my_assert_metric(*,G,I).\
    \  An assert is never considered inferior\n      if my_assert_metric(*,G,I) is\
    \ infinite.\n   Transitions from NoInfo State\n   When in NoInfo state, the following\
    \ events trigger transitions, but\n   only if the (S,G) assert state machine is\
    \ in NoInfo state before and\n   after consideration of the received message:\n\
    \     Receive Inferior Assert with RPTbit set AND\n          CouldAssert(*,G,I)==TRUE\n\
    \          An Inferior (*,G) assert is received for G on Interface I.  If\n  \
    \        CouldAssert(*,G,I) is TRUE, then I is our downstream\n          interface,\
    \ and we have (*,G) forwarding state on this\n          interface, so we should\
    \ be the assert winner.  We transition\n          to the \"I am Assert Winner\"\
    \ state and perform Actions A1\n          (below).\n     A data packet destined\
    \ for G arrives on interface I, AND\n          CouldAssert(*,G,I)==TRUE\n    \
    \      A data packet destined for G arrived on a downstream interface\n      \
    \    that is in our (*,G) outgoing interface list.  We therefore\n          believe\
    \ we should be the forwarder for this (*,G), and so we\n          transition to\
    \ the \"I am Assert Winner\" state and perform\n          Actions A1 (below).\n\
    \     Receive Acceptable Assert with RPT bit set AND\n          AssertTrackingDesired(*,G,I)==TRUE\n\
    \          We're interested in (*,G) Asserts, either because I is a\n        \
    \  downstream interface for which we have (*,G) forwarding state,\n          or\
    \ because I is the upstream interface for RP(G) and we have\n          (*,G) forwarding\
    \ state.  We get a (*,G) Assert that has a\n          better metric than our own,\
    \ so we do not win the Assert.  We\n          transition to \"I am Assert Loser\"\
    \ and perform Actions A2\n          (below).\n   Transitions from \"I am Assert\
    \ Winner\" State\n   When in \"I am Assert Winner\" state, the following events\
    \ trigger\n   transitions, but only if the (S,G) assert state machine is in NoInfo\n\
    \   state before and after consideration of the received message:\n     Receive\
    \ Inferior Assert\n          We receive a (*,G) assert that has a worse metric\
    \ than our\n          own.  Whoever sent the assert has lost, and so we resend\
    \ a\n          (*,G) Assert and restart the Assert Timer (Actions A3 below).\n\
    \     Receive Preferred Assert\n          We receive a (*,G) assert that has a\
    \ better metric than our\n          own.  We transition to \"I am Assert Loser\"\
    \ state and perform\n          Actions A2 (below).\n   When in \"I am Assert Winner\"\
    \ state, the following events trigger\n   transitions:\n     Assert Timer Expires\n\
    \          The (*,G) Assert Timer expires.  As we're in the Winner state,\n  \
    \        then we must still have (*,G) forwarding state that is\n          actively\
    \ being kept alive.  To prevent unnecessary thrashing\n          of the forwarder\
    \ and periodic flooding of duplicate packets,\n          we resend the (*,G) Assert\
    \ and restart the Assert Timer\n          (Actions A3 below).\n     CouldAssert(*,G,I)\
    \ -> FALSE\n          Our (*,G) forwarding state or RPF interface changed so as\
    \ to\n          make CouldAssert(*,G,I) become false.  We can no longer\n    \
    \      perform the actions of the assert winner, and so we transition\n      \
    \    to NoInfo state and perform Actions A4 (below).\n   Transitions from \"I\
    \ am Assert Loser\" State\n   When in \"I am Assert Loser\" state, the following\
    \ events trigger\n   transitions, but only if the (S,G) assert state machine is\
    \ in NoInfo\n   state before and after consideration of the received message:\n\
    \     Receive Preferred Assert with RPTbit set\n          We receive a (*,G) assert\
    \ that is better than that of the\n          current assert winner.  We stay in\
    \ Loser state and perform\n          Actions A2 below.\n     Receive Acceptable\
    \ Assert from Current Winner with RPTbit set\n          We receive a (*,G) assert\
    \ from the current assert winner that\n          is better than our own metric\
    \ for this group (although the\n          metric may be worse than the winner's\
    \ previous metric).  We\n          stay in Loser state and perform Actions A2\
    \ below.\n     Receive Inferior Assert or Assert Cancel from Current Winner\n\
    \          We receive an assert from the current assert winner that is\n     \
    \     worse than our own metric for this group (typically because\n          the\
    \ winner's metric became worse or is now an assert cancel).\n          We transition\
    \ to NoInfo state, delete this (*,G) assert state\n          (Actions A5), and\
    \ allow the normal PIM Join/Prune mechanisms\n          to operate.  Usually,\
    \ we will eventually re-assert and win\n          when data packets for G have\
    \ started flowing again.\n   When in \"I am Assert Loser\" state, the following\
    \ events trigger\n   transitions:\n     Assert Timer Expires\n          The (*,G)\
    \ Assert Timer expires.  We transition to NoInfo state\n          and delete this\
    \ (*,G) assert info (Actions A5).\n     Current Winner's GenID Changes or NLT\
    \ Expires\n          The Neighbor Liveness Timer associated with the current winner\n\
    \          expires or we receive a Hello message from the current winner\n   \
    \       reporting a different GenID from the one it previously\n          reported.\
    \  This indicates that the current winner's interface\n          or router has\
    \ gone down (and may have come back up), and so we\n          must assume it no\
    \ longer knows it was the winner.  We\n          transition to the NoInfo state,\
    \ deleting the (*,G) assert\n          information (Actions A5).\n     AssertTrackingDesired(*,G,I)->FALSE\n\
    \          AssertTrackingDesired(*,G,I) becomes FALSE.  Our forwarding\n     \
    \     state has changed so that (*,G) Asserts on interface I are no\n        \
    \  longer of interest to us.  We transition to NoInfo state and\n          delete\
    \ this (*,G) assert info (Actions A5).\n     My metric becomes better than the\
    \ assert winner's metric\n          My routing metric, rpt_assert_metric(G,I),\
    \ has changed so that\n          now my assert metric for (*,G) is better than\
    \ the metric we\n          have stored for current assert winner.  We transition\
    \ to\n          NoInfo state, delete this (*,G) assert state (Actions A5), and\n\
    \          allow the normal PIM Join/Prune mechanisms to operate.\n          Usually,\
    \ we will eventually re-assert and win when data\n          packets for G have\
    \ started flowing again.\n     RPF_interface(RP(G)) stops being interface I\n\
    \          Interface I used to be the RPF interface for RP(G), and now it\n  \
    \        is not.  We transition to NoInfo state and delete this (*,G)\n      \
    \    assert state (Actions A5).\n     Receive Join(*,G) or Join(*,*,RP(G)) on\
    \ interface I\n          We receive a Join(*,G) or a Join(*,*,RP(G)) that has\
    \ the\n          Upstream Neighbor Address field set to my primary IP address\n\
    \          on interface I.  The action is to transition to NoInfo state,\n   \
    \       delete this (*,G) assert state (Actions A5), and allow the\n         \
    \ normal PIM Join/Prune mechanisms to operate.  If whoever sent\n          the\
    \ Join was in error, then the normal assert mechanism will\n          eventually\
    \ re-apply, and we will lose the assert again.\n          However, whoever sent\
    \ the assert may know that the previous\n          assert winner has died, so\
    \ we may end up being the new\n          forwarder.\n   (*,G) Assert State machine\
    \ Actions\n     A1:  Send Assert(*,G).\n          Set Assert Timer to (Assert_Time\
    \ - Assert_Override_Interval).\n          Store self as AssertWinner(*,G,I).\n\
    \          Store rpt_assert_metric(G,I) as AssertWinnerMetric(*,G,I).\n     A2:\
    \  Store new assert winner as AssertWinner(*,G,I) and assert\n          winner\
    \ metric as AssertWinnerMetric(*,G,I).\n          Set Assert Timer to Assert_Time.\n\
    \     A3:  Send Assert(*,G)\n          Set Assert Timer to (Assert_Time - Assert_Override_Interval).\n\
    \     A4:  Send AssertCancel(*,G).\n          Delete assert info (AssertWinner(*,G,I)\
    \ and\n          AssertWinnerMetric(*,G,I) will then return their default\n  \
    \        values).\n     A5:  Delete assert info (AssertWinner(*,G,I) and\n   \
    \       AssertWinnerMetric(*,G,I) will then return their default\n          values).\n\
    \   Note that some of these actions may cause the value of\n   JoinDesired(*,G)\
    \ or RPF'(*,G)) to change, which could cause further\n   transitions in other\
    \ state machines.\n"
- title: 4.6.3.  Assert Metrics
  contents:
  - "4.6.3.  Assert Metrics\n   Assert metrics are defined as:\n     struct assert_metric\
    \ {\n       rpt_bit_flag;\n       metric_preference;\n       route_metric;\n \
    \      ip_address;\n     };\n   When comparing assert_metrics, the rpt_bit_flag,\
    \ metric_preference,\n   and route_metric field are compared in order, where the\
    \ first lower\n   value wins.  If all fields are equal, the primary IP address\
    \ of the\n   router that sourced the Assert message is used as a tie-breaker,\
    \ with\n   the highest IP address winning.\n   An assert metric for (S,G) to include\
    \ in (or compare against) an\n   Assert message sent on interface I should be\
    \ computed using the\n   following pseudocode:\n     assert_metric\n     my_assert_metric(S,G,I)\
    \ {\n         if( CouldAssert(S,G,I) == TRUE ) {\n             return spt_assert_metric(S,I)\n\
    \         } else if( CouldAssert(*,G,I) == TRUE ) {\n             return rpt_assert_metric(G,I)\n\
    \         } else {\n             return infinite_assert_metric()\n         }\n\
    \     }\n   spt_assert_metric(S,I) gives the assert metric we use if we're\n \
    \  sending an assert based on active (S,G) forwarding state:\n     assert_metric\n\
    \     spt_assert_metric(S,I) {\n        return {0,MRIB.pref(S),MRIB.metric(S),my_ip_address(I)}\n\
    \     }\n   rpt_assert_metric(G,I) gives the assert metric we use if we're\n \
    \  sending an assert based only on (*,G) forwarding state:\n     assert_metric\n\
    \     rpt_assert_metric(G,I) {\n         return {1,MRIB.pref(RP(G)),MRIB.metric(RP(G)),my_ip_address(I)}\n\
    \     }\n   MRIB.pref(X) and MRIB.metric(X) are the routing preference and\n \
    \  routing metrics associated with the route to a particular (unicast)\n   destination\
    \ X, as determined by the MRIB.  my_ip_address(I) is simply\n   the router's primary\
    \ IP address that is associated with the local\n   interface I.\n   infinite_assert_metric()\
    \ gives the assert metric we need to send an\n   assert but don't match either\
    \ (S,G) or (*,G) forwarding state:\n     assert_metric\n     infinite_assert_metric()\
    \ {\n          return {1,infinity,infinity,0}\n     }\n"
- title: 4.6.4.  AssertCancel Messages
  contents:
  - "4.6.4.  AssertCancel Messages\n   An AssertCancel message is simply an RPT Assert\
    \ message but with\n   infinite metric.  It is sent by the assert winner when\
    \ it deletes the\n   forwarding state that had caused the assert to occur.  Other\
    \ routers\n   will see this metric, and it will cause any other router that has\n\
    \   forwarding state to send its own assert, and to take over forwarding.\n  \
    \ An AssertCancel(S,G) is an infinite metric assert with the RPT bit\n   set that\
    \ names S as the source.\n   An AssertCancel(*,G) is an infinite metric assert\
    \ with the RPT bit\n   set and the source set to zero.\n   AssertCancel messages\
    \ are simply an optimization.  The original\n   Assert timeout mechanism will\
    \ allow a subnet to eventually become\n   consistent; the AssertCancel mechanism\
    \ simply causes faster\n   convergence.  No special processing is required for\
    \ an AssertCancel\n   message, since it is simply an Assert message from the current\n\
    \   winner.\n"
- title: 4.6.5.  Assert State Macros
  contents:
  - "4.6.5.  Assert State Macros\n   The macros lost_assert(S,G,rpt,I), lost_assert(S,G,I),\
    \ and\n   lost_assert(*,G,I) are used in the olist computations of Section 4.1,\n\
    \   and are defined as:\n     bool lost_assert(S,G,rpt,I) {\n       if ( RPF_interface(RP(G))\
    \ == I  OR\n            ( RPF_interface(S) == I AND SPTbit(S,G) == TRUE ) ) {\n\
    \          return FALSE\n       } else {\n          return ( AssertWinner(S,G,I)\
    \ != NULL AND\n                   AssertWinner(S,G,I) != me )\n       }\n    \
    \ }\n     bool lost_assert(S,G,I) {\n       if ( RPF_interface(S) == I ) {\n \
    \         return FALSE\n       } else {\n          return ( AssertWinner(S,G,I)\
    \ != NULL AND\n                   AssertWinner(S,G,I) != me  AND\n           \
    \        (AssertWinnerMetric(S,G,I) is better\n                      than spt_assert_metric(S,I)\
    \ )\n       }\n     }\n   Note: the term \"AssertWinnerMetric(S,G,I) is better\
    \ than\n   spt_assert_metric(S,I)\" is required to correctly handle the\n   transition\
    \ phase when a router has (S,G) join state, but has not yet\n   set the SPT bit.\
    \  In this case, it needs to ignore the assert state\n   if it will win the assert\
    \ once the SPTbit is set.\n     bool lost_assert(*,G,I) {\n       if ( RPF_interface(RP(G))\
    \ == I ) {\n          return FALSE\n       } else {\n          return ( AssertWinner(*,G,I)\
    \ != NULL AND\n                   AssertWinner(*,G,I) != me )\n       }\n    \
    \ }\n   AssertWinner(S,G,I) is the IP source address of the Assert(S,G)\n   packet\
    \ that won an Assert.\n   AssertWinner(*,G,I) is the IP source address of the\
    \ Assert(*,G)\n   packet that won an Assert.\n   AssertWinnerMetric(S,G,I) is\
    \ the Assert metric of the Assert(S,G)\n   packet that won an Assert.\n   AssertWinnerMetric(*,G,I)\
    \ is the Assert metric of the Assert(*,G)\n   packet that won an Assert.\n   AssertWinner(S,G,I)\
    \ defaults to NULL and AssertWinnerMetric(S,G,I)\n   defaults to Infinity when\
    \ in the NoInfo state.\n   Summary of Assert Rules and Rationale\n   This section\
    \ summarizes the key rules for sending and reacting to\n   asserts and the rationale\
    \ for these rules.  This section is not\n   intended to be and should not be treated\
    \ as a definitive\n   specification of protocol behavior.  The state machines\
    \ and\n   pseudocode should be consulted for that purpose.  Rather, this\n   section\
    \ is intended to document important aspects of the Assert\n   protocol behavior\
    \ and to provide information that may prove helpful\n   to the reader in understanding\
    \ and implementing this part of the\n   protocol.\n   1.  Behavior: Downstream\
    \ neighbors send Join(*,G) and Join(S,G)\n       periodic messages to the appropriate\
    \ RPF' neighbor, i.e., the RPF\n       neighbor as modified by the assert process.\
    \  They are not always\n       sent to the RPF neighbor as indicated by the MRIB.\
    \  Normal\n       suppression and override rules apply.\n       Rationale: By\
    \ sending the periodic and triggered Join messages to\n       the RPF' neighbor\
    \ instead of to the RPF neighbor, the downstream\n       router avoids re-triggering\
    \ the Assert process with every Join.\n       A side effect of sending Joins to\
    \ the Assert winner is that\n       traffic will not switch back to the \"normal\"\
    \ RPF neighbor until\n       the Assert times out.  This will not happen until\
    \ data stops\n       flowing, if item 8, below, is implemented.\n   2.  Behavior:\
    \ The assert winner for (*,G) acts as the local DR for\n       (*,G) on behalf\
    \ of IGMP/MLD members.\n       Rationale: This is required to allow a single router\
    \ to merge PIM\n       and IGMP/MLD joins and leaves.  Without this, overrides\
    \ don't\n       work.\n   3.  Behavior: The assert winner for (S,G) acts as the\
    \ local DR for\n       (S,G) on behalf of IGMPv3 members.\n       Rationale: Same\
    \ rationale as for item 2.\n   4.  Behavior: (S,G) and (*,G) prune overrides are\
    \ sent to the RPF'\n       neighbor and not to the regular RPF neighbor.\n   \
    \    Rationale: Same rationale as for item 1.\n   5.  Behavior: An (S,G,rpt) prune\
    \ override is not sent (at all) if\n       RPF'(S,G,rpt) != RPF'(*,G).\n     \
    \  Rationale: This avoids keeping state alive on the (S,G) tree when\n       only\
    \ (*,G) downstream members are left.  Also, it avoids sending\n       (S,G,rpt)\
    \ joins to a router that is not on the (*,G) tree.  This\n       behavior might\
    \ be confusing although this specification does\n       indicate that such a join\
    \ should be dropped.\n   6.  Behavior: An assert loser that receives a Join(S,G)\
    \ with an\n       Upstream Neighbor Address that is its primary IP address on\
    \ that\n       interface cancels the (S,G) Assert Timer.\n       Rationale: This\
    \ is necessary in order to have rapid convergence\n       in the event that the\
    \ downstream router that initially sent a\n       join to the prior Assert winner\
    \ has undergone a topology change.\n   7.  Behavior: An assert loser that receives\
    \ a Join(*,G) or a\n       Join(*,*,RP(G)) with an Upstream Neighbor Address that\
    \ is its\n       primary IP address on that interface cancels the (*,G) Assert\n\
    \       Timer and all (S,G) assert timers that do not have corresponding\n   \
    \    Prune(S,G,rpt) messages in the compound Join/Prune message.\n       Rationale:\
    \ Same rationale as for item 6.\n   8.  Behavior: An assert winner for (*,G) or\
    \ (S,G) sends a canceling\n       assert when it is about to stop forwarding on\
    \ a (*,G) or an (S,G)\n       entry.  This behavior does not apply to (S,G,rpt).\n\
    \       Rationale: This allows switching back to the shared tree after\n     \
    \  the last SPT router on the LAN leaves.  Doing this prevents\n       downstream\
    \ routers on the shared tree from keeping SPT state\n       alive.\n   9.  Behavior:\
    \ Resend the assert messages before timing out an assert.\n       (This behavior\
    \ is optional.)\n       Rationale: This prevents the periodic duplicates that\
    \ would\n       otherwise occur each time that an assert times out and is then\n\
    \       re-established.\n   10. Behavior: When RPF'(S,G,rpt) changes to be the\
    \ same as RPF'(*,G)\n       we need to trigger a Join(S,G,rpt) to RPF'(*,G).\n\
    \       Rationale: This allows switching back to the RPT after the last\n    \
    \   SPT member leaves.\n"
- title: 4.7.  PIM Bootstrap and RP Discovery
  contents:
  - "4.7.  PIM Bootstrap and RP Discovery\n   For correct operation, every PIM router\
    \ within a PIM domain must be\n   able to map a particular multicast group address\
    \ to the same RP.  If\n   this is not the case, then black holes may appear, where\
    \ some\n   receivers in the domain cannot receive some groups.  A domain in this\n\
    \   context is a contiguous set of routers that all implement PIM and are\n  \
    \ configured to operate within a common boundary.\n   A notable exception to this\
    \ is where a PIM domain is broken up into\n   multiple administrative scope regions;\
    \ these are regions where a\n   border has been configured so that a range of\
    \ multicast groups will\n   not be forwarded across that border.  For more information\
    \ on\n   Administratively Scoped IP Multicast, see RFC 2365.  The modified\n \
    \  criteria for admin-scoped regions are that the region is convex with\n   respect\
    \ to forwarding based on the MRIB, and that all PIM routers\n   within the scope\
    \ region map scoped groups to the same RP within that\n   region.\n   This specification\
    \ does not mandate the use of a single mechanism to\n   provide routers with the\
    \ information to perform the group-to-RP\n   mapping.  Currently four mechanisms\
    \ are possible, and all four have\n   associated problems:\n   Static Configuration\n\
    \        A PIM router MUST support the static configuration of group-to-\n   \
    \     RP mappings.  Such a mechanism is not robust to failures, but\n        does\
    \ at least provide a basic interoperability mechanism.\n   Embedded-RP\n     \
    \   Embedded-RP defines an address allocation policy in which the\n        address\
    \ of the Rendezvous Point (RP) is encoded in an IPv6\n        multicast group\
    \ address [17].\n   Cisco's Auto-RP\n        Auto-RP uses a PIM Dense-Mode multicast\
    \ group to announce\n        group-to-RP mappings from a central location.  This\
    \ mechanism is\n        not useful if PIM Dense-Mode is not being run in parallel\
    \ with\n        PIM Sparse-Mode, and was only intended for use with PIM Sparse-\n\
    \        Mode Version 1.  No standard specification currently exists.\n   BootStrap\
    \ Router (BSR)\n        RFC 2362 specifies a bootstrap mechanism based on the\
    \ automatic\n        election of a bootstrap router (BSR).  Any router in the\
    \ domain\n        that is configured to be a possible RP reports its candidacy\
    \ to\n        the BSR, and then a domain-wide flooding mechanism distributes\n\
    \        the BSR's chosen set of RPs throughout the domain.  As specified\n  \
    \      in RFC 2362, BSR is flawed in its handling of admin-scoped\n        regions\
    \ that are smaller than a PIM domain, but the mechanism\n        does work for\
    \ global-scoped groups.\n   As far as PIM-SM is concerned, the only important\
    \ requirement is that\n   all routers in the domain (or admin scope zone for scoped\
    \ regions)\n   receive the same set of group-range-to-RP mappings.  This may be\n\
    \   achieved through the use of any of these mechanisms, or through\n   alternative\
    \ mechanisms not currently specified.\n   It must be operationally ensured that\
    \ any RP address configured,\n   learned, or advertised is reachable from all\
    \ routers in the PIM\n   domain.\n"
- title: 4.7.1.  Group-to-RP Mapping
  contents:
  - "4.7.1.  Group-to-RP Mapping\n   Using one of the mechanisms described above,\
    \ a PIM router receives\n   one or more possible group-range-to-RP mappings. \
    \ Each mapping\n   specifies a range of multicast groups (expressed as a group\
    \ and mask)\n   and the RP to which such groups should be mapped.  Each mapping\
    \ may\n   also have an associated priority.  It is possible to receive multiple\n\
    \   mappings, all of which might match the same multicast group; this is\n   the\
    \ common case with BSR.  The algorithm for performing the group-\n   to-RP mapping\
    \ is as follows:\n   1.  Perform longest match on group-range to obtain a list\
    \ of RPs.\n   2.  From this list of matching RPs, find the one with highest\n\
    \       priority.  Eliminate any RPs from the list that have lower\n       priorities.\n\
    \   3.  If only one RP remains in the list, use that RP.\n   4.  If multiple RPs\
    \ are in the list, use the PIM hash function to\n       choose one.\n   Thus,\
    \ if two or more group-range-to-RP mappings cover a particular\n   group, the\
    \ one with the longest mask is the mapping to use.  If the\n   mappings have the\
    \ same mask length, then the one with the highest\n   priority is chosen.  If\
    \ there is more than one matching entry with\n   the same longest mask and the\
    \ priorities are identical, then a hash\n   function (see Section 4.7.2) is applied\
    \ to choose the RP.\n   This algorithm is invoked by a DR when it needs to determine\
    \ an RP\n   for a given group, e.g., upon reception of a packet or IGMP/MLD\n\
    \   membership indication for a group for which the DR does not know the\n   RP.\
    \  It is invoked by any router that has (*,*,RP) state when a\n   packet is received\
    \ for which there is no corresponding (S,G) or (*,G)\n   entry.  Furthermore,\
    \ the mapping function is invoked by all routers\n   upon receiving a (*,G) or\
    \ (*,*,RP) Join/Prune message.\n   Note that if the set of possible group-range-to-RP\
    \ mappings changes,\n   each router will need to check whether any existing groups\
    \ are\n   affected.  This may, for example, cause a DR or acting DR to re-join\n\
    \   a group, or cause it to restart register encapsulation to the new RP.\n  \
    \   Implementation note: the bootstrap mechanism described in RFC 2362\n     omitted\
    \ step 1 above.  However, of the implementations we are aware\n     of, approximately\
    \ half performed step 1 anyway.  Note that\n     implementations of BSR that omit\
    \ step 1 will not correctly\n     interoperate with implementations of this specification\
    \ when used\n     with the BSR mechanism described in [11].\n"
- title: 4.7.2.  Hash Function
  contents:
  - "4.7.2.  Hash Function\n   The hash function is used by all routers within a domain,\
    \ to map a\n   group to one of the RPs from the matching set of group-range-to-RP\n\
    \   mappings (this set all have the same longest mask length and same\n   highest\
    \ priority).  The algorithm takes as input the group address,\n   and the addresses\
    \ of the candidate RPs from the mappings, and gives\n   as output one RP address\
    \ to be used.\n   The protocol requires that all routers hash to the same RP within\
    \ a\n   domain (except for transients).  The following hash function must be\n\
    \   used in each router:\n   1.  For RP addresses in the matching group-range-to-RP\
    \ mappings,\n       compute a value:\n   Value(G,M,C(i))=\n   (1103515245 * ((1103515245\
    \ * (G&M)+12345) XOR C(i)) + 12345) mod 2^31\n       where C(i) is the RP address\
    \ and M is a hash-mask.  If BSR is\n       being used, the hash-mask is given\
    \ in the Bootstrap messages.  If\n       BSR is not being used, the alternative\
    \ mechanism that supplies\n       the group-range-to-RP mappings may supply the\
    \ value, or else it\n       defaults to a mask with the most significant 30 bits\
    \ being one\n       for IPv4 and the most significant 126 bits being one for IPv6.\n\
    \       The hash-mask allows a small number of consecutive groups (e.g.,\n   \
    \    4) to always hash to the same RP.  For instance, hierarchically-\n      \
    \ encoded data can be sent on consecutive group addresses to get\n       the same\
    \ delay and fate-sharing characteristics.\n       For address families other than\
    \ IPv4, a 32-bit digest to be used\n       as C(i) and G must first be derived\
    \ from the actual RP or group\n       address.  Such a digest method must be used\
    \ consistently\n       throughout the PIM domain.  For IPv6 addresses, we recommend\n\
    \       using the equivalent IPv4 address for an IPv4-compatible address,\n  \
    \     and the exclusive-or of each 32-bit segment of the address for\n       all\
    \ other IPv6 addresses.  For example, the digest of the IPv6\n       address 3ffe:b00:c18:1::10\
    \ would be computed as 0x3ffe0b00 ^\n       0x0c180001 ^ 0x00000000 ^ 0x00000010,\
    \ where ^ represents the\n       exclusive-or operation.\n   2.  The candidate\
    \ RP with the highest resulting hash value is then\n       the RP chosen by this\
    \ Hash Function.  If more than one RP has the\n       same highest hash value,\
    \ the RP with the highest IP address is\n       chosen.\n"
- title: 4.8.  Source-Specific Multicast
  contents:
  - "4.8.  Source-Specific Multicast\n   The Source-Specific Multicast (SSM) service\
    \ model [6] can be\n   implemented with a strict subset of the PIM-SM protocol\
    \ mechanisms.\n   Both regular IP Multicast and SSM semantics can coexist on a\
    \ single\n   router, and both can be implemented using the PIM-SM protocol.  A\n\
    \   range of multicast addresses, currently 232.0.0.0/8 in IPv4 and\n   FF3x::/32\
    \ for IPv6, is reserved for SSM, and the choice of semantics\n   is determined\
    \ by the multicast group address in both data packets and\n   PIM messages.\n"
- title: 4.8.1.  Protocol Modifications for SSM Destination Addresses
  contents:
  - "4.8.1.  Protocol Modifications for SSM Destination Addresses\n   The following\
    \ rules override the normal PIM-SM behavior for a\n   multicast address G in the\
    \ SSM range:\n   o A router MUST NOT send a (*,G) Join/Prune message for any reason.\n\
    \   o A router MUST NOT send an (S,G,rpt) Join/Prune message for any\n   reason.\n\
    \   o A router MUST NOT send a Register message for any packet that is\n     destined\
    \ to an SSM address.\n   o A router MUST NOT forward packets based on (*,G) or\
    \ (S,G,rpt)\n     state.  The (*,G)- and (S,G,rpt)-related state summarization\
    \ macros\n     are NULL for any SSM address, for the purposes of packet\n    \
    \ forwarding.\n   o A router acting as an RP MUST NOT forward any Register-encapsulated\n\
    \     packet that has an SSM destination address.\n   The last two rules are present\
    \ to deal with \"legacy\" routers unaware\n   of SSM that may be sending (*,G)\
    \ and (S,G,rpt) Join/Prunes, or\n   Register messages for SSM destination addresses.\n\
    \   Additionally:\n   o A router MAY be configured to advertise itself as a Candidate\
    \ RP\n     for an SSM address.  If so, it SHOULD respond with a Register-Stop\n\
    \     message to any Register message containing a packet destined for an\n  \
    \   SSM address.\n   o A router MAY optimize out the creation and maintenance\
    \ of (S,G,rpt)\n     and (*,G) state for SSM destination addresses -- this state\
    \ is not\n     needed for SSM packets.\n"
- title: 4.8.2.  PIM-SSM-Only Routers
  contents:
  - "4.8.2.  PIM-SSM-Only Routers\n   An implementer may choose to implement only\
    \ the subset of PIM\n   Sparse-Mode that provides SSM forwarding semantics.\n\
    \   A PIM-SSM-only router MUST implement the following portions of this\n   specification:\n\
    \   o Upstream (S,G) state machine (Section 4.5.7)\n   o Downstream (S,G) state\
    \ machine (Section 4.5.3)\n   o (S,G) Assert state machine (Section 4.6.1)\n \
    \  o Hello messages, neighbor discovery, and DR election (Section 4.3)\n   o Packet\
    \ forwarding rules (Section 4.2)\n   A PIM-SSM-only router does not need to implement\
    \ the following\n   protocol elements:\n   o Register state machine (Section 4.4)\n\
    \   o (*,G), (S,G,rpt), and (*,*,RP) Downstream state machines (Sections\n   \
    \  4.5.2, 4.5.4, and 4.5.1)\n   o (*,G), (S,G,rpt), and (*,*,RP) Upstream state\
    \ machines (Sections\n     4.5.6, 4.5.8, and 4.5.5)\n   o (*,G) Assert state machine\
    \ (Section 4.6.2)\n   o Bootstrap RP Election (Section 4.7)\n   o Keepalive Timer\n\
    \   o SPTbit (Section 4.2.2)\n   The Keepalive Timer should be treated as always\
    \ running, and SPTbit\n   should be treated as always being set for an SSM address.\n\
    \   Additionally, the Packet forwarding rules of Section 4.2 can be\n   simplified\
    \ in a PIM-SSM-only router:\n     if( iif == RPF_interface(S) AND UpstreamJPState(S,G)\
    \ == Joined ) {\n         oiflist = inherited_olist(S,G)\n     } else if( iif\
    \ is in inherited_olist(S,G) ) {\n         send Assert(S,G) on iif\n     }\n \
    \    oiflist = oiflist (-) iif\n     forward packet on all interfaces in oiflist\n\
    \   This is nothing more than the reduction of the normal PIM-SM\n   forwarding\
    \ rule, with all (S,G,rpt) and (*,G) clauses replaced with\n   NULL.\n"
- title: 4.9.  PIM Packet Formats
  contents:
  - "4.9.  PIM Packet Formats\n   This section describes the details of the packet\
    \ formats for PIM\n   control messages.\n   All PIM control messages have IP protocol\
    \ number 103.\n   PIM messages are either unicast (e.g., Registers and Register-Stop)\n\
    \   or multicast with TTL 1 to the 'ALL-PIM-ROUTERS' group (e.g.,\n   Join/Prune,\
    \ Asserts, etc.).  The source address used for unicast\n   messages is a domain-wide\
    \ reachable address; the source address used\n   for multicast messages is the\
    \ link-local address of the interface on\n   which the message is being sent.\n\
    \   The IPv4 'ALL-PIM-ROUTERS' group is '224.0.0.13'.  The IPv6 'ALL-PIM-\n  \
    \ ROUTERS' group is 'ff02::d'.\n   The PIM header common to all PIM messages is:\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |PIM Ver| Type  |   Reserved    |           Checksum            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   PIM Ver\n        PIM Version number is 2.\n   Type Types for specific PIM\
    \ messages.  PIM Types are:\n   Message Type                          Destination\n\
    \   ---------------------------------------------------------------------\n  \
    \ 0 = Hello                             Multicast to ALL-PIM-ROUTERS\n   1 = Register\
    \                          Unicast to RP\n   2 = Register-Stop               \
    \      Unicast to source of Register\n                                       \
    \     packet\n   3 = Join/Prune                        Multicast to ALL-PIM-ROUTERS\n\
    \   4 = Bootstrap                         Multicast to ALL-PIM-ROUTERS\n   5 =\
    \ Assert                            Multicast to ALL-PIM-ROUTERS\n   6 = Graft\
    \ (used in PIM-DM only)       Unicast to RPF'(S)\n   7 = Graft-Ack (used in PIM-DM\
    \ only)   Unicast to source of Graft\n                                       \
    \     packet\n   8 = Candidate-RP-Advertisement        Unicast to Domain's BSR\n\
    \   Reserved\n        Set to zero on transmission.  Ignored upon receipt.\n  \
    \ Checksum\n        The checksum is a standard IP checksum, i.e., the 16-bit one's\n\
    \        complement of the one's complement sum of the entire PIM\n        message,\
    \ excluding the \"Multicast data packet\" section of the\n        Register message.\
    \  For computing the checksum, the checksum\n        field is zeroed.  If the\
    \ packet's length is not an integral\n        number of 16-bit words, the packet\
    \ is padded with a trailing\n        byte of zero before performing the checksum.\n\
    \        For IPv6, the checksum also includes the IPv6 \"pseudo-header\",\n  \
    \      as specified in RFC 2460, Section 8.1 [5].  This \"pseudo-header\"\n  \
    \      is prepended to the PIM header for the purposes of calculating\n      \
    \  the checksum.  The \"Upper-Layer Packet Length\" in the pseudo-\n        header\
    \ is set to the length of the PIM message, except in\n        Register messages\
    \ where it is set to the length of the PIM\n        register header (8).  The\
    \ Next Header value used in the pseudo-\n        header is 103.\n   If a message\
    \ is received with an unrecognized PIM Ver or Type field,\n   or if a message's\
    \ destination does not correspond to the table above,\n   the message MUST be\
    \ discarded, and an error message SHOULD be logged\n   to the administrator in\
    \ a rate-limited manner.\n"
- title: 4.9.1.  Encoded Source and Group Address Formats
  contents:
  - "4.9.1.  Encoded Source and Group Address Formats\n   Encoded-Unicast Address\n\
    \   An Encoded-Unicast address takes the following format:\n    0            \
    \       1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Addr Family  | Encoding Type |     Unicast Address\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...\n\
    \   Addr Family\n        The PIM address family of the 'Unicast Address' field\
    \ of this\n        address.\n        Values 0-127 are as assigned by the IANA\
    \ for Internet Address\n        Families in [7].  Values 128-250 are reserved\
    \ to be assigned by\n        the IANA for PIM-specific Address Families.  Values\
    \ 251 though\n        255 are designated for private use.  As there is no assignment\n\
    \        authority for this space, collisions should be expected.\n   Encoding\
    \ Type\n        The type of encoding used within a specific Address Family.  The\n\
    \        value '0' is reserved for this field and represents the native\n    \
    \    encoding of the Address Family.\n   Unicast Address\n        The unicast\
    \ address as represented by the given Address Family\n        and Encoding Type.\n\
    \   Encoded-Group Address\n   Encoded-Group addresses take the following format:\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Addr Family  | Encoding Type |B| Reserved  |Z|  Mask Len     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                Group multicast Address\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...\n\
    \   Addr Family\n        Described above.\n   Encoding Type\n        Described\
    \ above.\n   [B]idirectional PIM\n        Indicates the group range should use\
    \ Bidirectional PIM [13].\n        For PIM-SM defined in this specification, this\
    \ bit MUST be zero.\n   Reserved\n        Transmitted as zero.  Ignored upon receipt.\n\
    \   Admin Scope [Z]one\n        indicates the group range is an admin scope zone.\
    \  This is used\n        in the Bootstrap Router Mechanism [11] only.  For all\
    \ other\n        purposes, this bit is set to zero and ignored on receipt.\n \
    \  Mask Len\n        The Mask length field is 8 bits.  The value is the number\
    \ of\n        contiguous one bits that are left justified and used as a mask;\n\
    \        when combined with the group address, it describes a range of\n     \
    \   groups.  It is less than or equal to the address length in bits\n        for\
    \ the given Address Family and Encoding Type.  If the message\n        is sent\
    \ for a single group, then the Mask length must equal the\n        address length\
    \ in bits for the given Address Family and Encoding\n        Type (e.g., 32 for\
    \ IPv4 native encoding, 128 for IPv6 native\n        encoding).\n   Group multicast\
    \ Address\n        Contains the group address.\n   Encoded-Source Address\n  \
    \ Encoded-Source address takes the following format:\n    0                  \
    \ 1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Addr Family   | Encoding Type | Rsrvd   |S|W|R|  Mask Len     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Source Address\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-...\n\
    \   Addr Family\n        Described above.\n   Encoding Type\n        Described\
    \ above.\n   Reserved\n        Transmitted as zero, ignored on receipt.\n   S\
    \    The Sparse bit is a 1-bit value, set to 1 for PIM-SM.  It is\n        used\
    \ for PIM version 1 compatibility.\n   W    The WC (or WildCard) bit is a 1-bit\
    \ value for use with PIM\n        Join/Prune messages (see Section 4.9.5.1).\n\
    \   R    The RPT (or Rendezvous Point Tree) bit is a 1-bit value for use\n   \
    \     with PIM Join/Prune messages (see Section 4.9.5.1).  If the WC\n       \
    \ bit is 1, the RPT bit MUST be 1.\n   Mask Len\n        The mask length field\
    \ is 8 bits.  The value is the number of\n        contiguous one bits left justified\
    \ used as a mask which,\n        combined with the Source Address, describes a\
    \ source subnet.\n        The mask length MUST be equal to the mask length in\
    \ bits for the\n        given Address Family and Encoding Type (32 for IPv4 native\
    \ and\n        128 for IPv6 native).  A router SHOULD ignore any messages\n  \
    \      received with any other mask length.\n   Source Address\n        The source\
    \ address.\n"
- title: 4.9.2.  Hello Message Format
  contents:
  - "4.9.2.  Hello Message Format\n   It is sent periodically by routers on all interfaces.\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |PIM Ver| Type  |   Reserved    |           Checksum            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          OptionType           |         OptionLength          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          OptionValue                          |\n   |  \
    \                            ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                               .                               |\n   |  \
    \                             .                               |\n   |        \
    \                       .                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          OptionType           |         OptionLength          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          OptionValue                          |\n   |  \
    \                            ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   PIM Version, Type, Reserved, Checksum\n        Described in Section 4.9.\n\
    \   OptionType\n        The type of the option given in the following OptionValue\
    \ field.\n   OptionLength\n        The length of the OptionValue field in bytes.\n\
    \   OptionValue\n        A variable length field, carrying the value of the option.\n\
    \   The Option fields may contain the following values:\n   o OptionType 1: Holdtime\n\
    \      0                   1                   2                   3\n      0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |          Type = 1             |         Length = 2            |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \        Holdtime             |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \ Holdtime is the amount of time a receiver must keep the neighbor\n     reachable,\
    \ in seconds.  If the Holdtime is set to '0xffff', the\n     receiver of this\
    \ message never times out the neighbor.  This may be\n     used with dial-on-demand\
    \ links, to avoid keeping the link up with\n     periodic Hello messages.\n  \
    \   Hello messages with a Holdtime value set to '0' are also sent by a\n     router\
    \ on an interface about to go down or changing IP address (see\n     Section 4.3.1).\
    \  These are effectively goodbye messages, and the\n     receiving routers should\
    \ immediately time out the neighbor\n     information for the sender.\n   o OptionType\
    \ 2: LAN Prune Delay\n      0                   1                   2        \
    \           3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |          Type = 2             |          Length = 4           |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |T|\
    \      Propagation_Delay      |      Override_Interval        |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     The LAN Prune Delay option is used to tune the prune propagation\n     delay\
    \ on multi-access LANs.  The T bit specifies the ability of the\n     sending\
    \ router to disable joins suppression.  Propagation_Delay and\n     Override_Interval\
    \ are time intervals in units of milliseconds.  A\n     router originating a LAN\
    \ Prune Delay option on interface I sets the\n     Propagation_Delay field to\
    \ the configured value of\n     Propagation_Delay(I) and the value of the Override_Interval\
    \ field\n     to the value of Override_Interval(I).  On a receiving router, the\n\
    \     values of the fields are used to tune the value of the\n     Effective_Override_Interval(I)\
    \ and its derived timer values.\n     Section 4.3.3 describes how these values\
    \ affect the behavior of a\n     router.\n   o OptionType 3 to 16: reserved to\
    \ be defined in future versions of\n     this document.\n   o OptionType 18: deprecated\
    \ and should not be used.\n   o OptionType 19: DR Priority\n      0          \
    \         1                   2                   3\n      0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |          Type = 19            |          Length = 4           |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                       DR Priority                           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     DR Priority is a 32-bit unsigned number and should be considered in\n  \
    \   the DR election as described in Section 4.3.2.\n   o OptionType 20: Generation\
    \ ID\n      0                   1                   2                   3\n  \
    \    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |          Type = 20            |          Length = 4           |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                     Generation ID                           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     Generation ID is a random 32-bit value for the interface on which\n    \
    \ the Hello message is sent.  The Generation ID is regenerated\n     whenever\
    \ PIM forwarding is started or restarted on the interface.\n   o OptionType 24:\
    \ Address List\n      0                   1                   2              \
    \     3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \ |          Type = 24            |      Length = <Variable>      |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |         Secondary Address 1 (Encoded-Unicast format)          |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n        \
    \                            ...\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |         Secondary Address N (Encoded-Unicast format)          |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     The\
    \ contents of the Address List Hello option are described in\n     Section 4.3.4.\
    \ All addresses within a single Address List must\n     belong to the same address\
    \ family.\n   OptionTypes 17 through 65000 are assigned by the IANA.  OptionTypes\n\
    \   65001 through 65535 are reserved for Private Use, as defined in [9].\n   Unknown\
    \ options MUST be ignored and MUST NOT prevent a neighbor\n   relationship from\
    \ being formed.  The \"Holdtime\" option MUST be\n   implemented; the \"DR Priority\"\
    \ and \"Generation ID\" options SHOULD be\n   implemented.  The \"Address List\"\
    \ option MUST be implemented for IPv6.\n"
- title: 4.9.3.  Register Message Format
  contents:
  - "4.9.3.  Register Message Format\n   A Register message is sent by the DR or a\
    \ PMBR to the RP when a\n   multicast packet needs to be transmitted on the RP-tree.\
    \  The IP\n   source address is set to the address of the DR, the destination\n\
    \   address to the RP's address.  The IP TTL of the PIM packet is the\n   system's\
    \ normal unicast TTL.\n    0                   1                   2         \
    \          3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |PIM Ver| Type  |   Reserved    |           Checksum            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |B|N|                       Reserved2                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   .  \
    \                   Multicast data packet                     .\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   PIM Version, Type, Reserved, Checksum\n        Described in Section 4.9. Note\
    \ that in order to reduce\n        encapsulation overhead, the checksum for Registers\
    \ is done only\n        on the first 8 bytes of the packet, including the PIM\
    \ header and\n        the next 4 bytes, excluding the data packet portion.  For\n\
    \        interoperability reasons, a message carrying a checksum\n        calculated\
    \ over the entire PIM Register message should also be\n        accepted.  When\
    \ calculating the checksum, the IPv6 pseudoheader\n        \"Upper-Layer Packet\
    \ Length\" is set to 8.\n   B    The Border bit.  If the router is a DR for a\
    \ source that it is\n        directly connected to, it sets the B bit to 0.  If\
    \ the router is\n        a PMBR for a source in a directly connected cloud, it\
    \ sets the B\n        bit to 1.\n   N    The Null-Register bit.  Set to 1 by a\
    \ DR that is probing the RP\n        before expiring its local Register-Suppression\
    \ Timer.  Set to 0\n        otherwise.\n   Reserved2\n        Transmitted as zero,\
    \ ignored on receipt.\n   Multicast data packet\n        The original packet sent\
    \ by the source.  This packet must be of\n        the same address family as the\
    \ encapsulating PIM packet, e.g.,\n        an IPv6 data packet must be encapsulated\
    \ in an IPv6 PIM packet.\n        Note that the TTL of the original packet is\
    \ decremented before\n        encapsulation, just like any other packet that is\
    \ forwarded.  In\n        addition, the RP decrements the TTL after decapsulating,\
    \ before\n        forwarding the packet down the shared tree.\n        For (S,G)\
    \ Null-Registers, the Multicast data packet portion\n        contains a dummy\
    \ IP header with S as the source address, G as\n        the destination address.\
    \  When generating an IPv4 Null-Register\n        message, the fields in the dummy\
    \ IPv4 header SHOULD be filled in\n        according to the following table. \
    \ Other IPv4 header fields may\n        contain any value that is valid for that\
    \ field.\n        Field                  Value\n        ---------------------------------------\n\
    \        IP Version             4\n        Header Length          5\n        Checksum\
    \               Header checksum\n        Fragmentation offset   0\n        More\
    \ Fragments         0\n        Total Length           20\n        IP Protocol\
    \            103 (PIM)\n        On receipt of an (S,G) Null-Register, if the Header\
    \ Checksum\n        field is non-zero, the recipient SHOULD check the checksum\
    \ and\n        discard null registers that have a bad checksum.  The recipient\n\
    \        SHOULD NOT check the value of any individual fields; a correct\n    \
    \    IP header checksum is sufficient.  If the Header Checksum field\n       \
    \ is zero, the recipient MUST NOT check the checksum.\n        With IPv6, an implementation\
    \ generates a dummy IP header\n        followed by a dummy PIM header with values\
    \ according to the\n        following table in addition to the source and group.\
    \  Other IPv6\n        header fields may contain any value that is valid for that\n\
    \        field.\n        Header Field   Value\n        --------------------------------------\n\
    \        IP Version     6\n        Next Header    103 (PIM)\n        Length  \
    \       4\n        PIM Version    0\n        PIM Type       0\n        PIM Reserved\
    \   0\n        PIM Checksum   PIM checksum including\n                       IPv6\
    \ \"pseudo-header\";\n                       see Section 4.9\n        On receipt\
    \ of an IPv6 (S,G) Null-Register, if the dummy PIM\n        header is present,\
    \ the recipient SHOULD check the checksum and\n        discard Null-Registers\
    \ that have a bad checksum.\n"
- title: 4.9.4.  Register-Stop Message Format
  contents:
  - "4.9.4.  Register-Stop Message Format\n   A Register-Stop is unicast from the\
    \ RP to the sender of the Register\n   message.  The IP source address is the\
    \ address to which the register\n   was addressed.  The IP destination address\
    \ is the source address of\n   the register message.\n    0                  \
    \ 1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |PIM Ver| Type  |   Reserved    |           Checksum            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             Group Address (Encoded-Group format)              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Source Address (Encoded-Unicast format)            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   PIM Version, Type, Reserved, Checksum\n        Described in Section 4.9.\n\
    \   Group Address\n        The group address from the multicast data packet in\
    \ the\n        Register.  Format described in Section 4.9.1. Note that for\n \
    \       Register-Stops the Mask Len field contains the full address\n        length\
    \ * 8 (e.g., 32 for IPv4 native encoding), if the message\n        is sent for\
    \ a single group.\n   Source Address\n        The host address of the source from\
    \ the multicast data packet in\n        the register.  The format for this address\
    \ is given in the\n        Encoded-Unicast address in Section 4.9.1. A special\
    \ wild card\n        value consisting of an address field of all zeros can be\
    \ used to\n        indicate any source.\n"
- title: 4.9.5.  Join/Prune Message Format
  contents:
  - "4.9.5.  Join/Prune Message Format\n   A Join/Prune message is sent by routers\
    \ towards upstream sources and\n   RPs.  Joins are sent to build shared trees\
    \ (RP trees) or source trees\n   (SPT).  Prunes are sent to prune source trees\
    \ when members leave\n   groups as well as sources that do not use the shared\
    \ tree.\n    0                   1                   2                   3\n \
    \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |PIM Ver| Type  |   Reserved    |           Checksum            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        Upstream Neighbor Address (Encoded-Unicast format)     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Reserved     | Num groups    |          Holdtime             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Multicast Group Address 1 (Encoded-Group format)      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   Number of Joined Sources    |   Number of Pruned Sources    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        Joined Source Address 1 (Encoded-Source format)        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                             .                                 |\n   |  \
    \                           .                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        Joined Source Address n (Encoded-Source format)        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        Pruned Source Address 1 (Encoded-Source format)        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                             .                                 |\n   |  \
    \                           .                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        Pruned Source Address n (Encoded-Source format)        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           .                                   |\n   |  \
    \                         .                                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Multicast Group Address m (Encoded-Group format)      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   Number of Joined Sources    |   Number of Pruned Sources    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        Joined Source Address 1 (Encoded-Source format)        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                             .                                 |\n   |  \
    \                           .                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        Joined Source Address n (Encoded-Source format)        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        Pruned Source Address 1 (Encoded-Source format)        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                             .                                 |\n   |  \
    \                           .                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        Pruned Source Address n (Encoded-Source format)        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   PIM Version, Type, Reserved, Checksum\n        Described in Section 4.9.\n\
    \   Unicast Upstream Neighbor Address\n        The address of the upstream neighbor\
    \ that is the target of the\n        message.  The format for this address is\
    \ given in the Encoded-\n        Unicast address in Section 4.9.1. For IPv6 the\
    \ source address\n        used for multicast messages is the link-local address\
    \ of the\n        interface on which the message is being sent.  For IPv4, the\n\
    \        source address is the primary address associated with that\n        interface.\n\
    \   Reserved\n        Transmitted as zero, ignored on receipt.\n   Holdtime\n\
    \        The amount of time a receiver must keep the Join/Prune state\n      \
    \  alive, in seconds.  If the Holdtime is set to '0xffff', the\n        receiver\
    \ of this message should hold the state until canceled by\n        the appropriate\
    \ canceling Join/Prune message, or timed out\n        according to local policy.\
    \  This may be used with dial-on-demand\n        links, to avoid keeping the link\
    \ up with periodic Join/Prune\n        messages.\n        Note that the HoldTime\
    \ must be larger than the\n        J/P_Override_Interval(I).\n   Number of Groups\n\
    \        The number of multicast group sets contained in the message.\n   Multicast\
    \ group address\n        For format description, see Section 4.9.1.\n   Number\
    \ of Joined Sources\n        Number of joined source addresses listed for a given\
    \ group.\n   Joined Source Address 1 .. n\n        This list contains the sources\
    \ for a given group that the\n        sending router will forward multicast datagrams\
    \ from if received\n        on the interface on which the Join/Prune message is\
    \ sent.\n        See Encoded-Source-Address format in Section 4.9.1.\n   Number\
    \ of Pruned Sources\n        Number of pruned source addresses listed for a group.\n\
    \   Pruned Source Address 1 .. n\n        This list contains the sources for a\
    \ given group that the\n        sending router does not want to forward multicast\
    \ datagrams from\n        when received on the interface on which the Join/Prune\
    \ message\n        is sent.\n   Within one PIM Join/Prune message, all the Multicast\
    \ Group Addresses,\n   Joined Source addresses, and Pruned Source addresses MUST\
    \ be of the\n   same address family.  It is NOT PERMITTED to mix IPv4 and IPv6\n\
    \   addresses within the same message.  In addition, the address family\n   of\
    \ the fields in the message SHOULD be the same as the IP source and\n   destination\
    \ addresses of the packet.  This permits maximum\n   implementation flexibility\
    \ for dual-stack IPv4/IPv6 routers.  If a\n   router receives a message with mixed\
    \ family addresses, it SHOULD only\n   process the addresses that are of the same\
    \ family as the unicast\n   upstream neighbor address.\n"
- title: 4.9.5.1.  Group Set Source List Rules
  contents:
  - "4.9.5.1.  Group Set Source List Rules\n   As described above, Join/Prune messages\
    \ are composed of one or more\n   group sets.  Each set contains two source lists,\
    \ the Joined Sources\n   and the Pruned Sources.  This section describes the different\
    \ types\n   of group sets and source list entries that can exist in a Join/Prune\n\
    \   message.\n   There are two valid group set types:\n   Wildcard Group Set\n\
    \        The wildcard group set is represented by the entire multicast\n     \
    \   range:  the beginning of the multicast address range in the\n        group\
    \ address field and the prefix length of the multicast\n        address range\
    \ in the mask length field of the Multicast Group\n        Address (i.e., '224.0.0.0/4'\
    \ for IPv4 or 'ff00::/8' for IPv6).\n        Each Join/Prune message SHOULD contain\
    \ at most one wildcard\n        group set.  Each wildcard group set may contain\
    \ one or more\n        (*,*,RP) source list entries in either the Joined or Pruned\n\
    \        lists.\n        A (*,*,RP) source list entry may only exist in a wildcard\
    \ group\n        set.  When added to a Joined source list, this type of source\n\
    \        entry expresses the router's interest in receiving traffic for\n    \
    \    all groups mapping to the specified RP.  When added to a Pruned\n       \
    \ source list a (*,*,RP) entry expresses the router's interest to\n        stop\
    \ receiving such traffic.  Note that as indicated by the\n        Join/Prune state\
    \ machines, such a Join or Prune will NOT\n        override Join/Prune state created\
    \ using a Group-Specific Set\n        (see below).\n        (*,*,RP) source list\
    \ entries have the Source-Address set to the\n        address of the RP, the Source-Address\
    \ Mask-Len set to the full\n        length of the IP address, and both the WC\
    \ and RPT bits of the\n        Source-Address set to 1.\n   Group-Specific Set\n\
    \        A Group-Specific Set is represented by a valid IP multicast\n       \
    \ address in the group address field and the full length of the IP\n        address\
    \ in the mask length field of the Multicast Group Address.\n        Each Join/Prune\
    \ message SHOULD NOT contain more than one group-\n        specific set for the\
    \ same IP multicast address.  Each group-\n        specific set may contain (*,G),\
    \ (S,G,rpt), and (S,G) source list\n        entries in the Joined or Pruned lists.\n\
    \     (*,G)\n          The (*,G) source list entry is used in Join/Prune messages\n\
    \          sent towards the RP for the specified group.  It expresses\n      \
    \    interest (or lack thereof) in receiving traffic sent to the\n          group\
    \ through the Rendezvous-Point shared tree.  There may\n          only be one\
    \ such entry in both the Joined and Pruned lists of\n          a group-specific\
    \ set.\n          (*,G) source list entries have the Source-Address set to the\n\
    \          address of the RP for group G, the Source-Address Mask-Len set\n  \
    \        to the full length of the IP address, and both the WC and RPT\n     \
    \     bits of the Encoded-Source-Address set.\n     (S,G,rpt)\n          The (S,G,rpt)\
    \ source list entry is used in Join/Prune messages\n          sent towards the\
    \ RP for the specified group.  It expresses\n          interest (or lack thereof)\
    \ in receiving traffic through the\n          shared tree sent by the specified\
    \ source to this group.  For\n          each source address, the entry may exist\
    \ in only one of the\n          Joined and Pruned source lists of a group-specific\
    \ set, but\n          not both.\n          (S,G,rpt) source list entries have\
    \ the Source-Address set to\n          the address of the source S, the Source-Address\
    \ Mask-Len set\n          to the full length of the IP address, and the WC bit\
    \ cleared\n          and the RPT bit set in the Encoded-Source-Address.\n    \
    \ (S,G)\n          The (S,G) source list entry is used in Join/Prune messages\n\
    \          sent towards the specified source.  It expresses interest (or\n   \
    \       lack thereof) in receiving traffic through the shortest path\n       \
    \   tree sent by the source to the specified group.  For each\n          source\
    \ address, the entry may exist in only one of the Joined\n          and Pruned\
    \ source lists of a group-specific set, but not both.\n          (S,G) source\
    \ list entries have the Source-Address set to the\n          address of the source\
    \ S, the Source-Address Mask-Len set to\n          the full length of the IP address,\
    \ and both the WC and RPT\n          bits of the Encoded-Source-Address cleared.\n\
    \   The rules described above are sufficient to prevent invalid\n   combinations\
    \ of source list entries in group-specific sets.  There\n   are, however, a number\
    \ of combinations that have a valid\n   interpretation but that are not generated\
    \ by the protocol as\n   described in this specification:\n   o Combining a (*,G)\
    \ Join and a (S,G,rpt) Join entry in the same\n     message is redundant as the\
    \ (*,G) entry covers the information\n     provided by the (S,G,rpt) entry.\n\
    \   o The same applies for a (*,G) Prunes and (S,G,rpt) Prunes.\n   o The combination\
    \ of a (*,G) Prune and a (S,G,rpt) Join is also not\n     generated.  (S,G,rpt)\
    \ Joins are only sent when the router is\n     receiving all traffic for a group\
    \ on the shared tree and it wishes\n     to indicate a change for the particular\
    \ source.  As a (*,G) prune\n     indicates that the router no longer wishes to\
    \ receive shared tree\n     traffic, the (S,G,rpt) Join would be meaningless.\n\
    \   o As Join/Prune messages are targeted to a single PIM neighbor,\n     including\
    \ both a (S,G) Join and a (S,G,rpt) Prune in the same\n     message is usually\
    \ redundant.  The (S,G) Join informs the neighbor\n     that the sender wishes\
    \ to receive the particular source on the\n     shortest path tree.  It is therefore\
    \ unnecessary for the router to\n     say that it no longer wishes to receive\
    \ it on the shared tree.\n     However, there is a valid interpretation for this\
    \ combination of\n     entries.  A downstream router may have to instruct its\
    \ upstream\n     only to start forwarding a specific source once it has started\n\
    \     receiving the source on the shortest-path tree.\n   o The combination of\
    \ a (S,G) Prune and a (S,G,rpt) Join could\n     possibly be used by a router\
    \ to switch from receiving a particular\n     source on the shortest-path tree\
    \ back to receiving it on the shared\n     tree (provided that the RPF neighbor\
    \ for the shortest-path and\n     shared trees is common).  However, Sparse-Mode\
    \ PIM does not provide\n     a mechanism for explicitly switching back to the\
    \ shared tree.\n   The rules are summarized in the tables below.\n   +----------++------+-------+-----------+-----------+-------+-------+\n\
    \   |          ||Join  | Prune | Join      | Prune     | Join  | Prune |\n   |\
    \          ||(*,G) | (*,G) | (S,G,rpt) | (S,G,rpt) | (S,G) | (S,G) |\n   +----------++------+-------+-----------+-----------+-------+-------+\n\
    \   |Join      ||-     | no    | ?         | yes       | yes   | yes   |\n   |(*,G)\
    \     ||      |       |           |           |       |       |\n   +----------++------+-------+-----------+-----------+-------+-------+\n\
    \   |Prune     ||no    | -     | ?         | ?         | yes   | yes   |\n   |(*,G)\
    \     ||      |       |           |           |       |       |\n   +----------++------+-------+-----------+-----------+-------+-------+\n\
    \   |Join      ||?     | ?     | -         | no        | yes   | ?     |\n   |(S,G,rpt)\
    \ ||      |       |           |           |       |       |\n   +----------++------+-------+-----------+-----------+-------+-------+\n\
    \   |Prune     ||yes   | ?     | no        | -         | yes   | ?     |\n   |(S,G,rpt)\
    \ ||      |       |           |           |       |       |\n   +----------++------+-------+-----------+-----------+-------+-------+\n\
    \   |Join      ||yes   | yes   | yes       | yes       | -     | no    |\n   |(S,G)\
    \     ||      |       |           |           |       |       |\n   +----------++------+-------+-----------+-----------+-------+-------+\n\
    \   |Prune     ||yes   | yes   | ?         | ?         | no    | -     |\n   |(S,G)\
    \     ||      |       |           |           |       |       |\n   +----------++------+-------+-----------+-----------+-------+-------+\n\
    \   +---------------++--------------+----------------+------------+\n   |    \
    \           ||Join (*,*,RP) | Prune (*,*,RP) | all others |\n   +---------------++--------------+----------------+------------+\n\
    \   |Join (*,*,RP)  ||-             | no             | yes        |\n   +---------------++--------------+----------------+------------+\n\
    \   |Prune (*,*,RP) ||no            | -              | yes        |\n   +---------------++--------------+----------------+------------+\n\
    \   |all others     ||yes           | yes            | see above  |\n   +---------------++--------------+----------------+------------+\n\
    \   yes  Allowed and expected.\n   no   Combination is not allowed by the protocol\
    \ and MUST NOT be\n        generated by a router.  A router MAY accept these messages,\
    \ but\n        the result is undefined.  An error message MAY be logged to the\n\
    \        administrator in a rate-limited manner.\n   ?    Combination not expected\
    \ by the protocol, but well-defined.  A\n        router MAY accept it but SHOULD\
    \ NOT generate it.\n   The order of source list entries in a group set source\
    \ list is not\n   important, except where limited by the packet format itself.\n"
- title: 4.9.5.2.  Group Set Fragmentation
  contents:
  - "4.9.5.2.  Group Set Fragmentation\n   When building a Join/Prune for a particular\
    \ neighbor, a router should\n   try to include in the message as much of the information\
    \ it needs to\n   convey to the neighbor as possible.  This implies adding one\
    \ group\n   set for each multicast group that has information pending\n   transmission\
    \ and within each set including all relevant source list\n   entries.\n   On a\
    \ router with a large amount of multicast state, the number of\n   entries that\
    \ must be included may result in packets that are larger\n   than the maximum\
    \ IP packet size.  In most such cases, the information\n   may be split into multiple\
    \ messages.\n   There is an exception with group sets that contain a (*,G) Joined\n\
    \   source list entry.  The group set expresses the router's interest in\n   receiving\
    \ all traffic for the specified group on the shared tree, and\n   it MUST include\
    \ an (S,G,rpt) Pruned source list entry for every\n   source that the router does\
    \ not wish to receive.  This list of\n   (S,G,rpt) Pruned source-list entries\
    \ MUST not be split in multiple\n   messages.\n   If only N (S,G,rpt) Prune entries\
    \ fit into a maximum-sized Join/Prune\n   message, but the router has more than\
    \ N (S,G,rpt) Prunes to add, then\n   the router MUST choose to include the first\
    \ N (numerically smallest\n   in network byte order) IP addresses.\n"
- title: 4.9.6.  Assert Message Format
  contents:
  - "4.9.6.  Assert Message Format\n   The Assert message is used to resolve forwarder\
    \ conflicts between\n   routers on a link.  It is sent when a router receives\
    \ a multicast\n   data packet on an interface on which the router would normally\
    \ have\n   forwarded that packet.  Assert messages may also be sent in response\n\
    \   to an Assert message from another router.\n    0                   1     \
    \              2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |PIM Ver| Type  |   Reserved    |           Checksum            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |              Group Address (Encoded-Group format)             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Source Address (Encoded-Unicast format)            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |R|                      Metric Preference                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                             Metric                            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   PIM Version, Type, Reserved, Checksum\n        Described in Section 4.9.\n\
    \   Group Address\n        The group address for which the router wishes to resolve\
    \ the\n        forwarding conflict.  This is an Encoded-Group address, as\n  \
    \      specified in Section 4.9.1.\n   Source Address\n        Source address\
    \ for which the router wishes to resolve the\n        forwarding conflict.  The\
    \ source address MAY be set to zero for\n        (*,G) asserts (see below).  The\
    \ format for this address is given\n        in Encoded-Unicast-Address in Section\
    \ 4.9.1.\n   R    RPT-bit is a 1-bit value.  The RPT-bit is set to 1 for\n   \
    \     Assert(*,G) messages and 0 for Assert(S,G) messages.\n   Metric Preference\n\
    \        Preference value assigned to the unicast routing protocol that\n    \
    \    provided the route to the multicast source or Rendezvous-Point.\n   Metric\n\
    \        The unicast routing table metric associated with the route used\n   \
    \     to reach the multicast source or Rendezvous-Point.  The metric\n       \
    \ is in units applicable to the unicast routing protocol used.\n   Assert messages\
    \ can be sent to resolve a forwarding conflict for all\n   traffic to a given\
    \ group or for a specific source and group.\n   Assert(S,G)\n        Source-specific\
    \ asserts are sent by routers forwarding a\n        specific source on the shortest-path\
    \ tree (SPTbit is TRUE).\n        (S,G) Asserts have the Group-Address field set\
    \ to the group G\n        and the Source-Address field set to the source S.  The\
    \ RPT-bit\n        is set to 0, the Metric-Preference is set to MRIB.pref(S) and\n\
    \        the Metric is set to MRIB.metric(S).\n   Assert(*,G)\n        Group-specific\
    \ asserts are sent by routers forwarding data for\n        the group and source(s)\
    \ under contention on the shared tree.\n        (*,G) asserts have the Group-Address\
    \ field set to the group G.\n        For data-triggered Asserts, the Source-Address\
    \ field MAY be set\n        to the IP source address of the data packet that triggered\
    \ the\n        Assert and is set to zero otherwise.  The RPT-bit is set to 1,\n\
    \        the Metric-Preference is set to MRIB.pref(RP(G)), and the Metric\n  \
    \      is set to MRIB.metric(RP(G)).\n"
- title: 4.10.  PIM Timers
  contents:
  - "4.10.  PIM Timers\n   PIM-SM maintains the following timers, as discussed in\
    \ Section 4.1.\n   All timers are countdown timers; they are set to a value and\
    \ count\n   down to zero, at which point they typically trigger an action.  Of\n\
    \   course they can just as easily be implemented as count-up timers,\n   where\
    \ the absolute expiry time is stored and compared against a\n   real-time clock,\
    \ but the language in this specification assumes that\n   they count downwards\
    \ to zero.\n   Global Timers\n   Per interface (I):\n        Hello Timer: HT(I)\n\
    \        Per neighbor (N):\n             Neighbor Liveness Timer: NLT(N,I)\n \
    \       Per active RP (RP):\n             (*,*,RP) Join Expiry Timer: ET(*,*,RP,I)\n\
    \             (*,*,RP) Prune-Pending Timer: PPT(*,*,RP,I)\n        Per Group (G):\n\
    \             (*,G) Join Expiry Timer: ET(*,G,I)\n             (*,G) Prune-Pending\
    \ Timer: PPT(*,G,I)\n             (*,G) Assert Timer: AT(*,G,I)\n            \
    \ Per Source (S):\n                  (S,G) Join Expiry Timer: ET(S,G,I)\n    \
    \              (S,G) Prune-Pending Timer: PPT(S,G,I)\n                  (S,G)\
    \ Assert Timer: AT(S,G,I)\n                  (S,G,rpt) Prune Expiry Timer: ET(S,G,rpt,I)\n\
    \                  (S,G,rpt) Prune-Pending Timer: PPT(S,G,rpt,I)\n   Per active\
    \ RP (RP):\n        (*,*,RP) Upstream Join Timer: JT(*,*,RP)\n   Per Group (G):\n\
    \        (*,G) Upstream Join Timer: JT(*,G)\n        Per Source (S):\n       \
    \      (S,G) Upstream Join Timer: JT(S,G)\n             (S,G) Keepalive Timer:\
    \ KAT(S,G)\n             (S,G,rpt) Upstream Override Timer: OT(S,G,rpt)\n   At\
    \ the DRs or relevant Assert Winners only:\n        Per Source,Group pair (S,G):\n\
    \             Register-Stop Timer: RST(S,G)\n"
- title: 4.11.  Timer Values
  contents:
  - "4.11.  Timer Values\n   When timers are started or restarted, they are set to\
    \ default values.\n   This section summarizes those default values.\n   Note that\
    \ protocol events or configuration may change the default\n   value of a timer\
    \ on a specific interface.  When timers are\n   initialized in this document,\
    \ the value specific to the interface in\n   context must be used.\n   Some of\
    \ the timers listed below (Prune-Pending, Upstream Join,\n   Upstream Override)\
    \ can be set to values that depend on the settings\n   of the Propagation_Delay\
    \ and Override_Interval of the corresponding\n   interface.  The default values\
    \ for these are given below.\n   Variable Name: Propagation_Delay(I)\n"
- title: +-------------------------------+--------------+----------------------+
  contents:
  - '+-------------------------------+--------------+----------------------+

    '
- title: '|  Value Name                   |  Value       |  Explanation         |'
  contents:
  - '|  Value Name                   |  Value       |  Explanation         |

    '
- title: +-------------------------------+--------------+----------------------+
  contents:
  - '+-------------------------------+--------------+----------------------+

    '
- title: '|  Propagation_delay_default    |  0.5 secs    |  Expected            |'
  contents:
  - '|  Propagation_delay_default    |  0.5 secs    |  Expected            |

    '
- title: '|                               |              |  propagation delay   |'
  contents:
  - '|                               |              |  propagation delay   |

    '
- title: '|                               |              |  over the local      |'
  contents:
  - '|                               |              |  over the local      |

    '
- title: '|                               |              |  link.               |'
  contents:
  - '|                               |              |  link.               |

    '
- title: +-------------------------------+--------------+----------------------+
  contents:
  - "+-------------------------------+--------------+----------------------+\n   The\
    \ default value of the Propagation_delay_default is chosen to be\n   relatively\
    \ large to provide compatibility with older PIM\n   implementations.\n   Variable\
    \ Name: Override_Interval(I)\n"
- title: +--------------------------+-----------------+-------------------------+
  contents:
  - '+--------------------------+-----------------+-------------------------+

    '
- title: '|  Value Name              |    Value        |    Explanation          |'
  contents:
  - '|  Value Name              |    Value        |    Explanation          |

    '
- title: +--------------------------+-----------------+-------------------------+
  contents:
  - '+--------------------------+-----------------+-------------------------+

    '
- title: '|  t_override_default      |    2.5 secs     |    Default delay        |'
  contents:
  - '|  t_override_default      |    2.5 secs     |    Default delay        |

    '
- title: '|                          |                 |    interval over        |'
  contents:
  - '|                          |                 |    interval over        |

    '
- title: '|                          |                 |    which to randomize   |'
  contents:
  - '|                          |                 |    which to randomize   |

    '
- title: '|                          |                 |    when scheduling a    |'
  contents:
  - '|                          |                 |    when scheduling a    |

    '
- title: '|                          |                 |    delayed Join         |'
  contents:
  - '|                          |                 |    delayed Join         |

    '
- title: '|                          |                 |    message.             |'
  contents:
  - '|                          |                 |    message.             |

    '
- title: +--------------------------+-----------------+-------------------------+
  contents:
  - "+--------------------------+-----------------+-------------------------+\n  \
    \ Timer Name: Hello Timer (HT(I))\n"
- title: +---------------------+--------+---------------------------------------+
  contents:
  - '+---------------------+--------+---------------------------------------+

    '
- title: '|Value Name           | Value  | Explanation                           |'
  contents:
  - '|Value Name           | Value  | Explanation                           |

    '
- title: +---------------------+--------+---------------------------------------+
  contents:
  - '+---------------------+--------+---------------------------------------+

    '
- title: '|Hello_Period         | 30 secs| Periodic interval for Hello messages. |'
  contents:
  - '|Hello_Period         | 30 secs| Periodic interval for Hello messages. |

    '
- title: +---------------------+--------+---------------------------------------+
  contents:
  - '+---------------------+--------+---------------------------------------+

    '
- title: '|Triggered_Hello_Delay| 5 secs | Randomized interval for initial Hello |'
  contents:
  - '|Triggered_Hello_Delay| 5 secs | Randomized interval for initial Hello |

    '
- title: '|                     |        | message on bootup or triggered Hello  |'
  contents:
  - '|                     |        | message on bootup or triggered Hello  |

    '
- title: '|                     |        | message to a rebooting neighbor.      |'
  contents:
  - '|                     |        | message to a rebooting neighbor.      |

    '
- title: +---------------------+--------+---------------------------------------+
  contents:
  - "+---------------------+--------+---------------------------------------+\n  \
    \ At system power-up, the timer is initialized to rand(0,\n   Triggered_Hello_Delay)\
    \ to prevent synchronization.  When a new or\n   rebooting neighbor is detected,\
    \ a responding Hello is sent within\n   rand(0, Triggered_Hello_Delay).\n   Timer\
    \ Name: Neighbor Liveness Timer (NLT(N,I))\n"
- title: +--------------------------+----------------------+--------------------+
  contents:
  - '+--------------------------+----------------------+--------------------+

    '
- title: '| Value Name               |  Value               |  Explanation       |'
  contents:
  - '| Value Name               |  Value               |  Explanation       |

    '
- title: +--------------------------+----------------------+--------------------+
  contents:
  - '+--------------------------+----------------------+--------------------+

    '
- title: '| Default_Hello_Holdtime   |  3.5 * Hello_Period  |  Default holdtime  |'
  contents:
  - '| Default_Hello_Holdtime   |  3.5 * Hello_Period  |  Default holdtime  |

    '
- title: '|                          |                      |  to keep neighbor  |'
  contents:
  - '|                          |                      |  to keep neighbor  |

    '
- title: '|                          |                      |  state alive       |'
  contents:
  - '|                          |                      |  state alive       |

    '
- title: +--------------------------+----------------------+--------------------+
  contents:
  - '+--------------------------+----------------------+--------------------+

    '
- title: '| Hello_Holdtime           |  from message        |  Holdtime from     |'
  contents:
  - '| Hello_Holdtime           |  from message        |  Holdtime from     |

    '
- title: '|                          |                      |  Hello Message     |'
  contents:
  - '|                          |                      |  Hello Message     |

    '
- title: '|                          |                      |  Holdtime option.  |'
  contents:
  - '|                          |                      |  Holdtime option.  |

    '
- title: +--------------------------+----------------------+--------------------+
  contents:
  - "+--------------------------+----------------------+--------------------+\n  \
    \ The Holdtime in a Hello Message should be set to (3.5 *\n   Hello_Period), giving\
    \ a default value of 105 seconds.\n   Timer Names: Expiry Timer (ET(*,*,RP,I),\
    \ ET(*,G,I), ET(S,G,I),\n   ET(S,G,rpt,I))\n"
- title: +----------------+----------------+------------------------------------+
  contents:
  - '+----------------+----------------+------------------------------------+

    '
- title: '| Value Name     |  Value         |  Explanation                       |'
  contents:
  - '| Value Name     |  Value         |  Explanation                       |

    '
- title: +----------------+----------------+------------------------------------+
  contents:
  - '+----------------+----------------+------------------------------------+

    '
- title: '| J/P_HoldTime   |  from message  |  Holdtime from Join/Prune Message  |'
  contents:
  - '| J/P_HoldTime   |  from message  |  Holdtime from Join/Prune Message  |

    '
- title: +----------------+----------------+------------------------------------+
  contents:
  - "+----------------+----------------+------------------------------------+\n  \
    \ See details of JT(*,G) for the Holdtime that is included in\n   Join/Prune Messages.\n\
    \   Timer Names: Prune-Pending Timer (PPT(*,*,RP,I), PPT(*,G,I),\n   PPT(S,G,I),\
    \ PPT(S,G,rpt,I))\n"
- title: +--------------------------+---------------------+---------------------+
  contents:
  - '+--------------------------+---------------------+---------------------+

    '
- title: '|Value Name                | Value               | Explanation         |'
  contents:
  - '|Value Name                | Value               | Explanation         |

    '
- title: +--------------------------+---------------------+---------------------+
  contents:
  - '+--------------------------+---------------------+---------------------+

    '
- title: '|J/P_Override_Interval(I)  | Default:            | Short period after  |'
  contents:
  - '|J/P_Override_Interval(I)  | Default:            | Short period after  |

    '
- title: '|                          | Effective_          | a join or prune to  |'
  contents:
  - '|                          | Effective_          | a join or prune to  |

    '
- title: '|                          | Propagation_        | allow other         |'
  contents:
  - '|                          | Propagation_        | allow other         |

    '
- title: '|                          | Delay(I) +          | routers on the LAN  |'
  contents:
  - '|                          | Delay(I) +          | routers on the LAN  |

    '
- title: '|                          | EffectiveOverride_  | to override the     |'
  contents:
  - '|                          | EffectiveOverride_  | to override the     |

    '
- title: '|                          | Interval(I)         | join or prune       |'
  contents:
  - '|                          | Interval(I)         | join or prune       |

    '
- title: +--------------------------+---------------------+---------------------+
  contents:
  - "+--------------------------+---------------------+---------------------+\n  \
    \ Note that both the Effective_Propagation_Delay(I) and the\n   Effective_Override_Interval(I)\
    \ are interface-specific values that may\n   change when Hello messages are received\
    \ (see Section 4.3.3).\n   Timer Names: Assert Timer (AT(*,G,I), AT(S,G,I))\n"
- title: +---------------------------+---------------------+--------------------+
  contents:
  - '+---------------------------+---------------------+--------------------+

    '
- title: '| Value Name                | Value               | Explanation        |'
  contents:
  - '| Value Name                | Value               | Explanation        |

    '
- title: +---------------------------+---------------------+--------------------+
  contents:
  - '+---------------------------+---------------------+--------------------+

    '
- title: '| Assert_Override_Interval  | Default: 3 secs     | Short interval     |'
  contents:
  - '| Assert_Override_Interval  | Default: 3 secs     | Short interval     |

    '
- title: '|                           |                     | before an assert   |'
  contents:
  - '|                           |                     | before an assert   |

    '
- title: '|                           |                     | times out where    |'
  contents:
  - '|                           |                     | times out where    |

    '
- title: '|                           |                     | the assert winner  |'
  contents:
  - '|                           |                     | the assert winner  |

    '
- title: '|                           |                     | resends an Assert  |'
  contents:
  - '|                           |                     | resends an Assert  |

    '
- title: '|                           |                     | message            |'
  contents:
  - '|                           |                     | message            |

    '
- title: +---------------------------+---------------------+--------------------+
  contents:
  - '+---------------------------+---------------------+--------------------+

    '
- title: '| Assert_Time               | Default: 180 secs   | Period after last  |'
  contents:
  - '| Assert_Time               | Default: 180 secs   | Period after last  |

    '
- title: '|                           |                     | assert before      |'
  contents:
  - '|                           |                     | assert before      |

    '
- title: '|                           |                     | assert state is    |'
  contents:
  - '|                           |                     | assert state is    |

    '
- title: '|                           |                     | timed out          |'
  contents:
  - '|                           |                     | timed out          |

    '
- title: +---------------------------+---------------------+--------------------+
  contents:
  - "+---------------------------+---------------------+--------------------+\n  \
    \ Note that for historical reasons, the Assert message lacks a Holdtime\n   field.\
    \  Thus, changing the Assert Time from the default value is not\n   recommended.\n\
    \   Timer Names: Upstream Join Timer (JT(*,*,RP), JT(*,G), JT(S,G))\n"
- title: +-------------+--------------------+-----------------------------------+
  contents:
  - '+-------------+--------------------+-----------------------------------+

    '
- title: '|Value Name   | Value              | Explanation                       |'
  contents:
  - '|Value Name   | Value              | Explanation                       |

    '
- title: +-------------+--------------------+-----------------------------------+
  contents:
  - '+-------------+--------------------+-----------------------------------+

    '
- title: '|t_periodic   | Default: 60 secs   | Period between Join/Prune Messages|'
  contents:
  - '|t_periodic   | Default: 60 secs   | Period between Join/Prune Messages|

    '
- title: +-------------+--------------------+-----------------------------------+
  contents:
  - '+-------------+--------------------+-----------------------------------+

    '
- title: '|t_suppressed | rand(1.1 *         | Suppression period when someone   |'
  contents:
  - '|t_suppressed | rand(1.1 *         | Suppression period when someone   |

    '
- title: '|             | t_periodic, 1.4 *  | else sends a J/P message so we    |'
  contents:
  - '|             | t_periodic, 1.4 *  | else sends a J/P message so we    |

    '
- title: '|             | t_periodic) when   | don''t need to do so.              |'
  contents:
  - '|             | t_periodic) when   | don''t need to do so.              |

    '
- title: '|             | Suppression_       |                                   |'
  contents:
  - '|             | Suppression_       |                                   |

    '
- title: '|             | Enabled(I) is      |                                   |'
  contents:
  - '|             | Enabled(I) is      |                                   |

    '
- title: '|             | true, 0 otherwise  |                                   |'
  contents:
  - '|             | true, 0 otherwise  |                                   |

    '
- title: +-------------+--------------------+-----------------------------------+
  contents:
  - '+-------------+--------------------+-----------------------------------+

    '
- title: '|t_override   | rand(0, Effective_ | Randomized delay to prevent       |'
  contents:
  - '|t_override   | rand(0, Effective_ | Randomized delay to prevent       |

    '
- title: '|             | Override_          | response implosion when sending a |'
  contents:
  - '|             | Override_          | response implosion when sending a |

    '
- title: '|             | Interval(I))       | join message to override someone  |'
  contents:
  - '|             | Interval(I))       | join message to override someone  |

    '
- title: '|             |                    | else''s Prune message.             |'
  contents:
  - '|             |                    | else''s Prune message.             |

    '
- title: +-------------+--------------------+-----------------------------------+
  contents:
  - "+-------------+--------------------+-----------------------------------+\n  \
    \ t_periodic may be set to take into account such things as the\n   configured\
    \ bandwidth and expected average number of multicast route\n   entries for the\
    \ attached network or link (e.g., the period would be\n   longer for lower-speed\
    \ links, or for routers in the center of the\n   network that expect to have a\
    \ larger number of entries).  If the\n   Join/Prune-Period is modified during\
    \ operation, these changes should\n   be made relatively infrequently, and the\
    \ router should continue to\n   refresh at its previous Join/Prune-Period for\
    \ at least Join/Prune-\n   Holdtime, in order to allow the upstream router to\
    \ adapt.\n   The holdtime specified in a Join/Prune message should be set to (3.5\n\
    \   * t_periodic).\n   t_override depends on the Effective_Override_Interval of\
    \ the upstream\n   interface, which may change when Hello messages are received.\n\
    \   t_suppressed depends on the Suppression State of the upstream\n   interface\
    \ (Section 4.3.3) and becomes zero when suppression is\n   disabled.\n   Timer\
    \ Name: Upstream Override Timer (OT(S,G,rpt))\n"
- title: +---------------+--------------------------+---------------------------+
  contents:
  - '+---------------+--------------------------+---------------------------+

    '
- title: '| Value Name    | Value                    |  Explanation              |'
  contents:
  - '| Value Name    | Value                    |  Explanation              |

    '
- title: +---------------+--------------------------+---------------------------+
  contents:
  - '+---------------+--------------------------+---------------------------+

    '
- title: '| t_override    | see Upstream Join Timer  |  see Upstream Join Timer  |'
  contents:
  - '| t_override    | see Upstream Join Timer  |  see Upstream Join Timer  |

    '
- title: +---------------+--------------------------+---------------------------+
  contents:
  - "+---------------+--------------------------+---------------------------+\n  \
    \ The upstream Override Timer is only ever set to t_override; this\n   value is\
    \ defined in the section on Upstream Join Timers.\n   Timer Name: Keepalive Timer\
    \ (KAT(S,G))\n"
- title: +-----------------------+-----------------------+----------------------+
  contents:
  - '+-----------------------+-----------------------+----------------------+

    '
- title: '| Value Name            |  Value                |  Explanation         |'
  contents:
  - '| Value Name            |  Value                |  Explanation         |

    '
- title: +-----------------------+-----------------------+----------------------+
  contents:
  - '+-----------------------+-----------------------+----------------------+

    '
- title: '| Keepalive_Period      |  Default: 210 secs    |  Period after last   |'
  contents:
  - '| Keepalive_Period      |  Default: 210 secs    |  Period after last   |

    '
- title: '|                       |                       |  (S,G) data packet   |'
  contents:
  - '|                       |                       |  (S,G) data packet   |

    '
- title: '|                       |                       |  during which (S,G)  |'
  contents:
  - '|                       |                       |  during which (S,G)  |

    '
- title: '|                       |                       |  Join state will be  |'
  contents:
  - '|                       |                       |  Join state will be  |

    '
- title: '|                       |                       |  maintained even in  |'
  contents:
  - '|                       |                       |  maintained even in  |

    '
- title: '|                       |                       |  the absence of      |'
  contents:
  - '|                       |                       |  the absence of      |

    '
- title: '|                       |                       |  (S,G) Join          |'
  contents:
  - '|                       |                       |  (S,G) Join          |

    '
- title: '|                       |                       |  messages.           |'
  contents:
  - '|                       |                       |  messages.           |

    '
- title: +-----------------------+-----------------------+----------------------+
  contents:
  - '+-----------------------+-----------------------+----------------------+

    '
- title: '| RP_Keepalive_Period   |  ( 3 * Register_      |  As                  |'
  contents:
  - '| RP_Keepalive_Period   |  ( 3 * Register_      |  As                  |

    '
- title: '|                       |  Suppression_Time )   |  Keepalive_Period,   |'
  contents:
  - '|                       |  Suppression_Time )   |  Keepalive_Period,   |

    '
- title: '|                       |  + Register_          |  but at the RP when  |'
  contents:
  - '|                       |  + Register_          |  but at the RP when  |

    '
- title: '|                       |  Probe_Time           |  a Register-Stop is  |'
  contents:
  - '|                       |  Probe_Time           |  a Register-Stop is  |

    '
- title: '|                       |                       |  sent.               |'
  contents:
  - '|                       |                       |  sent.               |

    '
- title: +-----------------------+-----------------------+----------------------+
  contents:
  - "+-----------------------+-----------------------+----------------------+\n  \
    \ The normal keepalive period for the KAT(S,G) defaults to 210 seconds.\n   However,\
    \ at the RP, the keepalive period must be at least the\n   Register_Suppression_Time,\
    \ or the RP may time out the (S,G) state\n   before the next Null-Register arrives.\
    \  Thus, the KAT(S,G) is set to\n   max(Keepalive_Period, RP_Keepalive_Period)\
    \ when a Register-Stop is\n   sent.\n   Timer Name: Register-Stop Timer (RST(S,G))\n"
- title: +---------------------------+--------------------+---------------------+
  contents:
  - '+---------------------------+--------------------+---------------------+

    '
- title: '|Value Name                 | Value              | Explanation         |'
  contents:
  - '|Value Name                 | Value              | Explanation         |

    '
- title: +---------------------------+--------------------+---------------------+
  contents:
  - '+---------------------------+--------------------+---------------------+

    '
- title: '|Register_Suppression_Time  | Default: 60 secs   | Period during       |'
  contents:
  - '|Register_Suppression_Time  | Default: 60 secs   | Period during       |

    '
- title: '|                           |                    | which a DR stops    |'
  contents:
  - '|                           |                    | which a DR stops    |

    '
- title: '|                           |                    | sending Register-   |'
  contents:
  - '|                           |                    | sending Register-   |

    '
- title: '|                           |                    | encapsulated data   |'
  contents:
  - '|                           |                    | encapsulated data   |

    '
- title: '|                           |                    | to the RP after     |'
  contents:
  - '|                           |                    | to the RP after     |

    '
- title: '|                           |                    | receiving a         |'
  contents:
  - '|                           |                    | receiving a         |

    '
- title: '|                           |                    | Register-Stop       |'
  contents:
  - '|                           |                    | Register-Stop       |

    '
- title: '|                           |                    | message.            |'
  contents:
  - '|                           |                    | message.            |

    '
- title: +---------------------------+--------------------+---------------------+
  contents:
  - '+---------------------------+--------------------+---------------------+

    '
- title: '|Register_Probe_Time        | Default: 5 secs    | Time before RST     |'
  contents:
  - '|Register_Probe_Time        | Default: 5 secs    | Time before RST     |

    '
- title: '|                           |                    | expires when a DR   |'
  contents:
  - '|                           |                    | expires when a DR   |

    '
- title: '|                           |                    | may send a Null-    |'
  contents:
  - '|                           |                    | may send a Null-    |

    '
- title: '|                           |                    | Register to the RP  |'
  contents:
  - '|                           |                    | Register to the RP  |

    '
- title: '|                           |                    | to cause it to      |'
  contents:
  - '|                           |                    | to cause it to      |

    '
- title: '|                           |                    | resend a Register-  |'
  contents:
  - '|                           |                    | resend a Register-  |

    '
- title: '|                           |                    | Stop message.       |'
  contents:
  - '|                           |                    | Stop message.       |

    '
- title: +---------------------------+--------------------+---------------------+
  contents:
  - "+---------------------------+--------------------+---------------------+\n  \
    \ If the Register_Suppression_Time or the Register_Probe_Time are\n   configured\
    \ to values other than the defaults, it MUST be ensured that\n   the value of\
    \ the Register_Probe_Time is less than half the value of\n   the Register_Suppression_Time\
    \ to prevent a possible negative value in\n   the setting of the Register-Stop\
    \ Timer.\n"
- title: 5.  IANA Considerations
  contents:
  - '5.  IANA Considerations

    '
- title: 5.1.  PIM Address Family
  contents:
  - "5.1.  PIM Address Family\n   The PIM Address Family field was chosen to be 8\
    \ bits as a tradeoff\n   between packet format and use of the IANA assigned numbers.\
    \  Because\n   when the PIM packet format was designed only 15 values were assigned\n\
    \   for Address Families, and large numbers of new Address Family values\n   were\
    \ not envisioned, 8 bits seemed large enough.  However, the IANA\n   assigns Address\
    \ Families in a 16-bit field.  Therefore, the PIM\n   Address Family is allocated\
    \ as follows:\n     Values 0 through 127 are designated to have the same meaning\
    \ as\n     IANA-assigned Address Family Numbers [7].\n     Values 128 through\
    \ 250 are designated to be assigned for PIM by the\n     IANA based upon IESG\
    \ Approval, as defined in [9].\n     Values 251 through 255 are designated for\
    \ Private Use, as defined\n     in [9].\n"
- title: 5.2.  PIM Hello Options
  contents:
  - "5.2.  PIM Hello Options\n   Values 17 through 65000 are to be assigned by the\
    \ IANA.  Since the\n   space is large, they may be assigned as First Come First\
    \ Served as\n   defined in [9].  Such assignments are valid for one year and may\
    \ be\n   renewed.  Permanent assignments require a specification (see\n   \"Specification\
    \ Required\" in [9].)\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   This section describes various possible security\
    \ concerns related to\n   the PIM-SM protocol, including a description of how\
    \ to use IPsec to\n   secure the protocol.  The reader is referred to [15] and\
    \ [16] for\n   further discussion of PIM-SM and multicast security.  The IPsec\n\
    \   authentication header [8] MAY be used to provide data integrity\n   protection\
    \ and groupwise data origin authentication of PIM protocol\n   messages.  Authentication\
    \ of PIM messages can protect against\n   unwanted behaviors caused by unauthorized\
    \ or altered PIM messages.\n"
- title: 6.1.  Attacks Based on Forged Messages
  contents:
  - "6.1.  Attacks Based on Forged Messages\n   The extent of possible damage depends\
    \ on the type of counterfeit\n   messages accepted.  We next consider the impact\
    \ of possible\n   forgeries, including forged link-local (Join/Prune, Hello, and\n\
    \   Assert) and forged unicast (Register and Register-Stop) messages.\n"
- title: 6.1.1.  Forged Link-Local Messages
  contents:
  - "6.1.1.  Forged Link-Local Messages\n   Join/Prune, Hello, and Assert messages\
    \ are all sent to the link-local\n   ALL_PIM_ROUTERS multicast addresses and thus\
    \ are not forwarded by a\n   compliant router.  A forged message of this type\
    \ can only reach a LAN\n   if it was sent by a local host or if it was allowed\
    \ onto the LAN by a\n   compromised or non-compliant router.\n   1.  A forged\
    \ Join/Prune message can cause multicast traffic to be\n       delivered to links\
    \ where there are no legitimate requesters,\n       potentially wasting bandwidth\
    \ on that link.  A forged leave\n       message on a multi-access LAN is generally\
    \ not a significant\n       attack in PIM, because any legitimately joined router\
    \ on the LAN\n       would override the leave with a join before the upstream\
    \ router\n       stops forwarding data to the LAN.\n   2.  By forging a Hello\
    \ message, an unauthorized router can cause\n       itself to be elected as the\
    \ designated router on a LAN.  The\n       designated router on a LAN is (in the\
    \ absence of asserts)\n       responsible for forwarding traffic to that LAN on\
    \ behalf of any\n       local members.  The designated router is also responsible\
    \ for\n       register-encapsulating to the RP any packets that are originated\n\
    \       by hosts on the LAN.  Thus, the ability of local hosts to send\n     \
    \  and receive multicast traffic may be compromised by a forged\n       Hello\
    \ message.\n   3.  By forging an Assert message on a multi-access LAN, an attacker\n\
    \       could cause the legitimate designated forwarder to stop\n       forwarding\
    \ traffic to the LAN.  Such a forgery would prevent any\n       hosts downstream\
    \ of that LAN from receiving traffic.\n"
- title: 6.1.2.  Forged Unicast Messages
  contents:
  - "6.1.2.  Forged Unicast Messages\n   Register messages and Register-Stop messages\
    \ are forwarded by\n   intermediate routers to their destination using normal\
    \ IP forwarding.\n   Without data origin authentication, an attacker who is located\n\
    \   anywhere in the network may be able to forge a Register or Register-\n   Stop\
    \ message.  We consider the effect of a forgery of each of these\n   messages\
    \ next.\n   1.  By forging a Register message, an attacker can cause the RP to\n\
    \       inject forged traffic onto the shared multicast tree.\n   2.  By forging\
    \ a Register-stop message, an attacker can prevent a\n       legitimate DR from\
    \ Registering packets to the RP.  This can\n       prevent local hosts on that\
    \ LAN from sending multicast packets.\n   The above two PIM messages are not changed\
    \ by intermediate routers\n   and need only be examined by the intended receiver.\
    \  Thus, these\n   messages can be authenticated end-to-end, using AH.  Attacks\
    \ on\n   Register and Register-Stop messages do not apply to a PIM-SSM-only\n\
    \   implementation, as these messages are not required for PIM-SSM.\n"
- title: 6.2.  Non-Cryptographic Authentication Mechanisms
  contents:
  - "6.2.  Non-Cryptographic Authentication Mechanisms\n   A PIM router SHOULD provide\
    \ an option to limit the set of neighbors\n   from which it will accept Join/Prune,\
    \ Assert, and Hello messages.\n   Either static configuration of IP addresses\
    \ or an IPsec security\n   association may be used.  Furthermore, a PIM router\
    \ SHOULD NOT accept\n   protocol messages from a router from which it has not\
    \ yet received a\n   valid Hello message.\n   A Designated Router MUST NOT register-encapsulate\
    \ a packet and send\n   it to the RP unless the source address of the packet is\
    \ a legal\n   address for the subnet on which the packet was received.  Similarly,\n\
    \   a Designated Router SHOULD NOT accept a Register-Stop packet whose IP\n  \
    \ source address is not a valid RP address for the local domain.\n   An implementation\
    \ SHOULD provide a mechanism to allow an RP to\n   restrict the range of source\
    \ addresses from which it accepts\n   Register-encapsulated packets.\n   All options\
    \ that restrict the range of addresses from which packets\n   are accepted MUST\
    \ default to allowing all packets.\n"
- title: 6.3.  Authentication Using IPsec
  contents:
  - "6.3.  Authentication Using IPsec\n   The IPsec [8] transport mode using the Authentication\
    \ Header (AH) is\n   the recommended method to prevent the above attacks against\
    \ PIM.  The\n   specific AH authentication algorithm and parameters, including\
    \ the\n   choice of authentication algorithm and the choice of key, are\n   configured\
    \ by the network administrator.  When IPsec authentication\n   is used, a PIM\
    \ router should reject (drop without processing) any\n   unauthorized PIM protocol\
    \ messages.\n   To use IPsec, the administrator of a PIM network configures each\
    \ PIM\n   router with one or more security associations (SAs) and associated\n\
    \   Security Parameter Indexes (SPIs) that are used by senders to\n   authenticate\
    \ PIM protocol messages and are used by receivers to\n   authenticate received\
    \ PIM protocol messages.  This document does not\n   describe protocols for establishing\
    \ SAs.  It assumes that manual\n   configuration of SAs is performed, but it does\
    \ not preclude the use\n   of a negotiation protocol such as the Internet Key\
    \ Exchange [14] to\n   establish SAs.\n   IPsec [8] provides protection against\
    \ replayed unicast and multicast\n   messages.  The anti-replay option for IPsec\
    \ SHOULD be enabled on all\n   SAs.\n   The following sections describe the SAs\
    \ required to protect PIM\n   protocol messages.\n"
- title: 6.3.1.  Protecting Link-Local Multicast Messages
  contents:
  - "6.3.1.  Protecting Link-Local Multicast Messages\n   The network administrator\
    \ defines an SA and SPI that are to be used\n   to authenticate all link-local\
    \ PIM protocol messages (Hello,\n   Join/Prune, and Assert) on each link in a\
    \ PIM domain.\n   IPsec [8] allows (but does not require) different Security Policy\n\
    \   Databases (SPD) for each router interface.  If available, it may be\n   desirable\
    \ to configure the Security Policy Database at a PIM router\n   such that all\
    \ incoming and outgoing Join/Prune, Assert, and Hello\n   packets use a different\
    \ SA for each incoming or outgoing interface.\n"
- title: 6.3.2.  Protecting Unicast Messages
  contents:
  - "6.3.2.  Protecting Unicast Messages\n   IPsec can also be used to provide data\
    \ origin authentication and data\n   integrity protection for the Register and\
    \ Register-Stop unicast\n   messages.\n"
- title: 6.3.2.1.  Register Messages
  contents:
  - "6.3.2.1.  Register Messages\n   The Security Policy Database at every PIM router\
    \ is configured to\n   select an SA to use when sending PIM Register packets to\
    \ each\n   rendezvous point.\n   In the most general mode of operation, the Security\
    \ Policy Database\n   at each DR is configured to select a unique SA and SPI for\
    \ traffic\n   sent to each RP.  This allows each DR to have a different\n   authentication\
    \ algorithm and key to talk to the RP.  However, this\n   creates a daunting key\
    \ management and distribution problem for the\n   network administrator.  Therefore,\
    \ it may be preferable in PIM\n   domains where all Designated Routers are under\
    \ a single\n   administrative control that the same authentication algorithm\n\
    \   parameters (including the key) be used for all Registered packets in\n   a\
    \ domain, regardless of who are the RP and the DR.\n   In this \"single shared\
    \ key\" mode of operation, the network\n   administrator must choose an SPI for\
    \ each DR that will be used to\n   send it PIM protocol packets.  The Security\
    \ Policy Database at every\n   DR is configured to select an SA (including the\
    \ authentication\n   algorithm, authentication parameters, and this SPI) when\
    \ sending\n   Register messages to this RP.\n   By using a single authentication\
    \ algorithm and associated parameters,\n   the key distribution problem is simplified.\
    \  Note, however, that this\n   method has the property that, in order to change\
    \ the authentication\n   method or authentication key used, all routers in the\
    \ domain must be\n   updated.\n"
- title: 6.3.2.2.  Register-Stop Messages
  contents:
  - "6.3.2.2.  Register-Stop Messages\n   Similarly, the Security Policy Database\
    \ at each Rendezvous Point\n   should be configured to choose an SA to use when\
    \ sending Register-\n   Stop messages.  Because Register-Stop messages are unicast\
    \ to the\n   destination DR, a different SA and a potentially unique SPI are\n\
    \   required for each DR.\n   In order to simplify the management problem, it\
    \ may be acceptable to\n   use the same authentication algorithm and authentication\
    \ parameters,\n   regardless of the sending RP and regardless of the destination\
    \ DR.\n   Although a unique SA is needed for each DR, the same authentication\n\
    \   algorithm and authentication algorithm parameters (secret key) can be\n  \
    \ shared by all DRs and by all RPs.\n"
- title: 6.4.  Denial-of-Service Attacks
  contents:
  - "6.4.  Denial-of-Service Attacks\n   There are a number of possible denial-of-service\
    \ attacks against PIM\n   that can be caused by generating false PIM protocol\
    \ messages or even\n   by generating data false traffic.  Authenticating PIM protocol\n\
    \   traffic prevents some, but not all, of these attacks.  Three of the\n   possible\
    \ attacks include:\n   -  Sending packets to many different group addresses quickly\
    \ can be a\n      denial-of-service attack in and of itself.  This will cause\
    \ many\n      register-encapsulated packets, loading the DR, the RP, and the\n\
    \      routers between the DR and the RP.\n   -  Forging Join messages can cause\
    \ a multicast tree to get set up.  A\n      large number of forged joins can consume\
    \ router resources and\n      result in denial of service.\n   -  Forging a (*,*,RP)\
    \ join presents a possibility for a denial-of-\n      service attack by causing\
    \ all traffic in the domain to flow to the\n      PMBR issuing the join.  (*,*,RP)\
    \ behavior is included here\n      primarily for backwards compatibility with\
    \ prior revisions of the\n      spec.  However, the implementation of (*,*,RP)\
    \ and PMBR is\n      optional.  When using (*,*,RP), the security concerns should\
    \ be\n      carefully considered.\n"
- title: 7.  Acknowledgements
  contents:
  - "7.  Acknowledgements\n   PIM-SM was designed over many years by a large group\
    \ of people,\n   including ideas, comments, and corrections from Deborah Estrin,\
    \ Dino\n   Farinacci, Ahmed Helmy, David Thaler, Steve Deering, Van Jacobson,\
    \ C.\n   Liu, Puneet Sharma, Liming Wei, Tom Pusateri, Tony Ballardie, Scott\n\
    \   Brim, Jon Crowcroft, Paul Francis, Joel Halpern, Horst Hodel, Polly\n   Huang,\
    \ Stephen Ostrowski, Lixia Zhang, Girish Chandranmenon, Brian\n   Haberman, Hal\
    \ Sandick, Mike Mroz, Garry Kump, Pavlin Radoslavov, Mike\n   Davison, James Huang,\
    \ Christopher Thomas Brown, and James Lingard.\n   Thanks are due to the American\
    \ Licorice Company, for its obscure but\n   possibly essential role in the creation\
    \ of this document.\n"
- title: 8.  Normative References
  contents:
  - "8.  Normative References\n   [1]  Bradner, S., \"Key words for use in RFCs to\
    \ Indicate Requirement\n        Levels\", BCP 14, RFC 2119, March 1997.\n   [2]\
    \  Cain, B., Deering, S., Kouvelas, I., Fenner, B., and A.\n        Thyagarajan,\
    \ \"Internet Group Management Protocol, Version 3\",\n        RFC 3376, October\
    \ 2002.\n   [3]  Deering, S., \"Host extensions for IP multicasting\", STD 5,\
    \ RFC\n        1112, August 1989.\n   [4]  Deering, S., Fenner, W., and B. Haberman,\
    \ \"Multicast Listener\n        Discovery (MLD) for IPv6\", RFC 2710, October\
    \ 1999.\n   [5]  Deering, S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6)\n\
    \        Specification\", RFC 2460, December 1998.\n   [6]  Holbrook, H. and B.\
    \ Cain, \"Source-Specific Multicast for IP\",\n        RFC 4507, August 2006.\n\
    \   [7]  IANA, \"Address Family Numbers\",\n        <http://www.iana.org/assignments/address-family-numbers>.\n\
    \   [8]  Kent, S. and K. Seo, \"Security Architecture for the Internet\n     \
    \   Protocol\", RFC 4301, December 2005.\n   [9]  Narten, T. and H. Alvestrand,\
    \ \"Guidelines for Writing an IANA\n        Considerations Section in RFCs\",\
    \ BCP 26, RFC 2434, October 1998.\n"
- title: 9.  Informative References
  contents:
  - "9.  Informative References\n   [10] Bates, T., Rekhter, Y., Chandra, R., and\
    \ D. Katz, \"Multiprotocol\n        Extensions for BGP-4\", RFC 2858, June 2000.\n\
    \   [11] Bhaskar, N., Gall, A., Lingard, J., and S. Venaas, \"Bootstrap\n    \
    \    Router (BSR) Mechanism for PIM Sparse Mode\", Work in Progress,\n       \
    \ May 2006.\n   [12] Black, D., \"Differentiated Services and Tunnels\", RFC 2983,\n\
    \        October 2000.\n   [13] Handley, M., Kouvelas, I., Speakman, T., and L.\
    \ Vicisano, \"Bi-\n        directional Protocol Independent Multicast\", Work\
    \ in Progress,\n        October 2005.\n   [14] Kaufman, C., \"Internet Key Exchange\
    \ (IKEv2) Protocol\", RFC 4306,\n        December 2005.\n   [15] Savola, P., Lehtonen,\
    \ R., and D. Meyer, \"Protocol Independent\n        Multicast - Sparse Mode (PIM-SM)\
    \ Multicast Routing Security\n        Issues and Enhancements\", RFC 4609, August\
    \ 2006.\n   [16] Savola, P. and J. Lingard, \"Last-hop Threats to Protocol\n \
    \       Independent Multicast (PIM)\", Work in Progress, January 2005.\n   [17]\
    \ Savola, P. and B. Haberman, \"Embedding the Rendezvous Point (RP)\n        Address\
    \ in an IPv6 Multicast Address\", RFC 3956, November 2004.\n   [18] Thaler, D.,\
    \ \"Interoperability Rules for Multicast Routing\n        Protocols\", RFC 2715,\
    \ October 1999.\n"
- title: Appendix A.  PIM Multicast Border Router Behavior
  contents:
  - "Appendix A.  PIM Multicast Border Router Behavior\n   In some cases, PIM-SM domains\
    \ will interconnect with non-PIM\n   multicast domains.  In these cases, the border\
    \ routers of the PIM\n   domain speak PIM-SM on some interfaces and speak other\
    \ multicast\n   routing protocols on other interfaces.  Such routers are termed\
    \ PIM\n   Multicast Border Routers (PMBRs).  In general, RFC 2715 [18] provides\n\
    \   rules for interoperability between different multicast routing\n   protocols.\
    \  In this appendix, we specify how PMBRs differ from\n   regular PIM-SM routers.\n\
    \   From the point of view of PIM-SM, a PMBR has two tasks:\n   o To ensure that\
    \ traffic from sources outside the PIM-SM domain\n     reaches receivers inside\
    \ the domain.\n   o To ensure that traffic from sources inside the PIM-SM domain\n\
    \     reaches receivers outside the domain.\n   We note that multiple PIM-SM domains\
    \ are sometimes connected together\n   using protocols such as Multicast Source\
    \ Discovery Protocol (MSDP),\n   which provides information about active external\
    \ sources, but does\n   not follow RFC 2715.  In such cases, the domains are not\
    \ connected\n   via PMBRs because Join(S,G) messages traverse the border between\n\
    \   domains.  A PMBR is required when no PIM messages can traverse the\n   border.\n"
- title: A.1.  Sources External to the PIM-SM Domain
  contents:
  - "A.1.  Sources External to the PIM-SM Domain\n   A PMBR needs to ensure that traffic\
    \ from multicast sources external\n   to the PIM-SM domain reaches receivers inside\
    \ the domain.  The PMBR\n   will follow the rules in RFC 2715, such that traffic\
    \ from external\n   sources reaches the PMBR itself.\n   According to RFC 2715,\
    \ the PIM-SM component of the PMBR will receive\n   an (S,G) Creation event when\
    \ data from an (S,G) data packet from an\n   external source first reaches the\
    \ PMBR.  If RPF_interface(S) is an\n   interface in the PIM-SM domain, the packet\
    \ cannot be originated into\n   the PIM domain at this router, and the PIM-SM\
    \ component of the PMBR\n   will not process the packet.  Otherwise, the PMBR\
    \ will then act\n   exactly as if it were the DR for this source (see Section\
    \ 4.4.1),\n   with the following modifications:\n   o The Border-bit is set in\
    \ all PIM Register messages sent for these\n     sources.\n   o DirectlyConnected(S)\
    \ is treated as being TRUE for these sources.\n   o The PIM-SM forwarding rule\
    \ \"iif == RPF_interface(S)\" is relaxed to\n     be TRUE if iif is any interface\
    \ that is not part of the PIM-SM\n     component of the PMBR (see Section 4.2).\n"
- title: A.2.  Sources Internal to the PIM-SM Domain
  contents:
  - "A.2.  Sources Internal to the PIM-SM Domain\n   A PMBR needs to ensure that traffic\
    \ from sources inside the PIM-SM\n   domain reaches receivers outside the domain.\
    \  Using terminology from\n   RFC 2715, there are two possible scenarios for this:\n\
    \   o Another component of the PMBR is a wildcard receiver.  In this\n     case,\
    \ the PIM-SM component of the PMBR must ensure that traffic\n     from all internal\
    \ sources reaches the PMBR until it is informed\n     otherwise.\n     Note that\
    \ certain profiles of PIM-SM (e.g., PIM-SSM, PIM-SM with\n     Embedded RP) cannot\
    \ interoperate with a neighboring wildcard\n     receiver domain.\n   o No other\
    \ component of the PMBR is a wildcard receiver.  In this\n     case the PMBR will\
    \ receive explicit information as to which groups\n     or (source,group) pairs\
    \ the external domains wish to receive.\n   In the former case, the PMBR will\
    \ need to send a Join(*,*,RP) to all\n   the active RPs in the PIM-SM domain.\
    \  It may also send a Join(*,*,RP)\n   to all the candidate RPs in the PIM-SM\
    \ domain.  This will cause all\n   traffic in the domain to reach the PMBR.  The\
    \ PMBR may then act as if\n   it were a DR with directly connected receivers and\
    \ trigger the\n   transition to a shortest path tree (see Section 4.2.1).\n  \
    \ In the latter case, the PMBR will not need to send Join(*,*,RP)\n   messages.\
    \  However, the PMBR will still need to act as a DR with\n   directly connected\
    \ receivers on behalf of the external receivers in\n   terms of being able to\
    \ switch to the shortest-path tree for\n   internally-reached sources.\n   According\
    \ to RFC 2715, the PIM-SM component of the PMBR may receive a\n   number of alerts\
    \ generated by events in the external routing\n   components.  To implement the\
    \ above behavior, one reasonable way to\n   map these alerts into PIM-SM state\
    \ is as follows:\n   o When a PIM-SM component receives an (S,G) Prune alert,\
    \ it sets\n     local_receiver_include(S,G,I) to FALSE for the discard interface.\n\
    \   o When a PIM-SM component receives a (*,G) Prune alert, it sets\n     local_receiver_include(*,G,I)\
    \ to FALSE for the discard interface.\n   o When a PIM-SM component receives an\
    \ (S,G) Join alert, it sets\n     local_receiver_include(S,G,I) to TRUE for the\
    \ discard interface.\n   o When a PIM-SM component receives a (*,G) Join alert,\
    \ it sets\n     local_receiver_include(*,G,I) to TRUE for the discard interface.\n\
    \   o When a PIM-SM component receives a (*,*) Join alert, it sets\n     DownstreamJPState(*,*,RP,I)\
    \ to Join state on the discard interface\n     for all RPs in the PIM-SM domain.\n\
    \   o When a PIM-SM component receives a (*,*) Prune alert, it sets\n     DownstreamJPState(*,*,RP,I)\
    \ to NoInfo state on the discard\n     interface for all RPs in the PIM-SM domain.\n\
    \   We refer above to the discard interface because the macros and state\n   machines\
    \ are interface specific, but we need to have PIM state that\n   is not associated\
    \ with any actual PIM-SM interface.  Implementers are\n   free to implement this\
    \ in any reasonable manner.\n   Note that these state changes will then cause\
    \ additional PIM-SM state\n   machine transitions in the normal way.\n   These\
    \ rules are, however, not sufficient to allow pruning off the\n   (*,*,RP) tree.\
    \  Some additional rules provide guidance as to one way\n   this may be done:\n\
    \   o If the PMBR has joined on the (*,*,RP) tree, then it should set\n     DownstreamJPState(*,G,I)\
    \ to JOIN on the discard interface for all\n     active groups.\n   o If the router\
    \ receives a (S,G) prune alert, it will need to set\n     DownstreamJPState(S,G,rpt,I)\
    \ to PRUNE on the discard interface.\n   o If the router receives a (*,G) prune\
    \ alert, it will need to set\n     DownstreamJPState(S,G,rpt,I) to PRUNE on the\
    \ discard interface for\n     all active sources sending to G.\n   The rationale\
    \ for this is that there is no way in PIM-SM to prune\n   traffic off the (*,*,RP)\
    \ tree, except by Joining the (*,G) tree and\n   then pruning each source individually.\n"
- title: Appendix B.  Index
  contents:
  - "Appendix B.  Index\n   Address_List. . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  31\n   Assert(*,G) . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . .27,128\n   Assert(S,G) . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . .27,128\n   AssertCancel(*,G) . . . . . . . . . . . . . . . . . . . . .\
    \ . . 97,99\n   AssertCancel(S,G) . . . . . . . . . . . . . . . . . . . . . .80,90,99\n\
    \   AssertTimer(*,G,I). . . . . . . . . . . . . . . . . . . .16,24,91,132\n  \
    \ AssertTimer(S,G,I). . . . . . . . . . . . . . . . . . . .18,24,84,132\n   AssertTrackingDesired(*,G,I).\
    \ . . . . . . . . . . . . . . . .93,94,96\n   AssertTrackingDesired(S,G,I). .\
    \ . . . . . . . . . . . . . 85,86,87,89\n   AssertWinner(*,G,I) . . . . . . .\
    \ . . . . . . . . .16,22,24,93,97,100\n   AssertWinner(S,G,I) . . . . . . . .\
    \ . . . . . .18,22,24,86,90,100,100\n   AssertWinnerMetric(*,G,I) . . . . . .\
    \ . . . . . . . . . . . 16,97,101\n   AssertWinnerMetric(S,G,I) . . . . . . .\
    \ . . . . . . . . . . 18,90,101\n   assert_metric . . . . . . . . . . . . . .\
    \ . . . . . . . . . . . .  98\n   Assert_Override_Interval. . . . . . . . . .\
    \ . . . . . . . . 90,97,132\n   Assert_Time . . . . . . . . . . . . . . . . .\
    \ . . . . . . . 90,97,132\n   AT(*,G,I) . . . . . . . . . . . . . . . . . . .\
    \ . . .16,24,91,129,132\n   AT(S,G,I) . . . . . . . . . . . . . . . . . . . .\
    \ . .18,24,84,129,132\n   CheckSwitchToSpt(S,G) . . . . . . . . . . . . . . .\
    \ . . . . . . 27,28\n   CouldAssert(*,G,I). . . . . . . . . . . . . . . . . .\
    \ .92,93,94,95,98\n   CouldAssert(S,G,I). . . . . . . . . . . . . . . . . 84,86,87,88,89,98\n\
    \   CouldRegister(S,G). . . . . . . . . . . . . . . . . . . . . . . 39,41\n  \
    \ Default_Hello_Holdtime. . . . . . . . . . . . . . . . . . . . . .  33\n   DirectlyConnected(S).\
    \ . . . . . . . . . . . . . . . . 27,27,29,41,143\n   DownstreamJPState(*,*,RP,I)\
    \ . . . . . . . . . . . . . . . . . .23,145\n   DownstreamJPState(*,G,I). . .\
    \ . . . . . . . . . . . . . . . . . .  23\n   DownstreamJPState(S,G,I). . . .\
    \ . . . . . . . . . . . . . . . . 23,40\n   DownstreamJPState(S,G,rpt,I). . .\
    \ . . . . . . . . . . . . . . . .  23\n   DR(I) . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . . . . . .  33\n   dr_is_better(a,b,I) . . . . . . . . .\
    \ . . . . . . . . . . . . . 33,33\n   DR_Priority . . . . . . . . . . . . . .\
    \ . . . . . . . . . . .31,32,33\n   Effective_Override_Interval(I). . . . . .\
    \ . . . . . . . . .36,114,132\n   Effective_Propagation_Delay(I). . . . . . .\
    \ . . . . . . . . . .35,132\n   ET(*,*,RP,I). . . . . . . . . . . . . . . . .\
    \ . . . . . 15,46,128,131\n   ET(*,G,I) . . . . . . . . . . . . . . . . . . .\
    \ . . . . 16,50,128,131\n   ET(S,G,I) . . . . . . . . . . . . . . . . . . . .\
    \ . . . 18,53,129,131\n   ET(S,G,rpt,I) . . . . . . . . . . . . . . . . . . .\
    \ .20,57,59,129,131\n   GenID . . . . . . . . . . . . . . . . . 15,17,19,31,64,68,70,73,85,93\n\
    \   Hash_Function . . . . . . . . . . . . . . . . . . . . . . . . .12,105\n  \
    \ Hello_Holdtime. . . . . . . . . . . . . . . . . . . . . . . . .33,131\n   Hello_Period.\
    \ . . . . . . . . . . . . . . . . . . . . . . . . .31,130\n   HT(I) . . . . .\
    \ . . . . . . . . . . . . . . . . . . . . . . . .31,130\n   IGMP. . . . . . .\
    \ . . . . . . . . . . . . . . . . . 6,8,17,23,101,105\n   immediate_olist(*,*,RP)\
    \ . . . . . . . . . . . . . . . . . . . . 22,64\n   immediate_olist(*,G). . .\
    \ . . . . . . . . . . . . . . . . . . . 22,68\n   immediate_olist(S,G). . . .\
    \ . . . . . . . . . . . . . . . . .22,40,73\n   infinite_assert_metric(). . .\
    \ . . . . . . . . . . . . . . . . . .  99\n   inherited_olist(S,G). . . . . .\
    \ . . . . . . . . 22,27,40,43,73,86,108\n   inherited_olist(S,G,rpt). . . . .\
    \ . . . . . . . . . 22,27,29,76,79,81\n   I_Am_Assert_Loser(*,G,I). . . . . .\
    \ . . . . . . . . . . . . . . .  24\n   I_Am_Assert_Loser(S,G,I). . . . . . .\
    \ . . . . . . . . . . . . . .  24\n   I_am_DR(I). . . . . . . . . . . . . . .\
    \ . . . . . . . .22,33,41,86,93\n   I_am_RP(G). . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . . 43,44\n   J/P_Holdtime. . . . . . . . . . . . .47,51,55,59,65,69,74,121,131,133\n\
    \   J/P_Override_Interval(I). . . . . . . . . . . . . 48,51,55,59,121,132\n  \
    \ JoinDesired(*,*,RP) . . . . . . . . . . . . . . . . . . . . . . 64,79\n   JoinDesired(*,G).\
    \ . . . . . . . . . . . . . . . . . . .17,68,79,86,97\n   JoinDesired(S,G). .\
    \ . . . . . . . . . . . . . . . . 19,29,73,86,88,90\n   joins(*,*,RP(G)). . .\
    \ . . . . . . . . . . . . . . . . . . . . . .  22\n   joins(*,*,RP) . . . . .\
    \ . . . . . . . . . . . . . . . . . 22,23,86,93\n   joins(*,G). . . . . . . .\
    \ . . . . . . . . . . . . . . . . 22,23,86,93\n   joins(S,G). . . . . . . . .\
    \ . . . . . . . . . . . . . . . . .22,23,86\n   JT(*,*,RP). . . . . . . . . .\
    \ . . . . . . . . . . . . . 15,62,129,133\n   JT(*,G) . . . . . . . . . . . .\
    \ . . . . . . . . . . . . 16,67,129,133\n   JT(S,G) . . . . . . . . . . . . .\
    \ . . . . . . . . . . . 18,71,129,133\n   KAT(S,G). . . . . . . . . . . . . .\
    \ .18,26,27,28,41,43,73,108,129,134\n   KeepaliveTimer(S,G) . . . . . . . 18,26,27,27,28,41,43,73,108,129,134\n\
    \   Keepalive_Period. . . . . . . . . . . . . . . . . . . . . . . .27,134\n  \
    \ lan_delay_enabled(I). . . . . . . . . . . . . . . . . . . . . . 35,36\n   LAN_Prune_Delay\
    \ . . . . . . . . . . . . . . . . . . . . . . . . .  31\n   local_receiver_exclude(S,G,I)\
    \ . . . . . . . . . . . . . . . . . .  23\n   local_receiver_include(*,G,I) .\
    \ . . . . . . . . . . . . . . 23,93,144\n   local_receiver_include(S,G,I) . .\
    \ . . . . . . . . . . . . . . . 23,86\n   local_receiver_include(S,G,I).. . .\
    \ . . . . . . . . . . . . . . . 144\n   lost_assert(*,G). . . . . . . . . . .\
    \ . . . . . . . . . . . .22,24,86\n   lost_assert(*,G,I). . . . . . . . . . .\
    \ . . . . . . . . . . 22,24,100\n   lost_assert(S,G). . . . . . . . . . . . .\
    \ . . . . . . . . . . . 22,24\n   lost_assert(S,G,I). . . . . . . . . . . . .\
    \ . . . . . . . . 22,24,100\n   lost_assert(S,G,rpt). . . . . . . . . . . . .\
    \ . . . . . . . . . .  24\n   lost_assert(S,G,rpt,I). . . . . . . . . . . . .\
    \ . . . . . . . .24,100\n   MBGP. . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . . 6,7\n   MFIB. . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . .6,13\n   MLD . . . . . . . . . . . . . . . . . . . . . . . . 6,8,17,23,101,105\n\
    \   MRIB. . . . . . . . . . . . . .6,7,11,15,19,25,62,66,66,75,98,103,128\n  \
    \ MRIB.next_hop(host) . . . . . . . . . . . . . . . . . . . 24,25,62,64\n   my_assert_metric(*,G,I)\
    \ . . . . . . . . . . . . . . . . . . . . .  94\n   my_assert_metric(S,G,I) .\
    \ . . . . . . . . . . . . . . . . 85,89,92,98\n   NBR(Interface,IP_address) .\
    \ . . . . . . . . . . . . . .25,37,62,64,66\n   NLT(N,I). . . . . . . . . . .\
    \ . . . . . . . . . . . . . 14,33,128,131\n   OT(S,G,rpt) . . . . . . . . . .\
    \ . . . . . . . . . . . . 20,77,129,134\n   Override_Interval(I). . . . . . .\
    \ . . . . . . 14,31,34,36,114,130,132\n   packet_arrives_on_rp_tunnel(pkt). .\
    \ . . . . . . . . . . . . . . .  43\n   pim_exclude(S,G). . . . . . . . . . .\
    \ . . . . . . . . . . 22,22,28,86\n   pim_include(*,G). . . . . . . . . . . .\
    \ . . . . . . 17,22,22,28,86,93\n   pim_include(S,G). . . . . . . . . . . . .\
    \ . . . . . . .19,22,22,28,86\n   PPT(*,*,RP,I) . . . . . . . . . . . . . . .\
    \ . . . . . . 15,46,128,132\n   PPT(*,G,I). . . . . . . . . . . . . . . . . .\
    \ . . . . . 16,50,129,132\n   PPT(S,G,I). . . . . . . . . . . . . . . . . . .\
    \ . . . . 18,53,129,132\n   PPT(S,G,rpt,I). . . . . . . . . . . . . . . . . .\
    \ . .20,57,59,129,132\n   Propagation_Delay(I). . . . . . . . . . . . . . . .\
    \ . . 31,35,130,132\n   Propagation_delay_default . . . . . . . . . . . . . .\
    \ . . . . .35,130\n   PruneDesired(S,G,rpt) . . . . . . . . . . . . . . . . .\
    \ . 79,80,88,90\n   prunes(S,G,rpt) . . . . . . . . . . . . . . . . . . . . .\
    \ . .22,23,86\n   Register-Stop(*,G). . . . . . . . . . . . . . . . . . . . .\
    \ . . .  42\n   Register-Stop(S,G). . . . . . . . . . . . . . . . . . . . . .\
    \ . .  43\n   Register-StopTimer(S,G) . . . . . . . . . . . . . . . . 38,39,129,135\n\
    \   Register_Probe_Time . . . . . . . . . . . . . . . . . . . . 39,44,135\n  \
    \ Register_Suppression_Time . . . . . . . . . . . . . . . . . 39,44,135\n   RP(G)\
    \ . . . . . . . . . . . . 5,22,24,40,43,49,68,77,86,93,99,102,128\n   RPF . .\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   6\n   RPF'(*,G)\
    \ . . . . . . . . . . . . . . . . 24,29,67,68,70,76,79,97,101\n   RPF'(S,G) .\
    \ . . . . . . . . . . . . . . . . . . 25,29,71,76,79,90,101\n   RPF'(S,G,rpt)\
    \ . . . . . . . . . . . . . . . . . . . . . .24,76,79,102\n   RPF_interface .\
    \ . . . . . . . . . . . . . . . . . . . . . . . . .  93\n   RPF_interface(host)\
    \ . . . . . .24,27,29,41,68,69,74,86,93,100,108,143\n   RPTJoinDesired(G) . .\
    \ . . . . . . . . . . . . . . . . . . . .79,81,93\n   rpt_assert_metric(G,I).\
    \ . . . . . . . . . . . . . . . . . . .96,97,99\n   RST(S,G). . . . . . . . .\
    \ . . . . . . . . . . . . . . . 38,39,129,135\n   SPTbit(S,G) . . . . . . . 19,27,29,43,53,74,76,79,86,86,89,90,100,108\n\
    \   spt_assert_metric(S,I). . . . . . . . . . . . . . . . . . . 90,98,100\n  \
    \ SSM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .10,106\n   Suppression_Enabled(I).\
    \ . . . . . . . . . . . . . . . . . . . .36,133\n   SwitchToSptDesired(S,G) .\
    \ . . . . . . . . . . . . . . . . . .28,28,43\n   TIB . . . . . . . . . . . .\
    \ . . . . . . . . . . . . . . . . . 6,13,26\n   Triggered_Hello_Delay . . . .\
    \ . . . . . . . . . . . . . . . 31,32,130\n   t_joinsuppress. . . . . . . . .\
    \ . . . . . . . . . . . .64,65,68,69,74\n   t_override. . . . . . . . . . . .\
    \ . . . . . . . . 64,68,73,78,133,134\n   t_override_default. . . . . . . . .\
    \ . . . . . . . . . . . . . .36,130\n   t_periodic. . . . . . . . . . . . . .\
    \ . . . . . . . . . .64,68,73,133\n   t_suppressed. . . . . . . . . . . . . .\
    \ . . . . . .36,65,69,73,74,133\n   Update_SPTbit(S,G,iif). . . . . . . . . .\
    \ . . . . . . . . . . . 27,29\n   UpstreamJPState(S,G). . . . . . . . . . . .\
    \ . . . . . . . . . .27,108\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Bill Fenner\n   AT&T Labs - Research\n   1 River Oaks\
    \ Place\n   San Jose, CA 95134\n   EMail: fenner@research.att.com\n   Mark Handley\n\
    \   Department of Computer Science\n   University College London\n   Gower Street\n\
    \   London WC1E 6BT\n   United Kingdom\n   EMail: M.Handley@cs.ucl.ac.uk\n   Hugh\
    \ Holbrook\n   Arastra, Inc.\n   P.O. Box 10905\n   Palo Alto, CA 94303\n   EMail:\
    \ holbrook@arastra.com\n   Isidor Kouvelas\n   Cisco Systems\n   170 W. Tasman\
    \ Drive\n   San Jose, CA 95134\n   EMail: kouvelas@cisco.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2006).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is provided by the IETF\n\
    \   Administrative Support Activity (IASA).\n"
