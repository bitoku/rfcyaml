- title: __initial_text__
  contents:
  - "                   TCP Friendly Rate Control (TFRC):\n                      \
    \   Protocol Specification\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2003).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document specifies TCP-Friendly Rate Control (TFRC).  TFRC\
    \ is a\n   congestion control mechanism for unicast flows operating in a best-\n\
    \   effort Internet environment.  It is reasonably fair when competing\n   for\
    \ bandwidth with TCP flows, but has a much lower variation of\n   throughput over\
    \ time compared with TCP, making it more suitable for\n   applications such as\
    \ telephony or streaming media where a relatively\n   smooth sending rate is of\
    \ importance.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction. . . . . . . . . . . . . . . . . . . .\
    \ . .  2\n   2.  Terminology . . . . . . . . . . . . . . . . . . . . . .  3\n\
    \   3.  Protocol Mechanism. . . . . . . . . . . . . . . . . . .  3\n       3.1.\
    \ TCP Throughput Equation. . . . . . . . . . . . . .  4\n       3.2. Packet Contents.\
    \ . . . . . . . . . . . . . . . . .  6\n            3.2.1. Data Packets. . . .\
    \ . . . . . . . . . . . .  6\n            3.2.2. Feedback Packets. . . . . . .\
    \ . . . . . . .  7\n   4.  Data Sender Protocol. . . . . . . . . . . . . . . .\
    \ . .  7\n       4.1. Measuring the Packet Size. . . . . . . . . . . . .  8\n\
    \       4.2. Sender Initialization. . . . . . . . . . . . . . .  8\n       4.3.\
    \ Sender behavior when a feedback packet is\n            received. . . . . . .\
    \ . . . . . . .. . . . . . . .  8\n       4.4. Expiration of nofeedback timer\
    \ . . . . . . . . . .  9\n       4.5. Preventing Oscillations. . . . . . . . .\
    \ . . . . . 10\n       4.6. Scheduling of Packet Transmissions . . . . . . . .\
    \ 11\n   5.  Calculation of the Loss Event Rate (p). . . . . . . . . 12\n    \
    \   5.1. Detection of Lost or Marked Packets. . . . . . . . 12\n       5.2. Translation\
    \ from Loss History to Loss Events . . . 13\n       5.3. Inter-loss Event Interval.\
    \ . . . . . . . . . . . . 14\n       5.4. Average Loss Interval. . . . . . . .\
    \ . . . . . . . 14\n       5.5. History Discounting. . . . . . . . . . . . . .\
    \ . . 15\n   6.  Data Receiver Protocol. . . . . . . . . . . . . . . . . 17\n\
    \       6.1. Receiver behavior when a data packet is\n            received . .\
    \ . . . . . . . . . . . . . . . . . . . 18\n       6.2. Expiration of feedback\
    \ timer . . . . . . . . . . . 18\n       6.3. Receiver initialization. . . . .\
    \ . . . . . . . . . 19\n            6.3.1. Initializing the Loss History after\
    \ the\n                   First Loss Event . . . . . . . . . .  . . . 19\n   7.\
    \  Sender-based Variants . . . . . . . . . . . . . . . . . 20\n   8.  Implementation\
    \ Issues . . . . . . . . . . . . . . . . . 20\n   9.  Security Considerations\
    \ . . . . . . . . . . . . . . . . 21\n   10. IANA Considerations . . . . . . .\
    \ . . . . . . . . . . . 22\n   11. Acknowledgments . . . . . . . . . . . . . .\
    \ . . . . . . 22\n   12. Non-Normative References. . . . . . . . . . . . . . .\
    \ . 22\n   13. Authors' Addresses. . . . . . . . . . . . . . . . . . . 23\n  \
    \ 14. Full Copyright Statement. . . . . . . . . . . . . . . . 24\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document specifies TCP-Friendly Rate Control (TFRC).\
    \  TFRC is a\n   congestion control mechanism designed for unicast flows operating\
    \ in\n   an Internet environment and competing with TCP traffic [2].  Instead\n\
    \   of specifying a complete protocol, this document simply specifies a\n   congestion\
    \ control mechanism that could be used in a transport\n   protocol such as RTP\
    \ [7], in an application incorporating end-to-end\n   congestion control at the\
    \ application level, or in the context of\n   endpoint congestion management [1].\
    \  This document does not discuss\n   packet formats or reliability.  Implementation-related\
    \ issues are\n   discussed only briefly, in Section 8.\n   TFRC is designed to\
    \ be reasonably fair when competing for bandwidth\n   with TCP flows, where a\
    \ flow is \"reasonably fair\" if its sending rate\n   is generally within a factor\
    \ of two of the sending rate of a TCP flow\n   under the same conditions.  However,\
    \ TFRC has a much lower variation\n   of throughput over time compared with TCP,\
    \ which makes it more\n   suitable for applications such as telephony or streaming\
    \ media where\n   a relatively smooth sending rate is of importance.\n   The penalty\
    \ of having smoother throughput than TCP while competing\n   fairly for bandwidth\
    \ is that TFRC responds slower than TCP to changes\n   in available bandwidth.\
    \  Thus TFRC should only be used when the\n   application has a requirement for\
    \ smooth throughput, in particular,\n   avoiding TCP's halving of the sending\
    \ rate in response to a single\n   packet drop.  For applications that simply\
    \ need to transfer as much\n   data as possible in as short a time as possible\
    \ we recommend using\n   TCP, or if reliability is not required, using an Additive-Increase,\n\
    \   Multiplicative-Decrease (AIMD) congestion control scheme with similar\n  \
    \ parameters to those used by TCP.\n   TFRC is designed for applications that\
    \ use a fixed packet size, and\n   vary their sending rate in packets per second\
    \ in response to\n   congestion.  Some audio applications require a fixed interval\
    \ of time\n   between packets and vary their packet size instead of their packet\n\
    \   rate in response to congestion.  The congestion control mechanism in\n   this\
    \ document cannot be used by those applications; TFRC-PS (for\n   TFRC-PacketSize)\
    \ is a variant of TFRC for applications that have a\n   fixed sending rate but\
    \ vary their packet size in response to\n   congestion.  TFRC-PS will be specified\
    \ in a later document.\n   TFRC is a receiver-based mechanism, with the calculation\
    \ of the\n   congestion control information (i.e., the loss event rate) in the\n\
    \   data receiver rather in the data sender.  This is well-suited to an\n   application\
    \ where the sender is a large server handling many\n   concurrent connections,\
    \ and the receiver has more memory and CPU\n   cycles available for computation.\
    \  In addition, a receiver-based\n   mechanism is more suitable as a building\
    \ block for multicast\n   congestion control.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   In this document, the key words \"MUST\", \"MUST NOT\", \"\
    REQUIRED\",\n   \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\",\n   and \"OPTIONAL\" are to be interpreted as described in BCP 14,\
    \ RFC 2119\n   and indicate requirement levels for compliant TFRC implementations.\n"
- title: 3.  Protocol Mechanism
  contents:
  - "3.  Protocol Mechanism\n   For its congestion control mechanism, TFRC directly\
    \ uses a throughput\n   equation for the allowed sending rate as a function of\
    \ the loss event\n   rate and round-trip time.  In order to compete fairly with\
    \ TCP, TFRC\n   uses the TCP throughput equation, which roughly describes TCP's\n\
    \   sending rate as a function of the loss event rate, round-trip time,\n   and\
    \ packet size.  We define a loss event as one or more lost or\n   marked packets\
    \ from a window of data, where a marked packet refers to\n   a congestion indication\
    \ from Explicit Congestion Notification (ECN)\n   [6].\n   Generally speaking,\
    \ TFRC's congestion control mechanism works as\n   follows:\n   o  The receiver\
    \ measures the loss event rate and feeds this\n      information back to the sender.\n\
    \   o  The sender also uses these feedback messages to measure the\n      round-trip\
    \ time (RTT).\n   o  The loss event rate and RTT are then fed into TFRC's throughput\n\
    \      equation, giving the acceptable transmit rate.\n   o  The sender then adjusts\
    \ its transmit rate to match the calculated\n      rate.\n   The dynamics of TFRC\
    \ are sensitive to how the measurements are\n   performed and applied.  We recommend\
    \ specific mechanisms below to\n   perform and apply these measurements.  Other\
    \ mechanisms are possible,\n   but it is important to understand how the interactions\
    \ between\n   mechanisms affect the dynamics of TFRC.\n"
- title: 3.1.  TCP Throughput Equation
  contents:
  - "3.1.  TCP Throughput Equation\n   Any realistic equation giving TCP throughput\
    \ as a function of loss\n   event rate and RTT should be suitable for use in TFRC.\
    \  However, we\n   note that the TCP throughput equation used must reflect TCP's\n\
    \   retransmit timeout behavior, as this dominates TCP throughput at\n   higher\
    \ loss rates.  We also note that the assumptions implicit in the\n   throughput\
    \ equation about the loss event rate parameter have to be a\n   reasonable match\
    \ to how the loss rate or loss event rate is actually\n   measured.  While this\
    \ match is not perfect for the throughput\n   equation and loss rate measurement\
    \ mechanisms given below, in\n   practice the assumptions turn out to be close\
    \ enough.\n   The throughput equation we currently recommend for TFRC is a slightly\n\
    \   simplified version of the throughput equation for Reno TCP from [4].\n   Ideally\
    \ we'd prefer a throughput equation based on SACK TCP, but no\n   one has yet\
    \ derived the throughput equation for SACK TCP, and from\n   both simulations\
    \ and experiments, the differences between the two\n   equations are relatively\
    \ minor.\n   The throughput equation is:\n                                   s\n\
    \   X =  ----------------------------------------------------------\n        R*sqrt(2*b*p/3)\
    \ + (t_RTO * (3*sqrt(3*b*p/8) * p * (1+32*p^2)))\n   Where:\n      X is the transmit\
    \ rate in bytes/second.\n      s is the packet size in bytes.\n      R is the\
    \ round trip time in seconds.\n      p is the loss event rate, between 0 and 1.0,\
    \ of the number of loss\n        events as a fraction of the number of packets\
    \ transmitted.\n      t_RTO is the TCP retransmission timeout value in seconds.\n\
    \      b is the number of packets acknowledged by a single TCP\n        acknowledgement.\n\
    \   We further simplify this by setting t_RTO = 4*R.  A more accurate\n   calculation\
    \ of t_RTO is possible, but experiments with the current\n   setting have resulted\
    \ in reasonable fairness with existing TCP\n   implementations [9].  Another possibility\
    \ would be to set t_RTO =\n   max(4R, one second), to match the recommended minimum\
    \ of one second\n   on the RTO [5].\n   Many current TCP connections use delayed\
    \ acknowledgements, sending an\n   acknowledgement for every two data packets\
    \ received, and thus have a\n   sending rate modeled by b = 2.  However, TCP is\
    \ also allowed to send\n   an acknowledgement for every data packet, and this\
    \ would be modeled\n   by b = 1.  Because many TCP implementations do not use\
    \ delayed\n   acknowledgements, we recommend b = 1.\n   In future, different TCP\
    \ equations may be substituted for this\n   equation.  The requirement is that\
    \ the throughput equation be a\n   reasonable approximation of the sending rate\
    \ of TCP for conformant\n   TCP congestion control.\n   The parameters s (packet\
    \ size), p (loss event rate) and R (RTT) need\n   to be measured or calculated\
    \ by a TFRC implementation.  The\n   measurement of s is specified in Section\
    \ 4.1, measurement of R is\n   specified in Section 4.3, and measurement of p\
    \ is specified in\n   Section 5.  In the rest of this document all data rates\
    \ are measured\n   in bytes/second.\n"
- title: 3.2.  Packet Contents
  contents:
  - "3.2.  Packet Contents\n   Before specifying the sender and receiver functionality,\
    \ we describe\n   the contents of the data packets sent by the sender and feedback\n\
    \   packets sent by the receiver.  As TFRC will be used along with a\n   transport\
    \ protocol, we do not specify packet formats, as these depend\n   on the details\
    \ of the transport protocol used.\n"
- title: 3.2.1.  Data Packets
  contents:
  - "3.2.1.  Data Packets\n   Each data packet sent by the data sender contains the\
    \ following\n   information:\n   o  A sequence number.  This number is incremented\
    \ by one for each\n      data packet transmitted.  The field must be sufficiently\
    \ large\n      that it does not wrap causing two different packets with the same\n\
    \      sequence number to be in the receiver's recent packet history at\n    \
    \  the same time.\n   o  A timestamp indicating when the packet is sent.  We denote\
    \ by ts_i\n      the timestamp of the packet with sequence number i.  The\n  \
    \    resolution of the timestamp should typically be measured in\n      milliseconds.\
    \  This timestamp is used by the receiver to determine\n      which losses belong\
    \ to the same loss event.  The timestamp is also\n      echoed by the receiver\
    \ to enable the sender to estimate the\n      round-trip time, for senders that\
    \ do not save timestamps of\n      transmitted data packets.  We note that as\
    \ an alternative to a\n      timestamp incremented in milliseconds, a \"timestamp\"\
    \ that\n      increments every quarter of a round-trip time would be sufficient\n\
    \      for determining when losses belong to the same loss event, in the\n   \
    \   context of a protocol where this is understood by both sender and\n      receiver,\
    \ and where the sender saves the timestamps of transmitted\n      data packets.\n\
    \   o  The sender's current estimate of the round trip time.  The\n      estimate\
    \ reported in packet i is denoted by R_i.  The round-trip\n      time estimate\
    \ is used by the receiver, along with the timestamp,\n      to determine when\
    \ multiple losses belong to the same loss event.\n      If the sender sends a\
    \ coarse-grained \"timestamp\" that increments\n      every quarter of a round-trip\
    \ time, as discussed above, then the\n      sender does not need to send its current\
    \ estimate of the round\n      trip time.\n"
- title: 3.2.2.  Feedback Packets
  contents:
  - "3.2.2.  Feedback Packets\n   Each feedback packet sent by the data receiver contains\
    \ the following\n   information:\n   o  The timestamp of the last data packet\
    \ received.  We denote this by\n      t_recvdata.  If the last packet received\
    \ at the receiver has\n      sequence number i, then t_recvdata = ts_i.  This\
    \ timestamp is used\n      by the sender to estimate the round-trip time, and\
    \ is only needed\n      if the sender does not save timestamps of transmitted\
    \ data\n      packets.\n   o  The amount of time elapsed between the receipt of\
    \ the last data\n      packet at the receiver, and the generation of this feedback\n\
    \      report.  We denote this by t_delay.\n   o  The rate at which the receiver\
    \ estimates that data was received\n      since the last feedback report was sent.\
    \  We denote this by\n      X_recv.\n   o  The receiver's current estimate of\
    \ the loss event rate, p.\n"
- title: 4.  Data Sender Protocol
  contents:
  - "4.  Data Sender Protocol\n   The data sender sends a stream of data packets to\
    \ the data receiver\n   at a controlled rate.  When a feedback packet is received\
    \ from the\n   data receiver, the data sender changes its sending rate, based\
    \ on the\n   information contained in the feedback report.  If the sender does\
    \ not\n   receive a feedback report for two round trip times, it cuts its\n  \
    \ sending rate in half.  This is achieved by means of a timer called\n   the nofeedback\
    \ timer.\n   We specify the sender-side protocol in the following steps:\n   o\
    \  Measurement of the mean packet size being sent.\n   o  The sender behavior\
    \ when a feedback packet is received.\n   o  The sender behavior when the nofeedback\
    \ timer expires.\n   o  Oscillation prevention (optional)\n   o  Scheduling of\
    \ transmission on non-realtime operating systems.\n"
- title: 4.1.  Measuring the Packet Size
  contents:
  - "4.1.  Measuring the Packet Size\n   The parameter s (packet size) is normally\
    \ known to an application.\n   This may not be so in two cases:\n   o  The packet\
    \ size naturally varies depending on the data.  In this\n      case, although\
    \ the packet size varies, that variation is not\n      coupled to the transmit\
    \ rate.  It should normally be safe to use\n      an estimate of the mean packet\
    \ size for s.\n   o  The application needs to change the packet size rather than\
    \ the\n      number of packets per second to perform congestion control.  This\n\
    \      would normally be the case with packet audio applications where a\n   \
    \   fixed interval of time needs to be represented by each packet.\n      Such\
    \ applications need to have a completely different way of\n      measuring parameters.\n\
    \   The second class of applications are discussed separately in a\n   separate\
    \ document on TFRC-PS.  For the remainder of this section we\n   assume the sender\
    \ can estimate the packet size, and that congestion\n   control is performed by\
    \ adjusting the number of packets sent per\n   second.\n"
- title: 4.2.  Sender Initialization
  contents:
  - "4.2.  Sender Initialization\n   To initialize the sender, the value of X is set\
    \ to 1 packet/second\n   and the nofeedback timer is set to expire after 2 seconds.\
    \  The\n   initial values for R (RTT) and t_RTO are undefined until they are set\n\
    \   as described below.  The initial value of tld, for the Time Last\n   Doubled\
    \ during slow-start, is set to -1.\n"
- title: 4.3.  Sender behavior when a feedback packet is received
  contents:
  - "4.3.  Sender behavior when a feedback packet is received\n   The sender knows\
    \ its current sending rate, X, and maintains an\n   estimate of the current round\
    \ trip time, R, and an estimate of the\n   timeout interval, t_RTO.\n   When a\
    \ feedback packet is received by the sender at time t_now, the\n   following actions\
    \ should be performed:\n   1) Calculate a new round trip sample.\n      R_sample\
    \ = (t_now - t_recvdata) - t_delay.\n   2) Update the round trip time estimate:\n\
    \            If no feedback has been received before\n                R = R_sample;\n\
    \            Else\n                R = q*R + (1-q)*R_sample;\n   TFRC is not sensitive\
    \ to the precise value for the filter constant q,\n   but we recommend a default\
    \ value of 0.9.\n   3) Update the timeout interval:\n         t_RTO = 4*R.\n \
    \  4) Update the sending rate as follows:\n         If (p > 0)\n             Calculate\
    \ X_calc using the TCP throughput equation.\n             X = max(min(X_calc,\
    \ 2*X_recv), s/t_mbi);\n         Else\n             If (t_now - tld >= R)\n  \
    \               X = max(min(2*X, 2*X_recv), s/R);\n                 tld = t_now;\n\
    \      Note that if p == 0, then the sender is in slow-start phase, where\n  \
    \    it approximately doubles the sending rate each round-trip time\n      until\
    \ a loss occurs.  The s/R term gives a minimum sending rate\n      during slow-start\
    \ of one packet per RTT.  The parameter t_mbi is\n      64 seconds, and represents\
    \ the maximum inter-packet backoff\n      interval in the persistent absence of\
    \ feedback.  Thus, when p > 0\n      the sender sends at least one packet every\
    \ 64 seconds.\n   5) Reset the nofeedback timer to expire after max(4*R, 2*s/X)\n\
    \      seconds.\n"
- title: 4.4.  Expiration of nofeedback timer
  contents:
  - "4.4.  Expiration of nofeedback timer\n   If the nofeedback timer expires, the\
    \ sender should perform the\n   following actions:\n   1) Cut the sending rate\
    \ in half.  If the sender has received feedback\n      from the receiver, this\
    \ is done by modifying the sender's cached\n      copy of X_recv (the receive\
    \ rate).  Because the sending rate is\n      limited to at most twice X_recv,\
    \ modifying X_recv limits the\n      current sending rate, but allows the sender\
    \ to slow-start,\n      doubling its sending rate each RTT, if feedback messages\
    \ resume\n      reporting no losses.\n         If (X_calc > 2*X_recv)\n      \
    \       X_recv = max(X_recv/2, s/(2*t_mbi));\n         Else\n             X_recv\
    \ = X_calc/4;\n      The term s/(2*t_mbi) limits the backoff to one packet every\
    \ 64\n      seconds in the case of persistent absence of feedback.\n   2) The\
    \ value of X must then be recalculated as described under point\n      (4) above.\n\
    \      If the nofeedback timer expires when the sender does not yet have\n   \
    \   an RTT sample, and has not yet received any feedback from the\n      receiver,\
    \ then step (1) can be skipped, and the sending rate cut\n      in half directly:\n\
    \         X = max(X/2, s/t_mbi)\n   3) Restart the nofeedback timer to expire\
    \ after max(4*R, 2*s/X)\n      seconds.\n   Note that when the sender stops sending,\
    \ the receiver will stop\n   sending feedback.  This will cause the nofeedback\
    \ timer to start to\n   expire and decrease X_recv.  If the sender subsequently\
    \ starts to\n   send again, X_recv will limit the transmit rate, and a normal\n\
    \   slowstart phase will occur until the transmit rate reaches X_calc.\n   If\
    \ the sender has been idle since this nofeedback timer was set and\n   X_recv\
    \ is less than four packets per round-trip time, then X_recv\n   should not be\
    \ halved in response to the timer expiration.  This\n   ensures that the allowed\
    \ sending rate is never reduced to less than\n   two packets per round-trip time\
    \ as a result of an idle period.\n"
- title: 4.5.  Preventing Oscillations
  contents:
  - "4.5.  Preventing Oscillations\n   To prevent oscillatory behavior in environments\
    \ with a low degree of\n   statistical multiplexing it is useful to modify sender's\
    \ transmit\n   rate to provide congestion avoidance behavior by reducing the\n\
    \   transmit rate as the queuing delay (and hence RTT) increases.  To do\n   this\
    \ the sender maintains an estimate of the long-term RTT and\n   modifies its sending\
    \ rate depending on how the most recent sample of\n   the RTT differs from this\
    \ value.  The long-term sample is R_sqmean,\n   and is set as follows:\n     \
    \   If no feedback has been received before\n            R_sqmean = sqrt(R_sample);\n\
    \        Else\n            R_sqmean = q2*R_sqmean + (1-q2)*sqrt(R_sample);\n \
    \  Thus R_sqmean gives the exponentially weighted moving average of the\n   square\
    \ root of the RTT samples.  The constant q2 should be set\n   similarly to q,\
    \ and we recommend a value of 0.9 as the default.\n   The sender obtains the base\
    \ transmit rate, X, from the throughput\n   function.  It then calculates a modified\
    \ instantaneous transmit rate\n   X_inst, as follows:\n        X_inst = X * R_sqmean\
    \ / sqrt(R_sample);\n   When sqrt(R_sample) is greater than R_sqmean then the\
    \ queue is\n   typically increasing and so the transmit rate needs to be decreased\n\
    \   for stable operation.\n   Note: This modification is not always strictly required,\
    \ especially\n   if the degree of statistical multiplexing in the network is high.\n\
    \   However, we recommend that it is done because it does make TFRC\n   behave\
    \ better in environments with a low level of statistical\n   multiplexing.  If\
    \ it is not done, we recommend using a very low value\n   of q, such that q is\
    \ close to or exactly zero.\n"
- title: 4.6.  Scheduling of Packet Transmissions
  contents:
  - "4.6.  Scheduling of Packet Transmissions\n   As TFRC is rate-based, and as operating\
    \ systems typically cannot\n   schedule events precisely, it is necessary to be\
    \ opportunistic about\n   sending data packets so that the correct average rate\
    \ is maintained\n   despite the course-grain or irregular scheduling of the operating\n\
    \   system.  Thus a typical sending loop will calculate the correct\n   inter-packet\
    \ interval, t_ipi, as follows:\n        t_ipi = s/X_inst;\n   When a sender first\
    \ starts sending at time t_0, it calculates t_ipi,\n   and calculates a nominal\
    \ send time t_1 = t_0 + t_ipi for packet 1.\n   When the application becomes idle,\
    \ it checks the current time, t_now,\n   and then requests re-scheduling after\
    \ (t_ipi - (t_now - t_0))\n   seconds.  When the application is re-scheduled,\
    \ it checks the current\n   time, t_now, again.  If (t_now > t_1 - delta) then\
    \ packet 1 is sent.\n   Now a new t_ipi may be calculated, and used to calculate\
    \ a nominal\n   send time t_2 for packet 2: t2 = t_1 + t_ipi.  The process then\n\
    \   repeats, with each successive packet's send time being calculated\n   from\
    \ the nominal send time of the previous packet.\n   In some cases, when the nominal\
    \ send time, t_i, of the next packet is\n   calculated, it may already be the\
    \ case that t_now > t_i - delta.  In\n   such a case the packet should be sent\
    \ immediately.  Thus if the\n   operating system has coarse timer granularity\
    \ and the transmit rate\n   is high, then TFRC may send short bursts of several\
    \ packets separated\n   by intervals of the OS timer granularity.\n   The parameter\
    \ delta is to allow a degree of flexibility in the send\n   time of a packet.\
    \  If the operating system has a scheduling timer\n   granularity of t_gran seconds,\
    \ then delta would typically be set to:\n        delta = min(t_ipi/2, t_gran/2);\n\
    \   t_gran is 10ms on many Unix systems.  If t_gran is not known, a value\n  \
    \ of 10ms can be safely assumed.\n"
- title: 5.  Calculation of the Loss Event Rate (p)
  contents:
  - "5.  Calculation of the Loss Event Rate (p)\n   Obtaining an accurate and stable\
    \ measurement of the loss event rate\n   is of primary importance for TFRC.  Loss\
    \ rate measurement is\n   performed at the receiver, based on the detection of\
    \ lost or marked\n   packets from the sequence numbers of arriving packets.  We\
    \ describe\n   this process before describing the rest of the receiver protocol.\n"
- title: 5.1.  Detection of Lost or Marked Packets
  contents:
  - "5.1.  Detection of Lost or Marked Packets\n   TFRC assumes that all packets contain\
    \ a sequence number that is\n   incremented by one for each packet that is sent.\
    \  For the purposes of\n   this specification, we require that if a lost packet\
    \ is\n   retransmitted, the retransmission is given a new sequence number that\n\
    \   is the latest in the transmission sequence, and not the same sequence\n  \
    \ number as the packet that was lost.  If a transport protocol has the\n   requirement\
    \ that it must retransmit with the original sequence\n   number, then the transport\
    \ protocol designer must figure out how to\n   distinguish delayed from retransmitted\
    \ packets and how to detect lost\n   retransmissions.\n   The receiver maintains\
    \ a data structure that keeps track of which\n   packets have arrived and which\
    \ are missing.  For the purposes of\n   specification, we assume that the data\
    \ structure consists of a list\n   of packets that have arrived along with the\
    \ receiver timestamp when\n   each packet was received.  In practice this data\
    \ structure will\n   normally be stored in a more compact representation, but\
    \ this is\n   implementation-specific.\n   The loss of a packet is detected by\
    \ the arrival of at least three\n   packets with a higher sequence number than\
    \ the lost packet.  The\n   requirement for three subsequent packets is the same\
    \ as with TCP, and\n   is to make TFRC more robust in the presence of reordering.\
    \  In\n   contrast to TCP, if a packet arrives late (after 3 subsequent packets\n\
    \   arrived) in TFRC, the late packet can fill the hole in TFRC's\n   reception\
    \ record, and the receiver can recalculate the loss event\n   rate.  Future versions\
    \ of TFRC might make the requirement for three\n   subsequent packets adaptive\
    \ based on experienced packet reordering,\n   but we do not specify such a mechanism\
    \ here.\n   For an ECN-capable connection, a marked packet is detected as a\n\
    \   congestion event as soon as it arrives, without having to wait for\n   the\
    \ arrival of subsequent packets.\n"
- title: 5.2.  Translation from Loss History to Loss Events
  contents:
  - "5.2.  Translation from Loss History to Loss Events\n   TFRC requires that the\
    \ loss fraction be robust to several consecutive\n   packets lost where those\
    \ packets are part of the same loss event.\n   This is similar to TCP, which (typically)\
    \ only performs one halving\n   of the congestion window during any single RTT.\
    \  Thus the receiver\n   needs to map the packet loss history into a loss event\
    \ record, where\n   a loss event is one or more packets lost in an RTT.  To perform\
    \ this\n   mapping, the receiver needs to know the RTT to use, and this is\n \
    \  supplied periodically by the sender, typically as control information\n   piggy-backed\
    \ onto a data packet.  TFRC is not sensitive to how the\n   RTT measurement sent\
    \ to the receiver is made, but we recommend using\n   the sender's calculated\
    \ RTT, R, (see Section 4.3) for this purpose.\n   To determine whether a lost\
    \ or marked packet should start a new loss\n   event, or be counted as part of\
    \ an existing loss event, we need to\n   compare the sequence numbers and timestamps\
    \ of the packets that\n   arrived at the receiver.  For a marked packet S_new,\
    \ its reception\n   time T_new can be noted directly.  For a lost packet, we can\n\
    \   interpolate to infer the nominal \"arrival time\".  Assume:\n      S_loss\
    \ is the sequence number of a lost packet.\n      S_before is the sequence number\
    \ of the last packet to arrive with\n      sequence number before S_loss.\n  \
    \    S_after is the sequence number of the first packet to arrive with\n     \
    \ sequence number after S_loss.\n      T_before is the reception time of S_before.\n\
    \      T_after is the reception time of S_after.\n   Note that T_before can either\
    \ be before or after T_after due to\n   reordering.\n   For a lost packet S_loss,\
    \ we can interpolate its nominal \"arrival\n   time\" at the receiver from the\
    \ arrival times of S_before and S_after.\n   Thus:\n   T_loss = T_before + ( (T_after\
    \ - T_before)\n               * (S_loss - S_before)/(S_after - S_before) );\n\
    \   Note that if the sequence space wrapped between S_before and S_after,\n  \
    \ then the sequence numbers must be modified to take this into account\n   before\
    \ performing this calculation.  If the largest possible sequence\n   number is\
    \ S_max, and S_before > S_after, then modifying each sequence\n   number S by\
    \ S' = (S + (S_max + 1)/2) mod (S_max + 1) would normally\n   be sufficient.\n\
    \   If the lost packet S_old was determined to have started the previous\n   loss\
    \ event, and we have just determined that S_new has been lost,\n   then we interpolate\
    \ the nominal arrival times of S_old and S_new,\n   called T_old and T_new respectively.\n\
    \   If T_old + R >= T_new, then S_new is part of the existing loss event.\n  \
    \ Otherwise S_new is the first packet in a new loss event.\n"
- title: 5.3.  Inter-loss Event Interval
  contents:
  - "5.3.  Inter-loss Event Interval\n   If a loss interval, A, is determined to have\
    \ started with packet\n   sequence number S_A and the next loss interval, B, started\
    \ with\n   packet sequence number S_B, then the number of packets in loss\n  \
    \ interval A is given by (S_B - S_A).\n"
- title: 5.4.  Average Loss Interval
  contents:
  - "5.4.  Average Loss Interval\n   To calculate the loss event rate p, we first\
    \ calculate the average\n   loss interval.  This is done using a filter that weights\
    \ the n most\n   recent loss event intervals in such a way that the measured loss\n\
    \   event rate changes smoothly.\n   Weights w_0 to w_(n-1) are calculated as:\n\
    \      If (i < n/2)\n         w_i = 1;\n      Else\n         w_i = 1 - (i - (n/2\
    \ - 1))/(n/2 + 1);\n   Thus if n=8, the values of w_0 to w_7 are:\n      1.0,\
    \ 1.0, 1.0, 1.0, 0.8, 0.6, 0.4, 0.2\n   The value n for the number of loss intervals\
    \ used in calculating the\n   loss event rate determines TFRC's speed in responding\
    \ to changes in\n   the level of congestion.  As currently specified, TFRC should\
    \ not be\n   used for values of n significantly greater than 8, for traffic that\n\
    \   might compete in the global Internet with TCP.  At the very least,\n   safe\
    \ operation with values of n greater than 8 would require a slight\n   change\
    \ to TFRC's mechanisms to include a more severe response to two\n   or more round-trip\
    \ times with heavy packet loss.\n   When calculating the average loss interval\
    \ we need to decide whether\n   to include the interval since the most recent\
    \ packet loss event.  We\n   only do this if it is sufficiently large to increase\
    \ the average loss\n   interval.\n   Thus if the most recent loss intervals are\
    \ I_0 to I_n, with I_0 being\n   the interval since the most recent loss event,\
    \ then we calculate the\n   average loss interval I_mean as:\n      I_tot0 = 0;\n\
    \      I_tot1 = 0;\n      W_tot = 0;\n      for (i = 0 to n-1) {\n        I_tot0\
    \ = I_tot0 + (I_i * w_i);\n        W_tot = W_tot + w_i;\n      }\n      for (i\
    \ = 1 to n) {\n        I_tot1 = I_tot1 + (I_i * w_(i-1));\n      }\n      I_tot\
    \ = max(I_tot0, I_tot1);\n      I_mean = I_tot/W_tot;\n   The loss event rate,\
    \ p is simply:\n      p = 1 / I_mean;\n"
- title: 5.5.  History Discounting
  contents:
  - "5.5.  History Discounting\n   As described in Section 5.4, the most recent loss\
    \ interval is only\n   assigned 1/(0.75*n) of the total weight in calculating\
    \ the average\n   loss interval, regardless of the size of the most recent loss\n\
    \   interval.  This section describes an optional history discounting\n   mechanism,\
    \ discussed further in [3] and [9], that allows the TFRC\n   receiver to adjust\
    \ the weights, concentrating more of the relative\n   weight on the most recent\
    \ loss interval, when the most recent loss\n   interval is more than twice as\
    \ large as the computed average loss\n   interval.\n   To carry out history discounting,\
    \ we associate a discount factor DF_i\n   with each loss interval L_i, for i >\
    \ 0, where each discount factor is\n   a floating point number.  The discount\
    \ array maintains the cumulative\n   history of discounting for each loss interval.\
    \  At the beginning, the\n   values of DF_i in the discount array are initialized\
    \ to 1:\n      for (i = 1 to n) {\n        DF_i = 1;\n      }\n   History discounting\
    \ also uses a general discount factor DF, also a\n   floating point number, that\
    \ is also initialized to 1.  First we show\n   how the discount factors are used\
    \ in calculating the average loss\n   interval, and then we describe later in\
    \ this section how the discount\n   factors are modified over time.\n   As described\
    \ in Section 5.4 the average loss interval is calculated\n   using the n previous\
    \ loss intervals I_1, ..., I_n, and the interval\n   I_0 that represents the number\
    \ of packets received since the last\n   loss event.  The computation of the average\
    \ loss interval using the\n   discount factors is a simple modification of the\
    \ procedure in Section\n   5.4, as follows:\n      I_tot0 = I_0 * w_0\n      I_tot1\
    \ = 0;\n      W_tot0 = w_0\n      W_tot1 = 0;\n      for (i = 1 to n-1) {\n  \
    \      I_tot0 = I_tot0 + (I_i * w_i * DF_i * DF);\n        W_tot0 = W_tot0 + w_i\
    \ * DF_i * DF;\n      }\n      for (i = 1 to n) {\n        I_tot1 = I_tot1 + (I_i\
    \ * w_(i-1) * DF_i);\n        W_tot1 = W_tot1 + w_(i-1) * DF_i;\n      }\n   \
    \   p = min(W_tot0/I_tot0, W_tot1/I_tot1);\n   The general discounting factor,\
    \ DF is updated on every packet arrival\n   as follows.  First, the receiver computes\
    \ the weighted average I_mean\n   of the loss intervals I_1, ..., I_n:\n     \
    \ I_tot = 0;\n      W_tot = 0;\n      for (i = 1 to n) {\n        W_tot = W_tot\
    \ + w_(i-1) * DF_i;\n        I_tot = I_tot + (I_i * w_(i-1) * DF_i);\n      }\n\
    \      I_mean = I_tot / W_tot;\n   This weighted average I_mean is compared to\
    \ I_0, the number of\n   packets received since the last loss event.  If I_0 is\
    \ greater than\n   twice I_mean, then the new loss interval is considerably larger\
    \ than\n   the old ones, and the general discount factor DF is updated to\n  \
    \ decrease the relative weight on the older intervals, as follows:\n      if (I_0\
    \ > 2 * I_mean) {\n        DF = 2 * I_mean/I_0;\n        if (DF < THRESHOLD)\n\
    \          DF = THRESHOLD;\n      } else\n        DF = 1;\n   A nonzero value\
    \ for THRESHOLD ensures that older loss intervals from\n   an earlier time of\
    \ high congestion are not discounted entirely.  We\n   recommend a THRESHOLD of\
    \ 0.5.  Note that with each new packet\n   arrival, I_0 will increase further,\
    \ and the discount factor DF will\n   be updated.\n   When a new loss event occurs,\
    \ the current interval shifts from I_0 to\n   I_1, loss interval I_i shifts to\
    \ interval I_(i+1), and the loss\n   interval I_n is forgotten.  The previous\
    \ discount factor DF has to be\n   incorporated into the discount array.  Because\
    \ DF_i carries the\n   discount factor associated with loss interval I_i, the\
    \ DF_i array has\n   to be shifted as well.  This is done as follows:\n      for\
    \ (i = 1 to n) {\n        DF_i = DF * DF_i;\n      }\n      for (i = n-1 to 0\
    \ step -1) {\n        DF_(i+1) = DF_i;\n      }\n      I_0 = 1;\n      DF_0 =\
    \ 1;\n      DF = 1;\n   This completes the description of the optional history\
    \ discounting\n   mechanism.  We emphasize that this is an optional mechanism\
    \ whose\n   sole purpose is to allow TFRC to response somewhat more quickly to\n\
    \   the sudden absence of congestion, as represented by a long current\n   loss\
    \ interval.\n"
- title: 6.  Data Receiver Protocol
  contents:
  - "6.  Data Receiver Protocol\n   The receiver periodically sends feedback messages\
    \ to the sender.\n   Feedback packets should normally be sent at least once per\
    \ RTT,\n   unless the sender is sending at a rate of less than one packet per\n\
    \   RTT, in which case a feedback packet should be send for every data\n   packet\
    \ received.  A feedback packet should also be sent whenever a\n   new loss event\
    \ is detected without waiting for the end of an RTT, and\n   whenever an out-of-order\
    \ data packet is received that removes a loss\n   event from the history.\n  \
    \ If the sender is transmitting at a high rate (many packets per RTT)\n   there\
    \ may be some advantages to sending periodic feedback messages\n   more than once\
    \ per RTT as this allows faster response to changing RTT\n   measurements, and\
    \ more resilience to feedback packet loss.  However,\n   there is little gain\
    \ from sending a large number of feedback messages\n   per RTT.\n"
- title: 6.1.  Receiver behavior when a data packet is received
  contents:
  - "6.1.  Receiver behavior when a data packet is received\n   When a data packet\
    \ is received, the receiver performs the following\n   steps:\n   1) Add the packet\
    \ to the packet history.\n   2) Let the previous value of p be p_prev.  Calculate\
    \ the new value of\n      p as described in Section 5.\n   3) If p > p_prev, cause\
    \ the feedback timer to expire, and perform the\n       actions described in Section\
    \ 6.2\n      If p <= p_prev no action need be performed.\n      However an optimization\
    \ might check to see if the arrival of the\n      packet caused a hole in the\
    \ packet history to be filled and\n      consequently two loss intervals were\
    \ merged into one.  If this is\n      the case, the receiver might also send feedback\
    \ immediately.  The\n      effects of such an optimization are normally expected\
    \ to be small.\n"
- title: 6.2.  Expiration of feedback timer
  contents:
  - "6.2.  Expiration of feedback timer\n   When the feedback timer at the receiver\
    \ expires, the action to be\n   taken depends on whether data packets have been\
    \ received since the\n   last feedback was sent.\n   Let the maximum sequence\
    \ number of a packet at the receiver so far be\n   S_m, and the value of the RTT\
    \ measurement included in packet S_m be\n   R_m.  If data packets have been received\
    \ since the previous feedback\n   was sent, the receiver performs the following\
    \ steps:\n   1) Calculate the average loss event rate using the algorithm\n  \
    \    described above.\n   2) Calculate the measured receive rate, X_recv, based\
    \ on the packets\n      received within the previous R_m seconds.\n   3) Prepare\
    \ and send a feedback packet containing the information\n      described in Section\
    \ 3.2.2\n   4) Restart the feedback timer to expire after R_m seconds.\n   If\
    \ no data packets have been received since the last feedback was\n   sent, no\
    \ feedback packet is sent, and the feedback timer is restarted\n   to expire after\
    \ R_m seconds.\n"
- title: 6.3.  Receiver initialization
  contents:
  - "6.3.  Receiver initialization\n   The receiver is initialized by the first packet\
    \ that arrives at the\n   receiver. Let the sequence number of this packet be\
    \ i.\n   When the first packet is received:\n      o  Set p=0\n      o  Set  X_recv\
    \ = 0.\n      o  Prepare and send a feedback packet.\n      o  Set the feedback\
    \ timer to expire after R_i seconds.\n"
- title: 6.3.1.  Initializing the Loss History after the First Loss Event
  contents:
  - "6.3.1.  Initializing the Loss History after the First Loss Event\n   The number\
    \ of packets until the first loss can not be used to compute\n   the sending rate\
    \ directly, as the sending rate changes rapidly during\n   this time.  TFRC assumes\
    \ that the correct data rate after the first\n   loss is half of the sending rate\
    \ when the loss occurred.  TFRC\n   approximates this target rate by X_recv, the\
    \ receive rate over the\n   most recent round-trip time.  After the first loss,\
    \ instead of\n   initializing the first loss interval to the number of packets\
    \ sent\n   until the first loss, the TFRC receiver calculates the loss interval\n\
    \   that would be required to produce the data rate X_recv, and uses this\n  \
    \ synthetic loss interval to seed the loss history mechanism.\n   TFRC does this\
    \ by finding some value p for which the throughput\n   equation in Section 3.1\
    \ gives a sending rate within 5% of X_recv,\n   given the current packet size\
    \ s and round-trip time R.  The first\n   loss interval is then set to 1/p.  (The\
    \ 5% tolerance is introduced\n   simply because the throughput equation is difficult\
    \ to invert, and we\n   want to reduce the costs of calculating p numerically.)\n"
- title: 7.  Sender-based Variants
  contents:
  - "7.  Sender-based Variants\n   It would be possible to implement a sender-based\
    \ variant of TFRC,\n   where the receiver uses reliable delivery to send information\
    \ about\n   packet losses to the sender, and the sender computes the packet loss\n\
    \   rate and the acceptable transmit rate.  However, we do not specify\n   the\
    \ details of a sender-based variant in this document.\n   The main advantages\
    \ of a sender-based variant of TFRC would be that\n   the sender would not have\
    \ to trust the receiver's calculation of the\n   packet loss rate.  However, with\
    \ the requirement of reliable delivery\n   of loss information from the receiver\
    \ to the sender, a sender-based\n   TFRC would have much tighter constraints on\
    \ the transport protocol in\n   which it is embedded.\n   In contrast, the receiver-based\
    \ variant of TFRC specified in this\n   document is robust to the loss of feedback\
    \ packets, and therefore\n   does not require the reliable delivery of feedback\
    \ packets.  It is\n   also better suited for applications such as streaming media\
    \ from web\n   servers, where it is typically desirable to offload work from the\n\
    \   server to the client as much as possible.\n   The sender-based and receiver-based\
    \ variants also have different\n   properties in terms of upgrades.  For example,\
    \ for changes in the\n   procedure for calculating the packet loss rate, the sender\
    \ would have\n   to be upgraded in the sender-based variant, and the receiver\
    \ would\n   have to be upgraded in the receiver-based variant.\n"
- title: 8.  Implementation Issues
  contents:
  - "8.  Implementation Issues\n   This document has specified the TFRC congestion\
    \ control mechanism,\n   for use by applications and transport protocols.  This\
    \ section\n   mentions briefly some of the few implementation issues.\n   For\
    \ t_RTO = 4*R and b = 1, the throughput equation in Section 3.1 can\n   be expressed\
    \ as follows:\n              s\n      X =  --------\n           R * f(p)\n   for\n\
    \      f(p) =  sqrt(2*p/3) + (12*sqrt(3*p/8) * p * (1+32*p^2)).\n   A table lookup\
    \ could be used for the function f(p).\n   Many of the multiplications (e.g.,\
    \ q and 1-q for the round-trip time\n   average, a factor of 4 for the timeout\
    \ interval) are or could be by\n   powers of two, and therefore could be implemented\
    \ as simple shift\n   operations.\n   We note that the optional sender mechanism\
    \ for preventing\n   oscillations described in Section 4.5 uses a square-root\
    \ computation.\n   The calculation of the average loss interval in Section 5.4\
    \ involves\n   multiplications by the weights w_0 to w_(n-1), which for n=8 are:\n\
    \      1.0, 1.0, 1.0, 1.0, 0.8, 0.6, 0.4, 0.2.\n   With a minor loss of smoothness,\
    \ it would be possible to use weights\n   that were powers of two or sums of powers\
    \ of two, e.g.,\n      1.0, 1.0, 1.0, 1.0, 0.75, 0.5, 0.25, 0.25.\n   The optional\
    \ history discounting mechanism described in Section 5.5\n   is used in the calculation\
    \ of the average loss rate.  The history\n   discounting mechanism is invoked\
    \ only when there has been an\n   unusually long interval with no packet losses.\
    \  For a more efficient\n   operation, the discount factor DF_i could be restricted\
    \ to be a power\n   of two.\n"
- title: 9.  Security Considerations
  contents:
  - "9.  Security Considerations\n   TFRC is not a transport protocol in its own right,\
    \ but a congestion\n   control mechanism that is intended to be used in conjunction\
    \ with a\n   transport protocol.  Therefore security primarily needs to be\n \
    \  considered in the context of a specific transport protocol and its\n   authentication\
    \ mechanisms.\n   Congestion control mechanisms can potentially be exploited to\
    \ create\n   denial of service.  This may occur through spoofed feedback.  Thus\n\
    \   any transport protocol that uses TFRC should take care to ensure that\n  \
    \ feedback is only accepted from the receiver of the data.  The precise\n   mechanism\
    \ to achieve this will however depend on the transport\n   protocol itself.\n\
    \   In addition, congestion control mechanisms may potentially be\n   manipulated\
    \ by a greedy receiver that wishes to receive more than its\n   fair share of\
    \ network bandwidth.  A receiver might do this by\n   claiming to have received\
    \ packets that in fact were lost due to\n   congestion.  Possible defenses against\
    \ such a receiver would normally\n   include some form of nonce that the receiver\
    \ must feed back to the\n   sender to prove receipt.  However, the details of\
    \ such a nonce would\n   depend on the transport protocol, and in particular on\
    \ whether the\n   transport protocol is reliable or unreliable.\n   We expect\
    \ that protocols incorporating ECN with TFRC will also want\n   to incorporate\
    \ feedback from the receiver to the sender using the ECN\n   nonce [WES02].  The\
    \ ECN nonce is a modification to ECN that protects\n   the sender from the accidental\
    \ or malicious concealment of marked\n   packets.  Again, the details of such\
    \ a nonce would depend on the\n   transport protocol, and are not addressed in\
    \ this document.\n"
- title: 10.  IANA Considerations
  contents:
  - "10.  IANA Considerations\n   There are no IANA actions required for this document.\n"
- title: 11.  Acknowledgments
  contents:
  - "11.  Acknowledgments\n   We would like to acknowledge feedback and discussions\
    \ on equation-\n   based congestion control with a wide range of people, including\n\
    \   members of the Reliable Multicast Research Group, the Reliable\n   Multicast\
    \ Transport Working Group, and the End-to-End Research Group.\n   We would like\
    \ to thank Ken Lofgren, Mike Luby, Eduardo Urzaiz,\n   Vladica Stanisic, Randall\
    \ Stewart, Shushan Wen, and Wendy Lee\n   (lhh@zsu.edu.cn) for feedback on earlier\
    \ versions of this document,\n   and to thank Mark Allman for his extensive feedback\
    \ from using the\n   document to produce a working implementation.\n"
- title: 12.  Informational References
  contents:
  - "12.  Informational References\n   [1] Balakrishnan, H., Rahul, H., and S. Seshan,\
    \ \"An Integrated\n       Congestion Management Architecture for Internet Hosts,\"\
    \ Proc. ACM\n       SIGCOMM, Cambridge, MA, September 1999.\n   [2] Floyd, S.,\
    \ Handley, M., Padhye, J. and J. Widmer, \"Equation-Based\n       Congestion Control\
    \ for Unicast Applications\", August 2000, Proc.\n       ACM SIGCOMM 2000.\n \
    \  [3] Floyd, S., Handley, M., Padhye, J. and J. Widmer, \"Equation-Based\n  \
    \     Congestion Control for Unicast Applications: the Extended\n       Version\"\
    , ICSI tech report TR-00-03, March 2000.\n   [4] Padhye, J., Firoiu, V., Towsley,\
    \ D. and J. Kurose, \"Modeling TCP\n       Throughput: A Simple Model and its\
    \ Empirical Validation\", Proc.\n       ACM SIGCOMM 1998.\n   [5] Paxson V. and\
    \ M. Allman, \"Computing TCP's Retransmission Timer\",\n       RFC 2988, November\
    \ 2000.\n   [6] Ramakrishnan, K., Floyd, S. and D. Black, \"The Addition of\n\
    \       Explicit Congestion Notification (ECN) to IP\", RFC 3168,\n       September\
    \ 2001.\n   [7] Schulzrinne, H., Casner, S., Frederick, R. and V. Jacobson, \"\
    RTP:\n       A Transport Protocol for Real-Time Applications\", RFC 1889,\n  \
    \     January 1996.\n   [8] Wetherall, D., Ely, D., N. Spring, S. Savage, and\
    \ T. Anderson,\n       \"Robust Congestion Signaling\", IEEE International Conference\
    \ on\n       Network Protocols, November 2001.\n   [9] Widmer, J., \"Equation-Based\
    \ Congestion Control\", Diploma Thesis,\n       University of Mannheim, February\
    \ 2000.  URL\n       \"http://www.icir.org/tfrc/\".\n"
- title: 13.  Authors' Addresses
  contents:
  - "13.  Authors' Addresses\n   Mark Handley\n   ICIR/ICSI\n   1947 Center St, Suite\
    \ 600\n   Berkeley, CA 94708\n   EMail: mjh@icir.org\n   Sally Floyd\n   ICIR/ICSI\n\
    \   1947 Center St, Suite 600\n   Berkeley, CA 94708\n   EMail: floyd@icir.org\n\
    \   Jitendra Padhye\n   Microsoft Research\n   EMail: padhye@microsoft.com\n \
    \  Joerg Widmer\n   Lehrstuhl Praktische Informatik IV\n   Universitat Mannheim\n\
    \   L 15, 16 - Room 415\n   D-68131 Mannheim\n   Germany\n   EMail: widmer@informatik.uni-mannheim.de\n"
- title: 14.  Full Copyright Statement
  contents:
  - "14.  Full Copyright Statement\n   Copyright (C) The Internet Society (2003).\
    \  All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
