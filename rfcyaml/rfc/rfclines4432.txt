Abstract This memo describes a key exchange method for the Secure Shell (SSH) protocol based on Rivest Shamir Adleman (RSA) public key encryption.
It uses much less client CPU time than the Diffie Hellman algorithm specified as part of the core protocol, and hence is particularly suitable for slow client systems.
[RFC4251] is a secure remote login protocol.
The core protocol uses Diffie Hellman key exchange.
On slow CPUs, this key exchange can take tens of seconds to complete, which can be irritating for the user.
A previous version of the SSH protocol, described in [SSH1], uses a key exchange method based on Rivest Shamir Adleman (RSA) public key encryption, which consumes an order of magnitude less CPU time on the client, and hence is particularly suitable for slow client systems such as mobile devices.
This memo describes a key exchange mechanism for the version of SSH described in [RFC4251] that is similar to that used by the older version, and about as fast, while retaining the security advantages of the newer protocol.
Conventions Used in This Document
The key words "MUST" and "SHOULD" in this document are to be interpreted as described in [RFC2119].
The data types "byte", "string", and "mpint" are defined in Section 5 of [RFC4251].
Other terminology and symbols have the same meaning as in [RFC4253].
The RSA key exchange method consists of three messages.
The server sends to the client an RSA public key, K T, to which the server holds the private key.
This may be a transient key generated solely for this SSH connection, or it may be re used for several connections.
The client generates a string of random bytes, K, encrypts it using K T, and sends the result back to the server, which decrypts it.
The client and server each hash K, K T, and the various key exchange parameters to generate the exchange hash, H, which is used to generate the encryption keys for the session, and the server signs H with its host key and sends the signature to the client.
The client then verifies the host key as described in Section 8 of [RFC4253].
This method provides explicit server identification as defined in Section 7 of [RFC4253].
It requires a signature capable host key.
The method uses the following messages.
The key K T is encoded according to the "ssh rsa" scheme described in Section 6.6 of [RFC4253].
Note that unlike an "ssh rsa" host key, K T is used only for encryption, and not for signature.
The modulus of K T MUST be at least MINKLEN bits long.
The client generates a random integer, K, in the range 0 <  K < 2^(KLEN
2 HLEN 49), where KLEN is the length of the modulus of K T, in bits.
The client then uses K T to encrypt:
See Appendix A for a proof that the encoding of K is always short enough to be thus encrypted.
This, combined with encoding the result as an SSH "string", gives a result that is similar, but not identical, to the SSH "mpint" encoding applied to that integer.
This is the same encoding as is used by "ssh rsa" signatures in [RFC4253].
If a decryption error occurs, the server SHOULD send SSH MESSAGE DISCONNECT with a reason code of SSH DISCONNECT KEY EXCHANGE FAILED and MUST disconnect.
The hash H is computed as the HASH hash of the concatenation of the following: string    V C, the client's identification string (CR and LF excluded)
string    V S, the server's identification string (CR and LF excluded)
I C, the payload of the client's SSH MSG KEXINIT string
I S, the payload of the server's SSH MSG KEXINIT string    K S, the host key string    K T, the transient RSA key string    RSAES OAEP ENCRYPT(K T, K), the encrypted secret mpint
K, the shared secret This value is called the exchange hash, and it is used to authenticate the key exchange.
The exchange hash SHOULD be kept secret.
The signature algorithm MUST be applied over H, not the original data.
Most signature algorithms include hashing and additional padding.
For example, "ssh dss" specifies SHA 1 hashing.
In such cases, the data is first hashed with HASH to compute H, and H is then hashed again as part of the signing operation.
The "rsa1024 sha1" method specifies RSA key exchange as described above with the following parameters:
The "rsa2048 sha256" method specifies RSA key exchange as described above with the following parameters:
The following message numbers are defined:
30 SSH MSG KEXRSA SECRET
31 SSH MSG KEXRSA DONE    32 8.
The security considerations in [RFC4251] apply.
If the RSA private key generated by the server is revealed, then the session key is revealed.
The server should thus arrange to erase this from memory as soon as it is no longer required.
If the same RSA key is used for multiple SSH connections, an attacker who can find the private key (either by factorising the public key or by other means) will gain access to all of the sessions that used that key.
As a result, servers SHOULD use each RSA key for as few key exchanges as possible.
[RFC3447] recommends that RSA keys used with RSAES OAEP not be used with other schemes, or with RSAES OAEP using a different hash function.
In particular, this means that K T should not be used as a host key, or as a server key in earlier versions of the SSH protocol.
Like all key exchange mechanisms, this one depends for its security on the randomness of the secrets generated by the client (the random number K) and the server (the transient RSA private key).
In particular, it is essential
that the client use a high quality cryptographic pseudo random number generator to generate K.  Using a bad random number generator will allow an attacker to break all the encryption and integrity protection of the Secure Shell transport layer.
See [RFC4086] for recommendations on random number generation.
The size of transient key used should be sufficient to protect the encryption and integrity keys generated by the key exchange method.
For recommendations on this, see [RFC3766].
The strength of RSAES OAEP is in part dependent on the hash function it uses.
[RFC3447] suggests using a hash with an output length of twice the security level required, so SHA 1 is appropriate for applications requiring up to 80 bits of security, and SHA 256 for those requiring up to 128 bits.
Unlike the Diffie Hellman key exchange method defined by [RFC4253], this method allows the client to fully determine the shared secret, K.
This is believed not to be significant, since K is only ever used when hashed with data provided in part by the server (usually in the form of the exchange hash, H).
If an extension to SSH were to use K directly and to assume that it had been generated by Diffie Hellman key exchange, this could produce a security weakness.
Protocol extensions using K directly should be viewed with extreme suspicion.
This key exchange method is designed to be resistant to collision attacks on the exchange hash, by ensuring that neither side is able to freely choose its input to the hash after seeing all of the other side's input.
The server's last input is in SSH MSG KEXRSA PUBKEY, before it has seen the client's choice of K.
The client's last input is K and its RSA encryption, and the one way nature of RSA encryption should ensure that the client cannot choose K so as to cause a collision.
IANA Considerations IANA has assigned the names "rsa1024 sha1" and "rsa2048 sha256" as Key Exchange Method Names in accordance with [RFC4250].
On the Size of K
The requirements on the size of K are intended to ensure that it is always possible to encrypt it under K T.
The mpint encoding of K requires a leading zero bit, padding to a whole number of bytes, and a four byte length field, giving a maximum length in bytes, B   (KLEN 2 HLEN 49 1 7)/8
The maximum length of message that can be encrypted using RSAEP OAEP is defined by [RFC3447] in terms of the key length in bytes, which is (KLEN 7)/8.
The maximum length is thus L
(KLEN 7 2 HLEN 16)/8
Thus, the encoded version of K is always small enough to be encrypted under K T.
