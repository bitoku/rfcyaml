- title: __initial_text__
  contents:
  - '              Tekelec''s Transport Adapter Layer Interface

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2001).  All Rights Reserved.\n\
    \   Readers should note that this memo presents a vendor's alternative to\n  \
    \ standards track technology being developed by the IETF SIGTRAN\n   Working Group.\
    \  The technology presented in this memo has not been\n   reviewed by the IETF\
    \ for its technical soundness or completeness.\n   Potential users of this type\
    \ of technology are urged to examine the\n   SIGTRAN work before deciding to use\
    \ the technology described here.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document proposes the interfaces of a Signaling Gateway, which\n\
    \   provides interworking between the Switched Circuit Network (SCN) and\n   an\
    \ IP network.  Since the Gateway is the central point of signaling\n   information,\
    \ not only does it provide transportation of signaling\n   from one network to\
    \ another, but it can also provide additional\n   functions such as protocol translation,\
    \ security screening, routing\n   information, and seamless access to Intelligent\
    \ Network (IN) services\n   on both networks.\n   The Transport Adapter Layer\
    \ Interface (TALI) is the proposed\n   interface, which provides TCAP (Transaction\
    \ Capability Application\n   Part), ISUP (ISDN User Part), and MTP (Mail Transport\
    \ Protocol)\n   messaging over TCP/IP.  In addition, TALI provides SCCP (Signalling\n\
    \   Connection Control Part) Management (SCMG), MTP Primitives, dynamic\n   registration\
    \ of circuits, and routing of call control messages based\n   on circuit location.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction                                       \
    \             4\n   2. Overview of the TALI Protocol                         \
    \          6\n   2.1 Traditional PSTN SS7 Networks                           \
    \       6\n   2.2 Converged SS7 Networks                                     \
    \    8\n   2.3 TALI Protocol Stack Overview                                  10\n\
    \   2.3.1 An Alternate TALI Protocol Stack using the SAAL Layer       13\n   2.3.2\
    \ An Alternate TALI Protocol Stack using SCTP                 15\n   2.4 Inputs\
    \ to the TALI Version 1.0 State Machine                  15\n   3. TALI Version\
    \ 1.0                                               17\n   3.1 Overview of the\
    \ TALI Message Structure                        17\n   3.1.1 Types of TALI Fields\
    \                                        19\n   3.2 Detailed TALI Message Structure\
    \                               20\n   3.2.1 TALI Peer to Peer Messages      \
    \                            20\n   3.2.1.1 Test Message (test)              \
    \                         20\n   3.2.1.2 Allow Message (allo)                \
    \                      21\n   3.2.1.3 Prohibit Message (proh)                \
    \                   21\n   3.2.1.4 Prohibit Acknowledgement Message (proa)   \
    \                21\n   3.2.1.5 Monitor Message (moni)                       \
    \             22\n   3.2.1.6 Monitor Acknowledge Message (mona)              \
    \          22\n   3.2.2 Service Messages                                     \
    \       23\n   3.2.2.1 SCCP Service Message (sccp)                           \
    \    23\n   3.2.2.1.1 SCCP Encapsulation using TALI                          \
    \ 25\n   3.2.2.2 ISUP Service Message (isot)                               27\n\
    \   3.2.2.2.1 ISUP Encapsulation using TALI                           27\n   3.2.2.3\
    \ MTP3 Service Message (mtp3)                               28\n   3.2.2.3.1 MTP3\
    \ Encapsulation using TALI                           29\n   3.2.2.4 SAAL Service\
    \ Message (saal)                               30\n   3.2.2.4.1 MTP3 and SAAL\
    \ Peer to Peer Encapsulation using TALI     31\n   3.3 TALI Timers           \
    \                                        34\n   3.3.1 T1 Timer               \
    \                                     34\n   3.3.2 T2 Timer                  \
    \                                  34\n   3.3.3 T3 Timer                     \
    \                               34\n   3.3.4 T4 Timer                        \
    \                            34\n   3.3.5 Recommended Defaults and Ranges for\
    \ the TALI Timers         35\n   3.4 TALI User Events                        \
    \                      35\n   3.4.1 Management Open Socket Event             \
    \                   35\n   3.4.2 Management Close Socket Event               \
    \                36\n   3.4.3 Management Allow Traffic Event                 \
    \             36\n   3.4.4 Management Prohibit Traffic Event                 \
    \          36\n   3.5 Other Implementation Dependent TALI Events             \
    \       37\n   3.6 TALI States                                               \
    \    37\n   3.7 TALI Version 1.0 State Machine                               \
    \ 38\n   3.7.1 State Machine Concepts                                      38\n\
    \   3.7.1.1 General Protocol Rules                                    38\n   3.7.1.2\
    \ Graceful Shutdown of a Socket                             39\n   3.7.1.3 TALI\
    \ Protocol Violations                                  39\n   3.7.2 The State\
    \ Machine                                           40\n   3.8 TALI 1.0 Implementation\
    \ Notes                                 42\n   3.8.1 Failure on a TCP/IP Socket\
    \                                  42\n   3.8.2 Congestion on a TCP/IP Socket\
    \                               43\n   3.9 TALI 1.0 Limitations              \
    \                            43\n   4. TALI Version 2.0                      \
    \                         43\n   4.1 Overview of TALI Version 2.0 Features   \
    \                      45\n   4.2 TALI Version Identification                \
    \                   47\n   4.3 Backwards Compatibility                       \
    \                50\n   4.3.1 Generating Protocol Violations based on Received\
    \ Messages   53\n   4.4 Overview of the TALI Message Structure               \
    \         55\n   4.4.1 Types of TALI Fields                                  \
    \      55\n   4.5 Detailed TALI Message Structures for New 2.0 Opcodes       \
    \   58\n   4.5.1 Management Message (mgmt)                                   60\n\
    \   4.5.1.1 Routing Key Registration Primitive (rkrp)                 61\n   4.5.1.1.1\
    \ RKRP Data Structures                                    65\n   4.5.1.1.1.1 Common\
    \ Fields in all RKRP Messages                    65\n   4.5.1.1.1.2 CIC Based\
    \ Routing Key Operations                      67\n   4.5.1.1.1.3 SCCP Routing\
    \ Key Operations                           71\n   4.5.1.1.1.4 DPC-SI, DPC and\
    \ SI based Routing Key Operations       74\n   4.5.1.1.1.5 Default Routing Key\
    \ Operations                        76\n   4.5.1.1.1.6 Support for Multiple RKRP\
    \ Registration Operations     78\n   4.5.1.1.1.6.1 Multiple Registrations Support\
    \                      78\n   4.5.1.1.1.6.2 Multiple RKRP Operations in a Single\
    \ Message        80\n   4.5.1.2 MTP3 Primitive (mtpp)                        \
    \             82\n   4.5.1.3 Socket Option Registration Primitive (sorp)     \
    \          87\n   4.5.2 Extended Service Message (xsrv)                      \
    \       91\n   4.5.3 Special Message (spcl)                                  \
    \    92\n   4.5.3.1 Special Messages Not Supported (smns)                    \
    \ 93\n   4.5.3.2 Query Message (qury)                                      93\n\
    \   4.5.3.3 Reply Message (rply)                                      94\n   4.5.3.4\
    \ Unsolicited Information Message (USIM)                    95\n   4.6 TALI Timers\
    \                                                   95\n   4.7 TALI User Events\
    \                                              95\n   4.8 TALI States        \
    \                                           96\n   4.9 TALI Version 2.0 State\
    \ Machine                                96\n   4.9.1 State Machine Concepts \
    \                                     96\n   4.9.1.1 General Protocol Rules  \
    \                                  96\n   4.9.1.2 Graceful Shutdown of a Socket\
    \                             97\n   4.9.1.3 TALI Protocol Violations        \
    \                          97\n   4.9.2 The State Machine                    \
    \                       97\n   4.10 TALI 2.0 Specification Limitations       \
    \                   101\n   5. Success/Failure Codes                         \
    \                101\n   6. Security Considerations                          \
    \             102\n   7. References                                          \
    \          102\n   8. Acknowledgments                                        \
    \       103\n   9. Authors' Addresses                                        \
    \    104\n   10. Full Copyright Statement                                    \
    \ 105\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   This document is organized into the following 6 sections:\n\
    \   -  Introduction to the document\n   -  Overview of the TALI Protocol\n   -\
    \  TALI Version 1.0\n   -  TALI Version 2.0\n   -  Success/Failure Codes\n   -\
    \  Security Considerations\n   The following terms are used throughout this document.\n\
    \   Circuit Identification Code (CIC):\n   A field identifying the circuit being\
    \ setup or released.  Depending\n   on SI and MSU Type, this field can be 12,\
    \ 14 or 32 bits.\n   Changeover/Changeback (co/cb):\n   SS7 MTP3 procedure related\
    \ to link failure and re-establishment.\n   Far End (FE):\n   The remote endpoint\
    \ of a socket connection.\n   Far End Allowed (FEA):\n   The FE is ready to use\
    \ the socket for service PDUs.\n   Far End Prohibited (FEP):\n   The FE is not\
    \ ready to use the socket for service PDUs.\n   Intelligent Network (IN):\n  \
    \ A network that allows functionality to be distributed flexibly at a\n   variety\
    \ of nodes on and off the network and allows the architecture\n   to be modified\
    \ to control the services.\n   Management ATM Adaptation Layer (MAAL):\n   This\
    \ layer is a component of SAAL.  This layer maps requests and\n   indications\
    \ between the System Management for the SG and the other\n   SAAL layers.  MAAL\
    \ includes interfaces to/from SSCOP, SSCF, and\n   system management.  More information\
    \ can be found in T1.652.\n   Media Gateway (MG):\n   A MG terminates SCN media\
    \ streams, packetizes the media data, if it\n   is not already packetized, and\
    \ delivers packetized traffic  to the\n   packet network.  It performs these functions\
    \ in reverse order for\n   media streams flowing from the packet network to the\
    \ SCN.\n   Media Gateway Controller (MGC):\n   An MGC handles the registration\
    \ and management of resources at the\n   MG.  The MGC may have the ability to\
    \ authorize resource usage based\n   on local policy.  For signaling transport\
    \ purposes, the MGC serves as\n   a possible termination and origination point\
    \ for SCN application\n   protocols, such as SS7 ISDN User Part and Q.931/DSS1.\n\
    \   MTP3 Framing (MTP3F):\n   TALI does not require full MTP3 procedures support\
    \ but rather uses\n   the MTP3 framing structure (ie: SIO, Routing Label, etc)\n\
    \   Near End (NE):\n   The local endpoint of a socket connection.\n   Near End\
    \ Allowed (NEA):\n   The NE is ready to use the socket for service PDUs.\n   Near\
    \ End Prohibited (NEP):\n   The NE is not ready to use the socket for service\
    \ PDUs.\n   Q.BICC ISUP:\n   An ISUP+ variant that uses 32 bit CIC codes instead\
    \ of 14/12 bit CIC\n   codes.  ISUP+, or Q.BICC ISUP, is based on the Q.765.BICC\n\
    \   specification currently being developed in ITU Study Group 11.\n   Signaling\
    \ ATM Adaptation Layer (SAAL):\n   This layer is the equivalent of MTP-2 for ATM\
    \ High Speed Links\n   carrying SS7 Traffic as described in GR-2878-CORE [8].\
    \  SAAL includes\n   SSCF, SSCOP and MAAL.\n   Signaling Gateway (SG):\n   An\
    \ SG is a signaling agent that receives/sends SCN native signaling\n   at the\
    \ edge of the IP network.  The SG function may relay, translate\n   or terminate\
    \ SS7 signaling in an SS7-Internet Gateway.  The SG\n   function may also be co-resident\
    \ with the MGC/MG functions to process\n   SCN signaling associated with line\
    \ or trunk terminations controlled\n   by the MG (e.g., signaling backhaul).\n\
    \   Service Specific Coordination Function (SSCF):\n   This layer is a component\
    \ of SAAL.  This layer maps the services\n   provided by the lower layers of the\
    \ SAAL to the needs of a specific\n   higher layer user.  In the case of the STP,\
    \ the higher layer user is\n   the MTP-3 protocol, and the SSCF required is that\
    \ as defined by\n   T1.645: SSCF for Support of Signaling at the Network Node\
    \ Interface\n   (SSCF at the NNI).  More information can be found in T1.645. \
    \ SSCF\n   provides the interface between SSCOP and MTP3 and includes the\n  \
    \ following functions:\n   -  Local Retrieve of messages to support link changeover\
    \ procedures\n   -  Flow control with four levels of congestion\n   Switched Circuit\
    \ Network (SCN):\n   The term SCN is used to refer to a network that carries traffic\n\
    \   within channelized bearers of pre-defined sizes.  Examples include\n   Public\
    \ Switched Telephone Networks (PSTNs) and Public Land Mobile\n   Networks (PLMNs).\
    \  Examples of signaling protocols used in SCN\n   include Q.931, SS7 MTP Level\
    \ 3 and SS7 Application/User parts.\n   Service Specific Connection Oriented Protocol\
    \ (SSCOP):\n   This layer is a component of SAAL.  This layer provides reliable\n\
    \   point to point data transfer with sequence integrity and error\n   recovery\
    \ by selective retransmission.  Protocol layer interfaces are\n   described in\
    \ T1.637.  Aspects of the protocol include flow control,\n   connection control,\
    \ error reporting to layer management, connection\n   maintenance in the prolonged\
    \ absence of data transfer, local data\n   retrieval by the user of the SSCOP,\
    \ error detection of protocol\n   control information and status reporting.  SSCOP\
    \ provides the link\n   layer functions that are:\n   -  In-Sequence Delivery\n\
    \   -  Flow Control\n   -  Error Detection/Correction\n   -  Keep Alive\n   -\
    \  Local Data Retrieval\n   -  Connection Control\n   -  Protocol Error Detection\
    \ and Recovery\n   Signaling Transfer Point (STP):\n   Packet switches that provide\
    \ CCS message routing and transport.  They\n   are stored programmed switches\
    \ that use information contained in the\n   message in conjunction with information\
    \ stored in memory to route the\n   message to the appropriate destination signaling\
    \ point.\n"
- title: 2. Overview of the TALI Protocol
  contents:
  - '2. Overview of the TALI Protocol

    '
- title: 2.1 Traditional PSTN SS7 Networks
  contents:
  - "2.1 Traditional PSTN SS7 Networks\n   The traditional PSTN SS7 network consists\
    \ of 3 types of devices\n   connected via dedicated SS7 signaling links.\n   The\
    \ 3 primary device types for PSTN networks are:\n   *  SSP:  Signaling Service\
    \ Point.  These nodes act as endpoints in\n      the SS7 network, originating\
    \ SS7 messages as users attempt to\n      place phone calls.  These nodes contain\
    \ interfaces into the SS7\n      data network and the SS7 voice network.\n   *\
    \  STP: Signaling Transfer Point.  These nodes act primarily as\n      switches,\
    \ switching SS7 traffic from node to node throughout the\n      network until\
    \ it reaches another endpoint.  An important feature\n      of each STP is to\
    \ provide SS7 network management functionality\n      that allows messages to\
    \ be delivered even when links and devices\n      fail.  STPs also sometimes provide\
    \ database type services, such as\n      Global Title Translations and Local Number\
    \ Portability.\n   *  SCP: Signaling Control Point.  These nodes act as databases.\n\
    \      These nodes contain stored data that is used to turn SS7 Queries\n    \
    \  into SS7 Replies.\n   There are 3 primary types of dedicated SS7 signaling\
    \ links:\n   *  56Kbps SS7 (DS0, V35, OCU) links.  These links implement the MTP-1\n\
    \      and MTP-2 protocols as defined in [1].\n   *  DS1 High Speed Links.  These\
    \ links use the SAAL protocol to\n      provide an alternative to 56Kbps SS7 links\
    \ that is based on newer,\n      faster technology.  These links implement the\
    \ SS7 protocol as\n      defined in [8].\n   *  E1 Links.\n      Figure 1 provides\
    \ an overview of the traditional PSTN network.  In\n      this network, any of\
    \ the links can be implemented via either 56\n      Kbps, DS1, or E1 links.\n\
    \                                 ^\n                                / \\\n  \
    \                             /SCP\\\n                              /-----\\\n\
    \                                /  \\\n                               /    \\\
    \n                              /      \\\n                             /    \
    \    \\\n               /---\\      +---+    +---+      /---\\\n             \
    \ | SSP |-----|STP|----|STP|-----| SSP |\n               \\---/  \\  /+-+-+\\\
    \  /+-+-+ \\  / \\---/\n                       \\/   |   \\/   |    \\/\n    \
    \                   /\\   |   /\\   |    /\\\n               /---\\  /  \\+-+-+/\
    \  \\+-+-+ /  \\ /---\\\n              | SSP |/----|STP|----|STP|/----| SSP |\n\
    \               \\---/      +---+    +---+      \\---/\n                     \
    \      \\           /\n                            \\         /\n            \
    \                 \\       /\n                              \\  ^  /\n       \
    \                        \\/ \\/\n                               /SCP\\\n    \
    \                          /-----\\\n              Figure 1: The Traditional PSTN\
    \ Network\n"
- title: 2.2 Converged SS7 Networks
  contents:
  - "2.2 Converged SS7 Networks\n   In the converged SS7 network, SS7 devices will\
    \ reside on both the\n   traditional PSTN network (with dedicated 56 Kbps and\
    \ DS1 links) and\n   on the IP network (with Ethernet links based on IP protocol).\
    \  The\n   services of SSPs, STPs, and SCPs can be provided by new types of\n\
    \   devices that reside on IP networks.  The IP network is not intended\n   to\
    \ completely replace the PSTN, rather devices on the 2 types of\n   networks must\
    \ be able to communicate with one another and convert\n   from 1 lower layer protocol\
    \ to the other.\n   Signaling Gateways are new devices that may also function\
    \ as an STP\n   in the converged network.  SGs provide interfaces to:\n   *  devices\
    \ on the SCN (traditional SSPs, STPs, and SCPs)\n   *  other SGs\n   *  new devices\
    \ on the IP network\n   SGs also continue to perform STP functions such as SS7\
    \ network\n   management and some database services (such as GTT and LNP).\n \
    \  New devices on the IP network include:\n   *  Media Gateway Controllers.  In\
    \ addition to other functions, these\n      devices control Media Gateways and\
    \ perform call processing.\n   *  Media Gateways.  In addition to other functions,\
    \ these devices\n      control voice circuits that are used to carry telephone\
    \ calls.\n      MGs + MGCs combine to provide the functionality of traditional\n\
    \      SSPs.\n   *  IP based SCPs.  The database services that are related to\
    \ SS7 can\n      be moved onto devices on the IP network.\n      Figure 2 provides\
    \ an overview of the converged SS7 network.\n                         -----  \
    \            +----+\n                /\\      /     \\-------------| SG |\n  \
    \             /  \\----|  SCN  |     +----+ +----+\n              /SCP \\    \\\
    \     /------| SG |  |\n              ------     -----       +----+  |\n     \
    \                    |   |           |   |\n                         |   |   \
    \        |   |\n                         |   |           -----\n             \
    \            |   |          /     \\      /\\\n                         |   |\
    \         |  IP   |----/  \\\n                         |  /---\\       \\    \
    \ /    /SCP \\\n                         | | SSP |       -----     ------\n  \
    \                       |  \\---/         /   \\\n                         | \
    \    |         /     \\\n                       /---\\   |        /       \\\n\
    \                      | SSP |  |     +---+    +---+\n                       \\\
    ---/ +----+  |MGC|    |MGC|\n                         |   | MG |  +---+    +---+\n\
    \                         |   +----+\\    \\     /\n                         |\
    \          \\    \\   /\n                         |           \\   -----\n   \
    \                      |            \\ /     \\\n                       +----+\
    \          |  IP   |\n                       | MG |-----------\\     /\n     \
    \                  +----+            -----\n                    Figure 2: The\
    \ Converged SS7 Network\n   In theory, the TALI protocol can be used between 2\
    \ nodes to carry SS7\n   traffic across TCP/IP.  Some of the areas that TALI could\
    \ be used\n   include:\n   -  For SG to SG communication across IP\n   -  For\
    \ SG to MGC communication across IP\n   -  For SG to IP based SCP communication\
    \ across IP\n   -  For communication between multiple IP based SCPs\n   -  For\
    \ communication between multiple MGCs\n   -  For communication between MGCs and\
    \ MGs\n   -  For other IP devices such as DNS, Policy Servers, etc.\n   In reality,\
    \ the communication between MGCs, or between MGC and MG is\n   probably better\
    \ suited to using other protocols.  With respect to the\n   Signaling Gateway\
    \ implementation, the TALI protocol is used to carry\n   SS7 traffic:\n   -  For\
    \ SG to SG communication\n   -  For SG to MGC communication\n   -  For SG to IP\
    \ based SCP communication\n"
- title: 2.3 TALI Protocol Stack Overview
  contents:
  - "2.3 TALI Protocol Stack Overview\n   The Transport Adapter Layer Interface is\
    \ the proposed interface that\n   provides SCCP, ISUP, and MTP messaging encapsulation\
    \ within a TCP/IP\n   packet between two switching elements.  In addition, TALI\
    \ provides\n   SCCP Management (SCMG), MTP Primitives, dynamic registration of\n\
    \   circuits, and routing of call control messages based on circuit\n   location.\n\
    \   The major purpose of the TALI protocol is to provide a bridge between\n  \
    \ the SS7 Signaling Network and applications that reside within an IP\n   network.\
    \  Figure 3 provides a simple illustration that highlights the\n   protocol stacks\
    \ used for transport of SS7 MSUs on both the SS7 side\n   and the IP side of the\
    \ SG.\n                 SS7 traffic       SS7 traffic\n              via 56Kbps\
    \ links     via TALI\n       +-----------+        +----+          +--------+\n\
    \       |Traditional|        | SG |          |   IP   |\n       |SS7 Devices|<------>|\
    \    |<-------->| Devices|\n       +-----------+        +----+          +--------+\n\
    \          SS7                          SS7, TALI, TCP/IP\n          protocol\
    \ stack               protocol stack\n        +---------------+              +---------------+\n\
    \        |SS7 application|              |SS7 application|\n        |layer    \
    \      |              |layer          |\n        +-------+-------+           \
    \   +-------+-------+\n        | TCAP  | ISUP  |              | TCAP  | ISUP \
    \ |\n        +-------+       |              +-------+       |\n        | SCCP\
    \  |       |              | SCCP  |       |\n        +-------+-------+       \
    \       +-------+-------+\n        |    MTP3       |              |    MTP3  \
    \     |\n        +---------------+              +---------------+\n        | \
    \   MTP2       |              |    TALI       |\n        +---------------+   \
    \           +---------------+\n        |    MTP1       |              |    TCP\
    \        |\n        |   (& phy.     |              +---------------+\n       \
    \ |    layer)     |              |    IP         |\n        +---------------+\
    \              +---------------+\n                                       |   \
    \ MAC        |\n                                       |   (& phy.     |\n   \
    \                                    |    layer)     |\n                     \
    \                  +---------------+\n       Figure 3: TALI Protocol to carry\
    \ SS7 over TCP/IP\n   From Figure 3, several observations can be made:\n   * \
    \ The TALI layer is used when transferring SS7 over IP.\n   *  When SS7 traffic\
    \ is carried over a IP network, the MTP2 and MTP1\n      layers of a traditional\
    \ 56 Kbps link are replaced by the TALI,\n      TCP, IP, and MAC layers\n   *\
    \  The TALI layer sits on top of the TCP layer.\n   *  The TALI layer sits below\
    \ the various SS7 layers (MTP3, SCCP/TCAP,\n      ISUP, and applications).  The\
    \ data from these SS7 layers is\n      carried as the data portion of TALI service\
    \ data packets.\n   Some of the facts concerning the TALI protocol which are important\
    \ to\n   understanding how TALI works that are not evident from Figure 3\n   include\
    \ the following:\n   *  Each TALI connection is provided over a single TCP socket.\n\
    \      *  The standard Berkeley sockets interface to the TCP is used by\n    \
    \     the TALI layer to provide connection oriented service from\n         endpoint\
    \ to peer endpoint.\n      *  TCP sockets are based on a Client/Server architecture;\
    \ one end\n         of the TALI connection must be defined as the 'server side',\n\
    \         the other end is a 'client'.\n      *  The client/server roles are important\
    \ only in bringing up the\n         TCP connection between the 2 endpoint, once\
    \ the connection is\n         established both ends use the same Berkeley sockets\
    \ calls\n         (send, recv) to transfer data.\n      *  The TCP socket must\
    \ be connected before the 2 TALI endpoints\n         can begin communicating.\n\
    \   *  TALI provides user control over each TALI connection that is\n      defined.\
    \  This control:\n      *  Allows the user to control when each TALI connection\
    \ will be\n         made\n      *  Allows the user to control when each TALI connection\
    \ is allowed\n         to carry SS7 traffic\n      * Allows the user to control\
    \ the graceful shutdown of each socket\n   *  TALI provides Peer to Peer messages.\
    \  These messages originate\n      from the TALI layer of one endpoint of the\
    \ connection and are\n      terminated at the TALI layer of the other endpoint.\
    \  Peer to Peer\n      messages are used:\n      *  To provide test and watchdog\
    \ maintenance messages\n      *  To control the ability of each socket to carry\
    \ SS7 service\n         messages\n   *  TALI provides Service messages.  These\
    \ messages originate from the\n      layer above the TALI layer of one endpoint\
    \ of the connection and\n      are transferred to and terminated at the layer\
    \ above the TALI\n      layer of the other endpoint.\n      *  The service messages\
    \ provide several different ways to\n         encapsulate the SS7 messages (SCCP/TCAP,\
    \ ISUP, and other MTP3\n         layer data) across the TCP/IP connection.\n \
    \     *  As we will see later, different Service opcodes are used to\n       \
    \  communicate across the TALI socket exactly how each SS7 message\n         has\
    \ been encapsulated.\n   *  A set of TALI timers is defined.  These timers are\
    \ used to\n      correctly implement the TALI state machine.\n"
- title: 2.3.1 An Alternate TALI Protocol Stack using the SAAL Layer
  contents:
  - "2.3.1 An Alternate TALI Protocol Stack using the SAAL Layer\n   This section\
    \ presents a different, slightly more complex, TALI\n   protocol stack that can\
    \ be used in place of the protocol stack in the\n   previous section.\n   Figure\
    \ 3 in the previous section provided a simple illustration that\n   highlighted\
    \ the basic TALI protocol stack that can be used to\n   transport SS7 MSUs between\
    \ 56 Kbps links on the SS7 side of an SG and\n   the IP devices.\n   Figure 4\
    \ below illustrates an alternate TALI protocol stack that\n   includes the SAAL\
    \ layer as part of the data transferred across the\n   TCP/IP connection.\n  \
    \                  SS7 traffic       SS7 traffic\n                    via DS1\
    \ links     via TALI\n          +-----------+        +----+          +--------+\n\
    \          |Traditional|        | SG |          |   IP   |\n          |SS7 Devices|<------>|\
    \    |<-------->| Devices|\n          +-----------+        +----+          +--------+\n\
    \             SS7 DS1                   SS7, TALI, TCP/IP\n             protocol\
    \ stack            protocol stack\n           +-----------------+        +-----------------+\n\
    \           | SS7 application |        | SS7 application |\n           | layer\
    \           |        | layer           |\n           +--------+--------+     \
    \   +--------+--------+\n           |  TCAP  | ISUP   |        |  TCAP  | ISUP\
    \   |\n           +--------+        |        +--------+        |\n           |\
    \  SCCP  |        |        |  SCCP  |        |\n           +--------+--------+\
    \        +--------+--------+\n           |      MTP3       |        |      MTP3\
    \       |\n           +-----------------+        +-----------------+\n       \
    \    |    SAAL         |        |     SAAL        |\n           |(SSCF,MAAL,SSCOP)|\
    \        |(SSCF,MAAL,SSCOP)|\n           +-----------------+        +-----------------+\n\
    \           |     AAL5        |        |     TALI        |\n           +-----------------+\
    \        +-----------------+\n           |     ATM         |        |     TCP\
    \         |\n           |    (& phy.      |        +-----------------+\n     \
    \      |     layer)      |        |     IP          |\n           +-----------------+\
    \        +-----------------+\n                                      |     MAC\
    \         |\n                                      |    (& phy.      |\n     \
    \                                 |     layer)      |\n                      \
    \                +-----------------+\n        Figure 4: An Alternate TALI Protocol\
    \ Stack with SAAL\n   The following bullets provide a discussion regarding the\
    \ differences\n   between these 2 protocol stacks, the reasons for having 2 protocol\n\
    \   stacks, and the advantages of each:\n   *  When the TALI protocol stack is\
    \ implemented without the SAAL\n      layer, as in Figure 3, the SEQUENCE NUMBER\
    \ of the SS7 MSU is NOT\n      part of the data transferred across the TCP/IP\
    \ connection.  In 56\n      Kbps SS7 links, the MTP2 header contains an 8 bit\
    \ sequence number\n      for each MSU.  The sequence number is used to preserve\
    \ message\n      sequencing and to support complex SS7 procedures involving MSU\n\
    \      retrieval during link changeover and changeback.  As indicated in\n   \
    \   Figure 3, the MTP2 header is NOT part of the data transferred\n      across\
    \ the TCP/IP connection.  The TALI protocol stack without\n      SAAL still guarantees\
    \ correct sequencing of SS7 data (this\n      sequencing is provided by sequence\
    \ numbers in the TCP layer),\n      however that protocol stack can not support\
    \ SS7 changeover and\n      changeback procedures.\n   *  When the TALI protocol\
    \ stack is implemented with the SAAL layer,\n      as in Figure 4, the SEQUENCE\
    \ NUMBER of the SS7 MSU IS part of the\n      data transferred across TCP/IP.\
    \  In SS7 DS1 links, the SSCOP\n      trailer contains a 24 bit sequence number\
    \ for each MSU.  This 24\n      bit sequence number serves the same purposes as\
    \ the 8 bit SS7\n      sequence number.  As indicated in Figure 4, the SSCOP trailer\
    \ IS\n      part of the data transferred across the TCP/IP connection.  The\n\
    \      protocol stack in Figure 4 can support SS7 changeover and\n      changeback\
    \ procedures.\n   *  Implementing the TALI protocol with SAAL therefore provides\n\
    \      support for SS7 co/cb and data retrieval and can help to minimize\n   \
    \   MSU loss as SS7 links are deactivated.  However, implementing SAAL\n     \
    \ is not a trivial matter.  The SAAL layer consists of 3 sublayers\n      (SSCF,\
    \ SSCOP, and MAAL), one of which (SSCOP) is quite involved.\n      It is envisioned\
    \ that most SS7 to TCP/IP applications will NOT\n      choose to implement SAAL.\n"
- title: 2.3.2 An Alternate TALI Protocol Stack using SCTP
  contents:
  - "2.3.2 An Alternate TALI Protocol Stack using SCTP\n   The TALI protocol is dependent\
    \ on a reliable transport layer below\n   it.  At the initial design of TALI,\
    \ TCP was the only reliable, proven\n   transport layer.  Simple Control Transport\
    \ Protocol (SCTP) is\n   currently being designed as a transport later specifically\
    \ for\n   signalling.  Once SCTP is a proven and accepted transport protocol,\n\
    \   SCTP can then be used in place of TCP as shown in Figures 3 and 4.\n"
- title: 2.4 Inputs to the TALI Version 1.0 State Machine
  contents:
  - "2.4 Inputs to the TALI Version 1.0 State Machine\n   Figure 5 illustrates the\
    \ inputs that affect the TALI State Machine.\n   Inputs to the state machine include:\n\
    \   *  Management events (ie: requests from the human user of the TALI\n     \
    \ connection) to control the operation of a particular TALI session.\n   *  TALI\
    \ messages received from the Peer.  These messages include peer\n      to peer\
    \ messages as well as service data messages.\n   *  Events from the User of the\
    \ TALI layer.  The user is the layer\n      above TALI in the protocol stack,\
    \ either the SS7 or SAAL layer.\n   *  Implementation Dependent Events.  Each\
    \ implementation must provide\n      inputs into the TALI state machine such as:\n\
    \      *  Socket Events\n      *  TALI protocol violations.  The TALI state machine\
    \ must detect\n         protocol violations and act accordingly.\n      * Timer\
    \ events.\n      +====+                                   +============+\n   \
    \   |    |    +---------+ +-------------+    |            |\n      |User|    |\
    \ Service | | Mgmt. Open  |    | MANAGEMENT |\n      |Part|<-->| Message | | Mgmt.\
    \ Close |<-->|            |\n      |    |    |         | | Mgmt. Proh. |    |\
    \            |\n      |    |    +---------+ | Mgmt. Allow |    +============+\n\
    \      +====+          ^     +-------------+\n                      |        \
    \    ^\n                      |            |\n                      v        \
    \    v\n      +========================================================+\n   \
    \   |                 TALI State Machine                     |\n      +========================================================+\n\
    \            ^               ^                 ^             ^\n            |\
    \               |                 |             |\n            |             \
    \  |                 |             |\n            v               |          \
    \       |             |\n       +---------+  +-----------------+ +-----------+\
    \ +------------+\n       | Received|  | Connection est. | | Protocol  | | T1 Expired\
    \ |\n       | 'test'  |  | Connection lost | | Violation | | T2 Expired |\n  \
    \     | 'allo'  |  |                 | |           | | T3 Expired |\n       |\
    \ 'proh'  |  +-----------------+ +-----------+ | T4 Expired |\n       | 'proa'\
    \  |          ^                 ^       +------------+\n       | 'moni'  |   \
    \       |                 |              ^\n       | 'mona'  |          |    \
    \             |              |\n       |    or   |          |                \
    \ |              |\n       | Service |          |                 |          \
    \    |\n       | Message |    +========================================+\n   \
    \    +---------+    |         IMPLEMENTATION                 |\n            ^\
    \         |           DEPENDENT                    |\n            |         +========================================+\n\
    \            |\n            v\n        +============+\n        |    PEER    |\n\
    \        |            |\n        +============+\n      Figure 5: Overview of Inputs\
    \ to the TALI 1.0 State Machine\n"
- title: 3. TALI Version 1.0
  contents:
  - "3. TALI Version 1.0\n   This chapter provides the states, messages, message exchange\
    \ rules\n   and state machine that must be implemented to provide a TALI version\n\
    \   1.0 protocol layer.\n"
- title: 3.1 Overview of the TALI Message Structure
  contents:
  - "3.1 Overview of the TALI Message Structure\n   Table 2 provides a summary of\
    \ the messages and message structure used\n   in TALI version 1.0.\n   +------------------------------------------------------------------+\n\
    \   | OCTET | DESCRIPTION              | SIZE     | VALUE  |    TYPE   |\n   +------------------------------------------------------------------+\n\
    \   | 0..3  | SYNC                     | 4 Octets |        | 4 byte    |\n   |\
    \       |                          |          |        | ASCII     |\n   +------------------------------------------------------------------+\n\
    \   |       |   TALI                   |          | 'TALI' |           |\n   +------------------------------------------------------------------+\n\
    \   | 4..7  | OPCODE                   | 4 Octets |        | 4 byte    |\n   |\
    \       |                          |          |        | ASCII     |\n   +------------------------------------------------------------------+\n\
    \   |       |   Test Service           |          | 'test' |           |\n   |\
    \       |   Allow Service          |          | 'allo' |           |\n   |   \
    \    |   Prohibit Service       |          | 'proh' |           |\n   |      \
    \ |   Prohibit Service Ack   |          | 'proa' |           |\n   |       | \
    \  Monitor Socket         |          | 'moni' |           |\n   |       |   Monitor\
    \ Socket Ack     |          | 'mona' |           |\n   |       |   SCCP Service\
    \           |          | 'sccp' |           |\n   |       |   ISUP Service over\
    \ TALI |          | 'isot' |           |\n   |       |   MTP3 Service over TALI\
    \ |          | 'mtp3' |           |\n   |       |   Service over SAAL      | \
    \         | 'saal' |           |\n   +------------------------------------------------------------------+\n\
    \   | 8..9  | LENGTH                   | 2 Octets |        | integer   |\n   |\
    \       |   (least significant     |          |        |           |\n   |   \
    \    |    byte first) non-0     |          |        |           |\n   |      \
    \ |    if Service or         |          |        |           |\n   |       | \
    \   Socket monitor message|          |        |           |\n   +------------------------------------------------------------------+\n\
    \   | 10..X | DATA PAYLOAD             | variable |        | variable  |\n   +------------------------------------------------------------------+\n\
    \                 Table 2: Message Structure for TALI 1.0\n   Table 3 indicates\
    \ the valid values of the LENGTH field for each\n   version 1.0 opcode.  The LENGTH\
    \ field is always an indication of the\n   # of bytes contained in the DATA PAYLOAD\
    \ portion of a general TALI\n   message.\n   +------------------------------------------------------------------+\n\
    \   | OPCODE | VALID LENGTH VALUES | COMMENTS                          |\n   +------------------------------------------------------------------+\n\
    \   | test   | 0 bytes             |                                   |\n   +------------------------------------------------------------------+\n\
    \   | allo   | 0 bytes             |                                   |\n   +------------------------------------------------------------------+\n\
    \   | proh   | 0 bytes             |                                   |\n   +------------------------------------------------------------------+\n\
    \   | proa   | 0 bytes             |                                   |\n   +------------------------------------------------------------------+\n\
    \   | moni   | 0-200 bytes         | A maximum length is provided so   |\n   |\
    \        |                     | that the maximum ethernet frame   |\n   |   \
    \     |                     | size is not exceeded.             |\n   +------------------------------------------------------------------+\n\
    \   | mona   | 0-200 bytes         | Mona reply length and content must|\n   |\
    \        |                     | match the original moni (with the |\n   |   \
    \     |                     | exception of the opcode)          |\n   +------------------------------------------------------------------+\n\
    \   | sccp   | 12-265 bytes        | These are the valid sizes for the |\n   |\
    \        |                     | SCCP-ONLY portions of SCCP UDT    |\n   |   \
    \     |                     | MSUs                              |\n   +------------------------------------------------------------------+\n\
    \   | isot   | 8-273 bytes         | The length is the number of octets|\n   |\
    \        |                     | in the MTP3 and higher layer(s) of|\n   |   \
    \     |                     | the SS7 MSU.  This length includes|\n   |      \
    \  |                     | the SIO byte, the MTP3 routing    |\n   |        |\
    \                     | label, the CIC code, and the      |\n   |        |   \
    \                  | ISUP Message Type field, and any  |\n   |        |      \
    \               | other bytes that may exist as part|\n   |        |         \
    \            | of the SIF (Service Information   |\n   |        |            \
    \         | Field)                            |\n   +------------------------------------------------------------------+\n\
    \   | mtp3   | 5-280 bytes         | The length is the number of octets|\n   |\
    \        |                     | in the MTP3 and higher layer(s) of|\n   |   \
    \     |                     | the SS7 MSU.  This length includes|\n   |      \
    \  |                     | the SIO byte and the MTP3 routing |\n   |        |\
    \                     | labeld, and any other bytes that  |\n   |        |   \
    \                  | may exist as part of the SIF      |\n   |        |      \
    \               | (Service Information Field)       |\n   +------------------------------------------------------------------+\n\
    \   | saal   | 11-280 bytes        | The length is the number of octets|\n   |\
    \        |                     | in the MTP3 and higher layer(s) of|\n   |   \
    \     |                     | the SS7 MSU.  This length includes|\n   |      \
    \  |                     | the SIO byte and all bytes in the |\n   |        |\
    \                     | SIF (Service Information Field)   |\n   |        |   \
    \                  | field.  The MTP3 routing label is |\n   |        |      \
    \               | part of the SIF field.  Seven (7) |\n   |        |         \
    \            | octets of SSCOP trailer is added  |\n   |        |            \
    \         | to the message.  The SSCOP trailer|\n   |        |               \
    \      | bytes are also included in the    |\n   |        |                  \
    \   | length.                           |\n   +------------------------------------------------------------------+\n\
    \        Table 3: Valid Length Fields for Each Opcode in TALI 1.0\n"
- title: 3.1.1 Types of TALI Fields
  contents:
  - "3.1.1 Types of TALI Fields\n   Several field types are used in the general TALI\
    \ message structure.\n   +------------------------------------------------------------------+\n\
    \   |Field Type | Implementation Notes for that Type                   |\n   +------------------------------------------------------------------+\n\
    \   |4 byte     | * 4 byte ASCII text strings are used to define the   |\n   |ASCII\
    \ text |   sync code and the opcode of the basic TALI message.|\n   |        \
    \   | * These fields are case sensitive, the coding for    |\n   |           |\
    \   each sync and opcode literal needs to match the    |\n   |           |   case\
    \ specified in Table 2.                         |\n   |           | * The standard\
    \ ASCII conversion table is used to     |\n   |           |   transform each character\
    \ into a byte.              |\n   |           | * The order of the ASCII characters\
    \ is important.    |\n   |           |   The first character in the string must\
    \ be the      |\n   |           |   first character transmitted across the wire.\
    \       |\n   |           | * For example, if the string being encoded is 'abCD',|\n\
    \   |           |   the order of the bytes as they are transferred     |\n   |\
    \           |   over the wire must be:                             |\n   |   \
    \        |     1st byte: 0x61 ('a')  3rd byte: 0x43 ('C')       |\n   |      \
    \     |     2nd byte: 0x62 ('b')  4th byte: 0x44 ('D')       |\n   |         \
    \  | * The software for each implementation should be     |\n   |           |\
    \   written in a manner that accounts for the required |\n   |           |   byte\
    \ order of transmission (ie: the Big Endian/    |\n   |           |   Little Endian\
    \ characteristics of the processor     |\n   |           |   need to be dealt\
    \ with in the software.             |\n   +------------------------------------------------------------------+\n\
    \   |Integer    | * A 1, 2 or 4 byte field to be treated as an integer |\n   |\
    \           |   value.  Integer fields should be transmitted Least |\n   |   \
    \        |   Significant Byte first across the wire.            |\n   |      \
    \     | * The software for each implementation should be     |\n   |         \
    \  |   written in a manner that accounts for the required |\n   |           |\
    \   byte order of transmission (ie: the Big Endian/    |\n   |           |   Little\
    \ Endian characteristics of the processor     |\n   |           |   need to be\
    \ dealt with in the software.             |\n   +------------------------------------------------------------------+\n\
    \   |Variable   | * The definition of the message structure for this   |\n   |\
    \           |   field is governed by other specifications.         |\n   |   \
    \        | * For example, when transferring MTP3 service data   |\n   |      \
    \     |   via a 'mtp3' opcode, the DATA PAYLOAD begins with  |\n   |         \
    \  |   the SIO byte of the MTP3 routing label.  The       |\n   |           |\
    \   structure for the entire DATA PAYLOAD is governed  |\n   |           |   by\
    \ the MTP3 message structure defined in [1].      |\n   +------------------------------------------------------------------+\n\
    \   |X byte     | * ASCII text fields of sizes other than 4 bytes      |\n   |ASCII\
    \ text |   should be supported according to the same rules    |\n   |        \
    \   |   presented for the 4 byte ASCII text fields.  For   |\n   |           |\
    \   instance, an 8 byte string such as 'ab01cd23' could|\n   |           |   be\
    \ used, where the 'a' would be the first byte of  |\n   |           |   the field\
    \ transmitted out the wire.                |\n   +------------------------------------------------------------------+\n\
    \         Table 4: Implementation Notes for each Type of TALI field\n"
- title: 3.2 Detailed TALI Message Structure
  contents:
  - '3.2 Detailed TALI Message Structure

    '
- title: 3.2.1 TALI Peer to Peer Messages
  contents:
  - "3.2.1 TALI Peer to Peer Messages\n   The following subsections provide more information\
    \ regarding the TALI\n   Peer to Peer messages that are implemented in version\
    \ 1.0.  The TALI\n   peer to peer messages originate at the TALI layer of 1 end\
    \ of the\n   socket connection (the near end) and are terminated at the TALI layer\n\
    \   of the far end of the connection.\n"
- title: 3.2.1.1 Test Message (test)
  contents:
  - "3.2.1.1 Test Message (test)\n   The 'test' message is used by a TALI implementation\
    \ to query the\n   remote end of the TALI connection with respect to the willingness\
    \ of\n   the remote end to carry SS7 service data.  This message asks the\n  \
    \ other end: are you ready to carry service data?  This message is sent\n   periodically\
    \ by each TALI implementation based on a T1 timer\n   interval.  Upon receiving\
    \ 'test', a TALI implementation must reply\n   with either 'proh' or 'allo' to\
    \ indicate the nodes willingness to\n   carry SS7 service data over that TALI\
    \ connection.\n   +------------------------------------------------------------------+\n\
    \   | Octets | Field Name  | Description                               |\n   +------------------------------------------------------------------+\n\
    \   | 0..3   | SYNC        | 'TALI'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 4..7   | OPCODE      | 'test'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 8..9   | LENGTH      | Length = 0                                |\n   +------------------------------------------------------------------+\n"
- title: 3.2.1.2 Allow Message (allo)
  contents:
  - "3.2.1.2 Allow Message (allo)\n   The 'allo' message is sent in reply to a 'test'\
    \ query, or in response\n   to some internal implementation event, to indicate\
    \ that a TALI\n   implementation IS willing to carry SS7 service data over the\
    \ TALI\n   session.  This message informs the far end that SS7 traffic can be\n\
    \   transmitted on the socket.  'allo' is one of the 2 possible replies\n   to\
    \ a 'test' message.  Before SS7 traffic can be carried over a\n   socket, both\
    \ ends of the connection need to send 'allo' messages.\n   +------------------------------------------------------------------+\n\
    \   | Octets | Field Name  | Description                               |\n   +------------------------------------------------------------------+\n\
    \   | 0..3   | SYNC        | 'TALI'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 4..7   | OPCODE      | 'allo'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 8..9   | LENGTH      | Length = 0                                |\n   +------------------------------------------------------------------+\n"
- title: 3.2.1.3 Prohibit Message (proh)
  contents:
  - "3.2.1.3 Prohibit Message (proh)\n   The 'proh' message is sent in reply to a\
    \ 'test' query, or in response\n   to some internal implementation event, to indicate\
    \ that a TALI\n   implementation is NOT willing to carry SS7 service data over\
    \ the TALI\n   session.  This message informs the far end that SS7 traffic can\
    \ not\n   be transmitted on the socket.  'proh' is one of the 2 possible\n   replies\
    \ to a 'test' message.  As long as 1 end of the connection\n   remains in the\
    \ 'prohibited' state, SS7 traffic can not be carried\n   over the socket.\n  \
    \ +------------------------------------------------------------------+\n   | Octets\
    \ | Field Name  | Description                               |\n   +------------------------------------------------------------------+\n\
    \   | 0..3   | SYNC        | 'TALI'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 4..7   | OPCODE      | 'proh'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 8..9   | LENGTH      | Length = 0                                |\n   +------------------------------------------------------------------+\n"
- title: 3.2.1.4 Prohibit Acknowledgement Message (proa)
  contents:
  - "3.2.1.4 Prohibit Acknowledgement Message (proa)\n   The 'proa' message is sent\
    \ by a TALI implementation each time a\n   'proh' is received from the far end.\
    \  This message is sent to\n   indicate to the far end that his 'prohibit' message\
    \ was received\n   correctly and will be acted on accordingly.\n   +------------------------------------------------------------------+\n\
    \   | Octets | Field Name  | Description                               |\n   +------------------------------------------------------------------+\n\
    \   | 0..3   | SYNC        | 'TALI'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 4..7   | OPCODE      | 'proa'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 8..9   | LENGTH      | Length = 0                                |\n   +------------------------------------------------------------------+\n"
- title: 3.2.1.5 Monitor Message (moni)
  contents:
  - "3.2.1.5 Monitor Message (moni)\n   The 'moni' message provides a generic ECHO\
    \ capability that can be\n   used by each TALI implementation as that implementation\
    \ sees fit.  A\n   TALI version 1.0 implementation does not have to originate\
    \ a 'moni'\n   message to be compliant with the 1.0 specification.  The primary\n\
    \   intent of this message is to provide a way for the TALI layer to test\n  \
    \ the round-trip message transfer time on a socket.  A 'mona' message\n   must\
    \ be sent in reply to each received 'moni' message.  The DATA\n   portion of a\
    \ 'moni' message is vendor implementation dependent.  The\n   DATA portion of\
    \ each 'mona' reply must exactly match the DATA portion\n   of the 'moni' that\
    \ is replied to.  Regardless of whether an\n   implementation chooses to send\
    \ 'moni' or not, 'mona' must be sent in\n   response to each 'moni' in order to\
    \ remain compliant with the TALI\n   protocol.\n   +------------------------------------------------------------------+\n\
    \   | Octets | Field Name  | Description                               |\n   +------------------------------------------------------------------+\n\
    \   | 0..3   | SYNC        | 'TALI'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 4..7   | OPCODE      | 'moni'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 8..9   | LENGTH      | Length                                    |\n   +------------------------------------------------------------------+\n\
    \   | 10..X  | DATA PAYLOAD| Vendor Dependent                          |\n   +------------------------------------------------------------------+\n"
- title: 3.2.1.6 Monitor Acknowledge Message (mona)
  contents:
  - "3.2.1.6 Monitor Acknowledge Message (mona)\n   As mentioned above, the 'mona'\
    \ must be sent in reply to each received\n   'moni'.  The contents of the 'mona'\
    \ DATA area must match the DATA\n   area of the received 'moni' message.\n   +------------------------------------------------------------------+\n\
    \   | Octets | Field Name  | Description                               |\n   +------------------------------------------------------------------+\n\
    \   | 0..3   | SYNC        | 'TALI'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 4..7   | OPCODE      | 'mona'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 8..9   | LENGTH      | Length                                    |\n   +------------------------------------------------------------------+\n\
    \   | 10..X  | DATA PAYLOAD| Vendor Dependent                          |\n   +------------------------------------------------------------------+\n"
- title: 3.2.2 Service Messages
  contents:
  - "3.2.2 Service Messages\n   The following subsections provide more information\
    \ regarding the TALI\n   Service messages that are implemented in version 1.0.\
    \  TALI Service\n   messages are used to carry SS7 MSUs across the IP network.\
    \  The\n   information in this section includes details with respect to how to\n\
    \   encapsulate SS7 MSUs into TCP/IP frames using each of the TALI\n   service\
    \ opcodes.  The TALI service messages originate at the layer\n   above TALI, are\
    \ transported across the IP network via a TALI service\n   message, and are delivered\
    \ to the layer above TALI at the far end of\n   the TALI connection.\n"
- title: 3.2.2.1 SCCP Service Message (sccp)
  contents:
  - "3.2.2.1 SCCP Service Message (sccp)\n   The 'sccp' opcode is used to deliver\
    \ SS7 MSUs with a Service\n   Indicator of 3 (SCCP) over a TALI connection.  This\
    \ opcode is only\n   used on TALI protocol stacks that are implemented without\
    \ SAAL.  The\n   MTP3 layer of the SS7 MSU is NOT part of the data transferred\
    \ across\n   TCP/IP for this opcode; the data portion of the TALI 'sccp' message\n\
    \   begins with the first byte of the SCCP data area in the SS7 MSU\n   (after\
    \ the MTP3 routing label).  The first byte in the SCCP data area\n   is an SCCP\
    \ message type field.\n   Several restrictions on the SCCP messages that this\
    \ TALI opcode can\n   carry exist.  These restrictions are as follows:\n   * \
    \ SCCP messages contain an SCCP message type field.  The SCCP\n      messages\
    \ that are supported by TALI 1.0 implementations are\n      limited to Class 0\
    \ and Class 1 SCCP messages with a message type\n      field of either:\n    \
    \  *  UDT\n      *  UDTS\n      *  XUDT\n      *  XUDTS\n   *  SCCP messages must\
    \ contain a Point Code in the 'calling party'\n      area in order to be transferred\
    \ across the TCP/IP connection as a\n      'sccp' message.  An implementation\
    \ may choose to modify the\n      original SCCP MSU to add an appropriate calling\
    \ party point code\n      before transmission across TALI if desired.\n   *  SCCP\
    \ messages must contain a Point Code in the 'called party' area\n      in order\
    \ to be transferred across the TCP/IP connection as a\n      'sccp' message. \
    \ An implementation may choose to modify the\n      original SCCP MSU to add an\
    \ appropriate called party point code\n      before transmission across TALI if\
    \ desired.\n   *  The encoding of the SS7 SCCP MSUs, as they are transmitted across\n\
    \      TALI via 'sccp', should remain compliant with the ANSI\n      specifications\
    \ (T1.112 and T1.114) that apply to the SCCP and TCAP\n      portions of the message\
    \ respectively.\n   NOTE 1: SCCP Subsystem Management for the IP based SCP's is\
    \ supported\n   via this 'sccp' opcode.  SS7 SCCP Management messages are controlled\n\
    \   by an SCMG SS7 process.  SCMG sends the management messages via SCCP\n   UNITDATA\
    \ (UDT) messages.  Therefore, the SCMG messages can be sent\n   across the TALI\
    \ connection.\n   NOTE 2: 'sccp' TALI messages will not include the MTP3 header\
    \ and\n   therefore will not retain the original DPC/OPC of the SS7 MSU.  Each\n\
    \   TALI implementation needs to consider if/how to provide this DPC/OPC\n   information\
    \ in the SCCP portion of the message.  For example the DPC\n   can be replicated\
    \ to the point code in the SCCP Called Party Address\n   area and the OPC can\
    \ be replicated to the point code in the SCCP\n   Calling Party Address area.\n\
    \   +------------------------------------------------------------------+\n   |\
    \ Octets | Field Name  | Description                               |\n   +------------------------------------------------------------------+\n\
    \   | 0..3   | SYNC        | 'TALI'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 4..7   | OPCODE      | 'sccp'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 8..9   | LENGTH      | Length                                    |\n   +------------------------------------------------------------------+\n\
    \   | 10..X  | SCCP Data   | SCCP data starting at the first byte after|\n   |\
    \        |             | the Layer 3 Routing Label (data does not  |\n   |   \
    \     |             | include the SIO or Routing Label)         |\n   +------------------------------------------------------------------+\n"
- title: 3.2.2.1.1 SCCP Encapsulation using TALI
  contents:
  - "3.2.2.1.1 SCCP Encapsulation using TALI\n   When an SCCP MSU arrives at an SG\
    \ from a 56 Kbps or DS1 link and is\n   routed within the SG for transmission\
    \ to an IP device, the SG\n   performs the following processing on the SS7 MSU:\n\
    \   *  discards the MTP Layer 2 information, CRC and flags\n   *  places the DPC\
    \ from MTP Layer 3 into the Called Party Address\n      field of the SCCP layer;\
    \ the Calling Party Address field is\n      created if it does not exist and then\
    \ filled\n   *  places the OPC from MTP Layer 3 into the Calling Party Address\n\
    \      field of the SCCP layer if there is no Calling Party Point Code\n   * \
    \ places the modified SCCP and unchanged TCAP data in the service\n      payload\
    \ area of the TALI packet\n   *  The SYNC field is set\n   *  The OPCODE is set\
    \ to 'sccp'\n   * The LENGTH is set to the number of octets in the SERVICE field\n\
    \   Once the fully formed 'sccp' TALI packet is created, it is handed to\n   the\
    \ TCP socket layer and transmitted.  The transmission process will\n   add TCP,\
    \ IP and MAC header information.\n   Since the routing information from MTP Layer\
    \ 3 is placed in the SCCP\n   part of the outgoing message, no routing information\
    \ needs to be\n   saved by the SG.\n                                SS7 MSU\n\
    \           |          Layer 3          |     Layer 2      |\n           |   \
    \                        |                  |\n      +----+---+-----+-----+-------+---+--+---+---+---+---+----+\n\
    \      |Flag|FCS|TCAP |SCCP |Routing|SIO|LI|FIB|FSN|BIB|BSN|Flag|\n      |   \
    \ |   |Layer|Layer| Label |   |  |   |   |   |   |    |\n      +----+---+-----+-----+-------+---+--+---+---+---+---+----+\n\
    \               |           |\n               |           |\n               |\
    \           |\n        TALI   +-----------+---+------+----+\n        Packet |\
    \  Service  |LEN|Opcode|SYNC|\n               +-----------+---+------+----+\n\
    \               |                           |\n               |              \
    \             |\n               |                           |\n              \
    \ +---------------------------+------+------+------+\n        IP     | TALI Packet\
    \               |TCP   | IP   | MAC  |\n        Packet |                     \
    \      |Header|Header|Header|\n               +---------------------------+------+------+------+\n\
    \   Figure 6: Encapsulation of SCCP MSUs using the TALI 'sccp' opcode\n   When\
    \ an 'sccp' TALI packet is received on by an SG from an IP device,\n   the SG\
    \ performs the following processing on the 'sccp' packet:\n   *  validates the\
    \ TALI header\n   *  Allocates space for a new SS7 message\n   *  Regenerates\
    \ the SIO with the Sub-Service Field set to National\n      Network, priority\
    \ of zero (0), Service Indicator set to SCCP\n   *  extracts the SCCP/TCAP data\
    \ from the SERVICE area and places it in\n      the new SS7 message\n   *  sets\
    \ the DPC to the SCCP Called Party Point Code\n   *  sets the OPC to the SCCP\
    \ Calling Party Point Code\n   *  randomly generates the SLS\n   Once the 'sccp'\
    \ packet is transformed back into a normal SS7 MSU, the\n   MSU is routed within\
    \ the SG according to the normal SS7 routing\n   procedures.\n"
- title: 3.2.2.2 ISUP Service Message (isot)
  contents:
  - "3.2.2.2 ISUP Service Message (isot)\n   The 'isot' opcode is used to deliver\
    \ SS7 MSUs with a Service\n   Indicator of 5 (ISUP) over a TALI connection.  This\
    \ opcode is only\n   used on TALI protocol stacks that are implemented without\
    \ SAAL.  The\n   MTP3 layer of the SS7 MSU IS part of the data transferred across\n\
    \   TCP/IP for this opcode; the data portion of the TALI 'isot' message\n   begins\
    \ with the SIO byte of the MTP3 header in the SS7 MSU.\n   +------------------------------------------------------------------+\n\
    \   | Octets | Field Name  | Description                               |\n   +------------------------------------------------------------------+\n\
    \   | 0..3   | SYNC        | 'TALI'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 4..7   | OPCODE      | 'isot'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 8..9   | LENGTH      | Length                                    |\n   +------------------------------------------------------------------+\n\
    \   | 10..X  | ISUP Data   | Raw ISUP data starting at the Layer 3 SIO |\n   |\
    \        |             | field.                                    |\n   +------------------------------------------------------------------+\n"
- title: 3.2.2.2.1 ISUP Encapsulation using TALI
  contents:
  - "3.2.2.2.1 ISUP Encapsulation using TALI\n   When an ISUP MSU arrives at an SG\
    \ from a 56 Kbps or DS1 link and is\n   routed within the SG to a IP device, the\
    \ SG performs the following\n   processing on the SS7 MSU:\n   *  discards the\
    \ MTP Layer 2 information, CRC and flags\n   *  places MTP Layer 3 into the SERVICE\
    \ payload area of the TALI\n      packet\n   *  The SYNC field is set\n   *  The\
    \ OPCODE is set to 'isot'\n   *  The LENGTH is set to the number of octets in\
    \ the SERVICE field\n   Once the fully formed 'isot' TALI packet is created, it\
    \ is handed to\n   the TCP socket layer and transmitted.  The transmission process\
    \ will\n   add TCP, IP and MAC header information.\n   Since the routing information\
    \ is placed in the TALI Packet, no\n   routing information needs to be saved by\
    \ the SG.\n                              SS7 MSU\n           |          Layer\
    \ 3            |     Layer 2      |\n           |                            \
    \ |                  |\n      +----+---+----+----+---+-------+---+--+---+---+---+---+----+\n\
    \      |Flag|FCS|ISUP|Msg.|CIC|Routing|SIO|LI|FIB|FSN|BIB|BSN|Flag|\n      | \
    \   |   |Part|Type|   |Label  |   |  |   |   |   |   |    |\n      +----+---+----+----+---+-------+---+--+---+---+---+---+----+\n\
    \               |                         /\n               |                \
    \        /\n               |                       |\n        TALI   +-----------------------+---+------+----+\n\
    \        Packet |  Service              |LEN|Opcode|SYNC|\n               +-----------------------+---+------+----+\n\
    \               |                                       /\n               |  \
    \                            ---------\n               |                     \
    \        /\n               +----------------------------+------+------+------+\n\
    \        IP     | TALI Packet                |TCP   | IP   | MAC  |\n        Packet\
    \ |                            |Header|Header|Header|\n               +----------------------------+------+------+------+\n\
    \     Figure 7: Encapsulation of ISUP MSUs using the TALI 'isot' opcode\n   When\
    \ an 'isot' TALI packet is received on an SG from an IP device,\n   the SG performs\
    \ the following processing on the 'isot' packet:\n   *  validates the TALI header\n\
    \   *  Allocates space for a new SS7 message\n   *  extracts the MTP Layer 3 data\
    \ from the SERVICE area and places it\n      in the new SS7 message\n   Once the\
    \ 'isot' packet is transformed back into a normal SS7 MSU, the\n   MSU is routed\
    \ within the SG according to the normal SS7 routing\n   procedures.\n"
- title: 3.2.2.3 MTP3 Service Message (mtp3)
  contents:
  - "3.2.2.3 MTP3 Service Message (mtp3)\n   The 'mtp3' opcode is used to deliver\
    \ SS7 MSUs with a Service\n   Indicator of 0-2, 4, 6-15 (non-SCCP, non-ISUP) over\
    \ a TALI\n   connection.  This opcode is only used on TALI protocol stacks that\n\
    \   are implemented without SAAL.  The MTP3 layer of the SS7 MSU IS part\n   of\
    \ the data transferred across TCP/IP for this opcode; the data\n   portion of\
    \ the TALI 'mtp3' message begins with the SIO byte of the\n   MTP3 header in the\
    \ SS7 MSU.\n   +------------------------------------------------------------------+\n\
    \   | Octets | Field Name  | Description                               |\n   +------------------------------------------------------------------+\n\
    \   | 0..3   | SYNC        | 'TALI'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 4..7   | OPCODE      | 'mtp3'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 8..9   | LENGTH      | Length                                    |\n   +------------------------------------------------------------------+\n\
    \   | 10..X  | Layer 3 MSU | Raw MSU data starting at the Layer 3 SIO  |\n   |\
    \        | Data        | field.                                    |\n   +------------------------------------------------------------------+\n"
- title: 3.2.2.3.1 MTP3 Encapsulation using TALI
  contents:
  - "3.2.2.3.1 MTP3 Encapsulation using TALI\n   When an SS7 MSU with SI=0-2,4,6-15\
    \ arrives at an SG from a 56 Kbps or\n   DS1 link and is routed within the SG\
    \ to an IP device, the SG performs\n   the following processing on the SS7 MSU:\n\
    \   *  discards the MTP Layer 2 information, CRC and flags\n   *  places MTP Layer\
    \ 3 into the SERVICE payload area of TALI packet\n   *  The SYNC field is set\n\
    \   *  The OPCODE is set to 'mtp3'\n   *  The LENGTH is set to the number of octets\
    \ in the SERVICE field\n   Once the fully formed 'mtp3' TALI packet is created,\
    \ it is handed to\n   the TCP socket layer and transmitted.  The transmission\
    \ process will\n   add TCP, IP and MAC header information.\n                 \
    \            SS7 MSU\n           |      Layer 3              |     Layer 2   \
    \   |\n           |                           |                  |\n      +----+---+-----------+-------+---+--+---+---+---+---+----+\n\
    \      |Flag|FCS|Other Layer|Routing|SIO|LI|FIB|FSN|BIB|BSN|Flag|\n      |   \
    \ |   |3 Data     |Label  |   |  |   |   |   |   |    |\n      +----+---+-----------+-------+---+--+---+---+---+---+----+\n\
    \               |                       /\n               |                 ------\n\
    \               |                /\n        TALI   +----------------+---+------+----+\n\
    \        Packet |  Service       |LEN|Opcode|SYNC|\n               +----------------+---+------+----+\n\
    \               |                                /\n               |         \
    \                     --\n               |                             /\n   \
    \            +----------------------------+------+------+------+\n        IP \
    \    | TALI Packet                |TCP   | IP   | MAC  |\n        Packet |   \
    \                         |Header|Header|Header|\n               +----------------------------+------+------+------+\n\
    \      Figure 8: Encapsulation of SS7 MSUs with SI!=3,5,13 using 'mtp3'\n   When\
    \ an 'mtp3' TALI packet is received by an SG from an IP device,\n   the SG performs\
    \ the following processing on the 'mtp3' packet:\n   *  validates the TALI header\n\
    \   *  Allocates space for a new SS7 message\n   *  extracts the MTP Layer 3 data\
    \ from the SERVICE area and places it\n      in the new SS7 message\n   Once the\
    \ 'mtp3' packet is transformed back into a normal SS7 MSU, the\n   MSU is routed\
    \ within the SG according to the normal SS7 routing\n   procedures.\n"
- title: 3.2.2.4 SAAL Service Message (saal)
  contents:
  - "3.2.2.4 SAAL Service Message (saal)\n   The 'saal' opcode is used to deliver\
    \ SS7 MSUs with any Service\n   Indicator over a TALI connection.  This opcode\
    \ is only used on TALI\n   protocol stacks that are implemented with SAAL.  The\
    \ 'saal' opcode is\n   also used to transmit SAAL peer to peer packets (SSCF peer\
    \ to peer\n   packets and SSCOP peer to peer packets other than SS7 service data)\n\
    \   over a TALI connection.\n   When used to transfer SS7 MSUs, the MTP3 layer\
    \ of the SS7 MSU IS part\n   of the data transferred across TCP/IP for this opcode;\
    \ the data\n   portion of the TALI 'saal' message begins with the SIO byte of\
    \ the\n   MTP3 header in the SS7 MSU and ends with the last byte of the SSCOP\n\
    \   trailer.\n   When used to transfer SSCF/SSCOP peer to peer messages the data\n\
    \   portion of the TALI 'saal' message includes the entire SSCOP PDU.\n   +------------------------------------------------------------------+\n\
    \   | Octets | Field Name  | Description                               |\n   +------------------------------------------------------------------+\n\
    \   | 0..3   | SYNC        | 'TALI'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 4..7   | OPCODE      | 'saal'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 8..9   | LENGTH      | Length                                    |\n   +------------------------------------------------------------------+\n\
    \   | 10..X  | Layer 3     | Raw MSU data starting at the Layer 3 SIO  |\n   |\
    \        | Data        | field.                                    |\n   +------------------------------------------------------------------+\n\
    \   | (X+1)  | SSCOP       | Zero (0) to three (3) octets of padding   |\n   |\
    \  ..Y   | Trailer     | plus 4 octets for the trailer data.  The  |\n   |   \
    \     |             | total length of the Layer 3 Data and the  |\n   |      \
    \  |             | SSCOP trailer must be a multiple of 4.    |\n   +------------------------------------------------------------------+\n\
    \                        or\n   +------------------------------------------------------------------+\n\
    \   | Octets | Field Name  | Description                               |\n   +------------------------------------------------------------------+\n\
    \   | 0..3   | SYNC        | 'TALI'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 4..7   | OPCODE      | 'saal'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 8..9   | LENGTH      | Length                                    |\n   +------------------------------------------------------------------+\n\
    \   | 10..X  | SAAL Peer   | Raw SSCF/SSCOP peer to peer packets are   |\n   |\
    \        | to Peer     | also transferred over the TALI connection |\n   |   \
    \     | message     | using this 'saal' opcode.                 |\n   +------------------------------------------------------------------+\n"
- title: 3.2.2.4.1 MTP3 and SAAL Peer to Peer Encapsulation using TALI
  contents:
  - "3.2.2.4.1 MTP3 and SAAL Peer to Peer Encapsulation using TALI\n   When an SS7\
    \ MSU (with any SI) arrives at an SG from a 56 Kbps or DS1\n   link and is routed\
    \ within the SG for transmission to an IP device,\n   the SG performs the following\
    \ processing on the SS7 MSU:\n   *  discards the MTP Layer 2 information, CRC\
    \ and flags\n   *  the MSU is passed from an MTP3 processing software layer to\
    \ the\n      SSCF and SSCOP layers (the SAAL layers).  These layers convert the\n\
    \      SS7 MSU into an SSCOP PDU.  Part of this conversion includes\n      adding\
    \ an SSCOP trailer.\n   *  the SSCOP PDU (whether it is a peer to peer SAAL message\
    \ or SS7\n      MSU in an SSCOP PDU) is copied into the SERVICE payload area of\n\
    \      the TALI packet\n   *  The SYNC field is set\n   *  The OPCODE is set to\
    \ 'saal'\n   *  The LENGTH is set to the number of octets in the SERVICE field\n\
    \   Once the fully formed 'saal' TALI packet is created, it is handed to\n   the\
    \ TCP socket layer and transmitted.  The transmission process will\n   add TCP,\
    \ IP and MAC header information.\n   Since the routing information is placed in\
    \ the TALI Packet, no\n   routing information needs to be saved by the SG.\n \
    \                              SS7 MSU\n           |          Layer 3        \
    \  |     Layer 2      |\n           |                           |            \
    \      |\n      +----+---+-----------+-------+---+--+---+---+---+---+----+\n \
    \     |Flag|FCS|Other Layer|Routing|SIO|LI|FIB|FSN|BIB|BSN|Flag|\n      |    |\
    \   |3 Data     |Label  |   |  |   |   |   |   |    |\n      +----+---+-----------+-------+---+--+---+---+---+---+----+\n\
    \               |                       |\n               |                  \
    \     |\n               |                       |\n       +-------+-----------------------+\n\
    \       |SSCOP  |  Service              |\n       |Trailer|                  \
    \     |\n       +-------+-----------------------+\n       |                  \
    \             |\n       +-------+-----------------------+---+------+----+\n  \
    \     |Service with SSCOP Trailer     |LEN|Opcode|SYNC|\n       +-------+-----------------------+---+------+----+\n\
    \       |                                               /\n       |          \
    \                    -----------------\n       |                             /\n\
    \       +----------------------------+------+------+------+\n       | TALI Packet\
    \                |TCP   | IP   | MAC  |\n       |                            |Header|Header|Header|\n\
    \       +----------------------------+------+------+------+\n   Figure 9: Encapsulation\
    \ of SAAL PDUs using the TALI 'saal' opcode\n   When an 'saal' TALI packet is\
    \ received at the SG from an IP device,\n   the SG performs the following processing\
    \ on the 'saal' packet:\n   *  validates the TALI header\n   *  Allocates space\
    \ for a new SSCOP PDU message\n   *  extracts the SSCOP PDU data from the SERVICE\
    \ area and places it in\n      the new SSCOP PDU message\n   Once the 'saal' packet\
    \ is transformed back into a normal DS1 SSCOP\n   PDU, the SSCOP PDU is passed\
    \ to the SAAL layer for receive\n   processing.  If the SSCOP PDU is a peer to\
    \ peer pdu, it is processed\n   completely in the appropriate SAAL layer.  If\
    \ the SSCOP PDU is an SS7\n   MSU, the MSU is transformed back to a normal SS7\
    \ MSU and is routed\n   within the SG according to the normal SS7 routing procedures.\n"
- title: 3.3 TALI Timers
  contents:
  - "3.3 TALI Timers\n   Version 1.0 of the TALI specification defined 4 TALI timers\
    \ that are\n   used as part of the TALI state machine.  These timers are generically\n\
    \   named 'T1' through 'T4'.  Brief descriptions of each timer are\n   provided\
    \ in the following subsections.  Timer expiration events for\n   each of the T1-T4\
    \ timers appear as inputs to the TALI state machine.\n   For exact processing\
    \ of each timer (when to start/stop, how to\n   process timer expirations), refer\
    \ to the TALI state machine.\n   Both ends of the TALI connection have there own\
    \ T1-T4 timers.  The\n   T1-T4 timer values can be set on each end of the connection\n\
    \   independent of the settings on the far end.  For each timer, a\n   default\
    \ value and range is recommended in the following sections.\n"
- title: 3.3.1 T1 Timer
  contents:
  - "3.3.1 T1 Timer\n   The T1 timer represents the time interval between the origination\
    \ of\n   a 'test' message at each TALI implementation.  Each time T1 expires,\n\
    \   the TALI implementation should send a 'test'.\n"
- title: 3.3.2 T2 Timer
  contents:
  - "3.3.2 T2 Timer\n   The T2 timer represents the amount of time that the Peer has\
    \ to\n   return an 'allo' or a 'proh' in response to a 'test'.  If the far end\n\
    \   fails to reply with 'allo' or 'proh' before T2 expires, the sender of\n  \
    \ the 'test' treats the T2 expiration as a protocol violation.  Note\n   that\
    \ T2 must be < T1 in order for these timers to work as designed.\n"
- title: 3.3.3 T3 Timer
  contents:
  - "3.3.3 T3 Timer\n   The T3 timer controls how long the near end should continue\
    \ to\n   process Service Data that is received from the far end after a\n   Management\
    \ Prohibit Traffic Event has occurred (at the near end).\n   This timer is used\
    \ when a transition from NEA-FEA (both ends allowed\n   to send service data)\
    \ to NEP-FEA (only far end willing to send\n   service data) occurs.  On that\
    \ transition, it is reasonable to expect\n   that the far end needs some amount\
    \ of time to adjust its TALI state\n   machine and divert service data traffic\
    \ away from this socket.  The\n   T3 timer controls the amount of time the far\
    \ end has to divert\n   traffic.\n"
- title: 3.3.4 T4 Timer
  contents:
  - "3.3.4 T4 Timer\n   The T4 timer represents the time interval between the origination\
    \ of\n   a 'moni' message at each TALI implementation.  Each time T4 expires,\n\
    \   the TALI implementation should send a 'moni'.\n"
- title: 3.3.5 Recommended Defaults and Ranges for the TALI Timers
  contents:
  - "3.3.5 Recommended Defaults and Ranges for the TALI Timers\n   The following table\
    \ provides the recommended default and configurable\n   range for each TALI timer.\n\
    \   +------------------------------------------------------------------+\n   |Name|\
    \  Min  |  Max  |Default| Description                         |\n   +------------------------------------------------------------------+\n\
    \   | T1 | 100ms | 60sec | 4 sec | Send test PDU timer                 |\n   +------------------------------------------------------------------+\n\
    \   | T2 | 100ms | 60sec | 3 sec | Response timer for an allo or proh  |\n   |\
    \    |       |       |       | response to test message.           |\n   +------------------------------------------------------------------+\n\
    \   | T3 | 100ms | 60sec | 5 sec | Timer controls how long to process  |\n   |\
    \    |       |       |       | rcvd serv data after an NE          |\n   |   \
    \ |       |       |       | transition from NEA to NEP.  System |\n   |    | \
    \      |       |       | is waiting for a proa response to   |\n   |    |    \
    \   |       |       | the first proh send when NE         |\n   |    |       |\
    \       |       | transitions from NEA to NEP.        |\n   +------------------------------------------------------------------+\n\
    \   | T4 | 100ms | 60sec |10 sec | Send moni PDU timer                 |\n   +------------------------------------------------------------------+\n\
    \                         Table 5: Timers\n   NOTE: The value of T1 must be at\
    \ least one (1) millisecond greater\n   than T2.  This is to prevent the system\
    \ from a lockup in the T1\n   expired condition.  If T1 is equal or less than\
    \ T2, it will expire\n   and restart T2 and not enforce responses to the test\
    \ message.\n   Enforcement of minimum and maximum timer values is implementation\n\
    \   dependent.\n"
- title: 3.4 TALI User Events
  contents:
  - "3.4 TALI User Events\n   Each TALI implementation must provide several user event\
    \ controls\n   over the behavior of the TALI state machine for each TALI connection.\n\
    \   The user interface to provide these capabilities is implementation\n   specific.\n"
- title: 3.4.1 Management Open Socket Event
  contents:
  - "3.4.1 Management Open Socket Event\n   The 'mgmt open socket' event, together\
    \ with the 'mgmt close socket'\n   event, allows the user to control when each\
    \ defined TALI connection\n   will form a TCP socket connection.  When 'open socket'\
    \ for a\n   particular TALI connection occurs, the TALI connection should begin\n\
    \   trying to form a TCP socket connection to the peer.\n   The steps that are\
    \ taken to connect are dependent on the\n   client/server role of that end of\
    \ the TALI connection.  The exact\n   steps to perform these tasks are implementation\
    \ dependent and may\n   differ based on the TCP stack being used.\n   In general,\
    \ TALI clients form socket connections by using the BSD\n   sockets calls:\n \
    \        Socket()\n         Bind()\n         Connect()\n   In general, TALI servers\
    \ form socket connections by using the BSD\n   sockets calls:\n         Socket()\n\
    \         Bind()\n         Listen()\n         Accept()\n"
- title: 3.4.2 Management Close Socket Event
  contents:
  - "3.4.2 Management Close Socket Event\n   The 'mgmt close socket' event can be\
    \ issued by the user when it is\n   desired that the TCP socket for a TALI socket,\
    \ be closed immediately,\n   or discontinue its attempts to connect to the peer.\
    \  After acting on\n   'close socket', the TALI connection will not be established\
    \ until\n   'mgmt open socket' is issued.\n"
- title: 3.4.3 Management Allow Traffic Event
  contents:
  - "3.4.3 Management Allow Traffic Event\n   The 'mgmt allow traffic' event, together\
    \ with the 'mgmt prohibit\n   traffic' event, allows the user to control when\
    \ each defined TALI\n   connection will be willing to carry SS7 service data over\
    \ that\n   particular TALI connection.  When 'mgmt allow traffic' is issued, the\n\
    \   TALI implementation becomes willing to carry service data.  The TALI\n   state\
    \ for the near end should transition to NEA (near end allowed) if\n   the connection\
    \ is already established.\n"
- title: 3.4.4 Management Prohibit Traffic Event
  contents:
  - "3.4.4 Management Prohibit Traffic Event\n   The 'mgmt prohibit traffic' event\
    \ is the opposite of 'allow traffic'.\n   When 'mgmt prohibit traffic' is issued,\
    \ the TALI implementation\n   becomes un-willing to carry SS7 service data over\
    \ that particular\n   TALI connection.  The TALI state for the near end should\
    \ transition\n   to NEP (near end prohibited) if the connection is already\n \
    \  established.\n"
- title: 3.5 Other Implementation Dependent TALI Events
  contents:
  - "3.5 Other Implementation Dependent TALI Events\n   In addition to timers, each\
    \ TALI implementation needs to be able to\n   detect, and react accordingly, for\
    \ the following events:\n   *  Connection Established.  When the TCP socket connection\
    \ is\n      initially established the TALI state machine must be notified.\n \
    \  *  Connection Lost.  When the TCP socket connection is lost, due to\n     \
    \ socket errors during reads/writes, the TALI state machine must be\n      notified.\n\
    \   *  Protocol Violations.  Any violation of the TALI protocol as\n      discussed\
    \ in 3.7.1.3.\n"
- title: 3.6 TALI States
  contents:
  - "3.6 TALI States\n   The TALI version 1.0 specification is based on a state machine\
    \ that\n   considers 6 TALI states.  Each end of the TALI connection maintains\n\
    \   its own TALI state.\n   +------------------------------------------------------------------+\n\
    \   | Name       | Description                                         |\n   +------------------------------------------------------------------+\n\
    \   | OOS        | The TALI connection is out of service.  This usually|\n   |\
    \            | corresponds to a user event to 'close' the socket,  |\n   |   \
    \         | or a user event to 'deactivate the SS7 link'.       |\n   +------------------------------------------------------------------+\n\
    \   | Connecting | The TALI layer is attempting to establish a TCP     |\n   |\
    \            | socket connection to the peer.  Servers are         |\n   |   \
    \         | 'accepting', clients are 'connecting'.              |\n   +------------------------------------------------------------------+\n\
    \   | NEP-FEP    | The TCP socket connection is established.  Neither  |\n   |\
    \            | side of the connection is ready to use the socket   |\n   |   \
    \         | for service PDUs.                                   |\n   +------------------------------------------------------------------+\n\
    \   | NEP-FEA    | The TCP socket connection is established.  The NE is|\n   |\
    \            | not ready to use the socket for service PDUs.  The  |\n   |   \
    \         | FE is ready to use the socket for service PDUs.     |\n   +------------------------------------------------------------------+\n\
    \   | NEA-FEP    | The TCP socket connection is established.  The NE is|\n   |\
    \            | ready to use the socket for service PDUs.  The FE is|\n   |   \
    \         | not ready to use the socket for service PDUs.       |\n   +------------------------------------------------------------------+\n\
    \   | NEA-FEA    | The TCP socket connection is established.  Both     |\n   |\
    \            | sides are ready to use the socket for service PDUs. |\n   |   \
    \         | This is the only state where normal bi-directional  |\n   |      \
    \      | SS7 data transfer occurs.                           |\n   +------------------------------------------------------------------+\n\
    \                              Table 6: TALI States\n"
- title: 3.7 TALI Version 1.0 State Machine
  contents:
  - "3.7 TALI Version 1.0 State Machine\n   This section provides the state machine\
    \ that must be followed by each\n   TALI implementation in order to be compliant\
    \ with this specification.\n"
- title: 3.7.1 State Machine Concepts
  contents:
  - "3.7.1 State Machine Concepts\n   Before presenting the actual state machine,\
    \ several concepts are\n   discussed.\n"
- title: 3.7.1.1 General Protocol Rules
  contents:
  - "3.7.1.1 General Protocol Rules\n   1.  Neither side can send service data unless\
    \ both sides are allowed.\n   2.  Each side initializes to the prohibited state\
    \ for both near end\n       and far end.\n   3.  State changes between the NEx-FEx\
    \ states are signaled with either\n       an 'allo' or 'proh'.\n   4.  Each side\
    \ can poll the far end's state with a 'test'.  Upon\n       sending 'test', T1\
    \ and T2 should always be restarted.\n   5.  Each side polls the far end with\
    \ a 'test' every T1 expiration.\n   6.  The reply to a 'test' is based on the\
    \ state of the near end only.\n   7.  The reply to a 'test' is either 'allo' or\
    \ 'proh'.\n   8.  A far end signals the last service PDU has been transmitted\
    \ with\n       either a 'proh' or a 'proa'.\n   9.  Upon receiving a 'proh', the\
    \ receiver must always reply with\n       'proa'.\n   10. The NE cannot gracefully\
    \ close a socket unless a 'proh' is sent\n       and 'proa' is received.\n   11.\
    \ On the transition from NEA to NEP, after sending a 'proh', the\n       near\
    \ end must continue to process received service data until a\n       'proa' is\
    \ received or until a T3 timer expires.\n"
- title: 3.7.1.2 Graceful Shutdown of a Socket
  contents:
  - "3.7.1.2 Graceful Shutdown of a Socket\n   The state table treats a management\
    \ request to close the socket as a\n   'hard' shutdown.  That is, it will close\
    \ the socket immediately\n   regardless of the current state.  Therefore, the\
    \ correct steps to\n   ensure a graceful shutdown of a socket (from the NEA_FEP\
    \ or NEA_FEA\n   states) is:\n   1. Management issues a Management Prohibit Traffic\
    \ Event on the\n      socket.\n   2. Management will wait for T3 to expire.\n\
    \   3. Management can then issue a Close Socket Event on the socket.\n"
- title: 3.7.1.3 TALI Protocol Violations
  contents:
  - "3.7.1.3 TALI Protocol Violations\n   Each TALI implementation must detect when\
    \ violations of the TALI\n   protocol have occurred and react accordingly.  Protocol\
    \ violations\n   include:\n   *  Invalid sync code in a received message\n   *\
    \  Invalid opcode in a received message\n   *  Invalid length field in a received\
    \ message\n   *  Not receiving an 'allo' or 'proh', in response to the origination\n\
    \      of a 'test' , before the T2 timer expires\n   *  Receiving Service Messages\
    \ on a prohibited socket.\n   *  TCP Socket errors - Connection Lost\n   In the\
    \ state machine that follows, State/Event combinations that\n   should be treated\
    \ as protocol violations are indicated via a 'PV' in\n   the state/event cell.\
    \  All of the 'PV' events are then processed as\n   per the 'Protocol Violation'\
    \ row in the table.\n"
- title: 3.7.2 The State Machine
  contents:
  - "3.7.2 The State Machine\n   Internal Data required for State Machine:\n   boolean\
    \ sock_allowed.  This flag indicates whether the NE is allowed\n   to carry Service\
    \ Messages.\n   Initial Conditions:\n   sock_allowed = FALSE\n   state = OOS\n\
    \   no timers running\n   +------------------------------------------------------------------+\n\
    \   |   State| OOS  |Connecting| NEP-FEP | NEP-FEA | NEA-FEP | NEA-FEA |\n   |Event\
    \   |      |          |         |         |         |         |\n   +------------------------------------------------------------------+\n\
    \   |T1 Exp. |      |          |Send test|Send test|Send test|Send test|\n   |\
    \        |      |          |Start T1 |Start T1 |Start T1 |Start T1 |\n   |   \
    \     |      |          |Start T2 |Start T2 |Start T2 |Start T2 |\n   +------------------------------------------------------------------+\n\
    \   |T2 Exp. |      |          |   PV    |   PV    |   PV    |   PV    |\n   +------------------------------------------------------------------+\n\
    \   |T3 Exp. |      |          |   PV    |   PV    |         |         |\n   +------------------------------------------------------------------+\n\
    \   |T4 Exp. |      |          |Send moni|Send moni|Send moni|Send moni|\n   |\
    \        |      |          |Start T4 |Start T4 |Start T4 |Start T4 |\n   +------------------------------------------------------------------+\n\
    \   |Rcv test|      |          |Send proh|Send proh|Send allo|Send allo|\n   +------------------------------------------------------------------+\n\
    \   |Rcv allo|      |          | Stop T2 | Stop T2 | Stop T2 | Stop T2 |\n   |\
    \        |      |          | NEP-FEA |         | NEA-FEA |         |\n   +------------------------------------------------------------------+\n\
    \   |Rcv proh|      |          | Stop T2 | Stop T2 | Stop T2 | Stop T2 |\n   |\
    \        |      |          |Send proa|Send proa|Send proa|Flush or |\n   |   \
    \     |      |          |         | NEP-FEP |         | reroute |\n   |      \
    \  |      |          |         |         |         |Send proa|\n   |        |\
    \      |          |         |         |         | NEA-FEP |\n   +------------------------------------------------------------------+\n\
    \   |Rcv proa|      |          | Stop T3 | Stop T3 |         |         |\n   +------------------------------------------------------------------+\n\
    \   |Rcv moni|      |          |Convert  |Convert  |Convert  |Convert  |\n   |\
    \        |      |          | to mona | to mona | to mona | to mona |\n   |   \
    \     |      |          |Send mona|Send mona|Send mona|Send mona|\n   +------------------------------------------------------------------+\n\
    \   |Rcv mona|      |          |Implemen-|Implemen-|Implemen-|Implemen-|\n   |\
    \        |      |          |tation   |tation   |tation   |tation   |\n   |   \
    \     |      |          |dependent|dependent|dependent|dependent|\n   +------------------------------------------------------------------+\n\
    \   |Rcv     |      |          |   PV    |If T3 run|   PV    |Process  |\n   |\
    \ Service|      |          |         | Process |         |         |\n   |   \
    \     |      |          |         |Else PV  |         |         |\n   +------------------------------------------------------------------+\n\
    \   |Connect.|      | Start T1 |         |         |         |         |\n   |Estab.\
    \  |      | Start T2 |         |         |         |         |\n   |        |\
    \      | Start T4 |         |         |         |         |\n   |        |   \
    \   |(if non-0)|         |         |         |         |\n   |        |      |if\
    \ sock_  |         |         |         |         |\n   |        |      |  allowed\
    \ |         |         |         |         |\n   |        |      |  = TRUE  | \
    \        |         |         |         |\n   |        |      | send allo|    \
    \     |         |         |         |\n   |        |      | send test|       \
    \  |         |         |         |\n   |        |      | NEA-FEP  |         |\
    \         |         |         |\n   |        |      |else      |         |   \
    \      |         |         |\n   |        |      | send proh|         |      \
    \   |         |         |\n   |        |      | send test|         |         |\
    \         |         |\n   |        |      | NEP-FEP  |         |         |   \
    \      |         |\n   +------------------------------------------------------------------+\n\
    \   |Connect.|      |          |   PV    |   PV    |   PV    |   PV    |\n   |Lost\
    \    |      |          |         |         |         |         |\n   +------------------------------------------------------------------+\n\
    \   |Protocol|      |          |Stop all |Stop all |Stop all |Stop all |\n   |Violat.\
    \ |      |          | timers  | timers  | timers  | timers  |\n   |        | \
    \     |          |Close the|Close the|Close the|Close the|\n   |        |    \
    \  |          | socket  | socket  | socket  | socket  |\n   |        |      |\
    \          |Connect- |Connect- |Connect- |Connect- |\n   |        |      |   \
    \       |  ing    |  ing    |  ing    |  ing    |\n   +------------------------------------------------------------------+\n\
    \   |Mgmt.   |Open  |          |         |         |         |         |\n   |Open\
    \    |socket|          |         |         |         |         |\n   |Socket \
    \ |Conne-|          |         |         |         |         |\n   |        | cting|\
    \          |         |         |         |         |\n   +------------------------------------------------------------------+\n\
    \   |Mgmt.   |      |Close the |Stop all |Stop all |Stop all |Stop all |\n   |Close\
    \   |      | socket   | timers  | timers  | timers  | timers  |\n   |Socket  |\
    \      |OOS       |Close the|Close the|Close the|Close the|\n   |        |   \
    \   |          | socket  | socket  | socket  | socket  |\n   |        |      |\
    \          |OOS      |OOS      |OOS      |OOS      |\n   +------------------------------------------------------------------+\n\
    \   |Mgmt.   |sock_ |sock_allo-|sock_all-|sock_all-|sock_all-|sock_all-|\n   |Prohibit|allow-|\
    \ wed=FALSE| owed=   | owed=   | owed=   | owed=   |\n   |Socket  |ed =  |   \
    \       | FALSE   | FALSE   | FALSE   | FALSE   |\n   |        |FALSE |      \
    \    |         |         |send proh|send proh|\n   |        |      |         \
    \ |         |         |start t3 |start t3 |\n   |        |      |          | \
    \        |         | NEP-FEP | NEP-FEA |\n   |        |      |          |    \
    \     |         |         |         |\n   +------------------------------------------------------------------+\n\
    \   |Mgmt.   |sock_ |sock_allo-|sock_all-|sock_all-|sock_all-|sock_all-|\n   |Allow\
    \   |allow-| wed=TRUE | owed=   | owed=   | owed=   | owed=   |\n   |Traffic |ed\
    \ =  |          | TRUE    | FALSE   | TRUE    | TRUE    |\n   |        |TRUE \
    \ |          |send allo|send allo|         |         |\n   |        |      | \
    \         | NEA-FEP | NEA-FEA |         |         |\n   +------------------------------------------------------------------+\n\
    \   |User    |reject| reject   | reject  | reject  | reject  | send    |\n   |Part\
    \    |data  | data     | data    | data    | data    | data    |\n   |Msgs.  \
    \ |      |          |         |         |         |         |\n   +------------------------------------------------------------------+\n\
    \                     Table 7: TALI 1.0 State Machine\n"
- title: 3.8 TALI 1.0 Implementation Notes
  contents:
  - "3.8 TALI 1.0 Implementation Notes\n   Several aspects of the expected TALI 1.0\
    \ implementation have not been\n   specifically addressed in the state machine\
    \ or previous text (or else\n   they were presented but will be reiterated here).\
    \  These\n   implementation notes in some cases have to do with the expected\n\
    \   behavior of the software layer above the TALI layer.\n"
- title: 3.8.1 Failure on a TCP/IP Socket
  contents:
  - "3.8.1 Failure on a TCP/IP Socket\n   *  The failure to read or write from a TCP\
    \ socket shall be detected\n      and generate a connection lost event.\n"
- title: 3.8.2 Congestion on a TCP/IP Socket
  contents:
  - "3.8.2 Congestion on a TCP/IP Socket\n   *  Message streams can be monitored for\
    \ congestion via implementation\n      dependent methods.\n   *  One possible\
    \ definition of congestion for the previous requirement\n      might be when a\
    \ TCP socket is blocked.\n"
- title: 3.9 TALI 1.0 Limitations
  contents:
  - "3.9 TALI 1.0 Limitations\n   Several limitations with the TALI 1.0 specification\
    \ and\n   implementation are identified:\n   *  For SCCP traffic, only UDT and\
    \ XUDT Class 0 and Class 1 traffic\n      should be managed by this protocol.\n\
    \   *  When the MTP3 Routing Label is not part of the data transmitted\n     \
    \ across the wire, priority zero (0) traffic is used for all traffic\n      when\
    \ the SIO is regenerated.\n"
- title: 4. TALI Version 2.0
  contents:
  - "4. TALI Version 2.0\n   Version 2.0 of the TALI specification provides several\
    \ additions to\n   the Version 1.0 specification.  The 2.0 additions are provided\
    \ by\n   introducing three new TALI opcodes.  The basic functionality and most\n\
    \   of the details of the TALI 1.0 implementation are NOT changed by the\n   2.0\
    \ additions.\n   The table below provides a summary of the messages and message\n\
    \   structure used in TALI version 2.0.\n   +------------------------------------------------------------------+\n\
    \   | OCTET | DESCRIPTION           | SIZE     | VALUE  |    TYPE      |\n   +------------------------------------------------------------------+\n\
    \   | 0..3  | SYNC                  | 4 Octets |        | 4 byte ASCII |\n   +------------------------------------------------------------------+\n\
    \   |       |   TALI                |          | 'TALI' |              |\n   +------------------------------------------------------------------+\n\
    \   | 4..7  | OPCODE                | 4 Octets |        | 4 byte ASCII |\n   +------------------------------------------------------------------+\n\
    \   |       |   Test Service        |          | 'test' |              |\n   |\
    \       |   Allow Service       |          | 'allo' |              |\n   |   \
    \    |   Prohibit Service    |          | 'proh' |              |\n   |      \
    \ |   Prohibit Service Ack|          | 'proa' |              |\n   |       | \
    \  Monitor Socket      |          | 'moni' |              |\n   |       |   Monitor\
    \ Socket Ack  |          | 'mona' |              |\n   |       |   SCCP Service\
    \        |          | 'sccp' |              |\n   |       |   ISUP Service o/TALI\
    \ |          | 'isot' |              |\n   |       |   MTP3 Service o/TALI | \
    \         | 'mtp3' |              |\n   |       |   Service o/SAAL      |    \
    \      | 'saal' |              |\n   |       |   Management Message  |       \
    \   | 'mgmt' |              |\n   |       |   Extended Service Msg|          |\
    \ 'xsrv' |              |\n   |       |   Special Message     |          | 'spcl'\
    \ |              |\n   +------------------------------------------------------------------+\n\
    \   | 8..9  | LENGTH                | 2 Octets |        | integer      |\n   |\
    \       |   (least significant  |          |        |              |\n   |   \
    \    |    byte first) non-0  |          |        |              |\n   |      \
    \ |    if Service or      |          |        |              |\n   |       | \
    \   Socket monitor msg |          |        |              |\n   +------------------------------------------------------------------+\n\
    \   | 10..X | DATA PAYLOAD          | variable |        | variable     |\n   +------------------------------------------------------------------+\n\
    \   Due to the minimal amount of change from 1.0, this chapter will only\n   provide:\n\
    \   *  Detailed information regarding how a TALI implementation can\n      identify\
    \ itself as a 2.0 vs. a 1.0 implementation\n   *  Detailed information regarding\
    \ how to provide backward\n      compatibility for a connection to a far end that\
    \ is only TALI 1.0\n      capable\n   *  Detailed information regarding the new\
    \ 2.0 opcodes\n   *  Detailed information regarding any other changes to the\n\
    \      information presented in previous sections that need to be\n      implemented\
    \ in order to be 2.0 compatible.\n   Therefore, readers of this chapter should\
    \ read this from the point of\n   view of modifying an existing TALI 1.0 implementation\
    \ to support the\n   new 2.0 features.\n"
- title: 4.1 Overview of TALI Version 2.0 Features
  contents:
  - "4.1 Overview of TALI Version 2.0 Features\n   A small number of changes to a\
    \ 1.0 TALI implementation are required\n   to support 2.0.  Figure 10 illustrates\
    \ the inputs that affect the 2.0\n   TALI State Machine.  The reader may notice\
    \ that the only differences\n   from the inputs for 1.0 are as follows:\n   Three\
    \ new TALI opcodes can be sent/received between a TALI node and\n   its peer.\
    \  The new opcodes are:\n   *  'mgmt'\n   *  'xsrv'\n   *  'spcl'\n   Three new\
    \ User Part capabilities need to be supported by the layer of\n   code above the\
    \ TALI layer in each implementation.  The user part\n   needs to provide support\
    \ for 'mgmt', 'xsrv', and 'spcl' data.\n   More information about the 3 new opcodes\
    \ is provided in individual\n   sections in this chapter.  However, a brief description\
    \ of the\n   purpose of each of these opcodes is as follows:\n   *  'mgmt' - This\
    \ opcode is intended to allow MANAGEMENT data, or data\n      that will manage\
    \ the operation of the device, to pass between the\n      TALI endpoints.  Examples\
    \ of this management data include:\n      *  configuration data, such as which\
    \ SS7 traffic streams a peer\n         would like to receive over a specific socket\n\
    \      *  SS7 Network Management data, such as information regarding\n       \
    \  point code (un)availability and congestion.\n      *  Enabling/disabling various\
    \ socket options, such as options\n         regarding which messages are supported,\
    \ or how to format data.\n   *  'xsrv' - Extended Service Opcodes.  It is envisioned\
    \ that the TALI\n      protocol could be extended to carry other types of traffic\
    \ that\n      are not covered by the 1.0 service data opcodes ('sccp', 'isot',\n\
    \      'mtp3', or 'saal').  By defining a new 'xsrv' service opcode, the\n   \
    \   TALI protocol is opened up to the possibility of being used for\n      other\
    \ types of data transport.\n   *  'spcl' - Special services.  It is envisioned\
    \ that vendors may want\n      to build special services into their TALI implementations\
    \ that are\n      only activated when the implementation is connected to other\n\
    \      equipment implementing the same special services.  This opcode is\n   \
    \   intended to provide a general means to discover more information\n      regarding\
    \ who the TALI session is connected to, and a means to\n      enable special features\
    \ based on the vendor/implementation on the\n      far end.\n   +====+    +---------+\
    \                    +============+\n   |    |    | Service | +-------------+\
    \    |            |\n   |User|    | Message,| | Mgmt. Open  |    | MANAGEMENT\
    \ |\n   |Part|<-->| MGMT,   | | Mgmt. Close |<-->|            |\n   |    |   \
    \ | XSRV,   | | Mgmt. Proh. |    |            |\n   |    |    | SPCL    | | Mgmt.\
    \ Allow |    +============+\n   +====+    +---------+ +-------------+\n      \
    \             ^            ^\n                   |            |\n            \
    \       v            v\n   +========================================================+\n\
    \   |                 TALI State Machine                     |\n   +========================================================+\n\
    \         ^               ^                 ^             ^\n         |      \
    \         |                 |             |\n         v               |      \
    \           |             |\n    +---------+          |                 |    \
    \         |\n    | Received|   +-----------------+ +-----------+ +------------+\n\
    \    | 'test', |   | Connection est. | | Protocol  | | T1 Expired |\n    | 'allo',\
    \ |   | Connection lost | | Violation | | T2 Expired |\n    | 'proh', |   |  \
    \               | |           | | T3 Expired |\n    | 'proa', |   +-----------------+\
    \ +-----------+ | T4 Expired |\n    | 'moni', |          ^                  ^\
    \       +------------+\n    | 'mona', |          |                  |        \
    \     ^\n    | 'mgmt', |          |                  |             |\n    | 'xsrv',\
    \ |          |                  |             |\n    | 'spcl', |          |  \
    \                |             |\n    |   or    |    +========================================+\n\
    \    | Service |    |         IMPLEMENTATION                 |\n    | Message\
    \ |    |           DEPENDENT                    |\n    +---------+    +========================================+\n\
    \         ^\n         |\n         v\n     +============+\n     |    PEER    |\n\
    \     |            |\n     +============+\n     Figure 10: Overview of Inputs\
    \ to the TALI 2.0 State Machine\n"
- title: 4.2 TALI Version Identification
  contents:
  - "4.2 TALI Version Identification\n   The TALI 1.0 specification did not provide\
    \ a simple means to perform\n   TALI version identification.  However, the general\
    \ purpose 'moni'\n   message from 1.0 can be used to solve this problem in 2.0.\n\
    \   Recall from 1.0 that the 'moni' message was very loosely defined in\n   the\
    \ 1.0 spec:\n   *  The primary purpose of the 'moni' message was to provide a\
    \ general\n      purpose ECHO capability.  It was envisioned that an important\
    \ task\n      that the ECHO capability could provide would be to measure Round\n\
    \      Trip TALI/TALI processing time.\n   *  The data portion of the 'moni' message\
    \ could be from 0-200 bytes\n      long.  The use of the data area was completely\
    \ implementation\n      specific.\n   *  There were no requirements that an implementation\
    \ ever send a\n      'moni'.\n   *  If an implementation did send 'moni', it should\
    \ use the T4 timer\n      to control the frequency of the outgoing 'moni'.\n \
    \  *  The receiver of the 'moni' should not make any assumptions as to\n     \
    \ the data portion of the 'moni'.  The receiver should simply\n      convert the\
    \ 'moni' into a 'mona' and return the message with the\n      same data portion.\n\
    \   TALI 2.0 implementations should use the 'moni' message to provide\n   version\
    \ identification as per the following bullets:\n   *  The primary purpose of the\
    \ 'moni' message is now twofold:\n   *  To provide version identification\n  \
    \    *  To continue to provide a general purpose ECHO capability that\n      \
    \   can be used to measure Round Trip time or perform other\n         implementation\
    \ specific tasks.\n   *  The data portion of the 'moni' message is now divided\
    \ into 2\n      portions\n      *  A portion dedicated to version identification,\
    \ 12 bytes long,\n         with a specific format that must be followed\n    \
    \  *  Followed by a free format section that can be used in a\n         completely\
    \ implementation specific manner.\n   *  The overall length of the data portion\
    \ for a 'moni' should still\n      not exceed 200 bytes.  This is required to\
    \ maintain backward\n      compatibility with 1.0 implementations that may check\
    \ for a\n      maximum length of 200 bytes on the 'moni' opcode.\n   *  If a TALI\
    \ implementation wants to identify itself as a version 2.0\n      node, it must\
    \ send a 'moni' encoded as per Table 8.  Every 'moni'\n      it sends should conform\
    \ to the encoding in Table 8.  The version\n      label should not change from\
    \ 'moni' to 'moni'.  The data following\n      the version label can change from\
    \ 'moni' to 'moni' and can\n      continue to be used for RTT calculations, or\
    \ other purposes.\n   *  If a TALI implementation is trying to determine if the\
    \ far end of\n      the TALI connection has implemented version 2.0, the\n   \
    \   implementation must examine any received 'moni' messages that\n      arrive\
    \ from the far end and see if they conform to the new\n      stricter 'moni' encoding\
    \ in Table 8.  On receiving 'moni', a TALI\n      2.0 node will compare the 12\
    \ bytes of data in the VER LABEL field\n      with a list of predetermined strings\
    \ to determine the\n      functionality of the TALI node it is connected to. \
    \ If the data\n      doesn't match any of the predetermined strings, the Far End\
    \ is\n      assumed to be a TALI 1.0 node.\n   *  Each TALI implementation must\
    \ assume that the far end of the\n      connection is a 1.0 implementation until\
    \ an arriving 'moni'\n      announces that the far end supports TALI version 2.0.\
    \  If a 'moni'\n      never arrives, the implementation knows the far end has\n\
    \      implemented version 1.0 of the specification.\n   *  TALI 1.0 implementations\
    \ can receive newly encoded 'moni' messages\n      and simply ignore the data.\
    \  The 1.0 implementations will continue\n      to operate as if the far end is\
    \ always a 1.0 node (ignore the data\n      portion of the 'moni', convert 'moni'\
    \ to 'mona', and return the\n      'mona').\n   *  The next section provides more\
    \ information regarding backwards\n      compatibility (2.0 implementations connected\
    \ to devices that\n      implemented version 1.0 of the specification).\n   +------------------------------------------------------------------+\n\
    \   | Octets | Field Name  | Description                  | Field Type |\n   +------------------------------------------------------------------+\n\
    \   | 0..3   | SYNC        | 'TALI'                       |4 byte ASCII|\n   +------------------------------------------------------------------+\n\
    \   | 4..7   | OPCODE      | 'moni'                       |4 byte ASCII|\n   +------------------------------------------------------------------+\n\
    \   | 8..9   | LENGTH      | Length (includes the version | Integer    |\n   |\
    \        |             | label and data fields)       |            |\n   +------------------------------------------------------------------+\n\
    \   | 10..21 | Ver. Label  | 'vers xxx.yyy'               | 12 byte    |\n   |\
    \        | See note    |                              | ASCII      |\n   +------------------------------------------------------------------+\n\
    \   | 22..X  | DATA        | Vendor Dependent             | Variable   |\n   |\
    \        |             | Maximum length of this       |            |\n   |   \
    \     |             | message (as coded in octets 8|            |\n   |      \
    \  |             | -9, and stored in bytes 10-X)|            |\n   |        |\
    \             | should not exceed 200 bytes. |            |\n   +------------------------------------------------------------------+\n\
    \               Table 8: Version Control 'moni' Message\n   NOTE: xxx.yyy = provides\
    \ the Major and Minor release number of the\n                   TALI specification\
    \ being implemented.\n         001.000 = Tali version 1.0\n         002.000 =\
    \ Tali version 2.0     // this specification.\n         002.001 = Tali version\
    \ 2.1     // a minor change to 2.0\n         003.000 = Tali version 3.0\n    \
    \     and so on.\n   The 'vers 002.000' field is an 12 byte field of field type\
    \ 'ascii\n   text'.  As such, 'v' should be the first byte of the field that is\n\
    \   transmitted out the wire.\n"
- title: 4.3 Backwards Compatibility
  contents:
  - "4.3 Backwards Compatibility\n   As part of adding new functionality to the TALI\
    \ specification,\n   backwards compatibility from TALI version 2.0 to version\
    \ 1.0 is\n   required.  Backwards compatibility is important since TALI 2.0 nodes\n\
    \   may be connected to far ends that only support version 1.0; it is\n   important\
    \ that these 2 implementations continue to inter-operate, and\n   that the 2.0\
    \ node falls back to supporting only 1.0 opcodes in this\n   situation.\n   The\
    \ previous section described how a TALI 2.0 implementation can use\n   the 'moni'\
    \ it sends to identify itself as a 2.0 node and how it can\n   use the 'moni'\
    \ it receives to determine if the far end is also a 2.0\n   node.  In addition\
    \ to the discussion in the previous section, the\n   following bullets provide\
    \ details regarding how backwards\n   compatibility must be achieved:\n   *  As\
    \ documented in the version 1.0 specification, TALI 1.0\n      implementations\
    \ that receive TALI messages with 'mgmt', 'xsrv',\n      and 'spcl' opcodes will\
    \ treat the message as a Protocol Violation\n      (invalid opcode received).\
    \  The Protocol Violation will cause the\n      socket to be dropped immediately.\n\
    \   *  It is therefore required that a 2.0 implementation only send\n      'mgmt',\
    \ 'xsrv', and 'spcl' opcodes, after it has used a received\n      'moni' message\
    \ to determine that the far end is a 2.0 (or later)\n      implementation and\
    \ has identified itself as a 2.0 (or later)\n      implementation.\n   *  Each\
    \ TALI 2.0 implementations must use the 'moni' as described in\n      the previous\
    \ section to identify themselves as 2.0, and to learn\n      if the far end is\
    \ 2.0.\n   *  Each TALI 2.0 implementation should maintain a variable as part\
    \ of\n      its state machine, 'far_end_version'.  The 'far_end_version'\n   \
    \   should be initialized to 1.0 when the socket is established.  Each\n     \
    \ time a 2.0 implementation receives 'moni', it should update the\n      'far_end_version'\
    \ variable.  If the 'moni' did not contain a\n      version label, the 'far_end_version'\
    \ should be reset to 1.0.  If\n      the 'moni' did contain a version label for\
    \ 2.0 (or a later\n      version), the 'far_end_version' should be set accordingly.\n\
    \   *  Each time a 2.0 implementation receives a new 2.0 opcode ('mgmt',\n   \
    \   'xsrv', and 'spcl') from the far end, it should examine the '\n      far_end_version'.\
    \  If the 'far_end_version' indicates the far end\n      is a 1.0 implementation,\
    \ the received TALI message should be\n      treated as a Protocol Violation (invalid\
    \ opcode).  If the\n      'far_end_version' is 2.0 (or later), the 2.0 implementation\
    \ should\n      process the received 'mgmt/xsrv/spcl' according to that nodes\n\
    \      capabilities for that opcode.\n   *  Each time a 2.0 implementation receives\
    \ a request to send a TALI\n      message with a 2.0 opcode ('mgmt/xsrv/spcl')\
    \ from a higher layer\n      of software, it should examine the 'far_end_version'.\
    \  If the\n      'far_end_version' indicates the far end is a 1.0 implementation,\n\
    \      the request to send the 2.0 opcode should be denied or ignored (an\n  \
    \    implementation decision) and the 2.0 opcode must NOT be sent to\n      the\
    \ far end.  If the 'far_end_version' indicates the far end is\n      2.0 (or later),\
    \ the request can be satisfied and the TALI message\n      with the 2.0 opcode\
    \ can be sent to the far end.\n   *  Each TALI 2.0 implementation can provide\
    \ a varying level of\n      support for each of the three new 2.0 opcodes ('mgmt/xsrv/spcl').\n\
    \      In other words, an implementation may wish to only support SOME OF\n  \
    \    the primitives within the new opcodes.  The level of support for\n      each\
    \ 2.0 opcode ('mgmt/xsrv/spcl') is independent of the other two\n      2.0 opcodes.\n\
    \   *  The basic message structure for TALI messages using the new 2.0\n     \
    \ opcodes is presented in Table 9.\n   *  The minimal level of support that is\
    \ required for each of the 2.0\n      opcodes (mgmt/xsrv/spcl) is to be able to\
    \ receive TALI messages\n      with these opcodes, recognize the new opcode, and\
    \ ignore the\n      message without affecting the state machine.  The TALI state\n\
    \      should not change.  The socket connection should stay up.  In\n      other\
    \ words, a 2.0 implementation can elect to ignore any received\n      'mgmt/xsrv/spcl'\
    \ messages, if that implementation does not care to\n      support the capability\
    \ intended by that particular opcode.\n   *  A partial level of support for a\
    \ 2.0 opcode could be implemented.\n      Partial support may consist of understanding\
    \ the data structure\n      for the 2.0 opcode, but only supporting some of the\
    \ variants of\n      the opcode.  The message structure for each of the new 2.0\
    \ opcodes\n      consists of an extra 'Primitive' field that follows the TALI\n\
    \      opcode and message length fields.  Each 'Primitive' is used to\n      differentiate\
    \ a variant of the opcode.  It is envisioned that each\n      new 2.0 opcode can\
    \ be extended by adding new 'Primitives', as more\n      capabilities are defined\
    \ for the opcode, without having to add new\n      TALI opcodes.  A 2.0 implementation\
    \ may understand and be willing\n      to act on some of the 'Primitives' for\
    \ an opcode, but not others.\n      Receiving variants of a 2.0 opcode that an\
    \ implementation does not\n      understand need to be ignored and not affect\
    \ the 2.0 state\n      machine.\n   *  The full level of support for a 2.0 opcode\
    \ could be implemented.\n      This support would consist of understanding and\
    \ fully supporting\n      every 'Primitive' within the 2.0 opcode.\n   +------------------------------------------------------------------+\n\
    \   | Octets | Field Name  | Description                  | Field Type |\n   +------------------------------------------------------------------+\n\
    \   | 0..3   | SYNC        | 'TALI'                       |4 byte ASCII|\n   +------------------------------------------------------------------+\n\
    \   | 4..7   | OPCODE      | 'mgmt', 'xsrv' or 'spcl'     |4 byte ASCII|\n   +------------------------------------------------------------------+\n\
    \   | 8..9   | LENGTH      | Length (length of the rest   | Integer    |\n   |\
    \        |             | of this packet)              |            |\n   +------------------------------------------------------------------+\n\
    \   | 10..13 | Primitive   | 'wxyz', or a 4 byte text     |  4 byte    |\n   |\
    \        | See note    | that is appropriate for the  |  ASCII     |\n   |   \
    \     |             | given opcode                 |            |\n   +------------------------------------------------------------------+\n\
    \   | 14..X  | DATA        | The content of the data area | Variable   |\n   |\
    \        |             | is dependent on the opcode/  |            |\n   |   \
    \     |             | primitive combination        |            |\n   +------------------------------------------------------------------+\n\
    \       Table 9: Basic Message Structure for New 2.0 TALI Opcodes\n   NOTE:  The\
    \ Primitive field acts as a modifier for each opcode.\n   Within an opcode, different\
    \ operations or groups of operations can be\n   defined and supported.  The Primitive\
    \ identifies each different\n   operation or set of operations.\n"
- title: 4.3.1 Generating Protocol Violations based on Received Messages
  contents:
  - "4.3.1 Generating Protocol Violations based on Received Messages\n   As implied\
    \ by some of the bullets before Table 9, it is a goal of the\n   2.0 TALI specification\
    \ to relax some of the error checking associated\n   with the processing of received\
    \ TALI messages.\n   Version 1.0 of this specification was very strict in detailing\
    \ the\n   fields that were checked for each received message.  As each received\n\
    \   message was processed, the SYNC code, opcode and length field of the\n   message\
    \ was checked; if any of these fields were invalid an internal\n   protocol violation\
    \ was generated.  The processing of the protocol\n   violation caused the socket\
    \ to go down.  In addition to the 3\n   specific checks (sync, opcode, length),\
    \ the overall philosophy of\n   version 1.0 was to treat any received data that\
    \ the receiver did not\n   understand, or which the receiver deemed to contain\
    \ incorrectly coded\n   fields as protocol violations.\n   Version 2.0 introduces\
    \ the possibility of partial support for\n   opcodes, partial support for primitives,\
    \ and partial support for\n   various fields (such as support for ANSI Pt Codes,\
    \ but not ITU Pt\n   Codes).  Thus, the overall philosophy of how to treat received\
    \ data\n   that the receiver does not support needs to be relaxed from the\n \
    \  strict treatment in version 1.0.  Version 2.0 implementations should\n   be\
    \ more tolerant when they receive messages they do not support (or\n   which they\
    \ believe contain incorrectly coded fields).  This tolerance\n   should include\
    \ NOT treating these receives as protocol violations.\n   Version 2.0 implementations\
    \ should perform the following level of\n   strict/loose checks on the received\
    \ messages:\n   *  Checks against the sync codes, opcodes and lengths for version\
    \ 1.0\n      and version 2.0 opcodes should be performed (against Table 3 and\n\
    \      Table 11).  Invalid data in these fields should be treated as\n      cause\
    \ for protocol violations.\n   *  Checks against the opcode field for messages\
    \ with new 2.0 opcodes\n      (mgmt/xsrv/spcl) should be performed to determine\
    \ whether the\n      message can be processed by the implementation.  If an\n\
    \      implementation chooses to NOT support a particular 2.0 opcode, the\n  \
    \    received message should be discarded, internal data (such as\n      measurements,\
    \ logs of messages, user notifications) could record\n      the event, and the\
    \ TALI state should NOT be affected.\n   *  Checks against the primitive field\
    \ for messages with new 2.0\n      opcodes (mgmt/xsrv/spcl) should be performed\
    \ to determine whether\n      the message can be processed by the implementation.\
    \  If an\n      implementation does not understand a particular primitive, or\
    \ has\n      chosen NOT to implement the features for a particular primitive,\n\
    \      the received message should be discarded, internal data (such as\n    \
    \  measurements, logs of messages, user notifications) could record\n      the\
    \ event, and the TALI state should NOT be affected.\n   *  Checks against other\
    \ field types in messages with new 2.0 opcodes\n      (such as checking the encoding\
    \ of a Point Code field for a valid\n      Pt Code type) should also be performed\
    \ in a 'soft' manner.  Errors\n      found in individual fields should cause the\
    \ received message to be\n      discarded, internal data (such as measurements,\
    \ logs of messages,\n      user notifications) could record the event, and the\
    \ TALI state\n      should NOT be affected.\n   The goals behind introducing this\
    \ gentler treatment of errors in\n   received data are as follows:\n   *  To keep\
    \ the socket up in order to perform the primary purpose of\n      the connection\
    \ (ie: to continue to transport SS7 data) in spite of\n      improperly formatted/unsupported\
    \ TALI messages related to other\n      features/extensions/etc.\n   *  To allow\
    \ applications to support and use some of the features for\n      a particular\
    \ TALI revision without requiring the application to\n      implement all of the\
    \ functionality for the TALI revision.\n   *  To increase the extensibility of\
    \ the protocol.  Looser receive\n      checks are preferred in order to be able\
    \ to add new primitives and\n      new primitive operations as they are defined.\n"
- title: 4.4 Overview of the TALI Message Structure
  contents:
  - "4.4 Overview of the TALI Message Structure\n   The basic message structure for\
    \ all TALI messages is unchanged with\n   the addition of new 2.0 opcodes.  The\
    \ base TALI header still consists\n   of SYNC + OPCODE + LENGTH, as described\
    \ in Table 2.\n   The message structure for the new 2.0 opcodes was shown in Table\
    \ 9.\n   These messages define an extra required field, PRIMITIVE, that\n   follows\
    \ the LENGTH field of Table 2.\n"
- title: 4.4.1 Types of TALI Fields
  contents:
  - "4.4.1 Types of TALI Fields\n   Table 4 in the version 1.0 specification provided\
    \ implementation\n   notes for all the 'types of fields' found in the 1.0 specification.\n\
    \   Version 2.0 of TALI continues to use all of the types provided in\n   Table\
    \ 4, and also defines some new fields that are used in TALI\n   messages that\
    \ use the new 2.0 opcodes.  The following table\n   introduces the new field types\
    \ that are introduced with version 2.0.\n   The types in Table 10 are used in\
    \ addition to the types in Table 4 to\n   implement the 2.0 TALI protocol.\n \
    \  +-----------+------------------------------------------------------+\n   |Field\
    \ Type | Implementation Notes for that Type                   |\n   +------------------------------------------------------------------+\n\
    \   |SS7 Point  | Used to transmit point code information for ANSI or  |\n   |Code\
    \       | ITU variants of point codes across the TALI interface|\n   |       \
    \    | * The point code structure is 4 bytes. Byte 3 is used|\n   |          \
    \ |   to identify the TYPE of point code. The actual     |\n   |           | \
    \  point code is then encoded in bytes 0-2 (w/byte 0  |\n   |           |   being\
    \ the least significant byte and the first byte|\n   |           |   transmitted\
    \ across the wire)                       |\n   |           | * Byte 3: encoding\
    \ of the type of point code (PC)    |\n   |           |   0 = an ANSI Full PC\
    \                                |\n   |           |   1 = an ITU International\
    \ Full PC w/ a 3/8/3 coding |\n   |           |       scheme for zone/area/identifier\
    \                |\n   |           |   2 = an ITU National Full PC w/ a raw 14\
    \ bit PC     |\n   |           |   3 = unused                                \
    \         |\n   |           |   4 = an ANSI Cluster PC                       \
    \      |\n   |           | * For ANSI Full PC w/byte 3=0.  These point codes are|\n\
    \   |           |   24 bit point codes as follows:                     |\n   |\
    \           |   Byte 2 = Network                                   |\n   |   \
    \        |   Byte 1 = Cluster                                   |\n   |      \
    \     |   Byte 0 = Member                                    |\n   |         \
    \  | * For ITU International Full PC (3/8/3) w/byte 3=1.  |\n   |           |\
    \   These point codes use 14 bits (stored in the 14    |\n   |           |   least\
    \ significant bits in bytes 0&1).  Byte 2 is   |\n   |           |   unused. \
    \ The 14 bits should be interpreted as 3    |\n   |           |   bits of zone,\
    \ 8 bits of area and 3 bits of         |\n   |           |   signaling point identifier.\
    \  The 3 bits of         |\n   |           |   signaling point identifier are\
    \ the 3 least         |\n   |           |   significant bits.                \
    \                  |\n   |           | * For ITU National Full PC w/byte 3=2.\
    \ These point   |\n   |           |   codes use 14 bits (stored in the 14 least\
    \          |\n   |           |   significant bits in bytes 0&1).  Byte 2 is unused.\
    \ |\n   |           |   The 14 bits represent a single 14-bit quantity that|\n\
    \   |           |   constitutes the point code.                        |\n   |\
    \           | * For unused w/byte 3=3.  Bytes 0 through 2 are      |\n   |   \
    \        |   undefined.                                         |\n   |      \
    \     | * For ANSI Cluster PC, w/byte 3=4.  These point codes|\n   |         \
    \  |   are 24 bit point codes as follows:                 |\n   |           |\
    \   Byte 2 = Network                                   |\n   |           |   Byte\
    \ 1 = Cluster                                   |\n   |           |   Byte 0 =\
    \ 0. This field is ignored and should be    |\n   |           |   coded as 0...all\
    \ members of the cluster are implied|\n   |           | * Byte 0 is the first\
    \ byte that is transmitted across|\n   |           |   the wire, followed by byte\
    \ 1, byte 2, then byte 3. |\n   +------------------------------------------------------------------+\n\
    \   |Bit-Field  | * Field containing an array of N bits, where N is a  |\n   |\
    \           |   multiple of 8.  Bit-Field types should be          |\n   |   \
    \        |   transmitted such that the byte containing bits 0   |\n   |      \
    \     |   through 7 is transmitted across the wire first,    |\n   |         \
    \  |   followed by the byte containing bits 8 through 15, |\n   |           |\
    \   etc.                                               |\n   |           | * The\
    \ software for each implementation should be     |\n   |           |   written\
    \ in a manner that accounts for the required |\n   |           |   byte order\
    \ of transmission (ie: the Big Endian/    |\n   |           |   Little Endian\
    \ characteristics of the processor need|\n   |           |   to be dealt with\
    \ in the software).                 |\n   +------------------------------------------------------------------+\n\
    \   |Version    |A TALI version label is a 12 byte ASCII text field.   |\n   |Label\
    \      |The label is of a format 'vers xxx.yyy', where xxx.yyy|\n   |        \
    \   |are used to identify the version such as 002.000.  As |\n   |           |with\
    \ other ASCII text fields, the first byte of the   |\n   |           |text field\
    \ (the 'v') should be the first byte         |\n   |           |transmitted out\
    \ the wire.                             |\n   +------------------------------------------------------------------+\n\
    \   |Primitive  |Messages that use the new TALI 2.0 opcodes all have a |\n   |\
    \           |4 byte text ASCII field referred to as a Primitive.   |\n   |   \
    \        |The Primitive acts as a modifier for the opcode. This |\n   |      \
    \     |allows a single opcode to be used to perform multiple |\n   |         \
    \  |actions.                                              |\n   +------------------------------------------------------------------+\n\
    \   |Primitive  |A Primitive can be used to specify either a specific  |\n   |Operation\
    \  |action or a set of actions.  When the Primitive field |\n   |           |is\
    \ used to specify a set of actions, an operation     |\n   |           |field\
    \ is used to pick a specific operation within that|\n   |           |group of\
    \ actions. Operation fields are 4 byte integers|\n   +------------------------------------------------------------------+\n\
    \   |Private    |Various RFC documents have detailed a set of assigned |\n   |Enterprise\
    \ |numbers (RFC 1700, Assigned Numbers) and defined data |\n   |Code       |structures\
    \ (RFC 1155, Structure and Identification of |\n   |(PEC)      |Management Information\
    \ for IP-based Internets)        |\n   |           |that are used on IP networks\
    \ to provide network       |\n   |           |management information.        \
    \                       |\n   |           |Network Management Object Identifiers\
    \ (OID) are used  |\n   |           |to recognize specific organizations, companies,\
    \       |\n   |           |protocols, and so on, in a manner that all vendors\
    \ can|\n   |           |agree on.                                            \
    \ |\n   |           |An Object Identifier exists which uniquely describes  |\n\
    \   |           |each company that does business in the data/telecomm  |\n   |\
    \           |industry.  That OID is referred to as an 'SMI Network |\n   |   \
    \        |Management Private Enterprise Code', which we are     |\n   |      \
    \     |shortening to Private Enterprise Code of PEC in this  |\n   |         \
    \  |document for simplicity.  Each PEC is assumed to have |\n   |           |a\
    \ defined prefix of                                   |\n   |           |'iso.org.dod.internet.private.enterprise'\
    \ or          |\n   |           |(1.3.6.1.4.1).                              \
    \          |\n   |           |                                               \
    \       |\n   |           |The PEC for each company can be found via a file at:\
    \  |\n   |           |ftp://ftp.isi.edu/in-notes/iana/assignments/          |\n\
    \   |           | enterprise-numbers                                   |\n   |\
    \           |                                                      |\n   |   \
    \        |To encode the PEC for a vendor in each implementation |\n   |      \
    \     |of TALI, a 2 byte integer field is used.  The contents|\n   |         \
    \  |of the integer field should match the PEC code for    |\n   |           |that\
    \ company in the file mentioned above.             |\n   |           |       \
    \                                               |\n   |           |For example,\
    \ Tekelec, which has a PEC of 323, will    |\n   |           |code this 2 byte\
    \ field as '0x0143'.                   |\n   |           |                   \
    \                                   |\n   |           |Like other integer fields,\
    \ the PEC value is           |\n   |           |transmitted Least Significant\
    \ Byte first across the   |\n   |           |ethernet wire.                  \
    \                      |\n   +------------------------------------------------------------------+\n\
    \   Table 10: Implementation for new field types introduced in TALI 2.0\n"
- title: 4.5 Detailed TALI Message Structures for New 2.0 Opcodes
  contents:
  - "4.5 Detailed TALI Message Structures for New 2.0 Opcodes\n   The message structures\
    \ for opcodes defined in version 1.0 of TALI are\n   unchanged from the information\
    \ presented earlier, with the exception\n   of the 'moni' message.  The 2.0 format\
    \ for the 'moni' message was\n   described earlier.\n   Detailed message structures,\
    \ and discussion of the capabilities, for\n   each of the new 2.0 opcodes is provided\
    \ in the following sections.\n   Before discussing each opcode individually, Table\
    \ 11 provides the\n   minimum and maximum value of the LENGTH field that should\
    \ be\n   supported for each new opcode (as well as 'moni/mona').  Table 11\n \
    \  additionally shows the impact of ITU support that was added in 2.0.\n   The\
    \ routing label for ITU point codes only uses 4 octets instead of 7\n   octets\
    \ as ANSI requires.\n   +------------------------------------------------------------------+\n\
    \   | Opcode | Valid Length | Comments                                 |\n   |\
    \        | Field Values |                                          |\n   +------------------------------------------------------------------+\n\
    \   | moni   | 0-200 bytes  | The overall length of the data portion   |\n   |\
    \        |              | for 'moni' on TALI 2.0 implementations   |\n   |   \
    \     |              | is unchanged from version 1.0 of the     |\n   |      \
    \  |              | specification and remains at 200 bytes   |\n   |        |\
    \              | to provide backwards compatibility.      |\n   +------------------------------------------------------------------+\n\
    \   | mona   | 0-200 bytes  | The overall length of the data portion   |\n   |\
    \        |              | for 'mona' on TALI 2.0 implementations   |\n   |   \
    \     |              | is unchanged from version 1.0 of the     |\n   |      \
    \  |              | specification and remains at 200 bytes   |\n   |        |\
    \              | to provide backwards compatibility.      |\n   +------------------------------------------------------------------+\n\
    \   | mgmt   | 4-4096 bytes | The minimum length of 4 bytes is required|\n   |\
    \        |              | to provide space for the Primitive field.|\n   |   \
    \     |              | The maximum length allows large TCP      |\n   |      \
    \  |              | packets to be supported if desired.      |\n   +------------------------------------------------------------------+\n\
    \   | xsrv   | 4-4096 bytes | The minimum length of 4 bytes is required|\n   |\
    \        |              | to provide space for the Primitive field.|\n   |   \
    \     |              | The maximum length allows large TCP      |\n   |      \
    \  |              | packets to be supported if desired.      |\n   +------------------------------------------------------------------+\n\
    \   | spcl   | 4-4096 bytes | The minimum length of 4 bytes is required|\n   |\
    \        |              | to provide space for the Primitive field.|\n   |   \
    \     |              | The maximum length allows large TCP      |\n   |      \
    \  |              | packets to be supported if desired.      |\n   +------------------------------------------------------------------+\n\
    \   | sccp   | 9-265 bytes  | These are the valid sizes for the        |\n   |\
    \        |              | SCCP-ONLY portions of SCCP UDT MSUs.     |\n   +------------------------------------------------------------------+\n\
    \   | isot   | 8-273 bytes  | The length is the number of octets that  |\n   |\
    \        |              | in the MTP3 and higher layer(s) of the   |\n   |   \
    \     |              | SS7 MSU.  This length includes the SIO   |\n   |      \
    \  |              | byte and all bytes in the SIF (Service   |\n   |        |\
    \              | Information Field) field.  The MTP3      |\n   |        |   \
    \           | routing label is part of the SIF field.  |\n   +------------------------------------------------------------------+\n\
    \   | mtp3   | 8-280 bytes  | The length is the number of octets that  |\n   |\
    \        |              | in the MTP3 and higher layer(s) of the   |\n   |   \
    \     |              | SS7 MSU.  This length includes the SIO   |\n   |      \
    \  |              | byte and all bytes in the SIF (Service   |\n   |        |\
    \              | Information Field) field.  The MTP3      |\n   |        |   \
    \           | routing label is part of the SIF field.  |\n   +------------------------------------------------------------------+\n\
    \   | saal   | 8-280 bytes  | The length is the number of octets that  |\n   |\
    \        |              | in the MTP3 and higher layer(s) of the   |\n   |   \
    \     |              | SS7 MSU.  This length includes the SIO   |\n   |      \
    \  |              | byte and all bytes in the SIF (Service   |\n   |        |\
    \              | Information Field) field.  The MTP3      |\n   |        |   \
    \           | routing label is part of the SIF field.  |\n   |        |      \
    \        | Seven (7) octets of SSCOP trailer is     |\n   |        |         \
    \     | added to the message.  The SSCOP trailer |\n   |        |            \
    \  | bytes are also included in the length.   |\n   +------------------------------------------------------------------+\n\
    \     Table 11: Valid Length Fields for Opcodes Affected by TALI 2.0\n"
- title: 4.5.1 Management Message (mgmt)
  contents:
  - "4.5.1 Management Message (mgmt)\n   The 'mgmt' opcode is intended to allow Management\
    \ data, or data that\n   will manage the operation of the device, to pass between\
    \ the TALI\n   endpoints over the socket connection.  'mgmt' messages can be\n\
    \   received and processed in any of the TALI NEx-FEx states.  Three\n   PRIMITIVES\
    \ are defined for use with this opcode:\n   *  'rkrp' - Routing Key Registration\
    \ Primitive.  This primitive\n      allows the nodes to configure the SS7 traffic\
    \ streams that they\n      wish to receive over each socket.  This 'routing key\
    \ registration'\n      is performed in-band, via TALI messages.\n   *  'mtpp'\
    \ - MTP3 Primitives.  This primitive allows SS7 MTP3 network\n      management\
    \ messages regarding the (un)availability and congestion\n      states of SS7\
    \ devices to be passed to the IP devices SG.\n   *  'sorp' - Socket Options Registration\
    \ Primitive.  This primitive\n      allows various socket options to be enabled/disabled\
    \ by each TALI\n      device.\n   As of version 2.0, the only defined primitives\
    \ for the 'mgmt' opcode\n   are 'rkrp', 'mtpp', and 'sorp'.  In the future, more\
    \ primitives can\n   be added to this opcode to extend the Management capabilities\
    \ of the\n   SG or IP devices.  The basic message structure for the 2.0 'mgmt'\n\
    \   messages for all 3 of these primitives is as follows:\n   +------------------------------------------------------------------+\n\
    \   | Octets | Field Name  | Description                               |\n   +------------------------------------------------------------------+\n\
    \   | 0..3   | SYNC        | 'TALI'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 4..7   | OPCODE      | 'mgmt'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 8..9   | LENGTH      | Length                                    |\n   +------------------------------------------------------------------+\n\
    \   | 10..13 | Primitive   | 'rkrp', 'mtpp' or 'sorp'  Each of these   |\n   |\
    \        |             | primitives specify a group of applicable  |\n   |   \
    \     |             | management operations.                    |\n   +------------------------------------------------------------------+\n\
    \   | 14..17 | Primitive   | The operation field specifies the one     |\n   |\
    \        | Operation   | operation within the group of operations  |\n   |   \
    \     |             | identified by the primitive.              |\n   +------------------------------------------------------------------+\n\
    \   | 18..   | Message     | The content of the message data area is   |\n   |\
    \        | Data        | dependent on the combination of opcode/   |\n   |   \
    \     |             | primitive/operation fields.  Each of those|\n   |      \
    \  |             | combinations could use a different message|\n   |        |\
    \             | data structure.                           |\n   +------------------------------------------------------------------+\n\
    \              Table 12: Message Structure for 'mgmt' opcode\n"
- title: 4.5.1.1 Routing Key Registration Primitive (rkrp)
  contents:
  - "4.5.1.1 Routing Key Registration Primitive (rkrp)\n   The 'rkrp' primitive allows\
    \ IP nodes to modify the application\n   routing key table in the SG by sending\
    \ TALI messages to configure the\n   SS7 traffic streams that they wish to receive\
    \ over each socket.  This\n   'routing key registration' is performed in-band,\
    \ via TALI messages,\n   as an alternative to using the SG user interface to configure\
    \ the\n   routing keys.\n   Recall from earlier discussion in this document that\
    \ the\n   specification supports five (5) types of fully specified routing\n \
    \  keys:\n   *  A key for SCCP traffic, where key = DPC-SI-SSN, where SI=3.\n\
    \   *  A key for ISUP traffic, where key = DPC-SI-OPC-CIC Range, where\n     \
    \ SI=5.  The CIC values for traditional ISUP are 14 bit quantities\n      in ANSI\
    \ networks and 12 bit quantities in ITU networks.\n   *  A key for TUP traffic,\
    \ where key = DPC-SI-OPC-CIC Range, where\n      SI=4.  This key is only supported\
    \ for ITU networks.  The CIC\n      values for TUP keys are 12 bit quantities\
    \ in ITU networks.\n   *  A key for QBICC traffic (an extension of ISUP which\
    \ uses 32 bit\n      CIC codes), where key = DPC-SI-OPC-CIC, where SI=13.  The\
    \ CIC\n      values for QBICC keys are 32 bit quantities for ANSI and ITU\n  \
    \    networks.\n   *  A key for OTHER-MTP3-SI (non-SCCP, non-ISUP, non-QBICC for\
    \ ANSI\n      and non-SCCP, non-ISUP, non-QBICC, non-TUP for ITU) traffic, where\n\
    \      key = DPC-SI\n   Each of these keys is fully specified key where the exact\
    \ content of\n   the MSU to be routed must match the data in the routing key.\n\
    \   Extensions to the routing keys have been added that will support\n   'partial\
    \ match' or 'default' routing keys.  The purpose of these\n   extensions is to\
    \ improve the handling of MSU traffic when no fully\n   specified routing key\
    \ exists that matches the MSU.  Partial match and\n   default routing keys are\
    \ used when the SG can not find a fully\n   specified routing key that can be\
    \ used to route an MSU.  Partial\n   match keys can be used to provide closest-match\
    \ routing such as\n   'ignore the CIC' for ISUP/QBICC/TUP traffic, or 'ignore\
    \ the SSN' for\n   SCCP traffic.  Default keys are used when no full or partial\
    \ routing\n   key has been  found as a last resort destination to route the MSU\
    \ to.\n   The types of partial and default keys defined by the protocol are\n\
    \   discussed in the following table.  The 4th column in the table\n   indicates\
    \ the data structure that is used in the TALI rkrp message to\n   perform operations\
    \ on each partial/default key type.  Note: The order\n   of the keys in the table\
    \ (from top to bottom) matches the\n   hierarchical search order that an SG will\
    \ use to attempt to find a\n   routing key to use for an MSU.  The partial and\
    \ default keys are only\n   used after attempting to find a fully specified key\
    \ that matches the\n   MSU.\n   +--------+------------+--------------------------------+-----------+\n\
    \   |Key     | Key        | Comments                       | Cross     |\n   |Type\
    \    | Attributes |                                | Reference |\n   +--------+------------+--------------------------------+-----------+\n\
    \   |Partial | DPC-SI-OPC |Used as backup routes for CIC   | 4.5.1.1.2 |\n   |\
    \        |            |based traffic (but ignoring the |           |\n   |   \
    \     |            |CIC field).                     |           |\n   +--------+------------+--------------------------------+-----------+\n\
    \   |Partial | DPC-SI     |Used as backup routes for CIC   | 4.5.1.1.4 |\n   |\
    \        |            |based or SCCP traffic (but      |           |\n   |   \
    \     |            |ignoring the OPC-CIC or SSN).   |           |\n   |      \
    \  |            |Routes traffic based solely on  |           |\n   |        |\
    \            |DPC and SI of the MSU.          |           |\n   +--------+------------+--------------------------------+-----------+\n\
    \   |Partial | DPC        |Used as a backup route for any  | 4.5.1.1.4 |\n   |\
    \        |            |MSU type.  Routes traffic based |           |\n   |   \
    \     |            |solely on the DPC field.        |           |\n   +--------+------------+--------------------------------+-----------+\n\
    \   |Partial | SI         |Used as a backup route for any  | 4.5.1.1.4 |\n   |\
    \        |            |MSU type.  Routes traffic based |           |\n   |   \
    \     |            |solely on the SI field.         |           |\n   +--------+------------+--------------------------------+-----------+\n\
    \   |Default | -          |If no other type of routing key | 4.5.1.1.5 |\n   |\
    \        |            |for an MSU can be found, use    |           |\n   |   \
    \     |            |this one.                       |           |\n   +--------+------------+--------------------------------+-----------+\n\
    \    Table 13: Partial and Default Routing Keys (in hierarchical order)\n   The\
    \ specific capability requested in each 'rkrp' message is indicated\n   via an\
    \ 'RKRP Operation' field.  These capabilities include:\n   *  ENTER: The ENTER\
    \ operation creates an association between a\n      specific socket and a specific\
    \ application routing key.  The\n      socket of the association is always the\
    \ socket that the 'rkrp' was\n      received on.  The application routing key\
    \ identifies an SS7\n      traffic stream that should be carried over that socket.\
    \  Multiple\n      sockets can be associated with the same application routing\
    \ key,\n      if so, they all receive traffic in a 'load sharing' mode.  An\n\
    \      override field can be used to remove any other socket associations\n  \
    \    for a particular routing key and add a single socket association.\n     \
    \ The ENTER operation is applicable for fully specified SCCP keys,\n      CIC\
    \ based keys (ISUP, Q.BICC, and TUP), OTHER-MTP3-SI keys, and\n      all types\
    \ of partial keys and to the default routing key.\n   *  DELETE: The DELETE operation\
    \ deletes an association between a\n      specific socket and a specific application\
    \ routing key.  The\n      socket of the association is always the socket that\
    \ the 'rkrp' was\n      received on.  Other socket associations for the same application\n\
    \      routing key are NOT affected by the deletion.  When the last\n      socket\
    \ association for a routing key is deleted, the entire\n      routing key entry\
    \ is removed from the database.  The DELETE\n      operation operation is applicable\
    \ for fully specified SCCP keys,\n      CIC based keys (ISUP, Q.BICC, and  TUP),\
    \ OTHER-MTP3-SI keys, and\n      all types of partial keys and to the default\
    \ routing key.\n   *  SPLIT: The SPLIT operation is used to convert a single application\n\
    \      routing key into 2 application routing keys that together cover\n     \
    \ the same SS7 traffic stream as the original key.  Immediately\n      after a\
    \ split is performed, both of the resulting entries retain\n      the same socket\
    \ associations as the original routing key.  When\n      the split is completed,\
    \ the socket associations can be modified\n      for each of the 2 resulting ranges\
    \ independent of the other range.\n      The split operation is only applicable\
    \ to fully specified CIC\n      based keys (ISUP, QBICC, and TUP).  Each fully\
    \ specified CIC based\n      key is uniquely identified by the combination of\
    \ DPC/SI/OPC/CIC\n      range.  The CIC range is a continuous set of numbers from\n\
    \      CICS(start) to CICE(end); the CIC range in the application routing\n  \
    \    key corresponds to the CIC value in a CIC based MSU.\n   *  RESIZE: The RESIZE\
    \ operation is used to modify the CIC range in\n      for a single application\
    \ routing key.  The resize operation is\n      only applicable to fully specified\
    \ CIC based routing keys.  The\n      resize operation replaces the CICS/CICE\
    \ values for a routing key\n      with a new CIC range (NCICS/NCICE).  A wide\
    \ variety of NCICS/NCICE\n      ranges can be supported based on the existing\
    \ CICS/CICE; just\n      about the only restriction is that the new range can\
    \ not already\n      exist in the database and can not overlap any other entry\
    \ in the\n      database.  The socket associations for the routing key are NOT\n\
    \      affected by the change in CICS/CICE.  The SPLIT operation is\n      applicable\
    \ only to fully specified CIC based keys (ISUP, Q.BICC,\n      and TUP).\n   The\
    \ list of RKRP Operations (and their encodings) that are supported\n   for TALI\
    \ version 2.0 is as follows:\n               0x0001 - ENTER ISUP KEY\n       \
    \        0x0002 - DELETE ISUP KEY\n               0x0003 - SPLIT ISUP KEY\n  \
    \             0x0004 - RESIZE ISUP KEY\n               0x0005 - ENTER Q.BICC ISUP\
    \ KEY\n               0x0006 - DELETE Q.BICC ISUP KEY\n               0x0007 -\
    \ SPLIT Q.BICC ISUP KEY\n               0x0008 - RESIZE Q.BICC ISUP KEY\n    \
    \           0x0009 - ENTER SCCP KEY\n               0x000A - DELETE SCCP KEY\n\
    \               0x000B - ENTER OTHER-MTP3-SI KEY\n               0x000C - DELETE\
    \ OTHER-MTP3-SI KEY\n               0x000D - ENTER TUP KEY (ITU only)\n      \
    \         0x000E - DELETE TUP KEY (ITU only)\n               0x000F - SPLIT TUP\
    \ KEY (ITU only)\n               0x0010 - RESIZE TUP KEY (ITU only)\n        \
    \       0x0011 - ENTER DPC-SI-OPC PARTIAL KEY\n               0x0012 - DELETE\
    \ DPC-SI-OPC PARTIAL KEY\n               0x0013 - ENTER DPC-SI PARTIAL KEY\n \
    \              0x0014 - DELETE DPC-SI PARTIAL KEY\n               0x0015 - ENTER\
    \ DPC PARTIAL KEY\n               0x0016 - DELETE DPC PARTIAL KEY\n          \
    \     0x0017 - ENTER SI PARTIAL KEY\n               0x0018 - DELETE SI PARTIAL\
    \ KEY\n               0x0019 - ENTER DEFAULT\n               0x001A - DELETE DEFAULT\
    \ KEY\n               0x001B - MULTIPLE REGISTRATION SUPPORT\n   The message data\
    \ area of the 'rkrp' messages will differ based on\n   which RKRP Operation is\
    \ specified.  Several different structures are\n   used, the correct structure\
    \ can be identified by the RKRP Operation\n   field.\n   In order to simplify\
    \ the implementation, each of these structures\n   will define a structure that\
    \ will support all of the operations\n   required for the key type.  This means\
    \ that based on the rkrp\n   operation, some of the fields will be required, and\
    \ some of the\n   fields will not be applicable for each RKRP message.  Unused\
    \ fields\n   should be initialized to 0 by the sender and ignored by the receiver.\n"
- title: 4.5.1.1.1 RKRP Data Structures
  contents:
  - '4.5.1.1.1 RKRP Data Structures

    '
- title: 4.5.1.1.1.1 Common Fields in all RKRP Messages
  contents:
  - "4.5.1.1.1.1 Common Fields in all RKRP Messages\n   In the following subsections\
    \ several different data structures to be\n   used for various RKRP operations\
    \ are presented.  It should be noted\n   that each of these data structures has\
    \ the following fields in\n   common.  The data structure below should begin at\
    \ byte 14 of the TALI\n   message as shown in Table 12.\n   +------------------------------------------------------------------+\n\
    \   | Octets | Field Name  | Description                  | Field Type |\n   +------------------------------------------------------------------+\n\
    \   | 2      | RKRP        | Identifies which 'rkrp'      | Integer    |\n   |\
    \        | Operation   | operation is desired.        |            |\n   +------------------------------------------------------------------+\n\
    \   | 2      | Request/    | Identifies whether the 'rkrp'| Integer    |\n   |\
    \        | Reply       | message is a request (from an|            |\n   |   \
    \     |             | IP node to SG) for some type |            |\n   |      \
    \  |             | of 'rkrp' action, or a reply |            |\n   |        |\
    \             | to a previous request (from  |            |\n   |        |   \
    \          | the SG back to the IP node). |            |\n   |        |      \
    \       | This integer field uses the  |            |\n   |        |         \
    \    | following encodings:         |            |\n   |        |            \
    \ | 0x0000=Request               |            |\n   |        |             | 0x0001=Reply.\
    \  See Success/  |            |\n   |        |             | Failure code for\
    \ more info.  |            |\n   +------------------------------------------------------------------+\n\
    \   | 2      | Success/    | Provides a success/failure   | Integer    |\n   |\
    \        | Failure     | indication as part of the    |            |\n   |   \
    \     | Code        | reply back to the IP node    |            |\n   |      \
    \  |             | for each processed request.  |            |\n   |        |\
    \             | This field is only used when |            |\n   |        |   \
    \          | the Request/Reply field is   |            |\n   |        |      \
    \       | 0x0001.  This field uses the |            |\n   |        |         \
    \    | encodings from in section 5. |            |\n   +------------------------------------------------------------------+\n\
    \          Table 14: Common Fields in ALL 'rkrp' Data Structures\n   The primary\
    \ purpose of requiring the data structures for all RKRP\n   operations to begin\
    \ with these same fields, is to provide a means for\n   a receiver to reply to\
    \ unknown RKRP messages in a consistent manner.\n   When an implementation receives\
    \ an RKRP request message it does not\n   understand, it should turn the request\
    \ into a reply and use the\n   success/failure code to indicate that the operation\
    \ is not supported\n   (with an RKRP Reply Code of Unsupported rkrp Operation).\n\
    \   It is a requirement that these common fields continue to be used as\n   new\
    \ RKRP operations are added to this specification.  This will\n   ensure that\
    \ the capability described in the previous paragraph will\n   always exist.\n"
- title: 4.5.1.1.1.2 CIC Based Routing Key Operations
  contents:
  - "4.5.1.1.1.2 CIC Based Routing Key Operations\n   The data structure used for\
    \ 'rkrp' messages related to MSUs which are\n   CIC based (ISUP, Q.BICC ISUP,\
    \ and TUP (ITU only)) is as presented in\n   the next table.  The data structure\
    \ below should begin at byte 14 of\n   the TALI message as shown in Table 12.\n\
    \   Note 1: The number of bits used in each CIC field will vary based on\n   the\
    \ SI and network type.\n   *  ISUP operations (0x0001 - 0x0004) are assumed to\
    \ use 14 bit CIC\n      values from the corresponding fields in the structure\
    \ when DPC/OPC\n      indicate an ANSI network (12 bits used in ITU networks).\
    \  Only the\n      14(12) least significant bits of the 32 bit CIC field will\
    \ be\n      used.\n   *  Q.BICC ISUP operations (0x0005 - 0x0008) are assumed\
    \ to use 32 bit\n      CIC values from the corresponding fields in the structure.\n\
    \   *  TUP operations (0x000d - 0x0010) are assumed to use 12 bit CIC\n      values\
    \ from the corresponding fields in the structure when DPC/OPC\n      indicate\
    \ an ITU network.  Only the 12 least significant bits of\n      the 32 bit CIC\
    \ field will be used.   TUP operations are not\n      supported for ANSI networks.\n\
    \   Note 2: This same structure should be used to specify the partial key\n  \
    \ = DPC-SI-OPC(ignoreCIC).  When specifying a DPC-SI-OPC partial key,\n   the\
    \ CIC fields in this structure should be set to 0 by the sender.\n   +------------------------------------------------------------------+\n\
    \   | Octets | Field Name  | Description                  | Field Type |\n   +------------------------------------------------------------------+\n\
    \   | 2      | RKRP        | Identifies which 'rkrp'      | Integer    |\n   |\
    \        | Operation   | operation is desired.        |            |\n   +------------------------------------------------------------------+\n\
    \   | 2      | Request/    | Identifies whether the 'rkrp'| Integer    |\n   |\
    \        | Reply       | message is a request (from an|            |\n   |   \
    \     |             | IP node to SG) for some type |            |\n   |      \
    \  |             | of 'rkrp' action, or a reply |            |\n   |        |\
    \             | to a previous request (from  |            |\n   |        |   \
    \          | the SG back to the IP node). |            |\n   |        |      \
    \       | This integer field uses the  |            |\n   |        |         \
    \    | following encodings:         |            |\n   |        |            \
    \ | 0x0000=Request               |            |\n   |        |             | 0x0001=Reply.\
    \  See Success/  |            |\n   |        |             | Failure code for\
    \ more info.  |            |\n   +------------------------------------------------------------------+\n\
    \   | 2      | Success/    | Provides a success/failure   | Integer    |\n   |\
    \        | Failure     | indication as part of the    |            |\n   |   \
    \     | Code        | reply back to the IP node    |            |\n   |      \
    \  |             | for each processed request.  |            |\n   |        |\
    \             | This field is only used when |            |\n   |        |   \
    \          | the Request/Reply field is   |            |\n   |        |      \
    \       | 0x0001.  This field uses the |            |\n   |        |         \
    \    | encodings listed in section  |            |\n   |        |            \
    \ | 5.                           |            |\n   +------------------------------------------------------------------+\n\
    \   | 2      | RKRP flags  | This is a 2 byte bit-field   | Bit-field  |\n   |\
    \        |             | that provides 16 possible    |            |\n   |   \
    \     |             | flags that can control       |            |\n   |      \
    \  |             | various aspects of the       |            |\n   |        |\
    \             | operation.                   |            |\n   |        |   \
    \          | Bit 0 - An Override bit is   |            |\n   |        |      \
    \       | used on the ENTER operation  |            |\n   |        |         \
    \    | to control how the socket    |            |\n   |        |            \
    \ | associations for a routing   |            |\n   |        |             | key\
    \ should be manipulated.   |            |\n   |        |             | This flag\
    \ determines if the  |            |\n   |        |             | ENTER is to add\
    \ the given    |            |\n   |        |             | socket association\
    \ in a      |            |\n   |        |             | 'load-sharing' mode or\
    \ if    |            |\n   |        |             | the new association should\
    \   |            |\n   |        |             | replace (Override) all       |\
    \            |\n   |        |             | existing associations.  This |   \
    \         |\n   |        |             | flag is only examined on     |      \
    \      |\n   |        |             | ENTER operations.            |         \
    \   |\n   |        |             | Bit 0=0, Load Sharing Mode   |            |\n\
    \   |        |             | Bit 0=1, Override Mode       |            |\n   |\
    \        |             | Bits 1-15, currently         |            |\n   |   \
    \     |             | undefined                    |            |\n   +------------------------------------------------------------------+\n\
    \   | 1      | SI          | Service Indicator.  The SI   | Integer    |\n   |\
    \        |             | field in an SS7 MSU          |            |\n   |   \
    \     |             | identifies the type of       |            |\n   |      \
    \  |             | traffic being carried by the |            |\n   |        |\
    \             | MSU (0=SNM, 3=SCCP, 5=ISUP,  |            |\n   |        |   \
    \          | etc).  Each application      |            |\n   |        |      \
    \       | routing key must specify a   |            |\n   |        |         \
    \    | specific SI value that it    |            |\n   |        |            \
    \ | relates to.                  |            |\n   |        |             | SI\
    \ should be 5 for ISUP keys.|            |\n   |        |             | SI should\
    \ be 13 for Q.BICC   |            |\n   |        |             | ISUP keys.  \
    \                 |            |\n   |        |             | SI should be 4 for\
    \ TUP keys. |            |\n   +------------------------------------------------------------------+\n\
    \   | 4      | DPC         | Destination Point Code.  Each| SS7 Point  |\n   |\
    \        |             | SS7 MSU contains a DPC that  | Code       |\n   |   \
    \     |             | identifies the destination   |            |\n   |      \
    \  |             | for the MSU.  Each           |            |\n   |        |\
    \             | application routing key must |            |\n   |        |   \
    \          | specify a specific DPC value |            |\n   |        |      \
    \       | that it relates to.          |            |\n   +------------------------------------------------------------------+\n\
    \   | 4      | OPC         | Origination Point Code.  Each| SS7 Point  |\n   |\
    \        |             | SS7 MSU contains a OPC that  | Code       |\n   |   \
    \     |             | identifies the source of the |            |\n   |      \
    \  |             | MSU.  ISUP routing keys must |            |\n   |        |\
    \             | each specify a single OPC    |            |\n   |        |   \
    \          | that the application routing |            |\n   |        |      \
    \       | key relates to.              |            |\n   +------------------------------------------------------------------+\n\
    \   | 4      | CICS        | Circuit Identification Code  | Integer    |\n   |\
    \        |             | Start.  Each SS7 ISUP MSU    |            |\n   |   \
    \     |             | contains a CIC code.  Each   |            |\n   |      \
    \  |             | ISUP/QBICC/TUP routing key   |            |\n   |        |\
    \             | identifies a range of CIC    |            |\n   |        |   \
    \          | values that are applicable   |            |\n   |        |      \
    \       | for the routing key.  The    |            |\n   |        |         \
    \    | CICS value is the low end of |            |\n   |        |            \
    \ | the CIC range.               |            |\n   +------------------------------------------------------------------+\n\
    \   | 4      | CICE        | Circuit Identification Code  | Integer    |\n   |\
    \        |             | End.  Each SS7 ISUP MSU      |            |\n   |   \
    \     |             | contains a CIC code.  Each   |            |\n   |      \
    \  |             | ISUP/QBICC/TUP routing key   |            |\n   |        |\
    \             | identifies a range of CIC    |            |\n   |        |   \
    \          | values that are applicable   |            |\n   |        |      \
    \       | for the routing key.  The    |            |\n   |        |         \
    \    | CICE value is the high end   |            |\n   |        |            \
    \ | of the CIC range.            |            |\n   +------------------------------------------------------------------+\n\
    \   | 4      | SPLIT CIC   | The SPLIT field is used on   | Integer    |\n   |\
    \        |             | the SPLIT operation to       |            |\n   |   \
    \     |             | specify where in the existing|            |\n   |      \
    \  |             | CIC range (given by CICS/    |            |\n   |        |\
    \             | CICE) an existing routing key|            |\n   |        |   \
    \          | should be split into 2       |            |\n   |        |      \
    \       | routing keys.  To be valid,  |            |\n   |        |         \
    \    | the following relationship   |            |\n   |        |            \
    \ | must be true before the SPLIT|            |\n   |        |             | is\
    \ performed:                |            |\n   |        |             |    CICS\
    \ < SPLIT <= CICE.     |            |\n   |        |             | After the SPLIT\
    \ is performed,|            |\n   |        |             | the 2 routing keys\
    \ are as    |            |\n   |        |             | follows:             \
    \        |            |\n   |        |             |    CICS to SPLIT-1      \
    \     |            |\n   |        |             |    SPLIT to CICE           \
    \  |            |\n   +------------------------------------------------------------------+\n\
    \   | 4      | NCICS       | The NCICS and NCICE fields   | Integer    |\n   |\
    \        |             | are used on the RESIZE       |            |\n   |   \
    \     |             | operation to specify how the |            |\n   |      \
    \  |             | CIC range for existing       |            |\n   |        |\
    \             | routing key should be        |            |\n   |        |   \
    \          | modified.  NCICS specifies   |            |\n   |        |      \
    \       | the new value that should    |            |\n   |        |         \
    \    | replace the existing CICS    |            |\n   |        |            \
    \ | value in the routing key.    |            |\n   +------------------------------------------------------------------+\n\
    \   | 4      | NCICE       | The NCICS and NCICE fields   | Integer    |\n   |\
    \        |             | are used on the RESIZE       |            |\n   |   \
    \     |             | operation to specify how the |            |\n   |      \
    \  |             | CIC range for existing       |            |\n   |        |\
    \             | routing key should be        |            |\n   |        |   \
    \          | modified.  NCICE specifies   |            |\n   |        |      \
    \       | the new value that should    |            |\n   |        |         \
    \    | replace the existing CICE    |            |\n   |        |            \
    \ | value in the routing key.    |            |\n   +------------------------------------------------------------------+\n\
    \    Table 15: Message Data Structure CIC based Routing Key Operations\n   The\
    \ following table indicates the Required (R), or Not Applicable\n   (NA) status\
    \ for each field of the message data structure in Table 15\n   based on the RKRP\
    \ Operation field.  As mentioned previously, unused\n   fields (those marked NA)\
    \ should be initialized to 0 by the sender and\n   ignored by the receiver.\n\
    \   +------------------------------------------------------------------+\n   |\
    \      Operation  | ENTER | DELETE | SPLIT | RESIZE | ENTER/DELETE |\n   |   \
    \              | (ISUP,| (ISUP, | (ISUP,| (ISUP, | PARTIAL DPC  |\n   |      \
    \           | QBICC,| QBICC, | QBICC,| QBICC, | SI OPC KEY   |\n   | Field   \
    \        | TUP)  | TUP)   | TUP)  | TUP)   |              |\n   +------------------------------------------------------------------+\n\
    \   | Request/Reply   | R     | R      | R     | R      | R            |\n   +------------------------------------------------------------------+\n\
    \   | Success/Failure | R     | R      | R     | R      | R            |\n   +------------------------------------------------------------------+\n\
    \   | RKRP Flags      | R     | R      | R     | R      | R            |\n   +------------------------------------------------------------------+\n\
    \   | SI              | R     | R      | R     | R      | R            |\n   +------------------------------------------------------------------+\n\
    \   | DPC             | R     | R      | R     | R      | R            |\n   +------------------------------------------------------------------+\n\
    \   | OPC             | R     | R      | R     | R      | R            |\n   +------------------------------------------------------------------+\n\
    \   | CICS            | R     | R      | R     | R      | NA           |\n   +------------------------------------------------------------------+\n\
    \   | CICE            | R     | R      | R     | R      | NA           |\n   +------------------------------------------------------------------+\n\
    \   | SPLIT CIC       | NA    | NA     | R     | NA     | NA           |\n   +------------------------------------------------------------------+\n\
    \   | NCICS           | NA    | NA     | NA    | R      | NA           |\n   +------------------------------------------------------------------+\n\
    \   | NCICE           | NA    | NA     | NA    | R      | NA           |\n   +------------------------------------------------------------------+\n\
    \   Table 16: Required/Not Applicable Fields for CIC based Routing Keys\n"
- title: 4.5.1.1.1.3 SCCP Routing Key Operations
  contents:
  - "4.5.1.1.1.3 SCCP Routing Key Operations\n   The data structure used for 'rkrp'\
    \ messages related to SCCP routing\n   keys is presented in the next table.  The\
    \ data structure below should\n   begin at byte 14 of the TALI message as shown\
    \ in Table 12.\n   +------------------------------------------------------------------+\n\
    \   | Octets | Field Name  | Description                  | Field Type |\n   +------------------------------------------------------------------+\n\
    \   | 2      | RKRP        | Identifies which 'rkrp'      | Integer    |\n   |\
    \        | Operation   | operation is desired.        |            |\n   +------------------------------------------------------------------+\n\
    \   | 2      | Request/    | Identifies whether the 'rkrp'| Integer    |\n   |\
    \        | Reply       | message is a request (from an|            |\n   |   \
    \     |             | IP node to SG) for some type |            |\n   |      \
    \  |             | of 'rkrp' action, or a reply |            |\n   |        |\
    \             | to a previous request (from  |            |\n   |        |   \
    \          | the SG back to the IP node). |            |\n   |        |      \
    \       | This integer field uses the  |            |\n   |        |         \
    \    | following encodings:         |            |\n   |        |            \
    \ | 0x0000=Request               |            |\n   |        |             | 0x0001=Reply.\
    \  See Success/  |            |\n   |        |             | Failure code for\
    \ more info.  |            |\n   +------------------------------------------------------------------+\n\
    \   | 2      | Success/    | Provides a success/failure   | Integer    |\n   |\
    \        | Failure     | indication as part of the    |            |\n   |   \
    \     | Code        | reply back to the IP node    |            |\n   |      \
    \  |             | for each processed request.  |            |\n   |        |\
    \             | This field is only used when |            |\n   |        |   \
    \          | the Request/Reply field is   |            |\n   |        |      \
    \       | 0x0001.  This field uses the |            |\n   |        |         \
    \    | encodings listed in section  |            |\n   |        |            \
    \ | 5.                           |            |\n   +------------------------------------------------------------------+\n\
    \   | 2      | RKRP flags  | This is a 2 byte bit-field   | Bit-field  |\n   |\
    \        |             | that provides 16 possible    |            |\n   |   \
    \     |             | flags that can control       |            |\n   |      \
    \  |             | various aspects of the       |            |\n   |        |\
    \             | operation.                   |            |\n   |        |   \
    \          | Bit 0 - An Override bit is   |            |\n   |        |      \
    \       | used on the ENTER operation  |            |\n   |        |         \
    \    | to control how the socket    |            |\n   |        |            \
    \ | associations for a routing   |            |\n   |        |             | key\
    \ should be manipulated.   |            |\n   |        |             | This flag\
    \ determines if the  |            |\n   |        |             | ENTER is to add\
    \ the given    |            |\n   |        |             | socket association\
    \ in a      |            |\n   |        |             | 'load-sharing' mode or\
    \ if    |            |\n   |        |             | the new association should\
    \   |            |\n   |        |             | replace (Override) all       |\
    \            |\n   |        |             | existing associations.  This |   \
    \         |\n   |        |             | flag is only examined on     |      \
    \      |\n   |        |             | ENTER operations.            |         \
    \   |\n   |        |             | Bit 0=0, Load Sharing Mode   |            |\n\
    \   |        |             | Bit 0=1, Override Mode       |            |\n   |\
    \        |             | Bits 1-15, currently         |            |\n   |   \
    \     |             | undefined                    |            |\n   +------------------------------------------------------------------+\n\
    \   | 1      | SI          | Service Indicator.  The SI   | Integer    |\n   |\
    \        |             | field in an SS7 MSU          |            |\n   |   \
    \     |             | identifies the type of       |            |\n   |      \
    \  |             | traffic being carried by the |            |\n   |        |\
    \             | MSU (0=SNM, 3=SCCP, 5=ISUP,  |            |\n   |        |   \
    \          | etc).  Each application      |            |\n   |        |      \
    \       | routing key must specify a   |            |\n   |        |         \
    \    | specific SI value that it    |            |\n   |        |            \
    \ | relates to.                  |            |\n   |        |             | SI\
    \ should be 3 for SCCP keys.|            |\n   +------------------------------------------------------------------+\n\
    \   | 4      | DPC         | Destination Point Code.  Each| SS7 Point  |\n   |\
    \        |             | SS7 MSU contains a DPC that  | Code       |\n   |   \
    \     |             | identifies the destination   |            |\n   |      \
    \  |             | for the MSU.  Each           |            |\n   |        |\
    \             | application routing key must |            |\n   |        |   \
    \          | specify a specific DPC value |            |\n   |        |      \
    \       | that it relates to.          |            |\n   +------------------------------------------------------------------+\n\
    \   | 1      | SSN         | SubSystem Number.  Each SCCP | Integer    |\n   |\
    \        |             | MSU contains a subsystem     |            |\n   |   \
    \     |             | number that identifies the   |            |\n   |      \
    \  |             | SCCP subsystem that should   |            |\n   |        |\
    \             | process the MSU.  SCCP       |            |\n   |        |   \
    \          | routing keys must each       |            |\n   |        |      \
    \       | specify a single SSN that    |            |\n   |        |         \
    \    | the application routing key  |            |\n   |        |            \
    \ | relates to.                  |            |\n   +------------------------------------------------------------------+\n\
    \      Table 17: Message Data Structure SCCP Routing Key Operations\n   The following\
    \ table indicates the Required (R), or Not Applicable\n   (NA) status for each\
    \ field of the message data structure in Table 17\n   based on the RKRP Operation\
    \ field.  As mentioned previously, unused\n   fields (those marked NA) should\
    \ be initialized to 0 by the sender and\n   ignored by the receiver.\n       \
    \       +--------------------------------------------+\n              |      Operation\
    \  | ENTER SCCP | DELETE SCCP |\n              | Field           |           \
    \ |             |\n              +--------------------------------------------+\n\
    \              | Request/Reply   | R          | R           |\n              +--------------------------------------------+\n\
    \              | Success/Failure | R          | R           |\n              +--------------------------------------------+\n\
    \              | RKRP Flags      | R          | R           |\n              +--------------------------------------------+\n\
    \              | SI              | R          | R           |\n              +--------------------------------------------+\n\
    \              | DPC             | R          | R           |\n              +--------------------------------------------+\n\
    \              | SSN             | R          | R           |\n              +--------------------------------------------+\n\
    \      Table 18: Required/Not Applicable Fields for SCCP Routing Keys\n"
- title: 4.5.1.1.1.4 DPC-SI, DPC and SI based Routing Key Operations
  contents:
  - "4.5.1.1.1.4 DPC-SI, DPC and SI based Routing Key Operations\n   The data structure\
    \ used for 'rkrp' messages related to DPC-SI based\n   (either full keys for non-sccp,\
    \ non-cic based traffic, or partial\n   keys for CIC based or SCCP), DPC based\
    \ (partial key), and SI based\n   (partial key) operations is as presented in\
    \ the next table.  The data\n   structure below should begin at byte 14 of the\
    \ TALI message as shown\n   in Table 12.\n   +------------------------------------------------------------------+\n\
    \   | Octets | Field Name  | Description                  | Field Type |\n   +------------------------------------------------------------------+\n\
    \   | 2      | RKRP        | Identifies which 'rkrp'      | Integer    |\n   |\
    \        | Operation   | operation is desired.        |            |\n   +------------------------------------------------------------------+\n\
    \   | 2      | Request/    | Identifies whether the 'rkrp'| Integer    |\n   |\
    \        | Reply       | message is a request (from an|            |\n   |   \
    \     |             | IP node to SG) for some type |            |\n   |      \
    \  |             | of 'rkrp' action, or a reply |            |\n   |        |\
    \             | to a previous request (from  |            |\n   |        |   \
    \          | the SG back to the IP node). |            |\n   |        |      \
    \       | This integer field uses the  |            |\n   |        |         \
    \    | following encodings:         |            |\n   |        |            \
    \ | 0x0000=Request               |            |\n   |        |             | 0x0001=Reply.\
    \  See Success/  |            |\n   |        |             | Failure code for\
    \ more info.  |            |\n   +------------------------------------------------------------------+\n\
    \   | 2      | Success/    | Provides a success/failure   | Integer    |\n   |\
    \        | Failure     | indication as part of the    |            |\n   |   \
    \     | Code        | reply back to the IP node    |            |\n   |      \
    \  |             | for each processed request.  |            |\n   |        |\
    \             | This field is only used when |            |\n   |        |   \
    \          | the Request/Reply field is   |            |\n   |        |      \
    \       | 0x0001.  This field uses the |            |\n   |        |         \
    \    | encodings from section 5.    |            |\n   +------------------------------------------------------------------+\n\
    \   | 2      | RKRP flags  | This is a 2 byte bit-field   | Bit-field  |\n   |\
    \        |             | that provides 16 possible    |            |\n   |   \
    \     |             | flags that can control       |            |\n   |      \
    \  |             | various aspects of the       |            |\n   |        |\
    \             | operation.                   |            |\n   |        |   \
    \          | Bit 0 - An Override bit is   |            |\n   |        |      \
    \       | used on the ENTER operation  |            |\n   |        |         \
    \    | to control how the socket    |            |\n   |        |            \
    \ | associations for a routing   |            |\n   |        |             | key\
    \ should be manipulated.   |            |\n   |        |             | This flag\
    \ determines if the  |            |\n   |        |             | ENTER is to add\
    \ the given    |            |\n   |        |             | socket association\
    \ in a      |            |\n   |        |             | 'load-sharing' mode or\
    \ if    |            |\n   |        |             | the new association should\
    \   |            |\n   |        |             | replace (Override) all       |\
    \            |\n   |        |             | existing associations.  This |   \
    \         |\n   |        |             | flag is only examined on     |      \
    \      |\n   |        |             | ENTER operations.            |         \
    \   |\n   |        |             | Bit 0=0, Load Sharing Mode   |            |\n\
    \   |        |             | Bit 0=1, Override Mode       |            |\n   |\
    \        |             | Bits 1-15, currently         |            |\n   |   \
    \     |             | undefined                    |            |\n   +------------------------------------------------------------------+\n\
    \   | 1      | SI          | Service Indicator.  The SI   | Integer    |\n   |\
    \        |             | field in an SS7 MSU          |            |\n   |   \
    \     |             | identifies the type of       |            |\n   |      \
    \  |             | traffic being carried by the |            |\n   |        |\
    \             | MSU (0=SNM, 3=SCCP, 5=ISUP,  |            |\n   |        |   \
    \          | etc).  Each application      |            |\n   |        |      \
    \       | routing key must specify a   |            |\n   |        |         \
    \    | specific SI value that it    |            |\n   |        |            \
    \ | relates to.                  |            |\n   +------------------------------------------------------------------+\n\
    \   | 4      | DPC         | Destination Point Code.  Each| SS7 Point  |\n   |\
    \        |             | SS7 MSU contains a DPC that  | Code       |\n   |   \
    \     |             | identifies the destination   |            |\n   |      \
    \  |             | for the MSU.  Each           |            |\n   |        |\
    \             | application routing key must |            |\n   |        |   \
    \          | specify a specific DPC value |            |\n   |        |      \
    \       | that it relates to.          |            |\n   +------------------------------------------------------------------+\n\
    \   Table 19: Message Data Structure DPC/SI, DPC and SI based Routing\n      \
    \       Key Operations\n   The following table indicates the Required (R), or\
    \ Not Applicable\n   (NA) status for each field of the message data structure\
    \ in Table 19\n   based on the RKRP Operation field.  As mentioned previously,\
    \ unused\n   fields (those marked NA) should be initialized to 0 by the sender\
    \ and\n   ignored by the receiver.\n         +-------------------------------------------------------+\n\
    \         |      Operation  | ENTER/  | ENTER/  | ENTER/ | ENTER/ |\n        \
    \ |                 | DELETE  | DELETE  | DELETE | DELETE |\n         |      \
    \           | OTHER   | DPC-SI  | DPC    | SI     |\n         | Field        \
    \   | MTP3 SI | PARTIAL | ONLY   | ONLY   |\n         +-------------------------------------------------------+\n\
    \         | Request/Reply   | R       | R       | R      | R      |\n        \
    \ +-------------------------------------------------------+\n         | Success/Failure\
    \ | R       | R       | R      | R      |\n         +-------------------------------------------------------+\n\
    \         | RKRP Flags      | R       | R       | R      | R      |\n        \
    \ +-------------------------------------------------------+\n         | SI   \
    \           | R       | R       | NA     | R      |\n         +-------------------------------------------------------+\n\
    \         | DPC             | R       | R       | R      | NA     |\n        \
    \ +-------------------------------------------------------+\n         Table 20:\
    \ Required/Not Applicable Fields for DPC/SI, DPC\n                   and SI based\
    \ Routing Keys\n"
- title: 4.5.1.1.1.5 Default Routing Key Operations
  contents:
  - "4.5.1.1.1.5 Default Routing Key Operations\n   The data structure used for 'rkrp'\
    \ messages related to entering and\n   deleting a default routing key is as presented\
    \ in the next table.\n   The data structure below should begin at byte 14 of the\
    \ TALI message\n   as shown in Table 12.\n   +------------------------------------------------------------------+\n\
    \   | Octets | Field Name  | Description                  | Field Type |\n   +------------------------------------------------------------------+\n\
    \   | 2      | RKRP        | Identifies which 'rkrp'      | Integer    |\n   |\
    \        | Operation   | operation is desired.        |            |\n   +------------------------------------------------------------------+\n\
    \   | 2      | Request/    | Identifies whether the 'rkrp'| Integer    |\n   |\
    \        | Reply       | message is a request (from an|            |\n   |   \
    \     |             | IP node to SG) for some type |            |\n   |      \
    \  |             | of 'rkrp' action, or a reply |            |\n   |        |\
    \             | to a previous request (from  |            |\n   |        |   \
    \          | the SG back to the IP node). |            |\n   |        |      \
    \       | This integer field uses the  |            |\n   |        |         \
    \    | following encodings:         |            |\n   |        |            \
    \ | 0x0000=Request               |            |\n   |        |             | 0x0001=Reply.\
    \  See Success/  |            |\n   |        |             | Failure code for\
    \ more info.  |            |\n   +------------------------------------------------------------------+\n\
    \   | 2      | Success/    | Provides a success/failure   | Integer    |\n   |\
    \        | Failure     | indication as part of the    |            |\n   |   \
    \     | Code        | reply back to the IP node    |            |\n   |      \
    \  |             | for each processed request.  |            |\n   |        |\
    \             | This field is only used when |            |\n   |        |   \
    \          | the Request/Reply field is   |            |\n   |        |      \
    \       | 0x0001.  This field uses the |            |\n   |        |         \
    \    | encodings listed in section  |            |\n   |        |            \
    \ | 5.                           |            |\n   +------------------------------------------------------------------+\n\
    \   | 2      | RKRP flags  | This is a 2 byte bit-field   | Bit-field  |\n   |\
    \        |             | that provides 16 possible    |            |\n   |   \
    \     |             | flags that can control       |            |\n   |      \
    \  |             | various aspects of the       |            |\n   |        |\
    \             | operation.                   |            |\n   |        |   \
    \          | Bit 0 - An Override bit is   |            |\n   |        |      \
    \       | used on the ENTER operation  |            |\n   |        |         \
    \    | to control how the socket    |            |\n   |        |            \
    \ | associations for a routing   |            |\n   |        |             | key\
    \ should be manipulated.   |            |\n   |        |             | This flag\
    \ determines if the  |            |\n   |        |             | ENTER is to add\
    \ the given    |            |\n   |        |             | socket association\
    \ in a      |            |\n   |        |             | 'load-sharing' mode or\
    \ if    |            |\n   |        |             | the new association should\
    \   |            |\n   |        |             | replace (Override) all       |\
    \            |\n   |        |             | existing associations.  This |   \
    \         |\n   |        |             | flag is only examined on     |      \
    \      |\n   |        |             | ENTER operations.            |         \
    \   |\n   |        |             | Bit 0=0, Load Sharing Mode   |            |\n\
    \   |        |             | Bit 0=1, Override Mode       |            |\n   |\
    \        |             | Bits 1-15, currently         |            |\n   |   \
    \     |             | undefined                    |            |\n   +------------------------------------------------------------------+\n\
    \        Table 21: Message Data Structure for Default Routing Keys\n   The following\
    \ table indicates the Required (R), or Not Applicable\n   (NA) status for each\
    \ field of the message data structure in Table 21\n   based on the RKRP Operation\
    \ field.  As mentioned previously, unused\n   fields (those marked NA) should\
    \ be initialized to 0 by the sender and\n   ignored by the receiver.\n       \
    \       +-------------------------------------+\n              |      Operation\
    \  | ENTER   | DELETE  |\n              | Field           | DEFAULT | DEFAULT\
    \ |\n              +-------------------------------------+\n              | Request/Reply\
    \   | R       | R       |\n              +-------------------------------------+\n\
    \              | Success/Failure | R       | R       |\n              +-------------------------------------+\n\
    \              | RKRP Flags      | R       | R       |\n              +-------------------------------------+\n\
    \      Table 22: Required/Not Applicable Fields for Default Routing Keys\n"
- title: 4.5.1.1.1.6 Support for Multiple RKRP Registration Operations
  contents:
  - "4.5.1.1.1.6 Support for Multiple RKRP Registration Operations\n   The intent\
    \ of support for multiple RKRP operations within a single\n   TALI message (opcode\
    \ = 'mgmt', primitive = 'rkrp') is to decrease the\n   message count and byte\
    \ overhead on network transmission when\n   performing massive registration sequences.\n\
    \   This functionality is added by 2 mechanisms:\n   *  a new RKRP operation (0X001B,\
    \ MULTIPLE REGISTRATIONS SUPPORT) is\n      defined.  This operation is meant\
    \ to be used in a query/reply\n      manner to determine if the far end supports\
    \ multiple RKRP\n      registrations per TALI message before using such capability.\n\
    \   *  The basic 'rkrp' message structure is extended to allow multiple\n    \
    \  rkrp operations to follow one another in a tali message.\n"
- title: 4.5.1.1.1.6.1 Multiple Registrations Support
  contents:
  - "4.5.1.1.1.6.1 Multiple Registrations Support\n   A new RKRP operation and accompanying\
    \ data structure are defined to\n   determine if a far end device supports multiple\
    \ RKRP registration\n   operations per TALI message.\n   The data structure used\
    \ for the 'multiple registrations support'\n   operation is as presented in the\
    \ next table.  The data structure\n   below should begin at byte 14 of the TALI\
    \ message as shown in Table\n   12.\n   +------------------------------------------------------------------+\n\
    \   | Octets | Field Name  | Description                  | Field Type |\n   +------------------------------------------------------------------+\n\
    \   | 2      | RKRP        | Identifies which 'rkrp'      | Integer    |\n   |\
    \        | Operation   | operation is desired.        |            |\n   +------------------------------------------------------------------+\n\
    \   | 2      | Request/    | Identifies whether the 'rkrp'| Integer    |\n   |\
    \        | Reply       | message is a request (from an|            |\n   |   \
    \     |             | IP node to SG) for some type |            |\n   |      \
    \  |             | of 'rkrp' action, or a reply |            |\n   |        |\
    \             | to a previous request (from  |            |\n   |        |   \
    \          | the SG back to the IP node). |            |\n   |        |      \
    \       | This integer field uses the  |            |\n   |        |         \
    \    | following encodings:         |            |\n   |        |            \
    \ | 0x0000=Request               |            |\n   |        |             | 0x0001=Reply.\
    \  See Success/  |            |\n   |        |             | Failure code for\
    \ more info.  |            |\n   +------------------------------------------------------------------+\n\
    \   | 2      | Success/    | Provides a success/failure   | Integer    |\n   |\
    \        | Failure     | indication as part of the    |            |\n   |   \
    \     | Code        | reply back to the IP node    |            |\n   |      \
    \  |             | for each processed request.  |            |\n   |        |\
    \             | This field is only used when |            |\n   |        |   \
    \          | the Request/Reply field is   |            |\n   |        |      \
    \       | 0x0001.  This field uses the |            |\n   |        |         \
    \    | encodings listed in section  |            |\n   |        |            \
    \ | 5.                           |            |\n   +------------------------------------------------------------------+\n\
    \   | 4      | Operations  | This field is used by the    | Integer    |\n   |\
    \        | Per Message | reply to tell the requester  |            |\n   |   \
    \     |             | the maximum # of RKRP        |            |\n   |      \
    \  |             | registration operations per  |            |\n   |        |\
    \             | TALI message that are        |            |\n   |        |   \
    \          | supported by the             |            |\n   |        |      \
    \       | implementation.              |            |\n   |        |         \
    \    | * This field should be set   |            |\n   |        |            \
    \ |   to 0 when the request/     |            |\n   |        |             | \
    \  reply field is set to      |            |\n   |        |             |   Request.\
    \                   |            |\n   |        |             | * This field should\
    \ be set to|            |\n   |        |             |   the Maximum # of operations|\
    \            |\n   |        |             |   per TALI message that a    |   \
    \         |\n   |        |             |   TALI implementation is     |      \
    \      |\n   |        |             |   willing to support when the|         \
    \   |\n   |        |             |   request/reply field is set |            |\n\
    \   |        |             |   to Reply.                  |            |\n   +------------------------------------------------------------------+\n\
    \    Table 23: Message Data Structure for Multiple Registrations Support\n   \
    \           Operation\n   The following table indicates the Required (R), or Not\
    \ Applicable\n   (NA) status for each field of the message data structure above.\
    \  As\n   mentioned previously, unused fields (those marked NA) should be\n  \
    \ initialized to 0 by the sender and ignored by the receiver.\n           +-------------------------------------------------+\n\
    \           |      Operation  | MULTIPLE      | MULTIPLE      |\n           |\
    \                 | REGISTRATIONS | REGISTRATIONS |\n           |            \
    \     | SUPPORT       | SUPPORT       |\n           | Field           | REQUEST\
    \       | REPLY         |\n           +-------------------------------------------------+\n\
    \           | Request/Reply   | R             | R             |\n           +-------------------------------------------------+\n\
    \           | Success/Failure | R             | R             |\n           +-------------------------------------------------+\n\
    \           | Operations Per  | R             | R             |\n           |\
    \ Message         |               |               |\n           +-------------------------------------------------+\n\
    \    Table 24: Required/Not Applicable Fields for Multiple Registrations\n   \
    \           Support Operation\n"
- title: 4.5.1.1.1.6.2 Multiple RKRP Operations in a Single Message
  contents:
  - "4.5.1.1.1.6.2 Multiple RKRP Operations in a Single Message\n   After using the\
    \ MULTIPLE REGISTRATIONS SUPPORT operation to determine\n   that the far end supports\
    \ multiple RKRP operations per TALI message,\n   a device wishing to use this\
    \ functionality can begin sending more\n   than 1 registration request/reply per\
    \ message.  To do so, the basic\n   message structure for an 'mgmt' opcode (presented\
    \ in Table 12) can be\n   extended so that each operation directly follows the\
    \ previous\n   operation in the TALI message.  An example showing a TALI message\n\
    \   with 3 RKRP operations in it would look as follows:\n   +------------------------------------------------------------------+\n\
    \   | Octets | Field Name  | Description                               |\n   +------------------------------------------------------------------+\n\
    \   | 0..3   | SYNC        | 'TALI'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 4..7   | OPCODE      | 'mgmt'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 8..9   | LENGTH      | Length. The length should be set such that|\n   |\
    \        |             | all (3 in this example) operations are    |\n   |   \
    \     |             | accounted for.                            |\n   +------------------------------------------------------------------+\n\
    \   | 10..13 | Primitive   | 'rkrp'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 14..17 | Primitive   | The fisrt operation field identifies a    |\n   |\
    \        | Operation   | specific rkrp operation to be performed.  |\n   |   \
    \     | #1          |                                           |\n   +------------------------------------------------------------------+\n\
    \   | 18..x  | Message     | The length of the message data (and the   |\n   |\
    \        | Data for    | interpretation of those bytes) for        |\n   |   \
    \     | Operation   | operation #1 depends on the message data  |\n   |      \
    \  | #1          | required for rkrp operation #1            |\n   +------------------------------------------------------------------+\n\
    \   | x+1..  | Primitive   | The fisrt operation field identifies a    |\n   |\
    \   x+4  | Operation   | specific rkrp operation to be performed.  |\n   |   \
    \     | #2          |                                           |\n   +------------------------------------------------------------------+\n\
    \   | x+5..y | Message     | The length of the message data (and the   |\n   |\
    \        | Data for    | interpretation of those bytes) for        |\n   |   \
    \     | Operation   | operation #2 depends on the message data  |\n   |      \
    \  | #2          | required for rkrp operation #2            |\n   +------------------------------------------------------------------+\n\
    \   | y+1..  | Primitive   | The fisrt operation field identifies a    |\n   |\
    \   y+4  | Operation   | specific rkrp operation to be performed.  |\n   |   \
    \     | #3          |                                           |\n   +------------------------------------------------------------------+\n\
    \   | y+5..z | Message     | The length of the message data (and the   |\n   |\
    \        | Data for    | interpretation of those bytes) for        |\n   |   \
    \     | Operation   | operation #3 depends on the message data  |\n   |      \
    \  | #3          | required for rkrp operation #3            |\n   +------------------------------------------------------------------+\n\
    \      Table 25: Message Structure for 'mgmt' opcode with multiple\n         \
    \       'rkrp' operations in 1 TALI Message\n   It should be reiterated that in\
    \ order to avoid unpredictable\n   behavior, a node using the 'multiple registrations\
    \ per TALI msg'\n   capability must be sure the far end device supports the capability.\n\
    \   The only way to be sure of this is to successfully send a MULTIPLE\n   REGISTRATION\
    \ SUPPORT request and receive a MULTIPLE REGISTRATION\n   SUPPORT reply.\n"
- title: 4.5.1.2 MTP3 Primitive (mtpp)
  contents:
  - "4.5.1.2 MTP3 Primitive (mtpp)\n   The 'mtpp' primitive allows IP nodes to receive\
    \ status regarding\n   point code (un)availability and congestion levels.  These\
    \ messages\n   provide information similar to the TFP/TFA (TransFer Prohibited\
    \ and\n   TransFer Allowed), TFC (TransFer Congested) and RCT (Route Congestion\n\
    \   Test) messages that are encoded as SS7 SNM (Signaling Network\n   Management)\
    \ MSUs in traditional SS7 networks.  The 'mtp3 primitives'\n   allow this status\
    \ information to be transferred in-band, via TALI\n   messages, to the IP nodes.\n\
    \   The specific information provided in each 'mtpp' message is indicated\n  \
    \ via an 'MTPP Operation' field.  These capabilities provided by the\n   various\
    \ MTPP Operation fields include:\n   *  POINT CODE UNAVAILABLE: This primitive\
    \ operation announces that an\n      SS7 Point Code is Unavailable (ie: the SG\
    \ has NO route available\n      to send traffic for the destination).  The PT\
    \ CODE field indicates\n      which SS7 Pt Code this operation is concerned with.\n\
    \   *  POINT CODE AVAILABLE: This primitive operation announces that an\n    \
    \  SS7 Point Code is Available (ie: the SG has SOME route available\n      to\
    \ send traffic for the destination).  The PT CODE field indicates\n      which\
    \ SS7 Pt Code this operation is concerned with.\n   *  REQUEST FOR POINT CODE\
    \ STATUS: This primitive operation provides a\n      way for one end of the connection\
    \ to poll the other end for the\n      available/unavailable status of a specific\
    \ SS7 pt code.  For\n      instance, the IP node can poll the SG - Can you send\
    \ traffic\n      successfully for the destination indicated?  The receiver of\
    \ the\n      request will reply to the request with either a point code\n    \
    \  available or pt code unavailable primitive respectively.\n   *  CLUSTER UNAVAILABLE:\
    \ This primitive operation announces that an\n      entire Cluster of SS7 Point\
    \ Codes (ex: 10-10-*) are Unavailable\n      (ie: the SG has NO route available\
    \ to send traffic for any of the\n      destinations in that cluster).  The PT\
    \ CODE field indicates which\n      SS7 Cluster Pt Code this operation is concerned\
    \ with.\n   *  CLUSTER AVAILABLE: This primitive operation announces that at\n\
    \      least 1 SS7 Point Code within a cluster is Available (ie: the SG\n    \
    \  has SOME route available to send traffic for at least 1 of the\n      destinations\
    \ in that cluster).  The PT CODE field indicates which\n      SS7 Cluster Pt Code\
    \ this operation is concerned with.\n   *  REQUEST FOR CLUSTER STATUS: This primitive\
    \ operation provides a\n      way for one end of the connection to poll the other\
    \ end for the\n      available/unavailable status of a cluster of SS7 pt codes.\
    \  For\n      instance, the IP node can poll the SG - Can you send traffic\n \
    \     successfully for any of the destinations in the cluster?  The\n      receiver\
    \ of the request will reply to the request with either a\n      cluster available\
    \ or cluster unavailable primitive respectively.\n   *  CONGESTED DESTINATION:\
    \ This primitive operation announces that the\n      path towards an SS7 Point\
    \ Code is Congested.  The PT CODE field\n      indicates which SS7 Pt Code this\
    \ operation is concerned with.  The\n      CONGESTION LEVEL field indicates the\
    \ severity of the congestion.\n   *  REQUEST FOR CONGESTION STATUS: This primitive\
    \ operation provides a\n      way for one end of the connection to poll the other\
    \ end for the\n      congestion status of an SS7 pt code.  For instance, the IP\
    \ node\n      can poll the SG - Is the path to the specified destination still\n\
    \      congested?  This request is used to abate congestion towards an\n     \
    \ SS7 destination.\n      *  As an implementation note: Upon receiving this request,\
    \ the SG\n         will generate and send a Route Congestion Test (RCT), SS7\n\
    \         Network Management Message with a priority set to match the\n      \
    \   congestion level in the request.  The RCT is sent towards the\n         SS7\
    \ destination.  If the SS7 destination is still congested,\n         the RCT will\
    \ result an SS7 Transfer Controlled (TFC) arriving\n         back at the SG, which\
    \ will be converted into a CONGESTED\n         DESTINATION primitive and sent\
    \ on to the IP node.\n   *  USER PART UNAVAILABLE: SS7 nodes send User Part Unavailable\n\
    \      messages when a user part that is mounted on a node is no longer\n    \
    \  available for service.  This primitive operation provides a way\n      for\
    \ an IP Node to receive the same information as the SS7 UPU\n      message.\n\
    \   In order to simplify the implementation, a single data structure is\n   defined\
    \ to be used for all of the 'mtpp' operations.  Depending on\n   the 'mtpp operation',\
    \ some of the fields will be required, and some\n   of the fields will not be\
    \ applicable for each MTPP message.  Unused\n   fields should be initialized to\
    \ 0 by the sender and ignored by the\n   receiver.  The data structure used for\
    \ 'mtpp' messages is as\n   presented in the next table.  The data structure below\
    \ should begin\n   at byte 14 of the TALI message as shown in Table 12.\n   +------------------------------------------------------------------+\n\
    \   | Octets | Field Name  | Description                  | Field Type |\n   +------------------------------------------------------------------+\n\
    \   | 2      | MTPP        | Identifies which 'mtpp'      | Integer    |\n   |\
    \        | Operation   | operation/capability is      |            |\n   |   \
    \     |             | provided in this message.    |            |\n   |      \
    \  |             | This integer field uses the  |            |\n   |        |\
    \             | following encodings:         |            |\n   |        |   \
    \          | 0x0001 = PC Unavailable      |            |\n   |        |      \
    \       | 0x0002 = PC Available        |            |\n   |        |         \
    \    | 0x0003 = Request for PC      |            |\n   |        |            \
    \ |          Status              |            |\n   |        |             | 0x0004\
    \ = Cluster Unavailable |            |\n   |        |             | 0x0005 = Cluster\
    \ Available   |            |\n   |        |             | 0x0006 = Request for\
    \ Cluster |            |\n   |        |             |          Status        \
    \      |            |\n   |        |             | 0x0007 = Congested        \
    \   |            |\n   |        |             |          Destination, w/Cong |\
    \            |\n   |        |             |          Level               |   \
    \         |\n   |        |             | 0x0008 = Request for         |      \
    \      |\n   |        |             |          Congestion Status   |         \
    \   |\n   |        |             | 0x0009 = User Part           |            |\n\
    \   |        |             |          Unavailable         |            |\n   +------------------------------------------------------------------+\n\
    \   | 4      | Concerned   | Identifies the SS7 Point Code| SS7 Point  |\n   |\
    \        | Point       | that is relevant to the mtpp | Code       |\n   |   \
    \     | Code        | operation.  The mtpp         |            |\n   |      \
    \  |             | operation is concerning this |            |\n   |        |\
    \             | point code (or cluster).     |            |\n   +------------------------------------------------------------------+\n\
    \   | 4      | Source      | This field is only used on   | SS7 Point  |\n   |\
    \        | Point       | the 'Congested Destination'  | Code       |\n   |   \
    \     | Code        | and 'Request for Congestion  |            |\n   |      \
    \  |             | Status' operations.          |            |\n   |        |\
    \             | * When used in an 'Congestion|            |\n   |        |   \
    \          |   Destination' operation,    |            |\n   |        |      \
    \       |   this field contains the Pt |            |\n   |        |         \
    \    |   Code of the Source of the  |            |\n   |        |            \
    \ |   traffic that was           |            |\n   |        |             | \
    \  experiencing congestion as |            |\n   |        |             |   it\
    \ made its way to the     |            |\n   |        |             |   Concerned\
    \ Pt Code.  In     |            |\n   |        |             |   terms of the\
    \ original SS7  |            |\n   |        |             |   MSUs (the TransFer\
    \         |            |\n   |        |             |   Controlled MSU) that \
    \      |            |\n   |        |             |   provided congestion     \
    \   |            |\n   |        |             |   information, the CPC of the|\
    \            |\n   |        |             |   TFC is the 'Concerned Point|   \
    \         |\n   |        |             |   Code' of the resulting MTPP|      \
    \      |\n   |        |             |   primitive and the DPC of   |         \
    \   |\n   |        |             |   the TFC is the 'Source     |            |\n\
    \   |        |             |   Point Code' of the         |            |\n   |\
    \        |             |   resulting MTPP primitive.  |            |\n   |   \
    \     |             | * When used in an 'Request   |            |\n   |      \
    \  |             |   for Congestion Status'     |            |\n   |        |\
    \             |   operation, this field      |            |\n   |        |   \
    \          |   indicates which Source Pt  |            |\n   |        |      \
    \       |   Code is trying to abate the|            |\n   |        |         \
    \    |   congestion of the concerned|            |\n   |        |            \
    \ |   Pt Code.  In terms of the  |            |\n   |        |             | \
    \  original SS7 MSUs (the     |            |\n   |        |             |   Route\
    \ Congestion Test MSU) |            |\n   |        |             |   that is used\
    \ to poll for   |            |\n   |        |             |   congestion, the\
    \ DPC of the |            |\n   |        |             |   RCT is the 'Concerned\
    \ Point|            |\n   |        |             |   Code' of the MTPP primitive|\
    \            |\n   |        |             |   and the OPC of the RCT is  |   \
    \         |\n   |        |             |   the 'Source Point Code' of |      \
    \      |\n   |        |             |   the MTPP primitive.        |         \
    \   |\n   +------------------------------------------------------------------+\n\
    \   | 2      | Congestion  | This field is used on the    | Integer    |\n   |\
    \        | Level       | 'Congested Destination' and  |            |\n   |   \
    \     |             | 'Request for Congestion      |            |\n   |      \
    \  |             | Status' operations to        |            |\n   |        |\
    \             | indicate the congestion level|            |\n   |        |   \
    \          | of the destination.  This    |            |\n   |        |      \
    \       | integer field uses the       |            |\n   |        |         \
    \    | following encodings:         |            |\n   |        |            \
    \ | 0x0000 = Congestion Level 0  |            |\n   |        |             | 0x0001\
    \ = Congestion Level 1  |            |\n   |        |             | 0x0002 = Congestion\
    \ Level 2  |            |\n   |        |             | 0x0003 = Congestion Level\
    \ 3  |            |\n   +------------------------------------------------------------------+\n\
    \   | 2      | Cause Code  | This field is used on the    | Integer    |\n   |\
    \        |             | 'User Part Unavailable'      |            |\n   |   \
    \     |             | operation to indicate the    |            |\n   |      \
    \  |             | Cause Code for why the UPU is|            |\n   |        |\
    \             | being sent.  This integer    |            |\n   |        |   \
    \          | field uses the following     |            |\n   |        |      \
    \       | encodings:                   |            |\n   |        |         \
    \    | 0x0000 = Cause Unknown       |            |\n   |        |            \
    \ | 0x0001 = User Part Unequipped|            |\n   |        |             | 0x0002\
    \ = User Part           |            |\n   |        |             |          Inaccessible\
    \        |            |\n   +------------------------------------------------------------------+\n\
    \   | 2      | User ID     | This field is used on the    | Integer    |\n   |\
    \        |             | 'User Part Unavailable'      |            |\n   |   \
    \     |             | operation to indicate which  |            |\n   |      \
    \  |             | user part is unavailable. The|            |\n   |        |\
    \             | User ID field identifies the |            |\n   |        |   \
    \          | type of traffic that was     |            |\n   |        |      \
    \       | unavailable (0=SNM, 3=SCCP,  |            |\n   |        |         \
    \    | 5=ISUP, etc).                |            |\n   +------------------------------------------------------------------+\n\
    \    Table 26: Message Data Structure for use with the 'mtpp' Primitive\n   The\
    \ following table indicates the Required (R), or Not Applicable\n   (NA) status\
    \ for each field of the message data structure in Table 26\n   based on the MTPP\
    \ Operation field.  As mentioned previously, unused\n   fields (those marked NA)\
    \ should be initialized to 0 by the sender and\n   ignored by the receiver.\n\
    \   +------------------------------------------------------------------+\n   |\
    \          Field  | Concerned | Source | Congestion | Cause | User |\n   |   \
    \              | Point     | Point  |  Level     | Code  | ID   |\n   | Operation\
    \       | Code      | Code   |            |       |      |\n   +------------------------------------------------------------------+\n\
    \   | PC Unavailable  | R         | NA     | NA         | NA    | NA   |\n   +------------------------------------------------------------------+\n\
    \   | PC Available    | R         | NA     | NA         | NA    | NA   |\n   +------------------------------------------------------------------+\n\
    \   | Request for PC  | R         | NA     | NA         | NA    | NA   |\n   |\
    \ Status          |           |        |            |       |      |\n   +------------------------------------------------------------------+\n\
    \   | Cluster         | R         | NA     | NA         | NA    | NA   |\n   |\
    \ Unavailable     |           |        |            |       |      |\n   +------------------------------------------------------------------+\n\
    \   | Cluster         | R         | NA     | NA         | NA    | NA   |\n   |\
    \ Available       |           |        |            |       |      |\n   +------------------------------------------------------------------+\n\
    \   | Request for     | R         | NA     | NA         | NA    | NA   |\n   |\
    \ Cluster Status  |           |        |            |       |      |\n   +------------------------------------------------------------------+\n\
    \   | Congested       |           |        |            |       |      |\n   |\
    \ Destination w/  | R         | R      | R          | NA    | NA   |\n   | Cong.\
    \ Level     |           |        |            |       |      |\n   +------------------------------------------------------------------+\n\
    \   | Request for     |           |        |            |       |      |\n   |\
    \ Congestion      | R         | R      | R          | NA    | NA   |\n   | Status\
    \          |           |        |            |       |      |\n   +------------------------------------------------------------------+\n\
    \   | User Part       | R         | NA     | NA         | R     | R    |\n   |\
    \ Unavailable     |           |        |            |       |      |\n   +------------------------------------------------------------------+\n\
    \      Table 27: Required/Not Applicable Fields for MTPP Operations\n"
- title: 4.5.1.3 Socket Option Registration Primitive (sorp)
  contents:
  - "4.5.1.3 Socket Option Registration Primitive (sorp)\n   The 'sorp' primitive\
    \ allows IP nodes to set various options on a\n   socket by socket basis.  This\
    \ allows the IP node some control over\n   the communication that will occur across\
    \ the TALI connection.  The\n   'sorp' primitives allows this socket option control\
    \ to be transferred\n   in-band, via TALI messages, to the IP nodes.\n   The SORP\
    \ primitives capabilities that are available to the IP device\n   in SG are as\
    \ follows:\n   *  Set SORP Flags: Used to set the flags bit field.  The receiver\
    \ of\n      this message should store the bit settings indicated in the SORP\n\
    \      Flag field.\n   *  Request Current SORP Flags Settings: Used to poll for\
    \ the status\n      of the bit field options.  The receiver of this message should\n\
    \      send a Reply w/ Current SORP Flag settings.\n   *  Reply w/ Current SORP\
    \ Flag Settings: Used to reply to a poll,\n      indicating the current bit field\
    \ settings to the far end.\n   As of TALI 2.0, each socket option is stored as\
    \ a bit in a 32 bit\n   bit-field.  Each bit in the field indicates the setting\
    \ for 1 option.\n   A bit field with a 0 value indicates the option is DISABLED.\
    \  A bit\n   field with a 1 value indicates the option is ENABLED.  The following\n\
    \   options are currently supported:\n   *  ENABLE/DISABLE BROADCAST PHASE MTPP\
    \ PRIMITIVES: Traditional STPs\n      send Broadcast Phase TFPs and TFAs to all\
    \ adjacent nodes when the\n      point code availability changes for destinations\
    \ in the STP's SS7\n      routing table.  These Broadcast Phase TFA/TFP SS7 messages\
    \ are\n      converted into TALI mtpp primitives by SG nodes such as the SG.\n\
    \      The ENABLE/DISABLE BROADCAST PHASE MTPP PRIMITIVES options allow\n    \
    \  each IP node to tell the remote end whether the IP node wants to\n      receive\
    \ the mtpp primitives that result from SS7 broadcast phase\n      messages.\n\
    \      *  As an implementation note: In the SG, each defined socket has a\n  \
    \       flag, 'enable_broadcast_phase_primitives', which is initialized\n    \
    \     to FALSE each time the socket connects.  The IP node should\n         send\
    \ the ENABLE BROADCAST PHASE MESSAGES operation to the SG to\n         announce\
    \ that it wants to receive unsolicited status changes\n         for a particular\
    \ socket.  As the SG is determining where to\n         send broadcast phase TFAs/TFPs,\
    \ it will interrogate the\n         'enable_broadcast_phase_primitives' flag for\
    \ each socket on\n         that socket.\n   *  ENABLE/DISABLE RESPONSE METHOD\
    \ MTPP PRIMITIVES: Traditional STPs\n      send Response Method TFPs to adjacent\
    \ nodes when the adjacent\n      nodes continue to send MSUs to the STP that can\
    \ not be delivered\n      (ie: the STP has told the adjacent node that a destination\
    \ is\n      Unavailable, but the adjacent node continues to send traffic\n   \
    \   destined for that unavailable DPC to the STP).  These Response\n      Method\
    \ messages are sent in response to MSUs that are received at\n      the STP. \
    \ These Response Method TFP messages are converted into\n      TALI mtpp primitives\
    \ by SG nodes such as the SG.  The\n      ENABLE/DISABLE RESPONSE METHOD MTPP\
    \ PRIMITIVES options allow each\n      IP node to tell the remote end whether\
    \ the IP node wants to\n      receive the mtpp primitives that result from SS7\
    \ response method\n      messages.  In addition to response method TFPs, 2 other\
    \ SS7\n      Network Management messages, namely TFCs (transfer controlled) and\n\
    \      UPUs (user part unavailable), fall into this RESPONSE METHOD\n      grouping.\
    \  TFCs and UPUs are similar to response method TFPs due\n      to the fact that\
    \ a previous action by the IP Node (sending traffic\n      toward some destination)\
    \ has caused a response method event back\n      to the IP Node.  The primary\
    \ difference between response method\n      TFPs versus response method TFCs/UPUs\
    \ is that the response method\n      TFP is converted to an MTPP primitive and\
    \ sent back to only the\n      original socket, while response method TFCs/UPUs\
    \ may need to be\n      replicated to multiple sockets (after being converted\
    \ to mtpp\n      primitives) since there is no way to tell which socket caused\
    \ the\n      response method event.\n      *  As an implementation node: In the\
    \ SG, each defined socket has a\n         flag, 'enable_response_method_primitives',\
    \ which is initialized\n         to FALSE each time the socket connects.  The\
    \ IP node should\n         send the ENABLE RESPONSE METHOD MTPP PRIMITIVES operation\
    \ to\n         the SG to announce that it wants to receive response method\n \
    \        TFPs when appropriate for a particular socket.  Before the SG\n     \
    \    sends a response method TFP (converted to a mtpp primitive)\n         back\
    \ to an IP node, the SG will interrogate the\n         'enable_response_method_primitives'\
    \ flag for that socket and\n         only perform the send if the flag allows\
    \ it.\n   *  ENABLE/DISABLE NORMALIZED SCCP: Version 1.0 of TALI specified that\n\
    \      the 'sccp' TALI opcode must be used on point to multipoint\n      connections\
    \ in order to transmit SCCP MSUs between the SG and IP\n      nodes.  When using\
    \ the 'sccp' opcode, the MTP3 header portion of\n      the original SS7 MSU was\
    \ stripped from the MSU and was NOT part of\n      the data transmitted across\
    \ the TALI connection.  The sender of\n      the 'sccp' TALI message was responsible\
    \ for duplicating the\n      DPC/OPC fields from the MTP3 header into appropriate\
    \ fields in the\n      SCCP portion of the message (into the Called/Calling Party\
    \ Address\n      Pt Code fields) before sending as a 'sccp' opcode.  This option\n\
    \      provides a way to send SCCP MSUs across TALI point to multipoint\n    \
    \  connections that includes the MTP3 header as part of the data\n      transmitted,\
    \ and does NOT involve any modification to the original\n      SS7 SCCP MSU. \
    \ When the ENABLE NORMALIZED SCCP primitive is\n      received, SCCP MSUs should\
    \ be sent across the TALI interface using\n      the 'mtp3' opcode.  This transmission\
    \ should include the entire\n      MTP3 header + the sccp portion of the original\
    \ MSU.  No\n      modification of the original SS7 MSU should occur.  When the\n\
    \      DISABLE NORMALIZED SCCP primitive is received, SCCP MSUs should be\n  \
    \    sent across the TALI interface using the 'sccp' opcode as\n      specified\
    \ in version 1.0 of TALI.\n   *  ENABLE/DISABLE NORMALIZED ISUP: Version 1.0 of\
    \ TALI specified that\n      the 'isot' TALI opcode must be used on point to multipoint\n\
    \      connections in order to transmit ISUP MSUs between the SG and IP\n    \
    \  nodes.  When using the 'isot' opcode, the original SS7 MSU,\n      including\
    \ the MTP3 header portion, was transmitted in a 'isot'\n      TALI message.  This\
    \ option indicates that the far end would prefer\n      to receive ISUP MSUs using\
    \ the 'mtp3' TALI opcode as opposed to\n      the 'isot' opcode.  When the option\
    \ is ENABLED, the 'mtp3' opcode\n      is used to transmit ISUP MSUs, including\
    \ the MTP3 header, across\n      the TALI connection.  When the option is DISABLED,\
    \ the 'isot'\n      opcode is used as in TALI Release 1.0.\n   The data structure\
    \ used for 'sorp' messages is as presented in the\n   next table.  The data structure\
    \ below should begin at byte 14 of the\n   TALI message as shown in Table 12.\n\
    \   +------------------------------------------------------------------+\n   |\
    \ Octets | Field Name  | Description                  | Field Type |\n   +------------------------------------------------------------------+\n\
    \   | 2      | SORP        | Identifies which 'sorp'      | Integer    |\n   |\
    \        | Operation   | operation/capability is      |            |\n   |   \
    \     |             | provided in this message.    |            |\n   |      \
    \  |             | This integer field uses the  |            |\n   |        |\
    \             | following encodings:         |            |\n   |        |   \
    \          | 0x0001 = Set SORP Flags      |            |\n   |        |      \
    \       | 0x0002 = Request Current     |            |\n   |        |         \
    \    |          SORP Flags Settings |            |\n   |        |            \
    \ | 0x0003 = Reply w/ Current    |            |\n   |        |             | \
    \         SORP Flag Settings  |            |\n   +------------------------------------------------------------------+\n\
    \   | 2      | SORP Flags  | A 4 byte bit-field that uses | Bit-Field  |\n   |\
    \        |             | each bit as an enabled/      |            |\n   |   \
    \     |             | disabled flag for a          |            |\n   |      \
    \  |             | particular socket option.    |            |\n   |        |\
    \             | Bit x = 0 indicates the      |            |\n   |        |   \
    \          |         option is DISABLED.  |            |\n   |        |      \
    \       | Bit x = 1 indicates the      |            |\n   |        |         \
    \    |         option is ENABLED.   |            |\n   |        |            \
    \ | The assignments for each BIT |            |\n   |        |             | are\
    \ as follows:              |            |\n   |        |             | Bit 0 =\
    \ Broadcast Phase MTPP |            |\n   |        |             |         Primitives\
    \           |            |\n   |        |             | Bit 1 = Response Method\
    \ MTPP |            |\n   |        |             |         Primitives        \
    \   |            |\n   |        |             | Bit 2 = Normalized SCCP      |\
    \            |\n   |        |             | Bit 3 = Normalized ISUP      |   \
    \         |\n   +------------------------------------------------------------------+\n\
    \     Table 28: Message Data Structure to be used for 'sorp' Primitive\n"
- title: 4.5.2 Extended Service Message (xsrv)
  contents:
  - "4.5.2 Extended Service Message (xsrv)\n   The Extended Service, 'xsrv', opcode\
    \ is added to the TALI 2.0\n   protocol to lay the groundwork for providing a\
    \ means to transport\n   other types of service traffic (beyond 'sccp', 'isot',\
    \ 'mtp3', and\n   'saal') in future revisions of this protocol without having\
    \ to define\n   a new opcode as each new service type is identified and added.\
    \  The\n   PRIMITIVE field will uniquely identify each new service type as they\n\
    \   are added.  It is envisioned that some 'xsrv' messages can be\n   received\
    \ and processed in any of the TALI NEx-FEx state, while some\n   other 'xsrv'\
    \ messages can only be received and processed in the NEA-\n   FEA state (such\
    \ as Service data in version 1.0 of TALI).\n   There are no specific PRIMITIVES\
    \ defined for this opcode in this\n   release.  It is expected that some new service\
    \ messages will be added\n   in the future.  This opcode provides for grouping\
    \ of the new service\n   data types.\n   +------------------------------------------------------------------+\n\
    \   | Octets | Field Name  | Description                               |\n   +------------------------------------------------------------------+\n\
    \   | 0..3   | SYNC        | 'TALI'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 4..7   | OPCODE      | 'xsrv'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 8..9   | LENGTH      | Length                                    |\n   +------------------------------------------------------------------+\n\
    \   | 10..13 | Primitive   | To be determined                          |\n   +------------------------------------------------------------------+\n\
    \   | 14..   | Message     | To be determined                          |\n   |\
    \   2000 | Data        |                                           |\n   +------------------------------------------------------------------+\n"
- title: 4.5.3 Special Message (spcl)
  contents:
  - "4.5.3 Special Message (spcl)\n   The Special Message, 'spcl', opcode is added\
    \ to the TALI 2.0 protocol\n   to provide a way for vendors to build special services\
    \ into their\n   TALI implementations that are only activated when the implementation\n\
    \   is connected to other equipment implementing the same special\n   services.\
    \  'spcl' messages can be received and processed in any of\n   the TALI NEx-FEx\
    \ states.  This opcode is intended to provide a\n   general means to discover\
    \ more information regarding who the TALI\n   session is connected to, and to\
    \ provide means to enable special\n   features based on the vendor/implementation\
    \ on the far end.\n   As part of the 2.0 specification, 4 primitives are initially\
    \ defined\n   for this opcode:\n   *  'smns' - Special Messages Not Supported.\n\
    \   *  'qury' - Query.\n   *  'rply' - Reply.\n   *  'usim' - UnSolicited Information\
    \ Message.\n   Additional primitives can be added in future versions of the TALI\n\
    \   protocol.\n   +------------------------------------------------------------------+\n\
    \   | Octets | Field Name  | Description                               |\n   +------------------------------------------------------------------+\n\
    \   | 0..3   | SYNC        | 'TALI'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 4..7   | OPCODE      | 'spcl'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 8..9   | LENGTH      | Length                                    |\n   +------------------------------------------------------------------+\n\
    \   | 10..13 | Primitive   | 'smns' - special messages not supported   |\n   |\
    \        |             | 'qury' - query                            |\n   |   \
    \     |             | 'rply' - reply                            |\n   |      \
    \  |             | 'usim' - UIM (unsolicited information msg)|\n   +------------------------------------------------------------------+\n\
    \   | 14..X  | Data        | Vendor dependent                          |\n   +------------------------------------------------------------------+\n"
- title: 4.5.3.1 Special Messages Not Supported (smns)
  contents:
  - "4.5.3.1 Special Messages Not Supported (smns)\n   This message is sent as a response\
    \ to a 'spcl' message with a 'qury'\n   PRIMITIVE.  A node may send out this message\
    \ when it wants the Far\n   End to know that it does not support 'spcl' messages\
    \ and wishes not\n   to receive them in the future.\n   +------------------------------------------------------------------+\n\
    \   | Octets | Field Name  | Description                               |\n   +------------------------------------------------------------------+\n\
    \   | 0..3   | SYNC        | 'TALI'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 4..7   | OPCODE      | 'spcl'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 8..9   | LENGTH      | Length                                    |\n   +------------------------------------------------------------------+\n\
    \   | 10..13 | Primitive   | 'smns'                                    |\n   +------------------------------------------------------------------+\n"
- title: 4.5.3.2 Query Message (qury)
  contents:
  - "4.5.3.2 Query Message (qury)\n   This message can be sent to Query the far end\
    \ of the connection (ie:\n   try to find out more information about the VENDOR,\
    \ TALI version, or\n   other features).  It is expected that each 2.0 implementation\
    \ would\n   respond to a 'qury' with a 'rply'.\n   +------------------------------------------------------------------+\n\
    \   | Octets | Field Name  | Description                               |\n   +------------------------------------------------------------------+\n\
    \   | 0..3   | SYNC        | 'TALI'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 4..7   | OPCODE      | 'spcl'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 8..9   | LENGTH      | Length                                    |\n   +------------------------------------------------------------------+\n\
    \   | 10..13 | Primitive   | 'qury'                                    |\n   +------------------------------------------------------------------+\n"
- title: 4.5.3.3 Reply Message (rply)
  contents:
  - "4.5.3.3 Reply Message (rply)\n   The 'rply' message provides a way for a TALI\
    \ 2.0 implementation to\n   identify itself in more detail.  The information included\
    \ in the\n   reply includes:\n   *  PEC - a 2 byte field that identifies the vendor\
    \ for the TALI\n      implemenation.\n   *  Version Number - a 12 byte field that\
    \ identifies the TALI version\n      of the implementation.\n   *  Other Vendor\
    \ Specific Data - the format of any remaining data that\n      a particular vendor\
    \ wants to provide is specific to each vendor.\n   +------------------------------------------------------------------+\n\
    \   | Octets | Field Name  | Description                               |\n   +------------------------------------------------------------------+\n\
    \   | 0..3   | SYNC        | 'TALI'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 4..7   | OPCODE      | 'spcl'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 8..9   | LENGTH      | Length                                    |\n   +------------------------------------------------------------------+\n\
    \   | 10..13 | Primitive   | 'rply'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 14..15 | PEC         | Private Enterprise Code *                 |\n   |\
    \        |             | (Vendor ID Number, Integer Field)         |\n   +------------------------------------------------------------------+\n\
    \   | 16..27 | Version     | 'vers xxx.yyy'                            |\n   |\
    \        | Label       |                                           |\n   +------------------------------------------------------------------+\n\
    \   | 28..?  | Other Vendor| Free Format data area, specific to each   |\n   |\
    \        | Specific    | vendor                                    |\n   |   \
    \     | Data        |                                           |\n   +------------------------------------------------------------------+\n\
    \   *See Table 4 for details on the PEC field.\n"
- title: 4.5.3.4 Unsolicited Information Message (USIM)
  contents:
  - "4.5.3.4 Unsolicited Information Message (USIM)\n   A 'usim' provides the same\
    \ information as the 'rply' primitive.  The\n   'usim' can be sent at any time\
    \ by a 2.0 implementation (whereas the\n   'rply' should only be sent in reply\
    \ to a 'qury').\n   +------------------------------------------------------------------+\n\
    \   | Octets | Field Name  | Description                               |\n   +------------------------------------------------------------------+\n\
    \   | 0..3   | SYNC        | 'TALI'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 4..7   | OPCODE      | 'spcl'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 8..9   | LENGTH      | Length                                    |\n   +------------------------------------------------------------------+\n\
    \   | 10..13 | Primitive   | 'usim'                                    |\n   +------------------------------------------------------------------+\n\
    \   | 14..15 | PEC         | Private Enterprise Code *                 |\n   |\
    \        |             | (Vendor ID Number, Integer Field)         |\n   +------------------------------------------------------------------+\n\
    \   | 16..27 | Version     | 'vers xxx.yyy'                            |\n   |\
    \        | Label       |                                           |\n   +------------------------------------------------------------------+\n\
    \   | 28..?  | Other Vendor| Free Format data area, specific to each   |\n   |\
    \        | Specific    | vendor                                    |\n   |   \
    \     | Data        |                                           |\n   +------------------------------------------------------------------+\n"
- title: 4.6 TALI Timers
  contents:
  - "4.6 TALI Timers\n   Version 2.0 of the TALI specification does not introduce\
    \ any new\n   timers.  The T1-T4 timers defined previously remain in effect.\n\
    \   While, it is expected that most implementations wishing to identify\n   themselves\
    \ as 2.0 (or later) would use a non-zero value for T4 - this\n   is a not a hard\
    \ requirement.  The only requirement for identifying\n   yourself as 2.0 is to\
    \ send at least 1 'moni' as per the 2.0 format\n   upon connection establishment.\n"
- title: 4.7 TALI User Events
  contents:
  - "4.7 TALI User Events\n   Version 2.0 of the TALI specification does not introduce\
    \ any new user\n   events.  The user events defined in Section 3.4 (mgmt open,\
    \ mgmt\n   close, mgmt allow, mgmt proh, connection established, connection\n\
    \   lost) remain in effect.\n"
- title: 4.8 TALI States
  contents:
  - "4.8 TALI States\n   Version 2.0 of the TALI specification does not introduce\
    \ any new TALI\n   states.  The TALI states defined in Section 3.6 remain in effect.\n"
- title: 4.9 TALI Version 2.0 State Machine
  contents:
  - "4.9 TALI Version 2.0 State Machine\n   This section provides the state machine\
    \ that must be followed by each\n   TALI 2.0 implementation in order to be compliant\
    \ with this\n   specification.  As mentioned throughout this document, a 2.0\n\
    \   implementation is based on several small additions to a 1.0\n   implementation\
    \ and each 2.0 implementation must be willing to inter-\n   operate in a backwards\
    \ compatible mode (a 2.0 implementation\n   connected to a 1.0 implementation\
    \ must fall back to 1.0 features\n   only).\n"
- title: 4.9.1 State Machine Concepts
  contents:
  - "4.9.1 State Machine Concepts\n   Before presenting the actual state machine,\
    \ several concepts are\n   discussed.\n"
- title: 4.9.1.1 General Protocol Rules
  contents:
  - "4.9.1.1 General Protocol Rules\n   A set of general protocol rules was presented\
    \ in the 1.0\n   specification, in section 3.7.1.1; those rules are still applicable\n\
    \   to 2.0 implementations.  In addition to those earlier rules, the\n   following\
    \ rules are also applicable to 2.0 nodes:\n   *  A 2.0 implementation should identify\
    \ the TALI version it has\n      implemented via the 'moni' message\n   *  A 2.0\
    \ implementation should process any received 'moni' messages,\n      attempting\
    \ to determine the TALI version of the far end.  A 2.0\n      implementation must\
    \ use an internal flag, such as\n      'far_end_version', to track the TALI version\
    \ that the far end of\n      the connection has implemented.  The 'far_end_version'\
    \ flag should\n      be initialized to version 1.0.\n   *  A 2.0 implementation\
    \ should reject/ignore internal requests (from\n      software layers in it's\
    \ own product, or requests from the\n      management interface for the device)\
    \ to send TALI messages that\n      require 2.0 opcodes when the far end is a\
    \ 1.0 implementation.  A\n      2.0 implementation should only send TALI messages\
    \ that require new\n      2.0 opcodes (mgmt, xsrv, spcl) when it knows the far\
    \ end is\n      capable of processing those opcodes (when 'far_end_version' is\
    \ 2.0\n      or greater).\n   *  Upon receiving a TALI message with a 2.0 opcode,\
    \ a 2.0\n      implementation should interrogate its 'far_end_flag'; if the far\n\
    \      end is not 2.0 or greater, the arrival of the message should be\n     \
    \ treated as a Protocol Violation.  If the far end is 2.0 or\n      greater, the\
    \ message should be processed according to the nodes\n      2.0 capabilities,\
    \ or ignored (if the node has chosen not to\n      implement any 2.0 functionalities).\n"
- title: 4.9.1.2 Graceful Shutdown of a Socket
  contents:
  - "4.9.1.2 Graceful Shutdown of a Socket\n   The steps to perform a graceful shutdown\
    \ of each socket were\n   presented in the 1.0 specification, in section 3.7.1.2.\
    \  Those steps\n   are not changed for 2.0 implementations.\n"
- title: 4.9.1.3 TALI Protocol Violations
  contents:
  - "4.9.1.3 TALI Protocol Violations\n   Each TALI implementation must detect when\
    \ violations of the TALI\n   protocol have occurred and react accordingly.  Protocol\
    \ violations\n   include:\n   *  Invalid sync code in a received message\n   *\
    \  Invalid opcode in a received message\n   *  Invalid length field in a received\
    \ message\n   *  Not receiving an 'allo' or 'proh', in response to the origination\n\
    \      of a 'test' , before the T2 timer expires\n   *  Receiving Service Messages\
    \ on a prohibited socket.\n   *  TCP Socket errors - Connection Lost\n   *  Receiving\
    \ a TALI message with a 2.0 opcode ('mgmt', 'xsrv', '\n      spcl') from a far\
    \ end that has not identified itself as a 2.0\n      implementation.\n   In the\
    \ state machine that follows, State/Event combinations that\n   should be treated\
    \ as protocol violations are indicated via a 'PV' in\n   the state/event cell.\
    \  All of the 'PV' events are then processed as\n   per the 'Protocol Violation'\
    \ row in the table.\n"
- title: 4.9.2 The State Machine
  contents:
  - "4.9.2 The State Machine\n   Internal Data required for State Machine:\n   * \
    \ boolean sock_allowed.  This flag indicate whether the NE is\n      allowed to\
    \ carry Service Messages.\n   *  Far_end_version.  This enumeration should track\
    \ the TALI version\n      of the far end of the socket.\n   Initial Conditions:\n\
    \   sock_allowed = FALSE\n   far_end_version = 1.0\n   state = OOS\n   no timers\
    \ running\n   +------------------------------------------------------------------+\n\
    \   |   State| OOS  |Connecting| NEP-FEP | NEP-FEA | NEA-FEP | NEA-FEA |\n   |Event\
    \   |      |          |         |         |         |         |\n   +------------------------------------------------------------------+\n\
    \   |T1 Exp. |      |          |Send test|Send test|Send test|Send test|\n   |\
    \        |      |          |Start T1 |Start T1 |Start T1 |Start T1 |\n   |   \
    \     |      |          |Start T2 |Start T2 |Start T2 |Start T2 |\n   +------------------------------------------------------------------+\n\
    \   |T2 Exp. |      |          |   PV    |   PV    |   PV    |   PV    |\n   +------------------------------------------------------------------+\n\
    \   |T3 Exp. |      |          |   PV    |   PV    |         |         |\n   +------------------------------------------------------------------+\n\
    \   |T4 Exp. |      |          |Send moni|Send moni|Send moni|Send moni|\n   |\
    \        |      |          |Start T4 |Start T4 |Start T4 |Start T4 |\n   +------------------------------------------------------------------+\n\
    \   |Rcv test|      |          |Send proh|Send proh|Send allo|Send allo|\n   +------------------------------------------------------------------+\n\
    \   |Rcv allo|      |          | Stop T2 | Stop T2 | Stop T2 | Stop T2 |\n   |\
    \        |      |          | NEP-FEA |         | NEA-FEA |         |\n   +------------------------------------------------------------------+\n\
    \   |Rcv proh|      |          | Stop T2 | Stop T2 | Stop T2 | Stop T2 |\n   |\
    \        |      |          |Send proa|Send proa|Send proa|Flush or |\n   |   \
    \     |      |          |         | NEP-FEP |         | reroute |\n   |      \
    \  |      |          |         |         |         |Send proa|\n   |        |\
    \      |          |         |         |         | NEA-FEP |\n   +------------------------------------------------------------------+\n\
    \   |Rcv proa|      |          | Stop T3 | Stop T3 |         |         |\n   +------------------------------------------------------------------+\n\
    \   |Rcv moni|      |          |Update   |Update   |Update   |Update   |\n   |\
    \        |      |          |'far end |'far end |'far end |'far end |\n   |   \
    \     |      |          |version' |version' |version' |version' |\n   |      \
    \  |      |          |based on |based on |based on |based on |\n   |        |\
    \      |          |moni     |moni     |moni     |moni     |\n   |        |   \
    \   |          |Convert  |Convert  |Convert  |Convert  |\n   |        |      |\
    \          | to mona | to mona | to mona | to mona |\n   |        |      |   \
    \       |Send mona|Send mona|Send mona|Send mona|\n   +------------------------------------------------------------------+\n\
    \   |Rcv mona|      |          |Implemen-|Implemen-|Implemen-|Implemen-|\n   |\
    \        |      |          |tation   |tation   |tation   |tation   |\n   |   \
    \     |      |          |dependent|dependent|dependent|dependent|\n   +------------------------------------------------------------------+\n\
    \   |Rcv     |      |          |   PV    |If T3 run|   PV    |Process  |\n   |\
    \ Service|      |          |         | Process |         |         |\n   |   \
    \     |      |          |         |Else PV  |         |         |\n   +------------------------------------------------------------------+\n\
    \   |Rcv mgmt|      |          |If FE<   |If FE<   |If FE<   |If FE<   |\n   |\
    \        |      |          | 2.0 PV  | 2.0 PV  | 2.0 PV  | 2.0 PV  |\n   |   \
    \     |      |          |Else     |Else     |Else     |Else     |\n   |      \
    \  |      |          | Process | Process | Process | Process |\n   +------------------------------------------------------------------+\n\
    \   |Rcv xsrv|      |          |If FE<   |If FE<   |If FE<   |If FE<   |\n   |\
    \        |      |          | 2.0 PV  | 2.0 PV  | 2.0 PV  | 2.0 PV  |\n   |   \
    \     |      |          |Else     |Else     |Else     |Else     |\n   |      \
    \  |      |          | Process | Process | Process | Process |\n   +------------------------------------------------------------------+\n\
    \   |Rcv spcl|      |          |If FE<   |If FE<   |If FE<   |If FE<   |\n   |\
    \        |      |          | 2.0 PV  | 2.0 PV  | 2.0 PV  | 2.0 PV  |\n   |   \
    \     |      |          |Else     |Else     |Else     |Else     |\n   |      \
    \  |      |          | Process | Process | Process | Process |\n   +------------------------------------------------------------------+\n\
    \   |Connect.|      | Start T1 |         |         |         |         |\n   |Estab.\
    \  |      | Start T2 |         |         |         |         |\n   |        |\
    \      | Start T4 |         |         |         |         |\n   |        |   \
    \   |(if non-0)|         |         |         |         |\n   |        |      |if\
    \ sock_  |         |         |         |         |\n   |        |      |  allowed\
    \ |         |         |         |         |\n   |        |      |  = TRUE  | \
    \        |         |         |         |\n   |        |      | send allo|    \
    \     |         |         |         |\n   |        |      | send test|       \
    \  |         |         |         |\n   |        |      | NEA-FEP  |         |\
    \         |         |         |\n   |        |      |else      |         |   \
    \      |         |         |\n   |        |      | send proh|         |      \
    \   |         |         |\n   |        |      | send test|         |         |\
    \         |         |\n   |        |      | NEP-FEP  |         |         |   \
    \      |         |\n   +------------------------------------------------------------------+\n\
    \   |Connect.|      |          |   PV    |   PV    |   PV    |   PV    |\n   |Lost\
    \    |      |          |         |         |         |         |\n   +------------------------------------------------------------------+\n\
    \   |Protocol|      |          |Stop all |Stop all |Stop all |Stop all |\n   |Violat.\
    \ |      |          | timers  | timers  | timers  | timers  |\n   |        | \
    \     |          |Close the|Close the|Close the|Close the|\n   |        |    \
    \  |          | socket  | socket  | socket  | socket  |\n   |        |      |\
    \          |Connect- |Connect- |Connect- |Connect- |\n   |        |      |   \
    \       |  ing    |  ing    |  ing    |  ing    |\n   +------------------------------------------------------------------+\n\
    \   |Mgmt.   |Open  |          |         |         |         |         |\n   |Open\
    \    |socket|          |         |         |         |         |\n   |Socket \
    \ |Conne-|          |         |         |         |         |\n   |        | cting|\
    \          |         |         |         |         |\n   +------------------------------------------------------------------+\n\
    \   |Mgmt.   |      |Close the |Stop all |Stop all |Stop all |Stop all |\n   |Close\
    \   |      | socket   | timers  | timers  | timers  | timers  |\n   |Socket  |\
    \      |OOS       |Close the|Close the|Close the|Close the|\n   |        |   \
    \   |          | socket  | socket  | socket  | socket  |\n   |        |      |\
    \          |OOS      |OOS      |OOS      |OOS      |\n   +------------------------------------------------------------------+\n\
    \   |Mgmt.   |sock_ |sock_allo-|sock_all-|sock_all-|sock_all-|sock_all-|\n   |Prohibit|allow-|\
    \ wed=FALSE| owed=   | owed=   | owed=   | owed=   |\n   |Socket  |ed =  |   \
    \       | FALSE   | FALSE   | FALSE   | FALSE   |\n   |        |FALSE |      \
    \    |         |         |send proh|send proh|\n   |        |      |         \
    \ |         |         |start t3 |start t3 |\n   |        |      |          | \
    \        |         | NEP-FEP | NEP-FEA |\n   |        |      |          |    \
    \     |         |         |         |\n   +------------------------------------------------------------------+\n\
    \   |Mgmt.   |sock_ |sock_allo-|sock_all-|sock_all-|sock_all-|sock_all-|\n   |Allow\
    \   |allow-| wed=TRUE | owed=   | owed=   | owed=   | owed=   |\n   |Traffic |ed\
    \ =  |          | TRUE    | FALSE   | TRUE    | TRUE    |\n   |        |TRUE \
    \ |          |send allo|send allo|         |         |\n   |        |      | \
    \         | NEA-FEP | NEA-FEA |         |         |\n   +------------------------------------------------------------------+\n\
    \   |User    |reject| reject   | reject  | reject  | reject  | send    |\n   |Part\
    \    |data  | data     | data    | data    | data    | data    |\n   |Msgs.  \
    \ |      |          |         |         |         |         |\n   +------------------------------------------------------------------+\n\
    \   |Request |      |          |If FE<2.0|If FE<2.0|If FE<2.0|If FE<2.0|\n   |to\
    \ Tx   |      |          | Ignore  | Ignore  | Ignore  | Ignore  |\n   |mgmt \
    \   |      |          |Else     |Else     |Else     |Else     |\n   |        |\
    \      |          | Process | Process | Process | Process |\n   +------------------------------------------------------------------+\n\
    \   |Request |      |          |If FE<2.0|If FE<2.0|If FE<2.0|If FE<2.0|\n   |to\
    \ Tx   |      |          | Ignore  | Ignore  | Ignore  | Ignore  |\n   |xsrv \
    \   |      |          |Else     |Else     |Else     |Else     |\n   |        |\
    \      |          | Process | Process | Process | Process |\n   +------------------------------------------------------------------+\n\
    \   |Request |      |          |If FE<2.0|If FE<2.0|If FE<2.0|If FE<2.0|\n   |to\
    \ Tx   |      |          | Ignore  | Ignore  | Ignore  | Ignore  |\n   |spcl \
    \   |      |          |Else     |Else     |Else     |Else     |\n   |        |\
    \      |          | Process | Process | Process | Process |\n   +------------------------------------------------------------------+\n\
    \                   Table 29: TALI 2.0 State Machine\n"
- title: 4.10 TALI 2.0 Specification Limitations
  contents:
  - "4.10 TALI 2.0 Specification Limitations\n   Several limitations with the TALI\
    \ 2.0 specification are identified.\n   These are considered possible areas for\
    \ expansion of the protocol in\n   the future:\n   *  Support for different types\
    \ of routing keys is limited.  It is\n      envisioned that new routing key types\
    \ will need to be added and\n      supported as new applications are identified.\n\
    \   *  An opcode, or new primitive within an existing opcode, could be\n     \
    \ added as a means of returning unknown or unsupported data to the\n      sender.\
    \  In addition to discarding and storing internal debug\n      data, an implementation\
    \ may want to return the original TALI\n      message to the sender when the receiver\
    \ of the message deems the\n      message to be unknown, unsupported, or incorrectly\
    \ formatted.\n"
- title: 5. Success/Failure Codes
  contents:
  - "5. Success/Failure Codes\n   The following list provides all the known success/failure\
    \ codes that\n   are being used for the rkrp feature.  New defines will be added\
    \ to\n   the end of the list as they are identified.\n   Error #    Meaning\n\
    \   1          Transaction successfully completed.\n   2          Length of TALI\
    \ msg is insufficient to contain all\n              required information for rkrp\
    \ operation\n   3          Unsupported 'rkrp' operation\n   4          Invalid\
    \ SI.  SI must be in range 0..15\n   5          Invalid SI/operation combination.\
    \  Split and resize only\n              supported for SI=4,5,13.  Enter, delete\
    \ and override\n              supported for all SI.\n   6          Invalid DPC.\
    \  Point code cannot be zero, and must be full\n              point code.\n  \
    \ 7          Invalid SSN.  SSN must be in range 0..255.\n   8          Invalid\
    \ OPC.  Point code cannot be zero, and must be full\n              point code.\n\
    \   9          Invalid CICS.  Must be in range appropriate for SI and PC\n   \
    \           type.\n   10         Invalid CICE.  Must be in range appropriate for\
    \ SI and PC\n              type.\n   11         Invalid CIC range.  CICS must\
    \ be less than or equal to\n              CICE.  On a split operation, CICS must\
    \ be strictly less\n              than than CICE (cannot split an range with only\
    \ one\n              entry).\n   12         Invalid NCICS.  Must be in range appropriate\
    \ for SI and\n              PC type.\n   13         Invalid NCICE.  Must be in\
    \ range appropriate for SI and\n              PC type.\n   14         Invalid\
    \ new CIC range.  NCICS must be less than or equal\n              to NCICE.\n\
    \   15         Invalid SPLIT value.   Must be in range appropriate for\n     \
    \         SI and PC type.  Must be greater than CICS and less than\n         \
    \     or equal to CICE.\n   16         No free entries in table.\n   17      \
    \   CIC range overlaps but does not match existing entry.\n   18         Entry\
    \ already has 16 associations.\n   19         Entry to be changed not found in\
    \ table.\n   20         New entry would overlap another entry (allowed to overlap\n\
    \              the entry being changed, but no others).\n   21         Entry to\
    \ be deleted not found in table.\n   22         TUP routing keys are not supported\
    \ for ANSI networks\n"
- title: 6. Security Considerations
  contents:
  - "6. Security Considerations\n   TALI is an interface for the transport of SS7\
    \ traffic and management\n   messages across an IP network.  As with traditional\
    \ PSTN networks,\n   the IP networks using TALI are expected to well engineered\
    \ systems.\n   The use of virtual private networks and firewalls is to be expected.\n\
    \   In addition, the use of IPSEC will bring added security benefit to\n   the\
    \ network.\n"
- title: 7. References
  contents:
  - "7. References\n   [1]  Bell Communications Research, Specification of Signaling\
    \ System\n        Number 7, GT-246-CORE, Bellcore, Issue 1, December 1994.\n \
    \  [2]  Postel, J., \"Internet Protocol\", STD 5, RFC 791, September 1981.\n \
    \  [3]  Postel, J., \"Internet Control Message Protocol\", STD 5, RFC 792,\n \
    \       September 1981.\n   [4]  Postel, J., \"Transmission Control Protocol\"\
    , STD 7, RFC 793,\n        September 1981.\n   [5]  Logical Link Control, IEEE\
    \ 802.2 and ISO 8802.2\n   [6]  Carrier Sense Multiple Access with Collision Detection\n\
    \        (Ethernet), IEEE 802.3 and ISO 8802-3 CSMA/CD.\n   [7]  Virtual LAN,\
    \ IEEE 802.1 Q and ISO 8802-1Q CSMA/CD.\n   [8]  Bell Communications Research,\
    \ Generic Requirements for CCS Nodes\n        Supporting ATM High-Speed Signaling\
    \ Links (HSLs), GR-2878-CORE,\n        Issue 1, Bellcore, November 1995.\n   [9]\
    \  Bell Communications Research, Asynchronous Transfer Mode (ATM)\n        and\
    \ ATM Adaptation Layer (AAL) Protocols, GR-1113-CORE,\n        Bellcore.\n   [10]\
    \ American National Standards Institute, B-ISDN Signaling ATM\n        Adaptation\
    \ Layer - Service Specific Connection Oriented Protocol\n        (SSCOP), T1.637.\n\
    \   [11] American National Standards Institute, B-ISDN Signaling ATM\n       \
    \ Adaptation Layer - Service Specific Coordination Function for\n        Support\
    \ of Signaling at the Network Node Interface (SSCF at the\n        NNI), T1.645.\n\
    \   [12] American National Standards Institute, B-ISDN Signaling ATM\n       \
    \ Adaptation Layer - Layer Management for the SAAL at the NNI,\n        T1.652.\n"
- title: 8. Acknowledgments
  contents:
  - "8. Acknowledgments\n   The authors would like to thank Ken Morneault for his\
    \ comments and\n   contributions to the document.\n"
- title: 9. Authors' Addresses
  contents:
  - "9. Authors' Addresses\n   David Sprague\n   Tekelec\n   5200 Paramount Pkwy.\n\
    \   Morrisville, NC  27560\n   Phone: +1 919-460-5563\n   EMail: david.sprague@tekelec.com\n\
    \   Dan Brendes\n   Tekelec\n   5200 Paramount Pkwy.\n   Morrisville, NC  27560\n\
    \   Phone: +1 919-460-2162\n   EMail: dan.brendes@tekelec.com\n   Robby Benedyk\n\
    \   Tekelec\n   5200 Paramount Pkwy.\n   Morrisville, NC  27560\n   Phone: +1\
    \ 919-460-5533\n   EMail: robby.benedyk@tekelec.com\n   Joe Keller\n   Tekelec\n\
    \   5200 Paramount Pkwy.\n   Morrisville, NC  27560\n   Phone: +1 919-460-5549\n\
    \   EMail: joe.keller@tekelec.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2001).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
