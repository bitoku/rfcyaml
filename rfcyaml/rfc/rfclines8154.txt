Abstract The Parallel Network File System (pNFS) allows a separation between the metadata (onto a metadata server) and data (onto a storage device) for a file.
The Small Computer System Interface (SCSI) layout type is defined in this document as an extension to pNFS to allow the use of SCSI based block storage devices.
Introduction Figure 1 shows the overall architecture of a Parallel NFS (pNFS) system:
The overall approach is that pNFS enhanced clients obtain sufficient information from the server to enable them to access the underlying storage (on the storage systems) directly.
See Section 12 of [RFC5661] for more details.
This document is concerned with access from pNFS clients to storage devices over block storage protocols based on the SCSI Architecture Model [SAM 5], e.g., the Fibre Channel Protocol (FCP), Internet SCSI (iSCSI), or Serial Attached SCSI (SAS).
pNFS SCSI layout requires block based SCSI command sets, for example, SCSI Block Commands [SBC3].
While SCSI command sets for non block
based access exist, these are not supported by the SCSI layout type, and all future references to SCSI storage devices will imply a block  based SCSI command set.
The Server to Storage System protocol, called the "Control Protocol", is not of concern for interoperability, although it will typically be the same SCSI based storage protocol.
This document is based on [RFC5663] and makes changes to the block layout type to provide a better pNFS layout protocol for SCSI based storage devices.
Despite these changes, [RFC5663] remains the defining document for the existing block layout type.
Block Disk Protection [RFC6688] is unnecessary in the context of the SCSI layout type because the new layout type provides mandatory disk access protection as part of the layout type definition.
In contrast to [RFC5663], this document uses SCSI protocol features to provide reliable fencing by using SCSI persistent reservations, and it can provide reliable and efficient device discovery by using SCSI device identifiers instead of having to rely on probing all devices potentially attached to a client.
This new layout type also optimizes the Input/Output (I/O) path by reducing the size of the LAYOUTCOMMIT payload.
The above two paragraphs summarize the major functional differences from [RFC5663].
There are other minor differences, e.g., the "base" volume type in this specification is used instead of the "simple" volume type in [RFC5663], but there are no significant differences in the data structures that describe the volume topology above this level (Section 2.3.2) or in the data structures that describe extents (Section 2.4).
Conventions Used in This Document
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "
SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC2119].
The following definitions are provided for the purpose of providing an appropriate context for the reader.
Byte:  an octet, i.e., a datum exactly 8 bits in length.
Client:  the entity that accesses the NFS server's resources.
The client may be an application that contains the logic to access the NFS server directly.
The client may also be the traditional operating system client that provides remote file system services for a set of applications.
Server:  the entity responsible for coordinating client access to a set of file systems and is identified by a server owner.
Metadata Server (MDS):  a pNFS server that provides metadata information for a file system object.
It also is responsible for generating layouts for file system objects.
Note that the MDS is also responsible for directory based operations.
The external data representation (XDR) description and scripts for extracting the XDR description are Code Components as described in Section 4 of "Legal Provisions Relating to IETF Documents" [LEGAL].
These Code Components are licensed according to the terms of Section 4 of "Legal Provisions Relating to IETF Documents".
This document contains the XDR [RFC4506] description of the NFSv4.1 SCSI layout protocol.
The XDR description is embedded in this document in a way that makes it simple for the reader to extract into a ready to compile form.
The reader can feed this document into the following shell script to produce the machine readable XDR description of the NFSv4.1 SCSI layout: #!
That is, if the above script is stored in a file called "extract.sh", and this document is in a file called "spec.txt", then the reader can do:
sh extract.sh < spec.txt > scsi
The embedded XDR file header follows.
Subsequent XDR descriptions with the sentinel sequence are embedded throughout the document.
Note that the XDR code contained in this document depends on types from the NFSv4.1 nfs4 prot.x file [RFC5662].
This code was derived from RFC 8154.
Please reproduce this note if possible.
Neither the name of Internet Society, IETF or IETF ///
IS PROVIDED BY THE COPYRIGHT HOLDERS ///
AS IS" AND ANY EXPRESS
FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
EVENT SHALL THE COPYRIGHT OWNER
NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
HOWEVER CAUSED AND ON ANY THEORY OF ///
IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
The fundamental storage model supported by SCSI storage devices is a logical unit (LU) consisting of a sequential series of fixed size blocks.
Logical units used as devices for NFS SCSI layouts, and the SCSI initiators used for the pNFS metadata server and clients, MUST support SCSI persistent reservations as defined in [SPC4].
A pNFS layout for this SCSI class of storage is responsible for mapping from an NFS file (or portion of a file) to the blocks of storage volumes that contain the file.
The blocks are expressed as extents with 64 bit offsets and lengths using the existing NFSv4 offset4 and length4 types.
Clients MUST be able to perform I/
O to the block extents without affecting additional areas of storage (especially important for writes); therefore, extents MUST be aligned to logical block size boundaries of the underlying logical units (typically 512 or 4096 bytes).
For complex volume topologies, the server MUST ensure extents are aligned to the logical block size boundaries of the largest logical block size in the volume topology.
The pNFS operation for requesting a layout (LAYOUTGET) includes the "layoutiomode4 loga iomode" argument, which indicates whether the requested layout is for read only use or read write use.
A read only layout may contain holes that are read as zero, whereas a read write layout will contain allocated but uninitialized storage in those holes (read as zero, can be written by client).
This document also supports client participation in copy on write (e.g., for file systems with snapshots) by providing both read only and uninitialized storage for the same range in a layout.
Reads are initially performed on the read only storage, with writes going to the uninitialized storage.
After the first write that initializes the uninitialized storage, all reads are performed to that now  initialized writable storage, and the corresponding read only storage is no longer used.
The SCSI layout solution expands the security responsibilities of the pNFS clients, and there are a number of environments where the mandatory to implement security properties for NFS cannot be satisfied.
The additional security responsibilities of the client follow, and a full discussion is present in Section 4 ("Security Considerations").
Typically, SCSI storage devices provide access control mechanisms (e.g., Logical Unit Number (LUN) mapping and/or masking), which operate at the granularity of individual hosts, not individual blocks.
For this reason, block based protection must be provided by the client software.
Similarly, SCSI storage devices typically are not able to validate NFS locks that apply to file regions.
For instance, if a file is covered by a mandatory read only lock, the server can ensure that only readable layouts for the file are granted to pNFS clients.
However, it is up to each pNFS client to ensure that the readable layout is used only to service read requests and not to allow writes to the existing parts of the file.
Since SCSI storage devices are generally not capable of enforcing such file based security, in environments where pNFS clients cannot be trusted to enforce such policies, pNFS SCSI layouts MUST NOT be used.
The layout4 type defined in [RFC5662] is extended with a new value as follows:
[RFC5661] specifies the loc body structure as an XDR type "opaque".
The opaque layout is uninterpreted by the generic pNFS client layers but obviously must be interpreted by the layout type implementation.
Volume Identification SCSI targets implementing [SPC4] export unique LU names for each LU through the Device Identification Vital Product Data (VPD) page (page code 0x83), which can be obtained using the INQUIRY command with the Enable VPD (
EVPD) bit set to one.
This document uses a subset of this information to identify LUs backing pNFS SCSI layouts.
The Device Identification VPD page descriptors used to identify LUs for use with pNFS SCSI layouts must adhere to the following restrictions: 1.
The "ASSOCIATION" MUST be set to 0 (The "DESIGNATOR" field is associated with the addressed logical unit).
The "DESIGNATOR TYPE" MUST be set to one of four values that are required for the mandatory logical unit name in Section 7.7.3 of [SPC4], as explicitly listed in the "pnfs scsi designator type" enumeration: PS DESIGNATOR T10 based on T10 vendor ID PS DESIGNATOR EUI64 based on EUI 64 PS DESIGNATOR NAA Network Address Authority
(NAA) PS DESIGNATOR NAME SCSI name string 3.
Any other association or designator type MUST NOT be used.
Use of T10 vendor IDs is discouraged when one of the other types can be used.
The "CODE SET" VPD page field is stored in the "sbv code set" field of the "pnfs scsi base volume info4" data structure, the "DESIGNATOR TYPE" is stored in "sbv designator type", and the DESIGNATOR is stored in "sbv designator".
Due to the use of an XDR array, the "DESIGNATOR LENGTH" field does not need to be set separately.
Only certain combinations of "sbv code set" and "sbv designator type" are valid; please refer to [SPC4] for details, and note that ASCII MAY be used as the code set for UTF 8 text that contains only printable ASCII characters.
Note that a Device Identification VPD page MAY contain multiple descriptors with the same association, code set, and designator type.
Thus, NFS clients MUST check all the descriptors for a possible match to "sbv code set", "sbv designator type", and "sbv designator".
Storage devices such as storage arrays can have multiple physical network interfaces that need not be connected to a common network, resulting in a pNFS client having simultaneous multipath access to the same storage volumes via different ports on different networks.
Selection of one or multiple ports to access the storage device is left up to the client.
Additionally, the server returns a persistent reservation key in the "sbv pr key" field.
See Section 2.4.10 for more details on the use of persistent reservations.
The pNFS SCSI layout volume topology is expressed in terms of the volume types described below.
The individual components of the topology are contained in an array, and components MAY refer to other components by using array indices.
PNFS SCSI VOLUME CONCAT   2,
/  volume is striped across ///
Code sets from SPC 4.
The types of aggregations that are allowed are stripes, concatenations, and slices.
Note that the volume topology expressed in the "pnfs scsi deviceaddr4" data structure will always resolve to a set of "pnfs scsi volume type4" PNFS SCSI VOLUME BASE.
The array of volumes is ordered such that the root of the volume hierarchy is the last element of the array.
Concat, slice, and stripe volumes MUST refer to volumes defined by lower indexed elements of the array.
The "pnfs scsi deviceaddr4" data structure is returned by the server as the storage protocol specific opaque field "da addr body" in the "device addr4" data structure by a successful GETDEVICEINFO operation [RFC5661].
As noted above, all "device addr4" data structures eventually resolve to a set of volumes of type PNFS SCSI VOLUME BASE.
Complicated volume hierarchies may be composed of dozens of volumes, each with several components; thus, the device address may require several kilobytes.
The client SHOULD be prepared to allocate a large buffer to contain the result.
In the case of the server returning
NFS4ERR TOOSMALL, the client SHOULD allocate a buffer of at least gdir mincount bytes to contain the expected result and retry the GETDEVICEINFO request.
SCSI layout is a list of extents within a flat array of data blocks in a volume.
The details of the volume topology can be determined by using the GETDEVICEINFO operation.
The SCSI layout describes the individual block extents on the volume that make up the file.
The offsets and length contained in an extent are specified in units of bytes.
It is a hole in the file.
d of the volume on ///
which extent of file is ///
The SCSI layout consists of a list of extents that map the regions of the file to locations on a volume.
The "se storage offset" field within each extent identifies a location on the volume specified by the "se vol id" field in the extent.
The "se vol id" itself is shorthand for the whole topology of the volume on which the file is stored.
The client is responsible for translating this volume  relative offset into an offset on the appropriate underlying SCSI LU.
Each extent maps a region of the file onto a portion of the specified LU.
"se length", and "se state" fields for an extent returned from the server are valid for all extents.
In contrast, the interpretation of the "se storage offset" field depends on the value of "se state" as follows (in increasing order):
WRITE DATA "se storage offset" is valid and points to valid/initialized data that can be read and written.
DATA "se storage offset" is valid and points to valid/initialized data that can only be read.
PNFS SCSI INVALID DATA "se storage offset" is valid but points to invalid, uninitialized data.
This data MUST not be read from the disk until it has been initialized.
A read request for a PNFS SCSI INVALID DATA extent MUST fill the user buffer with zeros, unless the extent is covered by a PNFS SCSI READ DATA extent of a copy on write file system.
Write requests MUST write whole server sized blocks to the disk; bytes not initialized by the user MUST be set to zero.
Any write to storage in a PNFS SCSI INVALID DATA extent changes the written portion of the extent
to PNFS SCSI READ WRITE DATA; the pNFS client is responsible for reporting this change via LAYOUTCOMMIT.
PNFS SCSI NONE DATA "se storage offset" is not valid, and this extent MAY not be used to satisfy write requests.
Read requests MAY be satisfied by zero filling as for PNFS SCSI INVALID DATA.
NONE DATA extents MAY be returned by requests for readable extents; they are never returned if the request was for a writable extent.
An extent list contains all relevant extents in increasing order of the se file offset of each extent; any ties are broken by increasing order of the extent state (se state).
Layout Requests and Extent Lists
Each request for a layout specifies at least three parameters: file offset, desired size, and minimum size.
If the status of a request indicates success, the extent list returned MUST meet the following criteria:
A request for a readable (but not writable) layout MUST return either PNFS SCSI READ DATA or PNFS SCSI
It SHALL NOT return PNFS SCSI INVALID DATA or PNFS SCSI
A request for a writable layout MUST return PNFS SCSI READ WRITE DATA or PNFS SCSI INVALID DATA extents, and it MAY return additional PNFS SCSI READ DATA extents for ranges covered by PNFS SCSI INVALID DATA extents to allow client side copy on write operations.
A request for a writable layout SHALL NOT return PNFS SCSI NONE DATA extents.
The first extent in the list MUST contain the requested starting offset.
The total size of extents within the requested range MUST cover at least the minimum size.
One exception is allowed: the total size MAY be smaller if only readable extents were requested and EOF is encountered.
Extents in the extent list MUST be logically contiguous for a read only layout.
For a read write layout, the set of writable extents (i.e., excluding PNFS SCSI READ DATA extents) MUST be logically contiguous.
Every PNFS SCSI READ DATA extent in a read
write layout MUST be covered by one or more PNFS SCSI INVALID DATA extents.
This overlap of PNFS SCSI READ DATA and PNFS SCSI INVALID DATA extents
is the only permitted extent overlap.
Extents MUST be ordered in the list by starting offset, with PNFS SCSI READ DATA extents preceding PNFS SCSI INVALID DATA extents in the case of equal se file offsets.
According to [RFC5661], if the minimum requested size, loga minlength, is zero, this is an indication to the metadata server that the client desires any layout at offset loga offset or less that the metadata server has "readily available".
Given the lack of a clear definition of this phrase, in the context of the SCSI layout type, when loga minlength is zero, the metadata server SHOULD do the following:  when processing requests for readable layouts, return all such layouts, even if some extents are in the PNFS SCSI NONE DATA state.
when processing requests for writable layouts, return extents that can be returned in the PNFS SCSI READ WRITE DATA state.
SCSI layout specific type for lou body
The "slu commit list" field is a list covering regions of the file layout that were previously in the PNFS SCSI INVALID DATA state but have been written by the client and SHOULD now be considered in the PNFS SCSI READ WRITE DATA state.
The extents in the commit list MUST be disjoint and MUST be sorted by sr file offset.
Implementors should be aware that a server MAY be unable to commit regions at a granularity smaller than a file system block (typically 4 KB or 8 KB).
As noted above, the block size that the server uses is available as an NFSv4 attribute, and any extents included in the "slu commit list" MUST be aligned to this granularity and have a size that is a multiple of this granularity.
Since the block in question is in state PNFS SCSI INVALID DATA,
byte ranges not written SHOULD be filled with zeros.
This applies even if it appears that the area being written is beyond what the client believes to be the end of file.
A LAYOUTRETURN operation represents an explicit release of resources by the client.
This MAY be done in response to a CB LAYOUTRECALL or before any recall, in order to avoid a future CB LAYOUTRECALL.
When the LAYOUTRETURN operation specifies a LAYOUTRETURN4 FILE return type, then the "layoutreturn file4" data structure specifies the region of the file layout that is no longer needed by the client.
The LAYOUTRETURN operation is done without any data specific to the SCSI layout.
The opaque "lrf body" field of the "layoutreturn file4" data structure MUST have length zero.
Layout Revocation Layouts MAY be unilaterally revoked by the server due to the client's lease time expiring or the client failing to return a layout that has been recalled in a timely manner.
For the SCSI layout type, this is accomplished by fencing off the client from access to storage as described in Section 2.4.10.
When this is done, it is necessary that all I/
Os issued by the fenced off client be rejected by the storage.
This includes any in flight
the client issued before the layout was revoked.
Note that the granularity of this operation can only be at the host/ LU level.
Thus, if one of a client's layouts is unilaterally revoked by the server, it will effectively render useless  all  of the client's layouts for files located on the storage units comprising the volume.
This may render useless the client's layouts for files in other file systems.
See Section 2.4.10.5 for a discussion of recovery from fencing.
Client Copy on Write Processing Copy on write is a mechanism used to support file and/or file system snapshots.
When writing to unaligned regions, or to regions smaller than a file system block, the writer MUST copy the portions of the original file data to a new location on disk.
This behavior can be implemented either on the client or the server.
The paragraphs below describe how a pNFS SCSI layout client implements access to a file that requires copy on write semantics.
Distinguishing the PNFS SCSI READ WRITE DATA and PNFS SCSI
DATA extent types in combination with the allowed overlap of PNFS SCSI READ
DATA extents with PNFS SCSI INVALID DATA extents allows copy on write processing to be done by pNFS clients.
In classic NFS, this operation would be done by the server.
Since pNFS enables clients to do direct block access, it is useful for clients to participate in copy on write operations.
pNFS clients MUST support this copy on write processing.
When a client wishes to write data covered by a PNFS SCSI READ DATA extent, it MUST have requested a writable layout from the server; that layout will contain PNFS SCSI INVALID DATA extents to cover all the data ranges of that layout's PNFS SCSI READ DATA extents.
More precisely, for any se file offset range covered by one or more PNFS SCSI READ DATA extents in a writable layout, the server MUST include one or more PNFS SCSI INVALID DATA extents in the layout that cover the same se file offset range.
When performing a write to such an area of a layout, the client MUST effectively copy the data from the PNFS SCSI READ DATA extent for any partial blocks of se file offset and range, merge in the changes to be written, and write the result to the PNFS SCSI INVALID DATA extent for the blocks for that se file offset and range.
That is, if entire blocks of data are to be overwritten by an operation, the corresponding PNFS SCSI READ DATA blocks need not be fetched, but
any partial  block writes MUST be merged with data fetched via PNFS SCSI
READ DATA extents before storing the result via PNFS SCSI INVALID DATA extents.
For the purposes of this discussion, "entire blocks" and "partial blocks" refer to the block size of the server's file system.
Storing of data in a PNFS SCSI INVALID DATA extent converts the written portion of the PNFS SCSI INVALID DATA extent to a PNFS SCSI READ WRITE DATA extent; all subsequent reads MUST be performed from this extent; the corresponding portion of the PNFS SCSI READ DATA extent MUST NOT be used after storing data in a PNFS SCSI INVALID DATA extent.
If a client writes only a portion of an extent, the extent MAY be split at block aligned boundaries.
When a client wishes to write data to a PNFS SCSI INVALID DATA extent that is not covered by a PNFS SCSI READ DATA extent, it MUST treat this write identically to a write to a file not involved with copy  on write semantics.
Thus, data MUST be written in at least block
sized increments and aligned to multiples of block sized offsets, and unwritten portions of blocks MUST be zero filled.
Extents Are Permissions Layout extents returned to pNFS clients grant permission to read or write; PNFS SCSI READ DATA and PNFS SCSI
NONE DATA are read only (PNFS SCSI NONE DATA reads as zeros), and PNFS SCSI READ WRITE DATA and
PNFS SCSI INVALID DATA are read write (PNFS SCSI INVALID DATA reads as zeros; any write converts it to PNFS SCSI READ WRITE DATA).
This is the only means a client has of obtaining permission to perform direct I/
O to storage devices; a pNFS client MUST NOT perform direct I/O operations that are not permitted by an extent held by the client.
Client adherence to this rule places the pNFS server in control of potentially conflicting storage device operations, enabling the server to determine what does conflict and how to avoid conflicts by granting and recalling extents to/from clients.
If a client makes a layout request that conflicts with an existing layout delegation, the request will be rejected with the error NFS4ERR LAYOUTTRYLATER.
This client is then expected to retry the request after a short interval.
During this interval, the server SHOULD recall the conflicting portion of the layout delegation from the client that currently holds it.
This reject and retry approach does not prevent client starvation when there is contention for the layout of a particular file.
For this reason, a pNFS server SHOULD implement a mechanism to prevent starvation.
One possibility is that the server can maintain a queue of rejected layout requests.
Each new layout request can be checked to see if it conflicts with a previous rejected request, and if so, the newer request can be rejected.
Once the original requesting client retries its request, its entry in the rejected request queue can be cleared, or the entry in the rejected request queue can be removed when it reaches a certain age.
NFSv4 supports mandatory locks and share reservations.
These are mechanisms that clients can use to restrict the set of I/O operations that are permissible to other clients.
I/O operations ultimately arrive at the NFSv4 server for processing, the server is in a position to enforce these restrictions.
However, with pNFS layouts, I/Os will be issued from the clients that hold the layouts directly to the storage devices that host the data.
These devices have no knowledge of files, mandatory locks, or share reservations, and they are not in a position to enforce such restrictions.
For this reason, the NFSv4 server MUST NOT grant layouts that conflict with mandatory locks or share reservations.
Further, if a conflicting mandatory lock request or a conflicting OPEN request arrives at the server, the server MUST recall the part of the layout in conflict with the request before granting the request.
Partial Block Updates SCSI storage devices do not provide byte granularity access and can only perform read and write operations atomically on a block granularity.
Writes to SCSI storage devices thus require read  modify write cycles to write data that is smaller than the block size or that is otherwise not block aligned.
Write operations from multiple clients to the same block can thus lead to data corruption even if the byte range written by the applications does not overlap.
When there are multiple clients who wish to access the same block, a pNFS server MUST avoid these conflicts by implementing a concurrency control policy of single writer XOR multiple readers for a given data block.
The end of file location can be changed in two ways: implicitly as the result of a WRITE or LAYOUTCOMMIT beyond the current end of file or explicitly as the result of a SETATTR request.
Typically, when a file is truncated by an NFSv4 client via the SETATTR call, the server frees any disk blocks belonging to the file that are beyond the new end of file byte and MUST write zeros to the portion of the new end  of file block beyond the new end of file byte.
These actions render semantically invalid any pNFS layouts that refer to the blocks that are freed or written.
Therefore, the server MUST recall from clients the portions of any pNFS layouts that refer to blocks that will be freed or written by the server before effecting the file truncation.
These recalls may take time to complete; as explained in [RFC5661], if the server cannot respond to the client SETATTR request in a reasonable amount of time, it SHOULD reply to the client with the error NFS4ERR DELAY.
Blocks in the PNFS SCSI INVALID DATA state that lie beyond the new end of file block present a special case.
The server has reserved these blocks for use by a pNFS client with a writable layout for the file, but the client has yet to commit the blocks, and they are not yet a part of the file mapping on disk.
The server MAY free these blocks while processing the SETATTR request.
If so, the server MUST recall any layouts from pNFS clients that refer to the blocks before processing the truncate.
If the server does not free the PNFS SCSI INVALID DATA blocks while processing the SETATTR request, it need not recall layouts that refer only to the PNFS SCSI INVALID DATA blocks.
When a file is extended implicitly by a WRITE or LAYOUTCOMMIT beyond the current end of file, or extended explicitly by a SETATTR request, the server need not recall any portions of any pNFS layouts.
The layout hint attribute specified in [RFC5661] is not supported by the SCSI layout, and the pNFS server MUST reject setting a layout hint attribute with a loh type value of LAYOUT4 SCSI VOLUME during OPEN or SETATTR operations.
On a file system only supporting the SCSI layout, a server MUST NOT report the layout hint attribute in the supported attrs attribute.
The pNFS SCSI protocol must handle situations in which a system failure, typically a network connectivity issue, requires the server to unilaterally revoke extents from a client after the client fails to respond to a CB LAYOUTRECALL request.
This is implemented by fencing off a non responding client from access to the storage device.
The pNFS SCSI protocol implements fencing using persistent reservations (PRs), similar to the fencing method used by existing shared disk file systems.
By placing a PR of type "Exclusive Access Registrants Only" on each SCSI LU exported to pNFS clients, the MDS prevents access from any client that does not have an outstanding device ID that gives the client a reservation key to access the LU and allows the MDS to revoke access to the logical unit at any time.
To allow fencing individual systems, each system MUST use a unique persistent reservation key.
[SPC4] does not specify a way to generate keys.
This document assigns the burden to generate unique keys to the MDS, which MUST generate a key for itself before exporting a volume and a key for each client that accesses SCSI layout volumes.
Individuals keys for each volume that a client can access are permitted but not required.
PRs   MDS Registration and Reservation
Before returning a PNFS SCSI VOLUME BASE volume to the client, the MDS needs to prepare the volume for fencing using PRs.
This is done by registering the reservation generated for the MDS with the device using the "PERSISTENT RESERVE OUT" command with a service action of "REGISTER", followed by a "PERSISTENT RESERVE OUT" command with a service action of "RESERVE" and the "TYPE" field set to 8h (Exclusive Access Registrants Only).
To make sure all I T nexuses (see Section 3.1.45 of [SAM 5]) are registered, the MDS SHOULD set the "All Target Ports" (ALL TG PT) bit when registering the key or otherwise ensure the registration is performed for each target port, and it MUST perform registration for each initiator port.
Before performing the first I/O to a device returned from a GETDEVICEINFO operation, the client will register the registration key returned in sbv pr key with the storage device by issuing a "PERSISTENT RESERVE OUT" command with a service action of REGISTER with the "SERVICE ACTION RESERVATION KEY" set to the reservation key returned in sbv pr key.
To make sure all I T nexuses are registered, the client SHOULD set the "All Target Ports" (ALL TG PT) bit when registering the key or otherwise ensure the registration is performed for each target port, and it MUST perform registration for each initiator port.
When a client stops using a device earlier returned by GETDEVICEINFO, it MUST unregister the earlier registered key by issuing a "PERSISTENT RESERVE OUT" command with a service action of "REGISTER" with the "RESERVATION KEY" set to the earlier registered reservation key.
In case of a non responding client, the MDS fences the client by issuing a "PERSISTENT RESERVE OUT" command with the service action set to "PREEMPT" or "PREEMPT AND ABORT", the "RESERVATION KEY" field set to the server's reservation key, the service action "RESERVATION KEY" field set to the reservation key associated with the non  responding client, and the "TYPE" field set to 8h (Exclusive Access Registrants Only).
After the MDS preempts a client, all client I/O to the LU fails.
The client SHOULD at this point return any layout that refers to the device ID that points to the LU.
Note that the client can distinguish I/O errors due to fencing from other errors based on the "RESERVATION CONFLICT" SCSI status.
Refer to [SPC4] for details.
Client Recovery after a Fence Action A client that detects a "RESERVATION CONFLICT" SCSI status (I/O error) on the storage devices MUST commit all layouts that use the storage device through the MDS, return all outstanding layouts for the device, forget the device ID, and unregister the reservation key.
MAY refer to the storage device again, in which case the client will perform a new registration based on the key provided (via sbv pr key) at that time.
A critical requirement in crash recovery is that both the client and the server know when the other has failed.
Additionally, it is required that a client sees a consistent view of data across server restarts.
These requirements and a full discussion of crash recovery issues are covered in Section 8.4 ("Crash Recovery") of the NFSv4.1 specification [RFC5661].
This document contains additional crash recovery material specific only to the SCSI layout.
When the server crashes while the client holds a writable layout, the client has written data to blocks covered by the layout, and the blocks are still in the PNFS SCSI INVALID DATA state, the client has two options for recovery.
If the data that has been written to these blocks is still cached by the client, the client can simply re write the data via
once the server has come back online.
However, if the data is no longer in the client's cache, the client MUST NOT attempt to source the data from the data servers.
Instead, it SHOULD attempt to commit the blocks in question to the server during the server's recovery grace period by sending a LAYOUTCOMMIT with the "loca reclaim" flag set to true.
This process is described in detail in Section 18.42.4 of [RFC5661].
The server MAY decide that it cannot hold all of the state for layouts without running out of resources.
In such a case, it is free to recall individual layouts using CB LAYOUTRECALL to reduce the load, or it MAY choose to request that the client return any layout.
The NFSv4.1 specification [RFC5661] defines the following types:
The server may respond to LAYOUTGET with a variety of error statuses.
These errors can convey transient conditions or more permanent conditions that are unlikely to be resolved soon.
The error NFS4ERR RECALLCONFLICT indicates that the server has recently issued a CB LAYOUTRECALL to the requesting client, making it necessary for the client to respond to the recall before processing the layout request.
A client can wait for that recall to be received and processed, or it can retry as NFS4ERR TRYLATER, as described below.
The error NFS4ERR TRYLATER is used to indicate that the server cannot immediately grant the layout to the client.
This may be due to constraints on writable sharing of blocks by multiple clients or to a conflict with a recallable lock (e.g., a delegation).
In either case, a reasonable approach for the client is to wait several milliseconds and retry the request.
The client SHOULD track the number of retries, and if forward progress is not made, the client SHOULD abandon the attempt to get a layout and perform READ and WRITE operations by sending them to the server.
The error NFS4ERR LAYOUTUNAVAILABLE MAY be returned by the server if layouts are not supported for the requested file or its containing file system.
The server MAY also return this error code if the server is in the process of migrating the file from secondary storage, there is a conflicting lock that would prevent the layout from being granted, or any other reason causes the server to be unable to supply the layout.
As a result of receiving NFS4ERR LAYOUTUNAVAILABLE, the client SHOULD abandon the attempt to get a layout and perform READ and WRITE operations by sending them to the MDS.
It is expected that a client will not cache the file's layoutunavailable state forever.
In particular, when the file is closed or opened by the client, issuing a new LAYOUTGET is appropriate.
Many storage devices implement volatile write caches that require an explicit flush to persist the data from write operations to stable storage.
Storage devices implementing [SBC3] should indicate a volatile write cache by setting the Write Cache Enable (WCE) bit to 1 in the Caching mode page.
When a volatile write cache is used, the pNFS server MUST ensure the volatile write cache has been committed to stable storage before the LAYOUTCOMMIT operation returns by using one of the SYNCHRONIZE CACHE commands.
The functionality provided by SCSI persistent reservations makes it possible for the MDS to control access by individual client machines to specific LUs.
Individual client machines may be allowed to or prevented from reading or writing to certain block devices.
Finer  grained access control methods are not generally available.
For this reason, certain responsibilities for enforcing NFSv4 semantics, including security and locking, are delegated to pNFS clients when SCSI layouts are being used.
The metadata server's role is to only grant layouts appropriately, and the pNFS clients have to be trusted to only perform accesses allowed by the layout extents they currently hold (e.g., not access storage for files on which a layout extent is not held).
In general, the server will not be able to prevent a client that holds a layout for a file from accessing parts of the physical disk not covered by the layout.
Similarly, the server will not be able to prevent a client from accessing blocks covered by a layout that it has already returned.
The pNFS client must respect the layout model for this mapping type to appropriately respect NFSv4 semantics.
Furthermore, there is no way for the storage to determine the specific NFSv4 entity (principal, openowner, lockowner) on whose behalf the I/
O operation is being done.
This fact may limit the functionality to be supported and require the pNFS client to implement server policies other than those describable by layouts.
In cases in which layouts previously granted become invalid, the server has the option of recalling them.
In situations in which communication difficulties prevent this from happening, layouts may be revoked by the server.
This revocation is accompanied by changes in persistent reservation that have the effect of preventing SCSI access to the LUs in question by the client.
The effective implementation of these NFSv4 semantic constraints is complicated by the different granularities of the actors for the different types of the functionality to be enforced:  To enforce security constraints for particular principals.
To enforce locking constraints for particular owners (openowners and lockowners).
Fundamental to enforcing both of these sorts of constraints is the principle that a pNFS client must not issue a SCSI I/
O operation unless it possesses both:  A valid open stateid for the file in question, performing the I/O that allows I/
O of the type in question, which is associated with the openowner and principal on whose behalf
the I/O is to be done.
A valid layout stateid for the file in question that covers the byte range on which the I/O is to be done and that allows I/
O of that type to be done.
As a result, if the equivalent of I/O with an anonymous or write  bypass stateid is to be done, it MUST NOT by done using the pNFS SCSI layout type.
The client MAY attempt such I/
O using READs and WRITEs that do not use pNFS and are directed to the MDS.
When open stateids are revoked, due to lease expiration or any form of administrative revocation, the server MUST recall all layouts that allow I/O to be done on any of the files for which open revocation happens.
When there is a failure to successfully return those layouts, the client MUST be fenced.
The restriction noted above provides adequate enforcement of appropriate security restriction when the principal issuing the I/O is the same as that opening the file.
The server is responsible for checking that the I/
O mode requested by the OPEN is allowed for the principal doing the OPEN.
If the correct sort of
I/O is done on behalf of the same principal, then the security restriction is thereby enforced.
If I/O is done by a principal different from the one that opened the file, the client SHOULD send the I
/O to be performed by the metadata server rather than doing it directly to the storage device.
3.3.  Enforcing Locking Restrictions Mandatory enforcement of whole file locking by means of share reservations is provided when the pNFS client obeys the requirement set forth in Section 3.1.
I/O requires a valid open stateid, an I
/O that violates an existing share reservation would only be possible when the server allows conflicting open stateids to exist.
The nature of the SCSI layout type is that such implementation/ enforcement of mandatory byte range locks is very difficult.
Given that layouts are granted to clients rather than owners, the pNFS client is in no position to successfully arbitrate among multiple lockowners on the same client.
Suppose lockowner A is doing a write and, while the I/O is pending, lockowner B requests a mandatory byte  range lock for a byte range potentially overlapping the pending I/O.
In such a situation, the lock request cannot be granted while the I/O is pending.
In a non pNFS environment, the server would have to wait for pending I
O before granting the mandatory byte range lock.
In the pNFS environment, the server does not issue the
I/O and is thus in no position to wait for its completion.
The server may recall such layouts, but in doing so, it has no way of distinguishing those being used by lockowners A and B, making it difficult to allow B to perform I
O while forbidding A from doing so.
Given this fact, the MDS need to successfully recall all layouts that overlap the range being locked before returning a successful response to the LOCK request.
While the lock is in effect, the server SHOULD respond to requests for layouts that overlap a currently locked area with NFS4ERR LAYOUTUNAVAILABLE.
To simplify the required logic, a server MAY do this for all layout requests on the file in question as long as there are any byte range locks in effect.
Given these difficulties, it may be difficult for servers supporting mandatory byte range locks to also support SCSI layouts.
Servers can support advisory byte range locks instead.
The NFSv4 protocol currently has no way of determining whether byte range lock support on a particular file system will be mandatory or advisory, except by trying operation, which would conflict if mandatory locking is in effect.
Therefore, to avoid confusion, servers SHOULD NOT switch between mandatory and advisory byte range locking based on whether any SCSI layouts have been obtained or whether a client that has obtained a SCSI layout has requested a byte range lock.
Security Considerations Access to SCSI storage devices is logically at a lower layer of the
I/O stack than NFSv4; hence, NFSv4 security is not directly applicable to protocols that access such storage directly.
Depending on the protocol, some of the security mechanisms provided by NFSv4 (e.g., encryption and cryptographic integrity) may not be available or may be provided via different means.
At one extreme, pNFS with SCSI layouts can be used with storage access protocols (e.g., Serial Attached SCSI [SAS3]) that provide essentially no security functionality.
At the other extreme, pNFS may be used with storage protocols such as iSCSI
[RFC7143] that can provide significant security functionality.
It is the responsibility of those administering and deploying pNFS with a SCSI storage access protocol to ensure that appropriate protection is provided to that protocol
(physical security is a common means for protocols not based on IP).
In environments where the security requirements for the storage protocol cannot be met, pNFS SCSI layouts SHOULD NOT be used.
When using IP based storage protocols such as iSCSI,
IPsec should be used as outlined in [RFC3723] and updated in [RFC7146].
When security is available for a storage protocol, it is generally at a different granularity and with a different notion of identity than NFSv4 (e.g.
, NFSv4 controls user access to files, and iSCSI controls initiator access to volumes).
The responsibility for enforcing appropriate correspondences between these security layers is placed upon the pNFS client.
As with the issues in the first paragraph of this section, in environments where the security requirements are such that client side protection from access to storage outside of the layout is not sufficient, pNFS SCSI layouts SHOULD NOT be used.
IANA Considerations IANA has assigned a new pNFS layout type in the "pNFS Layout Types Registry" as follows:
