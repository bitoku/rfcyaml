- contents:
  - '        Web Distributed Authoring and Versioning (WebDAV) SEARCH

    '
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2008 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents
    (http://trustee.ietf.org/\n   license-info) in effect on the date of publication
    of this document.\n   Please review these documents carefully, as they describe
    your rights\n   and restrictions with respect to this document.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document specifies a set of methods, headers, and properties\n
    \  composing Web Distributed Authoring and Versioning (WebDAV) SEARCH,\n   an
    application of the HTTP/1.1 protocol to efficiently search for DAV\n   resources
    based upon a set of client-supplied criteria.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .
    . . . . . .  4\n     1.1.  DASL . . . . . . . . . . . . . . . . . . . . . . .
    . . . .  4\n     1.2.  Relationship to DAV  . . . . . . . . . . . . . . . . .
    . .  4\n     1.3.  Terms  . . . . . . . . . . . . . . . . . . . . . . . . . .
    \ 5\n     1.4.  Notational Conventions . . . . . . . . . . . . . . . . . .  6\n
    \    1.5.  Note on Usage of 'DAV:' XML Namespace  . . . . . . . . . .  7\n     1.6.
    \ An Overview of DASL at Work  . . . . . . . . . . . . . . .  7\n   2.  The SEARCH
    Method  . . . . . . . . . . . . . . . . . . . . . .  7\n     2.1.  Overview .
    . . . . . . . . . . . . . . . . . . . . . . . .  7\n     2.2.  The Request  .
    . . . . . . . . . . . . . . . . . . . . . .  8\n       2.2.1.  The Request-URI
    \ . . . . . . . . . . . . . . . . . . .  8\n       2.2.2.  The Request Body .
    . . . . . . . . . . . . . . . . . .  8\n     2.3.  The Successful 207 (Multistatus)
    Response  . . . . . . . .  9\n       2.3.1.  Result Set Truncation  . . . . .
    . . . . . . . . . . .  9\n       2.3.2.  Extending the PROPFIND Response  . .
    . . . . . . . . . 10\n       2.3.3.  Example: A Simple Request and Response .
    . . . . . . . 10\n       2.3.4.  Example: Result Set Truncation . . . . . . .
    . . . . . 11\n     2.4.  Unsuccessful Responses . . . . . . . . . . . . . . .
    . . . 12\n       2.4.1.  Example of an Invalid Scope  . . . . . . . . . . . .
    . 12\n   3.  Discovery of Supported Query Grammars  . . . . . . . . . . . . 13\n
    \    3.1.  The OPTIONS Method . . . . . . . . . . . . . . . . . . . . 13\n     3.2.
    \ The DASL Response Header . . . . . . . . . . . . . . . . . 14\n     3.3.  DAV:supported-query-grammar-set
    (Protected)  . . . . . . . 14\n     3.4.  Example: Grammar Discovery . . . . .
    . . . . . . . . . . . 15\n   4.  Query Schema Discovery: QSD  . . . . . . . .
    . . . . . . . . . 17\n     4.1.  Additional SEARCH Semantics  . . . . . . . .
    . . . . . . . 17\n       4.1.1.  Example of Query Schema Discovery  . . . . .
    . . . . . 18\n   5.  The DAV:basicsearch Grammar  . . . . . . . . . . . . . .
    . . . 19\n     5.1.  Introduction . . . . . . . . . . . . . . . . . . . . . .
    . 19\n     5.2.  The DAV:basicsearch DTD  . . . . . . . . . . . . . . . . . 20\n
    \      5.2.1.  Example Query  . . . . . . . . . . . . . . . . . . . . 22\n     5.3.
    \ DAV:select . . . . . . . . . . . . . . . . . . . . . . . . 23\n     5.4.  DAV:from
    . . . . . . . . . . . . . . . . . . . . . . . . . 23\n       5.4.1.  Relationship
    to the Request-URI  . . . . . . . . . . . 23\n       5.4.2.  Scope  . . . . .
    . . . . . . . . . . . . . . . . . . . 24\n     5.5.  DAV:where  . . . . . . .
    . . . . . . . . . . . . . . . . . 24\n       5.5.1.  Use of Three-Valued Logic
    in Queries . . . . . . . . . 24\n       5.5.2.  Handling Optional Operators  .
    . . . . . . . . . . . . 24\n       5.5.3.  Treatment of NULL Values . . . . .
    . . . . . . . . . . 24\n       5.5.4.  Treatment of Properties with Mixed/Element
    Content . . 25\n       5.5.5.  Example: Testing for Equality  . . . . . . . .
    . . . . 25\n       5.5.6.  Example: Relative Comparisons  . . . . . . . . . .
    . . 25\n     5.6.  DAV:orderby  . . . . . . . . . . . . . . . . . . . . . . .
    26\n       5.6.1.  Example of Sorting . . . . . . . . . . . . . . . . . . 26\n
    \    5.7.  Boolean Operators: DAV:and, DAV:or, and DAV:not  . . . . . 26\n     5.8.
    \ DAV:eq . . . . . . . . . . . . . . . . . . . . . . . . . . 27\n     5.9.  DAV:lt,
    DAV:lte, DAV:gt, DAV:gte . . . . . . . . . . . . . 27\n     5.10. DAV:literal
    \ . . . . . . . . . . . . . . . . . . . . . . . 27\n     5.11. DAV:typed-literal
    (Optional) . . . . . . . . . . . . . . . 28\n       5.11.1. Example for Typed
    Numerical Comparison . . . . . . . . 28\n     5.12. Support for Matching xml:lang
    Attributes on Properties . . 29\n       5.12.1. DAV:language-defined (Optional)
    \ . . . . . . . . . . . 29\n       5.12.2. DAV:language-matches (Optional)  .
    . . . . . . . . . . 29\n       5.12.3. Example of Language-Aware Matching . .
    . . . . . . . . 29\n     5.13. DAV:is-collection  . . . . . . . . . . . . . .
    . . . . . . 30\n       5.13.1. Example of DAV:is-collection . . . . . . . . .
    . . . . 30\n     5.14. DAV:is-defined . . . . . . . . . . . . . . . . . . . .
    . . 30\n     5.15. DAV:like . . . . . . . . . . . . . . . . . . . . . . . . .
    30\n       5.15.1. Syntax for the Literal Pattern . . . . . . . . . . . . 31\n
    \      5.15.2. Example of DAV:like  . . . . . . . . . . . . . . . . . 31\n     5.16.
    DAV:contains . . . . . . . . . . . . . . . . . . . . . . . 31\n       5.16.1.
    Result Scoring (DAV:score Element) . . . . . . . . . . 32\n       5.16.2. Ordering
    by Score  . . . . . . . . . . . . . . . . . . 33\n       5.16.3. Examples . .
    . . . . . . . . . . . . . . . . . . . . . 33\n     5.17. Limiting the Result Set
    \ . . . . . . . . . . . . . . . . . 33\n       5.17.1. Relationship to Result
    Ordering  . . . . . . . . . . . 33\n     5.18. The 'caseless' XML Attribute .
    . . . . . . . . . . . . . . 34\n     5.19. Query Schema for DAV:basicsearch .
    . . . . . . . . . . . . 34\n       5.19.1. DTD for DAV:basicsearch QSD  . . .
    . . . . . . . . . . 34\n       5.19.2. DAV:propdesc Element . . . . . . . . .
    . . . . . . . . 35\n       5.19.3. The DAV:datatype Property Description  . .
    . . . . . . 35\n       5.19.4. The DAV:searchable Property Description  . . .
    . . . . 36\n       5.19.5. The DAV:selectable Property Description  . . . . .
    . . 36\n       5.19.6. The DAV:sortable Property Description  . . . . . . . .
    36\n       5.19.7. The DAV:caseless Property Description  . . . . . . . . 36\n
    \      5.19.8. The DAV:operators XML Element  . . . . . . . . . . . . 37\n       5.19.9.
    Example of Query Schema for DAV:basicsearch  . . . . . 38\n   6.  Internationalization
    Considerations  . . . . . . . . . . . . . 39\n   7.  Security Considerations  .
    . . . . . . . . . . . . . . . . . . 39\n     7.1.  Implications of XML External
    Entities  . . . . . . . . . . 39\n   8.  Scalability  . . . . . . . . . . . .
    . . . . . . . . . . . . . 40\n   9.  IANA Considerations  . . . . . . . . . .
    . . . . . . . . . . . 40\n     9.1.  HTTP Headers . . . . . . . . . . . . . .
    . . . . . . . . . 40\n       9.1.1.  DASL . . . . . . . . . . . . . . . . . .
    . . . . . . . 40\n   10. Contributors . . . . . . . . . . . . . . . . . . . .
    . . . . . 41\n   11. Acknowledgements . . . . . . . . . . . . . . . . . . . .
    . . . 41\n   12. References . . . . . . . . . . . . . . . . . . . . . . . . .
    . 41\n     12.1. Normative References . . . . . . . . . . . . . . . . . . . 41\n
    \    12.2. Informative References . . . . . . . . . . . . . . . . . . 42\n   Appendix
    A.  Three-Valued Logic in DAV:basicsearch . . . . . . . . 44\n   Appendix B.  Candidates
    for Future Protocol Extensions . . . . . . 45\n     B.1.  Collation Support  .
    . . . . . . . . . . . . . . . . . . . 45\n     B.2.  Count  . . . . . . . . .
    . . . . . . . . . . . . . . . . . 46\n     B.3.  Diagnostics for Unsupported Queries
    \ . . . . . . . . . . . 46\n     B.4.  Language Matching  . . . . . . . . . .
    . . . . . . . . . . 46\n     B.5.  Matching Media Types . . . . . . . . . . .
    . . . . . . . . 46\n     B.6.  Query by Name  . . . . . . . . . . . . . . . .
    . . . . . . 46\n     B.7.  Result Paging  . . . . . . . . . . . . . . . . . .
    . . . . 46\n     B.8.  Search Scope Discovery . . . . . . . . . . . . . . . .
    . . 47\n   Index  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    47\n"
  title: Table of Contents
- contents:
  - '1.  Introduction

    '
  - contents:
    - "1.1.  DASL\n   This document defines Web Distributed Authoring and Versioning\n
      \  (WebDAV) SEARCH, an application of HTTP/1.1 forming a lightweight\n   search
      protocol to transport queries and result sets that allows\n   clients to make
      use of server-side search facilities.  It is based on\n   earlier work done
      in the IETF DASL Working Group (see Section 10).\n   In this specification,
      the terms \"WebDAV SEARCH\" and \"DASL\" are used\n   interchangeably.\n   DASL
      minimizes the complexity of clients so as to facilitate\n   widespread deployment
      of applications capable of utilizing the DASL\n   search mechanisms.\n   DASL
      consists of:\n   o  the SEARCH method and the request/response formats defined
      for it\n      (Section 2),\n   o  feature discovery through the \"DASL\" response
      header and the\n      optional DAV:supported-grammar-set property (Section 3),\n
      \  o  optional grammar schema discovery (Section 4), and\n   o  one mandatory
      grammar: DAV:basicsearch (Section 5).\n"
    title: 1.1.  DASL
  - contents:
    - "1.2.  Relationship to DAV\n   DASL relies on the resource and property model
      defined by [RFC4918].\n   DASL does not alter this model.  Instead, DASL allows
      clients to\n   access DAV-modeled resources through server-side search.\n"
    title: 1.2.  Relationship to DAV
  - contents:
    - "1.3.  Terms\n   This document uses the terms defined in [RFC2616], [RFC4918],\n
      \  [RFC3253], and in this section.\n   Criteria\n      An expression against
      which each resource in the search scope is\n      evaluated.\n   Query\n      A
      query is a combination of a search scope, search criteria,\n      result record
      definition, sort specification, and a search\n      modifier.\n   Query Grammar\n
      \     A set of definitions of XML elements, attributes, and constraints\n      on
      their relations and values that defines a set of queries and\n      the intended
      semantics.\n   Query Schema\n      A listing, for any given grammar and scope,
      of the properties and\n      operators that may be used in a query with that
      grammar and scope.\n   Result\n      A result is a result set, optionally augmented
      with other\n      information describing the search as a whole.\n   Result Record\n
      \     A description of a resource.  A result record is a set of\n      properties,
      and possibly other descriptive information.\n   Result Record Definition\n      A
      specification of the set of properties to be returned in the\n      result record.\n
      \  Result Set\n      A set of records, one for each resource for which the search\n
      \     criteria evaluated to True.\n   Scope\n      A set of resources to be
      searched.\n   Search Arbiter\n      A resource that supports the SEARCH method.\n
      \  Search Modifier\n      An instruction that governs the execution of the query
      but is not\n      part of the search scope, result record definition, the search\n
      \     criteria, or the sort specification.  An example of a search\n      modifier
      is one that controls how much time the server can spend\n      on the query
      before giving a response.\n   Sort Specification\n      A specification of an
      ordering on the result records in the result\n      set.\n"
    title: 1.3.  Terms
  - contents:
    - "1.4.  Notational Conventions\n   This specification uses the Augmented Backus-Naur
      Form (ABNF)\n   notation of [RFC5234], unless explicitly stated otherwise.\n
      \  The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n
      \  \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in
      this\n   document are to be interpreted as described in [RFC2119].\n   This
      document uses XML DTD fragments ([XML], Section 3.2) as a purely\n   notational
      convention.  WebDAV request and response bodies cannot be\n   validated by a
      DTD due to the specific extensibility rules defined in\n   Section 17 of [RFC4918]
      and due to the fact that all XML elements\n   defined by this specification
      use the XML namespace name \"DAV:\".  In\n   particular:\n   1.  element names
      use the \"DAV:\" namespace,\n   2.  element ordering is irrelevant unless explicitly
      stated,\n   3.  extension elements (elements not already defined as valid child\n
      \      elements) may be added anywhere, except when explicitly stated\n       otherwise,\n
      \  4.  extension attributes (attributes not already defined as valid for\n       this
      element) may be added anywhere, except when explicitly\n       stated otherwise.\n
      \  When an XML element type in the \"DAV:\" namespace is referenced in\n   this
      document outside of the context of an XML fragment, the string\n   \"DAV:\"
      will be prefixed to the element type.\n   Similarly, when an XML element type
      in the namespace\n   \"http://www.w3.org/2001/XMLSchema\" is referenced in this
      document\n   outside of the context of an XML fragment, the string \"xs:\" will
      be\n   prefixed to the element type.\n   This document inherits, and sometimes
      extends, DTD productions from\n   Section 14 of [RFC4918].\n"
    title: 1.4.  Notational Conventions
  - contents:
    - "1.5.  Note on Usage of 'DAV:' XML Namespace\n   This specification defines
      elements, properties, and condition names\n   in the XML namespace \"DAV:\".
      \ In general, only specifications\n   authored by IETF working groups are supposed
      to do this.  In this\n   case an exception was made, because WebDAV SEARCH started
      its life in\n   the IETF DASL working group (<http://www.webdav.org/dasl/>,
      and at\n   the time the working group closed down there was already significant\n
      \  deployment of this specification.\n"
    title: 1.5.  Note on Usage of 'DAV:' XML Namespace
  - contents:
    - "1.6.  An Overview of DASL at Work\n   One can express the basic usage of DASL
      in the following steps:\n   o  The client constructs a query using the DAV:basicsearch
      grammar.\n   o  The client invokes the SEARCH method on a resource that will\n
      \     perform the search (the search arbiter) and includes a text/xml or\n      application/xml
      request entity that contains the query.\n   o  The search arbiter performs the
      query.\n   o  The search arbiter sends the results of the query back to the\n
      \     client in the response.  The server MUST send an entity that\n      matches
      the WebDAV multistatus format ([RFC4918], Section 13).\n"
    title: 1.6.  An Overview of DASL at Work
  title: 1.  Introduction
- contents:
  - '2.  The SEARCH Method

    '
  - contents:
    - "2.1.  Overview\n   The client invokes the SEARCH method to initiate a server-side\n
      \  search.  The body of the request defines the query.  The server MUST\n   emit
      an entity matching the WebDAV multistatus format ([RFC4918],\n   Section 13).\n
      \  The SEARCH method plays the role of transport mechanism for the query\n   and
      the result set.  It does not define the semantics of the query.\n   The type
      of the query defines the semantics.\n   SEARCH is a safe method; it does not
      have any significance other than\n   executing a query and returning a query
      result (see [RFC2616],\n   Section 9.1.1).\n"
    title: 2.1.  Overview
  - contents:
    - "2.2.  The Request\n   The client invokes the SEARCH method on the resource
      named by the\n   Request-URI.\n"
    - contents:
      - "2.2.1.  The Request-URI\n   The Request-URI identifies the search arbiter.
        \ Any HTTP resource may\n   function as search arbiter.  It is not a new type
        of resource (in the\n   sense of DAV:resourcetype as defined in [RFC4918],
        Section 15.9), nor\n   does it have to be a WebDAV-compliant resource.\n   The
        SEARCH method defines no relationship between the arbiter and the\n   scope
        of the search; rather, the particular query grammar used in the\n   query
        defines the relationship.  For example, a query grammar may\n   force the
        Request-URI to correspond exactly to the search scope.\n"
      title: 2.2.1.  The Request-URI
    - contents:
      - "2.2.2.  The Request Body\n   The server MUST process a text/xml or application/xml
        request body,\n   and MAY process request bodies in other formats.  See [RFC3023]
        for\n   guidance on packaging XML in requests.\n   Marshalling:\n      If
        a request body with content type text/xml or application/xml is\n      included,
        it MUST be either a DAV:searchrequest or a DAV:query-\n      schema-discovery
        XML element.  Its single child element identifies\n      the query grammar.\n
        \     For DAV:searchrequest, the definition of search criteria, the\n      result
        record, and any other details needed to perform the search\n      depend on
        the individual search grammar.\n      For DAV:query-schema-discovery, the
        semantics is defined in\n      Section 4.\n   Preconditions:\n      (DAV:search-grammar-discovery-supported):
        when an XML request body\n      is present and has a DAV:query-schema-discovery
        document element,\n      the server MUST support the query schema discovery
        mechanism\n      described in Section 4.\n      (DAV:search-grammar-supported):
        when an XML request body is\n      present, the search grammar identified
        by the document element's\n      child element must be a supported search
        grammar.\n      (DAV:search-multiple-scope-supported): if the SEARCH request\n
        \     specified multiple scopes, the server MUST support this optional\n      feature.\n
        \     (DAV:search-scope-valid): the supplied search scope must be valid.\n
        \     There can be various reasons for a search scope to be invalid,\n      including
        unsupported URI schemes and communication problems.\n      Servers MAY add
        [RFC4918] compliant DAV:response elements as\n      content to the condition
        element indicating the precise reason for\n      the failure.\n"
      title: 2.2.2.  The Request Body
    title: 2.2.  The Request
  - contents:
    - "2.3.  The Successful 207 (Multistatus) Response\n   If the server returns 207
      (Multistatus), then the search proceeded\n   successfully, and the response
      MUST use the WebDAV multistatus format\n   ([RFC4918], Section 13).  The results
      of this method SHOULD NOT be\n   cached.\n   There MUST be one DAV:response
      for each resource that matched the\n   search criteria.  For each such response,
      the DAV:href element\n   contains the URI of the resource, and the response
      MUST include a\n   DAV:propstat element.\n      Note: the WebDAV multistatus
      format requires at least one DAV:\n      response child element.  This specification
      relaxes that\n      restriction so that empty results can be represented.\n
      \  Note that for each matching resource found, there may be multiple\n   URIs
      within the search scope mapped to it.  In this case, a server\n   SHOULD report
      only one of these URIs.  Clients can use the live\n   property DAV:resource-id,
      defined in Section 3.1 of [WEBDAV-BIND] to\n   identify possible duplicates.\n"
    - contents:
      - "2.3.1.  Result Set Truncation\n   A server MAY limit the number of resources
        in a reply, for example,\n   to limit the amount of resources expended in
        processing a query.  If\n   it does so, the reply MUST use status code 207,
        return a DAV:\n   multistatus response body, and indicate a status of 507
        (Insufficient\n   Storage) for the search arbiter URI.  It SHOULD include
        the partial\n   results.\n   When a result set is truncated, there may be
        many more resources that\n   satisfy the search criteria but that were not
        examined.\n   If partial results are included and the client requested an
        ordered\n   result set in the original request, then any partial results that
        are\n   returned MUST be ordered as the client directed.\n   Note that the
        partial results returned MAY be any subset of the\n   result set that would
        have satisfied the original query.\n"
      title: 2.3.1.  Result Set Truncation
    - contents:
      - "2.3.2.  Extending the PROPFIND Response\n   A response MAY include more information
        than PROPFIND defines, so\n   long as the extra information does not invalidate
        the PROPFIND\n   response.  Query grammars SHOULD define how the response
        matches the\n   PROPFIND response.\n"
      title: 2.3.2.  Extending the PROPFIND Response
    - contents:
      - "2.3.3.  Example: A Simple Request and Response\n   This example demonstrates
        the request and response framework.  The\n   following XML document shows
        a simple (hypothetical) natural language\n   query.  The name of the query
        element is natural-language-query in\n   the XML namespace \"http://example.com/foo\".
        \ The actual query is\n   \"Find the locations of good Thai restaurants in
        Los Angeles\".  For\n   this hypothetical query, the arbiter returns two properties
        for each\n   selected resource.\n   >> Request:\n   SEARCH / HTTP/1.1\n   Host:
        example.org\n   Content-Type: application/xml; charset=\"utf-8\"\n   Content-Length:
        252\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <D:searchrequest xmlns:D=\"DAV:\"
        xmlns:F=\"http://example.com/foo\">\n     <F:natural-language-query>\n       Find
        the locations of good Thai restaurants in Los Angeles\n     </F:natural-language-query>\n
        \  </D:searchrequest>\n   >> Response:\n   HTTP/1.1 207 Multi-Status\n   Content-Type:
        text/xml; charset=\"utf-8\"\n   Content-Length: 429\n   <?xml version=\"1.0\"
        encoding=\"UTF-8\"?>\n   <D:multistatus xmlns:D=\"DAV:\"\n      xmlns:R=\"http://example.org/propschema\">\n
        \    <D:response>\n       <D:href>http://siamiam.example/</D:href>\n       <D:propstat>\n
        \        <D:prop>\n           <R:location>259 W. Hollywood</R:location>\n
        \          <R:rating><R:stars>4</R:stars></R:rating>\n         </D:prop>\n
        \        <D:status>HTTP/1.1 200 OK</D:status>\n       </D:propstat>\n     </D:response>\n
        \  </D:multistatus>\n"
      title: '2.3.3.  Example: A Simple Request and Response'
    - contents:
      - "2.3.4.  Example: Result Set Truncation\n   In the example below, the server
        returns just two results, and then\n   indicates that the result is truncated
        by adding a DAV:response\n   element for the search arbiter resource with
        507 (Insufficient\n   Storage) status.\n   >> Request:\n   SEARCH / HTTP/1.1\n
        \  Host: example.net\n   Content-Type: text/xml; charset=\"utf-8\"\n   Content-Length:
        xxx\n    ... the query goes here ...\n   >> Response:\n   HTTP/1.1 207 Multistatus\n
        \  Content-Type: text/xml; charset=\"utf-8\"\n   Content-Length: 640\n   <?xml
        version=\"1.0\" encoding=\"utf-8\"?>\n   <D:multistatus xmlns:D=\"DAV:\">\n
        \    <D:response>\n       <D:href>http://www.example.net/sounds/unbrokenchain.au</D:href>\n
        \      <D:status>HTTP/1.1 200 OK</D:status>\n     </D:response>\n     <D:response>\n
        \      <D:href>http://tech.mit.example/arch96/photos/Lesh1.jpg</D:href>\n
        \      <D:status>HTTP/1.1 200 OK</D:status>\n     </D:response>\n     <D:response>\n
        \      <D:href>http://example.net</D:href>\n       <D:status>HTTP/1.1 507
        Insufficient Storage</D:status>\n       <D:responsedescription xml:lang=\"en\">\n
        \         Only first two matching records were returned\n       </D:responsedescription>\n
        \    </D:response>\n   </D:multistatus>\n"
      title: '2.3.4.  Example: Result Set Truncation'
    title: 2.3.  The Successful 207 (Multistatus) Response
  - contents:
    - "2.4.  Unsuccessful Responses\n   If a SEARCH request could not be executed
      or the attempt to execute\n   it resulted in an error, the server MUST indicate
      the failure with an\n   appropriate status code and SHOULD add a response body
      as defined in\n   Section 1.6 of [RFC3253].  Unless otherwise stated, condition\n
      \  elements are empty; however, specific condition elements MAY include\n   additional
      child elements that describe the error condition in more\n   detail.\n"
    - contents:
      - "2.4.1.  Example of an Invalid Scope\n   In the example below, a request failed
        because the scope identifies a\n   HTTP resource that was not found.\n   >>
        Response:\n   HTTP/1.1 409 Conflict\n   Content-Type: text/xml; charset=\"utf-8\"\n
        \  Content-Length: 275\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <d:error
        xmlns:d=\"DAV:\">\n     <d:search-scope-valid>\n       <d:response>\n         <d:href>http://www.example.com/X</d:href>\n
        \        <d:status>HTTP/1.1 404 Object Not Found</d:status>\n       </d:response>\n
        \    </d:search-scope-valid>\n   </d:error>\n"
      title: 2.4.1.  Example of an Invalid Scope
    title: 2.4.  Unsuccessful Responses
  title: 2.  The SEARCH Method
- contents:
  - "3.  Discovery of Supported Query Grammars\n   Servers MUST support discovery
    of the query grammars supported by a\n   search arbiter resource.\n   Clients
    can determine which query grammars are supported by an\n   arbiter by invoking
    OPTIONS on the search arbiter.  If the resource\n   supports SEARCH, then the
    DASL response header will appear in the\n   response.  The DASL response header
    lists the supported grammars.\n   Servers supporting the WebDAV extensions [RFC3253]
    and/or [RFC3744]\n   MUST also:\n   o  report SEARCH in the live property DAV:supported-method-set
    for\n      all search arbiter resources, and\n   o  support the live property
    DAV:supported-query-grammar-set as\n      defined in Section 3.3.\n"
  - contents:
    - "3.1.  The OPTIONS Method\n   The OPTIONS method allows the client to discover
      if a resource\n   supports the SEARCH method and to determine the list of search\n
      \  grammars supported for that resource.\n   The client issues the OPTIONS method
      against a resource named by the\n   Request-URI.  This is a normal invocation
      of OPTIONS as defined in\n   Section 9.2 of [RFC2616].\n   If a resource supports
      the SEARCH method, then the server MUST list\n   SEARCH in the Allow header
      defined in Section 14.7 of [RFC2616].\n   DASL servers MUST include the DASL
      header in the OPTIONS response.\n   This header identifies the search grammars
      supported by that\n   resource.\n"
    title: 3.1.  The OPTIONS Method
  - contents:
    - "3.2.  The DASL Response Header\n   DASLHeader = \"DASL\" \":\" 1#Coded-URL\n
      \  Coded-URL  = <defined in Section 10.1 of [RFC4918]>\n   (This grammar uses
      the augmented BNF format defined in Section 2.1 of\n   [RFC2616].)\n   The DASL
      response header indicates server support for query grammars\n   in the OPTIONS
      method.  The value is a list of URIs that indicate the\n   types of supported
      grammars.  Note that although the URIs can be used\n   to identify each supported
      search grammar, there is not necessarily a\n   direct relationship between the
      URI and the XML element name that can\n   be used in XML based SEARCH requests
      (the element name itself is\n   identified by its namespace name (a URI reference)
      and the element's\n   local name).\n      Note: this header field value is defined
      as a comma-separated list\n      ([RFC2616], Section 4.2); thus, grammar URIs
      can appear in\n      multiple header instances, separated by commas, or both.\n
      \  For example:\n   DASL: <http://foobar.example/syntax1>,\n         <http://akuma.example/syntax2>,
      <DAV:basicsearch>\n   DASL: <http://example.com/foo/natural-language-query>\n"
    title: 3.2.  The DASL Response Header
  - contents:
    - "3.3.  DAV:supported-query-grammar-set (Protected)\n   This WebDAV property
      is required for any server supporting either\n   [RFC3253] and/or [RFC3744]
      and identifies the XML-based query\n   grammars that are supported by the search
      arbiter resource.\n   <!ELEMENT supported-query-grammar-set (supported-query-grammar*)>\n
      \  <!ELEMENT supported-query-grammar (grammar)>\n   <!ELEMENT grammar ANY>\n
      \  <!-- ANY value: a query grammar element type -->\n"
    title: 3.3.  DAV:supported-query-grammar-set (Protected)
  - contents:
    - "3.4.  Example: Grammar Discovery\n   This example shows that the server supports
      search on the /somefolder\n   resource with the query grammars: DAV:basicsearch,\n
      \  http://foobar.example/syntax1 and http://akuma.example/syntax2.  Note\n   that
      servers supporting WebDAV SEARCH MUST support DAV:basicsearch.\n   >> Request:\n
      \  OPTIONS /somefolder HTTP/1.1\n   Host: example.org\n   >> Response:\n   HTTP/1.1
      200 OK\n   Allow: OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, COPY, MOVE\n
      \  Allow: MKCOL, PROPFIND, PROPPATCH, LOCK, UNLOCK, SEARCH\n   DASL: <DAV:basicsearch>\n
      \  DASL: <http://foobar.example/syntax1>, <http://akuma.example/syntax2>\n   This
      example shows the equivalent taking advantage of a server's\n   support for
      DAV:supported-method-set and DAV:supported-query-grammar-\n   set.\n   >> Request:\n
      \  PROPFIND /somefolder HTTP/1.1\n   Host: example.org\n   Depth: 0\n   Content-Type:
      text/xml; charset=\"utf-8\"\n   Content-Length: 165\n   <?xml version=\"1.0\"
      encoding=\"UTF-8\" ?>\n   <propfind xmlns=\"DAV:\">\n     <prop>\n       <supported-query-grammar-set/>\n
      \      <supported-method-set/>\n     </prop>\n   </propfind>\n   >> Response:\n
      \  HTTP/1.1 207 Multi-Status\n   Content-Type: text/xml; charset=\"utf-8\"\n
      \  Content-Length: 1349\n   <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n   <multistatus
      xmlns=\"DAV:\">\n    <response>\n     <href>http://example.org/somefolder</href>\n
      \    <propstat>\n      <prop>\n       <supported-query-grammar-set>\n        <supported-query-grammar>\n
      \        <grammar><basicsearch/></grammar>\n        </supported-query-grammar>\n
      \       <supported-query-grammar>\n         <grammar><syntax1 xmlns=\"http://foobar.example/\"/></grammar>\n
      \       </supported-query-grammar>\n        <supported-query-grammar>\n         <grammar><syntax2
      xmlns=\"http://akuma.example/\"/></grammar>\n        </supported-query-grammar>\n
      \      </supported-query-grammar-set>\n       <supported-method-set>\n        <supported-method
      name=\"COPY\" />\n        <supported-method name=\"DELETE\" />\n        <supported-method
      name=\"GET\" />\n        <supported-method name=\"HEAD\" />\n        <supported-method
      name=\"LOCK\" />\n        <supported-method name=\"MKCOL\" />\n        <supported-method
      name=\"MOVE\" />\n        <supported-method name=\"OPTIONS\" />\n        <supported-method
      name=\"POST\" />\n        <supported-method name=\"PROPFIND\" />\n        <supported-method
      name=\"PROPPATCH\" />\n        <supported-method name=\"PUT\" />\n        <supported-method
      name=\"SEARCH\" />\n        <supported-method name=\"TRACE\" />\n        <supported-method
      name=\"UNLOCK\" />\n       </supported-method-set>\n      </prop>\n      <status>HTTP/1.1
      200 OK</status>\n     </propstat>\n    </response>\n   </multistatus>\n   Note
      that the query grammar element names marshalled as part of the\n   DAV:supported-query-grammar-set
      can be directly used as element names\n   in an XML-based query.\n"
    title: '3.4.  Example: Grammar Discovery'
  title: 3.  Discovery of Supported Query Grammars
- contents:
  - "4.  Query Schema Discovery: QSD\n   Servers MAY support the discovery of the
    schema for a query grammar.\n   The DASL response header and the DAV:supported-query-grammar-set\n
    \  property provide means for clients to discover the set of query\n   grammars
    supported by a resource.  This alone is not sufficient\n   information for a client
    to generate a query.  For example, the DAV:\n   basicsearch grammar defines a
    set of queries consisting of a set of\n   operators applied to a set of properties
    and values, but the grammar\n   itself does not specify which properties may be
    used in the query.\n   QSD for the DAV:basicsearch grammar allows a client to
    discover the\n   set of properties that are searchable, selectable, and sortable.\n
    \  Moreover, although the DAV:basicsearch grammar defines a minimal set\n   of
    operators, it is possible that a resource might support additional\n   operators
    in a query.  For example, a resource might support an\n   optional operator that
    can be used to express content-based queries\n   in a proprietary syntax.  QSD
    allows a client to discover these\n   operators and their syntax.  The set of
    discoverable quantities will\n   differ from grammar to grammar, but each grammar
    can define a means\n   for a client to discover what can be discovered.\n   In
    general, the schema for a given query grammar depends on both the\n   resource
    (the arbiter) and the scope.  A given resource might have\n   access to one set
    of properties for one potential scope, and another\n   set for a different scope.
    \ For example, consider a server able to\n   search two distinct collections:
    one holding cooking recipes, the\n   other design documents for nuclear weapons.
    \ While both collections\n   might support properties such as author, title, and
    date, the first\n   might also define properties such as calories and preparation
    time,\n   while the second defined properties such as yield and applicable\n   patents.
    \ Two distinct arbiters indexing the same collection might\n   also have access
    to different properties.  For example, the recipe\n   collection mentioned above
    might also be indexed by a value-added\n   server that also stored the names of
    chefs who had tested the recipe.\n   Note also that the available query schema
    might also depend on other\n   factors, such as the identity of the principal
    conducting the search,\n   but these factors are not exposed in this protocol.\n"
  - contents:
    - "4.1.  Additional SEARCH Semantics\n   Each query grammar supported by DASL
      defines its own syntax for\n   expressing the possible query schema.  A client
      retrieves the schema\n   for a given query grammar on an arbiter resource with
      a given scope\n   by invoking the SEARCH method on that arbiter with that grammar
      and\n   scope and with a root element of DAV:query-schema-discovery rather\n
      \  than DAV:searchrequest.\n   Marshalling:\n      The request body MUST be
      a DAV:query-schema-discovery element.\n      <!ELEMENT query-schema-discovery
      ANY>\n      <!-- ANY value: XML element specifying the query grammar\n                      and
      the scope -->\n      The response body takes the form of a DAV:multistatus element\n
      \     ([RFC4918], Section 13), where DAV:response is extended to hold\n      the
      returned query grammar inside a DAV:query-schema container\n      element.\n
      \     <!ELEMENT response (href, status, query-schema?,\n        responsedescription?)
      >\n      <!ELEMENT query-schema ANY>\n   The content of this container is an
      XML element whose name and syntax\n   depend upon the grammar, and whose value
      may (and likely will) vary\n   depending upon the grammar, arbiter, and scope.\n"
    - contents:
      - "4.1.1.  Example of Query Schema Discovery\n   In this example, the arbiter
        is recipes.example, the grammar is DAV:\n   basicsearch, the scope is also
        recipes.example.\n   >> Request:\n   SEARCH / HTTP/1.1\n   Host: recipes.example\n
        \  Content-Type: application/xml; charset=\"utf-8\"\n   Content-Length: 258\n
        \  <?xml version=\"1.0\"?>\n   <query-schema-discovery xmlns=\"DAV:\">\n     <basicsearch>\n
        \      <from>\n         <scope>\n           <href>http://recipes.example</href>\n
        \          <depth>infinity</depth>\n         </scope>\n       </from>\n     </basicsearch>\n
        \  </query-schema-discovery>\n   >> Response:\n   HTTP/1.1 207 Multistatus\n
        \  Content-Type: application/xml; charset=\"utf-8\"\n   Content-Length: xxx\n
        \  <?xml version=\"1.0\"?>\n   <multistatus xmlns=\"DAV:\">\n     <response>\n
        \      <href>http://recipes.example</href>\n       <status>HTTP/1.1 200 OK</status>\n
        \      <query-schema>\n         <basicsearchschema>\n           <!-- (See
        Section 5.19 for\n           the actual contents) -->\n         </basicsearchschema>\n
        \      </query-schema>\n     </response>\n   </multistatus>\n   The query
        schema for DAV:basicsearch is defined in Section 5.19.\n"
      title: 4.1.1.  Example of Query Schema Discovery
    title: 4.1.  Additional SEARCH Semantics
  title: '4.  Query Schema Discovery: QSD'
- contents:
  - '5.  The DAV:basicsearch Grammar

    '
  - contents:
    - "5.1.  Introduction\n   DAV:basicsearch uses an extensible XML syntax that allows
      clients to\n   express search requests that are generally useful for WebDAV\n
      \  scenarios.  DASL-extended servers MUST accept this grammar, and MAY\n   accept
      other grammars.\n   DAV:basicsearch has several components:\n   o  DAV:select
      provides the result record definition.\n   o  DAV:from defines the scope.\n
      \  o  DAV:where defines the criteria.\n   o  DAV:orderby defines the sort order
      of the result set.\n   o  DAV:limit provides constraints on the query as a whole.\n"
    title: 5.1.  Introduction
  - contents:
    - "5.2.  The DAV:basicsearch DTD\n   <!-- \"basicsearch\" element -->\n   <!ELEMENT
      basicsearch   (select, from, where?, orderby?, limit?) >\n   <!-- \"select\"
      element -->\n   <!ELEMENT select        (allprop | prop) >\n   <!-- \"from\"
      element -->\n   <!ELEMENT from          (scope+) >\n   <!ELEMENT scope         (href,
      depth, include-versions?) >\n   <!ELEMENT include-versions EMPTY >\n   <!--
      \"where\" element -->\n   <!ENTITY % comp_ops     \"eq | lt | gt| lte | gte\">\n
      \  <!ENTITY % log_ops      \"and | or | not\">\n   <!ENTITY % special_ops  \"is-collection
      | is-defined |\n                            language-defined | language-matches\">\n
      \  <!ENTITY % string_ops   \"like\">\n   <!ENTITY % content_ops  \"contains\">\n
      \  <!ENTITY % all_ops      \"%comp_ops; | %log_ops; | %special_ops; |\n                            %string_ops;
      | %content_ops;\">\n   <!ELEMENT where         ( %all_ops; ) >\n   <!ELEMENT
      and           ( %all_ops; )+ >\n   <!ELEMENT or            ( %all_ops; )+ >\n
      \  <!ELEMENT not           ( %all_ops; ) >\n   <!ELEMENT lt            (prop,
      (literal|typed-literal)) >\n   <!ATTLIST lt            caseless   (yes|no) #IMPLIED>\n
      \  <!ELEMENT lte           (prop, (literal|typed-literal)) >\n   <!ATTLIST lte
      \          caseless   (yes|no) #IMPLIED>\n   <!ELEMENT gt            (prop,
      (literal|typed-literal)) >\n   <!ATTLIST gt            caseless   (yes|no) #IMPLIED>\n
      \  <!ELEMENT gte           (prop, (literal|typed-literal)) >\n   <!ATTLIST gte
      \          caseless   (yes|no) #IMPLIED>\n   <!ELEMENT eq            (prop,
      (literal|typed-literal)) >\n   <!ATTLIST eq            caseless   (yes|no) #IMPLIED>\n
      \  <!ELEMENT literal       (#PCDATA)>\n   <!ELEMENT typed-literal (#PCDATA)>\n
      \  <!ATTLIST typed-literal xsi:type CDATA #IMPLIED>\n   <!ELEMENT is-collection
      EMPTY >\n   <!ELEMENT is-defined    (prop) >\n   <!ELEMENT language-defined
      \   (prop) >\n   <!ELEMENT language-matches    (prop, literal) >\n   <!ELEMENT
      like          (prop, literal) >\n   <!ATTLIST like          caseless   (yes|no)
      #IMPLIED>\n   <!ELEMENT contains      (#PCDATA)>\n   <!-- \"orderby\" element
      -->\n   <!ELEMENT orderby       (order+) >\n   <!ELEMENT order         ((prop
      | score), (ascending | descending)?)>\n   <!ATTLIST order         caseless   (yes|no)
      #IMPLIED>\n   <!ELEMENT ascending     EMPTY>\n   <!ELEMENT descending    EMPTY>\n
      \  <!-- \"limit\" element -->\n   <!ELEMENT limit         (nresults) >\n   <!ELEMENT
      nresults      (#PCDATA) >\n"
    - contents:
      - "5.2.1.  Example Query\n   This query retrieves the content length values
        for all resources\n   located under the server's \"/container1/\" URI namespace
        whose length\n   exceeds 10000 sorted ascending by size.\n   <d:searchrequest
        xmlns:d=\"DAV:\">\n     <d:basicsearch>\n       <d:select>\n         <d:prop><d:getcontentlength/></d:prop>\n
        \      </d:select>\n       <d:from>\n         <d:scope>\n           <d:href>/container1/</d:href>\n
        \          <d:depth>infinity</d:depth>\n         </d:scope>\n       </d:from>\n
        \      <d:where>\n         <d:gt>\n           <d:prop><d:getcontentlength/></d:prop>\n
        \          <d:literal>10000</d:literal>\n         </d:gt>\n       </d:where>\n
        \      <d:orderby>\n         <d:order>\n           <d:prop><d:getcontentlength/></d:prop>\n
        \          <d:ascending/>\n         </d:order>\n       </d:orderby>\n     </d:basicsearch>\n
        \  </d:searchrequest>\n"
      title: 5.2.1.  Example Query
    title: 5.2.  The DAV:basicsearch DTD
  - contents:
    - "5.3.  DAV:select\n   DAV:select defines the result record, which is a set of
      properties\n   and values.  This document defines two possible values: DAV:allprop\n
      \  and DAV:prop, both defined in Section 14 of [RFC4918].\n"
    title: 5.3.  DAV:select
  - contents:
    - "5.4.  DAV:from\n   <!ELEMENT scope            (href, depth, include-versions?)
      >\n   <!ELEMENT include-versions EMPTY >\n   DAV:from defines the query scope.
      \ This contains one or more DAV:\n   scope elements.  Support for multiple scope
      elements is optional,\n   however servers MUST fail a request specifying multiple
      DAV:scope\n   elements if they can't support it (see Section 2.2.2, precondition\n
      \  DAV:search-multiple-scope-supported).  The scope element contains\n   mandatory
      DAV:href and DAV:depth elements.\n   DAV:href indicates the URI reference ([RFC3986],
      Section 4.1) to use\n   as a scope.\n   When the scope is a collection, if DAV:depth
      is \"0\", the search\n   includes only the collection.  When it is \"1\", the
      search includes\n   the collection and its immediate children.  When it is \"infinity\",
      it\n   includes the collection and all its progeny.\n   When the scope is not
      a collection, the depth is ignored and the\n   search applies just to the resource
      itself.\n   If the server supports WebDAV Redirect Reference Resources\n   ([RFC4437])
      and the search scope contains a redirect reference\n   resource, then it applies
      only to that resource, not to its target.\n   When the child element DAV:include-versions
      is present, the search\n   scope will include all versions (see [RFC3253], Section
      2.2.1) of all\n   version-controlled resources in scope.  Servers that do support\n
      \  versioning but do not support the DAV:include-versions feature MUST\n   signal
      an error if it is used in a query (see Section 2.2.2,\n   precondition DAV:search-scope-valid).\n"
    - contents:
      - "5.4.1.  Relationship to the Request-URI\n   If the DAV:scope element is a
        URI ([RFC3986], Section 3), the scope\n   is exactly that URI.\n   If the
        DAV:scope element is a relative reference ([RFC3986], Section\n   4.2), the
        scope is taken to be relative to the Request-URI.\n"
      title: 5.4.1.  Relationship to the Request-URI
    - contents:
      - "5.4.2.  Scope\n   A Scope can be an arbitrary URI reference.\n   Servers,
        of course, may support only particular scopes.  This may\n   include limitations
        for particular schemes such as \"http:\" or \"ftp:\"\n   or certain URI namespaces.
        \ However, WebDAV-compliant search arbiters\n   minimally SHOULD support scopes
        that match their own URI.\n"
      title: 5.4.2.  Scope
    title: 5.4.  DAV:from
  - contents:
    - "5.5.  DAV:where\n   The DAV:where element defines the search condition for
      inclusion of\n   resources in the result set.  The value of this element is
      an XML\n   element that defines a search operator that evaluates to one of the\n
      \  Boolean truth values TRUE, FALSE, or UNKNOWN.  The search operator\n   contained
      by DAV:where may itself contain and evaluate additional\n   search operators
      as operands, which in turn may contain and evaluate\n   additional search operators
      as operands, etc., recursively.\n"
    - contents:
      - "5.5.1.  Use of Three-Valued Logic in Queries\n   Each operator defined for
        use in the where clause that returns a\n   Boolean value MUST evaluate to
        TRUE, FALSE, or UNKNOWN.  The resource\n   under scan is included as a member
        of the result set if and only if\n   the search condition evaluates to TRUE.\n
        \  Consult Appendix A for details on the application of three-valued\n   logic
        in query expressions.\n"
      title: 5.5.1.  Use of Three-Valued Logic in Queries
    - contents:
      - "5.5.2.  Handling Optional Operators\n   If a query contains an operator that
        is not supported by the server,\n   then the server MUST respond with a 422
        (Unprocessable Entity) status\n   code.\n"
      title: 5.5.2.  Handling Optional Operators
    - contents:
      - "5.5.3.  Treatment of NULL Values\n   If a PROPFIND for a property value would
        yield a non-2xx (see Section\n   10.2 of [RFC2616]) response for that property,
        then that property is\n   considered NULL.\n   NULL values are \"less than\"
        all other values in comparisons.\n   Empty strings (zero length strings) are
        not NULL values.  An empty\n   string is \"less than\" a string with length
        greater than zero.\n   The DAV:is-defined operator is defined to test if the
        value of a\n   property is not NULL.\n"
      title: 5.5.3.  Treatment of NULL Values
    - contents:
      - "5.5.4.  Treatment of Properties with Mixed/Element Content\n   Comparisons
        of properties that do not have simple types (text-only\n   content) is out
        of scope for the standard operators defined for DAV:\n   basicsearch and therefore
        is defined to be UNKNOWN (as per\n   Appendix A).  For querying the DAV:resourcetype
        property, see\n   Section 5.13.\n"
      title: 5.5.4.  Treatment of Properties with Mixed/Element Content
    - contents:
      - "5.5.5.  Example: Testing for Equality\n   The example shows a single operator
        (DAV:eq) applied in the criteria.\n   <d:where xmlns:d='DAV:'>\n     <d:eq>\n
        \      <d:prop>\n         <d:getcontentlength/>\n       </d:prop>\n       <d:literal>100</d:literal>\n
        \    </d:eq>\n   </d:where>\n"
      title: '5.5.5.  Example: Testing for Equality'
    - contents:
      - "5.5.6.  Example: Relative Comparisons\n   The example shows a more complex
        operation involving several\n   operators (DAV:and, DAV:eq, DAV:gt) applied
        in the criteria.  This\n   DAV:where expression matches those resources of
        type \"image/gif\" over\n   4K in size.\n   <D:where xmlns:D='DAV:'>\n     <D:and>\n
        \      <D:eq>\n         <D:prop>\n           <D:getcontenttype/>\n         </D:prop>\n
        \        <D:literal>image/gif</D:literal>\n       </D:eq>\n       <D:gt>\n
        \        <D:prop>\n           <D:getcontentlength/>\n         </D:prop>\n
        \        <D:literal>4096</D:literal>\n       </D:gt>\n     </D:and>\n   </D:where>\n"
      title: '5.5.6.  Example: Relative Comparisons'
    title: 5.5.  DAV:where
  - contents:
    - "5.6.  DAV:orderby\n   The DAV:orderby element specifies the ordering of the
      result set.  It\n   contains one or more DAV:order elements, each of which specifies
      a\n   comparison between two items in the result set.  Informally, a\n   comparison
      specifies a test that determines whether one resource\n   appears before another
      in the result set.  Comparisons are applied in\n   the order they occur in the
      DAV:orderby element, earlier comparisons\n   being more significant.\n   The
      comparisons defined here use only a single property from each\n   resource,
      compared using the same ordering as the DAV:lt operator\n   (ascending) or DAV:gt
      operator (descending).  If neither direction is\n   specified, the default is
      DAV:ascending.\n   In the context of the DAV:orderby element, null values are
      considered\n   to collate before any actual (i.e., non-null) value, including\n
      \  strings of zero length (this is compatible with [SQL99]).\n   The \"caseless\"
      attribute may be used to indicate case-sensitivity for\n   comparisons (Section
      5.18).\n"
    - contents:
      - "5.6.1.  Example of Sorting\n   This sort orders first by last name of the
        author and then by size,\n   in descending order, so that for each author,
        the largest works\n   appear first.\n   <d:orderby xmlns:d='DAV:' xmlns:r='http://example.com/ns'>\n
        \    <d:order>\n       <d:prop><r:lastname/></d:prop>\n       <d:ascending/>\n
        \    </d:order>\n     <d:order>\n       <d:prop><d:getcontentlength/></d:prop>\n
        \      <d:descending/>\n     </d:order>\n   </d:orderby>\n"
      title: 5.6.1.  Example of Sorting
    title: 5.6.  DAV:orderby
  - contents:
    - "5.7.  Boolean Operators: DAV:and, DAV:or, and DAV:not\n   The DAV:and operator
      performs a logical AND operation on the\n   expressions it contains.\n   The
      DAV:or operator performs a logical OR operation on the values it\n   contains.\n
      \  The DAV:not operator performs a logical NOT operation on the values\n   it
      contains.\n"
    title: '5.7.  Boolean Operators: DAV:and, DAV:or, and DAV:not'
  - contents:
    - "5.8.  DAV:eq\n   The DAV:eq operator provides simple equality matching on property\n
      \  values.\n   The \"caseless\" attribute may be used with this element\n   (Section
      5.18).\n"
    title: 5.8.  DAV:eq
  - contents:
    - "5.9.  DAV:lt, DAV:lte, DAV:gt, DAV:gte\n   The DAV:lt, DAV:lte, DAV:gt, and
      DAV:gte operators provide\n   comparisons on property values, using less-than,
      less-than or equal,\n   greater-than, and greater-than or equal, respectively.
      \ The\n   \"caseless\" attribute may be used with these elements (Section 5.18).\n"
    title: 5.9.  DAV:lt, DAV:lte, DAV:gt, DAV:gte
  - contents:
    - "5.10.  DAV:literal\n   DAV:literal allows literal values to be placed in an
      expression.\n   White space in literal values is significant in comparisons.
      \ For\n   consistency with [RFC4918], clients SHOULD NOT specify the attribute\n
      \  \"xml:space\" (Section 2.10 of [XML]) to override this behavior.\n   In comparisons,
      the contents of DAV:literal SHOULD be treated as\n   string, with the following
      exceptions:\n   o  when operand for a comparison with a DAV:getcontentlength\n
      \     property, it SHOULD be treated as an unsigned integer value (the\n      behavior
      for values not in this format is undefined),\n   o  when operand for a comparison
      with a DAV:creationdate or DAV:\n      getlastmodified property, it SHOULD be
      treated as a date value in\n      the ISO-8601 subset defined for the DAV:creationdate
      property (see\n      Section 15.1 of [RFC4918]; the behavior of values not in
      this\n      format is undefined),\n   o  when operand for a comparison with
      a property for which the type\n      is known and when compatible with that
      type, it MAY be treated\n      according to this type.\n"
    title: 5.10.  DAV:literal
  - contents:
    - "5.11.  DAV:typed-literal (Optional)\n   There are situations in which a client
      may want to force a comparison\n   not to be string-based (as defined for DAV:literal).
      \ In these cases,\n   a typed comparison can be enforced by using DAV:typed-literal\n
      \  instead.\n   <!ELEMENT typed-literal (#PCDATA)>\n   The data type is specified
      using the xsi:type attribute defined in\n   Section 2.6.1 of [XS1].  If the
      type is not specified, it defaults to\n   \"xs:string\".\n   A server MUST reject
      a request using an unknown type with a status of\n   422 (Unprocessable Entity).
      \ It SHOULD reject a request if the value\n   provided in DAV:typed-literal
      cannot be cast to the specified type.\n   The comparison evaluates to UNKNOWN
      if the property value cannot be\n   cast to the specified datatype (see [XPATHFUNC],
      Section 17).\n"
    - contents:
      - "5.11.1.  Example for Typed Numerical Comparison\n   Consider a set of resources
        with the dead property \"edits\" in the\n   namespace \"http://ns.example.org\":\n
        \                        +-----+----------------+\n                         |
        URI | property value |\n                         +-----+----------------+\n
        \                        | /a  | \"-1\"           |\n                         |
        /b  | \"01\"           |\n                         | /c  | \"3\"            |\n
        \                        | /d  | \"test\"         |\n                         |
        /e  | (undefined)    |\n                         +-----+----------------+\n
        \  The expression\n   <lt xmlns=\"DAV:\"\n     xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n
        \    xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">\n     <prop><edits xmlns=\"http://ns.example.org\"/></prop>\n
        \    <typed-literal xsi:type=\"xs:integer\">3</typed-literal>\n   </lt>\n
        \  will evaluate to TRUE for the resources \"/a\" and \"/b\" (their property\n
        \  values can be parsed as type xs:integer, and the numerical comparison\n
        \  evaluates to true), to FALSE for \"/c\" (property value is compatible,\n
        \  but numerical comparison evaluates to false), and UNKNOWN for \"/d\"\n
        \  and \"/e\" (the property either is undefined, or its value cannot be\n
        \  parsed as xs:integer).\n"
      title: 5.11.1.  Example for Typed Numerical Comparison
    title: 5.11.  DAV:typed-literal (Optional)
  - contents:
    - "5.12.  Support for Matching xml:lang Attributes on Properties\n   The following
      two optional operators can be used to express\n   conditions on the language
      of a property value (as expressed using\n   the xml:lang attribute).\n"
    - contents:
      - "5.12.1.  DAV:language-defined (Optional)\n   <!ELEMENT language-defined (prop)>\n
        \  This operator evaluates to TRUE if the language for the value of the\n
        \  given property is known, FALSE if it isn't, and UNKNOWN if the\n   property
        itself is not defined.\n"
      title: 5.12.1.  DAV:language-defined (Optional)
    - contents:
      - "5.12.2.  DAV:language-matches (Optional)\n   <!ELEMENT language-matches (prop,
        literal)>\n   This operator evaluates to TRUE if the language for the value
        of the\n   given property is known and matches the language name given in
        the\n   <literal> element, FALSE if it doesn't match, and UNKNOWN if the\n
        \  property itself is not defined.\n   Languages are considered to match if
        they are the same, or if the\n   language of the property value is a sublanguage
        of the language\n   specified in the <literal> element (see Section 4.3 of
        [XPATH], \"lang\n   function\").\n"
      title: 5.12.2.  DAV:language-matches (Optional)
    - contents:
      - "5.12.3.  Example of Language-Aware Matching\n   The expression below will
        evaluate to TRUE if the property \"foobar\"\n   exists and its language is
        either unknown, English, or a sublanguage\n   of English.\n   <or xmlns=\"DAV:\">\n
        \    <not>\n       <language-defined>\n         <prop><foobar/></prop>\n       </language-defined>\n
        \    </not>\n     <language-matches>\n       <prop><foobar/></prop>\n       <literal>en</literal>\n
        \    </language-matches>\n   </or>\n"
      title: 5.12.3.  Example of Language-Aware Matching
    title: 5.12.  Support for Matching xml:lang Attributes on Properties
  - contents:
    - "5.13.  DAV:is-collection\n   The DAV:is-collection operator allows clients
      to determine whether a\n   resource is a collection (that is, whether its DAV:resourcetype\n
      \  element contains the element DAV:collection).\n   Rationale: This operator
      is provided in lieu of defining generic\n   structure queries, which would suffice
      for this and for many more\n   powerful queries, but seems inappropriate to
      standardize at this\n   time.\n"
    - contents:
      - "5.13.1.  Example of DAV:is-collection\n   This example shows a search criterion
        that picks out all, and only,\n   the resources in the scope that are collections.\n
        \  <where xmlns=\"DAV:\">\n     <is-collection/>\n   </where>\n"
      title: 5.13.1.  Example of DAV:is-collection
    title: 5.13.  DAV:is-collection
  - contents:
    - "5.14.  DAV:is-defined\n   The DAV:is-defined operator allows clients to determine
      whether a\n   property is defined on a resource.  The meaning of \"defined on
      a\n   resource\" is found in Section 5.5.3.\n   Example:\n   <d:is-defined xmlns:d='DAV:'
      xmlns:x='http://example.com/ns'>\n     <d:prop><x:someprop/></d:prop>\n   </d:is-defined>\n"
    title: 5.14.  DAV:is-defined
  - contents:
    - "5.15.  DAV:like\n   The DAV:like is an optional operator intended to give simple\n
      \  wildcard-based pattern matching ability to clients.\n   The operator takes
      two arguments.\n   The first argument is a DAV:prop element identifying a single\n
      \  property to evaluate.\n   The second argument is a DAV:literal element that
      gives the pattern\n   matching string.\n"
    - contents:
      - "5.15.1.  Syntax for the Literal Pattern\n   pattern       = [wildcard] 0*(
        text [wildcard] )\n   wildcard      = exactlyone / zeroormore\n   text          =
        1*( character / escapeseq )\n   exactlyone    = \"_\"\n   zeroormore    =
        \"%\"\n   escapechar    = \"\\\"\n   escapeseq     = escapechar ( exactlyone
        / zeroormore / escapechar )\n   ; character: see [XML], Section 2.2, minus
        wildcard / escapechar\n   character     = HTAB / LF / CR ; whitespace\n   character
        \    =/ %x20-24 / %x26-5B / %x5D-5E / %x60-D7FF\n   character     =/ %xE000-FFFD
        / %x10000-10FFFF\n   (Note that the ABNF above is defined in terms of Unicode
        code points\n   ([UNICODE5]); when a query is transmitted as an XML document
        over\n   WebDAV, these characters are typically encoded in UTF-8 or UTF-16.)\n
        \  The value for the literal is composed of wildcards separated by\n   segments
        of text.  Wildcards may begin or end the literal.\n   The \"_\" wildcard matches
        exactly one character.\n   The \"%\" wildcard matches zero or more characters.\n
        \  The \"\\\" character is an escape sequence so that the literal can\n   include
        \"_\" and \"%\".  To include the \"\\\" character in the pattern,\n   the
        escape sequence \"\\\\\" is used.\n"
      title: 5.15.1.  Syntax for the Literal Pattern
    - contents:
      - "5.15.2.  Example of DAV:like\n   This example shows how a client might use
        DAV:like to identify those\n   resources whose content type was a subtype
        of image.\n   <D:where xmlns:D='DAV:'>\n     <D:like caseless=\"yes\">\n       <D:prop><D:getcontenttype/></D:prop>\n
        \      <D:literal>image/%</D:literal>\n     </D:like>\n   </D:where>\n"
      title: 5.15.2.  Example of DAV:like
    title: 5.15.  DAV:like
  - contents:
    - "5.16.  DAV:contains\n   The DAV:contains operator is an optional operator that
      provides\n   content-based search capability.  This operator implicitly searches\n
      \  against the text content of a resource, not against the content of\n   properties.
      \ The DAV:contains operator is intentionally not overly\n   constrained, in
      order to allow the server to do the best job it can\n   in performing the search.\n
      \  The DAV:contains operator evaluates to a Boolean value.  It evaluates\n   to
      TRUE if the content of the resource satisfies the search.\n   Otherwise, it
      evaluates to FALSE.\n   Within the DAV:contains XML element, the client provides
      a phrase: a\n   single word or whitespace delimited sequence of words.  Servers
      MAY\n   ignore punctuation in a phrase.  Case-sensitivity is at the\n   discretion
      of the server implementation.\n   The following non-exhaustive list enumerates
      things that may or may\n   not be done as part of the search: Phonetic methods
      such as \"soundex\"\n   may or may not be used.  Word stemming may or may not
      be performed.\n   Thesaurus expansion of words may or may not be done.  Right
      or left\n   truncation may or may not be performed.  The search may be case\n
      \  insensitive or case sensitive.  The word or words may or may not be\n   interpreted
      as names.  Multiple words may or may not be required to\n   be adjacent or \"near\"
      each other.  Multiple words may or may not be\n   required to occur in the same
      order.  Multiple words may or may not\n   be treated as a phrase.  The search
      may or may not be interpreted as\n   a request to find documents \"similar\"
      to the string operand.\n   Character canonicalization such as that done by the
      Unicode collation\n   algorithm may or may not be applied.\n"
    - contents:
      - "5.16.1.  Result Scoring (DAV:score Element)\n   Servers SHOULD indicate scores
        for the DAV:contains condition by\n   adding a DAV:score XML element to the
        DAV:response element.  Its\n   value is defined only in the context of a particular
        query result.\n   The value is a string representing the score, an integer
        from zero to\n   10000 inclusive, where a higher value indicates a higher
        score (e.g.,\n   more relevant).\n   Modified DTD fragment for DAV:propstat:\n
        \  <!ELEMENT response (href, ((href*, status)|(propstat+)),\n                       responsedescription?,
        score?) >\n   <!ELEMENT score    (#PCDATA) >\n   Clients should note that,
        in general, it is not meaningful to compare\n   the numeric values of scores
        from two different query results unless\n   both were executed by the same
        underlying search system on the same\n   collection of resources.\n"
      title: 5.16.1.  Result Scoring (DAV:score Element)
    - contents:
      - "5.16.2.  Ordering by Score\n   To order search results by their score, the
        DAV:score element may be\n   added as child to the DAV:orderby element (in
        place of a DAV:prop\n   element).\n"
      title: 5.16.2.  Ordering by Score
    - contents:
      - "5.16.3.  Examples\n   The example below shows a search for the phrase \"Peter
        Forsberg\".\n   Depending on its support for content-based searching, a server
        MAY\n   treat this as a search for documents that contain the words \"Peter\"\n
        \  and \"Forsberg\".\n   <D:where xmlns:D='DAV:'>\n     <D:contains>Peter
        Forsberg</D:contains>\n   </D:where>\n   The example below shows a search
        for resources that contain \"Peter\"\n   and \"Forsberg\".\n   <D:where xmlns:D='DAV:'>\n
        \    <D:and>\n       <D:contains>Peter</D:contains>\n       <D:contains>Forsberg</D:contains>\n
        \    </D:and>\n   </D:where>\n"
      title: 5.16.3.  Examples
    title: 5.16.  DAV:contains
  - contents:
    - "5.17.  Limiting the Result Set\n   <!ELEMENT limit (nresults) >\n   <!ELEMENT
      nresults (#PCDATA)> <!-- only digits -->\n   The DAV:limit XML element contains
      requested limits from the client\n   to limit the size of the reply or amount
      of effort expended by the\n   server.  The DAV:nresults XML element contains
      a requested maximum\n   number of DAV:response elements to be returned in the
      response body.\n   The server MAY disregard this limit.  The value of this element
      is an\n   unsigned integer.\n"
    - contents:
      - "5.17.1.  Relationship to Result Ordering\n   If the result set is both limited
        by DAV:limit and ordered according\n   to DAV:orderby, the results that are
        included in the response\n   document SHOULD be those that order highest.\n"
      title: 5.17.1.  Relationship to Result Ordering
    title: 5.17.  Limiting the Result Set
  - contents:
    - "5.18.  The 'caseless' XML Attribute\n   The \"caseless\" attribute allows clients
      to specify caseless matching\n   behavior instead of character-by-character
      matching for DAV:\n   basicsearch operators.\n   The possible values for \"caseless\"
      are \"yes\" or \"no\".  The default\n   value is server-specified.  Caseless
      matching SHOULD be implemented\n   as defined in Section 5.18 of the Unicode
      Standard ([UNICODE5]).\n   Support for the \"caseless\" attribute is optional.
      \ A server should\n   respond with a status of 422 if it is used but cannot
      be supported.\n"
    title: 5.18.  The 'caseless' XML Attribute
  - contents:
    - "5.19.  Query Schema for DAV:basicsearch\n   The DAV:basicsearch grammar defines
      a search criteria that is a\n   Boolean-valued expression, and allows for an
      arbitrary set of\n   properties to be included in the result record.  The result
      set may\n   be sorted on a set of property values.  Accordingly, the DTD for\n
      \  schema discovery for this grammar allows the server to express:\n   1.  the
      set of properties that may be either searched, returned, or\n       used to
      sort, and a hint about the data type of such properties.\n   2.  the set of
      optional operators defined by the resource.\n"
    - contents:
      - "5.19.1.  DTD for DAV:basicsearch QSD\n   <!ELEMENT basicsearchschema  (properties,
        operators)>\n   <!ELEMENT any-other-property EMPTY>\n   <!ELEMENT properties
        \        (propdesc*)>\n   <!ELEMENT propdesc           ((prop|any-other-property),
        datatype?,\n                                 searchable?, selectable?, sortable?,\n
        \                                caseless?)>\n   <!ELEMENT operators          (opdesc*)>\n
        \  <!ELEMENT opdesc             ANY>\n   <!ATTLIST opdesc             allow-pcdata
        (yes|no) #IMPLIED>\n   <!ELEMENT operand-literal    EMPTY>\n   <!ELEMENT operand-typed-literal
        EMPTY>\n   <!ELEMENT operand-property   EMPTY>\n   The DAV:properties element
        holds a list of descriptions of\n   properties.\n   The DAV:operators element
        describes the optional operators that may\n   be used in a DAV:where element.\n"
      title: 5.19.1.  DTD for DAV:basicsearch QSD
    - contents:
      - "5.19.2.  DAV:propdesc Element\n   Each instance of a DAV:propdesc element
        describes the property or\n   properties in the DAV:prop element it contains.
        \ All subsequent\n   elements are descriptions that apply to those properties.
        \ All\n   descriptions are optional and may appear in any order.  Servers\n
        \  SHOULD support all the descriptions defined here, and MAY define\n   others.\n
        \  DASL defines five descriptions.  The first, DAV:datatype, provides a\n
        \  hint about the type of the property value, and may be useful to a\n   user
        interface prompting for a value.  The remaining four (DAV:\n   searchable,
        DAV:selectable, DAV:sortable, and DAV:caseless) identify\n   portions of the
        query (DAV:where, DAV:select, and DAV:orderby,\n   respectively).  If a property
        has a description for a section, then\n   the server MUST allow the property
        to be used in that section.  These\n   descriptions are optional.  If a property
        does not have such a\n   description, or is not described at all, then the
        server MAY still\n   allow the property to be used in the corresponding section.\n"
      - contents:
        - "5.19.2.1.  DAV:any-other-property\n   This element can be used in place
          of DAV:prop to describe properties\n   of WebDAV properties not mentioned
          in any other DAV:prop element.\n   For instance, this can be used to indicate
          that all other properties\n   are searchable and selectable without giving
          details about their\n   types (a typical scenario for dead properties).\n"
        title: 5.19.2.1.  DAV:any-other-property
      title: 5.19.2.  DAV:propdesc Element
    - contents:
      - "5.19.3.  The DAV:datatype Property Description\n   The DAV:datatype element
        contains a single XML element that provides\n   a hint about the domain of
        the property, which may be useful to a\n   user interface prompting for a
        value to be used in a query.  Data\n   types are identified by an element
        name.  Where appropriate, a server\n   SHOULD use the simple data types defined
        in [XS2].\n   <!ELEMENT datatype ANY >\n   Examples from [XS2], Section 3:\n
        \                +----------------+---------------------+\n                 |
        Qualified name | Example             |\n                 +----------------+---------------------+\n
        \                | xs:boolean     | true, false, 1, 0   |\n                 |
        xs:string      | Foobar              |\n                 | xs:dateTime    |
        1994-11-05T08:15:5Z |\n                 | xs:float       | .314159265358979E+1
        |\n                 | xs:integer     | -259, 23            |\n                 +----------------+---------------------+\n
        \  If the data type of a property is not given, then the data type\n   defaults
        to xs:string.\n"
      title: 5.19.3.  The DAV:datatype Property Description
    - contents:
      - "5.19.4.  The DAV:searchable Property Description\n   <!ELEMENT searchable
        EMPTY>\n   If this element is present, then the server MUST allow this property\n
        \  to appear within a DAV:where element where an operator allows a\n   property.
        \ Allowing a search does not mean that the property is\n   guaranteed to be
        defined on every resource in the scope, it only\n   indicates the server's
        willingness to check.\n"
      title: 5.19.4.  The DAV:searchable Property Description
    - contents:
      - "5.19.5.  The DAV:selectable Property Description\n   <!ELEMENT selectable
        EMPTY>\n   This element indicates that the property may appear in the DAV:select\n
        \  element.\n"
      title: 5.19.5.  The DAV:selectable Property Description
    - contents:
      - "5.19.6.  The DAV:sortable Property Description\n   This element indicates
        that the property may appear in the DAV:\n   orderby element.\n   <!ELEMENT
        sortable EMPTY>\n"
      title: 5.19.6.  The DAV:sortable Property Description
    - contents:
      - "5.19.7.  The DAV:caseless Property Description\n   This element only applies
        to properties whose data type is \"xs:\n   string\" and derived data types
        as per the DAV:datatype property\n   description.  Its presence indicates
        that comparisons performed for\n   searches, and the comparisons for ordering
        results on the string\n   property will be caseless (the default is character
        by character).\n   <!ELEMENT caseless EMPTY>\n"
      title: 5.19.7.  The DAV:caseless Property Description
    - contents:
      - "5.19.8.  The DAV:operators XML Element\n   The DAV:operators element describes
        every optional operator supported\n   in a query.  (Mandatory operators are
        not listed since they are\n   mandatory and permit no variation in syntax.)
        \ All optional operators\n   that are supported MUST be listed in the DAV:operators
        element.\n   The listing for an operator, contained in an DAV:opdesc element,\n
        \  consists of the operator (as an empty element), followed by one\n   element
        for each operand.  The operand MUST be either DAV:operand-\n   property, DAV:operand-literal,
        or DAV:operand-typed-literal, which\n   indicate that the operand in the corresponding
        position is a\n   property, a literal value, or a typed literal value, respectively.\n
        \  If an operator is polymorphic (allows more than one operand syntax)\n   then
        each permitted syntax MUST be listed separately.\n   The DAV:opdesc element
        MAY have a \"allow-pcdata\" attribute\n   (defaulting to \"no\").  A value
        of \"yes\" indicates that the operator\n   can contain character data, as
        it is the case with DAV:contains (see\n   Section 5.16).  Definition of additional
        operators using this format\n   is NOT RECOMMENDED.\n   <operators xmlns='DAV:'>\n
        \    <opdesc>\n       <like/><operand-property/><operand-literal/>\n     </opdesc>\n
        \  </operators>\n"
      title: 5.19.8.  The DAV:operators XML Element
    - contents:
      - "5.19.9.  Example of Query Schema for DAV:basicsearch\n   <D:basicsearchschema
        xmlns:D=\"DAV:\"\n     xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">\n     <D:properties>\n
        \      <D:propdesc>\n         <D:prop><D:getcontentlength/></D:prop>\n         <D:datatype><xs:nonNegativeInteger/></D:datatype>\n
        \        <D:searchable/><D:selectable/><D:sortable/>\n       </D:propdesc>\n
        \      <D:propdesc>\n         <D:prop><D:getcontenttype/><D:displayname/></D:prop>\n
        \        <D:searchable/><D:selectable/><D:sortable/>\n       </D:propdesc>\n
        \      <D:propdesc>\n         <D:prop><fstop xmlns=\"http://ns.example.org\"/></D:prop>\n
        \        <D:selectable/>\n       </D:propdesc>\n       <D:propdesc>\n         <D:any-other-property/>\n
        \        <D:searchable/><D:selectable/>\n       </D:propdesc>\n     </D:properties>\n
        \    <D:operators>\n       <D:opdesc>\n         <D:like/><D:operand-property/><D:operand-literal/>\n
        \      </D:opdesc>\n       <D:opdesc allow-pcdata=\"yes\">\n         <D:contains/>\n
        \      </D:opdesc>\n     </D:operators>\n   </D:basicsearchschema>\n   This
        response lists four properties.  The data type of the last three\n   properties
        is not given, so it defaults to xs:string.  All are\n   selectable, and the
        first three may be searched.  All but the last\n   may be used in a sort.
        \ Of the optional DAV operators, DAV:contains\n   and DAV:like are supported.\n
        \     Note: The schema discovery defined here does not provide for\n      discovery
        of supported values of the \"caseless\" attribute.  This\n      may require
        that the reply also list the mandatory operators.\n"
      title: 5.19.9.  Example of Query Schema for DAV:basicsearch
    title: 5.19.  Query Schema for DAV:basicsearch
  title: 5.  The DAV:basicsearch Grammar
- contents:
  - "6.  Internationalization Considerations\n   Properties may be language-tagged
    using the xml:lang attribute (see\n   [RFC4918], Section 4.3).  The optional operators
    DAV:language-defined\n   (Section 5.12.1) and DAV:language-matches (Section 5.12.2)
    allow the\n   expression of conditions on the language tagging information.\n"
  title: 6.  Internationalization Considerations
- contents:
  - "7.  Security Considerations\n   This section is provided to detail issues concerning
    security\n   implications of which DASL applications need to be aware.  All of
    the\n   security considerations of HTTP/1.1 ([RFC2616] and WebDAV ([RFC4918])\n
    \  also apply to DASL.  In addition, this section will include security\n   risks
    inherent in the search and retrieval of resource properties and\n   content.\n
    \  A query MUST NOT allow clients to retrieve information that wouldn't\n   have
    been available through the GET or PROPFIND methods in the first\n   place.  In
    particular:\n   o  Query constraints on WebDAV properties for which the client
    does\n      not have read access need to be evaluated as if the property did\n
    \     not exist (see Section 5.5.3).\n   o  Query constraints on content (as with
    DAV:contains, defined in\n      Section 5.16) for which the client does not have
    read access need\n      to be evaluated as if a GET would return a 4xx status
    code.\n   A server should prepare for denial-of-service attacks.  For example
    a\n   client may issue a query for which the result set is expensive to\n   calculate
    or transmit because many resources match or must be\n   evaluated.\n"
  - contents:
    - "7.1.  Implications of XML External Entities\n   XML supports a facility known
      as \"external entities\", defined in\n   Section 4.2.2 of [XML], which instruct
      an XML processor to retrieve\n   and perform an inline include of XML located
      at a particular URI.  An\n   external XML entity can be used to append or modify
      the document type\n   declaration (DTD) associated with an XML document.  An
      external XML\n   entity can also be used to include XML within the content of
      an XML\n   document.  For non-validating XML, such as the XML used in this\n
      \  specification, including an external XML entity is not required by\n   [XML].
      \ However, [XML] does state that an XML processor may, at its\n   discretion,
      include the external XML entity.\n   External XML entities have no inherent
      trustworthiness and are\n   subject to all the attacks that are endemic to any
      HTTP GET request.\n   Furthermore, it is possible for an external XML entity
      to modify the\n   DTD, and hence affect the final form of an XML document, in
      the worst\n   case significantly modifying its semantics, or exposing the XML\n
      \  processor to the security risks discussed in [RFC3023].  Therefore,\n   implementers
      must be aware that external XML entities should be\n   treated as untrustworthy.\n
      \  There is also the scalability risk that would accompany a widely\n   deployed
      application that made use of external XML entities.  In this\n   situation,
      it is possible that there would be significant numbers of\n   requests for one
      external XML entity, potentially overloading any\n   server that fields requests
      for the resource containing the external\n   XML entity.\n"
    title: 7.1.  Implications of XML External Entities
  title: 7.  Security Considerations
- contents:
  - "8.  Scalability\n   Query grammars are identified by URIs.  Applications SHOULD
    NOT\n   attempt to retrieve these URIs even if they appear to be retrievable\n
    \  (for example, those that begin with \"http://\").\n"
  title: 8.  Scalability
- contents:
  - "9.  IANA Considerations\n   This document uses the namespace defined in Section
    21 of [RFC4918]\n   for XML elements.\n"
  - contents:
    - "9.1.  HTTP Headers\n   This document specifies the HTTP header listed below,
      which has been\n   added to the permanent HTTP header registry defined in [RFC3864].\n"
    - contents:
      - "9.1.1.  DASL\n   Header field name:  DASL\n   Applicable protocol:  http\n
        \  Status:  standard\n   Author/Change controller:  IETF\n   Specification
        document:  this specification (Section 3.2)\n"
      title: 9.1.1.  DASL
    title: 9.1.  HTTP Headers
  title: 9.  IANA Considerations
- contents:
  - "10.  Contributors\n   This document is based on prior work on the DASL protocol
    done by the\n   WebDAV DASL working group until the year 2000 -- namely by Alan\n
    \  Babich, Jim Davis, Rick Henderson, Dale Lowry, Saveen Reddy, Surendra\n   Reddy,
    and Judith Slein (see <http://www.webdav.org/dasl/> for the\n   working group's
    web site,\n   <http://purl.org/NET/webdav/dasl-references/reqs> for a requirements\n
    \  document, and\n   <http://purl.org/NET/webdav/dasl-references/dasl-protocol-00>
    for an\n   early version of the specification).\n"
  title: 10.  Contributors
- contents:
  - "11.  Acknowledgements\n   This document has benefited from thoughtful discussion
    by Lisa\n   Dusseault, Javier Godoy, Sung Kim, Chris Newman, Elias Sinderson,\n
    \  Martin Wallmer, Keith Wannamaker, Jim Whitehead, and Kevin Wiggen.\n"
  title: 11.  Acknowledgements
- contents:
  - '12.  References

    '
  - contents:
    - "12.1.  Normative References\n   [RFC2119]      Bradner, S., \"Key words for
      use in RFCs to Indicate\n                  Requirement Levels\", BCP 14, RFC
      2119, March 1997.\n   [RFC2616]      Fielding, R., Gettys, J., Mogul, J., Frystyk,
      H.,\n                  Masinter, L., Leach, P., and T. Berners-Lee,\n                  \"Hypertext
      Transfer Protocol -- HTTP/1.1\", RFC 2616,\n                  June 1999.\n   [RFC3023]
      \     Murata, M., St. Laurent, S., and D. Kohn, \"XML Media\n                  Types\",
      RFC 3023, January 2001.\n   [RFC3253]      Clemm, G., Amsden, J., Ellison, T.,
      Kaler, C., and J.\n                  Whitehead, \"Versioning Extensions to WebDAV
      (Web\n                  Distributed Authoring and Versioning)\", RFC 3253,\n
      \                 March 2002.\n   [RFC3744]      Clemm, G., Reschke, J., Sedlar,
      E., and J. Whitehead,\n                  \"Web Distributed Authoring and Versioning
      (WebDAV)\n                  Access Control Protocol\", RFC 3744, May 2004.\n
      \  [RFC3986]      Berners-Lee, T., Fielding, R., and L. Masinter,\n                  \"Uniform
      Resource Identifier (URI): Generic Syntax\",\n                  STD 66, RFC
      3986, January 2005.\n   [RFC4918]      Dusseault, L., Ed., \"HTTP Extensions
      for Web\n                  Distributed Authoring and Versioning (WebDAV)\",\n
      \                 RFC 4918, June 2007.\n   [RFC5234]      Crocker, D., Ed. and
      P. Overell, \"Augmented BNF for\n                  Syntax Specifications: ABNF\",
      STD 68, RFC 5234,\n                  January 2008.\n   [XML]          Bray,
      T., Paoli, J., Sperberg-McQueen, C., Maler, E.,\n                  and F. Yergeau,
      \"Extensible Markup Language (XML) 1.0\n                  (Fourth Edition)\",
      W3C REC-xml-20060816, August 2006,\n                  <http://www.w3.org/TR/2006/REC-xml-20060816>.\n
      \  [XPATH]        Clark, J. and S. DeRose, \"XML Path Language (XPath)\n                  Version
      1.0\", W3C REC-xpath-19991116, November 1999,\n                  <http://www.w3.org/TR/1999/REC-xpath-19991116>.\n
      \  [XPATHFUNC]    Malhotra, A., Melton, J., and N. Walsh, \"XQuery 1.0\n                  and
      XPath 2.0 Functions and Operators\", W3C REC-xpath-\n                  functions-20070123,
      January 2007, <http://www.w3.org/\n                  TR/2007/REC-xpath-functions-20070123/>.\n
      \  [XS1]          Thompson, H., Beech, D., Maloney, M., Mendelsohn, N.,\n                  and
      World Wide Web Consortium, \"XML Schema Part 1:\n                  Structures\",
      W3C REC-xmlschema-1-20041028,\n                  October 2004,\n                  <http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/>.\n
      \  [XS2]          Biron, P., Malhotra, A., and World Wide Web\n                  Consortium,
      \"XML Schema Part 2: Datatypes Second\n                  Edition\", W3C REC-xmlschema-2-20041028,
      October 2004,\n                  <http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/>.\n"
    title: 12.1.  Normative References
  - contents:
    - "12.2.    Informative References\n   [BCP47]        Phillips, A. and M. Davis,
      \"Matching of Language\n                  Tags\", BCP 47, RFC 4647, September
      2006.\n   [RFC3864]      Klyne, G., Nottingham, M., and J. Mogul, \"Registration\n
      \                 Procedures for Message Header Fields\", BCP 90,\n                  RFC
      3864, September 2004.\n   [RFC4437]      Whitehead, J., Clemm, G., and J. Reschke,
      Ed., \"Web\n                  Distributed Authoring and Versioning (WebDAV)
      Redirect\n                  Reference Resources\", RFC 4437, March 2006.\n   [RFC4790]
      \     Newman, C., Duerst, M., and A. Gulbrandsen, \"Internet\n                  Application
      Protocol Collation Registry\", RFC 4790,\n                  March 2007.\n   [SQL99]
      \       Milton, J., \"Database Language SQL Part 2:  Foundation\n                  (SQL/Foundation)\",
      ISO ISO/IEC 9075-2:1999 (E),\n                  July 1999.\n   [UNICODE5]     The
      Unicode Consortium, \"The Unicode Standard -\n                  Version 5.0\",
      Addison-Wesley , November 2006,\n                  <http://www.unicode.org/versions/Unicode5.0.0/>.\n
      \                 ISBN 0321480910 [1]\n   [WEBDAV-BIND]  Clemm, G., Crawford,
      J., Reschke, J., Ed., and J.\n                  Whitehead, \"Binding Extensions
      to Web Distributed\n                  Authoring and Versioning (WebDAV)\", October
      2008.\n"
    - "URIs\n   [1]  <urn:isbn:0321480910>\n"
    title: 12.2.    Informative References
  title: 12.  References
- contents:
  - "Appendix A.  Three-Valued Logic in DAV:basicsearch\n   ANSI standard three-valued
    logic is used when evaluating the search\n   condition (as defined in the ANSI
    standard SQL specifications, for\n   example, in ANSI X3.135-1992, Section 8.12,
    pp. 188-189, Section 8.2,\n   p. 169, General Rule 1)a), etc.).\n   ANSI standard
    three-valued logic is undoubtedly the most widely\n   practiced method of dealing
    with the issues of properties in the\n   search condition not having a value (e.g.,
    being null or not defined)\n   for the resource under scan, and with undefined
    expressions in the\n   search condition (e.g., division by zero, etc.).  Three
    valued logic\n   works as follows.\n   Undefined expressions are expressions for
    which the value of the\n   expression is not defined.  Undefined expressions are
    a completely\n   separate concept from the truth value UNKNOWN, which is, in fact,\n
    \  well defined.  Property names and literal constants are considered\n   expressions
    for purposes of this section.  If a property in the\n   current resource under
    scan has not been set to a value, then the\n   value of that property is undefined
    for the resource under scan.\n   DASL 1.0 has no arithmetic division operator,
    but if it did, division\n   by zero would be an undefined arithmetic expression.\n
    \  If any subpart of an arithmetic, string, or datetime subexpression is\n   undefined,
    the whole arithmetic, string, or datetime subexpression is\n   undefined.\n   There
    are no manifest constants to explicitly represent undefined\n   number, string,
    or datetime values.\n   Since a Boolean value is ultimately returned by the search
    condition,\n   arithmetic, string, and datetime expressions are always arguments
    to\n   other operators.  Examples of operators that convert arithmetic,\n   string,
    and datetime expressions to Boolean values are the six\n   relational operators
    (\"greater than\", \"less than\", \"equals\", etc.).\n   If either or both operands
    of a relational operator have undefined\n   values, then the relational operator
    evaluates to UNKNOWN.\n   Otherwise, the relational operator evaluates to TRUE
    or FALSE,\n   depending upon the outcome of the comparison.\n   The Boolean operators
    DAV:and, DAV:or, and DAV:not are evaluated\n   according to the following rules:\n
    \  not UNKNOWN = UNKNOWN\n   UNKNOWN and TRUE = UNKNOWN\n   UNKNOWN and FALSE
    = FALSE\n   UNKNOWN and UNKNOWN = UNKNOWN\n   UNKNOWN or TRUE = TRUE\n   UNKNOWN
    or FALSE = UNKNOWN\n   UNKNOWN or UNKNOWN = UNKNOWN\n"
  title: Appendix A.  Three-Valued Logic in DAV:basicsearch
- contents:
  - "Appendix B.  Candidates for Future Protocol Extensions\n   This section summarizes
    issues that have been raised during the\n   development of this specification,
    but for which no resolution could\n   be found with the constraints in place.
    \ Future revisions of this\n   specification should revisit these issues, though.\n"
  - contents:
    - "B.1.  Collation Support\n   Matching and sorting of textual data relies on
      collations.  With\n   respect to WebDAV SEARCH, a combination of various design
      approaches\n   could be used:\n   o  Require server support for specific collations.\n
      \  o  Require that the server can advertise which collations it\n      supports.\n
      \  o  Allow a client to select the collation to be used.\n   In practice, the
      current implementations of WebDAV SEARCH usually\n   rely on backends they do
      not control, and for which collation\n   information may not be available.  To
      make things worse,\n   implementations of the DAV:basicsearch grammar frequently
      need to\n   combine data from multiple underlying stores (such as properties
      and\n   full text content), and thus collation support may vary based on the\n
      \  operator or property.\n   Another open issue is what collation formalism
      to support.  At the\n   time of this writing, the two specifications below seem
      to provide\n   the necessary framework and thus may be the base for future work
      on\n   collation support in WebDAV SEARCH:\n   1.  \"Internet Application Protocol
      Collation Registry\" ([RFC4790]).\n   2.  \"XQuery 1.0 and XPath 2.0 Functions
      and Operators\" ([XPATHFUNC],\n       Section 7.3.1).\n"
    title: B.1.  Collation Support
  - contents:
    - "B.2.  Count\n   DAV:basicsearch does not allow a request that returns the count
      of\n   matching resources.\n   A protocol extension would need to extend DAV:select,
      and also modify\n   the DAV:multistatus response format.\n"
    title: B.2.  Count
  - contents:
    - "B.3.  Diagnostics for Unsupported Queries\n   There are many reasons why a
      given query may not be supported by a\n   server.  Query Schema Discovery (Section
      4) can be used to discover\n   some constraints, but not all.\n   Future revisions
      should consider the introduction of specific\n   condition codes ([RFC4918],
      Section 16) to these situations.\n"
    title: B.3.  Diagnostics for Unsupported Queries
  - contents:
    - "B.4.  Language Matching\n   Section 5.12.2 defines language matching in terms
      of the XPath \"lang\"\n   function ([XPATH], Section 4.3).  Future revisions
      should consider\n   building on [BCP47] instead.\n"
    title: B.4.  Language Matching
  - contents:
    - "B.5.  Matching Media Types\n   Matching media types using the DAV:getcontenttype
      property and the\n   DAV:like operator is hard due to DAV:getcontenttype also
      allowing\n   parameters.  A new operator specifically designed for the purpose
      of\n   matching media types probably would simplify things a lot.  See <http\n
      \  ://lists.w3.org/Archives/Public/www-webdav-dasl/2003OctDec/0109.html>\n   for
      a specific proposal.\n"
    title: B.5.  Matching Media Types
  - contents:
    - "B.6.  Query by Name\n   DAV:basicsearch operates on the properties (and optionally
      the\n   contents) of resources, and thus doesn't really allow matching on\n
      \  parts of the resource's URI.  See <http://lists.w3.org/Archives/\n   Public/www-webdav-dasl/2003OctDec/0100.html>
      for a proposed extension\n   covering this use case.\n"
    title: B.6.  Query by Name
  - contents:
    - "B.7.  Result Paging\n   A frequently discussed feature is the ability to specifically
      request\n   the \"next\" set of results, when either the server decided to truncate\n
      \  the result, or the client explicitly asked for a limited set (for\n   instance,
      using the DAV:limit element defined in Section 5.17).\n   In this case, it would
      be desirable if the server could keep the full\n   query result, and provide
      a new URI identifying a separate result\n   resource, allowing the client to
      retrieve additional data through GET\n   requests, and remove the result through
      a DELETE request.\n"
    title: B.7.  Result Paging
  - contents:
    - "B.8.  Search Scope Discovery\n   Given a Search Arbiter resource, there's currently
      no way to discover\n   programmatically the supported sets of search scopes.
      \ Future\n   revisions of this specification could specify a scope discovery\n
      \  mechanism, similar to the Query Schema Discovery defined in\n   Section 4.\n"
    title: B.8.  Search Scope Discovery
  title: Appendix B.  Candidates for Future Protocol Extensions
- contents:
  - "Index\n   C\n      caseless attribute  26-27, 34\n      Condition Names\n         DAV:search-grammar-discovery-supported
    (pre)  9\n         DAV:search-grammar-supported (pre)  9\n         DAV:search-multiple-scope-supported
    (pre)  9\n         DAV:search-scope-valid (pre)  9\n      Criteria  5\n   D\n
    \     DAV:and  26\n      DAV:ascending  26\n      DAV:contains  31\n      DAV:depth
    \ 23\n      DAV:descending  26\n      DAV:eq  27\n         caseless attribute
    \ 27\n      DAV:from  23\n      DAV:gt  27\n      DAV:gte  27\n      DAV:include-versions
    \ 23\n      DAV:is-collection  30\n      DAV:is-defined  30\n      DAV:language-defined
    \ 29\n      DAV:language-matches  29\n      DAV:like  30\n      DAV:limit  33\n
    \     DAV:literal  27\n      DAV:lt  27\n      DAV:lte  27\n      DAV:not  26\n
    \     DAV:nresults  33\n      DAV:or  26\n      DAV:orderby  26\n      DAV:scope
    \ 23\n      DAV:score  32\n         relationship to DAV:orderby  33\n      DAV:search-grammar-discovery-supported
    precondition  9\n      DAV:search-grammar-supported precondition  9\n      DAV:search-multiple-scope-supported
    precondition  9\n      DAV:search-scope-valid precondition  9\n      DAV:select
    \ 23\n      DAV:supported-query-grammar-set property  14\n      DAV:typed-literal
    \ 28\n      DAV:where  24\n   M\n      Methods\n         SEARCH  7\n   O\n      OPTIONS
    method  13\n         DASL response header  14\n   P\n      Properties\n         DAV:supported-query-grammar-set
    \ 14\n   Q\n      Query  5\n      Query Grammar  5\n      Query Grammar Discovery
    \ 13\n         using live property  13\n         using OPTIONS  13\n      Query
    Schema  5\n   R\n      Result  5\n      Result Record  5\n      Result Record
    Definition  5\n      Result Set  5\n      Result Set Truncation\n         Example
    \ 10\n   S\n      Scope  6\n      Search Arbiter  6\n      SEARCH method  7\n
    \     Search Modifier  6\n      Sort Specification  6\n"
  title: Index
- contents:
  - "Authors' Addresses\n   Julian F. Reschke (editor)\n   greenbytes GmbH\n   Hafenweg
    16\n   Muenster, NW  48155\n   Germany\n   Phone: +49 251 2807760\n   EMail: julian.reschke@greenbytes.de\n
    \  URI:   http://greenbytes.de/tech/webdav/\n   Surendra Reddy\n   Mitrix, Inc.\n
    \  303 Twin Dolphin Drive, Suite 600-37\n   Redwood City, CA  94065\n   U.S.A.\n
    \  Phone: +1 408 500 1135\n   EMail: Surendra.Reddy@mitrix.com\n   Jim Davis\n
    \  27 Borden Street\n   Toronto, Ontario  M5S 2M8\n   Canada\n   Phone: +1 416
    929 5854\n   EMail: jrd3@alum.mit.edu\n   URI:   http://www.econetwork.net/~jdavis\n
    \  Alan Babich\n   IBM Corporation\n   3565 Harbor Blvd.\n   Costa Mesa, CA  92626\n
    \  U.S.A.\n   Phone: +1 714 327 3403\n   EMail: ababich@us.ibm.com\n"
  title: Authors' Addresses
