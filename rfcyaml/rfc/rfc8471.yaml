- contents:
  - '                 The Token Binding Protocol Version 1.0

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This document specifies version 1.0 of the Token Binding protocol.\n
    \  The Token Binding protocol allows client/server applications to\n   create
    long-lived, uniquely identifiable TLS bindings spanning\n   multiple TLS sessions
    and connections.  Applications are then enabled\n   to cryptographically bind
    security tokens to the TLS layer,\n   preventing token export and replay attacks.
    \ To protect privacy, the\n   Token Binding identifiers are only conveyed over
    TLS and can be reset\n   by the user at any time.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    7841.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8471.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2018 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (https://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .
    . . . . .   3\n     1.1.  Requirements Language . . . . . . . . . . . . . . .
    . . .   4\n   2.  Token Binding Protocol Overview . . . . . . . . . . . . . .
    .   4\n   3.  Token Binding Protocol Message  . . . . . . . . . . . . . . .   5\n
    \    3.1.  TokenBinding.tokenbinding_type  . . . . . . . . . . . . .   6\n     3.2.
    \ TokenBinding.tokenbindingid . . . . . . . . . . . . . . .   7\n     3.3.  TokenBinding.signature
    \ . . . . . . . . . . . . . . . . .   7\n     3.4.  TokenBinding.extensions .
    . . . . . . . . . . . . . . . .   9\n   4.  Establishing a Token Binding  . .
    . . . . . . . . . . . . . .   9\n     4.1.  Client Processing Rules . . . . .
    . . . . . . . . . . . .   9\n     4.2.  Server Processing Rules . . . . . . .
    . . . . . . . . . .  10\n   5.  Bound Security Token Creation and Validation  .
    . . . . . . .  11\n   6.  IANA Considerations . . . . . . . . . . . . . . . .
    . . . . .  11\n     6.1.  Token Binding Key Parameters Registry . . . . . . .
    . . .  11\n     6.2.  Token Binding Types Registry  . . . . . . . . . . . . .
    .  12\n     6.3.  Token Binding Extensions Registry . . . . . . . . . . . .  13\n
    \    6.4.  Registration of Token Binding TLS Exporter Label  . . . .  13\n   7.
    \ Security Considerations . . . . . . . . . . . . . . . . . . .  14\n     7.1.
    \ Security Token Replay . . . . . . . . . . . . . . . . . .  14\n     7.2.  Downgrade
    Attacks . . . . . . . . . . . . . . . . . . . .  14\n     7.3.  Token Binding
    Key-Sharing between Applications  . . . . .  14\n     7.4.  Triple Handshake Vulnerability
    in TLS 1.2 and Older TLS\n           Versions  . . . . . . . . . . . . . . . .
    . . . . . . . .  15\n   8.  Privacy Considerations  . . . . . . . . . . . . .
    . . . . . .  15\n   9.  References  . . . . . . . . . . . . . . . . . . . . .
    . . . .  16\n     9.1.  Normative References  . . . . . . . . . . . . . . . .
    . .  16\n     9.2.  Informative References  . . . . . . . . . . . . . . . . .
    \ 17\n   Acknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  18\n
    \  Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  18\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   Servers often generate various security tokens (e.g., HTTP
    cookies,\n   OAuth tokens [RFC6749]) for applications to present when accessing\n
    \  protected resources.  In general, any party in possession of bearer\n   security
    tokens gains access to certain protected resource(s).\n   Attackers take advantage
    of this by exporting bearer tokens from a\n   user's application connections or
    machines, presenting them to\n   application servers, and impersonating authenticated
    users.  The idea\n   of Token Binding is to prevent such attacks by cryptographically\n
    \  binding application security tokens to the underlying TLS layer\n   [RFC5246].
    \ (Note: This document deals with TLS 1.2 and therefore\n   refers to RFC 5246
    (which has been obsoleted by RFC 8446);\n   [TOKENBIND-TLS13] addresses Token
    Binding in TLS 1.3.)\n   A Token Binding is established by a User Agent generating
    a\n   private-public key pair (possibly within a secure hardware module,\n   such
    as a Trusted Platform Module) per target server, providing the\n   public key
    to the server, and proving possession of the corresponding\n   private key, on
    every TLS connection to the server.  The proof of\n   possession involves signing
    the Exported Keying Material (EKM)\n   [RFC5705] from the TLS connection with
    the private key.  The\n   corresponding public key is included in the Token Binding
    identifier\n   structure (described in Section 3.2 (\"TokenBinding.tokenbindingid\")).\n
    \  Token Bindings are long-lived, i.e., they encompass multiple TLS\n   connections
    and TLS sessions between a given client and server.  To\n   protect privacy, Token
    Binding IDs are never conveyed over insecure\n   connections and can be reset
    by the user at any time, e.g., when\n   clearing browser cookies.\n   When issuing
    a security token to a client that supports Token\n   Binding, a server includes
    the client's Token Binding ID (or its\n   cryptographic hash) in the token.  Later
    on, when a client presents a\n   security token containing a Token Binding ID,
    the server verifies\n   that the ID in the token matches the ID of the Token Binding\n
    \  established with the client.  In the case of a mismatch, the server\n   rejects
    the token (details are application specific).\n   In order to successfully export
    and replay a bound security token, an\n   attacker needs to also be able to use
    the client's private key; this\n   is hard to do if the key is specially protected,
    e.g., generated in a\n   secure hardware module.\n"
  - contents:
    - "1.1.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
      \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT
      RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted
      as described in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear
      in all\n   capitals, as shown here.\n"
    title: 1.1.  Requirements Language
  title: 1.  Introduction
- contents:
  - "2.  Token Binding Protocol Overview\n   In the course of a TLS handshake, a client
    and server can use the\n   Token Binding negotiation TLS extension [RFC8472] to
    negotiate the\n   Token Binding protocol version and the parameters (signature\n
    \  algorithm, length) of the Token Binding key.  This negotiation does\n   not
    require additional round trips.\n   Version 1.0 of the Token Binding protocol
    is represented by\n   TB_ProtocolVersion.major = 1 and TB_ProtocolVersion.minor
    = 0 in the\n   Token Binding negotiation TLS extension; see [RFC8472] (\"Transport\n
    \  Layer Security (TLS) Extension for Token Binding Protocol\n   Negotiation\").\n
    \  The Token Binding protocol consists of one message sent by the client\n   to
    the server, proving possession of one or more client-generated\n   asymmetric
    private keys.  This message is not sent if the Token\n   Binding negotiation has
    been unsuccessful.  The Token Binding message\n   is sent with the application
    protocol data over TLS.\n   A server receiving the Token Binding message verifies
    that the key\n   parameters in the message match the Token Binding parameters\n
    \  negotiated (e.g., via [RFC8472]) and then validates the signatures\n   contained
    in the Token Binding message.  If either of these checks\n   fails, the server
    rejects the binding, along with all associated\n   bound tokens.  Otherwise, the
    Token Binding is successfully\n   established with the ID contained in the Token
    Binding message.\n   When a server supporting the Token Binding protocol receives
    a bound\n   token, the server compares the Token Binding ID in the token with
    the\n   Token Binding ID established with the client.  If the bound token is\n
    \  received on a TLS connection without a Token Binding or if the Token\n   Binding
    IDs do not match, the token is rejected.\n   This document defines the format
    of the Token Binding protocol\n   message, the process of establishing a Token
    Binding, the format of\n   the Token Binding ID, and the process of validating
    a bound token.\n   [RFC8472] describes the negotiation of the Token Binding protocol
    and\n   key parameters.  [RFC8473] (\"Token Binding over HTTP\") explains how\n
    \  the Token Binding message is encapsulated within HTTP/1.1 messages\n   [RFC7230]
    or HTTP/2 messages [RFC7540].  [RFC8473] also describes\n   Token Binding between
    multiple communicating parties: User Agent,\n   Identity Provider, and Relying
    Party.\n"
  title: 2.  Token Binding Protocol Overview
- contents:
  - "3.  Token Binding Protocol Message\n   The Token Binding message is sent by the
    client to prove possession\n   of one or more private keys held by the client.
    \ This message MUST be\n   sent if the client and server successfully negotiated
    the use of the\n   Token Binding protocol (e.g., via [RFC8472] or a different
    mechanism)\n   and MUST NOT be sent otherwise.  This message MUST be sent in the\n
    \  client's first application protocol message.  This message MAY also\n   be
    sent in subsequent application protocol messages, proving\n   possession of additional
    private keys held by the same client; this\n   information can be used to facilitate
    Token Binding between more than\n   two communicating parties.  For example, [RFC8473]
    specifies an\n   encapsulation of the Token Binding message in HTTP application\n
    \  protocol messages, as well as scenarios involving more than two\n   communicating
    parties.\n   The Token Binding message format is defined using the TLS\n   presentation
    language (see Section 4 of [RFC5246]):\n   enum {\n       rsa2048_pkcs1.5(0),
    rsa2048_pss(1), ecdsap256(2), (255)\n   } TokenBindingKeyParameters;\n   struct
    {\n       opaque modulus<1..2^16-1>;\n       opaque publicexponent<1..2^8-1>;\n
    \  } RSAPublicKey;\n   struct {\n       opaque point <1..2^8-1>;\n   } TB_ECPoint;\n
    \  struct {\n       TokenBindingKeyParameters key_parameters;\n       uint16 key_length;
    \ /* Length (in bytes) of the following\n                              TokenBindingID.TokenBindingPublicKey
    */\n       select (key_parameters) {\n           case rsa2048_pkcs1.5:\n           case
    rsa2048_pss:\n               RSAPublicKey rsapubkey;\n           case ecdsap256:\n
    \              TB_ECPoint point;\n       } TokenBindingPublicKey;\n   } TokenBindingID;\n
    \  enum {\n       (255)        /* No initial TB_ExtensionType registrations */\n
    \  } TB_ExtensionType;\n   struct {\n       TB_ExtensionType extension_type;\n
    \      opaque extension_data<0..2^16-1>;\n   } TB_Extension;\n   enum {\n       provided_token_binding(0),
    referred_token_binding(1), (255)\n   } TokenBindingType;\n   struct {\n       TokenBindingType
    tokenbinding_type;\n       TokenBindingID tokenbindingid;\n       opaque signature<64..2^16-1>;
    /* Signature over the concatenation\n                                        of
    tokenbinding_type,\n                                        key_parameters, and
    EKM */\n       TB_Extension extensions<0..2^16-1>;\n   } TokenBinding;\n   struct
    {\n       TokenBinding tokenbindings<132..2^16-1>;\n   } TokenBindingMessage;\n
    \  The Token Binding message consists of a series of TokenBinding\n   structures,
    each containing the type of the Token Binding, the\n   TokenBindingID, and a signature
    using the Token Binding key,\n   optionally followed by TB_Extension structures.\n"
  - contents:
    - "3.1.  TokenBinding.tokenbinding_type\n   This document defines two Token Binding
      types:\n   o  provided_token_binding - used to establish a Token Binding when\n
      \     connecting to a server.\n   o  referred_token_binding - used when requesting
      tokens that are\n      intended to be presented to a different server.\n   [RFC8473]
      describes a use case for referred_token_binding where Token\n   Bindings are
      established between multiple communicating parties:\n   User Agent, Identity
      Provider, and Relying Party.  The User Agent\n   sends referred_token_binding
      to the Identity Provider in order to\n   prove possession of the Token Binding
      key it uses with the Relying\n   Party.  The Identity Provider can then bind
      the token it is supplying\n   (for presentation to the Relying Party) to the
      Token Binding ID\n   contained in referred_token_binding.\n   An implementation
      MUST ignore any unknown Token Binding types.\n"
    title: 3.1.  TokenBinding.tokenbinding_type
  - contents:
    - "3.2.  TokenBinding.tokenbindingid\n   The ID of the Token Binding established
      as a result of Token Binding\n   message processing contains the identifier
      of the negotiated key\n   parameters, the length (in bytes) of the Token Binding
      public key,\n   and the Token Binding public key itself.  The Token Binding
      ID can be\n   obtained from the TokenBinding structure by discarding the Token\n
      \  Binding type, signature, and extensions.\n   When rsa2048_pkcs1.5 or rsa2048_pss
      is used, RSAPublicKey.modulus and\n   RSAPublicKey.publicexponent contain the
      modulus and exponent of a\n   2048-bit RSA public key represented in big-endian
      format, with\n   leading zero bytes omitted.\n   When ecdsap256 is used, TB_ECPoint.point
      contains the X coordinate\n   followed by the Y coordinate of a Curve P-256
      key.  The X and Y\n   coordinates are unsigned 32-byte integers encoded in big-endian\n
      \  format, preserving any leading zero bytes.  Future specifications may\n   define
      Token Binding keys using other elliptic curves with their\n   corresponding
      signature and point formats.\n   Token Binding protocol implementations SHOULD
      make Token Binding IDs\n   available to the application as opaque byte sequences,
      so that\n   applications do not rely on a particular Token Binding ID structure.\n
      \  For example, server applications will use Token Binding IDs when\n   generating
      and verifying bound tokens.\n"
    title: 3.2.  TokenBinding.tokenbindingid
  - contents:
    - "3.3.  TokenBinding.signature\n   When rsa2048_pkcs1.5 is used, TokenBinding.signature
      contains the\n   signature generated using the RSASSA-PKCS1-v1_5 signature scheme\n
      \  defined in [RFC8017] with SHA256 [FIPS.180-4.2015] as the hash\n   function.\n
      \  When rsa2048_pss is used, TokenBinding.signature contains the\n   signature
      generated using the RSA Probabilistic Signature Scheme\n   (RSASSA-PSS) defined
      in [RFC8017] with SHA256 as the hash function.\n   MGF1 with SHA256 MUST be
      used as the mask generation function (MGF),\n   and the salt length MUST equal
      32 bytes.\n   When ecdsap256 is used, TokenBinding.signature contains a pair
      of\n   32-byte integers, R followed by S, generated with the Elliptic Curve\n
      \  Digital Signature Algorithm (ECDSA) using Curve P-256 and SHA256 as\n   defined
      in [FIPS.186-4.2013] and [ANSI.X9-62.2005].  R and S are\n   encoded in big-endian
      format, preserving any leading zero bytes.\n   The signature is computed over
      the byte string representing the\n   concatenation of:\n   o  The TokenBindingType
      value contained in the\n      TokenBinding.tokenbinding_type field,\n   o  The
      TokenBindingKeyParameters value contained in the\n      TokenBindingID.key_parameters
      field, and\n   o  The EKM value obtained from the current TLS connection.\n
      \  Please note that TLS 1.2 and earlier versions support renegotiation,\n   which
      produces a new TLS master secret for the same connection, with\n   the associated
      session keys and EKM value.  TokenBinding.signature\n   MUST be a signature
      of the EKM value derived from the TLS master\n   secret that produced the session
      keys encrypting the TLS\n   application_data record(s) containing this TokenBinding.
      \ Such use of\n   the current EKM for the TLS connection makes replay of bound
      tokens\n   within renegotiated TLS sessions detectable but requires the\n   application
      to synchronize Token Binding message generation and\n   verification with the
      TLS handshake state.\n   Specifications defining the use of Token Binding with
      application\n   protocols, such as Token Binding over HTTP [RFC8473], MAY prohibit\n
      \  the use of TLS renegotiation in combination with Token Binding,\n   obviating
      the need for such synchronization.  Alternatively, such\n   specifications need
      to define (1) a way to determine which EKM value\n   corresponds to a given
      TokenBindingMessage and (2) a mechanism that\n   prevents a TokenBindingMessage
      from being split across TLS\n   renegotiation boundaries due to TLS message
      fragmentation; see\n   Section 6.2.1 of [RFC5246].  Note that application-layer
      messages\n   conveying a TokenBindingMessage may cross renegotiation boundaries
      in\n   ways that make processing difficult.\n   The EKM is obtained using the
      keying material exporters for TLS as\n   defined in [RFC5705], by supplying
      the following input values:\n   o  Label: The ASCII string \"EXPORTER-Token-Binding\"
      with no\n      terminating NUL.\n   o  Context value: No application context
      supplied.\n   o  Length: 32 bytes.\n"
    title: 3.3.  TokenBinding.signature
  - contents:
    - "3.4.  TokenBinding.extensions\n   A Token Binding message may optionally contain
      a series of\n   TB_Extension structures, each consisting of an extension_type
      and\n   extension_data.  The structure and meaning of extension_data depends\n
      \  on the specific extension_type.\n   Initially, no extension types are defined
      (see Section 6.3\n   (\"Token Binding Extensions Registry\")).  One of the possible
      uses of\n   extensions envisioned at the time of this writing is attestation:\n
      \  cryptographic proof that allows the server to verify that the Token\n   Binding
      key is hardware bound.  The definitions of such Token Binding\n   protocol extensions
      are outside the scope of this specification.\n"
    title: 3.4.  TokenBinding.extensions
  title: 3.  Token Binding Protocol Message
- contents:
  - '4.  Establishing a Token Binding

    '
  - contents:
    - "4.1.  Client Processing Rules\n   The client MUST include at least one TokenBinding
      structure in the\n   Token Binding message.  When a provided_token_binding is
      included,\n   the key parameters used in a provided_token_binding MUST match
      those\n   negotiated with the server (e.g., via [RFC8472] or a different\n   mechanism).\n
      \  The client MUST generate and store Token Binding keys in a secure\n   manner
      that prevents key export.  In order to prevent cooperating\n   servers from
      linking user identities, the scope of the Token Binding\n   keys MUST NOT be
      broader than the scope of the tokens, as defined by\n   the application protocol.\n
      \  When the client needs to send a referred_token_binding to the\n   Identity
      Provider, the client SHALL construct the referred\n   TokenBinding structure
      in the following manner:\n   o  Set TokenBinding.tokenbinding_type to referred_token_binding.\n
      \  o  Set TokenBinding.tokenbindingid to the Token Binding ID used with\n      the
      Relying Party.\n   o  Generate TokenBinding.signature, using the EKM value of
      the TLS\n      connection to the Identity Provider, the Token Binding key\n
      \     established with the Relying Party, and the signature algorithm\n      indicated
      by the associated key parameters.  Note that these key\n      parameters may
      differ from the key parameters negotiated with the\n      Identity Provider.\n
      \  Conveying referred Token Bindings in this fashion allows the Identity\n   Provider
      to verify that the client controls the Token Binding key\n   used with the Relying
      Party.\n"
    title: 4.1.  Client Processing Rules
  - contents:
    - "4.2.  Server Processing Rules\n   The triple handshake vulnerability in TLS
      1.2 and older TLS versions\n   affects the security of the Token Binding protocol,
      as described in\n   Section 7 (\"Security Considerations\").  Therefore, the
      server\n   MUST NOT negotiate the use of the Token Binding protocol with these\n
      \  TLS versions, unless the server also negotiates the extended master\n   secret
      TLS extension [RFC7627] and the renegotiation indication TLS\n   extension [RFC5746].\n
      \  If the use of the Token Binding protocol was not negotiated but the\n   client
      sends a Token Binding message, the server MUST reject any\n   contained bindings.\n
      \  If the Token Binding type is \"provided_token_binding\", the server\n   MUST
      verify that the signature algorithm (including an elliptic curve\n   in the
      case of ECDSA) and key length in the Token Binding message\n   match those negotiated
      with this client (e.g., via [RFC8472] or a\n   different mechanism).  In the
      case of a mismatch, the server MUST\n   reject the binding.  Token Bindings
      of type \"referred_token_binding\"\n   may use different key parameters than
      those negotiated with this\n   client.\n   If the Token Binding message does
      not contain at least one\n   TokenBinding structure or if a signature contained
      in any\n   TokenBinding structure is invalid, the server MUST reject the\n   binding.\n
      \  Servers MUST ignore any unknown extensions.  Initially, no extension\n   types
      are defined (see Section 6.3 (\"Token Binding Extensions\n   Registry\")).\n
      \  If all checks defined above have passed successfully, the Token\n   Binding
      between this client and server is established.  The Token\n   Binding ID(s)
      conveyed in the Token Binding message can be provided\n   to the server-side
      application.  The application may then use the\n   Token Binding IDs for bound
      security token creation and validation;\n   see Section 5.\n   If a Token Binding
      is rejected, any associated bound tokens presented\n   on the current TLS connection
      MUST also be rejected by the server.\n   The effect of this is application specific,
      e.g., failing requests, a\n   requirement for the client to re-authenticate
      and present a different\n   token, or connection termination.\n"
    title: 4.2.  Server Processing Rules
  title: 4.  Establishing a Token Binding
- contents:
  - "5.  Bound Security Token Creation and Validation\n   Security tokens can be bound
    to the TLS layer in a variety of ways,\n   e.g., by embedding the Token Binding
    ID or its cryptographic hash in\n   the token or by maintaining a database mapping
    tokens to Token\n   Binding IDs.  The specific method of generating bound security
    tokens\n   is defined by the application and is beyond the scope of this\n   document.
    \ Note that applicable security considerations are outlined\n   in Section 7.\n
    \  Either or both clients and servers MAY create bound security tokens.\n   For
    example, HTTPS servers employing Token Binding for securing their\n   HTTP cookies
    will bind these cookies.  In the case of a server-\n   initiated challenge-response
    protocol employing Token Binding and\n   TLS, the client can, for example, incorporate
    the Token Binding ID\n   within the signed object it returns, thus binding the
    object.\n   Upon receipt of a security token, the server attempts to retrieve\n
    \  Token Binding ID information from the token and from the TLS\n   connection
    with the client.  Application-provided policy determines\n   whether to honor
    non-bound (bearer) tokens.  If the token is bound\n   and a Token Binding has
    not been established for the client\n   connection, the server MUST reject the
    token.  If the Token Binding\n   ID for the token does not match the Token Binding
    ID established for\n   the client connection, the server MUST reject the token.\n"
  title: 5.  Bound Security Token Creation and Validation
- contents:
  - "6.  IANA Considerations\n   This section establishes a new IANA registry titled
    \"Token Binding\n   Protocol\" with subregistries \"Token Binding Key Parameters\",
    \"Token\n   Binding Types\", and \"Token Binding Extensions\".  It also registers
    a\n   new TLS exporter label in the \"TLS Exporter Labels\" registry.\n"
  - contents:
    - "6.1.  Token Binding Key Parameters Registry\n   This document establishes a
      subregistry for identifiers of Token\n   Binding key parameters titled \"Token
      Binding Key Parameters\" under\n   the \"Token Binding Protocol\" registry.\n
      \  Entries in this registry require the following fields:\n   o  Value: The
      octet value that identifies a set of Token Binding key\n      parameters (0-255).\n
      \  o  Description: The description of the Token Binding key parameters.\n   o
      \ Reference: A reference to a specification that defines the Token\n      Binding
      key parameters.\n   This registry operates under the \"Specification Required\"
      policy as\n   defined in [RFC8126].  The designated expert will require the\n
      \  inclusion of a reference to a permanent and readily available\n   specification
      that enables the creation of interoperable\n   implementations using the identified
      set of Token Binding key\n   parameters.\n   An initial set of registrations
      for this registry follows:\n      Value: 0\n      Description: rsa2048_pkcs1.5\n
      \     Specification: This document\n      Value: 1\n      Description: rsa2048_pss\n
      \     Specification: This document\n      Value: 2\n      Description: ecdsap256\n
      \     Specification: This document\n"
    title: 6.1.  Token Binding Key Parameters Registry
  - contents:
    - "6.2.  Token Binding Types Registry\n   This document establishes a subregistry
      for Token Binding type\n   identifiers titled \"Token Binding Types\" under
      the \"Token Binding\n   Protocol\" registry.\n   Entries in this registry require
      the following fields:\n   o  Value: The octet value that identifies the Token
      Binding type\n      (0-255).\n   o  Description: The description of the Token
      Binding type.\n   o  Reference: A reference to a specification that defines
      the Token\n      Binding type.\n   This registry operates under the \"Specification
      Required\" policy as\n   defined in [RFC8126].  The designated expert will require
      the\n   inclusion of a reference to a permanent and readily available\n   specification
      that enables the creation of interoperable\n   implementations using the identified
      Token Binding type.\n   An initial set of registrations for this registry follows:\n
      \     Value: 0\n      Description: provided_token_binding\n      Specification:
      This document\n      Value: 1\n      Description: referred_token_binding\n      Specification:
      This document\n"
    title: 6.2.  Token Binding Types Registry
  - contents:
    - "6.3.  Token Binding Extensions Registry\n   This document establishes a subregistry
      for Token Binding extensions\n   titled \"Token Binding Extensions\" under the
      \"Token Binding Protocol\"\n   registry.\n   Entries in this registry require
      the following fields:\n   o  Value: The octet value that identifies the Token
      Binding extension\n      (0-255).\n   o  Description: The description of the
      Token Binding extension.\n   o  Reference: A reference to a specification that
      defines the Token\n      Binding extension.\n   This registry operates under
      the \"Specification Required\" policy as\n   defined in [RFC8126].  The designated
      expert will require the\n   inclusion of a reference to a permanent and readily
      available\n   specification that enables the creation of interoperable\n   implementations
      using the identified Token Binding extension.  This\n   document creates no
      initial registrations in the \"Token Binding\n   Extensions\" registry.\n"
    title: 6.3.  Token Binding Extensions Registry
  - contents:
    - "6.4.  Registration of Token Binding TLS Exporter Label\n   This document adds
      the following registration in the \"TLS Exporter\n   Labels\" registry:\n      Value:
      EXPORTER-Token-Binding\n      DTLS-OK: Y\n      Recommended: Y\n      Reference:
      This document\n"
    title: 6.4.  Registration of Token Binding TLS Exporter Label
  title: 6.  IANA Considerations
- contents:
  - '7.  Security Considerations

    '
  - contents:
    - "7.1.  Security Token Replay\n   The goal of the Token Binding protocol is to
      prevent attackers from\n   exporting and replaying security tokens and from
      thereby\n   impersonating legitimate users and gaining access to protected\n
      \  resources.  Bound tokens can be replayed by malware present in\n   User Agents;
      this may be undetectable to a server.  However, in order\n   to export bound
      tokens to other machines and successfully replay\n   them, attackers also need
      to export corresponding Token Binding\n   private keys.  Token Binding private
      keys are therefore high-value\n   assets and SHOULD be strongly protected, ideally
      by generating them\n   in a hardware security module that prevents key export.\n
      \  The manner in which a token is bound to the TLS layer is defined by\n   the
      application and is beyond the scope of this document.  However,\n   the resulting
      bound token needs to be integrity-protected, so that an\n   attacker cannot
      remove the binding or substitute a Token Binding ID\n   of their choice without
      detection.\n   The Token Binding protocol does not prevent cooperating clients
      from\n   sharing a bound token.  A client could intentionally export a bound\n
      \  token with the corresponding Token Binding private key or perform\n   signatures
      using this key on behalf of another client.\n"
    title: 7.1.  Security Token Replay
  - contents:
    - "7.2.  Downgrade Attacks\n   The Token Binding protocol MUST be negotiated using
      a mechanism that\n   prevents downgrade attacks.  For example, [RFC8472] specifies
      a TLS\n   extension for Token Binding negotiation.  TLS detects handshake\n
      \  message modification by active attackers; therefore, it is not\n   possible
      for an attacker to remove or modify the \"token_binding\"\n   extension without
      breaking the TLS handshake.  The signature\n   algorithm and key length used
      in the TokenBinding of type\n   \"provided_token_binding\" MUST match the negotiated
      parameters.\n"
    title: 7.2.  Downgrade Attacks
  - contents:
    - "7.3.  Token Binding Key-Sharing between Applications\n   Existing systems provide
      a variety of platform-specific mechanisms\n   for certain applications to share
      tokens, e.g., to enable \"single\n   sign-on\" scenarios.  For these scenarios
      to keep working with bound\n   tokens, the applications that are allowed to
      share tokens will need\n   to also share Token Binding keys.  Care must be taken
      to restrict the\n   sharing of Token Binding keys to the same group(s) of applications\n
      \  that shares the same tokens.\n"
    title: 7.3.  Token Binding Key-Sharing between Applications
  - contents:
    - "7.4.  Triple Handshake Vulnerability in TLS 1.2 and Older TLS Versions\n   The
      Token Binding protocol relies on the TLS exporters [RFC5705] to\n   associate
      a TLS connection with a Token Binding.  The triple\n   handshake attack [TRIPLE-HS]
      is a known vulnerability in TLS 1.2 and\n   older TLS versions, allowing the
      attacker to synchronize keying\n   material between TLS connections.  The attacker
      can then successfully\n   replay bound tokens.  For this reason, the Token Binding
      protocol\n   MUST NOT be negotiated with these TLS versions, unless the extended\n
      \  master secret TLS extension [RFC7627] and the renegotiation\n   indication
      TLS extension [RFC5746] have also been negotiated.\n"
    title: 7.4.  Triple Handshake Vulnerability in TLS 1.2 and Older TLS Versions
  title: 7.  Security Considerations
- contents:
  - "8.  Privacy Considerations\n   The Token Binding protocol uses persistent, long-lived
    Token Binding\n   IDs.  To protect privacy, Token Binding IDs are never transmitted
    in\n   clear text and can be reset by the user at any time, e.g., when\n   clearing
    browser cookies.  Some applications offer a special privacy\n   mode where they
    don't store or use tokens supplied by the server,\n   e.g., \"in private\" browsing.
    \ When operating in this special privacy\n   mode, applications SHOULD use newly
    generated Token Binding keys and\n   delete them when exiting this mode; otherwise,
    they SHOULD NOT\n   negotiate Token Binding at all.\n   In order to prevent cooperating
    servers from linking user identities,\n   the scope of the Token Binding keys
    MUST NOT be broader than the\n   scope of the tokens, as defined by the application
    protocol.\n   A server can use tokens and Token Binding IDs to track clients.\n
    \  Client applications that automatically limit the lifetime or scope of\n   tokens
    to maintain user privacy SHOULD apply the same validity time\n   and scope limits
    to Token Binding keys.\n"
  title: 8.  Privacy Considerations
- contents:
  - '9.  References

    '
  - contents:
    - "9.1.  Normative References\n   [ANSI.X9-62.2005]\n              American National
      Standards Institute, \"Public Key\n              Cryptography for the Financial
      Services Industry: The\n              Elliptic Curve Digital Signature Algorithm
      (ECDSA)\",\n              ANSI X9.62, November 2005.\n   [FIPS.180-4.2015]\n
      \             National Institute of Standards and Technology, \"Secure\n              Hash
      Standard (SHS)\", FIPS 180-4,\n              DOI 10.6028/NIST.FIPS.180-4, August
      2015,\n              <https://nvlpubs.nist.gov/nistpubs/FIPS/\n              NIST.FIPS.180-4.pdf>.\n
      \  [FIPS.186-4.2013]\n              National Institute of Standards and Technology,
      \"Digital\n              Signature Standard (DSS)\", FIPS 186-4,\n              DOI
      10.6028/NIST.FIPS.186-4, July 2013,\n              <https://nvlpubs.nist.gov/nistpubs/fips/\n
      \             nist.fips.186-4.pdf>.\n   [RFC2119]  Bradner, S., \"Key words
      for use in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC
      2119,\n              DOI 10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n
      \  [RFC5246]  Dierks, T. and E. Rescorla, \"The Transport Layer Security\n              (TLS)
      Protocol Version 1.2\", RFC 5246,\n              DOI 10.17487/RFC5246, August
      2008,\n              <https://www.rfc-editor.org/info/rfc5246>.\n   [RFC5705]
      \ Rescorla, E., \"Keying Material Exporters for Transport\n              Layer
      Security (TLS)\", RFC 5705, DOI 10.17487/RFC5705,\n              March 2010,
      <https://www.rfc-editor.org/info/rfc5705>.\n   [RFC5746]  Rescorla, E., Ray,
      M., Dispensa, S., and N. Oskov,\n              \"Transport Layer Security (TLS)
      Renegotiation Indication\n              Extension\", RFC 5746, DOI 10.17487/RFC5746,
      February 2010,\n              <https://www.rfc-editor.org/info/rfc5746>.\n   [RFC7230]
      \ Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer\n              Protocol
      (HTTP/1.1): Message Syntax and Routing\",\n              RFC 7230, DOI 10.17487/RFC7230,
      June 2014,\n              <https://www.rfc-editor.org/info/rfc7230>.\n   [RFC7540]
      \ Belshe, M., Peon, R., and M. Thomson, Ed., \"Hypertext\n              Transfer
      Protocol Version 2 (HTTP/2)\", RFC 7540,\n              DOI 10.17487/RFC7540,
      May 2015,\n              <https://www.rfc-editor.org/info/rfc7540>.\n   [RFC7627]
      \ Bhargavan, K., Ed., Delignat-Lavaud, A., Pironti, A.,\n              Langley,
      A., and M. Ray, \"Transport Layer Security (TLS)\n              Session Hash
      and Extended Master Secret Extension\",\n              RFC 7627, DOI 10.17487/RFC7627,
      September 2015,\n              <https://www.rfc-editor.org/info/rfc7627>.\n
      \  [RFC8126]  Cotton, M., Leiba, B., and T. Narten, \"Guidelines for\n              Writing
      an IANA Considerations Section in RFCs\", BCP 26,\n              RFC 8126, DOI
      10.17487/RFC8126, June 2017,\n              <https://www.rfc-editor.org/info/rfc8126>.\n
      \  [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n              2119
      Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n              May 2017,
      <https://www.rfc-editor.org/info/rfc8174>.\n   [RFC8472]  Popov, A., Ed., Nystroem,
      M., and D. Balfanz, \"Transport\n              Layer Security (TLS) Extension
      for Token Binding Protocol\n              Negotiation\", RFC 8472, DOI 10.17487/RFC8472,
      October\n              2018, <https://www.rfc-editor.org/info/rfc8472>.\n   [RFC8473]
      \ Popov, A., Nystroem, M., Balfanz, D., Ed., Harper, N., and\n              J.
      Hodges, \"Token Binding over HTTP\", RFC 8473,\n              DOI 10.17487/RFC8473,
      October 2018,\n              <https://www.rfc-editor.org/info/rfc8473>.\n"
    title: 9.1.  Normative References
  - contents:
    - "9.2.  Informative References\n   [RFC6749]  Hardt, D., Ed., \"The OAuth 2.0
      Authorization Framework\",\n              RFC 6749, DOI 10.17487/RFC6749, October
      2012,\n              <https://www.rfc-editor.org/info/rfc6749>.\n   [RFC8017]
      \ Moriarty, K., Ed., Kaliski, B., Jonsson, J., and A. Rusch,\n              \"PKCS
      #1: RSA Cryptography Specifications Version 2.2\",\n              RFC 8017,
      DOI 10.17487/RFC8017, November 2016,\n              <https://www.rfc-editor.org/info/rfc8017>.\n
      \  [TOKENBIND-TLS13]\n              Harper, N., \"Token Binding for Transport
      Layer Security\n              (TLS) Version 1.3 Connections\", Work in Progress,\n
      \             draft-ietf-tokbind-tls13-01, May 2018.\n   [TRIPLE-HS]\n              Bhargavan,
      K., Delignat-Lavaud, A., Fournet, C., Pironti,\n              A., and P. Strub,
      \"Triple Handshakes and Cookie Cutters:\n              Breaking and Fixing Authentication
      over TLS\",\n              IEEE Symposium on Security and Privacy,\n              DOI
      10.1109/SP.2014.14, May 2014.\n"
    title: 9.2.  Informative References
  title: 9.  References
- contents:
  - "Acknowledgements\n   This document incorporates comments and suggestions offered
    by Eric\n   Rescorla, Gabriel Montenegro, Martin Thomson, Vinod Anupam, Anthony\n
    \  Nadalin, Michael B. Jones, Bill Cox, Nick Harper, Brian Campbell,\n   Benjamin
    Kaduk, Alexey Melnikov, and others.\n   This document was produced under the chairmanship
    of John Bradley and\n   Leif Johansson.  The area directors included Eric Rescorla,
    Kathleen\n   Moriarty, and Stephen Farrell.\n"
  title: Acknowledgements
- contents:
  - "Authors' Addresses\n   Andrei Popov (editor)\n   Microsoft Corp.\n   United States
    of America\n   Email: andreipo@microsoft.com\n   Magnus Nystroem\n   Microsoft
    Corp.\n   United States of America\n   Email: mnystrom@microsoft.com\n   Dirk
    Balfanz\n   Google Inc.\n   United States of America\n   Email: balfanz@google.com\n
    \  Jeff Hodges\n   Kings Mountain Systems\n   United States of America\n   Email:
    Jeff.Hodges@KingsMountain.com\n"
  title: Authors' Addresses
