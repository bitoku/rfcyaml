- contents:
  - '    Internationalized Domain Names in Applications (IDNA): Protocol

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This document is the revised protocol definition for\n   Internationalized
    Domain Names (IDNs).  The rationale for changes,\n   the relationship to the older
    specification, and important\n   terminology are provided in other documents.
    \ This document specifies\n   the protocol mechanism, called Internationalized
    Domain Names in\n   Applications (IDNA), for registering and looking up IDNs in
    a way\n   that does not require changes to the DNS itself.  IDNA is only meant\n
    \  for processing domain names, not free text.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc5891.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2010 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n   This document may contain
    material from IETF Documents or IETF\n   Contributions published or made publicly
    available before November\n   10, 2008.  The person(s) controlling the copyright
    in some of this\n   material may not have granted the IETF Trust the right to
    allow\n   modifications of such material outside the IETF Standards Process.\n
    \  Without obtaining an adequate license from the person(s) controlling\n   the
    copyright in such materials, this document may not be modified\n   outside the
    IETF Standards Process, and derivative works of it may\n   not be created outside
    the IETF Standards Process, except to format\n   it for publication as an RFC
    or to translate it into languages other\n   than English.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .
    . . . . . .  4\n   2.  Terminology  . . . . . . . . . . . . . . . . . . . . .
    . . . .  4\n   3.  Requirements and Applicability . . . . . . . . . . . . . .
    . .  5\n     3.1.  Requirements . . . . . . . . . . . . . . . . . . . . . . .
    \ 5\n     3.2.  Applicability  . . . . . . . . . . . . . . . . . . . . . .  5\n
    \      3.2.1.  DNS Resource Records . . . . . . . . . . . . . . . . .  6\n       3.2.2.
    \ Non-Domain-Name Data Types Stored in the DNS . . . . .  6\n   4.  Registration
    Protocol  . . . . . . . . . . . . . . . . . . . .  6\n     4.1.  Input to IDNA
    Registration . . . . . . . . . . . . . . . .  7\n     4.2.  Permitted Character
    and Label Validation . . . . . . . . .  7\n       4.2.1.  Input Format . . . .
    . . . . . . . . . . . . . . . . .  7\n       4.2.2.  Rejection of Characters That
    Are Not Permitted . . . .  8\n       4.2.3.  Label Validation . . . . . . . .
    . . . . . . . . . . .  8\n       4.2.4.  Registration Validation Requirements
    . . . . . . . . .  9\n     4.3.  Registry Restrictions  . . . . . . . . . . .
    . . . . . . .  9\n     4.4.  Punycode Conversion  . . . . . . . . . . . . . .
    . . . . .  9\n     4.5.  Insertion in the Zone  . . . . . . . . . . . . . . .
    . . . 10\n   5.  Domain Name Lookup Protocol  . . . . . . . . . . . . . . . .
    . 10\n     5.1.  Label String Input . . . . . . . . . . . . . . . . . . . . 10\n
    \    5.2.  Conversion to Unicode  . . . . . . . . . . . . . . . . . . 10\n     5.3.
    \ A-label Input  . . . . . . . . . . . . . . . . . . . . . . 10\n     5.4.  Validation
    and Character List Testing  . . . . . . . . . . 11\n     5.5.  Punycode Conversion
    \ . . . . . . . . . . . . . . . . . . . 13\n     5.6.  DNS Name Resolution  .
    . . . . . . . . . . . . . . . . . . 13\n   6.  Security Considerations  . . .
    . . . . . . . . . . . . . . . . 13\n   7.  IANA Considerations  . . . . . . .
    . . . . . . . . . . . . . . 13\n   8.  Contributors . . . . . . . . . . . . .
    . . . . . . . . . . . . 13\n   9.  Acknowledgments  . . . . . . . . . . . . .
    . . . . . . . . . . 14\n   10. References . . . . . . . . . . . . . . . . . .
    . . . . . . . . 14\n     10.1. Normative References . . . . . . . . . . . . .
    . . . . . . 14\n     10.2. Informative References . . . . . . . . . . . . . .
    . . . . 15\n   Appendix A.  Summary of Major Changes from IDNA2003  . . . . .
    . . 17\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   This document supplies the protocol definition for Internationalized\n
    \  Domain Names in Applications (IDNA), with the version specified here\n   known
    as IDNA2008.  Essential definitions and terminology for\n   understanding this
    document and a road map of the collection of\n   documents that make up IDNA2008
    appear in a separate Definitions\n   document [RFC5890].  Appendix A discusses
    the relationship between\n   this specification and the earlier version of IDNA
    (referred to here\n   as \"IDNA2003\").  The rationale for these changes, along
    with\n   considerable explanatory material and advice to zone administrators\n
    \  who support IDNs, is provided in another document, known informally\n   in
    this series as the \"Rationale document\" [RFC5894].\n   IDNA works by allowing
    applications to use certain ASCII [ASCII]\n   string labels (beginning with a
    special prefix) to represent\n   non-ASCII name labels.  Lower-layer protocols
    need not be aware of\n   this; therefore, IDNA does not change any infrastructure.
    \ In\n   particular, IDNA does not depend on any changes to DNS servers,\n   resolvers,
    or DNS protocol elements, because the ASCII name service\n   provided by the existing
    DNS can be used for IDNA.\n   IDNA applies only to a specific subset of DNS labels.
    \ The base DNS\n   standards [RFC1034] [RFC1035] and their various updates specify
    how\n   to combine labels into fully-qualified domain names and parse labels\n
    \  out of those names.\n   This document describes two separate protocols, one
    for IDN\n   registration (Section 4) and one for IDN lookup (Section 5).  These\n
    \  two protocols share some terminology, reference data, and operations.\n"
  title: 1.  Introduction
- contents:
  - "2.  Terminology\n   As mentioned above, terminology used as part of the definition
    of\n   IDNA appears in the Definitions document [RFC5890].  It is worth\n   noting
    that some of this terminology overlaps with, and is consistent\n   with, that
    used in Unicode or other character set standards and the\n   DNS.  Readers of
    this document are assumed to be familiar with the\n   associated Definitions document
    and with the DNS-specific terminology\n   in RFC 1034 [RFC1034].\n   The key words
    \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\",
    \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document
    are to be interpreted as described in BCP 14, RFC 2119\n   [RFC2119].\n"
  title: 2.  Terminology
- contents:
  - '3.  Requirements and Applicability

    '
  - contents:
    - "3.1.  Requirements\n   IDNA makes the following requirements:\n   1.  Whenever
      a domain name is put into a domain name slot that is not\n       IDNA-aware
      (see Section 2.3.2.6 of the Definitions document\n       [RFC5890]), it MUST
      contain only ASCII characters (i.e., its\n       labels must be either A-labels
      or NR-LDH labels), unless the DNS\n       application is not subject to historical
      recommendations for\n       \"hostname\"-style names (see RFC 1034 [RFC1034]
      and\n       Section 3.2.1).\n   2.  Labels MUST be compared using equivalent
      forms: either both\n       A-label forms or both U-label forms.  Because A-labels
      and\n       U-labels can be transformed into each other without loss of\n       information,
      these comparisons are equivalent (however, in\n       practice, comparison of
      U-labels requires first verifying that\n       they actually are U-labels and
      not just Unicode strings).  A pair\n       of A-labels MUST be compared as case-insensitive
      ASCII (as with\n       all comparisons of ASCII DNS labels).  U-labels MUST
      be compared\n       as-is, without case folding or other intermediate steps.
      \ While\n       it is not necessary to validate labels in order to compare them,\n
      \      successful comparison does not imply validity.  In many cases,\n       not
      limited to comparison, validation may be important for other\n       reasons
      and SHOULD be performed.\n   3.  Labels being registered MUST conform to the
      requirements of\n       Section 4.  Labels being looked up and the lookup process
      MUST\n       conform to the requirements of Section 5.\n"
    title: 3.1.  Requirements
  - contents:
    - "3.2.  Applicability\n   IDNA applies to all domain names in all domain name
      slots in\n   protocols except where it is explicitly excluded.  It does not
      apply\n   to domain name slots that do not use the LDH syntax rules as\n   described
      in the Definitions document [RFC5890].\n   Because it uses the DNS, IDNA applies
      to many protocols that were\n   specified before it was designed.  IDNs occupying
      domain name slots\n   in those older protocols MUST be in A-label form until
      and unless\n   those protocols and their implementations are explicitly upgraded
      to\n   be aware of IDNs and to accept the U-label form.  IDNs actually\n   appearing
      in DNS queries or responses MUST be A-labels.\n   IDNA-aware protocols and implementations
      MAY accept U-labels,\n   A-labels, or both as those particular protocols specify.
      \ IDNA is not\n   defined for extended label types (see RFC 2671 [RFC2671],
      Section 3).\n"
    - contents:
      - "3.2.1.  DNS Resource Records\n   IDNA applies only to domain names in the
        NAME and RDATA fields of DNS\n   resource records whose CLASS is IN.  See
        the DNS specification\n   [RFC1035] for precise definitions of these terms.\n
        \  The application of IDNA to DNS resource records depends entirely on\n   the
        CLASS of the record, and not on the TYPE except as noted below.\n   This will
        remain true, even as new TYPEs are defined, unless a new\n   TYPE defines
        TYPE-specific rules.  Special naming conventions for SRV\n   records (and
        \"underscore labels\" more generally) are incompatible\n   with IDNA coding
        as discussed in the Definitions document [RFC5890],\n   especially Section
        2.3.2.3.  Of course, underscore labels may be part\n   of a domain that uses
        IDN labels at higher levels in the tree.\n"
      title: 3.2.1.  DNS Resource Records
    - contents:
      - "3.2.2.  Non-Domain-Name Data Types Stored in the DNS\n   Although IDNA enables
        the representation of non-ASCII characters in\n   domain names, that does
        not imply that IDNA enables the\n   representation of non-ASCII characters
        in other data types that are\n   stored in domain names, specifically in the
        RDATA field for types\n   that have structured RDATA format.  For example,
        an email address\n   local part is stored in a domain name in the RNAME field
        as part of\n   the RDATA of an SOA record (e.g., hostmaster@example.com would
        be\n   represented as hostmaster.example.com).  IDNA does not update the\n
        \  existing email standards, which allow only ASCII characters in local\n
        \  parts.  Even though work is in progress to define\n   internationalization
        for email addresses [RFC4952], changes to the\n   email address part of the
        SOA RDATA would require action in, or\n   updates to, other standards, specifically
        those that specify the\n   format of the SOA RR.\n"
      title: 3.2.2.  Non-Domain-Name Data Types Stored in the DNS
    title: 3.2.  Applicability
  title: 3.  Requirements and Applicability
- contents:
  - "4.  Registration Protocol\n   This section defines the model for registering
    an IDN.  The model is\n   implementation independent; any sequence of steps that
    produces\n   exactly the same result for all labels is considered a valid\n   implementation.\n
    \  Note that, while the registration (this section) and lookup protocols\n   (Section
    5) are very similar in most respects, they are not\n   identical, and implementers
    should carefully follow the steps\n   described in this specification.\n"
  - contents:
    - "4.1.  Input to IDNA Registration\n   Registration processes, especially processing
      by entities (often\n   called \"registrars\") who deal with registrants before
      the request\n   actually reaches the zone manager (\"registry\") are outside
      the scope\n   of this definition and may differ significantly depending on local\n
      \  needs.  By the time a string enters the IDNA registration process as\n   described
      in this specification, it MUST be in Unicode and in\n   Normalization Form C
      (NFC [Unicode-UAX15]).  Entities responsible for\n   zone files (\"registries\")
      MUST accept only the exact string for which\n   registration is requested, free
      of any mappings or local adjustments.\n   They MAY accept that input in any
      of three forms:\n   1.  As a pair of A-label and U-label.\n   2.  As an A-label
      only.\n   3.  As a U-label only.\n   The first two of these forms are RECOMMENDED
      because the use of\n   A-labels avoids any possibility of ambiguity.  The first
      is normally\n   preferred over the second because it permits further verification
      of\n   user intent (see Section 4.2.1).\n"
    title: 4.1.  Input to IDNA Registration
  - contents:
    - '4.2.  Permitted Character and Label Validation

      '
    - contents:
      - "4.2.1.  Input Format\n   If both the U-label and A-label forms are available,
        the registry\n   MUST ensure that the A-label form is in lowercase, perform
        a\n   conversion to a U-label, perform the steps and tests described below\n
        \  on that U-label, and then verify that the A-label produced by the\n   step
        in Section 4.4 matches the one provided as input.  In addition,\n   the U-label
        that was provided as input and the one obtained by\n   conversion of the A-label
        MUST match exactly.  If, for some reason,\n   these tests fail, the registration
        MUST be rejected.\n   If only an A-label was provided and the conversion to
        a U-label is\n   not performed, the registry MUST still verify that the A-label
        is\n   superficially valid, i.e., that it does not violate any of the rules\n
        \  of Punycode encoding [RFC3492] such as the prohibition on trailing\n   hyphen-minus,
        the requirement that all characters be ASCII, and so\n   on.  Strings that
        appear to be A-labels (e.g., they start with\n   \"xn--\") and strings that
        are supplied to the registry in a context\n   reserved for A-labels (such
        as a field in a form to be filled out),\n   but that are not valid A-labels
        as described in this paragraph, MUST\n   NOT be placed in DNS zones that support
        IDNA.\n   If only an A-label is provided, the conversion to a U-label is not\n
        \  performed, but the superficial tests described in the previous\n   paragraph
        are performed, registration procedures MAY, and usually\n   will, bypass the
        tests and actions in the balance of Section 4.2 and\n   in Sections 4.3 and
        4.4.\n"
      title: 4.2.1.  Input Format
    - contents:
      - "4.2.2.  Rejection of Characters That Are Not Permitted\n   The candidate
        Unicode string MUST NOT contain characters that appear\n   in the \"DISALLOWED\"
        and \"UNASSIGNED\" lists specified in the Tables\n   document [RFC5892].\n"
      title: 4.2.2.  Rejection of Characters That Are Not Permitted
    - contents:
      - "4.2.3.  Label Validation\n   The proposed label (in the form of a Unicode
        string, i.e., a string\n   that at least superficially appears to be a U-label)
        is then examined\n   using tests that require examination of more than one
        character.\n   Character order is considered to be the on-the-wire order.
        \ That\n   order may not be the same as the display order.\n"
      - contents:
        - "4.2.3.1.  Hyphen Restrictions\n   The Unicode string MUST NOT contain \"--\"
          (two consecutive hyphens) in\n   the third and fourth character positions
          and MUST NOT start or end\n   with a \"-\" (hyphen).\n"
        title: 4.2.3.1.  Hyphen Restrictions
      - contents:
        - "4.2.3.2.  Leading Combining Marks\n   The Unicode string MUST NOT begin
          with a combining mark or combining\n   character (see The Unicode Standard,
          Section 2.11 [Unicode] for an\n   exact definition).\n"
        title: 4.2.3.2.  Leading Combining Marks
      - contents:
        - "4.2.3.3.  Contextual Rules\n   The Unicode string MUST NOT contain any
          characters whose validity is\n   context-dependent, unless the validity
          is positively confirmed by a\n   contextual rule.  To check this, each code
          point identified as\n   CONTEXTJ or CONTEXTO in the Tables document [RFC5892]
          MUST have a\n   non-null rule.  If such a code point is missing a rule,
          the label is\n   invalid.  If the rule exists but the result of applying
          the rule is\n   negative or inconclusive, the proposed label is invalid.\n"
        title: 4.2.3.3.  Contextual Rules
      - contents:
        - "4.2.3.4.  Labels Containing Characters Written Right to Left\n   If the
          proposed label contains any characters from scripts that are\n   written
          from right to left, it MUST meet the Bidi criteria [RFC5893].\n"
        title: 4.2.3.4.  Labels Containing Characters Written Right to Left
      title: 4.2.3.  Label Validation
    - contents:
      - "4.2.4.  Registration Validation Requirements\n   Strings that contain at
        least one non-ASCII character, have been\n   produced by the steps above,
        whose contents pass all of the tests in\n   Section 4.2.3, and are 63 or fewer
        characters long in\n   ASCII-compatible encoding (ACE) form (see Section 4.4),
        are U-labels.\n   To summarize, tests are made in Section 4.2 for invalid
        characters,\n   invalid combinations of characters, for labels that are invalid
        even\n   if the characters they contain are valid individually, and for labels\n
        \  that do not conform to the restrictions for strings containing\n   right-to-left
        characters.\n"
      title: 4.2.4.  Registration Validation Requirements
    title: 4.2.  Permitted Character and Label Validation
  - contents:
    - "4.3.  Registry Restrictions\n   In addition to the rules and tests above, there
      are many reasons why\n   a registry could reject a label.  Registries at all
      levels of the\n   DNS, not just the top level, are expected to establish policies
      about\n   label registrations.  Policies are likely to be informed by the local\n
      \  languages and the scripts that are used to write them and may depend\n   on
      many factors including what characters are in the label (for\n   example, a
      label may be rejected based on other labels already\n   registered).  See the
      Rationale document [RFC5894], Section 3.2, for\n   further discussion and recommendations
      about registry policies.\n   The string produced by the steps in Section 4.2
      is checked and\n   processed as appropriate to local registry restrictions.
      \ Application\n   of those registry restrictions may result in the rejection
      of some\n   labels or the application of special restrictions to others.\n"
    title: 4.3.  Registry Restrictions
  - contents:
    - "4.4.  Punycode Conversion\n   The resulting U-label is converted to an A-label
      (defined in Section\n   2.3.2.1 of the Definitions document [RFC5890]).  The
      A-label is the\n   encoding of the U-label according to the Punycode algorithm
      [RFC3492]\n   with the ACE prefix \"xn--\" added at the beginning of the string.
      \ The\n   resulting string must, of course, conform to the length limits\n   imposed
      by the DNS.  This document does not update or alter the\n   Punycode algorithm
      specified in RFC 3492 in any way.  RFC 3492 does\n   make a non-normative reference
      to the information about the value and\n   construction of the ACE prefix that
      appears in RFC 3490 or Nameprep\n   [RFC3491].  For consistency and reader convenience,
      IDNA2008\n   effectively updates that reference to point to this document.  That\n
      \  change does not alter the prefix itself.  The prefix, \"xn--\", is the\n
      \  same in both sets of documents.\n   With the exception of the maximum string
      length test on Punycode\n   output, the failure conditions identified in the
      Punycode encoding\n   procedure cannot occur if the input is a U-label as determined
      by the\n   steps in Sections 4.1 through 4.3 above.\n"
    title: 4.4.  Punycode Conversion
  - contents:
    - "4.5.  Insertion in the Zone\n   The label is registered in the DNS by inserting
      the A-label into a\n   zone.\n"
    title: 4.5.  Insertion in the Zone
  title: 4.  Registration Protocol
- contents:
  - "5.  Domain Name Lookup Protocol\n   Lookup is different from registration and
    different tests are applied\n   on the client.  Although some validity checks
    are necessary to avoid\n   serious problems with the protocol, the lookup-side
    tests are more\n   permissive and rely on the assumption that names that are present
    in\n   the DNS are valid.  That assumption is, however, a weak one because\n   the
    presence of wildcards in the DNS might cause a string that is not\n   actually
    registered in the DNS to be successfully looked up.\n"
  - contents:
    - "5.1.  Label String Input\n   The user supplies a string in the local character
      set, for example,\n   by typing it, clicking on it, or copying and pasting it
      from a\n   resource identifier, e.g., a Uniform Resource Identifier (URI)\n
      \  [RFC3986] or an Internationalized Resource Identifier (IRI)\n   [RFC3987],
      from which the domain name is extracted.  Alternately,\n   some process not
      directly involving the user may read the string from\n   a file or obtain it
      in some other way.  Processing in this step and\n   the one specified in Section
      5.2 are local matters, to be\n   accomplished prior to actual invocation of
      IDNA.\n"
    title: 5.1.  Label String Input
  - contents:
    - "5.2.  Conversion to Unicode\n   The string is converted from the local character
      set into Unicode, if\n   it is not already in Unicode.  Depending on local needs,
      this\n   conversion may involve mapping some characters into other characters\n
      \  as well as coding conversions.  Those issues are discussed in the\n   mapping-related
      sections (Sections 4.2, 4.4, 6, and 7.3) of the\n   Rationale document [RFC5894]
      and in the separate Mapping document\n   [IDNA2008-Mapping].  The result MUST
      be a Unicode string in NFC form.\n"
    title: 5.2.  Conversion to Unicode
  - contents:
    - "5.3.  A-label Input\n   If the input to this procedure appears to be an A-label
      (i.e., it\n   starts in \"xn--\", interpreted case-insensitively), the lookup\n
      \  application MAY attempt to convert it to a U-label, first ensuring\n   that
      the A-label is entirely in lowercase (converting it to lowercase\n   if necessary),
      and apply the tests of Section 5.4 and the conversion\n   of Section 5.5 to
      that form.  If the label is converted to Unicode\n   (i.e., to U-label form)
      using the Punycode decoding algorithm, then\n   the processing specified in
      those two sections MUST be performed, and\n   the label MUST be rejected if
      the resulting label is not identical to\n   the original.  See Section 8.1 of
      the Rationale document [RFC5894]\n   for additional discussion on this topic.\n
      \  Conversion from the A-label and testing that the result is a U-label\n   SHOULD
      be performed if the domain name will later be presented to the\n   user in native
      character form (this requires that the lookup\n   application be IDNA-aware).
      \ If those steps are not performed, the\n   lookup process SHOULD at least test
      to determine that the string is\n   actually an A-label, examining it for the
      invalid formats specified\n   in the Punycode decoding specification.  Applications
      that are not\n   IDNA-aware will obviously omit that testing; others MAY treat
      the\n   string as opaque to avoid the additional processing at the expense of\n
      \  providing less protection and information to users.\n"
    title: 5.3.  A-label Input
  - contents:
    - "5.4.  Validation and Character List Testing\n   As with the registration procedure
      described in Section 4, the\n   Unicode string is checked to verify that all
      characters that appear\n   in it are valid as input to IDNA lookup processing.
      \ As discussed\n   above and in the Rationale document [RFC5894], the lookup
      check is\n   more liberal than the registration one.  Labels that have not been\n
      \  fully evaluated for conformance to the applicable rules are referred\n   to
      as \"putative\" labels as discussed in Section 2.3.2.1 of the\n   Definitions
      document [RFC5890].  Putative U-labels with any of the\n   following characteristics
      MUST be rejected prior to DNS lookup:\n   o  Labels that are not in NFC [Unicode-UAX15].\n
      \  o  Labels containing \"--\" (two consecutive hyphens) in the third and\n
      \     fourth character positions.\n   o  Labels whose first character is a combining
      mark (see The Unicode\n      Standard, Section 2.11 [Unicode]).\n   o  Labels
      containing prohibited code points, i.e., those that are\n      assigned to the
      \"DISALLOWED\" category of the Tables document\n      [RFC5892].\n   o  Labels
      containing code points that are identified in the Tables\n      document as
      \"CONTEXTJ\", i.e., requiring exceptional contextual\n      rule processing
      on lookup, but that do not conform to those rules.\n      Note that this implies
      that a rule must be defined, not null: a\n      character that requires a contextual
      rule but for which the rule\n      is null is treated in this step as having
      failed to conform to the\n      rule.\n   o  Labels containing code points that
      are identified in the Tables\n      document as \"CONTEXTO\", but for which
      no such rule appears in the\n      table of rules.  Applications resolving DNS
      names or carrying out\n      equivalent operations are not required to test
      contextual rules\n      for \"CONTEXTO\" characters, only to verify that a rule
      is defined\n      (although they MAY make such tests to provide better protection
      or\n      give better information to the user).\n   o  Labels containing code
      points that are unassigned in the version\n      of Unicode being used by the
      application, i.e., in the UNASSIGNED\n      category of the Tables document.\n
      \     This requirement means that the application must use a list of\n      unassigned
      characters that is matched to the version of Unicode\n      that is being used
      for the other requirements in this section.  It\n      is not required that
      the application know which version of Unicode\n      is being used; that information
      might be part of the operating\n      environment in which the application is
      running.\n   In addition, the application SHOULD apply the following test.\n
      \  o  Verification that the string is compliant with the requirements\n      for
      right-to-left characters specified in the Bidi document\n      [RFC5893].\n
      \  This test may be omitted in special circumstances, such as when the\n   lookup
      application knows that the conditions are enforced elsewhere,\n   because an
      attempt to look up and resolve such strings will almost\n   certainly lead to
      a DNS lookup failure except when wildcards are\n   present in the zone.  However,
      applying the test is likely to give\n   much better information about the reason
      for a lookup failure --\n   information that may be usefully passed to the user
      when that is\n   feasible -- than DNS resolution failure information alone.\n
      \  For all other strings, the lookup application MUST rely on the\n   presence
      or absence of labels in the DNS to determine the validity of\n   those labels
      and the validity of the characters they contain.  If\n   they are registered,
      they are presumed to be valid; if they are not,\n   their possible validity
      is not relevant.  While a lookup application\n   may reasonably issue warnings
      about strings it believes may be\n   problematic, applications that decline
      to process a string that\n   conforms to the rules above (i.e., does not look
      it up in the DNS)\n   are not in conformance with this protocol.\n"
    title: 5.4.  Validation and Character List Testing
  - contents:
    - "5.5.  Punycode Conversion\n   The string that has now been validated for lookup
      is converted to ACE\n   form by applying the Punycode algorithm to the string
      and then adding\n   the ACE prefix (\"xn--\").\n"
    title: 5.5.  Punycode Conversion
  - contents:
    - "5.6.  DNS Name Resolution\n   The A-label resulting from the conversion in
      Section 5.5 or supplied\n   directly (see Section 5.3) is combined with other
      labels as needed to\n   form a fully-qualified domain name that is then looked
      up in the DNS,\n   using normal DNS resolver procedures.  The lookup can obviously\n
      \  either succeed (returning information) or fail.\n"
    title: 5.6.  DNS Name Resolution
  title: 5.  Domain Name Lookup Protocol
- contents:
  - "6.  Security Considerations\n   Security Considerations for this version of IDNA
    are described in the\n   Definitions document [RFC5890], except for the special
    issues\n   associated with right-to-left scripts and characters.  The latter are\n
    \  discussed in the Bidi document [RFC5893].\n   In order to avoid intentional
    or accidental attacks from labels that\n   might be confused with others, special
    problems in rendering, and so\n   on, the IDNA model requires that registries
    exercise care and\n   thoughtfulness about what labels they choose to permit.
    \ That issue\n   is discussed in Section 4.3 of this document which, in turn,
    points\n   to a somewhat more extensive discussion in the Rationale document\n
    \  [RFC5894].\n"
  title: 6.  Security Considerations
- contents:
  - "7.  IANA Considerations\n   IANA actions for this version of IDNA are specified
    in the Tables\n   document [RFC5892] and discussed informally in the Rationale
    document\n   [RFC5894].  The components of IDNA described in this document do
    not\n   require any IANA actions.\n"
  title: 7.  IANA Considerations
- contents:
  - "8.  Contributors\n   While the listed editor held the pen, the original versions
    of this\n   document represent the joint work and conclusions of an ad hoc design\n
    \  team consisting of the editor and, in alphabetic order, Harald\n   Alvestrand,
    Tina Dam, Patrik Faltstrom, and Cary Karp.  This document\n   draws significantly
    on the original version of IDNA [RFC3490] both\n   conceptually and for specific
    text.  This second-generation version\n   would not have been possible without
    the work that went into that\n   first version and especially the contributions
    of its authors Patrik\n   Faltstrom, Paul Hoffman, and Adam Costello.  While Faltstrom
    was\n   actively involved in the creation of this version, Hoffman and\n   Costello
    were not and should not be held responsible for any errors\n   or omissions.\n"
  title: 8.  Contributors
- contents:
  - "9.  Acknowledgments\n   This revision to IDNA would have been impossible without
    the\n   accumulated experience since RFC 3490 was published and resulting\n   comments
    and complaints of many people in the IETF, ICANN, and other\n   communities (too
    many people to list here).  Nor would it have been\n   possible without RFC 3490
    itself and the efforts of the Working Group\n   that defined it.  Those people
    whose contributions are acknowledged\n   in RFC 3490, RFC 4690 [RFC4690], and
    the Rationale document [RFC5894]\n   were particularly important.\n   Specific
    textual changes were incorporated into this document after\n   suggestions from
    the other contributors, Stephane Bortzmeyer, Vint\n   Cerf, Lisa Dusseault, Paul
    Hoffman, Kent Karlsson, James Mitchell,\n   Erik van der Poel, Marcos Sanz, Andrew
    Sullivan, Wil Tan, Ken\n   Whistler, Chris Wright, and other WG participants and
    reviewers\n   including Martin Duerst, James Mitchell, Subramanian Moonesamy,
    Peter\n   Saint-Andre, Margaret Wasserman, and Dan Winship who caught specific\n
    \  errors and recommended corrections.  Special thanks are due to Paul\n   Hoffman
    for permission to extract material to form the basis for\n   Appendix A from a
    draft document that he prepared.\n"
  title: 9.  Acknowledgments
- contents:
  - '10.  References

    '
  - contents:
    - "10.1.  Normative References\n   [RFC1034]    Mockapetris, P., \"Domain names
      - concepts and\n                facilities\", STD 13, RFC 1034, November 1987.\n
      \  [RFC1035]    Mockapetris, P., \"Domain names - implementation and\n                specification\",
      STD 13, RFC 1035, November 1987.\n   [RFC2119]    Bradner, S., \"Key words for
      use in RFCs to Indicate\n                Requirement Levels\", BCP 14, RFC 2119,
      March 1997.\n   [RFC3492]    Costello, A., \"Punycode: A Bootstring encoding
      of\n                Unicode for Internationalized Domain Names in\n                Applications
      (IDNA)\", RFC 3492, March 2003.\n   [RFC5890]    Klensin, J., \"Internationalized
      Domain Names for\n                Applications (IDNA): Definitions and Document\n
      \               Framework\", RFC 5890, August 2010.\n   [RFC5892]    Faltstrom,
      P., Ed., \"The Unicode Code Points and\n                Internationalized Domain
      Names for Applications (IDNA)\",\n                RFC 5892, August 2010.\n   [RFC5893]
      \   Alvestrand, H., Ed. and C. Karp, \"Right-to-Left Scripts\n                for
      Internationalized Domain Names for Applications\n                (IDNA)\", RFC
      5893, August 2010.\n   [Unicode-UAX15]\n                The Unicode Consortium,
      \"Unicode Standard Annex #15:\n                Unicode Normalization Forms\",
      September 2009,\n                <http://www.unicode.org/reports/tr15/>.\n"
    title: 10.1.  Normative References
  - contents:
    - "10.2.  Informative References\n   [ASCII]      American National Standards
      Institute (formerly United\n                States of America Standards Institute),
      \"USA Code for\n                Information Interchange\", ANSI X3.4-1968, 1968.
      \ ANSI\n                X3.4-1968 has been replaced by newer versions with\n
      \               slight modifications, but the 1968 version remains\n                definitive
      for the Internet.\n   [IDNA2008-Mapping]\n                Resnick, P. and P.
      Hoffman, \"Mapping Characters in\n                Internationalized Domain Names
      for Applications (IDNA)\",\n                Work in Progress, April 2010.\n
      \  [RFC2671]    Vixie, P., \"Extension Mechanisms for DNS (EDNS0)\",\n                RFC
      2671, August 1999.\n   [RFC3490]    Faltstrom, P., Hoffman, P., and A. Costello,\n
      \               \"Internationalizing Domain Names in Applications\n                (IDNA)\",
      RFC 3490, March 2003.\n   [RFC3491]    Hoffman, P. and M. Blanchet, \"Nameprep:
      A Stringprep\n                Profile for Internationalized Domain Names (IDN)\",\n
      \               RFC 3491, March 2003.\n   [RFC3986]    Berners-Lee, T., Fielding,
      R., and L. Masinter, \"Uniform\n                Resource Identifier (URI): Generic
      Syntax\", STD 66,\n                RFC 3986, January 2005.\n   [RFC3987]    Duerst,
      M. and M. Suignard, \"Internationalized Resource\n                Identifiers
      (IRIs)\", RFC 3987, January 2005.\n   [RFC4690]    Klensin, J., Faltstrom, P.,
      Karp, C., and IAB, \"Review\n                and Recommendations for Internationalized
      Domain Names\n                (IDNs)\", RFC 4690, September 2006.\n   [RFC4952]
      \   Klensin, J. and Y. Ko, \"Overview and Framework for\n                Internationalized
      Email\", RFC 4952, July 2007.\n   [RFC5894]    Klensin, J., \"Internationalized
      Domain Names for\n                Applications (IDNA): Background, Explanation,
      and\n                Rationale\", RFC 5894, August 2010.\n   [Unicode]    The
      Unicode Consortium, \"The Unicode Standard, Version\n                5.0\",
      2007.  Boston, MA, USA: Addison-Wesley.  ISBN\n                0-321-48091-0.
      \ This printed reference has now been\n                updated online to reflect
      additional code points.  For\n                code points, the reference at
      the time this document was\n                published is to Unicode 5.2.\n"
    title: 10.2.  Informative References
  title: 10.  References
- contents:
  - "Appendix A.  Summary of Major Changes from IDNA2003\n   1.   Update base character
    set from Unicode 3.2 to Unicode version\n        agnostic.\n   2.   Separate the
    definitions for the \"registration\" and \"lookup\"\n        activities.\n   3.
    \  Disallow symbol and punctuation characters except where special\n        exceptions
    are necessary.\n   4.   Remove the mapping and normalization steps from the protocol
    and\n        have them, instead, done by the applications themselves,\n        possibly
    in a local fashion, before invoking the protocol.\n   5.   Change the way that
    the protocol specifies which characters are\n        allowed in labels from \"humans
    decide what the table of code\n        points contains\" to \"decision about code
    points are based on\n        Unicode properties plus a small exclusion list created
    by\n        humans\".\n   6.   Introduce the new concept of characters that can
    be used only in\n        specific contexts.\n   7.   Allow typical words and names
    in languages such as Dhivehi and\n        Yiddish to be expressed.\n   8.   Make
    bidirectional domain names (delimited strings of labels,\n        not just labels
    standing on their own) display in a less\n        surprising fashion, whether
    they appear in obvious domain name\n        contexts or as part of running text
    in paragraphs.\n   9.   Remove the dot separator from the mandatory part of the\n
    \       protocol.\n   10.  Make some currently valid labels that are not actually
    IDNA\n        labels invalid.\n"
  title: Appendix A.  Summary of Major Changes from IDNA2003
- contents:
  - "Author's Address\n   John C Klensin\n   1770 Massachusetts Ave, Ste 322\n   Cambridge,
    MA  02140\n   USA\n   Phone: +1 617 245 1457\n   EMail: john+ietf@jck.com\n"
  title: Author's Address
