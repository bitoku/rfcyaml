Abstract This document specifies the data model and the overall structure for a framework to provision Session Establishment Data (SED) into Session Data Registries and SIP Service Provider (SSP) data stores.
The framework is called the "Session Peering Provisioning Framework" (SPPF).
The provisioned data is typically used by network elements for session establishment.
Introduction Service Providers (SPs) and
enterprises use routing databases known as Registries to make session routing decisions for Voice over IP, SMS, and Multimedia Messaging Service (MMS) traffic exchanges.
This document is narrowly focused on the provisioning framework for these Registries.
This framework prescribes a way for an entity to provision session related data into a Session Peering Provisioning Protocol (SPPP)
The data being provisioned can be optionally shared with other participating peering entities.
The requirements and use cases driving this framework have been documented in [RFC6461].
Three types of provisioning flows have been described in the use case document: client to Registry, Registry to local data repository, and Registry to Registry.
This document addresses client to Registry flow enabling the ability to provision Session Establishment Data (SED).
The framework that supports the flow of messages to facilitate client to Registry provisioning is referred to as the "Session Peering Provisioning Framework" (SPPF).
The roles of the "client" and the "server" only apply to the connection, and those roles are not related in any way to the type of entity that participates in a protocol exchange.
For example, a Registry might also include a "client" when such a Registry initiates a connection (for example, for data distribution to an SSP).
A "terminating" SSP provisions SED into the Registry to be selectively shared with other peer SSPs.
SED is typically used by various downstream SIP signaling systems to route a call to the next hop associated with the called domain.
These systems typically use a local data store ("Local Data Repository") as their source of session routing information.
More specifically, the SED is the set of parameters that the outgoing Signaling Path Border Elements (SBEs) need to initiate the session.
See [RFC5486] for more details.
A Registry may distribute the provisioned data into local data repositories or may additionally offer a central query resolution service (not shown in the above figure) for query purposes.
A key requirement for the SPPF is to be able to accommodate two basic deployment scenarios: 1.
A resolution system returns a Lookup Function (LUF) that identifies the target domain to assist in call routing (as described in Section 4.3.3 of [RFC5486]).
In this case, the querying entity may use other means to perform the Location Routing Function (LRF), which in turn helps determine the actual location of the Signaling Function in that domain.
A resolution system returns an LRF that comprises the location (address) of the Signaling Function in the target domain (as described in [RFC5486]).
In terms of framework design, SPPF is agnostic to the substrate protocol.
This document includes the specification of the data model and identifies, but does not specify, the means to enable protocol operations within a request and response structure.
That aspect of the specification has been delegated to the "protocol" specification for the framework.
To encourage interoperability, the framework supports extensibility aspects.
In this document, an XML Schema is used to describe the building blocks of the SPPF and to express the data types, semantic relationships between the various data types, and various constraints as a binding construct.
However, a "protocol" specification is free to choose any data representation format as long as it meets the requirements laid out in the SPPF XML Schema Definition (XSD).
As an example, XML and JSON are two widely used data representation formats.
This document is organized as follows:
Section 2 provides the terminology  Section 3 provides an overview of SPPF, including functional entities and a data model  Section 4 specifies requirements for SPPF substrate protocols  Section 5 describes the base framework data structures, the generic response types that MUST be supported by a conforming substrate "protocol" specification, and the basic object type from which most first class objects extend  Section 6 provides a detailed description of the data model object specifications  Section 7 describes the operations that are supported by the data model  Section 8 defines XML considerations XML parsers must meet to conform to this specification
security, internationalization, and IANA considerations, respectively  Section 12 normatively defines the SPPF using its XSD.
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC2119].
This document reuses terms from [RFC3261], [RFC5486]
, use cases and requirements documented in [RFC6461], and the ENUM Validation Architecture [RFC4725].
This document defines the following additional terms: SPPF:   Session Peering Provisioning Framework, which is the framework used by a substrate protocol to provision data into a Registry (see arrow labeled "1" in Figure 1 of [RFC6461]).
It is the primary scope of this document.
In the context of SPPF, this is an application that initiates a provisioning request.
It is sometimes referred to as a "Registry client".
In the context of SPPF, this is an application that receives a provisioning request and responds accordingly.
The Registry operates a master database of SED for one or more Registrants.
The definition of a Registrant is based on [RFC4725].
It is the end user, person, or organization that is the "holder" of the SED being provisioned into the Registry by a Registrar.
For example, in [RFC6461], a Registrant is pictured as an SP in Figure 2.
Within the confines of a Registry, a Registrant is uniquely identified by the "rant" element.
The definition of a Registrar is based on [RFC4725].
It is an entity that performs provisioning operations on behalf of a Registrant by interacting with the Registry via SPPF operations.
In other words, the Registrar is the SPPF client.
The Registrar and Registrant roles are logically separate to allow, but not require, a single Registrar to perform provisioning operations on behalf of more than one Registrant.
A peering organization is an entity to which a Registrant's SED Groups are made visible using the operations of SPPF.
This section introduces the structure of the data model and provides the information framework for the SPPF.
The data model is defined along with all the objects manipulated by a conforming substrate protocol and their relationships.
The data model illustrated and described in Figure 2 defines the logical objects and the relationships between these objects supported by SPPF.
SPPF defines protocol operations through which an SPPF client populates a Registry with these logical objects.
SPPF clients belonging to different Registrars may provision data into the Registry using a conforming substrate protocol that implements these operations
The logical structure presented below is consistent with the terminology and requirements defined in [RFC6461].
The objects and attributes that comprise the data model can be described as follows (
objects listed from the bottom up):  Public Identifier: From a broad perspective, a Public Identifier is a well known attribute that is used as the key to perform resolution lookups.
Within the context of SPPF, a Public Identifier object can be a Telephone Number (TN), a range of TNs, a Public Switched Telephone Network (PSTN)
Routing Number (RN), a TN prefix, or a URI.
An SPPF Public Identifier may be a member of zero or more Destination Groups to create logical groupings of Public Identifiers that share a common set of SED (e.g., routes).
A TN Public Identifier may optionally be associated with zero or more individual SED Records.
This ability for a Public Identifier to be directly associated with a SED Record, as opposed to forcing membership in one or more Destination Groups, supports use cases where the SED Record contains data specifically tailored to an individual TN Public Identifier.
A named logical grouping of zero or more Public Identifiers that can be associated with one or more SED Groups for the purpose of facilitating the management of their common SED.
A SED Group contains a set of SED Record references, a set of Destination Group references, and a set of peering organization identifiers.
This is used to establish a three part relationship between a set of Public Identifiers, the SED shared across these Public Identifiers, and the list of peering organizations whose query responses from the resolution system may include the SED contained in a given SED Group.
In addition, the sourceIdent element within a SED Group, in concert with the set of peering organization identifiers, enables fine grained source based routing.
For further details about the SED Group and source based routing, refer to the definitions and descriptions in Section 6.1.
A SED Record contains the data that a resolution system returns in response to a successful query for a Public Identifier.
SED Records are generally associated with a SED Group when the SED within is not specific to a Public Identifier.
To support the use cases defined in [RFC6461], the SPPF defines three types of SED Records: URIType, NAPTRType, and NSType.
These SED Records extend the abstract type SedRecType and inherit the common attribute "priority" that is meant for setting precedence across the SED Records defined within a SED Group in a protocol  agnostic fashion.
In a high availability environment, the originating SSP likely has more than one egress path to the ingress SBE of the target SSP.
The Egress Route allows the originating SSP to choose a specific egress SBE to be associated with the target ingress SBE.
The "svcs" element specifies ENUM services
that are used to identify the SED Records associated with the SED Group that will be modified by the originating SSP.
An Organization is an entity that may fulfill any combination of three roles: Registrant, Registrar, and peering organization.
All objects in SPPF are associated with two organization identifiers to identify each object's Registrant and Registrar.
A SED Group object is also associated with a set of zero or more organization identifiers that identify
the peering organization(s) whose resolution query responses may include the SED defined in the SED Records within that SED Group.
A peering organization is an entity with which the Registrant intends to share the SED data.
Some request and response messages in SPPF include a time value or values defined as type xs:
dateTime, a built in W3C XML Schema Datatype.
Use of an unqualified local time value is disallowed as it can lead to interoperability issues.
The value of a time attribute MUST be expressed in Coordinated Universal Time (UTC) format without the time zone digits.
"2010 05 30T09:30:10Z" is an example of an acceptable time value for use in SPPF messages.
30T06:30:10 3:00" is a valid UTC time but is not acceptable for use in SPPF messages.
The framework contains various points of extensibility in the form of the "ext" elements.
Extensions used beyond the scope of private SPPF installations need to be documented in an RFC, and the first such extension is expected to define an IANA registry, holding a list of documented extensions.
This section provides requirements for substrate protocols suitable to carry SPPF.
More specifically, this section specifies the services, features, and assumptions that SPPF delegates to the chosen substrate and envelope technologies.
Mandatory Substrate None of the existing transport protocols carried directly over IP, appearing as "Protocol" in the IPv4 headers or "Next Header" in the IPv6 headers, meet the requirements listed in this section to carry SPPF.
Therefore, one choice to carry SPPF has been provided in "Session Peering Provisioning (SPP) Protocol over SOAP" [RFC7878], using SOAP as the substrate.
To encourage interoperability, the SPPF server MUST provide support for this protocol.
With time, it is possible that other choices may surface that comply with the requirements discussed above.
The SPPF follows a model where a client establishes a connection to a server in order to further exchange SPPF messages over such a point  to point connection.
Therefore, a substrate protocol for SPPF will be connection oriented.
Request and Response Model Provisioning operations in SPPF follow the request response model, where a client sends a request message to initiate a transaction and the server sends a response.
Multiple subsequent request response exchanges MAY be performed over a single persistent connection.
Therefore, a substrate protocol for SPPF will follow the request  response model by ensuring a response is sent to the request initiator.
Some use cases involve provisioning a single request to a network element.
Connections supporting such provisioning requests might be short lived, and may be established only on demand, for the duration of a few seconds.
Other use cases involve provisioning either a large dataset or a constant stream of small updates, both of which would likely require long lived connections, spanning multiple hours or even days.
Therefore, a protocol suitable for SPPF SHOULD be able to support both short lived and long lived connections.
All SPPF objects are associated with a Registrant identifier.
An SPPF client provisions SPPF objects on behalf of Registrants.
An authenticated SPP client is a Registrar.
Therefore, the SPPF substrate protocol MUST provide means for an SPPF server to authenticate an SPPF client.
After successful authentication of the SPPF client as a Registrar, the Registry performs authorization checks to determine if the Registrar is authorized to act on behalf of the Registrant whose identifier is included in the SPPF request.
Refer to Section 9 for further guidance.
Confidentiality and Integrity SPPF objects that the Registry manages can be private in nature.
Therefore, the substrate protocol MUST provide means for data integrity protection.
If the data is compromised in flight between the SPPF client and Registry, it will seriously affect the stability and integrity of the system.
Therefore, the substrate protocol MUST provide means for data integrity protection.
Near Real Time Many use cases require responses in near real time from the server (in the range of a few multiples of round trip time between the server and client).
Therefore, a Data for Reachability of Inter /Intra
NetworK SIP (DRINKS) substrate protocol MUST support near real time responses to requests submitted by the client.
Request and Response Sizes Use of SPPF may involve simple updates that may consist of a small number of bytes, such as the update of a single Public Identifier.
Other provisioning operations may constitute a large dataset, as in adding millions of records to a Registry.
As a result, a suitable substrate protocol for SPPF SHOULD accommodate datasets of various sizes.
Correlation A substrate protocol suitable for SPPF MUST allow responses to be correlated with requests.
Base Framework Data Structures and Response Codes SPPF contains some common data structures for most of the supported object types.
This section describes these common data structures.
Basic Object Type and Organization Identifiers
All first class objects extend the type BasicObjType.
It consists of the Registrant organization, the Registrar organization, the date and time of object creation, and the last date and time
The Registry MUST store the date and time of the object creation and modification, if applicable, for all Get operations (see Section 7).
If the client passed in either date or time values, the Registry MUST ignore it.
The Registrar performs the SPPF operations on behalf of the Registrant, the organization that owns the object.
<complexType name "BasicObjType" abstract "true"
> <sequence> <element name "rant" type "sppfb:OrgIdType"/
> <element name "rar" type "sppfb:OrgIdType"/
<element name "cDate" type "dateTime" minOccurs "
> <element name "mDate" type "dateTime" minOccurs "
> <element name "ext" type "sppfb:ExtAnyType
The identifiers used for Registrants (rant) and Registrars (rar) are instances of OrgIdType.
The OrgIdType is defined as a string and all OrgIdType instances MUST follow the textual convention: "namespace:value" (for example, "iana en:32473").
Specifically: Strings used as OrgIdType Namespace identifiers MUST conform to the following syntax in the Augmented Backus Naur Form (ABNF) [RFC5234].
See Section 11 for the corresponding IANA registry definition.
The SPPF data model contains various object relationships.
In some cases, these object relationships are established by embedding the unique identity of the related object inside the relating object.
Note that an object's unique identity is required to Delete or Get the details of an object.
The following subsections normatively define the various object keys in SPPF and the attributes of those keys.
Name" attributes that are used as components of object key types MUST be compared using the toCasefold() function, as specified in Section 3.13 of [Unicode6.1] (or a newer version of Unicode).
This function performs case insensitive comparisons.
Most objects in SPPF are uniquely identified by an object key that has the object's name, type, and Registrant's organization ID as attributes.
The abstract type called ObjKeyType is where this unique identity is housed.
Any concrete representation of the ObjKeyType MUST contain the following:
The name of the object.
The unique organization ID that identifies the Registrant.
The value that represents the type of SPPF object.
This is required as different types of objects in SPPF, that belong to the same Registrant, can have the same name.
The structure of abstract ObjKeyType is as follows:
<complexType name "ObjKeyType" abstract "true"
> <annotation> <documentation>   Generic type that represents the key for various objects in SPPF.
The SPPF data model contains certain objects that are uniquely identified by attributes, different from or in addition to the attributes in the generic object key described in the previous section.
Object keys of this kind are derived from the abstract ObjKeyType and defined in their own abstract key types.
Because these object key types are abstract, they MUST be specified in a concrete form in any SPPF conforming substrate "protocol" specification.
These are used in Delete and Get operations and may also be used in Accept and Reject operations.
Following are the derived object keys in an SPPF data model:
This uniquely identifies a SED Group object offer.
This key type extends from ObjKeyType and MUST also have the organization ID of the Registrant to whom the object is being offered as one of its attributes.
In addition to the Delete and Get operations, these key types are used in Accept and Reject operations on a SED Group Offer object.
The structure of abstract SedGrpOfferKeyType is as follows:
<complexType name "SedGrpOfferKeyType" abstract "true"
> <extension base "sppfb:ObjKeyType"> <annotation> <documentation>   Generic type that represents the key for an object offer.
A SED Group Offer object MUST use SedGrpOfferKeyType.
Refer to Section 6.5 for a description of the SED Group Offer object.
PubIdKeyType: This uniquely identifies a Public Identity object.
This key type extends from the abstract ObjKeyType.
Any concrete definition of PubIdKeyType MUST contain the elements that identify the value and type of Public Identity and also contain the organization ID of the Registrant that is the owner of the Public Identity object.
A Public Identity object in SPPF is uniquely identified by the Registrant's organization ID, the value of the Public Identity, and the type of the Public Identity object.
The unique organization ID that identifies the Registrant.
The value of the Public Identity.
The type of the Public Identity object.
The PubIdKeyType is used in Delete and Get operations on a Public Identifier object.
The structure of abstract PubIdKeyType is as follows:
<complexType name "PubIdKeyType" abstract "true"
> <extension base "sppfb:ObjKeyType"> <annotation> <documentation>   Generic type that represents the key for a Pub ID.
A Public Identity object MUST use attributes of PubIdKeyType for its unique identification.
Refer to Section 6 for a description of a Public Identity object.
The following table contains the list of response types that MUST be defined for a substrate protocol used to carry SPPF.
An SPPF server MUST implement all of the following at minimum.
Response Types When the response messages are "parameterized" with the Attribute Name and Attribute Value, then the use of these parameters MUST adhere to the following rules:
Any value provided for the Attribute Name parameter MUST be an exact XSD element name of the protocol data element to which the response message is referring.
For example, valid values for "attribute name" are "dgName", "sedGrpName", "sedRec", etc.
The value for Attribute Value MUST be the value of the data element to which the preceding Attribute Name refers.
Response type "Attribute value invalid" MUST be used whenever an element value does not adhere to data validation rules.
Response types "Attribute value invalid" and
"Object does not exist" MUST NOT be used interchangeably.
"Object does not exist" MUST be returned by an Update/Del/Accept/Reject operation when the data element(s) used to uniquely identify a preexisting object does not exist.
If the data elements used to uniquely identify an object are malformed, then response type "Attribute value invalid" MUST be returned.
This section provides a description of the specification of each supported data model object (the nouns) and identifies the commands (the verbs) that MUST be supported for each data model object.
However, the specification of the data structures necessary to support each command is delegated to an SPPF conforming substrate "protocol" specification.
Destination Group A Destination Group represents a logical grouping of Public Identifiers with common SED.
The substrate protocol MUST support the ability to Add, Get, and Delete Destination Groups (refer to Section 7 for a generic description of various operations).
A Destination Group object MUST be uniquely identified by attributes as defined in the description of "ObjKeyType" in "Generic Object Key Type" (Section 5.2.1 of this document).
The DestGrpType object structure is defined as follows: <complexType name "DestGrpType"> <complexContent> <extension base
The DestGrpType object is composed of the following elements:  base: All first class objects extend BasicObjType (see Section 5.1).
The character string that contains the name of the Destination Group.
ext: Point of extensibility described in Section 3.3. 6.2.
Public Identifier A Public Identifier is the search key used for locating the SED.
In many cases, a Public Identifier is attributed to the end user who has a retail relationship with the SP or Registrant organization.
SPPF supports the notion of the carrier of record as defined in [RFC5067].
Therefore, the Registrant under which the Public Identifier is being created can optionally claim to be a carrier of record.
SPPF identifies three types of Public Identifiers: TNs, RNs, and URIs.
SPPF provides structures to manage a single TN, a contiguous range of TNs, and a TN prefix.
The substrate protocol MUST support the ability to Add, Get, and Delete Public Identifiers (refer to Section 7 for a generic description of various operations).
A Public Identity object MUST be uniquely identified by attributes as defined in the description of "PubIdKeyType" in Section 5.2.2.
The abstract XSD type PubIdType is a generalization for the concrete Public Identifier schema types.
The PubIdType element "dgName" represents the name of a Destination Group of which a given Public Identifier may be a member.
Note that this element may be present multiple times so that a given Public Identifier may be a member of multiple Destination Groups.
The PubIdType object structure is defined as follows: <complexType name "PubIdType" abstract "true"> <complexContent> <extension base
<element name "dgName" type "sppfb:ObjNameType" minOccurs
A Public Identifier may be a member of zero or more Destination Groups.
When a Public Identifier is a member of a Destination Group, it is intended to be associated with SED through the SED Group(s) that is associated with the Destination Group.
When a Public Identifier is not member of any Destination Group, it is intended to be associated with SED through the SED Records that are directly associated with the Public Identifier.
A TN is provisioned using the TNType, an extension of PubIdType.
Each TNType object is uniquely identified by the combination of its value contained within the <tn> element and its Registrant ID.
TNType is defined as follows:
> <extension base "sppfb:PubIdType"> <sequence>
<element name "tn" type "sppfb:
<element name "corInfo" type "sppfb:CORInfoType" minOccurs "
> <element name "sedRecRef" type "sppfb:SedRecRefType
" minOccurs "0" maxOccurs "
> <element name "corDate" type "dateTime" minOccurs "
<restriction base "token"> <maxLength value "20"/
TNType consists of the following attributes:  tn:
Telephone number to be added to the Registry.
sedRecRef: Optional reference to SED Records that are directly associated with the TN Public Identifier.
Following the SPPF data model, the SED Record could be a protocol agnostic URIType or another type.
: corInfo is an optional parameter of type CORInfoType that allows the Registrant organization to set forth a claim to be the carrier of record (see [RFC5067]).
This is done by setting the value of the <corClaim> element of the CORInfoType object structure to "true".
The other two parameters of the CORInfoType, <cor> and <corDate>, are set by the Registry to describe the outcome of the carrier of record claim by the Registrant.
In general, inclusion of the <corInfo> parameter is useful if the Registry has the authority information, such as the number portability data, etc., in order to qualify whether the Registrant claim can be satisfied.
If the carrier of record claim disagrees with the authority data in the Registry, whether or not a TN Add operation fails is a matter of policy and is beyond the scope of this document.
An RN is provisioned using the RNType, an extension of PubIDType.
The Registrant organization can add the RN and associate it with the appropriate Destination Group(s) to share the route information.
This allows SSPs to use the RN search key to derive the Ingress Routes for session establishment at the runtime resolution process (see [RFC6116]).
Each RNType object is uniquely identified by the combination of its value inside the <rn> element and its Registrant ID.
RNType is defined as follows:
<complexType name "RNType"> <complexContent> <extension base "sppfb:PubIdType"> <sequence> <element name "rn" type "sppfb:
<element name "corInfo" type "sppfb:CORInfoType" minOccurs "
RNType has the following attributes:  rn: The RN used as the search key.
: corInfo is an optional parameter of type CORInfoType that allows the Registrant organization to set forth a claim to be the carrier of record (see [RFC5067]).
TNRType structure is used to provision a contiguous range of TNs.
The object definition requires a starting TN and an ending TN that together define the span of the TN range, including the starting and ending TN.
Use of TNRType is particularly useful when expressing a TN range that does not include all the TNs within a TN block or prefix.
The TNRType definition accommodates the open number plan as well such that the TNs that fall in the range between the start and end TN may include TNs with different length variance.
Whether the Registry can accommodate the open number plan semantics is a matter of policy and is beyond the scope of this document.
Each TNRType object is uniquely identified by the combination of its value that, in turn, is a combination of the <startTn> and <endTn> elements and its Registrant ID.
The TNRType object structure definition is as follows:
> <extension base "sppfb:PubIdType"> <sequence
"corInfo" type "sppfb:CORInfoType" minOccurs "
<element name "startTn" type "sppfb:NumberValType"/
> <element name "endTn" type "sppfb:NumberValType"/
> TNRType has the following attributes:  startTn:
The starting TN in the TN range.
The last TN in the TN range.
: corInfo is an optional parameter of type CORInfoType that allows the Registrant organization to set forth a claim to be the carrier of record (see [RFC5067]).
In some cases, it is useful to describe a set of TNs with the help of the first few digits of the TN, also referred to as the TN prefix or a block.
A given TN prefix may include TNs with different length variance in support of the open number plan.
Once again, whether the Registry supports the open number plan semantics is a matter of policy, and it is beyond the scope of this document.
The TNPType data structure is used to provision a TN prefix.
Each TNPType object is uniquely identified by the combination of its value in the <tnPrefix> element and its Registrant ID.
TNPType is defined as follows: <complexType name "TNPType"> <complexContent
> <extension base "sppfb:PubIdType"> <sequence>
<element name "tnPrefix" type "sppfb:NumberValType"/
> <element name "corInfo" type "sppfb:CORInfoType" minOccurs "
TNPType consists of the following attributes:
: corInfo is an optional parameter of type CORInfoType that allows the Registrant organization to set forth a claim to be the carrier of record (see [RFC5067]).
In some cases, a Public Identifier may be a URI, such as an email address.
The URIPubIdType object is comprised of the data element necessary to house such Public Identifiers.
Each URIPubIdType object is uniquely identified by the combination of its value in the <uri> element and its Registrant ID.
URIPubIdType is defined as follows: <complexType name "URIPubIdType"> <complexContent
URIPubIdType consists of the following attributes:
The value that acts as the Public Identifier.
ext: Point of extensibility described in Section 3.3.
SED Group SED Group is a grouping of one or more Destination Groups, the common SED Records, and the list of peer organizations with access to the SED Records associated with a given SED Group.
It is this indirect linking of Public Identifiers to their SED that significantly improves the scalability and manageability of the peering data.
Additions and changes to SED information are reduced to a single operation on a SED Group or SED Record rather than millions of data updates to individual Public Identifier records that individually contain their peering data.
The substrate protocol MUST support the ability to Add, Get, and Delete SED Groups (refer to Section 7 for a generic description of various operations).
A SED Group object MUST be uniquely identified by attributes as defined in the description of "ObjKeyType" in "Generic Object Key Type" (Section 5.2.1 of this document).
The SedGrpType object structure is defined as follows: <complexType name "SedGrpType"> <complexContent> <extension base
" minOccurs "0" maxOccurs "unbounded"/>
<element name "dgName" type "sppfb:ObjNameType" minOccurs
<element name "ext" type "sppfb:ExtAnyType
<element name "ext" type "sppfb:ExtAnyType
The SedGrpType object is composed of the following elements:  base: All first class objects extend BasicObjType (see Section 5.1).
sedGrpName: The character string that contains the name of the SED Group.
It uniquely identifies this object within the context of the Registrant ID (a child element of the base element as described above).
sedRecRef: Set of zero or more objects of type SedRecRefType
that house the unique keys of the SED Records (containing the SED) that the SedGrpType object refers to and their relative priority within the context of this SED Group.
dgName: Set of zero or more names of DestGrpType object instances.
Each dgName name, in association with this SED Group's Registrant ID, uniquely identifies a DestGrpType object instance whose associated Public Identifiers are reachable using the SED housed in this SED Group.
An intended side effect of this is that a SED Group cannot provide session establishment information for a Destination Group belonging to another Registrant.
Set of zero or more peering organization IDs that have accepted an offer to receive this SED Group's information.
Note that this identifier "peeringOrg" is an instance of OrgIdType.
The set of peering organizations in this list is not directly settable or modifiable using the addSedGrpsRqst operation.
This set is instead controlled using the SED Offer and Accept operations.
zero or more SourceIdentType object instances.
These objects, described further below, house the source identification schemes and identifiers that are applied at resolution time as part of source based routing algorithms for the SED Group.
A boolean element that defines whether this SED Group is in service.
The SED contained in a SED Group that is in service is a candidate for inclusion in resolution responses for Public Identities residing in the Destination Group associated with this SED Group.
The session establishment information contained in a SED Group that is not in service is not a candidate for inclusion in resolution responses.
Priority value that can be used to provide a relative value weighting of one SED Group over another.
The manner in which this value is used, perhaps in conjunction with other factors, is a matter of policy.
ext: Point of extensibility described in Section 3.3.
As described above, the SED Group contains a set of references to SED Record objects.
A SED Record object is based on an abstract type: SedRecType.
The concrete types that use SedRecType as an extension base are NAPTRType, NSType, and URIType.
The definitions of these types are included in "SED Record" (Section 6.4 of this document).
The SedGrpType object provides support for source based routing via the peeringOrg data element and more granular source based routing via the source identity element.
The source identity element provides the ability to specify zero or more of the following in association with a given SED Group: a regular expression that is matched against the resolution client IP address, a regular expression that is matched against the root domain name(s), and/or a regular expression that is matched against the calling party URI(s).
The result will be that, after identifying the visible SED Groups whose associated Destination Group(s) contains the lookup key being queried and whose peeringOrg list contains the querying organization's organization ID, the resolution server will evaluate the characteristics of the Source URI, Source IP address, and root domain of the lookup key being queried.
The resolution server then compares these criteria against the source identity criteria associated with the SED Groups.
The SED contained in SED Groups that have source based routing criteria
will only be included in the resolution response if one or more of the criteria matches the source criteria from the resolution request.
The source identity data element is of type SourceIdentType, whose structure is defined as follows: <complexType name "SourceIdentType"> <sequence>
<restriction base "token"> <enumeration value "uri"/>
The SourceIdentType object is composed of the following data elements:  sourceIdentScheme: The source identification scheme that this source identification criteria applies to and that the associated sourceIdentRegex should be matched against.
sourceIdentRegex: The regular expression that should be used to test for a match against the portion of the resolution request that is dictated by the associated sourceIdentScheme.
ext: Point of extensibility described in Section 3.3.
SED Record SED Group represents a combined grouping of SED Records that define SED.
However, SED Records need not be created to just serve a single SED Group.
SED Records can be created and managed to serve multiple SED Groups.
As a result, a change, for example, to the properties of a network node used for multiple routes would necessitate just a single update operation to change the properties of that node.
The change would then be reflected in all the SED Groups whose SED Record set contains a reference to that node.
The substrate protocol MUST support the ability to Add, Get, and Delete SED Records (refer to Section 7 for a generic description of various operations).
A SED Record object MUST be uniquely identified by attributes as defined in the description of "ObjKeyType" in "Generic Object Key Type" (Section 5.2.1 of this document).
The SedRecType object structure is defined as follows:
<complexType name "SedRecType" abstract "true"
<restriction base "token"> <enumeration value "routing"/
The SedRecType object is composed of the following elements:
All first class objects extend BasicObjType (see Section 5.1).
The character string that contains the name of the SED Record.
It uniquely identifies this object within the context of the Registrant ID (a child element of the base element as described above).
sedFunction: As described in [RFC6461], SED falls primarily into one of two categories or functions: LUF and LRF.
To remove any ambiguity as to the function a SED Record is intended to provide, this optional element allows the provisioning party to make its intentions explicit.
A boolean element that defines whether or not this SED Record is in service.
The session establishment information contained in a SED Record that is in service is a candidate for inclusion in resolution responses for TNs that are either directly associated to this SED Record or for Public Identities residing in a Destination Group that is associated to a SED Group, which, in turn, has an association to this SED Record.
Number of seconds that an addressing server may cache a particular SED Record.
As described above, SED Records are based on abstract type SedRecType.
The concrete types that use SedRecType as an extension base are NAPTRType, NSType, and URIType.
The definitions of these types are included below.
The NAPTRType object is comprised of the data elements necessary for a Naming Authority Pointer (NAPTR) (see [RFC3403])
that contains routing information for a SED Group.
The NSType object is comprised of the data elements necessary for a DNS name server that points to another DNS server that contains the desired routing information.
The NSType is relevant only when the resolution protocol is ENUM (see [RFC6116]).
The URIType object is comprised of the data elements necessary to house a URI.
The data provisioned in a Registry can be leveraged for many purposes and queried using various protocols including SIP, ENUM, and others.
As such, the resolution data represented by the SED Records must be in a form suitable for transport using one of these protocols.
In the NAPTRType, for example, if the URI is associated with a Destination Group, the user part of the replacement string <uri> that may require the Public Identifier cannot be preset.
As a SIP Redirect, the resolution server will apply <ere
> pattern on the input Public Identifier in the query and process the replacement string by substituting any back references in the <uri> to arrive at the final URI that is returned in the SIP Contact header.
For an ENUM query, the resolution server will simply return the values of the <ere> and <uri
> members of the URI.
> <extension base "sppfb:SedRecType"> <sequence> <element name "order" type "unsignedShort"/>
<element name "flags" type "sppfb:FlagsType" minOccurs "
element name "regx" type "sppfb:RegexParamType" minOccurs "
> <element name "repl" type "sppfb:ReplType" minOccurs "
> <element name "ext" type "sppfb:ExtAnyType
> <extension base "sppfb:SedRecType"> <sequence> <element name "hostName" type "
> <element name "ipAddr" type "sppfb:IPAddrType" minOccurs "
> </sequence> <attribute name "type" type "sppfb:IPType
> <simpleType name "IPType"> <restriction base "token"> <enumeration value "
> <extension base "sppfb:SedRecType"> <sequence> <element name "ere" type "token" default "
<simpleType name "flagsType"> <restriction base "token">
The NAPTRType object is composed of the following elements:
Order value in an ENUM NAPTR, relative to other NAPTRType objects in the same SED Group.
that is served by the SBE.
This field's value must be of the form specified in [RFC6116] (e.g., E2U pstn:sip sip).
The allowable values are a matter of policy and are not limited by this protocol.
regx: NAPTR's regular expression field.
If this is not included, then the repl field must be included.
repl: NAPTR replacement field; it should only be provided if the regx field is not provided; otherwise, the server will ignore it.
ext: Point of extensibility described in Section 3.3.
The NSType object is composed of the following elements:
Root relative host name of the name server.
ipAddr: Zero or more objects of type
Each object holds an IP Address and the IP Address type ("IPv4" or "IPv6").
ext: Point of extensibility described in Section 3.3.
The URIType object is composed of the following elements:
The POSIX Extended Regular Expression (ere) as defined in [RFC3986].
the URI as defined in [RFC3986].
In some cases, this will serve as the replacement string, and it will be left to the resolution server to arrive at the final usable URI.
The list of peer organizations whose resolution responses can include the SED contained in a given SED Group is controlled by the organization to which a SED Group object belongs (its Registrant) and the peer organization that submits resolution requests (a data recipient, also known as a peering organization).
The Registrant offers access to a SED Group by submitting a SED Group Offer.
The data recipient can then accept or reject that offer.
Not until access to a SED Group has been offered and accepted
will the data recipient's organization ID be included in the peeringOrg list in a SED Group object, and that SED Group's peering information becomes a candidate for inclusion in the responses to the resolution requests submitted by that data recipient.
The substrate protocol MUST support the ability to Add, Get, Delete, Accept, and Reject SED Group Offers (refer to Section 7 for a generic description of various operations).
A SED Group Offer object MUST be uniquely identified by attributes as defined in the description of "SedGrpOfferKeyType" in "Derived Object Key Types"
(Section 5.2.2 of this document).
The SedGrpOfferType object structure is defined as follows: <complexType name "SedGrpOfferType"> <complexContent> <extension base
> <element name "acceptDateTime" type "dateTime" minOccurs "
> <element name "ext" type "sppfb:ExtAnyType
> <complexType name "SedGrpOfferKeyType" abstract "true"> <annotation> <documentation>   Generic type that represents the key for a SED Group Offer.
Must be defined in concrete form in a substrate "protocol" specification.
> <simpleType name "SedGrpOfferStatusType"> <restriction base "token"> <enumeration value "offered"/>
The SedGrpOfferType object is composed of the following elements:  base: All first class objects extend BasicObjType (see Section 5.1).
The object that identifies the SED that is or has been offered and the organization to which it is or has been offered.
The status of the offer, offered or accepted.
The server controls the status.
It is automatically set to "offered" whenever a new SED Group Offer is added and is automatically set to "accepted" if and when that offer is accepted.
The value of the element is ignored when passed in by the client.
Date and time in UTC when the SED Group Offer was added.
Date and time in UTC when the SED Group Offer was accepted.
In a high availability environment, the originating SSP likely has more than one egress path to the ingress SBE of the target SSP.
If the originating SSP wants to exercise greater control and choose a specific egress SBE to be associated to the target ingress SBE, it can do so using the EgrRteType object.
An Egress Route object MUST be uniquely identified by attributes as defined in the description of "ObjKeyType" in "Generic Object Key Type" (Section 5.2.1 of this document).
Assume that the target SSP has offered, as part of its SED, to share one or more Ingress Routes and that the originating SSP has accepted the offer.
In order to add the Egress Route to the Registry, the originating SSP uses a valid regular expression to rewrite the Ingress Route in order to include the egress SBE information.
Also, more than one Egress Route can be associated with a given Ingress Route in support of fault tolerant configurations.
The supporting SPPF structure provides a way to include route precedence information to help manage traffic to more than one outbound egress SBE.
The substrate protocol MUST support the ability to Add, Get, and Delete Egress Routes (refer to Section 7 for a generic description of various operations).
The EgrRteType object structure is defined as follows:
<complexType name "EgrRteType"> <complexContent> <extension base
" minOccurs "0" maxOccurs "
> <element name "ext" type "sppfb:ExtAnyType
The EgrRteType object is composed of the following elements:
All first class objects extend BasicObjType (see Section 5.1).
: The name of the Egress Route.
The preference of this Egress Route relative to other Egress Routes that may get selected when responding to a resolution request.
The regular expression rewrite rule that should be applied to the regular expression of the ingress NAPTR(s) that belongs to the Ingress Route.
The ingress SED Group that the Egress Route should be used for.
that is served by an Egress Route.
This element is used to identify the ingress NAPTRs associated with the SED Group to which an Egress Route's regxRewriteRule should be applied.
If no ENUM service(s) is associated with an Egress Route, then the Egress Route's regxRewriteRule should be applied to all the NAPTRs associated with the SED Group.
This field's value must be of the form specified in [RFC6116] (e.g., E2U pstn:sip sip).
The allowable values are a matter of policy and are not limited by this protocol.
ext: Point of extensibility described in Section 3.3. 7.
In addition to the operation specific object types, all operations MAY specify the minor version of the protocol that when used in conjunction with the major version (which can be, for instance, specified in the protocol Namespace) can serve to identify the version of the SPPF protocol that the client is using.
If the minor version is not specified, the latest minor version supported by the SPPF server for the given major version will be used.
Additionally, operations that may potentially modify persistent protocol objects SHOULD include a transaction ID as well.
Any conforming substrate "protocol" specification MUST provide a definition for the operation that adds one or more SPPF objects into the Registry.
If the object, as identified by the request attributes that form part of the object's key, does not exist, then the Registry MUST create the object.
If the object does exist, then the Registry MUST replace the current properties of the object with the properties passed in as part of the Add operation.
Note that this effectively allows modification of a preexisting object.
If the entity that issued the command is not authorized to perform this operation, an appropriate error message MUST be returned from amongst the response messages defined in "Response Message Types" (Section 5.3 of this document).
Any conforming substrate "protocol" specification MUST provide a definition for the operation that deletes one or more SPPF objects from the Registry using the object's key.
If the entity that issued the command is not authorized to perform this operation, an appropriate error message MUST be returned from amongst the response messages defined in "Response Message Types" (Section 5.3 of this document).
When an object is deleted, any references to that object must of course also be removed as the SPPF server implementation fulfills the deletion request.
Furthermore, the deletion of a composite object must also result in the deletion of the objects it contains.
As a result, the following rules apply to the deletion of SPPF object types:  Destination Groups:
When a Destination Group is deleted, any cross references between that destination group and any SED Group must be automatically removed by the SPPF implementation as part of fulfilling the deletion request.
Similarly, any cross  references between that Destination Group and any Public Identifier must be removed by the SPPF implementation.
SED Groups: When a SED Group is deleted, any references between that SED Group and any Destination Group must be automatically removed by the SPPF implementation as part of fulfilling the deletion request.
Similarly, any cross references between that SED Group and any SED Records must be removed by the SPPF implementation as part of fulfilling the deletion request.
Furthermore, SED Group Offers relating to that SED Group must also be deleted.
When a SED Record is deleted, any cross references between that SED Record and any SED Group must be removed by the SPPF implementation as part of fulfilling the deletion request.
Similarly, any reference between that SED Record and any Public Identifier must be removed by the SPPF implementation.
: When a Public Identifier is deleted, any cross references between that Public Identifier and any referenced Destination Group must be removed by the SPPF implementation as part of fulfilling the deletion request.
Any references to SED Records associated directly to that Public Identifier must also be deleted by the SPPF implementation.
Get Operations At times, on behalf of the Registrant, the Registrar may need to get information about SPPF objects that were previously provisioned in the Registry.
A few examples include logging, auditing, and pre  provisioning dependency checking.
This query mechanism is limited to aid provisioning scenarios and should not be confused with query protocols provided as part of the resolution system (e.g., ENUM and SIP).
Any conforming "protocol" specification MUST provide a definition for the operation that queries the details of one or more SPPF objects from the Registry using the object's key.
If the entity that issued the command is not authorized to perform this operation, an appropriate error message MUST be returned from among the response messages defined in Section 5.3.
If the response to the Get operation includes an object(s) that extends the BasicObjType, the Registry MUST include the "cDate" and "mDate", if applicable.
In SPPF, a SED Group Offer can be accepted or rejected by, or on behalf of, the Registrant to which the SED Group has been offered (refer to Section 6.5 of this document for a description of the SED Group Offer object).
The Accept operation is used to accept the SED Group Offers.
Any conforming substrate "protocol" specification MUST provide a definition for the operation to accept SED Group Offers by, or on behalf of, the Registrant, using the SED Group Offer object key.
Not until access to a SED Group has been offered and accepted will the Registrant's organization ID be included in the peeringOrg list in that SED Group object, and that SED Group's peering information becomes a candidate for inclusion in the responses to the resolution requests submitted by that Registrant.
A SED Group Offer that is in the "offered" status is accepted by, or on behalf of, the Registrant to which it has been offered.
When the SED Group Offer is accepted, the SED Group Offer is moved to the "accepted" status and the data recipient's organization ID is added into the list of peerOrgIds for that SED Group.
If the entity that issued the command is not authorized to perform this operation, an appropriate error message MUST be returned from amongst the response messages defined in "Response Message Types" (Section 5.3 of this document).
In SPPF, a SED Group Offer object can be accepted or rejected by, or on behalf of, the Registrant to which the SED Group has been offered (refer to "Framework Data Model Objects", Section 6 of this document, for a description of the SED Group Offer object).
Furthermore, that offer may be rejected, regardless of whether or not it has been previously accepted.
The Reject operation is used to reject the SED Group Offer.
When the SED Group Offer is rejected, that SED Group Offer is deleted, and, if appropriate, the data recipient's organization ID is removed from the list of peeringOrg IDs for that SED Group.
Any conforming substrate "protocol" specification MUST provide a definition for the operation to reject SED Group Offers by, or on behalf of, the Registrant, using the SED Group Offer object key.
If the entity that issued the command is not authorized to perform this operation, an appropriate error message MUST be returned from among the response messages defined in "Response Message Types" (Section 5.3 of this document).
In SPPF, the Get Server Details operation can be used to request certain details about the SPPF server that include the SPPF server's current status and the major/minor version of the SPPF protocol supported by the SPPF server.
Any conforming substrate "protocol" specification MUST provide a definition for the operation to request such details from the SPPF server.
If the entity that issued the command is not authorized to perform this operation, an appropriate error message MUST be returned from among the response messages defined in "Response Message Types" (Section 5.3 of this document).
XML Considerations XML serves as the encoding format for SPPF, allowing complex hierarchical data to be expressed in a text format that can be read, saved, and manipulated with both traditional text tools and tools specific to XML.
Unless stated otherwise, the character casing of XML specifications in this document MUST be preserved to develop a conforming specification.
This section discusses a small number of XML related considerations pertaining to SPPF.
Namespaces All SPPF elements are defined in the Namespaces in the "IANA Considerations" and "Formal Framework Specification" sections of this document.
All XML instances SHOULD begin with an <?
> declaration to identify the version of XML that is being used, optionally identify use of the character encoding used, and optionally provide a hint to an XML parser that an external schema file is needed to validate the XML instance.
Conformant XML parsers recognize both UTF 8 (defined in [RFC3629]) and UTF 16 (defined in [RFC2781]); per [RFC2277], UTF 8 is the RECOMMENDED character encoding for use with SPPF.
Character encodings other than UTF 8 and UTF 16 are allowed by XML.
UTF 8 is the default encoding assumed by XML in the absence of an "encoding" attribute or a byte order mark (BOM); thus, the "encoding" attribute in the XML declaration is OPTIONAL if UTF 8 encoding is used.
SPPF clients and servers MUST accept a UTF 8 BOM if present, though emitting a UTF 8 BOM is NOT RECOMMENDED.
xml version "1.0" encoding "UTF 8" standalone "no"?
Many SPPF implementations manage data that is considered confidential and critical.
Furthermore, SPPF implementations can support provisioning activities for multiple Registrars and Registrants.
As a result, any SPPF implementation must address the requirements for confidentiality, authentication, and authorization.
With respect to confidentiality and authentication, the substrate protocol requirements section of this document contains security properties that the substrate protocol must provide, so that authenticated endpoints can exchange data confidentially and with integrity protection.
Refer to Section 4 of this document and [RFC7878] for the specific solutions to authentication and confidentiality.
With respect to authorization, the SPPF server implementation must define and implement a set of authorization rules that precisely address (1) which Registrars will be authorized to create/modify/ delete each SPPF object type for a given Registrant(s) and (2) which Registrars will be authorized to view/get each SPPF object type for a given Registrant(s).
These authorization rules are a matter of policy and are not specified within the context of SPPF.
However, any SPPF implementation must specify these authorization rules in order to function in a reliable and safe manner.
In general, guidance on Denial of Service (DoS) issues is given in "Internet Denial of Service Considerations" [RFC4732], which also gives a general vocabulary for describing the DoS issue.
SPPF is a high level client server protocol that can be implemented on lower level mechanisms such as remote procedure call and web  service API protocols.
As such, it inherits any Denial of Service issues inherent to the specific lower level mechanism used for any implementation of SPPF.
SPPF also has its own set of higher level exposures that are likely to be independent of lower layer mechanism choices.
DoS Issues Inherited from the Substrate Mechanism
In general, an SPPF implementation is dependent on the selection and implementation of a lower level substrate protocol and a binding between that protocol and SPPF.
The archetypal SPPF implementation uses XML [W3C.REC xml 20081126] representation in a SOAP [SOAPREF] request/response framework over HTTP [RFC7230], probably also uses Transport Layer Security (TLS)
[RFC5246] for on the wire data integrity and participant authentication, and might use HTTP Digest authentication [RFC2069].
The typical deployment scenario for SPPF is to have servers in a managed facility; therefore, techniques such as Network Ingress Filtering [RFC2827] are generally applicable.
In short, any DoS mechanism affecting a typical HTTP implementation would affect such an SPPF implementation; therefore, the mitigation tools for HTTP in general also apply to SPPF.
SPPF does not directly specify an authentication mechanism; instead, it relies on the lower level substrate protocol to provide for authentication.
In general, authentication is an expensive operation, and one apparent attack vector is to flood an SPPF server with repeated requests for authentication, thereby exhausting its resources.
Therefore, SPPF implementations SHOULD be prepared to handle authentication floods, perhaps by noting repeated failed login requests from a given source address and blocking that source address.
DoS Issues Specific to SPPF The primary defense mechanism against DoS within SPPF is authentication.
Implementations MUST tightly control access to the SPPF service, SHOULD implement DoS and other policy control screening, and MAY employ a variety of policy violation reporting and response measures such as automatic blocking of specific users and alerting of operations personnel.
In short, the primary SPPF response to DoS like activity by a user is to block that user or subject their actions to additional review.
SPPF allows a client to submit multiple element or "batch" requests that may insert or otherwise affect a large amount of data with a single request.
In the simplest case, the server progresses sequentially through each element in a batch, completing one before starting the next.
Mid batch failures are handled by stopping the batch and rolling back the data store to its pre request state.
This "stop and roll back
" design provides a DoS opportunity.
A hostile client could repeatedly issue large batch requests with one or more failing elements, causing the server to repeatedly stop and roll back large transactions.
The suggested response is to monitor clients for such failures and take administrative action (such as blocking the user) when an excessive number of rollbacks is reported.
An additional suggested response is for an implementer to set their maximum allowable XML message size and their maximum allowable batch size at a level that they feel protects their operational instance, given the hardware sizing they have in place and the expected load and size needs that their users expect.
It is not uncommon for the logging systems to document on the wire messages for various purposes, such as debugging, auditing, and tracking.
At the minimum, the various support and administration staff will have access to these logs.
Also, if an unprivileged user gains access to the SPPF deployments and/or support systems, it will have access to the information that is potentially deemed confidential.
To manage information disclosure concerns beyond the substrate level, SPPF implementations MAY provide support for encryption at the SPPF object level.
Non repudiation In some situations, it may be required to protect against denial of involvement (see [RFC4949]) and tackle non repudiation concerns in regard to SPPF messages.
This type of protection is useful to satisfy authenticity concerns related to SPPF messages beyond the end to end connection integrity, confidentiality, and authentication protection that the substrate layer provides.
This is an optional feature, and some SPPF implementations MAY provide support for it.
Replay Attacks Anti replay protection ensures that a given SPPF object replayed at a later time won't affect the integrity of the system.
SPPF provides at least one mechanism to fight against replay attacks.
Use of the optional client transaction identifier allows the SPPF client to correlate the request message with the response and to be sure that it is not a replay of a server response from earlier exchanges.
Use of unique values for the client transaction identifier is highly encouraged to avoid chance matches to a potential replay message.
The SPPF client or Registrar can be a separate entity acting on behalf of the Registrant in facilitating provisioning transactions to the Registry.
Therefore, even though the substrate layer provides end to end protection for each specific SPPP connection between client and server, data might be available in clear text before or after it traverses an SPPP connection.
Therefore, a man in the middle attack by one of the intermediaries is a possibility that could affect the integrity of the data that belongs to the Registrant and/or expose peering data to unintended actors.
Internationalization Considerations Character encodings to be used for SPPF elements are described in Section 8.2.
The use of time elements in the protocol is specified in Section 3.2.
Where human readable messages that are presented to an end user are used in the protocol, those messages SHOULD be tagged according to [RFC5646], and the substrate protocol MUST support a respective mechanism to transmit such tags together with those human  readable messages.
This document uses URNs to describe XML Namespaces and XML Schemas conforming to a Registry mechanism described in [RFC3688].
Two URI assignments have been made: Registration for the SPPF
Namespace URIs do not represent an XML specification.
Registration request for the XML Schema:
: See "Formal Specification" (Section 12 of this document).
Organization Identifier Namespace Registry IANA has created and will maintain a registry titled "SPPF OrgIdType Namespaces".
The formal syntax is described in Section 5.1.
Assignments consist of the OrgIdType Namespace string and the definition of the associated Namespace.
iana en Future assignments are to be made through the well known IANA Policy "RFC Required" (see Section 4.1 of [RFC5226]).
Such assignments will typically be requested when a new Namespace for identification of SPs is defined.
This section provides the XSD for the SPPF protocol.
xml version "1.0" encoding "UTF 8"?
sppf:base:1" xmlns "http://www.w3.org/2001/XMLSchema" targetNamespace "urn:ietf:params:xml:ns:sppf:base:1"
elementFormDefault "qualified" xml:lang "EN"> <annotation> <documentation>   Generic object key types to be defined by specific substrate/architecture.
The types defined here can be extended by the specific architecture to define the Object Identifiers.
> </annotation> <complexType name "ObjKeyType" abstract "true"
> <annotation> <documentation>   Generic type that represents the key for various objects in SPPF.
<complexType name "SedGrpOfferKeyType" abstract "true"> <complexContent>
<extension base "sppfb:ObjKeyType"> <annotation> <documentation>   Generic type that represents the key for a SED Group Offer.
<complexType name "PubIdKeyType" abstract "true"> <complexContent>
<extension base "sppfb:ObjKeyType"> <annotation> <documentation>  Generic type that represents the key for a Pub ID.
" minOccurs "0" maxOccurs "unbounded"/>
<element name "dgName" type "sppfb:ObjNameType" minOccurs
<element name "ext" type "sppfb:ExtAnyType
<complexType name "PubIdType" abstract "true"> <complexContent> <extension base
<element name "dgName" type "sppfb:ObjNameType" minOccurs
> <extension base "sppfb:PubIdType"> <sequence>
<element name "tn" type "sppfb:
<element name "corInfo" type "sppfb:CORInfoType" minOccurs "
> <element name "sedRecRef" type "sppfb:SedRecRefType
" minOccurs "0" maxOccurs "
> <extension base "sppfb:PubIdType"> <sequence
"corInfo" type "sppfb:CORInfoType" minOccurs "
<element name "tnPrefix" type "sppfb:NumberValType"/
> <element name "corInfo" type "sppfb:CORInfoType" minOccurs "
<complexType name "RNType"> <complexContent> <extension base "sppfb:PubIdType"> <sequence> <element name "rn" type "sppfb:
<element name "corInfo" type "sppfb:CORInfoType" minOccurs "
<complexType name "SedRecType" abstract "true"
> <extension base "sppfb:SedRecType"> <sequence> <element name "order" type "unsignedShort"/>
<element name "flags" type "sppfb:FlagsType" minOccurs "
element name "regx" type "sppfb:RegexParamType" minOccurs "
> <element name "repl" type "sppfb:ReplType" minOccurs "
> <element name "ext" type "sppfb:ExtAnyType
> <extension base "sppfb:SedRecType"> <sequence> <element name "hostName" type "
> <element name "ipAddr" type "sppfb:IPAddrType" minOccurs "
> <extension base "sppfb:SedRecType"> <sequence> <element name "ere" type "token" default "
<complexType name "SedGrpOfferType"> <complexContent> <extension base
> <element name "acceptDateTime" type "dateTime" minOccurs "
> <element name "ext" type "sppfb:ExtAnyType
<complexType name "EgrRteType"> <complexContent> <extension base
" minOccurs "0" maxOccurs "
> <element name "ext" type "sppfb:ExtAnyType
> <sequence> <element name "rant" type "sppfb:OrgIdType"/
> <element name "rar" type "sppfb:OrgIdType"/
<element name "cDate" type "dateTime" minOccurs "
> <element name "mDate" type "dateTime" minOccurs "
> <element name "ext" type "sppfb:ExtAnyType
<element name "ere" type "sppfb:RegexType" default "
> </sequence> <attribute name "type" type "sppfb:IPType
<element name "ext" type "sppfb:ExtAnyType
> <element name "corDate" type "dateTime" minOccurs "
<complexType name "ExtAnyType"> <sequence> <
any namespace "##other" maxOccurs "
> <simpleType name "FlagsType"> <restriction base "token"> <length value "1"/
> <pattern value "[A Z] [a z] [0 9]"/
> <simpleType name "SvcType"> <restriction base "token"> <minLength value "1"/
<restriction base "token"> <minLength value "
> <simpleType name "ReplType"> <restriction base "token"> <minLength value "1"/>
> <simpleType name "OrgIdType"> <restriction base "token"/
> <simpleType name "ObjNameType"> <restriction base "token"> <minLength value "3"/
> <simpleType name "TransIdType"> <restriction base "token"> <minLength value "3"/
<simpleType name "MinorVerType"> <restriction base "unsignedLong"/>
> <simpleType name "IPType"> <restriction base "token"> <enumeration value "v4"/>
<restriction base "token"> <enumeration value "uri"/>
> <simpleType name "ServerStatusType"> <restriction base "token"> <enumeration value "
> <simpleType name "SedGrpOfferStatusType"> <restriction base "token"> <enumeration value "
<restriction base "token"> <maxLength value "20"/
> <simpleType name "NumberTypeEnum"> <restriction base "token"> <enumeration value "
<restriction base "token"> <enumeration value "routing"/
<element name "value" type "sppfb:
> <element name "type" type "sppfb:NumberTypeEnum"/
<complexType name "NumberRangeType"> <sequence> <element name "startRange" type "sppfb:
> <element name "endRange" type "sppfb:NumberValType"/
