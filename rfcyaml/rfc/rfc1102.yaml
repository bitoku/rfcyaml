- title: __initial_text__
  contents:
  - '                  Policy Routing in Internet Protocols

    '
- title: 1. Status of this Memo
  contents:
  - "1. Status of this Memo\n   The purpose of this RFC is to focus discussion on\
    \ particular problems\n   in the Internet and possible methods of solution.  No\
    \ proposed\n   solutions in this document are intended as standards for the\n\
    \   Internet.  Distribution of this memo is unlimited.\n"
- title: 2. Introduction
  contents:
  - "2. Introduction\n   An integral component of the Internet protocols is the routing\n\
    \   function, which determines the series of networks and gateways a\n   packet\
    \ will traverse in passing from the source to the destination.\n   Although there\
    \ have been a number of routing protocols used in the\n   Internet, they share\
    \ the idea that one route should be selected out\n   of all available routes based\
    \ on minimizing some measure of the\n   route, such as delay.  Recently, it has\
    \ become important to select\n   routes in order to restrict the use of network\
    \ resources to certain\n   classes of customers.  These considerations, which\
    \ are usually\n   described as resource policies, are poorly enforced by the existing\n\
    \   technology in the Internet.  This document proposes an approach to\n   integrating\
    \ policy controls into the Internet.\n   I assume that the resources of the Internet:\
    \ networks, links, and\n   gateways, are partitioned into Administrative Regions\
    \ or ARs.  Each\n   AR is governed by a somewhat autonomous administration, with\
    \ distinct\n   goals as to the class of customers it intends to serve, the qualities\n\
    \   of service it intends to deliver, and the means for recovering its\n   cost.\
    \  To construct a route across the Internet, a sequence of ARs\n   must be selected\
    \ that collectively supply a path from the source to\n   the destination.  This\
    \ sequence of ARs will be called a Policy Route,\n   or PR.  Each AR through which\
    \ a Policy Route passes will be concerned\n   that the PR has been properly constructed.\
    \  To this end, each AR may\n   wish to insure that the user of the PR is authorized,\
    \ the requested\n   quality of service is supported, and that the cost of the\
    \ service can\n   be recovered.\n   In the abstract, a Policy Route is a series\
    \ of ARs, which are assumed\n   to be named with globally distinct identifiers.\
    \  (The requirement for\n   global names for ARs suggests that the name space\
    \ of ARs is flat.\n   That simplifying assumption is made in this RFC, but it\
    \ should be\n   possible to extend the scheme described here to permit nesting\
    \ of ARs\n   to reduce the amount of global information.  The problem of adding\n\
    \   structure to the space of ARs is an exercise for later study.)\n   Before\
    \ a PR can be used, however, it must be reduced to more concrete\n   terms; a\
    \ series of gateways which connect the sequence of ARs.  These\n   gateways will\
    \ be called Policy Gateways.\n   Presently, the closest mechanism to policy routing\
    \ in the Internet is\n   EGP, the Exterior Gateway Protocol.  EGP was constructed\
    \ to permit\n   regions of the Internet to communicate reachability information,\
    \ even\n   though they did not totally share trust.  In this respect, the\n  \
    \ regions hooked together by EGP could each be viewed as Administrative\n   Regions.\
    \  However, the mechanisms of EGP imposed a topological\n   restriction on the\
    \ interconnection of the Administration Regions.  In\n   practice, this has proved\
    \ unsatisfactory.  Policy matters are driven\n   by human concerns, and these\
    \ have not turned out to be amenable to\n   topological constraints, or indeed\
    \ to constraints of almost any sort.\n   The proposals in this memo are designed\
    \ to permit as wide a latitude\n   as possible in the construction and enforcement\
    \ of policies.  In\n   particular, no topological restrictions are assumed.  In\
    \ general, the\n   approach taken in this memo is driven by the belief that since\n\
    \   policies reflect human concerns, the system should primarily be\n   concerned\
    \ with enforcement of policy, rather than synthesis of\n   policy.  The proposal\
    \ permits both end points and transit services to\n   express and enforce local\
    \ policy concerns.\n"
- title: 3. Policy Routes
  contents:
  - "3. Policy Routes\n   Almost all approaches to policy control share, to some degree,\
    \ the\n   idea of a Policy Route.  The distinguishing component of a policy\n\
    \   approach is the procedure by which the Policy Route is synthesized.\n   One\
    \ approach to synthesizing routes is to associate with each\n   distinct policy\
    \ a subset of all the gateways in the system, and then\n   run a routing algorithm\
    \ across the subset of the gateways.  This\n   approach has several drawbacks.\
    \  It requires a distinct routing\n   computation for every policy, which may\
    \ be prohibitively expensive.\n   It requires the global agreement on the nature\
    \ and scope of each\n   policy, which is at odds with the desire of Administrative\
    \ Regions to\n   establish their own independent policy assertions.  Finally,\
    \ it\n   almost inevitably implies a topological restriction on the\n   interconnection\
    \ of regions.\n   Another synthesis approach is to have each Policy Gateway examine\n\
    \   incoming packets and determine, based on local policy constraints,\n   the\
    \ most appropriate next AR.  This approach might possibly work, but\n   again\
    \ has several drawbacks.  First, it implies a substantial amount\n   of computation\
    \ at each Policy Gateway.  More importantly, it removes\n   the route selection\
    \ from the location where it would most naturally\n   be executed, the end-points\
    \ of the connection.\n   It is useful to think of the interconnected ARs as a\
    \ marketplace, in\n   which various services are offered and users select among\
    \ these\n   services to obtain packet transport.  By this analogy, it seems\n\
    \   appropriate that the actual selection of the Policy Route should be\n   made\
    \ by the end ARs desiring to send the packets, rather than by the\n   Policy Gateways.\
    \  Looking to the phone system for comparison, it is\n   the customer of the phone\
    \ system who selects which of the long\n   distance carriers to use, whether to\
    \ purchase a fixed price service\n   or pay incrementally for usage, and so on.\
    \  In this proposal,\n   therefore, Policy Routes are synthesized at the end point,\
    \ where the\n   packet originates, and are attached to packets in order to direct\n\
    \   them through the appropriate series of ARs.  In other words, Policy\n   Routes\
    \ are a form of source routing.  The role of synthesizing a\n   Policy Route is\
    \ shared between the source AR and the particular\n   source host.\n   In this\
    \ architecture, therefore, the function of the Policy Gateway\n   is not to synthesize\
    \ the Policy Route, but to verify it.  In the\n   following sections, we will\
    \ address the two questions of how a Policy\n   Route is verified, and how a Policy\
    \ Route is synthesized.\n   In determining that Policy Routes should be synthesized\
    \ at the end\n   point, it is important to distinguish between those aspects of\n\
    \   routing that reflect legitimate policy concerns, and those aspects of\n  \
    \ routing which, in reality, relate to the detailed operation of the\n   ARs.\
    \  For example, if one were to represent Policy Routes using the\n   existing\
    \ Internet source route mechanism, which allows the end point\n   to specify a\
    \ series of gateways through which the packet should pass,\n   the result would\
    \ be that too much function has been transferred from\n   the internals of the\
    \ Internet to the end points.  The end point would\n   have to have knowledge\
    \ of exactly which gateways are up and\n   operational at a particular moment,\
    \ and this degree of knowledge\n   cannot be justified by policy concerns.  Further,\
    \ it would be\n   necessary to run a systemwide gateway reachability protocol.\n\
    \   This proposal attempts to strike a balance between end point\n   specification\
    \ of those concerns legitimately related to policy, and\n   local determination\
    \ in the Policy Gateways of the more specific\n   details necessary for reliable\
    \ operation.  This leads to a two-level\n   routing model, in which the abstract\
    \ Policy Route, a series of\n   administrative regions, is specified by the end\
    \ point as a form of\n   source route, and each Policy Gateway selects the next\
    \ actual Policy\n   Gateway that is to be used to forward this packet.  In other\
    \ words,\n   the abstract Policy Route is made concrete incrementally.  This\n\
    \   division of function does require that the source AR know if there\n   are\
    \ faults that have partitioned pairs of ARs that are normally\n   connected together.\
    \  This implies a global reachability protocol to\n   be run for the purpose of\
    \ providing information to the source AR, but\n   it need only concern itself\
    \ at the level of ARs, not at the level of\n   gateways.  In a later section on\
    \ cost-recovery, the topic of gateway\n   selection will be discussed in more\
    \ detail.\n   An objection to a scheme such as source routing is that the\n  \
    \ potentially bulky source route must be in every packet, and must be\n   evaluated\
    \ for each packet.  One solution to this performance problem\n   is to employ\
    \ a limited form of route setup, in which the actual\n   Policy Route is carried\
    \ only in the first packet of a sequence, and a\n   short identifier or \"handle\"\
    \ is included in subsequent packets of the\n   sequence.  Each Policy Gateway\
    \ evaluates the PR on first encounter,\n   and caches the result, which is then\
    \ retrieved for later packets\n   using the handle in the packet.  The idea of\
    \ a handle and caching,\n   and the need for a form of route setup, is discussed\
    \ later.\n"
- title: 4. Verification of Policy Routes
  contents:
  - "4. Verification of Policy Routes\n   As a packet arrives at a Policy Gateway,\
    \ attempting to enter an AR,\n   the Policy Gateway must decide whether it is\
    \ legitimate to forward\n   this packet, and if so, at what next Policy Gateway\
    \ the packet should\n   exit the AR (assuming that the final destination is not\
    \ within the\n   AR).  The information available to the Policy Gateway to support\
    \ its\n   decision determines the range of policies that can be enforced.\n  \
    \ Determining what information is to be available is therefore a\n   central feature\
    \ of our proposal.\n"
- title: 4.1. Identifying the User
  contents:
  - "4.1. Identifying the User\n   Classic routing decisions, those minimizing some\
    \ cost, are typically\n   driven only by the destination of the packet.  At a\
    \ minimum, policy\n   decisions must be based both on the source and the destination\
    \ of the\n   packet.  In fact, source and destination addresses may not be\n \
    \  sufficient to determine policy, for an AR may support different users\n   with\
    \ different rights, moreover a single user may wish to exercise\n   different\
    \ rights at different times.  I suggest that to identify the\n   user who is proposing\
    \ to use this particular Policy Route, it is\n   sufficient that the packets contain\
    \ the source host and AR, the\n   destination host and AR, and, optionally, a\
    \ User Class Identifier, or\n   UCI.  In a later section, I discuss how to prevent\
    \ misuse of the user\n   class identifier.\n   In fact, the source and destination\
    \ host address may not be needed to\n   support the practical range of policy\
    \ decisions required at\n   intermediate ARs.  Only the source and destination\
    \ AR information may\n   be necessary.  If individual host addresses are to be\
    \ used, that\n   implies that intermediate ARs will want to keep track of the\
    \ rights\n   of individual hosts.  It would be much simpler if the source AR could\n\
    \   be trusted to permit only the proper hosts to use certain PRs.  I\n   will\
    \ consider this further in a later section when I discuss the role\n   of the\
    \ Policy Controller.\n"
- title: 4.2. Verifying the Route
  contents:
  - "4.2. Verifying the Route\n   The packet contains an abstract Policy Route: a\
    \ series of AR\n   identifiers.  To validate this route, each Policy Gateway could\
    \ store\n   the complete selection of acceptable policy routes, and require that\n\
    \   an incoming packet have a Policy Route that exactly matched one of\n   the\
    \ stored entries.  This degree of constraint probably overspecifies\n   the situation,\
    \ and causes an information explosion.  At the other end\n   of the scale, Policy\
    \ Gateways could simply be sensitive to the source\n   AR and the destination\
    \ AR.  In some cases, particularly as regards to\n   billing, this does not provide\
    \ sufficient constraints.  This proposal\n   suggests that in deciding whether\
    \ a given Policy Route is valid, a\n   Policy Gateway should look at the source\
    \ and destination ARs, and\n   also the ARs immediately abutting the AR in question,\
    \ called the\n   entry and exit ARs.\n   One can think of the verification information\
    \ in the Policy Gateway\n   as a number of templates.  Each template is associated\
    \ with a valid\n   set of users, as described by the source and destination host\
    \ address\n   and the optional User Class, and contains the four ARs described\n\
    \   above, Source, Destination, Exit, and Entry.  An incoming packet\n   should\
    \ be forwarded if, and only if, there is a template matching the\n   information\
    \ in the packet.  These templates will be called Policy\n   Terms.\n"
- title: 4.3. Conditions
  contents:
  - "4.3. Conditions\n   The Policy Terms, as described so far, do not permit the\
    \ expression\n   of a realistic range of policies.  What is needed is the ability\
    \ to\n   attach to a Policy Term a number of conditions, which describe\n   circumstances\
    \ under which the term is valid.  These might include\n   what type of service\
    \ (TOS) is available, what times of day the term\n   is valid, what accounting\
    \ options are valid, and so on.  A time-of-\n   day condition, for example, would\
    \ permit networks, like time-sharing\n   systems, to offer their off-peak capacity\
    \ to a wider community.\n   In general, these conditions could be quite arbitrary.\
    \  The important\n   constraint on these conditions is that any condition imposed\
    \ by the\n   Policy Gateway must be understood by the end point, so that it can\n\
    \   generate Policy Routes which will conform to the condition.  If this\n   is\
    \ not so, and the Policy Gateway attaches capricious conditions to\n   its policy\
    \ terms, then the end points will construct Policy Routes in\n   good faith which\
    \ are rejected, leading to a failure to obtain service\n   and serious dissatisfaction\
    \ among users.  For this reason, it is\n   necessary that the nature of policy\
    \ conditions be negotiated in\n   advance.\n   The most interesting and difficult\
    \ conditions are those that relate\n   to the dynamic state of the network.  An\
    \ excellent example is a\n   bilateral mutual aid agreement between two transit\
    \ ARs in which each\n   agrees to carry the load of the other if the other should\
    \ go down.\n   To capture this agreement, each might wish to put in Policy Terms\n\
    \   with the condition that they are valid only if some other AR is non-\n   functional.\
    \  In the earlier discussion of Policy Route synthesis, it\n   was necessary for\
    \ the ARs to run a global up-down protocol to\n   describe the connectivity of\
    \ ARs.  This protocol is sufficient to\n   allow the Policy Gateway to know that\
    \ some other AR is non-\n   functional, but care is required in the dynamics of\
    \ this system to\n   ensure that the end point in the PR have a consistent view\
    \ of the\n   up-down status of the world.  Otherwise, there would be transient\n\
    \   service outages, which again would lead to user dissatisfaction.\n   In general,\
    \ this proposal asserts that policies should not be based\n   on highly dynamic\
    \ phenomenon.  Administrative Regions should be\n   thought of as stable entities\
    \ which do not change state rapidly.\n   Highly dynamic characteristics like queue\
    \ length should be dealt with\n   by proper engineering internal to the AR.  Precisely\
    \ because\n   conditions must be propagated globally, attempting to base a\n \
    \  condition on a highly dynamic parameter is liable to lead to system\n   instability.\n"
- title: 4.4. Ownership of Policy Gateways
  contents:
  - "4.4. Ownership of Policy Gateways\n   In Section 1, all the resources of the\
    \ network were described as\n   being partitioned among the ARs.  This statement\
    \ does not extend to\n   the Policy Gateways, which sit on the boundary between\
    \ ARs.  Either\n   the Policy Gateway must be composed of two physical halves,\
    \ connected\n   by a wire, or there must be a joint agreement for the ownership\
    \ and\n   operation of the gateway.  This is a matter for further study.\n"
- title: 5. Examples of Policy Terms
  contents:
  - "5. Examples of Policy Terms\n   This section presents examples of how policy\
    \ terms would be used to\n   express a range of practical policies.  In order\
    \ to give examples, it\n   is necessary to define a notation for policy terms.\
    \  The following is\n   not necessarily the most compact form, but will be sufficient\
    \ for\n   some simple examples.\n        A Policy Term will be expressed as follows:\n\
    \        ((Hs,ARs,ARent),(Hd,ARd,ARexit),UCI,Cg)\n   where:\n        Hs is the\
    \ source host address,\n        ARs is the source AR,\n        ARent is the entry\
    \ AR,\n   and these three values comprise the first \"element\" of the term,\n\
    \   describing the permitted access looking toward the source.\n   Similarly,\
    \ for the destination, there is an element describing the\n   host address, the\
    \ adjacent AR, and the ultimate AR.\n   In addition to the two directional elements\
    \ of the term, there is\n   global information:\n        UCI is the User Class\
    \ Id, and\n        Cg are any global conditions.\n   In many cases, an element\
    \ will not want to constrain one of the\n   values, and we will use the \"*\"\
    \ symbol to indicate a \"wild-card\"\n   match.\n   To construct some simple examples,\
    \ here is a topology, where H\n   elements are hosts, G elements are Policy Gateways,\
    \ and Numbered\n   elements are ARs.\n      H1 ---  1 --- G1 -----  2 ------ G2\
    \ ----- 3 ----- H2\n              |                                 |\n      \
    \        |                                 |\n              |                \
    \                 |\n              |---- G3 -----  4 ------ G4 ------|------ G5\
    \ --- 5\n                              |                                |\n  \
    \                            |                                |\n            \
    \                  |                               H4\n                      \
    \        H3\n   In this picture, there are four hosts, five gateways, and five\n\
    \   Administrative Regions.\n   First, consider AR two.  It has no hosts attached,\
    \ and models a\n   transit service, such as the NSF network.  It may have a very\
    \ simple\n   policy: it will carry any traffic between universities, without\n\
    \   further constraint.  If we let AR1 and AR3 be the regions of two\n   particular\
    \ universities, then its policy term could be written as:\n      AR2: ((*,1,*),(*,3,*),*,*).\n\
    \   This says that AR 2 agrees to carry traffic from AR 1 to AR 3,\n   without\
    \ concern as to the entry and exit AR, and for any hosts in\n   these ARs.\n \
    \  This notation works, but is very bulky, as a new term is required for\n   every\
    \ pair of universities.  There are several ways to compact the\n   notation. \
    \ First, we can use the * and a new symbol, \"-\", to broaden\n   the terms a\
    \ bit.  For example:\n      AR2: ((*,1,*),(*,*,-),*,*)\n   would assert that AR\
    \ 1 can use AR 2 to talk to any directly attached\n   AR, where we use the \"\
    -\" to mean that the exit AR must be the\n   destination AR.  In other words,\
    \ the destination AR must be directly\n   attached to AR2.  If AR 2 only attaches\
    \ to universities, then this\n   would provide the proper constraint.\n   Another\
    \ approach is to use the User Class ID:\n      AR2:((*,*,*),(*,*,*),University,*)\n\
    \   says that any traffic of any sort that has the User Class of\n   University\
    \ is acceptable.\n   Another, and perhaps most suitable notation, is to observe\
    \ that the\n   distinction between source and destination is actually artificial.\n\
    \   While it helps in this memo to have names for the two ends, either\n   end\
    \ can be a source, depending on who sends the first packet. (A\n   later section\
    \ explores the bi-directional nature of PRs).  A more\n   general form of a PR\
    \ is thus to permit any number of elements.  That\n   is, a Policy Term can have\
    \ more than two elements, and the meaning of\n   this is that a PR is valid if\
    \ it uses any two of these.\n   For example, if university 5 wanted to use the\
    \ AR2 service, AR2 might\n   write a Policy term as follows:\n      AR2:((*,1,*),(*,3,*),(*,5,*),*,*)\n\
    \   which would permit a policy route between hosts in any two of the ARs\n  \
    \ 1, 3 and 5.\n   All the terms so far relate to the policies of AR2.  If university\
    \ 1\n   wanted to subscribe to this service, and use it to reach any other\n \
    \  site, it would specify terms of its own.  For example:\n      AR1: ((*,1, -),(*,*,2),*,*).\n\
    \   This term says that any host in AR 1 can use AR 2 as a path to any\n   host\
    \ in any AR.  Again we use the \"-\" notation to indicate that the\n   entry AR\
    \ is the same as the source AR, in this case the AR writing\n   the term.\n  \
    \ The ARs numbered 3 and 5 are more interesting.  While 3 is directly\n   attached\
    \ to 2, 5 is not.  Instead, 5 has attached to 3.  If 3 wants\n   to use 2 for\
    \ general transit service, it must provide a term similar\n   to the one provided\
    \ by 1:\n      AR3: ((*,3,-),(*,*,2),*,*).\n   If 5 wants to use 2, more terms\
    \ are required.  Since 2 is not\n   directly attached, it cannot be named as the\
    \ exit AR in a term\n   written by 5.  The directly attached AR, 3, is all that\
    \ can be named:\n      AR5: ((*,5,-),(*,*,3),*,*).\n   Then AR3 must agree to\
    \ carry the transit traffic for 5.\n      AR3: ((*,5,-),(*,*,2),*,*)\n   AR3 might\
    \ not want to carry all forms of transit traffic for 5, but\n   only of certain\
    \ sorts or to certain locations.  This could be\n   expressed by restricting the\
    \ previous term.  For example,\n      AR3: ((*,5,-),(*,2,-),*,*)\n   would permit\
    \ traffic from 5 to cross 3 to reach 2, but only to hosts\n   directly in those\
    \ ARs.\n   For some further examples, consider AR 4, which might represent the\n\
    \   AR of a commercial user.  It connects together the hosts of that\n   user,\
    \ for example, H3, and is connected to the other environment to\n   permit cross-communication.\
    \  Given the terms so far, no traffic will\n   flow into this AR.\n   If AR 1\
    \ wants to permit communication with AR 4, it could add:\n      AR1: ((*,1,-),(*,4,-),*,*)\n\
    \   This would permit communication between hosts directly in each AR,\n   but\
    \ no transit traffic.  In particular, H3 and H2 cannot talk.  There\n   are several\
    \ different terms that would permit them to talk.\n   The direct path would be\
    \ the following:\n      AR4: ((*,4,-),(H2,3,-),*,*)\n      AR3: ((*,3,-),(H3,4,-),*,*).\n\
    \   This would permit direct connection through G4.  Note, for variety,\n   that\
    \ each term has been set up so that any host in the local AR can\n   match, but\
    \ only one host in the other AR.  The combination happens to\n   permit only H3\
    \ and H2 to communicate.\n   If G4 were not there, another path would be via AR\
    \ 2, which could be\n   permitted by suitable terms in ARs 1,2,3 and 4.\n   Even\
    \ if G3 and G4 exist, no transit traffic will flow across AR 4\n   from 1 to 3.\
    \  Even if 1 and 3 want it to:\n      AR1: ((*,1,-),(*,3,4),*,*) and\n      AR3:\
    \ ((*,3,-),(*,1,4),*,*),\n   the lack of a term for AR4 will prevent a valid PR\
    \ via that path.\n   Only if AR 4 added:\n      AR4:((*,1,-),(*,3,-),*,*)\n  \
    \ would AR 4 start serving AR a transit path from 1 to 3.\n   If AR4 added:\n\
    \   AR4: ((*,4,-),(*,*,*),*,*), any host in AR 4 could talk to any host\n   anywhere\
    \ else, but AR 4 would still not become a transit service.\n   These various examples\
    \ demonstrate how individual ARs can offer\n   Policy Terms that can be combined\
    \ to form a route.  The notation\n   proposed here is probably not adequate to\
    \ express the needed range of\n   policies.  For example, it may be desirable\
    \ to have lists of ARs as\n   part of a term, as well as single values and \"\
    *\".  Other notation\n   might be proposed to permit exclusion of a limited set\
    \ of ARs.  It\n   may also be appropriate to write elements that are directional,\
    \ so\n   that connections can be \"opened\" in one direction but not in others.\n\
    \   This idea is vague in a connectionless architecture, but seems to\n   relate\
    \ to some real policy requirements.\n   In general, the problem of expressing\
    \ policy terms in compact form is\n   the same as the problem of constructing\
    \ compact access control lists.\n   There is still an ongoing argument whether\
    \ access control lists\n   should be ordered, and should permit exclusion, and\
    \ so on.  It would\n   seem that the exact same issues arise here. Some experience\n\
    \   attempting to express real policies may give guidance as to the\n   expressive\
    \ power needed.\n"
- title: 6. Cost Recovery
  contents:
  - "6. Cost Recovery\n   Almost all of the existing Internet has been paid for as\
    \ a capital\n   purchase and provided to the users as a free good.  There are\
    \ limited\n   examples of cost recovery, but these are based on an annual\n  \
    \ subscription fee rather than a charge related to the utilization.\n   There\
    \ is a growing body of opinion which says that accounting for\n   usage, if not\
    \ billing for it, is an important component of effective\n   resource management.\
    \  For this reason, tools for accounting and\n   billing must be a central part\
    \ of any policy mechanism.  However,\n   precisely because the administrative\
    \ regions are autonomous, we\n   cannot impose a uniform form of billing policy\
    \ on all of the regions.\n   Some of them may continue to provide service freely,\
    \ or on the basis\n   of an annual fee.  Others may charge on the basis of resources\n\
    \   consumed, but even here there may be variations in detail, as some\n   may\
    \ charge by the packet and others may charge by the byte.  Again,\n   in the telephone\
    \ analogy, we see a variety of billing policies, with\n   both local and long\
    \ distance carriers selling service either on the\n   basis of a monthly fee or\
    \ on a fee-per-minute of usage, with time of\n   day conditions attached.  The\
    \ billing problem is thus a very\n   complicated one, for the user would presumably\
    \ desire to minimize the\n   cost, in the context of the various outstanding conditions.\n\
    \   If we are actually to pay for use of services, there is also the\n   problem\
    \ of collection.  Using the current telephone system as an\n   example, there\
    \ are two strategies for collecting revenues.  One is\n   the pre-divestiture\
    \ mode, in which the source AR (or the destination\n   AR in the case of a collect\
    \ call) serves as a single collection point\n   for all of the ARs involved in\
    \ the call.  After divestiture, we see\n   another paradigm, in which the transit\
    \ AR separately bills the\n   customer.\n   There are many reasons to support\
    \ both collection formats.  The\n   primary reason for separate billing is that\
    \ not all regions may wish\n   to charge the user in the same units of currency.\
    \  Some regions may\n   wish to charge actual dollars, while others may wish to\
    \ charge using\n   some form of private allocation units.  On the other hand,\
    \ having a\n   single point of collection is very convenient, because it eliminates\n\
    \   a lot of duplicate effort in collection.  It does, however, require a\n  \
    \ greater degree of trust and coordination among ARs.\n   Single point collection\
    \ also simplifies another sticky problem, lost\n   packets.  For most types of\
    \ service, the user would presumably be\n   offended if asked to pay for a significant\
    \ number of packets\n   undelivered because they have been lost before reaching\
    \ the\n   destination.  If each region separately bills for its traffic, then\n\
    \   to avoid billing for packets that are lost between that AR and the\n   destination,\
    \ it is necessary to have some form of lost packet\n   reporting, which travels\
    \ backward through system decrementing the\n   counters of all the intervening\
    \ ARs.  If single point collection is\n   performed, then the usage meters can\
    \ be put in the destination AR,\n   and periodically propagated to the billing\
    \ AR, if that is a different\n   region.\n   The discussion of lost packets makes\
    \ clear an important relationship\n   between billing and policy.  If a Policy\
    \ Route takes packets through\n   a region of known unreliability, the regions\
    \ preceding it on the path\n   may be quite unwilling to forgive the charges for\
    \ packets which have\n   successfully crossed their region, only to be lost further\
    \ down the\n   route.  A billing policy is a way of asserting that one region\
    \ wishes\n   to divorce itself from the reliability behavior of another region.\n\
    \   The conditions in the policy terms, and corresponding policy routes,\n   must\
    \ therefore be able to capture two distinct conditions.  The first\n   is whether\
    \ or not there exists a bilateral agreement between two ARs\n   by which one agrees\
    \ to be the collection agent for the other.  The\n   concatenation of a number\
    \ of these agreements permits a single\n   collection point to be used for the\
    \ entire policy route.  The other\n   condition is whether or not the AR will\
    \ accept packet and byte counts\n   from the next AR downstream as the basis of\
    \ billing, or whether the\n   AR insists that the billing be based on the counts\
    \ at the exit point\n   of this AR.  This condition allows an AR to build a wall\
    \ between it\n   and a subsequent unreliable AR.  One can imagine certain regions\n\
    \   agreeing to carry traffic into unreliable regions, but only\n   grudgingly,\
    \ knowing that the result is going to be user frustration\n   which may be directed\
    \ to all the ARs indiscriminately.  The use of a\n   specific policy condition\
    \ can make clear to the end user which ARs do\n   not view themselves as interworking\
    \ harmoniously.\n   To enforce these mechanisms, the abstract PR which is included\
    \ in the\n   packet must be augmented with a number of conditions.  First, for\n\
    \   each AR there is a 3-way flag which describes whether the billing\n   should\
    \ be separately collected for the region, propagated back to the\n   source (which\
    \ corresponds to the normal telephone company paradigm),\n   or propagated towards\
    \ the destination (which corresponds to a collect\n   call).  Second, there is\
    \ a flag which indicates whether the region is\n   expected to accept from the\
    \ next region downstream the packet and\n   byte counts as the basis of billing.\
    \  Third, there must be a charge\n   code, a unique number somewhat resembling\
    \ a credit card number to\n   which bills may be sent.  The Policy Terms in the\
    \ Gateways must\n   similarly be augmented to permit verification.  The management\
    \ of the\n   charge code, insuring its uniqueness and preventing its abuse, is\n\
    \   discussed later.\n   These conditions, which relate to agreements between\
    \ two ARs, are\n   somewhat different from the conditions previously discussed,\
    \ such as\n   time of day.  Conditions relating to AR agreements will be called\n\
    \   \"bilateral conditions,\" while the others are called \"global\n   conditions.\"\
    \  Note that even though bilateral conditions relate to\n   the agreement between\
    \ two ARs, they can have global effects.\n"
- title: 7. Gateway Selection
  contents:
  - "7. Gateway Selection\n   In Section Two, this memo proposed that the end point\
    \ should specify\n   an abstract Policy Route, as a series of ARs, and the Policy\
    \ Gateway\n   at the entry to each AR should convert the next hop to a concrete\n\
    \   route, selecting the Policy Gateway to exit from this region into the\n  \
    \ next.  It turns out that this selection is not entirely devoid of\n   policy\
    \ concerns, and some additional conditions are required in the\n   Policy Terms\
    \ in order to make this operate properly.\n   In order that each Policy Gateway\
    \ be able to select the next Policy\n   Gateway on the route, it is necessary\
    \ to have a table which lists all\n   of the potential Policy Gateways that connect\
    \ together adjacent\n   regions.  Presumably, this information is very slowly\
    \ changing, and\n   is not difficult to propagate.  The more dynamic information\
    \ that is\n   needed is whether each of these gateways is up.  It is therefore\n\
    \   necessary that all of the Policy Gateways attached to a given AR must\n  \
    \ run a local up-down algorithm, one which hopefully can determine not\n   only\
    \ that each of the other gateways is up, but that its interfaces\n   are up and\
    \ that it is properly forwarding traffic.  It is slightly\n   complicated to design\
    \ such a test.  However, we do not have to design\n   a strategy for propagating\
    \ this information globally, because it is\n   only needed by the other Policy\
    \ Gateways attached to each region.\n   The policy matter related to concrete\
    \ routes arises if there are\n   several gateways connecting two administrative\
    \ regions.  As described\n   so far, the exit Policy Gateway from any region (which\
    \ is the entry\n   Policy Gateway for the next region) is selected by the entry\
    \ Policy\n   Gateway for that region.  In other words, each region may select\
    \ its\n   exit gateway, but has no control over its entry gateway.  There are\n\
    \   certain circumstances where a particular region might insist on being\n  \
    \ able to control the entry gateway used.  Imagine two parallel transit\n   regions,\
    \ one which charges incrementally for service, the other of\n   which provides\
    \ its service as a free good.  Obviously, from the point\n   of view of the user,\
    \ it is desirable to minimize the use of the\n   charging AR, and maximize the\
    \ use of the free AR.  But this may lead\n   to gross overloads in the free AR,\
    \ and apparent discrimination\n   against the charging AR.  The owner of the free\
    \ AR, therefore, might\n   choose to impose a policy which says that it can be\
    \ used only to\n   reach certain points which are not directly connected to the\
    \ AR which\n   bills for its service, and the traffic must enter the free AR at\
    \ the\n   closest point to the destination.  In other words, the free AR\n   requires\
    \ that it be allowed to choose its entry gateway so that it\n   minimizes its\
    \ costs (which are not, in fact, being billed), with the\n   intent of shifting\
    \ as much as possible of the cost onto the other\n   network.\n   By adding more\
    \ bilateral conditions to the Policy Terms and the\n   Policy Route in the packet,\
    \ it is possible to control the various\n   options for Policy Gateway selection.\
    \  At each boundary between ARs,\n   there are only a limited number of ways to\
    \ select the Policy Gateway.\n   Either it is selected by the entry side, by the\
    \ exit side, or by some\n   collaborative algorithm specified through a bilateral\
    \ agreement.\n   (There might be several such algorithms, which requires the\n\
    \   possibility of more complexity in the specification.  In particular,\n   if\
    \ two adjacent ARs have agreed to use a common routing metric for\n   some type\
    \ of service, they may agree to make a common routing based\n   on this metric.)\n\
    \   Allowing the policy gateway to be selected by the AR which is on the\n   far\
    \ side of the gateway represents an interesting implementation\n   problem.  It\
    \ would be possible to send some message in advance of the\n   packet, which requests\
    \ the next AR to select its entry gateway.  To\n   do this, it would figure out\
    \ what its exit gateway would be, and then\n   figure backwards to minimize its\
    \ costs (for example) to select the\n   potential entry gateway back into the\
    \ immediate region.  This is\n   complicated to describe, and would probably be\
    \ complicated to\n   implement.  One way to focus the problem is to observe that\
    \ routes\n   are bi-directional, because a packet flow is bi-directional, and\
    \ it\n   is very desirable that the packets from both directions follow the\n\
    \   same route.  Once a packet has come back along the reverse route, the\n  \
    \ gateway from which it emerges is precisely the gateway which should\n   be used\
    \ for future traffic in the other direction.  But each gateway,\n   in either\
    \ the forward or reverse direction, must remember a decision\n   made by another\
    \ AR.\n   For this to work it is necessary that gateways not be stateless.  If\n\
    \   each Policy Gateway maintains a cache of recently computed Policy\n   Routes,\
    \ in particular remembering the result of computing the gateway\n   for each abstract\
    \ route, then by simply determining whether or not\n   the forward direction or\
    \ the reverse direction is allowed to\n   constrain the gateway across this boundary,\
    \ both policies can be\n   enforced.  But this requires building gateways with\
    \ state, which has\n   not been culturally acceptable in the Internet.  I therefore\
    \ consider\n   as a separate topic the virtues of state in Policy Gateways. I\n\
    \   believe that fairly simple algorithms exist to set up the required\n   bindings\
    \ in the Policy Gateways, but that problem is a matter for\n   later study.\n"
- title: 8. Flow States
  contents:
  - "8. Flow States\n   The previous section suggested that the gateway needed to\
    \ maintain\n   state in order to tie together the forward and reverse halves of\
    \ a\n   flow.  This solved the particular problem of tying together the\n   routing\
    \ decision which had been made in each direction, so that they\n   could be used\
    \ in the other.  There are, in fact, a number of reasons\n   why the two halves\
    \ of the flow should be tied together.\n   - There is considerable overhead in\
    \ accounting and collecting for the\n     usage.  It is clearly desirable to have\
    \ both halves of the flow\n     metered jointly.\n   - If the route is not bi-directional,\
    \ then a failure in the node\n     produces a uni-directional link.  Uni-directional\
    \ links are known\n     to cause anomalous behavior in protocols.\n   - As part\
    \ of resource management, it may be desirable for\n     intermediate nodes to\
    \ pass flow control information back to the\n     source of the flow.  If identifiable\
    \ reverse-direction packets\n     are passing through the gateway, then this information\
    \ can be\n     piggy-backed onto those packets.\n   An additional advantage of\
    \ maintaining state in the gateway is that\n   it will greatly reduce the overhead\
    \ of dealing with incoming packets.\n   There are a number of decisions which\
    \ the Policy Gateway must make\n   which are a part of forwarding a packet: it\
    \ must validate the Policy\n   Route against its terms, it must create or modify\
    \ an accounting\n   record, and it must select the next Policy Gateway.  It is\n\
    \   unreasonable to imagine performing these tasks from scratch for each\n   incoming\
    \ packet.  Once these decisions have been made, the results\n   should be cached,\
    \ so that they can be used for subsequent packets.\n   The stateless gateway was\
    \ proposed as part of the Internet design in\n   order to insure a robust architecture.\
    \  If the gateway has no state,\n   then a crash of a gateway cannot endanger\
    \ an on-going connection.  If\n   there is state in a gateway, and that state\
    \ information is lost\n   because of a crash, then it is possible that a flow\
    \ would be\n   disrupted.\n   In moving from a gateway with no state to a gateway\
    \ which caches\n   information, it is necessary to ensure that the cached information\n\
    \   can be lost and reconstructed.  The idea of keeping in gateways only\n   that\
    \ state which can be easily reconstructed I call \"soft state.\"\n"
- title: 9. Synthesis and Selection of Policy Routes
  contents:
  - "9. Synthesis and Selection of Policy Routes\n   In this proposal, a packet contains\
    \ a Policy Route, which is verified\n   by each Policy Gateway along the way.\
    \  This section discusses how the\n   Policy Route is created in the first place.\n\
    \   PR creation cannot be done totally automatically by the system, but\n   will\
    \ in general require human judgment.  Policies, after all, are\n   matters of\
    \ human concern.  The approach to PR creation is thus a\n   joint one, in which\
    \ the system provides support to the persons\n   setting policy.\n   Most commonly,\
    \ the desired PR will be selected from among those\n   available by first finding\
    \ all valid PRs, and then picking one that\n   meets the requirements of the user\
    \ and has the lowest real cost.\n   These two stages will be called synthesis\
    \ and selection.\n   To synthesize a PR across a sequence of ARs, one must find\
    \ a Policy\n   Term in each AR that would permit such a PR.  The Policy Terms\
    \ in\n   each adjacent AR must be compatible in their billing conditions and\n\
    \   other particulars.  One can imagine finding a sequence of Policy\n   Terms\
    \ that match, rather like dominoes, and reach from the source to\n   the destination.\n\
    \   For a Policy Term at some AR to be acceptable as a part of a PR, the\n   following\
    \ must be true:\n   - The Source and Destination Host address and UCI must match\
    \ the\n     term,\n   - The Source and Destination AR must match the term,\n \
    \  - The Entry and Exit AR must match the adjacent AR in the route,\n   - The\
    \ conditions in the term relating to the adjacent AR (e.g.,\n     billing) must\
    \ match the conditions in the term from that region.\n   These conditions, of\
    \ course, are exactly what the Policy Gateway\n   would test in validating the\
    \ PR when it is used.\n   As the route is synthesized from matching terms, the\
    \ global\n   conditions of each term are noted, and the combination of these\n\
    \   become the condition under which the PR is valid.  As a starting\n   point\
    \ of the synthesis the user may have indicated constraints on the\n   acceptable\
    \ conditions in order to limit the candidate terms in the\n   synthesis.\n   The\
    \ result of PR synthesis, which is somewhat similar to the\n   computation in\
    \ a link-state routing algorithm where each Policy Term\n   represents an abstract\
    \ link, is a potentially long list of possible\n   PRs to each destination AR,\
    \ each with attached conditions.  The\n   selection process must identify one\
    \ of these which is actually to be\n   used.  The selection can be based on the\
    \ conditions, and on the cost\n   of each PR.\n   To determine the cost, it must\
    \ be possible to ask each AR to identify\n   the cost of using that Policy Term\
    \ in the context of this particular\n   set of Entry and Exit ARs.  Either there\
    \ must be an architected\n   protocol for reporting these costs, or the task of\
    \ cost determination\n   must be left to humans to perform outside the system.\
    \  The problem\n   with architected cost reporting is that while some ARs may\
    \ bill using\n   real dollars, others may bill in terms of abstract usage\n  \
    \ authorizations which have no meaning outside that AR.  Even so, I\n   believe\
    \ that we should attempt to define a representation for\n   reporting the billing\
    \ basis associated with each AR.  This is a\n   matter for later study.\n   While\
    \ PR synthesis may be an automated process, selection probably is\n   not.  While\
    \ cost minimization will help prune the list, and some\n   routes may be rejected\
    \ automatically on the basis of conditions, part\n   of the selection will in\
    \ general require human judgment.  This\n   observation, together with the observation\
    \ that PR synthesis may be\n   costly, suggests first that synthesis and selection\
    \ cannot be done\n   for each packet or indeed each time a transport connection\
    \ is\n   established, and second that it should not be done separately for\n \
    \  each host in the AR.\n   Instead, each AR should have one (or more) Policy\
    \ Servers, servers\n   inside the AR which support the management of PRs.  The\
    \ Policy Server\n   would perform a number of functions.\n   - It would store\
    \ the Policy Terms for the AR, and make them available\n     to the Policy Gateways\
    \ and the Servers of other ARs as appropriate.\n   - It would synthesize potential\
    \ PRs to reach other ARs, and remember\n     which of these have been selected\
    \ for use.\n   - It will respond to requests from hosts in the AR for PRs, and\n\
    \     return them so that they can be included in outgoing packets.\n   - It will\
    \ participate on behalf of the AR in AR up-down protocols,\n     and other inter-AR\
    \ routing algorithms.\n   - It will remember the location of all Policy Gateways\
    \ attached to\n     this AR.\n   - It will provide the management interface for\
    \ those persons who must\n     establish AR policy: setting of local Policy Terms,\
    \ selection of\n     Policy Routes, and so on.\n   A host wishing to send packets\
    \ outside the local AR must first obtain\n   a PR to put into the packets.  In\
    \ the normal case, it would do so by\n   directing a request to the local Policy\
    \ Server, supplying the desired\n   destination and other negotiable conditions.\
    \  (For example, the TOS\n   is negotiable, the current time is not.)  The Server,\
    \ based on this\n   input, must select the most appropriate PR and return it.\n\
    \   At this point in the process, human intervention is not reasonable,\n   as\
    \ it would take much too long.  By now, sufficient selection must\n   have been\
    \ done so that automated PR selection is possible.  The most\n   direct implementation\
    \ is that the manual selection process should\n   yield an ordered (or partially\
    \ ordered) list of potential PRs, and\n   the list is searched in order until\
    \ a PR is found that matches the\n   destination and conditions.  That PR is then\
    \ returned.\n"
- title: 10. Security
  contents:
  - "10. Security\n   There are a number of aspects of this scheme which present\n\
    \   opportunities for abuse.  In essentially all cases, the possible\n   abuse\
    \ is theft of network resources or improper charging.  They thus\n   have a somewhat\
    \ different nature than problems related to corruption\n   or disclosure of data.\
    \  Mechanism to insure proper use and charging\n   of resources often tolerate\
    \ minor abuse in exchange for ease of\n   operation.  Also, control is often based\
    \ on detection and recovery\n   rather than prevention.  Assumptions of this sort\
    \ are probably\n   acceptable here as well.  An isolated packet, which is not\
    \ a part of\n   any sequence of packets, may be too small an item to account for\
    \ or\n   control.  But if a significant stream of packets goes unaccounted,\n\
    \   this is less acceptable.\n   There are three general options for abuse.  One\
    \ is to falsify the\n   user identification information in the PR, the source\
    \ and destination\n   host, the User Class Id and the charge code.  Another is\
    \ to take a\n   valid PR and misuse it intact.  And the third is to read out a\
    \ valid\n   charge code from a PR and then make additional charges against it.\n\
    \   To protect against putting false user identification information into\n  \
    \ a PR, the PRs should be sealed or signed, using a crypto sealing\n   technique.\
    \  Since Policy Servers are the source of PRs, the sealing\n   can be done by\
    \ the Server.  This would require that the seal or\n   digital signature of each\
    \ Server be known, but avoids the need to\n   have each host known.  The Server\
    \ would be trusted to seal only valid\n   PRs.  It must only put User Class Ids\
    \ and charge codes into PRs from\n   a source permitted to use them, for example.\n\
    \   Assuming a public key system, each Policy Server could have a\n   separate\
    \ key pair, the public half of which was advertised in some\n   way.  It is a\
    \ matter for further study exactly what parts of the PR\n   need be sealed.\n\
    \   If the Policy Server violates this trust, and uses a UCI or charge\n   code\
    \ with an unauthorized host, there are two sub-cases: the false\n   source host\
    \ is in the same AS, or is outside it.  If it is outside,\n   this can be detected\
    \ by inspection of the PR, since the relation\n   between AR and network number\
    \ is (almost) static.  One approach is to\n   make an AR identifier part of the\
    \ charge code, so that use of the\n   code can be rejected unless that AR is the\
    \ source AR for the packet.\n   This works, but prevents using charge codes from\
    \ a foreign location.\n   Other more general techniques could probably be proposed.\n\
    \   If the false source host is inside the AR, then further steps are\n   required\
    \ to prevent the problem.  One general solution is to note\n   that a PR is valid\
    \ only if sealed by a Policy Server.  Any AR\n   attempting to collect for usage\
    \ should be required to keep a copy of\n   the PR as proof that the route was\
    \ used.  If there seems to be\n   unauthorized use of a charge code, the owner\
    \ can ask to see the PR\n   which generated the charge, which will show the Policy\
    \ Server which\n   constructed the route.  If this is an unauthorized use, action\
    \ can be\n   taken against the AR owning that Server, with the sealed PR as\n\
    \   evidence. In other words, detection and redress may be more effective\n  \
    \ than prevention.\n   If we can assume that the Policy Server for a particular\
    \ region is as\n   trustworthy as that AR requires, there is still the problem\
    \ of a\n   Server of one region trying to steal from another AR.  This could be\n\
    \   done, for example, by taking a valid PR, and sending data forward\n   along\
    \ it from the \"middle\" of the route, so that what appears to be\n   coming from\
    \ one source is actually coming from another in a different\n   AR.\n   This would\
    \ require that packets coming back along the route towards\n   the original source\
    \ be rerouted to the false source, which would\n   require that the whole routing\
    \ function within the AR be corrupted.\n   It is unlikely that this would go long\
    \ undetected, but if direct\n   control of this class of fraud is needed, it could\
    \ be achieved by\n   requiring any AR intending to charge against a particular\
    \ PR to\n   obtain from time to time a confirmation, sealed by the Server of the\n\
    \   source AR, that its policy gateway has in fact forwarded some number\n   of\
    \ packets using this PR. This sort of function is probably overkill,\n   but this\
    \ class of fraud needs to be considered.\n   Obviously, a more detailed study\
    \ will be required of the problem of\n   resource theft, but I believe that a\
    \ mechanism can be made to work\n   based on:\n   - Local trust of the Policy\
    \ Server within each AR.\n   - Sealing of the PR by the Server.\n   - Selective\
    \ validation of the seal at the Policy Gateway.\n   - Selective consistency checking\
    \ of the PR at the Policy Gateway.\n   - Use of seal on PR as evidence of the\
    \ source of the PR.\n"
- title: 11. An Experimental Program -- Migration to Policy Routing
  contents:
  - "11. An Experimental Program -- Migration to Policy Routing\n   The proposal above\
    \ calls for several Internet components not present\n   today: the Policy Route\
    \ IP option, Policy Gateways, Policy Servers,\n   and support protocols such as\
    \ the global AS up-down protocol and the\n   local (to the AS) Policy Gateway\
    \ up-down protocol.  Any plan for\n   introduction of policy routing must provide\
    \ a method to experiment\n   with the concept without changing all the hosts and\
    \ the gateways now\n   in place.\n   Since the Policy Server is a new component\
    \ which can be added to the\n   Internet without changing any existing components,\
    \ it is easy to put\n   that facility in place.  This, then, becomes the central\
    \ part of an\n   experimental plan. Later, it is possible to imagine adding the\
    \ policy\n   controls to some of the gateways.  Most difficult will be modifying\n\
    \   all the hosts to use the PR IP option.  Based on our experience with\n   adding\
    \ minor features such as IP subnetworks, it will never be\n   possible to get\
    \ the PR option into all the hosts, and policy routing\n   must be made to work\
    \ anyway.\n   Taking into account these difficulties, here is a concrete\n   experimental\
    \ plan, in three phases.\n   In Phase I, software for a Policy Server is created,\
    \ and made\n   available to all potential ARs.  As a part of its function, it\
    \ has\n   two \"temporary\" feature, to mimic the function of the missing host\n\
    \   and gateway support.\n   To mimic the function of the policy gateway, two\
    \ policy Servers are\n   placed \"near\" a current function gateway which happens\
    \ to connect the\n   two ARs, one on each side of the current gateway, and representing\n\
    \   their respective ARs.  These two Servers then proceed to fool the\n   current\
    \ gateway as follows.\n   - The current gateway is given the two Servers as neighbors\
    \ in its\n     routing exchanges.  In this way, the Servers can control which\n\
    \     network numbers are advertised.  This is similar to the way \"gated\"\n\
    \     is used today to control routes.\n   - A packet entering the AR is directed\
    \ to the \"near\" Server inside\n     the AR, which performs the functions of\
    \ the Policy Gateway and\n     then resends the packet.  This may require the\
    \ use of a regular\n     source route in some cases, but can probably just be\
    \ done by\n     rewriting the destination IP address in the packet.  (Note that\n\
    \     the IP PR option proposed in the Appendix has fields for the\n     original\
    \ IP source and destination, so that these fields can be\n     reused in forwarding\
    \ the packet from gateway to gateway.)\n   To deal with the lack of host support\
    \ for the PR option, we again\n   make use of the Server.  Since the Server is\
    \ the recipient of all\n   routing information coming into the AR (since it has\
    \ been set up as\n   the neighbor of the current gateway at the actual AR boundary)\
    \ it\n   alone knows the proper routes out.  Internally, it advertises itself\n\
    \   as the default gateway to all networks outside the AR, so that it\n   receives\
    \ all the packets intending to leave the region.  It, rather\n   than the host,\
    \ adds the PR option and then sends the packet on the\n   Policy Gateway (or the\
    \ matching Server in the next AR playing its\n   part) for relaying.\n   By controlling\
    \ how routes are propagated by the regular gateways, it\n   is possible to prevent\
    \ hosts from manually setting up routes to\n   bypass the Servers.  In any event,\
    \ enforcement is not the primary\n   concern in Phase I of the experiment.\n \
    \  In Phase II, certain of the current gateways are augmented with the\n   Policy\
    \ Gateway functions.  This will make enforcement easier, and\n   eliminate the\
    \ extra hop which the packet had make in Phase I, as it\n   passed from one Server\
    \ to another through the current gateway.  At\n   the same time, some of the hosts\
    \ are modified to insert the IP PR\n   option into the packet at the source. \
    \ This will explore the problems\n   of PR selection.\n   In Phase III, the PR\
    \ design is proposed for general implementation.\n"
- title: 12. Policy Route Setup
  contents:
  - "12. Policy Route Setup\n   One objection to this scheme is the large size of\
    \ the IP PR option.\n   With all the information proposed in this memo, it is\
    \ larger than the\n   IP header itself.  However, this problem can easily be avoided;\
    \ the\n   PR option seldom need be sent.\n   Since the Policy Gateways are going\
    \ to cache the result of processing\n   the PR, the cache holds the equivalent\
    \ of the PR.  All that is\n   required is a very short option in the packet which\
    \ is a handle that\n   permits the gateway to find the correct cache entry.  This\
    \ handle\n   would be included in the original IP PR option, and then repeated\
    \ in\n   every packet.  The Policy Server which generated the PR could select\n\
    \   the handle, so it would be unique for each AR.  Perhaps the AR id and\n  \
    \ a 16 bit UID would be sufficient.\n   The full PR option needs to be in the\
    \ packet only if the cached\n   Information in the gateway is lost.  If a gateway\
    \ crashes or the\n   route changes, the end point must reconstruct the caches\
    \ in the\n   series of gateways that form the route.  The end point could\n  \
    \ determine that this was necessary either when a gateway reports\n   explicitly\
    \ that it does not have an entry corresponding to a handle,\n   or when the host\
    \ determines that it is not getting the desired\n   service.\n   This sort of\
    \ action can be thought of as an extension to the idea of\n   retransmitting.\
    \  In transport protocols such as TCP, the host keeps\n   track of the behavior\
    \ of the network, and if it believes that\n   something is wrong (e.g., there\
    \ is a lack of an acknowledgment), it\n   takes action to restore the desired\
    \ service.  Other examples include\n   switching to another gateway if the currently\
    \ active adjacent gateway\n   seems to be down.  Sending the full PR option in\
    \ the packet is just\n   another example of allowing the end node to restore the\
    \ state of the\n   connection if it seems to be broken.\n   Using this model,\
    \ most packets would have only a short option\n   (perhaps 12 bytes).\n   This\
    \ idea of restoring the state in the gateway as needed achieves\n   the idea of\
    \ \"soft state\" mentioned earlier, and allows gateways with\n   state to achieve\
    \ the same robustness associated with datagram\n   networks.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   David D. Clark\n   Massachusetts Institute of Technology\n\
    \   Laboratory for Computer Science\n   545 Main Street\n   Cambridge, MA 02139\n\
    \   Phone: (617) 253-6003\n   Email: ddc@LCS.MIT.EDU\n"
