Abstract This document provides sockets Application Program Interface (API) to support "advanced" IPv6 applications, as a supplement to a separate specification, RFC 3493.
The expected applications include Ping, Traceroute, routing daemons and the like, which typically use raw sockets to access IPv6 or ICMPv6 header fields.
This document proposes some portable interfaces for applications that use raw sockets under IPv6.
There are other features of IPv6 that some applications will need to access:
interface identification (specifying the outgoing interface and determining the incoming interface), IPv6 extension headers, and path Maximum Transmission Unit (MTU) information.
This document provides API access to these features too.
Additionally, some extended interfaces to libraries for the "r" commands are defined.
The extension will provide better backward compatibility to existing implementations that are not IPv6 capable.
A separate specification [RFC 3493] contains changes to the sockets API to support IP version 6.
Those changes are for TCP and UDP based applications.
This document defines some of the "advanced" features of the sockets API that are required for applications to take advantage of additional features of IPv6.
Today, the portability of applications using IPv4 raw sockets is quite high, but this is mainly because most IPv4 implementations started from a common base (the Berkeley source code) or at least started with the Berkeley header files.
This allows programs such as Ping and Traceroute, for example, to compile with minimal effort on many hosts that support the sockets API.
With IPv6, however, there is no common source code base that implementors are starting from, and
the possibility for divergence at this level between different implementations is high.
To avoid a complete lack of portability amongst applications that use raw IPv6 sockets, some standardization is necessary.
There are also features from the basic IPv6 specification that are not addressed in [RFC 3493]: sending and receiving Routing headers, Hop by Hop options, and Destination options, specifying the outgoing interface, being told of the receiving interface, and control of path MTU information.
This document updates and replaces RFC 2292.
This revision is based on implementation experience of RFC 2292, as well as some additional extensions that have been found to be useful through the IPv6 deployment.
Note, however, that further work on this document may still be needed.
Once the API specification becomes mature and is deployed among implementations, it may be formally standardized by a more appropriate body, such as has been done with the Basic API [RFC 3493].
This document can be divided into the following main sections.
Definitions of the basic constants and structures required for applications to use raw IPv6 sockets.
This includes structure definitions for the IPv6 and ICMPv6 headers and all associated constants (e.g., values for the Next Header field).
Some basic semantic definitions for IPv6 raw sockets.
For example, a raw ICMPv4 socket requires the application to calculate and store the ICMPv4 header checksum.
But with IPv6 this would require the application to choose the source IPv6 address because the source address is part of the pseudo header that ICMPv6 now uses for its checksum computation.
It should be defined that with a raw ICMPv6 socket the kernel always calculates and stores the ICMPv6 header checksum.
how applications can obtain the received interface, destination address, and received hop limit, along with specifying these values on a per packet basis.
There are a class of applications that need this capability and the technique should be portable.
Access to the optional Routing header, Hop by Hop options, and Destination options extension headers.
Additional features required for improved IPv6 application portability.
The packet information along with access to the extension headers (Routing header, Hop by Hop options, and Destination options) are specified using the "ancillary data" fields that were added to the 4.3BSD Reno sockets API in 1990.
The reason is that these ancillary data fields are part of the Posix standard [POSIX] and should therefore be adopted by most vendors.
This document does not address application access to either the authentication header or the encapsulating security payload header.
Many examples in this document omit error checking in favor of brevity and clarity.
We note that some of the functions and socket options defined in this document may have error returns that are not defined in this document.
Some of these possible error returns will be recognized only as implementations proceed.
Datatypes in this document follow the Posix format: intN t means a signed integer of exactly N bits (e.g., int16 t) and uintN t means an unsigned integer of exactly N bits (e.g., uint32 t).
Note that we use the (unofficial) terminology ICMPv4, IGMPv4, and ARPv4 to avoid any confusion with the newer ICMPv6 protocol.
Many advanced applications examine fields in the IPv6 header and set and examine fields in the various ICMPv6 headers.
Common structure definitions for these protocol headers are required, along with common constant definitions for the structure members.
This API assumes that the fields in the protocol headers are left in the network byte order, which is big endian for the Internet protocols.
If not, then either these constants or the fields being tested must be converted at run time, using something like htons() or htonl().
Two new header files are defined: <netinet/ip6.h> and <netinet
When an include file is specified, that include file is allowed to include other files that do the actual declaration or definition.
The following structure is defined as a result of including <netinet/ip6.h
Note that this is a new header.
/ uint8 t  ip6 un1 hlim
un1 nxt #define ip6 hlim
ip6 ctlun.ip6 un1.ip6 un1 hlim 2.1.1.
IPv6 defines many new values for the Next Header field.
The following constants are defined as a result of including <netinet/in.h>.
IPv6 Hop by Hop options  /
define IPPROTO FRAGMENT 44   /
IPv6 Destination options  / Berkeley derived IPv4 implementations also define IPPROTO IP to be 0.
This should not be a problem since IPPROTO IP is used only with IPv4 sockets and IPPROTO HOPOPTS only with IPv6 sockets.
Headers Six extension headers are defined for IPv6.
We define structures for all except the Authentication header and Encapsulating Security Payload header, both of which are beyond the scope of this document.
The following structures are defined as a result of including <netinet/ip6.h>. /
/ struct ip6 hbh {
/  mask out offset from ip6f offlg  /
/  reserved bits in ip6f offlg  /
/  more fragments flag  /
/  mask out offset from ip6f offlg  /
/  reserved bits in ip6f offlg  /
IPv6 Options Several options are defined for IPv6, and we define structures and macro definitions for some of them below.
The following structures are defined as a result of including <netinet/ip6.h>. /
IPv6 options  / struct ip6 opt { uint8 t  ip6o type;
when processing an unknown option and whether or not the option   content changes in flight.
/  00 0 00100  /
/ struct ip6 opt jumbo {
uint8 t  ip6oj type; uint8 t  ip6oj len; uint8
; uint8 t  ip6on len; uint8
t  ip6on src nsap len
/  Tunnel Limit Option  / struct ip6 opt tunnel { uint8 t  ip6ot type
; uint8 t  ip6ot len; uint8
uint8 t  ip6or len; uint8 t  ip6or
The ICMPv6 header is needed by numerous IPv6 applications including Ping, Traceroute, router discovery daemons, and neighbor discovery daemons.
The following structure is defined as a result of including <netinet/icmp6.h
Note that this is a new header.
In addition to a common structure for the ICMPv6 header, common definitions are required for the ICMPv6 type and code fields.
The following constants are also defined as a result of including <netinet/icmp6.h>.
/  no route to destination  /
DST UNREACH BEYONDSCOPE 2 /  beyond scope of source address  /
4 /  bad port  /
/  erroneous header field  /
1 /  unrecognized Next Header  /
2 /  unrecognized IPv6 option  /
The five ICMP message types defined by IPv6 neighbor discovery (133  137) are defined in the next section.
The following structures and definitions are defined as a result of including <netinet/icmp6.h>.
135 #define ND NEIGHBOR ADVERT
/ struct icmp6 hdr  nd ra hdr;
nd ra hdr.icmp6 cksum #define
neighbor advertisement  / struct icmp6 hdr  nd na hdr; struct in6 addr   nd na target; /
#define ND NA FLAG SOLICITED
#define ND NA FLAG SOLICITED
nd rd hdr.icmp6 cksum #define
/ uint8 t  nd opt type;
uint8 t  nd opt len;
2 #define  ND OPT PREFIX INFORMATION
nd opt pi type; uint8 t   nd opt pi len; uint8 t
nd opt pi prefix len; uint8 t   nd opt pi flags reserved;
uint32 t  nd opt pi valid time;
uint32 t  nd opt pi preferred time;
; uint8 t   nd opt rh len;
nd opt mtu len; uint16
The following structures and definitions are defined as a result of including <netinet/icmp6.h>.
The following structures and definitions are defined as a result of including <netinet/icmp6.h>.
/  Router renumbering flags  /
BIG ENDIAN #define ICMP6 RR PCOUSE FLAGS DECRVLTIME 0x80000000
#define ICMP6 RR PCOUSE FLAGS DECRPLTIME 0x40000000
#elif BYTE ORDER   LITTLE ENDIAN #
define ICMP6 RR PCOUSE FLAGS DECRPLTIME 0x40
define ICMP6 RR RESULT FLAGS FORBIDDEN  0x0001
#elif BYTE ORDER   LITTLE ENDIAN #
RR RESULT FLAGS FORBIDDEN  0x0100
The basic API ([RFC 3493]) defines some macros for testing an IPv6 address for certain properties.
This API extends those definitions with additional address testing macros, defined as a result of including <netinet/in.h>.
Many hosts provide the file /etc/protocols that contains the names of the various IP protocols and their protocol number (e.g., the value of the protocol field in the IPv4 header for that protocol, such as 1 for ICMP).
Some programs then call the function getprotobyname() to obtain the protocol value that is then specified as the third argument to the socket() function.
For example, the Ping program contains code of the form
struct protoent   proto; proto   getprotobyname("icmp"); s   socket(AF INET, SOCK RAW, proto p proto); Common names are required for the new IPv6 protocols in this file, to provide portability of applications that call the getprotoXXX() functions.
We define the following protocol names with the values shown.
These are taken under http://www.iana.org/numbers.html.
# fragment header for ipv6 esp
# encapsulating security payload for ipv6
# authentication header for ipv6 ipv6 icmp
Raw Sockets Raw sockets bypass the transport layer (TCP or UDP).
With IPv4, raw sockets are used to access ICMPv4, IGMPv4, and to read and write IPv4 datagrams containing a protocol field that the kernel does not process.
An example of the latter is a routing daemon for OSPF, since it uses IPv4 protocol field 89.
With IPv6 raw sockets will be used for ICMPv6 and to read and write IPv6 datagrams containing a Next Header field that the kernel does not process.
Examples of the latter are a routing daemon for OSPF for IPv6 and RSVP (protocol field 46).
All data sent via raw sockets must be in network byte order and all data received via raw sockets will be in network byte order.
This differs from the IPv4 raw sockets, which did not specify a byte ordering and used the host's byte order for certain IP header fields.
Another difference from IPv4 raw sockets is that complete packets (that is, IPv6 packets with extension headers) cannot be sent or received using the IPv6 raw sockets API.
Instead, ancillary data objects are used to transfer the extension headers and hoplimit information, as described in Section 6.
Should an application need access to the complete IPv6 packet, some other technique, such as the datalink interfaces BPF or DLPI, must be used.
All fields except the flow label in the IPv6 header that an application might want to change (i.e., everything other than the version number) can be modified using ancillary data and/or socket options by the application for output.
All fields except the flow label in a received IPv6 header (other than the version number and Next Header fields) and all extension headers that an application might want to know are also made available to the application as ancillary data on input.
Hence there is no need for a socket option similar to the IPv4 IP HDRINCL socket option and on receipt the application will only receive the payload i.e., the data after the IPv6 header and all the extension headers.
This API does not define access to the flow label field, because today there is no standard usage of the field.
When writing to a raw socket the kernel will automatically fragment the packet if its size exceeds the path MTU, inserting the required fragment headers.
On input the kernel reassembles received fragments, so the reader of a raw socket never sees any fragment headers.
When we say "an ICMPv6 raw socket" we mean a socket created by calling the socket function with the three arguments AF INET6, SOCK RAW, and IPPROTO ICMPV6.
Most IPv4 implementations give special treatment to a raw socket created with a third argument to socket() of IPPROTO RAW, whose value is normally 255, to have it mean that the application will send down complete packets including the IPv4 header.
(Note: This feature was added to IPv4 in 1988 by Van Jacobson to support traceroute, allowing a complete IP header to be passed by the application, before the IP HDRINCL socket option was added.)
We note that IPPROTO RAW has no special meaning to an IPv6 raw socket (and the IANA currently reserves the value of 255 when used as a next header field).
The kernel will calculate and insert the ICMPv6 checksum for ICMPv6 raw sockets, since this checksum is mandatory.
For other raw IPv6 sockets (that is, for raw IPv6 sockets created with a third argument other than IPPROTO ICMPV6), the application must set the new IPV6 CHECKSUM socket option to have the kernel (1) compute and store a checksum for output, and (2) verify the received checksum on input, discarding the packet if the checksum is in error.
This option prevents applications from having to perform source address selection on the packets they send.
The checksum will incorporate the IPv6 pseudo header, defined in Section 8.1 of [RFC  2460].
This new socket option also specifies an integer offset into the user data of where the checksum is located.
offset   2; setsockopt(fd, IPPROTO IPV6, IPV6 CHECKSUM, &offset, sizeof(offset)); By default, this socket option is disabled.
Setting the offset to  1 also disables the option.
By disabled we mean (1) the kernel will not calculate and store a checksum for outgoing packets, and (2) the kernel will not verify a checksum for received packets.
This option assumes the use of the 16 bit one's complement of the one's complement sum as the checksum algorithm and that the checksum field is aligned on a 16 bit boundary.
Thus, specifying a positive odd value as offset is invalid, and setsockopt() will fail for such offset values.
An attempt to set IPV6 CHECKSUM for an ICMPv6 socket will fail.
Also, an attempt to set or get IPV6 CHECKSUM for a non raw IPv6 socket will fail.
(Note: Since the checksum is always calculated by the kernel for an ICMPv6 socket, applications are not able to generate ICMPv6 packets with incorrect checksums (presumably for testing purposes) using this API.
Type Filtering ICMPv4 raw sockets receive most ICMPv4 messages received by the kernel.
(We say "most" and not "all" because Berkeley derived kernels never pass echo requests, timestamp requests, or address mask requests to a raw socket.
Instead these three messages are processed entirely by the kernel.)
But ICMPv6 is a superset of ICMPv4, also including the functionality of IGMPv4 and ARPv4.
This means that an ICMPv6 raw socket can potentially receive many more messages than would be received with an ICMPv4 raw socket: ICMP messages similar to ICMPv4, along with neighbor solicitations, neighbor advertisements, and the three multicast listener discovery messages.
Most applications using an ICMPv6 raw socket care about only a small subset of the ICMPv6 message types.
To transfer extraneous ICMPv6 messages from the kernel to user can incur a significant overhead.
Therefore this API includes a method of filtering ICMPv6 messages by the ICMPv6 type field.
Each ICMPv6 raw socket has an associated filter whose datatype is defined as struct icmp6 filter; This structure, along with the macros and constants defined later in this section, are defined as a result of including the <netinet/icmp6.h
The current filter is fetched and stored using getsockopt() and setsockopt() with a level of IPPROTO ICMPV6 and an option name of ICMP6 FILTER.
Six macros operate on an icmp6 filter structure
: void ICMP6 FILTER SETPASSALL (struct icmp6 filter  );
The pointer argument to all six macros is a pointer to a filter that is modified by the first four macros and is examined by the last two macros.
The first two macros, SETPASSALL and SETBLOCKALL, let us specify that all ICMPv6 messages are passed to the application or that all ICMPv6 messages are blocked from being passed to the application.
The next two macros, SETPASS and SETBLOCK, let us specify that messages of a given ICMPv6 type should be passed to the application or not passed to the application (blocked).
The final two macros, WILLPASS and WILLBLOCK, return true or false depending whether the specified message type is passed to the application or blocked from being passed to the application by the filter pointed to by the second argument.
When an ICMPv6 raw socket is created, it will by default pass all ICMPv6 message types to the application.
As an example, a program that wants to receive only router advertisements could execute the following: struct icmp6 filter  myfilt; fd   socket(AF INET6, SOCK RAW, IPPROTO ICMPV6); ICMP6 FILTER SETBLOCKALL(&myfilt); ICMP6 FILTER SETPASS(ND ROUTER ADVERT, &myfilt); setsockopt(fd, IPPROTO ICMPV6, ICMP6 FILTER, &myfilt, sizeof(myfilt)); The filter structure is declared and then initialized to block all messages types.
The filter structure is then changed to allow router advertisement messages to be passed to the application and the filter is installed using setsockopt().
In order to clear an installed filter the application can issue a setsockopt for ICMP6 FILTER with a zero length.
When no such filter has been installed, getsockopt() will return the kernel default filter.
The icmp6 filter structure is similar to the fd set datatype used with the select() function in the sockets API.
The icmp6 filter structure is an opaque datatype and the application should not care how it is implemented.
All the application does with this datatype is allocate a variable of this type, pass a pointer to a variable of this type to getsockopt() and setsockopt(), and operate on a variable of this type using the six macros that we just defined.
Nevertheless, it is worth showing a simple implementation of this datatype and the six macros.
struct icmp6 filter { uint32 t  icmp6 filt[8];
#define ICMP6 FILTER WILLBLOCK(type, filterp)
memset((filterp), 0xFF, sizeof(struct icmp6 filter))
memset((filterp), 0, sizeof(struct icmp6 filter))
These sample definitions have two limitations that an implementation may want to change.
The first four macros evaluate their first argument two times.
The second two macros require the inclusion of the <string.h> header for the memset() function.)
The protocol stack will verify the ICMPv6 checksum and discard any packets with invalid checksums.
An implementation might perform additional validity checks on the ICMPv6 message content and discard malformed packets.
However, a portable application must not assume that such validity checks have been performed.
The protocol stack should not automatically discard packets if the ICMP type is unknown to the stack.
For extensibility reasons received ICMP packets with any type (informational or error) must be passed to the applications (subject to ICMP6 FILTER filtering on the type value and the checksum verification).
Access to IPv6 and Extension Headers Applications need to be able to control IPv6 header and extension header content when sending as well as being able to receive the content of these headers.
This is done by defining socket option types which can be used both with setsockopt and with ancillary data.
Ancillary data is discussed in Appendix A.
The following optional information can be exchanged between the application and the kernel: 1.
The send/receive interface and source/destination address, 2.
Hop by Hop options header, and 7.
This document does not define how to receive the optional information on a TCP socket.
See Section 4.1 for more details.
Two different mechanisms exist for sending this optional information:
Using setsockopt to specify the option content for a socket.
These are known "sticky" options since they affect all transmitted packets on the socket until either a new setsockopt is done or the options are overridden using ancillary data.
Using ancillary data to specify the option content for a single datagram.
This only applies to datagram and raw sockets; not to TCP sockets.
IPV6 HOPLIMIT can be used as ancillary data items only)
All these options are described in detail in Section 6, 7, 8 and 9.
All the constants beginning with IPV6  are defined as a result of including <netinet/in.h
Note: We intentionally use the same constant for the cmsg level member as is used as the second argument to getsockopt() and setsockopt() (what is called the "level"), and the same constant for the cmsg type member as is used as the third argument to getsockopt() and setsockopt() (what is called the "option name").
Issuing getsockopt() for the above options will return the sticky option value i.e., the value set with setsockopt().
If no sticky option value has been set getsockopt() will return the following values:  For the IPV6 PKTINFO option, it will return an in6 pktinfo structure with ipi6 addr being in6addr
any and ipi6 ifindex being zero.
For the IPV6 TCLASS option, it will return the kernel default value.
For other options, it will indicate the lack of the option value with optlen being zero.
The application does not explicitly need to access the data structures for the Routing header, Hop by Hop options header, and Destination options header, since the API to these features is through a set of inet6 rth XXX() and inet6 opt XXX() functions that we define in Section 7 and Section 10.
Those functions simplify the interface to these features instead of requiring the application to know the intimate details of the extension header formats.
When specifying extension headers, this API assumes the header ordering and the number of occurrences of each header as described in [RFC 2460].
More details about the ordering issue will be discussed in Section 12.
It is not possible to use ancillary data to transmit the above options for TCP since there is not a one to one mapping between send operations and the TCP segments being transmitted.
Instead an application can use setsockopt to specify them as sticky options.
When the application uses setsockopt to specify the above options it is expected that TCP will start using the new information when sending segments.
However, TCP may or may not use the new information when retransmitting segments that were originally sent when the old sticky options were in effect.
It is unclear how a TCP application can use received information (such as extension headers) due to the lack of mapping between received TCP segments and receive operations.
In particular, the received information could not be used for access control purposes like on UDP and raw sockets.
This specification therefore does not define how to get the received information on TCP sockets.
The result of the IPV6 RECVxxx options on a TCP socket is undefined as well.
UDP and Raw Socket Implications
The receive behavior for UDP and raw sockets is quite straightforward.
After the application has enabled an IPV6 RECVxxx socket option it will receive ancillary data items for every recvmsg
() call containing the requested information.
However, if the information is not present in the packet the ancillary data item will not be included.
For example, if the application enables IPV6 RECVRTHDR and a received datagram does not contain a Routing header there will not be an IPV6 RTHDR ancillary data item.
Note that due to buffering in the socket implementation there might be some packets queued when an IPV6 RECVxxx option is enabled and they might not have the ancillary data information.
For sending the application has the choice between using sticky options and ancillary data.
The application can also use both having the sticky options specify the "default" and using ancillary data to override the default options.
When an ancillary data item is specified in a call to sendmsg(), the item will override an existing sticky option of the same name (if previously specified).
For example, if the application has set IPV6 RTHDR using a sticky option and later passes IPV6 RTHDR as ancillary data this will override the IPV6 RTHDR sticky option and the routing header of the outgoing packet will be from the ancillary data item, not from the sticky option.
Note, however, that other sticky options than IPV6 RTHDR will not be affected by the IPV6 RTHDR ancillary data item; the overriding mechanism only works for the same type of sticky options and ancillary data items.
(Note: the overriding rule is different from the one in RFC 2292.
In RFC 2292, an ancillary data item overrode all sticky options previously defined.
This was reasonable, because sticky options could only be specified as a set by a single socket option.
However, in this API, each option is separated so that it can be specified as a single sticky option.
Additionally, there are much more ancillary data items and sticky options than in RFC 2292, including ancillary  only one.
Thus, it should be natural for application programmers to separate the overriding rule as well.)
An application can also temporarily disable a particular sticky option by specifying a corresponding ancillary data item that could disable the sticky option when being used as an argument for a socket option.
For example, if the application has set IPV6 HOPOPTS as a sticky option and later passes IPV6 HOPOPTS with a zero length as an ancillary data item, the packet will not have a Hop by Hop options header.
Extensions to Socket Ancillary Data
This specification uses ancillary data as defined in Posix with some compatible extensions, which are described in the following subsections.
Section 20 will provide a detailed overview of ancillary data and related structures and macros, including the extensions.
CMSG NXTHDR struct cmsghdr  CMSG NXTHDR(const struct msghdr  mhdr, const struct cmsghdr  cmsg); CMSG NXTHDR()
returns a pointer to the cmsghdr structure describing the next ancillary data object.
Mhdr is a pointer to a msghdr structure and cmsg is a pointer to a cmsghdr structure.
If there is not another ancillary data object, the return value is NULL.
The following behavior of this macro is new to this API: if the value of the cmsg pointer is NULL, a pointer to the cmsghdr structure describing the first ancillary data object is returned.
CMSG NXTHDR(mhdr, NULL) is equivalent to CMSG FIRSTHDR(mhdr).
If there are no ancillary data objects, the return value is NULL.
t CMSG SPACE(socklen t length); This macro is new with this API.
Given the length of an ancillary data object, CMSG SPACE() returns an upper bound on the space required by the object and its cmsghdr structure, including any padding needed to satisfy alignment requirements.
This macro can be used, for example, when allocating space dynamically for the ancillary data.
This macro should not be used to initialize the cmsg len member of a cmsghdr structure; instead use the CMSG LEN() macro.
CMSG LEN socklen t CMSG LEN(socklen t length); This macro is new with this API.
Given the length of an ancillary data object, CMSG LEN() returns the value to store in the cmsg len member of the cmsghdr structure, taking into account any padding needed to satisfy alignment requirements.
Note the difference between CMSG SPACE() and CMSG LEN(), shown also in the figure in Section 20.2:
the former accounts for any required padding at the end of the ancillary data object and the latter is the actual length to store in the cmsg len member of the ancillary data object.
There are five pieces of information that an application can specify for an outgoing packet using ancillary data: 1.
the source IPv6 address, 2.
the outgoing interface index, 3.
the outgoing hop limit, 4.
the next hop address, and 5.
the outgoing traffic class value.
Four similar pieces of information can be returned for a received packet as ancillary data: 1.
the destination IPv6 address, 2.
the arriving interface index, 3.
the arriving hop limit, and 4.
the arriving traffic class value.
The first two pieces of information are contained in an in6 pktinfo structure that is set with setsockopt() or sent as ancillary data with sendmsg() and received as ancillary data with recvmsg().
This structure is defined as a result of including <netinet/in.h
; In the socket option and cmsghdr level will be IPPROTO IPV6, the type will be IPV6 PKTINFO, and the first byte of the option value and cmsg data[] will be the first byte of the in6 pktinfo structure.
An application can clear any sticky IPV6 PKTINFO option by doing a "regular" setsockopt with ipi6 addr being in6addr
any and ipi6 ifindex being zero.
This information is returned as ancillary data by recvmsg() only if the application has enabled the IPV6 RECVPKTINFO socket option:
Some UDP servers want to respond to client requests by sending their reply out the same interface on which the request was received and with the source IPv6 address of the reply equal to the destination IPv6 address of the request.
To do this the application can enable just the IPV6 RECVPKTINFO socket option and then use the received control information from recvmsg() as the outgoing control information for sendmsg().
The application need not examine or modify the in6 pktinfo structure at all.
But if the hop limit were contained in this structure, the application would have to parse the received control information and change the hop limit member, since the received hop limit is not the desired value for an outgoing packet.)
/Receiving the Interface Interfaces on an IPv6 node are identified by a small positive integer, as described in Section 4 of [RFC 3493].
That document also describes a function to map an interface name to its interface index, a function to map an interface index to its interface name, and a function to return all the interface names and indexes.
Notice from this document that no interface is ever assigned an index of 0.
When specifying the outgoing interface, if the ipi6 ifindex value is 0, the kernel will choose the outgoing interface.
The ordering among various options that can specify the outgoing interface, including IPV6 PKTINFO, is defined in Section 6.7.
When the IPV6 RECVPKTINFO socket option is enabled, the received interface index is always returned as the ipi6 ifindex member of the in6 pktinfo structure.
The source IPv6 address can be specified by calling bind() before each output operation, but supplying the source address together with the data requires less overhead (i.e., fewer system calls) and requires less state to be stored and protected in a multithreaded application.
When specifying the source IPv6 address as ancillary data, if the ipi6 addr member of the in6 pktinfo structure is the unspecified address (IN6ADDR ANY INIT or in6addr
(a) if an address is currently bound to the socket, it is used as the source address, or (b) if no address is currently bound to the socket, the kernel will choose the source address.
If the ipi6 addr member is not the unspecified address, but the socket has already bound a source address, then the ipi6 addr value overrides the already bound source address for this output operation only.
The kernel must verify that the requested source address is indeed a unicast address assigned to the node.
When the address is a scoped one, there may be ambiguity about its scope zone.
This is particularly the case for link local addresses.
In such a case, the kernel must first determine the appropriate scope zone based on the zone of the destination address or the outgoing interface (if known), then qualify the address.
This also means that it is not feasible to specify the source address for a non binding socket by the IPV6 PKTINFO sticky option, unless the outgoing interface is also specified.
The application should simply use bind() for such purposes.
IPV6 PKTINFO can also be used as a sticky option for specifying the socket's default source address.
However, the ipi6 addr member must be the unspecified address for TCP sockets, because it is not possible to dynamically change the source address of a TCP connection.
When the IPV6 PKTINFO option is specified for a TCP socket with a non unspecified address, the call will fail.
This restriction should be applied even before the socket binds a specific address.
When the in6 pktinfo structure is returned as ancillary data by recvmsg(), the ipi6 addr member contains the destination IPv6 address from the received packet.
The outgoing hop limit is normally specified with either the IPV6 UNICAST HOPS socket option or the IPV6 MULTICAST HOPS socket option, both of which are described in [RFC 3493].
Specifying the hop limit as ancillary data lets the application override either the kernel's default or a previously specified value, for either a unicast destination or a multicast destination, for a single output operation.
Returning the received hop limit is useful for IPv6 applications that need to verify that the received hop limit is 255 (e.g., that the packet has not been forwarded).
The received hop limit is returned as ancillary data by recvmsg() only if the application has enabled the IPV6 RECVHOPLIMIT socket option:
int  on   1; setsockopt(fd, IPPROTO IPV6, IPV6 RECVHOPLIMIT, &on, sizeof(on)); In the cmsghdr structure containing this ancillary data, the cmsg level member will be IPPROTO IPV6, the cmsg type member will be IPV6 HOPLIMIT, and the first byte of cmsg data[] will be the first byte of the integer hop limit.
Nothing special need be done to specify the outgoing hop limit: just specify the control information as ancillary data for sendmsg().
As specified in [RFC 3493], the interpretation of the integer hop limit value is x <  1:
return an error of EINVAL x    1:
return an error of EINVAL
This API defines IPV6 HOPLIMIT as an ancillary only option, that is, the option name cannot be used as a socket option.
This is because [RFC 3493] has more fine grained socket options
; IPV6 UNICAST HOPS and IPV6 MULTICAST HOPS.
Specifying the Next Hop Address
The IPV6 NEXTHOP ancillary data object specifies the next hop for the datagram as a socket address structure.
In the cmsghdr structure containing this ancillary data, the cmsg level member will be IPPROTO IPV6, the cmsg type member will be IPV6 NEXTHOP, and the first byte of cmsg data[] will be the first byte of the socket address structure.
This is a privileged option.
(Note: It is implementation defined and beyond the scope of this document to define what "privileged" means.
Unix systems use this term to mean the process must have an effective user ID of 0.)
This API only defines the case where the socket address contains an IPv6 address (i.e., the sa family member is AF INET6).
And, in this case, the node identified by that address must be a neighbor of the sending host.
If that address equals the destination IPv6 address of the datagram, then this is equivalent to the existing SO DONTROUTE socket option.
This option does not have any meaning for multicast destinations.
In such a case, the specified next hop will be ignored.
When the outgoing interface is specified by IPV6 PKTINFO as well, the next hop specified by this option must be reachable via the specified interface.
In order to clear a sticky IPV6 NEXTHOP option the application must issue a setsockopt for IPV6 NEXTHOP with a zero length.
Specifying/Receiving the Traffic Class value
The outgoing traffic class is normally set to 0.
Specifying the traffic class as ancillary data lets the application override either the kernel's default or a previously specified value, for either a unicast destination or a multicast destination, for a single output operation.
Returning the received traffic class is useful for programs such as a diffserv debugging tool and for user level ECN (explicit congestion notification) implementation.
The received traffic class is returned as ancillary data by recvmsg() only if the application has enabled the IPV6 RECVTCLASS socket option:
int  on   1; setsockopt(fd, IPPROTO IPV6, IPV6 RECVTCLASS, &on, sizeof(on)); In the cmsghdr structure containing this ancillary data, the cmsg level member will be IPPROTO IPV6, the cmsg type member will be IPV6 TCLASS, and the first byte of cmsg data[] will be the first byte of the integer traffic class.
To specify the outgoing traffic class value, just specify the control information as ancillary data for sendmsg() or using setsockopt().
Just like the hop limit value, the interpretation of the integer traffic class value is x <  1:
return an error of EINVAL x    1:
return an error of EINVAL
In order to clear a sticky IPV6 TCLASS option the application can specify  1 as the value.
There are cases where the kernel needs to control the traffic class value and conflicts with the user specified value on the outgoing traffic.
An example is an implementation of ECN in the kernel, setting 2 bits of the traffic class value.
In such cases, the kernel should override the user specified value.
On the incoming traffic, the kernel may mask some of the bits in the traffic class field.
Additional Errors with sendmsg() and setsockopt()
With the IPV6 PKTINFO socket option there are no additional errors possible with the call to recvmsg().
But when specifying the outgoing interface or the source address, additional errors are possible from sendmsg() or setsockopt().
Note that some implementations might only be able to return this type of errors for setsockopt().
The interface specified by ipi6 ifindex is not enabled for IPv6 use.
EADDRNOTAVAIL ipi6 ifindex specifies an interface but the address ipi6 addr is not available for use on that interface.
No route to the destination exists over the interface specified by ipi6 ifindex.
Summary of Outgoing Interface Selection
This document and [RFC 3493] specify various methods that affect the selection of the packet's outgoing interface.
This subsection summarizes the ordering among those in order to ensure deterministic behavior.
For a given outgoing packet on a given socket, the outgoing interface is determined in the following order: 1.
if an interface is specified in an IPV6 PKTINFO ancillary data item, the interface is used.
otherwise, if an interface is specified in an IPV6 PKTINFO sticky option, the interface is used.
otherwise, if the destination address is a multicast address and the IPV6 MULTICAST IF socket option is specified for the socket, the interface is used.
otherwise, if an IPV6 NEXTHOP ancillary data item is specified, the interface to the next hop is used.
otherwise, if an IPV6 NEXTHOP sticky option is specified, the interface to the next hop is used.
otherwise, the outgoing interface should be determined in an implementation dependent manner.
The ordering above particularly means if the application specifies an interface by the IPV6 MULTICAST IF socket option (described in [RFC  3493]) as well as specifying a different interface by the IPV6 PKTINFO sticky option, the latter will override the former for every multicast packet on the corresponding socket.
The reason for the ordering comes from expectation that the source address is specified as well and that the pair of the address and the outgoing interface should be preferred.
In any case, the kernel must also verify that the source and destination addresses do not break their scope zones with regard to the outgoing interface.
Routing Header Option Source routing in IPv6 is accomplished by specifying a Routing header as an extension header.
There can be different types of Routing headers, but IPv6 currently defines only the Type 0 Routing header [RFC 2460].
This type supports up to 127 intermediate nodes (limited by the length field in the extension header).
With this maximum number of intermediate nodes, a source, and a destination, there are 128 hops.
Source routing with the IPv4 sockets API (the IP OPTIONS socket option) requires the application to build the source route in the format that appears as the IPv4 header option, requiring intimate knowledge of the IPv4 options format.
This IPv6 API, however, defines six functions that the application calls to build and examine a Routing header, and the ability to use sticky options or ancillary data to communicate this information between the application and the kernel using the IPV6 RTHDR option.
Three functions build a Routing header: inet6 rth space
Three functions deal with a returned Routing header:
reverse a Routing header inet6 rth segments() return #segments in a Routing header inet6 rth getaddr
()  fetch one address from a Routing header
The function prototypes for these functions are defined as a result of including <netinet/in.h>.
To receive a Routing header the application must enable the IPV6 RECVRTHDR socket option:
; setsockopt(fd, IPPROTO IPV6, IPV6 RECVRTHDR, &on, sizeof(on)); Each received Routing header is returned as one ancillary data object described by a cmsghdr structure with cmsg type set to IPV6 RTHDR.
When multiple Routing headers are received, multiple ancillary data objects (with cmsg type set to IPV6 RTHDR) will be returned to the application.
To send a Routing header the application specifies it either as ancillary data in a call to sendmsg() or using setsockopt().
For the sending side, this API assumes the number of occurrences of the Routing header as described in [RFC 2460].
That is, applications can only specify at most one outgoing Routing header.
The application can remove any sticky Routing header by calling setsockopt() for IPV6 RTHDR with a zero option length.
When using ancillary data a Routing header is passed between the application and the kernel as follows: The cmsg level member has a value of IPPROTO IPV6 and the cmsg type member has a value of IPV6 RTHDR.
The contents of the cmsg data[] member is implementation dependent and should not be accessed directly by the application, but should be accessed using the six functions that we are about to describe.
The following constant is defined as a result of including the <netinet/in.h>: #
define IPV6 RTHDR TYPE 0    0 /
IPv6 Routing header type 0
When a Routing header is specified, the destination address specified for connect(), sendto(), or sendmsg() is the final destination address of the datagram.
The Routing header then contains the addresses of all the intermediate nodes.
rth space socklen t inet6 rth space(int type, int segments); This function returns the number of bytes required to hold a Routing header of the specified type containing the specified number of segments (addresses).
For an IPv6 Type 0 Routing header, the number of segments must be between 0 and 127, inclusive.
The return value is just the space for the Routing header.
When the application uses ancillary data it must pass the returned length to CMSG SPACE() to determine how much memory is needed for the ancillary data object (including the cmsghdr structure).
If the return value is 0, then either the type of the Routing header is not supported by this implementation or the number of segments is invalid for this type of Routing header.
(Note: This function returns the size but does not allocate the space required for the ancillary data.
This allows an application to allocate a larger buffer, if other ancillary data objects are desired, since all the ancillary data objects must be specified to sendmsg() as a single msg control buffer.)
init(void  bp, socklen t bp len, int type, int segments); This function initializes the buffer pointed to by bp to contain a Routing header of the specified type and sets ip6r len based on the segments parameter.
bp len is only used to verify that the buffer is large enough.
The ip6r segleft field is set to zero;
When the application uses ancillary data the application must initialize any cmsghdr fields.
The caller must allocate the buffer and its size can be determined by calling inet6 rth space().
Upon success the return value is the pointer to the buffer (bp), and this is then used as the first argument to the inet6 rth add() function.
Upon an error the return value is NULL.
bp, const struct in6 addr  addr); This function adds the IPv6 address pointed to by addr to the end of the Routing header being constructed.
If successful, the segleft member of the Routing Header is updated to account for the new address in the Routing header and the return value of the function is 0.
Upon an error the return value of the function is  1. 7.4.
, void  out); This function takes a Routing header extension header (pointed to by the first argument) and writes a new Routing header that sends datagrams along the reverse of that route.
The function reverses the order of the addresses and sets the segleft member in the new Routing header to the number of segments.
Both arguments are allowed to point to the same buffer (that is, the reversal can occur in place).
The return value of the function is 0 on success, or  1 upon an error.
inet6 rth segments int inet6
; This function returns the number of segments (addresses) contained in the Routing header described by bp.
On success the return value is zero or greater.
The return value of the function is  1 upon an error.
rth getaddr struct in6 addr
bp, int index); This function returns a pointer to the IPv6 address specified by index (which must have a value between 0 and one less than the value returned by inet6 rth segments()) in the Routing header described by bp.
An application should first call inet6 rth segments() to obtain the number of segments in the Routing header.
Upon an error the return value of the function is NULL.
A variable number of Hop by Hop options can appear in a single Hop  by Hop options header.
Each option in the header is TLV encoded with a type, length, and value.
This IPv6 API defines seven functions that the application calls to build and examine a Hop by Hop options header, and the ability to use sticky options or ancillary data to communicate this information between the application and the kernel.
This uses the IPV6 HOPOPTS for a Hop by Hop options header.
Today several Hop by Hop options are defined for IPv6.
Two pad options, Pad1 and PadN, are for alignment purposes and are automatically inserted by the inet6 opt XXX() routines and ignored by the inet6 opt XXX() routines on the receive side.
This section of the API is therefore defined for other (and future)
Hop by Hop options that an application may need to specify and receive.
Four functions build an options header:
finish adding TLV options to the options header
()  add one component of the option content to the option Three functions deal with a returned options header:
()  retrieve one component of the option content Individual Hop by Hop options (and Destination options, which are described in Section 9 and are very similar to the Hop by Hop options) may have specific alignment requirements.
For example, the 4 byte Jumbo Payload length should appear on a 4 byte boundary, and IPv6 addresses are normally aligned on an 8 byte boundary.
These requirements and the terminology used with these options are discussed in Section 4.2 and Appendix B of [RFC 2460].
The alignment of first byte of each option is specified by two values, called x and y, written as "xn   y".
This states that the option must appear at an integer multiple of x bytes from the beginning of the options header
(x can have the values 1, 2, 4, or 8), plus y bytes (y can have a value between 0 and 7, inclusive).
The Pad1 and PadN options are inserted as needed to maintain the required alignment.
The functions below need to know the alignment of the end of the option (which is always in the form "xn," where x can have the values 1, 2, 4, or 8) and the total size of the data portion of the option.
These are passed as the "align" and "len" arguments to inet6 opt append().
Multiple Hop by Hop options must be specified by the application by placing them in a single extension header.
Finally, we note that use of some Hop by Hop options or some Destination options, might require special privilege.
That is, normal applications (without special privilege) might be forbidden from setting certain options in outgoing packets, and might never see certain options in received packets.
Receiving Hop by Hop Options To receive a Hop by Hop options header the application must enable the IPV6 RECVHOPOPTS socket option:
int  on   1; setsockopt(fd, IPPROTO IPV6, IPV6 RECVHOPOPTS, &on, sizeof(on)); When using ancillary data a Hop by hop options header is passed between the application and the kernel as follows: The cmsg level member will be IPPROTO IPV6 and the cmsg type member will be IPV6 HOPOPTS.
These options are then processed by calling the inet6 opt next(), inet6 opt find(), and inet6 opt get
val() functions, described in Section 10.
8.2.  Sending Hop by Hop Options
To send a Hop by Hop options header, the application specifies the header either as ancillary data in a call to sendmsg() or using setsockopt().
The application can remove any sticky Hop by Hop options header by calling setsockopt() for IPV6 HOPOPTS with a zero option length.
All the Hop by Hop options must be specified by a single ancillary data object.
The cmsg level member is set to IPPROTO IPV6 and the cmsg type member is set to IPV6 HOPOPTS.
The option is normally constructed using the inet6 opt init(), inet6 opt append(), inet6 opt finish(), and inet6 opt set val() functions, described in Section 10.
Additional errors may be possible from sendmsg() and setsockopt() if the specified option is in error.
Destination Options A variable number of Destination options can appear in one or more Destination options headers.
As defined in [RFC 2460], a Destination options header appearing before a Routing header is processed by the first destination plus any subsequent destinations specified in the Routing header, while a Destination options header that is not followed by a Routing header is processed only by the final destination.
As with the Hop by Hop options, each option in a Destination options header is TLV encoded with a type, length, and value.
Receiving Destination Options To receive Destination options header the application must enable the IPV6 RECVDSTOPTS socket option:
int  on   1; setsockopt(fd, IPPROTO IPV6, IPV6 RECVDSTOPTS, &on, sizeof(on)); Each Destination options header is returned as one ancillary data object described by a cmsghdr structure with cmsg level set to IPPROTO IPV6 and cmsg type set to IPV6 DSTOPTS.
These options are then processed by calling the inet6 opt next(), inet6 opt find(), and inet6 opt get value() functions.
9.2.  Sending Destination Options To send a Destination options header, the application specifies it either as ancillary data in a call to sendmsg() or using setsockopt().
The application can remove any sticky Destination options header by calling setsockopt() for IPV6 RTHDRDSTOPTS/IPV6 DSTOPTS with a zero option length.
This API assumes the ordering about extension headers as described in [RFC 2460].
Thus, one set of Destination options can only appear before a Routing header, and one set can only appear after a Routing header (or in a packet with no Routing header).
Each set can consist of one or more options but each set is a single extension header.
Today all destination options that an application may want to specify can be put after (or without) a Routing header.
Thus, applications should usually need IPV6 DSTOPTS only and should avoid using IPV6 RTHDRDSTOPTS whenever possible.
When using ancillary data a Destination options header is passed between the application and the kernel as follows:
The set preceding a Routing header are specified with the cmsg level member set to IPPROTO IPV6 and the cmsg type member set to IPV6 RTHDRDSTOPTS.
Any setsockopt or ancillary data for IPV6 RTHDRDSTOPTS is silently ignored when sending packets unless a Routing header is also specified.
Note that the "Routing header" here means the one specified by this API.
Even when the kernel inserts a routing header in its internal routine (e.g., in a mobile IPv6 stack), the Destination options header specified by IPV6 RTHDRDSTOPTS will still be ignored unless the application explicitly specifies its own Routing header.
The set of Destination options after a Routing header, which are also used when no Routing header is present, are specified with the cmsg level member is set to IPPROTO IPV6 and the cmsg type member is set to IPV6 DSTOPTS.
The Destination options are normally constructed using the inet6 opt init(), inet6 opt append(), inet6 opt finish(), and inet6 opt set val() functions, described in Section 10.
Additional errors may be possible from sendmsg() and setsockopt() if the specified option is in error.
Hop by Hop and Destination Options Processing Building and parsing the Hop by Hop and Destination options is complicated for the reasons given earlier.
We therefore define a set of functions to help the application.
These functions assume the formatting rules specified in Appendix B in [RFC 2460] i.e., that the largest field is placed last in the option.
The function prototypes for these functions are defined as a result of including <netinet/in.h
The first 3 functions (init, append, and finish) are used both to calculate the needed buffer size for the options, and to actually encode the options once the application has allocated a buffer for the header.
In order to only calculate the size the application must pass a NULL extbuf and a zero extlen to those functions.
inet6 opt init int inet6 opt
extbuf, socklen t extlen); This function returns the number of bytes needed for the empty extension header i.e., without any options.
If extbuf is not NULL it also initializes the extension header to have the correct length field.
In that case if the extlen value is not a positive (i.e., non zero) multiple of 8 the function fails and returns
(Note: since the return value on success is based on a "constant" parameter, i.e., the empty extension header, an implementation may return a constant value.
However, this specification does not require the value be constant, and leaves it as implementation dependent.
The application should not assume a particular constant value as a successful return value of this function.)
inet6 opt append int inet6 opt
, int offset, uint8 t type, socklen t len, uint t align,
void   databufp); Offset should be the length returned by inet6 opt init() or a previous inet6 opt append().
This function returns the updated total length taking into account adding an option with length 'len' and alignment 'align'.
If extbuf is not NULL then, in addition to returning the length, the function inserts any needed pad option, initializes the option (setting the type and length fields) and returns a pointer to the location for the option content in databufp.
If the option does not fit in the extension header buffer the function returns
Type is the 8 bit option type.
Len is the length of the option data (i.e., excluding the option type and option length fields).
Once inet6 opt append() has been called the application can use the databuf directly, or use inet6 opt set val() to specify the content of the option.
The option type must have a value from 2 to 255, inclusive.
(0 and 1 are reserved for the Pad1 and PadN options, respectively.)
The option data length must have a value between 0 and 255, inclusive, and is the length of the option data that follows.
The align parameter must have a value of 1, 2, 4, or 8.
The align value can not exceed the value of len. 10.3.
inet6 opt finish int inet6 opt
extbuf, socklen t extlen, int offset)
; Offset should be the length returned by inet6 opt init() or inet6 opt append().
This function returns the updated total length taking into account the final padding of the extension header to make it a multiple of 8 bytes.
If extbuf is not NULL the function also initializes the option by inserting a Pad1 or PadN option of the proper length.
If the necessary pad does not fit in the extension header buffer the function returns  1. 10.4.
val int inet6 opt set val(void
databuf, int offset, void  val, socklen t vallen); Databuf should be a pointer returned by inet6 opt append().
This function inserts data items of various sizes in the data portion of the option.
Val should point to the data to be inserted.
Offset specifies where in the data portion of the option the value should be inserted; the first byte after the option type and length is accessed by specifying an offset of zero.
The caller should ensure that each field is aligned on its natural boundaries as described in Appendix B of [RFC 2460], but the function must not rely on the caller's behavior.
Even when the alignment requirement is not satisfied, inet6 opt set val
should just copy the data as required.
The function returns the offset for the next field (i.e., offset   vallen) which can be used when composing option content with multiple fields.
, int offset, uint8 t  typep, socklen t  lenp, void   databufp); This function parses received option extension headers returning the next option.
Extbuf and extlen specifies the extension header.
Offset should either be zero (for the first option) or the length returned by a previous call to inet6 opt next() or inet6 opt find().
It specifies the position where to continue scanning the extension buffer.
The next option is returned by updating typep, lenp, and databufp.
Typep stores the option type, lenp stores the length of the option data (i.e., excluding the option type and option length fields), and databufp points the data field of the option.
This function returns the updated "previous" length computed by advancing past the option that was returned.
This returned "previous" length can then be passed to subsequent calls to inet6 opt next().
This function does not return any PAD1 or PADN options.
When there are no more options or if the option extension header is malformed the return value is  1. 10.6.
inet6 opt find int inet6 opt
, int offset, uint8 t type, socklen t  lenp, void   databufp); This function is similar to the previously described inet6 opt next() function, except this function lets the caller specify the option type to be searched for, instead of always returning the next option in the extension header.
If an option of the specified type is located, the function returns the updated "previous" total length computed by advancing past the option that was returned and past any options that didn't match the type.
"previous" length can then be passed to subsequent calls to inet6 opt find() for finding the next occurrence of the same option type.
If an option of the specified type is not located, the return value is  1.
If the option extension header is malformed, the return value is  1.
inet6 opt get val int inet6 opt get val(void
databuf, int offset, void  val, socklen t vallen); Databuf should be a pointer returned by inet6 opt next() or inet6 opt find().
This function extracts data items of various sizes in the data portion of the option.
Val should point to the destination for the extracted data.
Offset specifies from where in the data portion of the option the value should be extracted; the first byte after the option type and length is accessed by specifying an offset of zero.
It is expected that each field is aligned on its natural boundaries as described in Appendix B of [RFC 2460], but the function must not rely on the alignment.
The function returns the offset for the next field (i.e., offset   vallen) which can be used when extracting option content with multiple fields.
Additional Advanced API Functions 11.1.
Sending with the Minimum MTU Unicast applications should usually let the kernel perform path MTU discovery [RFC 1981], as long as the kernel supports it, and should not care about the path MTU.
Some applications, however, might not want to incur the overhead of path MTU discovery, especially if the applications only send a single datagram to a destination.
A potential example is a DNS server.
[RFC 1981] describes how path MTU discovery works for multicast destinations.
From practice in using IPv4 multicast, however, many careless applications that send large multicast packets on the wire have caused implosion of ICMPv4 error messages.
The situation can be worse when there is a filtering node that blocks the ICMPv4 messages.
Though the filtering issue applies to unicast as well, the impact is much larger in the multicast cases.
Thus, applications sending multicast traffic should explicitly enable path MTU discovery only when they understand that the benefit of possibly larger MTU usage outweighs the possible impact of MTU discovery for active sources across the delivery tree(s).
This default behavior is based on the today's practice with IPv4 multicast and path MTU discovery.
The behavior may change in the future once it is found that path MTU discovery effectively works with actual multicast applications and network configurations.
This specification defines a mechanism to avoid path MTU discovery by sending at the minimum IPv6 MTU [RFC 2460].
If the packet is larger than the minimum MTU and this feature has been enabled the IP layer will fragment to the minimum MTU.
To control the policy about path MTU discovery, applications can use the IPV6 USE MIN MTU socket option.
As described above, the default policy should depend on whether the destination is unicast or multicast.
For unicast destinations path MTU discovery should be performed by default.
For multicast destinations path MTU discovery should be disabled by default.
This option thus takes the following three types of integer arguments:  1:
perform path MTU discovery for unicast destinations but do not perform it for multicast destinations.
Packets to multicast destinations are therefore sent with the minimum MTU. 0: always perform path MTU discovery.
1: always disable path MTU discovery and send packets at the minimum MTU.
The default value of this option is  1.
Values other than  1, 0, and 1 are invalid, and an error EINVAL will be returned for those values.
As an example, if a unicast application intentionally wants to disable path MTU discovery, it will add the following lines: int  on   1; setsockopt(fd, IPPROTO IPV6, IPV6 USE MIN MTU, &on, sizeof(on)); Note that this API intentionally excludes the case where the application wants to perform path MTU discovery for multicast but to disable it for unicast.
This is because such usage is not feasible considering a scale of performance issues around whether to do path MTU discovery or not.
When path MTU discovery makes sense to a destination but not to a different destination, regardless of whether the destination is unicast or multicast, applications either need to toggle the option between sending such packets on the same socket, or use different sockets for the two classes of destinations.
This option can also be sent as ancillary data.
In the cmsghdr structure containing this ancillary data, the cmsg level member will be IPPROTO IPV6, the cmsg type member will be IPV6 USE MIN MTU, and the first byte of cmsg data[] will be the first byte of the integer.
In order to provide for easy porting of existing UDP and raw socket applications IPv6 implementations will, when originating packets, automatically insert a fragment header in the packet if the packet is too big for the path MTU.
Some applications might not want this behavior.
An example is traceroute which might want to discover the actual path MTU.
This specification defines a mechanism to turn off the automatic inserting of a fragment header for UDP and raw sockets.
This can be enabled using the IPV6 DONTFRAG socket option.
int on   1; setsockopt(fd, IPPROTO IPV6, IPV6 DONTFRAG, &on, sizeof(on)); By default, this socket option is disabled.
Setting the value to 0 also disables the option i.e., reverts to the default behavior of automatic inserting.
This option can also be sent as ancillary data.
In the cmsghdr structure containing this ancillary data, the cmsg level member will be IPPROTO IPV6, the cmsg type member will be IPV6 DONTFRAG, and the first byte of cmsg data[] will be the first byte of the integer.
This API only specifies the use of this option for UDP and raw sockets, and does not define the usage for TCP sockets.
When the data size is larger than the MTU of the outgoing interface, the packet will be discarded.
Applications can know the result by enabling the IPV6 RECVPATHMTU option described below and receiving the corresponding ancillary data items.
An additional error EMSGSIZE may also be returned in some implementations.
Note, however, that some other implementations might not be able to return this additional error when sending a message.
Path MTU Discovery and UDP UDP and raw socket applications need to be able to  determine the "maximum send transport message size" (Section 5.1 of [RFC 1981]) to a given destination so that those applications can participate in path MTU discovery.
This lets those applications send smaller datagrams to the destination, avoiding fragmentation.
This is accomplished using a new ancillary data item (IPV6 PATHMTU) which is delivered to recvmsg() without any actual data.
The application can enable the receipt of IPV6 PATHMTU ancillary data items by setting the IPV6 RECVPATHMTU socket option.
int  on   1; setsockopt(fd, IPPROTO IPV6, IPV6 RECVPATHMTU, &on, sizeof(on)); By default, this socket option is disabled.
Setting the value to 0 also disables the option.
This API only specifies the use of this option for UDP and raw sockets, and does not define the usage for TCP sockets.
When the application is sending packets too big for the path MTU recvmsg() will return zero (indicating no data) but there will be a cmsghdr with cmsg type set to IPV6 PATHMTU, and cmsg len will indicate that cmsg data is sizeof(struct ip6 mtuinfo)
This can happen when the sending node receives a corresponding
ICMPv6 packet too big error, or when the packet is sent from a socket with the IPV6 DONTFRAG option being on and the packet size is larger than the MTU of the outgoing interface.
This indication is considered as an ancillary data item for a separate (empty) message.
Thus, when there are buffered messages (i.e., messages that the application has not received yet) on the socket the application will first receive the buffered messages and then receive the indication.
The first byte of cmsg data[] will point to a struct ip6 mtuinfo carrying the path MTU to use together with the IPv6 destination address.
; This cmsghdr will be passed to every socket that sets the IPV6 RECVPATHMTU socket option, even if the socket is non connected.
Note that this also means an application that sets the option may receive an IPV6 MTU ancillary data item for each ICMP too big error the node receives, including such ICMP errors caused by other applications on the node.
Thus, an application that wants to perform the path MTU discovery by itself needs to keep history of destinations that it has actually sent to and to compare the address returned in the ip6 mtuinfo structure to the history.
An implementation may choose not to delivery data to a connected socket that has a foreign address that is different than the address specified in the ip6m addr structure.
When an application sends a packet with a routing header, the final destination stored in the ip6m addr member does not necessarily contain complete information of the entire path.
Determining the Current Path MTU
Some applications might need to determine the current path MTU e.g., applications using IPV6 RECVPATHMTU might want to pick a good starting value.
This specification defines a get only socket option to retrieve the current path MTU value for the destination of a given connected socket.
If the IP layer does not have a cached path MTU value it will return the interface MTU for the interface that will be used when sending to the destination address.
This information is retrieved using the IPV6 PATHMTU socket option.
This option takes a pointer to the ip6 mtuinfo structure as the fourth argument, and the size of the structure should be passed as a value result parameter in the fifth argument.
sizeof(mtuinfo); getsockopt(fd, IPPROTO IPV6, IPV6 PATHMTU, &mtuinfo, &infolen); When the call succeeds, the path MTU value is stored in the ip6m mtu member of the ip6 mtuinfo structure.
Since the socket is connected, the ip6m addr member is meaningless and should not be referred to by the application.
This option can only be used for a connected socket, because a non  connected socket does not have the information of the destination and there is no way to pass the destination via getsockopt().
When getsockopt() for this option is issued on a non connected socket, the call will fail.
Despite this limitation, this option is still useful from a practical point of view, because applications that care about the path MTU tend to send a lot of packets to a single destination and to connect the socket to the destination for performance reasons.
If the application needs to get the MTU value in a more generic way, it should use a more generic interface, such as routing sockets [TCPIPILLUST].
Ordering of Ancillary Data and IPv6 Extension Headers
Three IPv6 extension headers can be specified by the application and returned to the application using ancillary data with sendmsg() and recvmsg(): the Routing header, Hop by Hop options header, and Destination options header.
When multiple ancillary data objects are transferred via recvmsg() and these objects represent any of these three extension headers, their placement in the control buffer is directly tied to their location in the corresponding IPv6 datagram.
For example, when the application has enabled the IPV6 RECVRTHDR and IPV6 RECVDSTOPTS options and later receives an IPv6 packet with extension headers in the following order: The IPv6 header A Hop by Hop options header A Destination options header (1)
An Authentication header A Destination options header (2)
A UDP header and UDP data
then the application will receive three ancillary data objects in the following order: an object with cmsg type set to IPV6 DSTOPTS, which represents the destination options header (1) an object with cmsg type set to IPV6 RTHDR, which represents the Routing header an object with cmsg type set to IPV6 DSTOPTS, which represents the destination options header (2)
This example follows the header ordering described in [RFC 2460], but the receiving side of this specification does not assume the ordering.
Applications may receive any numbers of objects in any order according to the ordering of the received IPv6 datagram.
For the sending side, however, this API imposes some ordering constraints according to [RFC 2460].
Applications using this API cannot make a packet with extension headers that do not follow the ordering.
Note, however, that this does not mean applications must always follow the restriction.
This is just a limitation in this API in order to give application programmers a guideline to construct headers in a practical manner.
Should an application need to make an outgoing packet in an arbitrary order about the extension headers, some other technique, such as the datalink interfaces BPF or DLPI, must be used.
The followings are more details about the constraints:  Each IPV6 xxx ancillary data object for a particular type of extension header can be specified at most once in a single control buffer.
IPV6 xxx ancillary data objects can appear in any order in a control buffer, because there is no ambiguity of the ordering.
Each set of IPV6 xxx ancillary data objects and sticky options will be put in the outgoing packet along with the header ordering described in [RFC 2460].
An ancillary data object or a sticky option of IPV6 RTHDRDSTOPTS will affect the outgoing packet only when a Routing header is specified as an ancillary data object or a sticky option.
Otherwise, the specified value for IPV6 RTHDRDSTOPTS will be ignored.
For example, when an application sends a UDP datagram with a control data buffer containing ancillary data objects in the following order: an object with cmsg type set to IPV6 DSTOPTS an object with cmsg type set to IPV6 RTHDRDSTOPTS an object with cmsg type set to IPV6 HOPOPTS and the sending socket does not have any sticky options, then the outgoing packet would be constructed as follows:
The IPv6 header A Hop by Hop options
header A Destination options header A UDP header and UDP data where the destination options header corresponds to the ancillary data object with the type IPV6 DSTOPTS.
Note that the constraints above do not necessarily mean that the outgoing packet sent on the wire always follows the header ordering specified in this API document.
The kernel may insert additional headers that break the ordering as a result.
For example, if the kernel supports Mobile IPv6, an additional destination options header may be inserted before an authentication header, even without a routing header.
This API does not provide access to any other extension headers than the supported three types of headers.
In particular, no information is provided about the IP security headers on an incoming packet, nor can be specified for an outgoing packet.
This API is for applications that do not care about the existence of IP security headers.
IPv6 Specific Options with IPv4 Mapped IPv6 Addresses The various socket options and ancillary data specifications defined in this document apply only to true IPv6 sockets.
It is possible to create an IPv6 socket that actually sends and receives IPv4 packets, using IPv4 mapped IPv6 addresses, but the mapping of the options defined in this document to an IPv4 datagram is beyond the scope of this document.
In general, attempting to specify an IPv6 only option, such as the Hop by Hop options, Destination options, or Routing header on an IPv6 socket that is using IPv4 mapped IPv6 addresses, will probably result in an error.
Some implementations, however, may provide access to the packet information (source/destination address, send/receive interface, and hop limit) on an IPv6 socket that is using IPv4 mapped IPv6 addresses.
Extended interfaces for rresvport, rcmd and rexec Library functions that support the "r" commands hide the creation of a socket and the name resolution procedure from an application.
When the libraries return an AF INET6 socket to an application that do not support the address family, the application may encounter an unexpected result when, e.g., calling getpeername() for the socket.
In order to support AF INET6 sockets for the "r" commands while keeping backward compatibility, this section defines some extensions to the libraries.
The rresvport() function is used by the rcmd() function, and this function is in turn called by many of the "r" commands such as rlogin.
While new applications are not being written to use the rcmd() function, legacy applications such as rlogin will continue to use it and these will be ported to IPv6.
rresvport() creates an IPv4/TCP socket and binds a "reserved port" to the socket.
Instead of defining an IPv6 version of this function we define a new function that takes an address family as its argument.
af(int  port, int family); This function behaves the same as the existing rresvport() function, but instead of creating an AF INET TCP socket, it can also create an AF INET6 TCP socket.
The family argument is either AF INET or AF INET6, and a new error return is EAFNOSUPPORT if the address family is not supported.
(Note: There is little consensus on which header defines the rresvport() and rcmd() function prototypes.
4.4BSD defines it in <unistd.h>, others in <netdb.h>,
and others don't define the function prototypes at all.)
The existing rcmd() function can not transparently use AF INET6 sockets since an application would not be prepared to handle AF INET6 addresses returned by e.g., getpeername() on the file descriptor created by rcmd().
Thus a new function is needed.
int rcmd af(char   ahost, unsigned short rport, const char  locuser, const char
This function behaves the same as the existing rcmd() function, but instead of creating an AF INET TCP socket, it can also create an AF INET6 TCP socket.
The family argument is AF INET, AF INET6, or AF UNSPEC.
When either AF INET or AF INET6 is specified, this function will create a socket of the specified address family.
When AF UNSPEC is specified, it will try all possible address families until a connection can be established, and will return the associated socket of the connection.
A new error EAFNOSUPPORT will be returned if the address family is not supported.
The existing rexec() function can not transparently use AF INET6 sockets since an application would not be prepared to handle AF INET6 addresses returned by e.g., getpeername() on the file descriptor created by rexec().
Thus a new function is needed.
int rexec af(char   ahost, unsigned short rport, const char  name, const char
This function behaves the same as the existing rexec() function, but instead of creating an AF INET TCP socket, it can also create an AF INET6 TCP socket.
The family argument is AF INET, AF INET6, or AF UNSPEC.
When either AF INET or AF INET6 is specified, this function will create a socket of the specified address family.
When AF UNSPEC is specified, it will try all possible address families until a connection can be established, and will return the associated socket of the connection.
A new error EAFNOSUPPORT will be returned if the address family is not supported.
The following list summarizes the constants and structure, definitions discussed in this memo, sorted by header.
/icmp6.h> ICMP6 DST UNREACH ADMIN <netinet/icmp6.h
DST UNREACH NOPORT <netinet/icmp6.h> ICMP6
> ICMP6 PACKET TOO BIG <netinet/icmp6.h
> ICMP6 PARAMPROB HEADER <netinet/icmp6.h
/icmp6.h> ICMP6 PARAMPROB OPTION <netinet/icmp6.h
PARAM PROB <netinet/icmp6.h> ICMP6 ROUTER RENUMBERING <netinet
RR FLAGS FORCEAPPLY <netinet/icmp6.h> ICMP6 RR FLAGS PREVDONE <netinet
RR FLAGS REQRESULT <netinet/icmp6.h> ICMP6 RR FLAGS SPECSITE <netinet/icmp6.h> ICMP6
RR PCOUSE FLAGS DECRPLTIME <netinet/icmp6.h> ICMP6
RR PCOUSE FLAGS DECRVLTIME <netinet/icmp6.h> ICMP6 RR PCOUSE RAFLAGS AUTO <netinet/icmp6.h> ICMP6 RR PCOUSE RAFLAGS ONLINK <netinet/icmp6.h> ICMP6
RR RESULT FLAGS FORBIDDEN <
> ICMP6 TIME EXCEEDED <netinet
> ICMP6 TIME EXCEED REASSEMBLY <netinet/icmp6.h> ICMP6 TIME EXCEED TRANSIT <netinet
ND NA FLAG ROUTER <netinet/icmp6.h
ND NA FLAG SOLICITED <netinet/icmp6.h
> ND OPT MTU <netinet/icmp6.h
ND OPT PI FLAG AUTO
ND OPT PI FLAG ONLINK <netinet/icmp6.h
ND OPT PREFIX INFORMATION <netinet/icmp6.h
ND OPT REDIRECTED HEADER <netinet/icmp6.h
ND OPT SOURCE LINKADDR <netinet/icmp6.h
> ND OPT TARGET LINKADDR <netinet/icmp6.h
> ND RA FLAG OTHER <netinet/icmp6.h
ND ROUTER SOLICIT <netinet/icmp6.h> struct icmp6 filter{};
IPV6 RTHDR TYPE 0 <
; The following list summarizes the function and macro prototypes discussed in this memo, sorted by header.
SETBLOCK(int, struct icmp6 filter  );
int inet6 opt get val(void  , int, void  , socklen t); <netinet/in.h>
find(void  , socklen t, int, uint8 t ,
finish(void  , socklen t, int)
next(void  , socklen t, int, uint8 t  , socklen t
int inet6 opt set val(void  , int, void  , socklen t); <netinet/in.h>
init(void  , socklen t, int, int)
inet6 rth space(int, int); <netinet/ip6.h
socklen t CMSG LEN(socklen t); <sys/socket.h>
socklen t CMSG SPACE(socklen t)
int rresvport af(int  , int); <unistd.h>
The setting of certain Hop by Hop options and Destination options may be restricted to privileged processes.
Similarly some Hop by Hop options and Destination options may not be returned to non privileged applications.
The ability to specify an arbitrary source address using IPV6 PKTINFO must be prevented; at least for non privileged processes.
Significant changes that affect the compatibility to RFC 2292:  Removed the IPV6 PKTOPTIONS socket option by allowing sticky options to be set with individual setsockopt() calls.
Removed the ability to be able to specify Hop by Hop and Destination options using multiple ancillary data items.
The application, using the inet6 opt xxx() routines (see below), is responsible for formatting the whole extension header.
Removed the support for the loose/strict Routing header since that has been removed from the IPv6 specification.
Loosened the constraints for jumbo payload option that this option was always hidden from applications.
Disabled the use of the IPV6 HOPLIMIT sticky option.
Removed ip6r0 addr field from the ip6 rthdr structure.
Intentionally unspecified how to get received packet's information on TCP sockets.
New features:  Added IPV6 RTHDRDSTOPTS to specify a Destination Options header before the Routing header.
Added separate IPV6 RECVxxx options to enable the receipt of the corresponding ancillary data items.
() and inet6 opt xxx() functions to deal with routing or IPv6 options headers.
Added extensions of libraries for the "r" commands.
Introduced additional IPv6 option definitions such as IP6OPT PAD1.
Added MLD and router renumbering definitions.
Added MTU related socket options and ancillary data items.
Added options and ancillary data items to manipulate the traffic class field.
Changed the name of ICMPv6 unreachable code 2 to be "beyond scope of source address.
DST UNREACH NOTNEIGHBOR was removed with this change.
Clarifications:  Added clarifications on extension headers ordering; for the sending side, assume the recommended ordering described in RFC 2460.
For the receiving side, do not assume any ordering and pass all headers to the application in the received order.
Added a summary about the interface selection rule.
Clarified the ordering between IPV6 MULTICAST IF and the IPV6 PKTINFO sticky option for multicast packets.
Clarified how sticky options and the ICMPv6 filter are turned off and that getsockopt() of a sticky option returns what was set with setsockopt().
Clarified that IPV6 NEXTHOP should be ignored for a multicast destination, that it should not contradict with the specified outgoing interface, and that the next hop should be a sockaddr in6 structure.
Clarified corner cases of IPV6 CHECKSUM.
Aligned with the POSIX standard.
(since this is an informational document).
Revised abstract to be more clear and concise, particularly concentrating on differences from RFC 2292.
Made the URL of assigned numbers less specific so that it would be more robust for future changes.
Updated the reference to the basic API.
Added a reference to the latest POSIX standard.
Moved general specifications of ancillary data and CMSG macros to the appendix.
Ancillary Data Overview 4.2BSD allowed file descriptors to be transferred between separate processes across a UNIX domain socket using the sendmsg() and recvmsg() functions.
Two members of the msghdr structure, msg accrights and msg accrightslen, were used to send and receive the descriptors.
When the OSI protocols were added to 4.3BSD Reno in 1990
the names of these two fields in the msghdr structure were changed to msg control and msg controllen, because they were used by the OSI protocols for "control information", although the comments in the source code call this "ancillary data".
Other than the OSI protocols, the use of ancillary data has been rare.
In 4.4BSD, for example, the only use of ancillary data with IPv4 is to return the destination address of a received UDP datagram if the IP RECVDSTADDR socket option is set.
With Unix domain sockets ancillary data is still used to send and receive descriptors.
Nevertheless the ancillary data fields of the msghdr structure provide a clean way to pass information in addition to the data that is being read or written.
The inclusion of the msg control and msg controllen members of the msghdr structure along with the cmsghdr structure that is pointed to by the msg control member is required by the Posix sockets API standard.
The msghdr structure is used by the recvmsg() and sendmsg() functions.
# elements in msg iov
Earlier drafts of Posix had the two socklen t members as size t, but it then changed these to socklen t to simplify binary portability for 64 bit implementations and to align Posix with X/Open's Networking Services, Issue 5.
The change in msg control to a "void  " pointer
affects any code that increments this pointer.)
Most Berkeley derived implementations limit the amount of ancillary data in a call to sendmsg() to no more than 108 bytes (an mbuf).
This API requires a minimum of 10240 bytes of ancillary data, but it is recommended that the amount be limited only by the buffer space reserved by the socket (which can be modified by the SO SNDBUF socket option).
(Note: This magic number 10240 was picked as a value that should always be large enough.
108 bytes is clearly too small as the maximum size of a Routing header is 2048 bytes.)
The cmsghdr structure describes ancillary data objects transferred by recvmsg() and sendmsg().
Before Posix the cmsg len member was an integer, and not a socklen
See the Note in the previous section for why socklen t is used here.)
As shown in this definition, normally there is no member with the name cmsg data[].
Instead, the data portion is accessed using the CMSG xxx()
macros, as described in Section 20.3.
Nevertheless, it is common to refer to the cmsg data[] member.
When ancillary data is sent or received, any number of ancillary data objects can be specified by the msg control and msg controllen members of the msghdr structure, because each object is preceded by a cmsghdr structure defining the object's length (the cmsg len member).
Historically Berkeley derived implementations have passed only one object at a time, but this API allows multiple objects to be passed in a single call to sendmsg() or recvmsg().
The following example shows two ancillary data objects in a control buffer.
len   level type  XX    data[]
XX len   level type  XX   data
The fields shown as "XX" are possible padding, between the cmsghdr structure and the data, and between the data and the next cmsghdr structure, if required by the implementation.
While sending an application may or may not include padding at the end of last ancillary data in msg controllen and implementations must accept both as valid.
On receiving a portable application must provide space for padding at the end of the last ancillary data as implementations may copy out the padding at the end of the control message buffer and include it in the received msg controllen.
When recvmsg() is called if msg controllen is too small for all the ancillary data items including any trailing padding after the last item an implementation may set MSG CTRUNC.
To aid in the manipulation of ancillary data objects, three macros from 4.4BSD are defined by Posix: CMSG DATA(), CMSG NXTHDR(), and CMSG FIRSTHDR().
Before describing these macros, we show the following example of how they might be used with a call to recvmsg().
struct msghdr   msg; struct cmsghdr
; cmsgptr   CMSG NXTHDR(&msg, cmsgptr))
} We now describe the three Posix macros, followed by two more that are new with this API: CMSG SPACE() and CMSG LEN().
All these macros are defined as a result of including <sys/socket.h
CMSG FIRSTHDR(const struct msghdr  mhdr); CMSG FIRSTHDR() returns a pointer to the first cmsghdr structure in the msghdr structure pointed to by mhdr.
The macro returns NULL if there is no ancillary data pointed to by the msghdr structure (that is, if either msg control is NULL or if msg controllen is less than the size of a cmsghdr structure).
One possible implementation could be #
msg controllen >  sizeof(struct cmsghdr) ?
Most existing implementations do not test the value of msg controllen, and just return the value of msg control.
The value of msg controllen must be tested, because if the application asks recvmsg() to return ancillary data, by setting msg control to point to the application's buffer and setting msg controllen to the length of this buffer, the kernel indicates that no ancillary data is available by setting msg controllen to 0 on return.
It is also easier to put this test into this macro, than making the application perform the test.)
As described in Section 5.1, CMSG NXTHDR has been extended to handle a NULL 2nd argument to mean "get the first header".
This provides an alternative way of coding the processing loop shown earlier: struct msghdr  msg; struct cmsghdr
The macros ALIGN H() and ALIGN D(), which are implementation dependent, round their arguments up to the next even multiple of whatever alignment is required for the start of the cmsghdr structure and the data, respectively.
(This is probably a multiple of 4 or 8 bytes.)
They are often the same macro in implementations platforms where alignment requirement for header and data is chosen to be identical.
CMSG DATA(const struct cmsghdr  cmsg); CMSG DATA() returns a pointer to the data (what is called the cmsg data[] member, even though such a member is not defined in the structure) following a cmsghdr structure.
One possible implementation could be: #define CMSG DATA(cmsg)
CMSG SPACE CMSG SPACE is new with this API (see Section 5.2).
It is used to determine how much space needs to be allocated for an ancillary data item.
One possible implementation could be: #define CMSG SPACE(length)
CMSG LEN CMSG LEN is new with this API (see Section 5.3).
It  returns the value to store in the cmsg len member of the cmsghdr structure, taking into account any padding needed to satisfy alignment requirements.
One possible implementation could be: #define CMSG LEN(length)
Examples Using the inet6 rth
Here we show an example for both sending Routing headers and processing and reversing a received Routing header.
As an example of these Routing header functions defined in this document, we go through the function calls for the example on p. 17 of [RFC 2460].
The source is S, the destination is D, and the three intermediate nodes are I1, I2, and I3.
3 src and dst are the source and destination IPv6 addresses in the IPv6 header.
, A[2], and A[3] are the three addresses in the Routing header.
#seg is the Segments Left field in the Routing header.
The six values in the column beneath node S are the values in the Routing header specified by the sending application using sendmsg() of setsockopt().
The function calls by the sender would look like: void   extptr; socklen t   extlen; struct msghdr  msg; struct cmsghdr
cmsgptr; int   cmsglen; struct sockaddr in6  I1, I2, I3, D;
rth space(IPV6 RTHDR TYPE 0, 3)
; cmsglen   CMSG SPACE(extlen); cmsgptr   malloc(cmsglen); cmsgptr cmsg len   CMSG LEN(extlen); cmsgptr cmsg level   IPPROTO IPV6; cmsgptr cmsg type
IPV6 RTHDR; extptr   CMSG DATA(cmsgptr); extptr
, IPV6 RTHDR TYPE 0, 3);
inet6 rth add(extptr, &I1.sin6 addr);
inet6 rth add(extptr, &I2.sin6 addr);
inet6 rth add(extptr, &I3.sin6 addr); msg.msg control   cmsgptr; msg.msg controllen   cmsglen
/ We also assume that the source address for the socket is not specified (i.e., the asterisk in the figure).
The four columns of six values that are then shown between the five nodes are the values of the fields in the packet while the packet is in transit between the two nodes.
that before the packet is sent by the source node S, the source address is chosen (replacing the asterisk), I1 becomes the destination address of the datagram, the two addresses A[2] and A[3] are "shifted up", and D is moved to A[3].
The columns of values that are shown beneath the destination node are the values returned by recvmsg(), assuming the application has enabled both the IPV6 RECVPKTINFO and IPV6 RECVRTHDR socket options.
The source address is S (contained in the sockaddr in6 structure pointed to by the msg name member), the destination address is D (returned as an ancillary data object in an in6 pktinfo structure), and the ancillary data object specifying the Routing header will contain three addresses (I1, I2, and I3).
The number of segments in the Routing header is known from the Hdr Ext Len field in the Routing header (a value of 6, indicating 3 addresses).
The return value from inet6 rth segments() will be 3 and inet6 rth getaddr(0) will return I1, inet6 rth getaddr(1) will return I2, and inet6
rth getaddr(2) will return I3, If the receiving application then calls inet6 rth reverse(), the order of the three addresses will become I3, I2, and I1.
We can also show what an implementation might store in the ancillary data object as the Routing header is being built by the sending process.
If we assume a 32 bit architecture where sizeof(struct cmsghdr) equals 12, with a desired alignment of 4 byte boundaries, then the call to inet6 rth space(3) returns 68: 12 bytes for the cmsghdr structure and 56 bytes for the Routing header (8   3 16).
The first call to inet6
rth add() adds I1 to the list.
cmsg len is incremented by 16, and the Segments Left field is incremented by 1.
The next call to inet6
rth add() adds I2 to the list.
cmsg len is incremented by 16, and the Segments Left field is incremented by 1.
The last call to inet6
() adds I3 to the list.
cmsg len is incremented by 16, and the Segments Left field is incremented by 1. 21.2.
This example assumes that the application has enabled IPV6 RECVRTHDR socket option.
The application prints and reverses a source route and uses that to echo the received data.
CMSG DATA(cmsgptr); msg.msg control   cmsgptr; msg.msg controllen   cmsgspace; msg.msg name
0 && cmsgptr cmsg level
IPPROTO IPV6 && cmsgptr cmsg type
{ struct in6 addr  in6; char asciiname[INET6 ADDRSTRLEN]; struct ip6 rthdr  rthdr
getaddr(extptr, i); if (in6   NULL)
The above example is a simple illustration.
It skips some error checks, including those involving the MSG TRUNC and MSG CTRUNC flags.
It also leaves some type mismatches in favor of brevity.
Examples Using the inet6 opt XXX() Functions
This shows how Hop by Hop and Destination options can be both built as well as parsed using the inet6 opt XXX() functions.
These examples assume that there are defined values for OPT X and OPT Y. Note: The example is a simple illustration.
It skips some error checks and leaves some type mismatches in favor of brevity.
We now provide an example that builds two Hop by Hop options using the example in Appendix B of [RFC 2460].
socklen t extlen; int currentlen
; void  databuf; int offset; uint8 t value1; uint16 t value2; uint32 t value4; uint64 t value8
inet6 opt init(NULL, 0); if (currentlen    1) return ( 1); currentlen   inet6 opt append(NULL, 0, currentlen, OPT X, 12, 8, NULL); if (currentlen    1) return ( 1); currentlen   inet6 opt append(NULL, 0, currentlen, OPT Y, 7, 4, NULL); if (currentlen    1)
inet6 opt finish(NULL, 0, currentlen);
if (currentlen    1) return ( 1); extlen   currentlen; extbuf
/ offset   0; value4   0x12345678
; offset   inet6 opt set val(databuf, offset, &value4, sizeof (value4))
for 8 octet field  / value8   0x0102030405060708; offset   inet6 opt set val(databuf, offset, &value8, sizeof (value8)); currentlen   inet6 opt append(extbuf, extlen, currentlen, OPT Y, 7, 4, &databuf); if (currentlen    1)
; offset   inet6 opt set val(databuf, offset, &value1, sizeof (value1))
This example parses and prints the content of the two options in the previous example.
extbuf, socklen t extlen) { struct ip6 dest  ext;
int currentlen; uint8 t type; socklen t len
; void  databuf; int offset;
uint8 t value1; uint16 t value2; uint32 t value4; uint64 t value8; ext
(struct ip6 dest  )extbuf; printf("nxt %u, len %u (bytes %d)\n", ext ip6d nxt, ext ip6d len, (ext ip6d len   1)   8); currentlen   0; while (1) { currentlen
inet6 opt next(extbuf, extlen, currentlen, &type, &len, &databuf)
; if (currentlen    1) break; printf("Received opt %u len %u\n", type, len); switch (type) { case OPT X:
inet6 opt get val(databuf, offset, &value4, sizeof (value4))
; printf("X 4 byte field %x\n", value4); offset   inet6 opt get val(databuf, offset, &value8, sizeof (value8)); printf("X 8 byte field %llx\n", value8); break; case OPT Y: offset   0; offset
inet6 opt get val(databuf, offset, &value1, sizeof (value1)); printf("Y 1 byte field %x\n", value1); offset
inet6 opt get val(databuf, offset, &value2, sizeof (value2)); printf("Y 2 byte field %x\n", value2); offset
