- title: __initial_text__
  contents:
  - '                  Stream Control Transmission Protocol

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2000).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes the Stream Control Transmission Protocol\n\
    \   (SCTP).  SCTP is designed to transport PSTN signaling messages over\n   IP\
    \ networks, but is capable of broader applications.\n   SCTP is a reliable transport\
    \ protocol operating on top of a\n   connectionless packet network such as IP.\
    \  It offers the following\n   services to its users:\n      -- acknowledged error-free\
    \ non-duplicated transfer of user data,\n      -- data fragmentation to conform\
    \ to discovered path MTU size,\n      -- sequenced delivery of user messages within\
    \ multiple streams,\n         with an option for order-of-arrival delivery of\
    \ individual user\n         messages,\n      -- optional bundling of multiple\
    \ user messages into a single SCTP\n         packet, and\n      -- network-level\
    \ fault tolerance through supporting of multi-\n         homing at either or both\
    \ ends of an association.\n   The design of SCTP includes appropriate congestion\
    \ avoidance behavior\n   and resistance to flooding and masquerade attacks.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction..................................................\
    \  5\n     1.1 Motivation..................................................  6\n\
    \     1.2 Architectural View of SCTP..................................  6\n  \
    \   1.3 Functional View of SCTP.....................................  7\n    \
    \   1.3.1 Association Startup and Takedown........................  8\n      \
    \ 1.3.2 Sequenced Delivery within Streams.......................  9\n       1.3.3\
    \ User Data Fragmentation.................................  9\n       1.3.4 Acknowledgement\
    \ and Congestion Avoidance................  9\n       1.3.5 Chunk Bundling .........................................\
    \ 10\n       1.3.6 Packet Validation....................................... 10\n\
    \       1.3.7 Path Management......................................... 11\n  \
    \   1.4 Key Terms................................................... 11\n    \
    \ 1.5 Abbreviations............................................... 15\n     1.6\
    \ Serial Number Arithmetic.................................... 15\n   2. Conventions....................................................\
    \ 16\n   3.  SCTP packet Format............................................ 16\n\
    \     3.1 SCTP Common Header Field Descriptions....................... 17\n  \
    \   3.2 Chunk Field Descriptions.................................... 18\n    \
    \   3.2.1 Optional/Variable-length Parameter Format............... 20\n     3.3\
    \ SCTP Chunk Definitions...................................... 21\n       3.3.1\
    \ Payload Data (DATA)..................................... 22\n       3.3.2 Initiation\
    \ (INIT)....................................... 24\n         3.3.2.1 Optional\
    \ or Variable Length Parameters.............. 26\n       3.3.3 Initiation Acknowledgement\
    \ (INIT ACK)................... 30\n         3.3.3.1 Optional or Variable Length\
    \ Parameters.............. 33\n       3.3.4 Selective Acknowledgement (SACK)........................\
    \ 33\n       3.3.5 Heartbeat Request (HEARTBEAT)........................... 37\n\
    \       3.3.6 Heartbeat Acknowledgement (HEARTBEAT ACK)............... 38\n  \
    \     3.3.7 Abort Association (ABORT)............................... 39\n    \
    \   3.3.8 Shutdown Association (SHUTDOWN)......................... 40\n      \
    \ 3.3.9 Shutdown Acknowledgement (SHUTDOWN ACK)................. 40\n       3.3.10\
    \ Operation Error (ERROR)................................ 41\n         3.3.10.1\
    \ Invalid Stream Identifier.......................... 42\n         3.3.10.2 Missing\
    \ Mandatory Parameter........................ 43\n         3.3.10.3 Stale Cookie\
    \ Error................................. 43\n         3.3.10.4 Out of Resource....................................\
    \ 44\n         3.3.10.5 Unresolvable Address............................... 44\n\
    \         3.3.10.6 Unrecognized Chunk Type............................ 44\n  \
    \       3.3.10.7 Invalid Mandatory Parameter........................ 45\n    \
    \     3.3.10.8 Unrecognized Parameters............................ 45\n      \
    \   3.3.10.9 No User Data....................................... 46\n        \
    \ 3.3.10.10 Cookie Received While Shutting Down............... 46\n       3.3.11\
    \ Cookie Echo (COOKIE ECHO).............................. 46\n       3.3.12 Cookie\
    \ Acknowledgement (COOKIE ACK).................... 47\n       3.3.13 Shutdown\
    \ Complete (SHUTDOWN COMPLETE).................. 48\n   4. SCTP Association State\
    \ Diagram................................. 48\n   5. Association Initialization.....................................\
    \ 52\n     5.1 Normal Establishment of an Association...................... 52\n\
    \       5.1.1 Handle Stream Parameters................................ 54\n  \
    \     5.1.2 Handle Address Parameters............................... 54\n    \
    \   5.1.3 Generating State Cookie................................. 56\n      \
    \ 5.1.4 State Cookie Processing................................. 57\n       5.1.5\
    \ State Cookie Authentication............................. 57\n       5.1.6 An\
    \ Example of Normal Association Establishment.......... 58\n     5.2 Handle Duplicate\
    \ or unexpected INIT, INIT ACK, COOKIE ECHO,\n         and COOKIE ACK..............................................\
    \ 60\n       5.2.1 Handle Duplicate INIT in COOKIE-WAIT\n             or COOKIE-ECHOED\
    \ States................................. 60\n       5.2.2 Unexpected INIT in\
    \ States Other than CLOSED,\n             COOKIE-ECHOED, COOKIE-WAIT and SHUTDOWN-ACK-SENT........\
    \ 61\n       5.2.3 Unexpected INIT ACK..................................... 61\n\
    \       5.2.4 Handle a COOKIE ECHO when a TCB exists.................. 62\n  \
    \       5.2.4.1 An Example of a Association Restart................. 64\n    \
    \   5.2.5 Handle Duplicate COOKIE ACK............................. 66\n      \
    \ 5.2.6 Handle Stale COOKIE Error............................... 66\n     5.3\
    \ Other Initialization Issues................................. 67\n       5.3.1\
    \ Selection of Tag Value.................................. 67\n   6. User Data\
    \ Transfer............................................. 67\n     6.1 Transmission\
    \ of DATA Chunks................................. 69\n     6.2 Acknowledgement\
    \ on Reception of DATA Chunks................. 70\n       6.2.1 Tracking Peer's\
    \ Receive Buffer Space.................... 73\n     6.3 Management Retransmission\
    \ Timer............................. 75\n       6.3.1 RTO Calculation.........................................\
    \ 75\n       6.3.2 Retransmission Timer Rules.............................. 76\n\
    \       6.3.3 Handle T3-rtx Expiration................................ 77\n  \
    \   6.4 Multi-homed SCTP Endpoints.................................. 78\n    \
    \   6.4.1 Failover from Inactive Destination Address.............. 79\n     6.5\
    \ Stream Identifier and Stream Sequence Number................ 80\n     6.6 Ordered\
    \ and Unordered Delivery.............................. 80\n     6.7 Report Gaps\
    \ in Received DATA TSNs........................... 81\n     6.8 Adler-32 Checksum\
    \ Calculation............................... 82\n     6.9 Fragmentation...............................................\
    \ 83\n     6.10 Bundling .................................................. 84\n\
    \   7. Congestion Control   .......................................... 85\n  \
    \   7.1 SCTP Differences from TCP Congestion Control................ 85\n    \
    \ 7.2 SCTP Slow-Start and Congestion Avoidance.................... 87\n      \
    \ 7.2.1 Slow-Start.............................................. 87\n       7.2.2\
    \ Congestion Avoidance.................................... 89\n       7.2.3 Congestion\
    \ Control...................................... 89\n       7.2.4 Fast Retransmit\
    \ on Gap Reports.......................... 90\n     7.3 Path MTU Discovery..........................................\
    \ 91\n   8.  Fault Management.............................................. 92\n\
    \     8.1 Endpoint Failure Detection.................................. 92\n  \
    \   8.2 Path Failure Detection...................................... 92\n    \
    \ 8.3 Path Heartbeat.............................................. 93\n     8.4\
    \ Handle \"Out of the blue\" Packets............................ 95\n     8.5\
    \ Verification Tag............................................ 96\n       8.5.1\
    \ Exceptions in Verification Tag Rules.................... 97\n   9. Termination\
    \ of Association..................................... 98\n     9.1 Abort of an\
    \ Association..................................... 98\n     9.2 Shutdown of an\
    \ Association.................................. 98\n   10. Interface with Upper\
    \ Layer....................................101\n     10.1 ULP-to-SCTP................................................101\n\
    \     10.2 SCTP-to-ULP................................................111\n  \
    \ 11. Security Considerations.......................................114\n    \
    \ 11.1 Security Objectives........................................114\n     11.2\
    \ SCTP Responses To Potential Threats........................115\n       11.2.1\
    \ Countering Insider Attacks.............................115\n       11.2.2 Protecting\
    \ against Data Corruption in the Network......115\n       11.2.3 Protecting Confidentiality.............................115\n\
    \       11.2.4 Protecting against Blind Denial of Service Attacks.....116\n  \
    \       11.2.4.1 Flooding...........................................116\n    \
    \     11.2.4.2 Blind Masquerade...................................118\n      \
    \   11.2.4.3 Improper Monopolization of Services................118\n     11.3\
    \ Protection against Fraud and Repudiation...................119\n   12. Recommended\
    \ Transmission Control Block (TCB) Parameters.......120\n     12.1 Parameters\
    \ necessary for the SCTP instance.................120\n     12.2 Parameters necessary\
    \ per association (i.e. the TCB)........120\n     12.3 Per Transport Address Data.................................122\n\
    \     12.4 General Parameters Needed..................................123\n  \
    \ 13. IANA Considerations...........................................123\n    \
    \ 13.1 IETF-defined Chunk Extension...............................123\n     13.2\
    \ IETF-defined Chunk Parameter Extension.....................124\n     13.3 IETF-defined\
    \ Additional Error Causes.......................124\n     13.4 Payload Protocol\
    \ Identifiers...............................125\n   14. Suggested SCTP Protocol\
    \ Parameter Values......................125\n   15. Acknowledgements..............................................126\n\
    \   16. Authors' Addresses............................................126\n  \
    \ 17. References....................................................128\n   18.\
    \ Bibliography..................................................129\n   Appendix\
    \ A .......................................................131\n   Appendix B\
    \ .......................................................132\n   Full Copyright\
    \ Statement .........................................134\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   This section explains the reasoning behind the development\
    \ of the\n   Stream Control Transmission Protocol (SCTP), the services it offers,\n\
    \   and the basic concepts needed to understand the detailed description\n   of\
    \ the protocol.\n"
- title: 1.1 Motivation
  contents:
  - "1.1 Motivation\n   TCP [RFC793] has performed immense service as the primary\
    \ means of\n   reliable data transfer in IP networks.  However, an increasing\
    \ number\n   of recent applications have found TCP too limiting, and have\n  \
    \ incorporated their own reliable data transfer protocol on top of UDP\n   [RFC768].\
    \  The limitations which users have wished to bypass include\n   the following:\n\
    \      -- TCP provides both reliable data transfer and strict order-of-\n    \
    \  transmission delivery of data.  Some applications need reliable\n      transfer\
    \ without sequence maintenance, while others would be\n      satisfied with partial\
    \ ordering of the data.  In both of these\n      cases the head-of-line blocking\
    \ offered by TCP causes unnecessary\n      delay.\n      -- The stream-oriented\
    \ nature of TCP is often an inconvenience.\n      Applications must add their\
    \ own record marking to delineate their\n      messages, and must make explicit\
    \ use of the push facility to\n      ensure that a complete message is transferred\
    \ in a reasonable\n      time.\n      -- The limited scope of TCP sockets complicates\
    \ the task of\n      providing highly-available data transfer capability using\
    \ multi-\n      homed hosts.\n      -- TCP is relatively vulnerable to denial\
    \ of service attacks, such\n      as SYN attacks.\n   Transport of PSTN signaling\
    \ across the IP network is an application\n   for which all of these limitations\
    \ of TCP are relevant.  While this\n   application directly motivated the development\
    \ of SCTP, other\n   applications may find SCTP a good match to their requirements.\n"
- title: 1.2 Architectural View of SCTP
  contents:
  - "1.2 Architectural View of SCTP\n   SCTP is viewed as a layer between the SCTP\
    \ user application (\"SCTP\n   user\" for short) and a connectionless packet network\
    \ service such as\n   IP.  The remainder of this document assumes SCTP runs on\
    \ top of IP.\n   The basic service offered by SCTP is the reliable transfer of\
    \ user\n   messages between peer SCTP users.  It performs this service within\n\
    \   the context of an association between two SCTP endpoints. Section 10\n   of\
    \ this document sketches the API which should exist at the boundary\n   between\
    \ the SCTP and the SCTP user layers.\n   SCTP is connection-oriented in nature,\
    \ but the SCTP association is a\n   broader concept than the TCP connection. \
    \ SCTP provides the means for\n   each SCTP endpoint (Section 1.4) to provide\
    \ the other endpoint\n   (during association startup) with a list of transport\
    \ addresses\n   (i.e., multiple IP addresses in combination with an SCTP port)\n\
    \   through which that endpoint can be reached and from which it will\n   originate\
    \ SCTP packets.  The association spans transfers over all of\n   the possible\
    \ source/destination combinations which may be generated\n   from each endpoint's\
    \ lists.\n       _____________                                      _____________\n\
    \      |  SCTP User  |                                    |  SCTP User  |\n  \
    \    | Application |                                    | Application |\n    \
    \  |-------------|                                    |-------------|\n      |\
    \    SCTP     |                                    |    SCTP     |\n      |  Transport\
    \  |                                    |  Transport  |\n      |   Service   |\
    \                                    |   Service   |\n      |-------------|  \
    \                                  |-------------|\n      |             |One or\
    \ more    ----      One or more|             |\n      | IP Network  |IP address\
    \      \\/        IP address| IP Network  |\n      |   Service   |appearances\
    \     /\\       appearances|   Service   |\n      |_____________|            \
    \   ----                 |_____________|\n        SCTP Node A |<-------- Network\
    \ transport ------->| SCTP Node B\n                        Figure 1: An SCTP Association\n"
- title: 1.3 Functional View of SCTP
  contents:
  - "1.3 Functional View of SCTP\n   The SCTP transport service can be decomposed\
    \ into a number of\n   functions.  These are depicted in Figure 2 and explained\
    \ in the\n   remainder of this section.\n                           SCTP User\
    \ Application\n         -----------------------------------------------------\n\
    \          _____________                  ____________________\n         |   \
    \          |                | Sequenced delivery |\n         | Association | \
    \               |   within streams   |\n         |             |             \
    \   |____________________|\n         |   startup   |\n         |             |\
    \         ____________________________\n         |     and     |        |    User\
    \ Data Fragmentation |\n         |             |        |____________________________|\n\
    \         |   takedown  |\n         |             |         ____________________________\n\
    \         |             |        |     Acknowledgement        |\n         |  \
    \           |        |          and               |\n         |             |\
    \        |    Congestion Avoidance    |\n         |             |        |____________________________|\n\
    \         |             |\n         |             |         ____________________________\n\
    \         |             |        |       Chunk Bundling       |\n         |  \
    \           |        |____________________________|\n         |             |\n\
    \         |             |     ________________________________\n         |   \
    \          |    |      Packet Validation         |\n         |             | \
    \   |________________________________|\n         |             |\n         | \
    \            |     ________________________________\n         |             |\
    \    |     Path Management            |\n         |_____________|    |________________________________|\n\
    \           Figure 2: Functional View of the SCTP Transport Service\n"
- title: 1.3.1 Association Startup and Takedown
  contents:
  - "1.3.1 Association Startup and Takedown\n   An association is initiated by a request\
    \ from the SCTP user (see the\n   description of the ASSOCIATE (or SEND) primitive\
    \ in Section 10).\n   A cookie mechanism, similar to one described by Karn and\
    \ Simpson in\n   [RFC2522], is employed during the initialization to provide\n\
    \   protection against security attacks.  The cookie mechanism uses a\n   four-way\
    \ handshake, the last two legs of which are allowed to carry\n   user data for\
    \ fast setup.  The startup sequence is described in\n   Section 5 of this document.\n\
    \   SCTP provides for graceful close (i.e., shutdown) of an active\n   association\
    \ on request from the SCTP user.  See the description of\n   the SHUTDOWN primitive\
    \ in Section 10.  SCTP also allows ungraceful\n   close (i.e., abort), either\
    \ on request from the user (ABORT\n   primitive) or as a result of an error condition\
    \ detected within the\n   SCTP layer.  Section 9 describes both the graceful and\
    \ the ungraceful\n   close procedures.\n   SCTP does not support a half-open state\
    \ (like TCP) wherein one side\n   may continue sending data while the other end\
    \ is closed.  When either\n   endpoint performs a shutdown, the association on\
    \ each peer will stop\n   accepting new data from its user and only deliver data\
    \ in queue at\n   the time of the graceful close (see Section 9).\n"
- title: 1.3.2 Sequenced Delivery within Streams
  contents:
  - "1.3.2 Sequenced Delivery within Streams\n   The term \"stream\" is used in SCTP\
    \ to refer to a sequence of user\n   messages that are to be delivered to the\
    \ upper-layer protocol in\n   order with respect to other messages within the\
    \ same stream.  This is\n   in contrast to its usage in TCP, where it refers to\
    \ a sequence of\n   bytes (in this document a byte is assumed to be eight bits).\n\
    \   The SCTP user can specify at association startup time the number of\n   streams\
    \ to be supported by the association.  This number is\n   negotiated with the\
    \ remote end (see Section 5.1.1).  User messages\n   are associated with stream\
    \ numbers (SEND, RECEIVE primitives, Section\n   10).  Internally, SCTP assigns\
    \ a stream sequence number to each\n   message passed to it by the SCTP user.\
    \  On the receiving side, SCTP\n   ensures that messages are delivered to the\
    \ SCTP user in sequence\n   within a given stream.  However, while one stream\
    \ may be blocked\n   waiting for the next in-sequence user message, delivery from\
    \ other\n   streams may proceed.\n   SCTP provides a mechanism for bypassing the\
    \ sequenced delivery\n   service.  User messages sent using this mechanism are\
    \ delivered to\n   the SCTP user as soon as they are received.\n"
- title: 1.3.3 User Data Fragmentation
  contents:
  - "1.3.3 User Data Fragmentation\n   When needed, SCTP fragments user messages to\
    \ ensure that the SCTP\n   packet passed to the lower layer conforms to the path\
    \ MTU.  On\n   receipt, fragments are reassembled into complete messages before\n\
    \   being passed to the SCTP user.\n"
- title: 1.3.4 Acknowledgement and Congestion Avoidance
  contents:
  - "1.3.4 Acknowledgement and Congestion Avoidance\n   SCTP assigns a Transmission\
    \ Sequence Number (TSN) to each user data\n   fragment or unfragmented message.\
    \  The TSN is independent of any\n   stream sequence number assigned at the stream\
    \ level.  The receiving\n   end acknowledges all TSNs received, even if there\
    \ are gaps in the\n   sequence.  In this way, reliable delivery is kept functionally\n\
    \   separate from sequenced stream delivery.\n   The acknowledgement and congestion\
    \ avoidance function is responsible\n   for packet retransmission when timely\
    \ acknowledgement has not been\n   received.  Packet retransmission is conditioned\
    \ by congestion\n   avoidance procedures similar to those used for TCP.  See Sections\
    \ 6\n   and 7 for a detailed description of the protocol procedures\n   associated\
    \ with this function.\n"
- title: 1.3.5 Chunk Bundling
  contents:
  - "1.3.5 Chunk Bundling\n   As described in Section 3, the SCTP packet as delivered\
    \ to the lower\n   layer consists of a common header followed by one or more chunks.\n\
    \   Each chunk may contain either user data or SCTP control information.\n   The\
    \ SCTP user has the option to request bundling of more than one\n   user messages\
    \ into a single SCTP packet.  The chunk bundling function\n   of SCTP is responsible\
    \ for assembly of the complete SCTP packet and\n   its disassembly at the receiving\
    \ end.\n   During times of congestion an SCTP implementation MAY still perform\n\
    \   bundling even if the user has requested that SCTP not bundle.  The\n   user's\
    \ disabling of bundling only affects SCTP implementations that\n   may delay a\
    \ small period of time before transmission (to attempt to\n   encourage bundling).\
    \  When the user layer disables bundling, this\n   small delay is prohibited but\
    \ not bundling that is performed during\n   congestion or retransmission.\n"
- title: 1.3.6 Packet Validation
  contents:
  - "1.3.6 Packet Validation\n   A mandatory Verification Tag field and a 32 bit checksum\
    \ field (see\n   Appendix B for a description of the Adler-32 checksum) are included\n\
    \   in the SCTP common header.  The Verification Tag value is chosen by\n   each\
    \ end of the association during association startup.  Packets\n   received without\
    \ the expected Verification Tag value are discarded,\n   as a protection against\
    \ blind masquerade attacks and against stale\n   SCTP packets from a previous\
    \ association.  The Adler-32 checksum\n   should be set by the sender of each\
    \ SCTP packet to provide additional\n   protection against data corruption in\
    \ the network.  The receiver of\n   an SCTP packet with an invalid Adler-32 checksum\
    \ silently discards\n   the packet.\n"
- title: 1.3.7 Path Management
  contents:
  - "1.3.7 Path Management\n   The sending SCTP user is able to manipulate the set\
    \ of transport\n   addresses used as destinations for SCTP packets through the\n\
    \   primitives described in Section 10.  The SCTP path management\n   function\
    \ chooses the destination transport address for each outgoing\n   SCTP packet\
    \ based on the SCTP user's instructions and the currently\n   perceived reachability\
    \ status of the eligible destination set.  The\n   path management function monitors\
    \ reachability through heartbeats\n   when other packet traffic is inadequate\
    \ to provide this information\n   and advises the SCTP user when reachability\
    \ of any far-end transport\n   address changes.  The path management function\
    \ is also responsible\n   for reporting the eligible set of local transport addresses\
    \ to the\n   far end during association startup, and for reporting the transport\n\
    \   addresses returned from the far end to the SCTP user.\n   At association start-up,\
    \ a primary path is defined for each SCTP\n   endpoint, and is used for normal\
    \ sending of SCTP packets.\n   On the receiving end, the path management is responsible\
    \ for\n   verifying the existence of a valid SCTP association to which the\n \
    \  inbound SCTP packet belongs before passing it for further processing.\n   Note:\
    \ Path Management and Packet Validation are done at the same\n   time, so although\
    \ described separately above, in reality they cannot\n   be performed as separate\
    \ items.\n"
- title: 1.4 Key Terms
  contents:
  - "1.4 Key Terms\n   Some of the language used to describe SCTP has been introduced\
    \ in the\n   previous sections.  This section provides a consolidated list of\
    \ the\n   key terms and their definitions.\n   o  Active destination transport\
    \ address: A transport address on a\n      peer endpoint which a transmitting\
    \ endpoint considers available\n      for receiving user messages.\n   o  Bundling:\
    \ An optional multiplexing operation, whereby more than\n      one user message\
    \ may be carried in the same SCTP packet.  Each\n      user message occupies its\
    \ own DATA chunk.\n   o  Chunk: A unit of information within an SCTP packet, consisting\
    \ of\n      a chunk header and chunk-specific content.\n   o  Congestion Window\
    \ (cwnd): An SCTP variable that limits the data,\n      in number of bytes, a\
    \ sender can send to a particular destination\n      transport address before\
    \ receiving an acknowledgement.\n   o  Cumulative TSN Ack Point: The TSN of the\
    \ last DATA chunk\n      acknowledged via the Cumulative TSN Ack field of a SACK.\n\
    \   o  Idle destination address: An address that has not had user\n      messages\
    \ sent to it within some length of time, normally the\n      HEARTBEAT interval\
    \ or greater.\n   o  Inactive destination transport address: An address which\
    \ is\n      considered inactive due to errors and unavailable to transport\n \
    \     user messages.\n   o  Message = user message:  Data submitted to SCTP by\
    \ the Upper Layer\n      Protocol (ULP).\n   o  Message Authentication Code (MAC):\
    \  An integrity check mechanism\n      based on cryptographic hash functions using\
    \ a secret key.\n      Typically, message authentication codes are used between\
    \ two\n      parties that share a secret key in order to validate information\n\
    \      transmitted between these parties.  In SCTP it is used by an\n      endpoint\
    \ to validate the State Cookie information that is returned\n      from the peer\
    \ in the COOKIE ECHO chunk.  The term \"MAC\" has\n      different meanings in\
    \ different contexts.  SCTP uses this term\n      with the same meaning as in\
    \ [RFC2104].\n   o  Network Byte Order: Most significant byte first, a.k.a., Big\n\
    \      Endian.\n   o  Ordered Message: A user message that is delivered in order\
    \ with\n      respect to all previous user messages sent within the stream the\n\
    \      message was sent on.\n   o  Outstanding TSN (at an SCTP endpoint): A TSN\
    \ (and the associated\n      DATA chunk) that has been sent by the endpoint but\
    \ for which it\n      has not yet received an acknowledgement.\n   o  Path: The\
    \ route taken by the SCTP packets sent by one SCTP\n      endpoint to a specific\
    \ destination transport address of its peer\n      SCTP endpoint.  Sending to\
    \ different destination transport\n      addresses does not necessarily guarantee\
    \ getting separate paths.\n   o  Primary Path: The primary path is the destination\
    \ and source\n      address that will be put into a packet outbound to the peer\n\
    \      endpoint by default.  The definition includes the source address\n    \
    \  since an implementation MAY wish to specify both destination and\n      source\
    \ address to better control the return path taken by reply\n      chunks and on\
    \ which interface the packet is transmitted when the\n      data sender is multi-homed.\n\
    \   o  Receiver Window (rwnd): An SCTP variable a data sender uses to\n      store\
    \ the most recently calculated receiver window of its peer, in\n      number of\
    \ bytes.  This gives the sender an indication of the space\n      available in\
    \ the receiver's inbound buffer.\n   o  SCTP association: A protocol relationship\
    \ between SCTP endpoints,\n      composed of the two SCTP endpoints and protocol\
    \ state information\n      including Verification Tags and the currently active\
    \ set of\n      Transmission Sequence Numbers (TSNs), etc.  An association can\
    \ be\n      uniquely identified by the transport addresses used by the\n     \
    \ endpoints in the association.  Two SCTP endpoints MUST NOT have\n      more\
    \ than one SCTP association between them at any given time.\n   o  SCTP endpoint:\
    \ The logical sender/receiver of SCTP packets.  On a\n      multi-homed host,\
    \ an SCTP endpoint is represented to its peers as\n      a combination of a set\
    \ of eligible destination transport addresses\n      to which SCTP packets can\
    \ be sent and a set of eligible source\n      transport addresses from which SCTP\
    \ packets can be received.  All\n      transport addresses used by an SCTP endpoint\
    \ must use the same\n      port number, but can use multiple IP addresses.  A\
    \ transport\n      address used by an SCTP endpoint must not be used by another\
    \ SCTP\n      endpoint.  In other words, a transport address is unique to an\n\
    \      SCTP endpoint.\n   o  SCTP packet (or packet): The unit of data delivery\
    \ across the\n      interface between SCTP and the connectionless packet network\n\
    \      (e.g., IP).  An SCTP packet includes the common SCTP header,\n      possible\
    \ SCTP control chunks, and user data encapsulated within\n      SCTP DATA chunks.\n\
    \   o  SCTP user application (SCTP user): The logical higher-layer\n      application\
    \ entity which uses the services of SCTP, also called\n      the Upper-layer Protocol\
    \ (ULP).\n   o  Slow Start Threshold (ssthresh): An SCTP variable.  This is the\n\
    \      threshold which the endpoint will use to determine whether to\n      perform\
    \ slow start or congestion avoidance on a particular\n      destination transport\
    \ address.  Ssthresh is in number of bytes.\n   o  Stream: A uni-directional logical\
    \ channel established from one to\n      another associated SCTP endpoint, within\
    \ which all user messages\n      are delivered in sequence except for those submitted\
    \ to the\n      unordered delivery service.\n   Note: The relationship between\
    \ stream numbers in opposite directions\n   is strictly a matter of how the applications\
    \ use them.  It is the\n   responsibility of the SCTP user to create and manage\
    \ these\n   correlations if they are so desired.\n   o  Stream Sequence Number:\
    \ A 16-bit sequence number used internally\n      by SCTP to assure sequenced\
    \ delivery of the user messages within a\n      given stream.  One stream sequence\
    \ number is attached to each user\n      message.\n   o  Tie-Tags: Verification\
    \ Tags from a previous association.  These\n      Tags are used within a State\
    \ Cookie so that the newly restarting\n      association can be linked to the\
    \ original association within the\n      endpoint that did not restart.\n   o\
    \  Transmission Control Block (TCB): An internal data structure\n      created\
    \ by an SCTP endpoint for each of its existing SCTP\n      associations to other\
    \ SCTP endpoints.  TCB contains all the status\n      and operational information\
    \ for the endpoint to maintain and\n      manage the corresponding association.\n\
    \   o  Transmission Sequence Number (TSN): A 32-bit sequence number used\n   \
    \   internally by SCTP.  One TSN is attached to each chunk containing\n      user\
    \ data to permit the receiving SCTP endpoint to acknowledge its\n      receipt\
    \ and detect duplicate deliveries.\n   o  Transport address:  A Transport Address\
    \ is traditionally defined\n      by Network Layer address, Transport Layer protocol\
    \ and Transport\n      Layer port number.  In the case of SCTP running over IP,\
    \ a\n      transport address is defined by the combination of an IP address\n\
    \      and an SCTP port number (where SCTP is the Transport protocol).\n   o Unacknowledged\
    \ TSN (at an SCTP endpoint): A TSN (and the associated\n      DATA chunk) which\
    \ has been received by the endpoint but for which\n      an acknowledgement has\
    \ not yet been sent. Or in the opposite case,\n      for a packet that has been\
    \ sent but no acknowledgement has been\n      received.\n   o  Unordered Message:\
    \ Unordered messages are \"unordered\" with respect\n      to any other message,\
    \ this includes both other unordered messages\n      as well as other ordered\
    \ messages.  Unordered message might be\n      delivered prior to or later than\
    \ ordered messages sent on the same\n      stream.\n   o  User message: The unit\
    \ of data delivery across the interface\n      between SCTP and its user.\n  \
    \ o  Verification Tag: A 32 bit unsigned integer that is randomly\n      generated.\
    \  The Verification Tag provides a key that allows a\n      receiver to verify\
    \ that the SCTP packet belongs to the current\n      association and is not an\
    \ old or stale packet from a previous\n      association.\n"
- title: 1.5. Abbreviations
  contents:
  - "1.5. Abbreviations\n   MAC    - Message Authentication Code [RFC2104]\n   RTO\
    \    - Retransmission Time-out\n   RTT    - Round-trip Time\n   RTTVAR - Round-trip\
    \ Time Variation\n   SCTP   - Stream Control Transmission Protocol\n   SRTT  \
    \ - Smoothed RTT\n   TCB    - Transmission Control Block\n   TLV    - Type-Length-Value\
    \ Coding Format\n   TSN    - Transmission Sequence Number\n   ULP    - Upper-layer\
    \ Protocol\n"
- title: 1.6 Serial Number Arithmetic
  contents:
  - "1.6 Serial Number Arithmetic\n   It is essential to remember that the actual\
    \ Transmission Sequence\n   Number space is finite, though very large.  This space\
    \ ranges from 0\n   to 2**32 - 1. Since the space is finite, all arithmetic dealing\
    \ with\n   Transmission Sequence Numbers must be performed modulo 2**32.  This\n\
    \   unsigned arithmetic preserves the relationship of sequence numbers as\n  \
    \ they cycle from 2**32 - 1 to 0 again.  There are some subtleties to\n   computer\
    \ modulo arithmetic, so great care should be taken in\n   programming the comparison\
    \ of such values.  When referring to TSNs,\n   the symbol \"=<\" means \"less\
    \ than or equal\"(modulo 2**32).\n   Comparisons and arithmetic on TSNs in this\
    \ document SHOULD use Serial\n   Number Arithmetic as defined in [RFC1982] where\
    \ SERIAL_BITS = 32.\n   An endpoint SHOULD NOT transmit a DATA chunk with a TSN\
    \ that is more\n   than 2**31 - 1 above the beginning TSN of its current send\
    \ window.\n   Doing so will cause problems in comparing TSNs.\n   Transmission\
    \ Sequence Numbers wrap around when they reach 2**32 - 1.\n   That is, the next\
    \ TSN a DATA chunk MUST use after transmitting TSN =\n   2*32 - 1 is TSN = 0.\n\
    \   Any arithmetic done on Stream Sequence Numbers SHOULD use Serial\n   Number\
    \ Arithmetic as defined in [RFC1982] where SERIAL_BITS = 16.\n   All other arithmetic\
    \ and comparisons in this document uses normal\n   arithmetic.\n"
- title: 2. Conventions
  contents:
  - "2. Conventions\n   The keywords MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD,\n\
    \   SHOULD NOT, RECOMMENDED, NOT RECOMMENDED, MAY, and OPTIONAL, when\n   they\
    \ appear in this document, are to be interpreted as described in\n   [RFC2119].\n"
- title: 3.  SCTP packet Format
  contents:
  - "3.  SCTP packet Format\n   An SCTP packet is composed of a common header and\
    \ chunks. A chunk\n   contains either control information or user data.\n   The\
    \ SCTP packet format is shown below:\n       0                   1           \
    \        2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                        Common Header                          |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                          Chunk #1                             |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                           ...                                 |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                          Chunk #n                             |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Multiple chunks can be bundled into one SCTP packet up to the MTU\n   size,\
    \ except for the INIT, INIT ACK, and SHUTDOWN COMPLETE chunks.\n   These chunks\
    \ MUST NOT be bundled with any other chunk in a packet.\n   See Section 6.10 for\
    \ more details on chunk bundling.\n   If a user data message doesn't fit into\
    \ one SCTP packet it can be\n   fragmented into multiple chunks using the procedure\
    \ defined in\n   Section 6.9.\n   All integer fields in an SCTP packet MUST be\
    \ transmitted in network\n   byte order, unless otherwise stated.\n"
- title: 3.1 SCTP Common Header Field Descriptions
  contents:
  - "3.1 SCTP Common Header Field Descriptions\n                         SCTP Common\
    \ Header Format\n       0                   1                   2            \
    \       3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |     Source Port Number        |     Destination Port Number   |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                      Verification Tag                         |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                           Checksum                            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Source\
    \ Port Number: 16 bits (unsigned integer)\n      This is the SCTP sender's port\
    \ number.  It can be used by the\n      receiver in combination with the source\
    \ IP address, the SCTP\n      destination port and possibly the destination IP\
    \ address to\n      identify the association to which this packet belongs.\n \
    \  Destination Port Number: 16 bits (unsigned integer)\n      This is the SCTP\
    \ port number to which this packet is destined.\n      The receiving host will\
    \ use this port number to de-multiplex the\n      SCTP packet to the correct receiving\
    \ endpoint/application.\n   Verification Tag: 32 bits (unsigned integer)\n   \
    \   The receiver of this packet uses the Verification Tag to validate\n      the\
    \ sender of this SCTP packet.  On transmit, the value of this\n      Verification\
    \ Tag MUST be set to the value of the Initiate Tag\n      received from the peer\
    \ endpoint during the association\n      initialization, with the following exceptions:\n\
    \      -  A packet containing an INIT chunk MUST have a zero Verification\n  \
    \       Tag.\n      -  A packet containing a SHUTDOWN-COMPLETE chunk with the\
    \ T-bit\n         set MUST have the Verification Tag copied from the packet with\n\
    \         the SHUTDOWN-ACK chunk.\n      -  A packet containing an ABORT chunk\
    \ may have the verification\n         tag copied from the packet which caused\
    \ the ABORT to be sent.\n         For details see Section 8.4 and 8.5.\n   An\
    \ INIT chunk MUST be the only chunk in the SCTP packet carrying it.\n   Checksum:\
    \ 32 bits (unsigned integer)\n         This field contains the checksum of this\
    \ SCTP packet.  Its\n         calculation is discussed in Section 6.8.  SCTP uses\
    \ the Adler-\n         32 algorithm as described in Appendix B for calculating\
    \ the\n         checksum\n"
- title: 3.2  Chunk Field Descriptions
  contents:
  - "3.2  Chunk Field Descriptions\n   The figure below illustrates the field format\
    \ for the chunks to be\n   transmitted in the SCTP packet.  Each chunk is formatted\
    \ with a Chunk\n   Type field, a chunk-specific Flag field, a Chunk Length field,\
    \ and a\n   Value field.\n       0                   1                   2   \
    \                3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |   Chunk Type  | Chunk  Flags  |        Chunk Length           |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \\\
    \                                                               \\\n      /  \
    \                        Chunk Value                          /\n      \\    \
    \                                                           \\\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Chunk Type: 8 bits (unsigned integer)\n      This field identifies the type\
    \ of information contained in the\n      Chunk Value field.  It takes a value\
    \ from 0 to 254.  The value of\n      255 is reserved for future use as an extension\
    \ field.\n   The values of Chunk Types are defined as follows:\n   ID Value  \
    \  Chunk Type\n   -----       ----------\n   0          - Payload Data (DATA)\n\
    \   1          - Initiation (INIT)\n   2          - Initiation Acknowledgement\
    \ (INIT ACK)\n   3          - Selective Acknowledgement (SACK)\n   4         \
    \ - Heartbeat Request (HEARTBEAT)\n   5          - Heartbeat Acknowledgement (HEARTBEAT\
    \ ACK)\n   6          - Abort (ABORT)\n   7          - Shutdown (SHUTDOWN)\n \
    \  8          - Shutdown Acknowledgement (SHUTDOWN ACK)\n   9          - Operation\
    \ Error (ERROR)\n   10         - State Cookie (COOKIE ECHO)\n   11         - Cookie\
    \ Acknowledgement (COOKIE ACK)\n   12         - Reserved for Explicit Congestion\
    \ Notification Echo (ECNE)\n   13         - Reserved for Congestion Window Reduced\
    \ (CWR)\n   14         - Shutdown Complete (SHUTDOWN COMPLETE)\n   15 to 62  \
    \ - reserved by IETF\n   63         - IETF-defined Chunk Extensions\n   64 to\
    \ 126  - reserved by IETF\n   127        - IETF-defined Chunk Extensions\n   128\
    \ to 190 - reserved by IETF\n   191        - IETF-defined Chunk Extensions\n \
    \  192 to 254 - reserved by IETF\n   255        - IETF-defined Chunk Extensions\n\
    \   Chunk Types are encoded such that the highest-order two bits specify\n   the\
    \ action that must be taken if the processing endpoint does not\n   recognize\
    \ the Chunk Type.\n   00 - Stop processing this SCTP packet and discard it, do\
    \ not process\n        any further chunks within it.\n   01 - Stop processing\
    \ this SCTP packet and discard it, do not process\n        any further chunks\
    \ within it, and report the unrecognized\n        parameter in an 'Unrecognized\
    \ Parameter Type' (in either an\n        ERROR or in the INIT ACK).\n   10 - Skip\
    \ this chunk and continue processing.\n   11 - Skip this chunk and continue processing,\
    \ but report in an ERROR\n        Chunk using the 'Unrecognized Chunk Type' cause\
    \ of error.\n   Note: The ECNE and CWR chunk types are reserved for future use\
    \ of\n   Explicit Congestion Notification (ECN).\n   Chunk Flags: 8 bits\n   \
    \   The usage of these bits depends on the chunk type as given by the\n      Chunk\
    \ Type.  Unless otherwise specified, they are set to zero on\n      transmit and\
    \ are ignored on receipt.\n   Chunk Length: 16 bits (unsigned integer)\n     \
    \ This value represents the size of the chunk in bytes including the\n      Chunk\
    \ Type, Chunk Flags, Chunk Length, and Chunk Value fields.\n      Therefore, if\
    \ the Chunk Value field is zero-length, the Length\n      field will be set to\
    \ 4.  The Chunk Length field does not count any\n      padding.\n   Chunk Value:\
    \ variable length\n      The Chunk Value field contains the actual information\
    \ to be\n      transferred in the chunk.  The usage and format of this field is\n\
    \      dependent on the Chunk Type.\n   The total length of a chunk (including\
    \ Type, Length and Value fields)\n   MUST be a multiple of 4 bytes.  If the length\
    \ of the chunk is not a\n   multiple of 4 bytes, the sender MUST pad the chunk\
    \ with all zero\n   bytes and this padding is not included in the chunk length\
    \ field.\n   The sender should never pad with more than 3 bytes.  The receiver\n\
    \   MUST ignore the padding bytes.\n   SCTP defined chunks are described in detail\
    \ in Section 3.3.  The\n   guidelines for IETF-defined chunk extensions can be\
    \ found in Section\n   13.1 of this document.\n"
- title: 3.2.1  Optional/Variable-length Parameter Format
  contents:
  - "3.2.1  Optional/Variable-length Parameter Format\n   Chunk values of SCTP control\
    \ chunks consist of a chunk-type-specific\n   header of required fields, followed\
    \ by zero or more parameters.  The\n   optional and variable-length parameters\
    \ contained in a chunk are\n   defined in a Type-Length-Value format as shown\
    \ below.\n       0                   1                   2                   3\n\
    \       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    \
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \          Parameter Type       |       Parameter Length        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      \\                                                               \\\n \
    \     /                       Parameter Value                         /\n    \
    \  \\                                                               \\\n     \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Chunk\
    \ Parameter Type:  16 bits (unsigned integer)\n      The Type field is a 16 bit\
    \ identifier of the type of parameter.\n      It takes a value of 0 to 65534.\n\
    \      The value of 65535 is reserved for IETF-defined extensions. Values\n  \
    \    other than those defined in specific SCTP chunk description are\n      reserved\
    \ for use by IETF.\n   Chunk Parameter Length:  16 bits (unsigned integer)\n \
    \     The Parameter Length field contains the size of the parameter in\n     \
    \ bytes, including the Parameter Type, Parameter Length, and\n      Parameter\
    \ Value fields.  Thus, a parameter with a zero-length\n      Parameter Value field\
    \ would have a Length field of 4.  The\n      Parameter Length does not include\
    \ any padding bytes.\n   Chunk Parameter Value: variable-length.\n      The Parameter\
    \ Value field contains the actual information to be\n      transferred in the\
    \ parameter.\n   The total length of a parameter (including Type, Parameter Length\
    \ and\n   Value fields) MUST be a multiple of 4 bytes.  If the length of the\n\
    \   parameter is not a multiple of 4 bytes, the sender pads the Parameter\n  \
    \ at the end (i.e., after the Parameter Value field) with all zero\n   bytes.\
    \  The length of the padding is not included in the parameter\n   length field.\
    \  A sender SHOULD NOT pad with more than 3 bytes.  The\n   receiver MUST ignore\
    \ the padding bytes.\n   The Parameter Types are encoded such that the highest-order\
    \ two bits\n   specify the action that must be taken if the processing endpoint\
    \ does\n   not recognize the Parameter Type.\n   00 - Stop processing this SCTP\
    \ packet and discard it, do not process\n        any further chunks within it.\n\
    \   01 - Stop processing this SCTP packet and discard it, do not process\n   \
    \     any further chunks within it, and report the unrecognized\n        parameter\
    \ in an 'Unrecognized Parameter Type' (in either an\n        ERROR or in the INIT\
    \ ACK).\n   10 - Skip this parameter and continue processing.\n   11 - Skip this\
    \ parameter and continue processing but report the\n        unrecognized parameter\
    \ in an 'Unrecognized Parameter Type' (in\n        either an ERROR or in the INIT\
    \ ACK).\n   The actual SCTP parameters are defined in the specific SCTP chunk\n\
    \   sections.  The rules for IETF-defined parameter extensions are\n   defined\
    \ in Section 13.2.\n"
- title: 3.3 SCTP Chunk Definitions
  contents:
  - "3.3 SCTP Chunk Definitions\n   This section defines the format of the different\
    \ SCTP chunk types.\n"
- title: 3.3.1 Payload Data (DATA) (0)
  contents:
  - "3.3.1 Payload Data (DATA) (0)\n   The following format MUST be used for the DATA\
    \ chunk:\n       0                   1                   2                   3\n\
    \       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    \
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \   Type = 0    | Reserved|U|B|E|    Length                     |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                              TSN                              |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \      Stream Identifier S      |   Stream Sequence Number n    |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                  Payload Protocol Identifier                  |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \\\
    \                                                               \\\n      /  \
    \               User Data (seq n of Stream S)                 /\n      \\    \
    \                                                           \\\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Reserved: 5 bits\n      Should be set to all '0's and ignored by the receiver.\n\
    \   U bit: 1 bit\n      The (U)nordered bit, if set to '1', indicates that this\
    \ is an\n      unordered DATA chunk, and there is no Stream Sequence Number\n\
    \      assigned to this DATA chunk.  Therefore, the receiver MUST ignore\n   \
    \   the Stream Sequence Number field.\n      After re-assembly (if necessary),\
    \ unordered DATA chunks MUST be\n      dispatched to the upper layer by the receiver\
    \ without any attempt\n      to re-order.\n      If an unordered user message\
    \ is fragmented, each fragment of the\n      message MUST have its U bit set to\
    \ '1'.\n   B bit: 1 bit\n      The (B)eginning fragment bit, if set, indicates\
    \ the first fragment\n      of a user message.\n   E bit:  1 bit\n      The (E)nding\
    \ fragment bit, if set, indicates the last fragment of\n      a user message.\n\
    \   An unfragmented user message shall have both the B and E bits set to\n   '1'.\
    \  Setting both B and E bits to '0' indicates a middle fragment of\n   a multi-fragment\
    \ user message, as summarized in the following table:\n            B E       \
    \           Description\n         ============================================================\n\
    \         |  1 0 | First piece of a fragmented user message          |\n     \
    \    +----------------------------------------------------------+\n         |\
    \  0 0 | Middle piece of a fragmented user message         |\n         +----------------------------------------------------------+\n\
    \         |  0 1 | Last piece of a fragmented user message           |\n     \
    \    +----------------------------------------------------------+\n         |\
    \  1 1 | Unfragmented Message                              |\n         ============================================================\n\
    \         |             Table 1: Fragment Description Flags          |\n     \
    \    ============================================================\n   When a user\
    \ message is fragmented into multiple chunks, the TSNs are\n   used by the receiver\
    \ to reassemble the message.  This means that the\n   TSNs for each fragment of\
    \ a fragmented user message MUST be strictly\n   sequential.\n   Length:  16 bits\
    \ (unsigned integer)\n      This field indicates the length of the DATA chunk\
    \ in bytes from\n      the beginning of the type field to the end of the user\
    \ data field\n      excluding any padding.  A DATA chunk with no user data field\
    \ will\n      have Length set to 16 (indicating 16 bytes).\n   TSN : 32 bits (unsigned\
    \ integer)\n      This value represents the TSN for this DATA chunk.  The valid\n\
    \      range of TSN is from 0 to 4294967295 (2**32 - 1).  TSN wraps back\n   \
    \   to 0 after reaching 4294967295.\n   Stream Identifier S: 16 bits (unsigned\
    \ integer)\n      Identifies the stream to which the following user data belongs.\n\
    \   Stream Sequence Number n: 16 bits (unsigned integer)\n      This value represents\
    \ the stream sequence number of the following\n      user data within the stream\
    \ S.  Valid range is 0 to 65535.\n      When a user message is fragmented by SCTP\
    \ for transport, the same\n      stream sequence number MUST be carried in each\
    \ of the fragments of\n      the message.\n   Payload Protocol Identifier: 32\
    \ bits (unsigned integer)\n      This value represents an application (or upper\
    \ layer) specified\n      protocol identifier.  This value is passed to SCTP by\
    \ its upper\n      layer and sent to its peer.  This identifier is not used by\
    \ SCTP\n      but can be used by certain network entities as well as the peer\n\
    \      application to identify the type of information being carried in\n    \
    \  this DATA chunk. This field must be sent even in fragmented DATA\n      chunks\
    \ (to make sure it is available for agents in the middle of\n      the network).\n\
    \      The value 0 indicates no application identifier is specified by\n     \
    \ the upper layer for this payload data.\n   User Data: variable length\n    \
    \  This is the payload user data.  The implementation MUST pad the\n      end\
    \ of the data to a 4 byte boundary with all-zero bytes.  Any\n      padding MUST\
    \ NOT be included in the length field.  A sender MUST\n      never add more than\
    \ 3 bytes of padding.\n"
- title: 3.3.2 Initiation (INIT) (1)
  contents:
  - "3.3.2 Initiation (INIT) (1)\n   This chunk is used to initiate a SCTP association\
    \ between two\n   endpoints.  The format of the INIT chunk is shown below:\n \
    \      0                   1                   2                   3\n       0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |   Type = 1    |  Chunk Flags  |      Chunk Length             |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                         Initiate Tag                          |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |           Advertised Receiver Window Credit (a_rwnd)          |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \  Number of Outbound Streams   |  Number of Inbound Streams    |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                          Initial TSN                          |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \\\
    \                                                               \\\n      /  \
    \            Optional/Variable-Length Parameters              /\n      \\    \
    \                                                           \\\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The INIT chunk contains the following parameters.  Unless otherwise\n   noted,\
    \ each parameter MUST only be included once in the INIT chunk.\n         Fixed\
    \ Parameters                     Status\n         ----------------------------------------------\n\
    \         Initiate Tag                        Mandatory\n         Advertised Receiver\
    \ Window Credit   Mandatory\n         Number of Outbound Streams          Mandatory\n\
    \         Number of Inbound Streams           Mandatory\n         Initial TSN\
    \                         Mandatory\n         Variable Parameters            \
    \      Status     Type Value\n         -------------------------------------------------------------\n\
    \         IPv4 Address (Note 1)               Optional    5\n         IPv6 Address\
    \ (Note 1)               Optional    6\n         Cookie Preservative         \
    \        Optional    9\n         Reserved for ECN Capable (Note 2)   Optional\
    \    32768 (0x8000)\n         Host Name Address (Note 3)          Optional   \
    \ 11\n         Supported Address Types (Note 4)    Optional    12\n   Note 1:\
    \ The INIT chunks can contain multiple addresses that can be\n   IPv4 and/or IPv6\
    \ in any combination.\n   Note 2: The ECN capable field is reserved for future\
    \ use of Explicit\n   Congestion Notification.\n   Note 3: An INIT chunk MUST\
    \ NOT contain more than one Host Name\n   address parameter.  Moreover, the sender\
    \ of the INIT MUST NOT combine\n   any other address types with the Host Name\
    \ address in the INIT.  The\n   receiver of INIT MUST ignore any other address\
    \ types if the Host Name\n   address parameter is present in the received INIT\
    \ chunk.\n   Note 4: This parameter, when present, specifies all the address types\n\
    \   the sending endpoint can support.  The absence of this parameter\n   indicates\
    \ that the sending endpoint can support any address type.\n   The Chunk Flags\
    \ field in INIT is reserved and all bits in it should\n   be set to 0 by the sender\
    \ and ignored by the receiver.  The sequence\n   of parameters within an INIT\
    \ can be processed in any order.\n   Initiate Tag: 32 bits (unsigned integer)\n\
    \      The receiver of the INIT (the responding end) records the value of\n  \
    \    the Initiate Tag parameter.  This value MUST be placed into the\n      Verification\
    \ Tag field of every SCTP packet that the receiver of\n      the INIT transmits\
    \ within this association.\n      The Initiate Tag is allowed to have any value\
    \ except 0.  See\n      Section 5.3.1 for more on the selection of the tag value.\n\
    \      If the value of the Initiate Tag in a received INIT chunk is found\n  \
    \    to be 0, the receiver MUST treat it as an error and close the\n      association\
    \ by transmitting an ABORT.\n   Advertised Receiver Window Credit (a_rwnd): 32\
    \ bits (unsigned\n      integer)\n      This value represents the dedicated buffer\
    \ space, in number of\n      bytes, the sender of the INIT has reserved in association\
    \ with\n      this window.  During the life of the association this buffer space\n\
    \      SHOULD not be lessened (i.e. dedicated buffers taken away from\n      this\
    \ association); however, an endpoint MAY change the value of\n      a_rwnd it\
    \ sends in SACK chunks.\n   Number of Outbound Streams (OS):  16 bits (unsigned\
    \ integer)\n      Defines the number of outbound streams the sender of this INIT\n\
    \      chunk wishes to create in this association.  The value of 0 MUST\n    \
    \  NOT be used.\n      Note: A receiver of an INIT with the OS value set to 0\
    \ SHOULD\n      abort the association.\n   Number of Inbound Streams (MIS) : 16\
    \ bits (unsigned integer)\n      Defines the maximum number of streams the sender\
    \ of this INIT\n      chunk allows the peer end to create in this association.\
    \  The\n      value 0 MUST NOT be used.\n      Note: There is no negotiation of\
    \ the actual number of streams but\n      instead the two endpoints will use the\
    \ min(requested, offered).\n      See Section 5.1.1 for details.\n      Note:\
    \ A receiver of an INIT with the MIS value of 0 SHOULD abort\n      the association.\n\
    \   Initial TSN (I-TSN) : 32 bits (unsigned integer)\n      Defines the initial\
    \ TSN that the sender will use.  The valid range\n      is from 0 to 4294967295.\
    \  This field MAY be set to the value of\n      the Initiate Tag field.\n"
- title: 3.3.2.1 Optional/Variable Length Parameters in INIT
  contents:
  - "3.3.2.1 Optional/Variable Length Parameters in INIT\n   The following parameters\
    \ follow the Type-Length-Value format as\n   defined in Section 3.2.1.  Any Type-Length-Value\
    \ fields MUST come\n   after the fixed-length fields defined in the previous section.\n\
    \   IPv4 Address Parameter (5)\n       0                   1                 \
    \  2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |        Type = 5               |      Length = 8               |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                        IPv4 Address                           |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   IPv4 Address: 32 bits (unsigned integer)\n      Contains an IPv4 address of\
    \ the sending endpoint.  It is binary\n      encoded.\n   IPv6 Address Parameter\
    \ (6)\n       0                   1                   2                   3\n\
    \       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    \
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \            Type = 6           |          Length = 20          |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                                               |\n   \
    \   |                         IPv6 Address                          |\n      |\
    \                                                               |\n      |   \
    \                                                            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   IPv6 Address: 128 bit (unsigned integer)\n      Contains an IPv6 address of\
    \ the sending endpoint.  It is binary\n      encoded.\n      Note: A sender MUST\
    \ NOT use an IPv4-mapped IPv6 address [RFC2373]\n      but should instead use\
    \ an IPv4 Address Parameter for an IPv4\n      address.\n      Combined with the\
    \ Source Port Number in the SCTP common header,\n      the value passed in an\
    \ IPv4 or IPv6 Address parameter indicates a\n      transport address the sender\
    \ of the INIT will support for the\n      association being initiated.  That is,\
    \ during the lifetime of this\n      association, this IP address can appear in\
    \ the source address\n      field of an IP datagram sent from the sender of the\
    \ INIT, and can\n      be used as a destination address of an IP datagram sent\
    \ from the\n      receiver of the INIT.\n      More than one IP Address parameter\
    \ can be included in an INIT\n      chunk when the INIT sender is multi-homed.\
    \  Moreover, a multi-\n      homed endpoint may have access to different types\
    \ of network, thus\n      more than one address type can be present in one INIT\
    \ chunk, i.e.,\n      IPv4 and IPv6 addresses are allowed in the same INIT chunk.\n\
    \      If the INIT contains at least one IP Address parameter, then the\n    \
    \  source address of the IP datagram containing the INIT chunk and\n      any\
    \ additional address(es) provided within the INIT can be used as\n      destinations\
    \ by the endpoint receiving the INIT.  If the INIT does\n      not contain any\
    \ IP Address parameters, the endpoint receiving the\n      INIT MUST use the source\
    \ address associated with the received IP\n      datagram as its sole destination\
    \ address for the association.\n      Note that not using any IP address parameters\
    \ in the INIT and\n      INIT-ACK is an alternative to make an association more\
    \ likely to\n      work across a NAT box.\n   Cookie Preservative (9)\n      The\
    \ sender of the INIT shall use this parameter to suggest to the\n      receiver\
    \ of the INIT for a longer life-span of the State Cookie.\n       0          \
    \         1                   2                   3\n       0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |          Type = 9             |          Length = 8           |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \         Suggested Cookie Life-span Increment (msec.)          |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Suggested Cookie Life-span Increment: 32 bits (unsigned integer)\n      This\
    \ parameter indicates to the receiver how much increment in\n      milliseconds\
    \ the sender wishes the receiver to add to its default\n      cookie life-span.\n\
    \      This optional parameter should be added to the INIT chunk by the\n    \
    \  sender when it re-attempts establishing an association with a peer\n      to\
    \ which its previous attempt of establishing the association failed\n      due\
    \ to a stale cookie operation error.  The receiver MAY choose to\n      ignore\
    \ the suggested cookie life-span increase for its own security\n      reasons.\n\
    \   Host Name Address (11)\n      The sender of INIT uses this parameter to pass\
    \ its Host Name (in\n      place of its IP addresses) to its peer.  The peer is\
    \ responsible\n      for resolving the name.  Using this parameter might make\
    \ it more\n      likely for the association to work across a NAT box.\n      0\
    \                   1                   2                   3\n      0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |          Type = 11            |          Length               |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      /\
    \                          Host Name                            /\n      \\  \
    \                                                             \\\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Host Name: variable length\n      This field contains a host name in \"host\
    \ name syntax\" per RFC1123\n      Section 2.1 [RFC1123].  The method for resolving\
    \ the host name is\n      out of scope of SCTP.\n      Note: At least one null\
    \ terminator is included in the Host Name\n      string and must be included in\
    \ the length.\n   Supported Address Types (12)\n      The sender of INIT uses\
    \ this parameter to list all the address\n      types it can support.\n      \
    \ 0                   1                   2                   3\n       0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |          Type = 12            |          Length               |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \        Address Type #1        |        Address Type #2        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |        ......\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Address Type:\
    \ 16 bits (unsigned integer)\n      This is filled with the type value of the\
    \ corresponding address\n      TLV (e.g., IPv4 = 5, IPv6 = 6, Hostname = 11).\n"
- title: '3.3.3 Initiation Acknowledgement (INIT ACK) (2):'
  contents:
  - "3.3.3 Initiation Acknowledgement (INIT ACK) (2):\n   The INIT ACK chunk is used\
    \ to acknowledge the initiation of an SCTP\n   association.\n   The parameter\
    \ part of INIT ACK is formatted similarly to the INIT\n   chunk.  It uses two\
    \ extra variable parameters: The State Cookie and\n   the Unrecognized Parameter:\n\
    \   The format of the INIT ACK chunk is shown below:\n       0               \
    \    1                   2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |   Type = 2    |  Chunk Flags  |      Chunk Length             |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                         Initiate Tag                          |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |              Advertised Receiver Window Credit                |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \  Number of Outbound Streams   |  Number of Inbound Streams    |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                          Initial TSN                          |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \\\
    \                                                               \\\n      /  \
    \            Optional/Variable-Length Parameters              /\n      \\    \
    \                                                           \\\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Initiate Tag: 32 bits (unsigned integer)\n      The receiver of the INIT ACK\
    \ records the value of the Initiate Tag\n      parameter.  This value MUST be\
    \ placed into the Verification Tag\n      field of every SCTP packet that the\
    \ INIT ACK receiver transmits\n      within this association.\n      The Initiate\
    \ Tag MUST NOT take the value 0.  See Section 5.3.1 for\n      more on the selection\
    \ of the Initiate Tag value.\n      If the value of the Initiate Tag in a received\
    \ INIT ACK chunk is\n      found to be 0, the receiver MUST treat it as an error\
    \ and close\n      the association by transmitting an ABORT.\n   Advertised Receiver\
    \ Window Credit (a_rwnd): 32 bits (unsigned\n   integer)\n      This value represents\
    \ the dedicated buffer space, in number of\n      bytes, the sender of the INIT\
    \ ACK has reserved in association with\n      this window.  During the life of\
    \ the association this buffer space\n      SHOULD not be lessened (i.e. dedicated\
    \ buffers taken away from\n      this association).\n   Number of Outbound Streams\
    \ (OS):  16 bits (unsigned integer)\n      Defines the number of outbound streams\
    \ the sender of this INIT ACK\n      chunk wishes to create in this association.\
    \  The value of 0 MUST\n      NOT be used.\n      Note: A receiver of an INIT\
    \ ACK  with the OS value set to 0 SHOULD\n      destroy the association discarding\
    \ its TCB.\n   Number of Inbound Streams (MIS) : 16 bits (unsigned integer)\n\
    \      Defines the maximum number of streams the sender of this INIT ACK\n   \
    \   chunk allows the peer end to create in this association.  The\n      value\
    \ 0 MUST NOT be used.\n      Note: There is no negotiation of the actual number\
    \ of streams but\n      instead the two endpoints will use the min(requested,\
    \ offered).\n      See Section 5.1.1 for details.\n      Note: A receiver of an\
    \ INIT ACK  with the MIS value set to 0\n      SHOULD destroy the association\
    \ discarding its TCB.\n   Initial TSN (I-TSN) : 32 bits (unsigned integer)\n \
    \     Defines the initial TSN that the INIT-ACK sender will use.  The\n      valid\
    \ range is from 0 to 4294967295.  This field MAY be set to the\n      value of\
    \ the Initiate Tag field.\n      Fixed Parameters                     Status\n\
    \      ----------------------------------------------\n      Initiate Tag    \
    \                    Mandatory\n      Advertised Receiver Window Credit   Mandatory\n\
    \      Number of Outbound Streams          Mandatory\n      Number of Inbound\
    \ Streams           Mandatory\n      Initial TSN                         Mandatory\n\
    \      Variable Parameters                  Status     Type Value\n      -------------------------------------------------------------\n\
    \      State Cookie                        Mandatory   7\n      IPv4 Address (Note\
    \ 1)               Optional    5\n      IPv6 Address (Note 1)               Optional\
    \    6\n      Unrecognized Parameters             Optional    8\n      Reserved\
    \ for ECN Capable (Note 2)   Optional    32768 (0x8000)\n      Host Name Address\
    \ (Note 3)          Optional    11\n   Note 1: The INIT ACK chunks can contain\
    \ any number of IP address\n   parameters that can be IPv4 and/or IPv6 in any\
    \ combination.\n   Note 2: The ECN capable field is reserved for future use of\
    \ Explicit\n   Congestion Notification.\n   Note 3: The INIT ACK chunks MUST NOT\
    \ contain more than one Host Name\n   address parameter.  Moreover, the sender\
    \ of the INIT ACK MUST NOT\n   combine any other address types with the Host Name\
    \ address in the\n   INIT ACK.  The receiver of the INIT ACK MUST ignore any other\
    \ address\n   types if the Host Name address parameter is present.\n   IMPLEMENTATION\
    \ NOTE: An implementation MUST be prepared to receive a\n   INIT ACK that is quite\
    \ large (more than 1500 bytes) due to the\n   variable size of the state cookie\
    \ AND the variable address list.  For\n   example if a responder to the INIT has\
    \ 1000 IPv4 addresses it wishes\n   to send, it would need at least 8,000 bytes\
    \ to encode this in the\n   INIT ACK.\n   In combination with the Source Port\
    \ carried in the SCTP common\n   header, each IP Address parameter in the INIT\
    \ ACK indicates to the\n   receiver of the INIT ACK a valid transport address\
    \ supported by the\n   sender of the INIT ACK for the lifetime of the association\
    \ being\n   initiated.\n   If the INIT ACK contains at least one IP Address parameter,\
    \ then the\n   source address of the IP datagram containing the INIT ACK and any\n\
    \   additional address(es) provided within the INIT ACK may be used as\n   destinations\
    \ by the receiver of the INIT-ACK.  If the INIT ACK does\n   not contain any IP\
    \ Address parameters, the receiver of the INIT-ACK\n   MUST use the source address\
    \ associated with the received IP datagram\n   as its sole destination address\
    \ for the association.\n   The State Cookie and Unrecognized Parameters use the\
    \ Type-Length-\n   Value format as defined in Section 3.2.1 and are described\
    \ below.\n   The other fields are defined the same as their counterparts in the\n\
    \   INIT chunk.\n"
- title: 3.3.3.1 Optional or Variable Length Parameters
  contents:
  - "3.3.3.1 Optional or Variable Length Parameters\n   State Cookie\n      Parameter\
    \ Type Value: 7\n      Parameter Length:  variable size, depending on Size of\
    \ Cookie\n      Parameter Value:\n         This parameter value MUST contain all\
    \ the necessary state and\n         parameter information required for the sender\
    \ of this INIT ACK\n         to create the association, along with a Message Authentication\n\
    \         Code (MAC).  See Section 5.1.3 for details on State Cookie\n       \
    \  definition.\n   Unrecognized Parameters:\n      Parameter Type Value: 8\n \
    \     Parameter Length:  Variable Size.\n      Parameter Value:\n         This\
    \ parameter is returned to the originator of the INIT chunk\n         when the\
    \ INIT contains an unrecognized parameter which has a\n         value that indicates\
    \ that it should be reported to the sender.\n         This parameter value field\
    \ will contain unrecognized parameters\n         copied from the INIT chunk complete\
    \ with Parameter Type, Length\n         and Value fields.\n"
- title: '3.3.4 Selective Acknowledgement (SACK) (3):'
  contents:
  - "3.3.4 Selective Acknowledgement (SACK) (3):\n   This chunk is sent to the peer\
    \ endpoint to acknowledge received DATA\n   chunks and to inform the peer endpoint\
    \ of gaps in the received\n   subsequences of DATA chunks as represented by their\
    \ TSNs.\n   The SACK MUST contain the Cumulative TSN Ack and Advertised Receiver\n\
    \   Window Credit (a_rwnd) parameters.\n   By definition, the value of the Cumulative\
    \ TSN Ack parameter is the\n   last TSN received before a break in the sequence\
    \ of received TSNs\n   occurs; the next TSN value following this one has not yet\
    \ been\n   received at the endpoint sending the SACK.  This parameter therefore\n\
    \   acknowledges receipt of all TSNs less than or equal to its value.\n   The\
    \ handling of a_rwnd by the receiver of the SACK is discussed in\n   detail in\
    \ Section 6.2.1.\n   The SACK also contains zero or more Gap Ack Blocks.  Each\
    \ Gap Ack\n   Block acknowledges a subsequence of TSNs received following a break\n\
    \   in the sequence of received TSNs.  By definition, all TSNs\n   acknowledged\
    \ by Gap Ack Blocks are greater than the value of the\n   Cumulative TSN Ack.\n\
    \       0                   1                   2                   3\n      \
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |   Type = 3    |Chunk  Flags   |      Chunk Length             |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                      Cumulative TSN Ack                       |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |          Advertised Receiver Window Credit (a_rwnd)           |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \ Number of Gap Ack Blocks = N  |  Number of Duplicate TSNs = X |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |  Gap Ack Block #1 Start       |   Gap Ack Block #1 End        |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      /\
    \                                                               /\n      \\  \
    \                            ...                              \\\n      /    \
    \                                                           /\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |   Gap Ack Block #N Start      |  Gap Ack Block #N End         |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                       Duplicate TSN 1                         |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      /                                                               /\n   \
    \   \\                              ...                              \\\n    \
    \  /                                                               /\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                       Duplicate TSN X                         |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Chunk\
    \ Flags: 8 bits\n      Set to all zeros on transmit and ignored on receipt.\n\
    \   Cumulative TSN Ack: 32 bits (unsigned integer)\n      This parameter contains\
    \ the TSN of the last DATA chunk received in\n      sequence before a gap.\n \
    \  Advertised Receiver Window Credit (a_rwnd): 32 bits (unsigned\n      integer)\n\
    \      This field indicates the updated receive buffer space in bytes of\n   \
    \   the sender of this SACK, see Section 6.2.1 for details.\n   Number of Gap\
    \ Ack Blocks: 16 bits (unsigned integer)\n      Indicates the number of Gap Ack\
    \ Blocks included in this SACK.\n   Number of Duplicate TSNs: 16 bit\n      This\
    \ field contains the number of duplicate TSNs the endpoint has\n      received.\
    \  Each duplicate TSN is listed following the Gap Ack\n      Block list.\n   Gap\
    \ Ack Blocks:\n      These fields contain the Gap Ack Blocks.  They are repeated\
    \ for\n      each Gap Ack Block up to the number of Gap Ack Blocks defined in\n\
    \      the Number of Gap Ack Blocks field.  All DATA chunks with TSNs\n      greater\
    \ than or equal to (Cumulative TSN Ack + Gap Ack Block\n      Start) and less\
    \ than or equal to (Cumulative TSN Ack + Gap Ack\n      Block End) of each Gap\
    \ Ack Block are assumed to have been received\n      correctly.\n   Gap Ack Block\
    \ Start: 16 bits (unsigned integer)\n      Indicates the Start offset TSN for\
    \ this Gap Ack Block.  To\n      calculate the actual TSN number the Cumulative\
    \ TSN Ack is added to\n      this offset number.  This calculated TSN identifies\
    \ the first TSN\n      in this Gap Ack Block that has been received.\n   Gap Ack\
    \ Block End:  16 bits (unsigned integer)\n      Indicates the End offset TSN for\
    \ this Gap Ack Block.  To calculate\n      the actual TSN number the Cumulative\
    \ TSN Ack is added to this\n      offset number.  This calculated TSN identifies\
    \ the TSN of the last\n      DATA chunk received in this Gap Ack Block.\n   For\
    \ example, assume the receiver has the following DATA chunks newly\n   arrived\
    \ at the time when it decides to send a Selective ACK,\n                     \
    \   ----------\n                        | TSN=17 |\n                        ----------\n\
    \                        |        | <- still missing\n                       \
    \ ----------\n                        | TSN=15 |\n                        ----------\n\
    \                        | TSN=14 |\n                        ----------\n    \
    \                    |        | <- still missing\n                        ----------\n\
    \                        | TSN=12 |\n                        ----------\n    \
    \                    | TSN=11 |\n                        ----------\n        \
    \                | TSN=10 |\n                        ----------\n   then, the\
    \ parameter part of the SACK MUST be constructed as follows\n   (assuming the\
    \ new a_rwnd is set to 4660 by the sender):\n                  +--------------------------------+\n\
    \                  |   Cumulative TSN Ack = 12      |\n                  +--------------------------------+\n\
    \                  |        a_rwnd = 4660           |\n                  +----------------+---------------+\n\
    \                  | num of block=2 | num of dup=0  |\n                  +----------------+---------------+\n\
    \                  |block #1 strt=2 |block #1 end=3 |\n                  +----------------+---------------+\n\
    \                  |block #2 strt=5 |block #2 end=5 |\n                  +----------------+---------------+\n\
    \   Duplicate TSN: 32 bits (unsigned integer)\n      Indicates the number of times\
    \ a TSN was received in duplicate\n      since the last SACK was sent.  Every\
    \ time a receiver gets a\n      duplicate TSN (before sending the SACK) it adds\
    \ it to the list of\n      duplicates.  The duplicate count is re-initialized\
    \ to zero after\n      sending each SACK.\n      For example, if a receiver were\
    \ to get the TSN 19 three times it\n      would list 19 twice in the outbound\
    \ SACK.  After sending the SACK\n      if it received yet one more TSN 19 it would\
    \ list 19 as a duplicate\n      once in the next outgoing SACK.\n"
- title: '3.3.5 Heartbeat Request (HEARTBEAT) (4):'
  contents:
  - "3.3.5 Heartbeat Request (HEARTBEAT) (4):\n   An endpoint should send this chunk\
    \ to its peer endpoint to probe the\n   reachability of a particular destination\
    \ transport address defined in\n   the present association.\n   The parameter\
    \ field contains the Heartbeat Information which is a\n   variable length opaque\
    \ data structure understood only by the sender.\n       0                   1\
    \                   2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |   Type = 4    | Chunk  Flags  |      Heartbeat Length         |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \\\
    \                                                               \\\n      /  \
    \          Heartbeat Information TLV (Variable-Length)        /\n      \\    \
    \                                                           \\\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Chunk Flags: 8 bits\n      Set to zero on transmit and ignored on receipt.\n\
    \   Heartbeat Length: 16 bits (unsigned integer)\n      Set to the size of the\
    \ chunk in bytes, including the chunk header\n      and the Heartbeat Information\
    \ field.\n   Heartbeat Information: variable length\n      Defined as a variable-length\
    \ parameter using the format described\n      in Section 3.2.1, i.e.:\n      Variable\
    \ Parameters                  Status     Type Value\n      -------------------------------------------------------------\n\
    \      Heartbeat Info                       Mandatory   1\n       0          \
    \         1                   2                   3\n       0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |    Heartbeat Info Type=1      |         HB Info Length        |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      /\
    \                  Sender-specific Heartbeat Info               /\n      \\  \
    \                                                             \\\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      The Sender-specific Heartbeat Info field should normally include\n    \
    \  information about the sender's current time when this HEARTBEAT\n      chunk\
    \ is sent and the destination transport address to which this\n      HEARTBEAT\
    \ is sent (see Section 8.3).\n"
- title: '3.3.6 Heartbeat Acknowledgement (HEARTBEAT ACK) (5):'
  contents:
  - "3.3.6 Heartbeat Acknowledgement (HEARTBEAT ACK) (5):\n   An endpoint should send\
    \ this chunk to its peer endpoint as a response\n   to a HEARTBEAT chunk (see\
    \ Section 8.3).  A HEARTBEAT ACK is always\n   sent to the source IP address of\
    \ the IP datagram containing the\n   HEARTBEAT chunk to which this ack is responding.\n\
    \   The parameter field contains a variable length opaque data structure.\n  \
    \     0                   1                   2                   3\n       0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |   Type = 5    | Chunk  Flags  |    Heartbeat Ack Length       |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \\\
    \                                                               \\\n      /  \
    \          Heartbeat Information TLV (Variable-Length)        /\n      \\    \
    \                                                           \\\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Chunk Flags: 8 bits\n      Set to zero on transmit and ignored on receipt.\n\
    \   Heartbeat Ack Length:  16 bits (unsigned integer)\n      Set to the size of\
    \ the chunk in bytes, including the chunk header\n      and the Heartbeat Information\
    \ field.\n   Heartbeat Information: variable length\n      This field MUST contain\
    \ the Heartbeat Information parameter of\n      the Heartbeat Request to which\
    \ this Heartbeat Acknowledgement is\n      responding.\n      Variable Parameters\
    \                  Status     Type Value\n      -------------------------------------------------------------\n\
    \      Heartbeat Info                       Mandatory   1\n"
- title: '3.3.7 Abort Association (ABORT) (6):'
  contents:
  - "3.3.7 Abort Association (ABORT) (6):\n   The ABORT chunk is sent to the peer\
    \ of an association to close the\n   association.  The ABORT chunk may contain\
    \ Cause Parameters to inform\n   the receiver the reason of the abort.  DATA chunks\
    \ MUST NOT be\n   bundled with ABORT.  Control chunks (except for INIT, INIT ACK\
    \ and\n   SHUTDOWN COMPLETE) MAY be bundled with an ABORT but they MUST be\n \
    \  placed before the ABORT in the SCTP packet, or they will be ignored\n   by\
    \ the receiver.\n   If an endpoint receives an ABORT with a format error or for\
    \ an\n   association that doesn't exist, it MUST silently discard it.\n   Moreover,\
    \ under any circumstances, an endpoint that receives an ABORT\n   MUST NOT respond\
    \ to that ABORT by sending an ABORT of its own.\n       0                   1\
    \                   2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |   Type = 6    |Reserved     |T|           Length              |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \\\
    \                                                               \\\n      /  \
    \                 zero or more Error Causes                   /\n      \\    \
    \                                                           \\\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Chunk Flags: 8 bits\n   Reserved:  7 bits\n      Set to 0 on transmit and\
    \ ignored on receipt.\n   T bit:  1 bit\n      The T bit is set to 0 if the sender\
    \ had a TCB that it destroyed.\n      If the sender did not have a TCB it should\
    \ set this bit to 1.\n   Note: Special rules apply to this chunk for verification,\
    \ please see\n   Section 8.5.1 for details.\n   Length:  16 bits (unsigned integer)\n\
    \      Set to the size of the chunk in bytes, including the chunk header\n   \
    \   and all the Error Cause fields present.\n   See Section 3.3.10 for Error Cause\
    \ definitions.\n"
- title: '3.3.8 Shutdown Association (SHUTDOWN) (7):'
  contents:
  - "3.3.8 Shutdown Association (SHUTDOWN) (7):\n   An endpoint in an association\
    \ MUST use this chunk to initiate a\n   graceful close of the association with\
    \ its peer.  This chunk has the\n   following format.\n       0              \
    \     1                   2                   3\n       0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |   Type = 7    | Chunk  Flags  |      Length = 8               |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                      Cumulative TSN Ack                       |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Chunk Flags: 8 bits\n      Set to zero on transmit and ignored on receipt.\n\
    \   Length:  16 bits (unsigned integer)\n      Indicates the length of the parameter.\
    \  Set to 8.\n   Cumulative TSN Ack: 32 bits (unsigned integer)\n      This parameter\
    \ contains the TSN of the last chunk received in\n      sequence before any gaps.\n\
    \      Note:  Since the SHUTDOWN message does not contain Gap Ack Blocks,\n  \
    \    it cannot be used to acknowledge TSNs received out of order.  In a\n    \
    \  SACK, lack of Gap Ack Blocks that were previously included\n      indicates\
    \ that the data receiver reneged on the associated DATA\n      chunks.  Since\
    \ SHUTDOWN does not contain Gap Ack Blocks, the\n      receiver of the SHUTDOWN\
    \ shouldn't interpret the lack of a Gap Ack\n      Block as a renege. (see Section\
    \ 6.2 for information on reneging)\n"
- title: '3.3.9 Shutdown Acknowledgement (SHUTDOWN ACK) (8):'
  contents:
  - "3.3.9 Shutdown Acknowledgement (SHUTDOWN ACK) (8):\n   This chunk MUST be used\
    \ to acknowledge the receipt of the SHUTDOWN\n   chunk at the completion of the\
    \ shutdown process, see Section 9.2 for\n   details.\n   The SHUTDOWN ACK chunk\
    \ has no parameters.\n       0                   1                   2       \
    \            3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |   Type = 8    |Chunk  Flags   |      Length = 4               |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Chunk\
    \ Flags:  8 bits\n      Set to zero on transmit and ignored on receipt.\n"
- title: '3.3.10 Operation Error (ERROR) (9):'
  contents:
  - "3.3.10 Operation Error (ERROR) (9):\n   An endpoint sends this chunk to its peer\
    \ endpoint to notify it of\n   certain error conditions.  It contains one or more\
    \ error causes.  An\n   Operation Error is not considered fatal in and of itself,\
    \ but may be\n   used with an ABORT chunk to report a fatal condition.  It has\
    \ the\n   following parameters:\n       0                   1                \
    \   2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |   Type = 9    | Chunk  Flags  |           Length              |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \\\
    \                                                               \\\n      /  \
    \                  one or more Error Causes                   /\n      \\    \
    \                                                           \\\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Chunk Flags:  8 bits\n      Set to zero on transmit and ignored on receipt.\n\
    \   Length:  16 bits (unsigned integer)\n      Set to the size of the chunk in\
    \ bytes, including the chunk header\n      and all the Error Cause fields present.\n\
    \   Error causes are defined as variable-length parameters using the\n   format\
    \ described in 3.2.1, i.e.:\n       0                   1                   2\
    \                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |           Cause Code          |       Cause Length            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      /\
    \                    Cause-specific Information                 /\n      \\  \
    \                                                             \\\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Cause Code: 16 bits (unsigned integer)\n      Defines the type of error conditions\
    \ being reported.\n      Cause Code\n      Value           Cause Code\n      ---------\
    \      ----------------\n       1              Invalid Stream Identifier\n   \
    \    2              Missing Mandatory Parameter\n       3              Stale Cookie\
    \ Error\n       4              Out of Resource\n       5              Unresolvable\
    \ Address\n       6              Unrecognized Chunk Type\n       7           \
    \   Invalid Mandatory Parameter\n       8              Unrecognized Parameters\n\
    \       9              No User Data\n      10              Cookie Received While\
    \ Shutting Down\n   Cause Length: 16 bits (unsigned integer)\n      Set to the\
    \ size of the parameter in bytes, including the Cause\n      Code, Cause Length,\
    \ and Cause-Specific Information fields\n   Cause-specific Information: variable\
    \ length\n      This field carries the details of the error condition.\n   Sections\
    \ 3.3.10.1 - 3.3.10.10 define error causes for SCTP.\n   Guidelines for the IETF\
    \ to define new error cause values are\n   discussed in Section 13.3.\n"
- title: 3.3.10.1 Invalid Stream Identifier (1)
  contents:
  - "3.3.10.1 Invalid Stream Identifier (1)\n   Cause of error\n   ---------------\n\
    \   Invalid Stream Identifier:  Indicates endpoint received a DATA chunk\n   sent\
    \ to a nonexistent stream.\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |     Cause Code=1              |      Cause Length=8           |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \        Stream Identifier      |         (Reserved)            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Stream Identifier: 16 bits (unsigned integer)\n      Contains the Stream Identifier\
    \ of the DATA chunk received in\n      error.\n   Reserved: 16 bits\n      This\
    \ field is reserved.  It is set to all 0's on transmit and\n      Ignored on receipt.\n"
- title: 3.3.10.2 Missing Mandatory Parameter (2)
  contents:
  - "3.3.10.2 Missing Mandatory Parameter (2)\n   Cause of error\n   ---------------\n\
    \   Missing Mandatory Parameter:  Indicates that one or more mandatory\n   TLV\
    \ parameters are missing in a received INIT or INIT ACK.\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |     Cause Code=2              |      Cause Length=8+N*2       |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                   Number of missing params=N                  |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |   Missing Param Type #1       |   Missing Param Type #2       |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \   Missing Param Type #N-1     |   Missing Param Type #N       |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Number of Missing params:  32 bits (unsigned integer)\n      This field contains\
    \ the number of parameters contained in the\n      Cause-specific Information\
    \ field.\n   Missing Param Type:  16 bits (unsigned integer)\n      Each field\
    \ will contain the missing mandatory parameter number.\n"
- title: 3.3.10.3 Stale Cookie Error (3)
  contents:
  - "3.3.10.3 Stale Cookie Error (3)\n   Cause of error\n   --------------\n   Stale\
    \ Cookie Error:  Indicates the receipt of a valid State Cookie\n   that has expired.\n\
    \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   \
    \   |     Cause Code=3              |       Cause Length=8          |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                 Measure of Staleness (usec.)                  |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Measure\
    \ of Staleness:  32 bits (unsigned integer)\n      This field contains the difference,\
    \ in microseconds, between the\n      current time and the time the State Cookie\
    \ expired.\n      The sender of this error cause MAY choose to report how long\
    \ past\n      expiration the State Cookie is by including a non-zero value in\n\
    \      the Measure of Staleness field.  If the sender does not wish to\n     \
    \ provide this information it should set the Measure of Staleness\n      field\
    \ to the value of zero.\n"
- title: 3.3.10.4 Out of Resource (4)
  contents:
  - "3.3.10.4 Out of Resource (4)\n   Cause of error\n   ---------------\n   Out of\
    \ Resource: Indicates that the sender is out of resource.  This\n   is usually\
    \ sent in combination with or within an ABORT.\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |     Cause Code=4              |      Cause Length=4           |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 3.3.10.5 Unresolvable Address (5)
  contents:
  - "3.3.10.5 Unresolvable Address (5)\n   Cause of error\n   ---------------\n  \
    \ Unresolvable Address: Indicates that the sender is not able to\n   resolve the\
    \ specified address parameter (e.g., type of address is not\n   supported by the\
    \ sender).  This is usually sent in combination with\n   or within an ABORT.\n\
    \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   \
    \   |     Cause Code=5              |      Cause Length             |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      /                  Unresolvable Address                         /\n   \
    \   \\                                                               \\\n    \
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Unresolvable\
    \ Address:  variable length\n      The unresolvable address field contains the\
    \ complete Type, Length\n      and Value of the address parameter (or Host Name\
    \ parameter) that\n      contains the unresolvable address or host name.\n"
- title: 3.3.10.6 Unrecognized Chunk Type (6)
  contents:
  - "3.3.10.6 Unrecognized Chunk Type (6)\n   Cause of error\n   ---------------\n\
    \   Unrecognized Chunk Type:  This error cause is returned to the\n   originator\
    \ of the chunk if the receiver does not understand the chunk\n   and the upper\
    \ bits of the 'Chunk Type' are set to 01 or 11.\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |     Cause Code=6              |      Cause Length             |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      /\
    \                  Unrecognized Chunk                           /\n      \\  \
    \                                                             \\\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Unrecognized Chunk:  variable length\n      The Unrecognized Chunk field contains\
    \ the unrecognized Chunk from\n      the SCTP packet complete with Chunk Type,\
    \ Chunk Flags and Chunk\n      Length.\n"
- title: 3.3.10.7 Invalid Mandatory Parameter (7)
  contents:
  - "3.3.10.7 Invalid Mandatory Parameter (7)\n   Cause of error\n   ---------------\n\
    \   Invalid Mandatory Parameter:  This error cause is returned to the\n   originator\
    \ of an INIT or INIT ACK chunk when one of the mandatory\n   parameters is set\
    \ to a invalid value.\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |     Cause Code=7              |      Cause Length=4           |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 3.3.10.8 Unrecognized Parameters (8)
  contents:
  - "3.3.10.8 Unrecognized Parameters (8)\n   Cause of error\n   ---------------\n\
    \   Unrecognized Parameters:  This error cause is returned to the\n   originator\
    \ of the INIT ACK chunk if the receiver does not recognize\n   one or more Optional\
    \ TLV parameters in the INIT ACK chunk.\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |     Cause Code=8              |      Cause Length             |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      /\
    \                  Unrecognized Parameters                      /\n      \\  \
    \                                                             \\\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Unrecognized Parameters:  variable length\n      The Unrecognized Parameters\
    \ field contains the unrecognized\n      parameters copied from the INIT ACK chunk\
    \ complete with TLV.  This\n      error cause is normally contained in an ERROR\
    \ chunk bundled with\n      the COOKIE ECHO chunk when responding to the INIT\
    \ ACK, when the\n      sender of the COOKIE ECHO chunk wishes to report unrecognized\n\
    \      parameters.\n"
- title: 3.3.10.9 No User Data (9)
  contents:
  - "3.3.10.9 No User Data (9)\n   Cause of error\n   ---------------\n   No User\
    \ Data:  This error cause is returned to the originator of a\n   DATA chunk if\
    \ a received DATA chunk has no user data.\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |     Cause Code=9              |      Cause Length=8           |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      /\
    \                  TSN value                                    /\n      \\  \
    \                                                             \\\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   TSN value:  32 bits (+unsigned integer)\n      The TSN value field contains\
    \ the TSN of the DATA chunk received\n      with no user data field.\n      This\
    \ cause code is normally returned in an ABORT chunk (see\n      Section 6.2)\n"
- title: 3.3.10.10 Cookie Received While Shutting Down (10)
  contents:
  - "3.3.10.10 Cookie Received While Shutting Down (10)\n   Cause of error\n   ---------------\n\
    \   Cookie Received While Shutting Down:  A COOKIE ECHO was received\n   While\
    \ the endpoint was in SHUTDOWN-ACK-SENT state.  This error is\n   usually returned\
    \ in an ERROR chunk bundled with the retransmitted\n   SHUTDOWN ACK.\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |     Cause Code=10              |      Cause Length=4          |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: '3.3.11 Cookie Echo (COOKIE ECHO) (10):'
  contents:
  - "3.3.11 Cookie Echo (COOKIE ECHO) (10):\n   This chunk is used only during the\
    \ initialization of an association.\n   It is sent by the initiator of an association\
    \ to its peer to complete\n   the initialization process.  This chunk MUST precede\
    \ any DATA chunk\n   sent within the association, but MAY be bundled with one\
    \ or more DATA\n   chunks in the same packet.\n       0                   1  \
    \                 2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |   Type = 10   |Chunk  Flags   |         Length                |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      /\
    \                     Cookie                                    /\n      \\  \
    \                                                             \\\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Chunk Flags: 8 bit\n      Set to zero on transmit and ignored on receipt.\n\
    \   Length: 16 bits (unsigned integer)\n      Set to the size of the chunk in\
    \ bytes, including the 4 bytes of\n      the chunk header and the size of the\
    \ Cookie.\n   Cookie: variable size\n      This field must contain the exact cookie\
    \ received in the State\n      Cookie parameter from the previous INIT ACK.\n\
    \      An implementation SHOULD make the cookie as small as possible to\n    \
    \  insure interoperability.\n"
- title: '3.3.12 Cookie Acknowledgement (COOKIE ACK) (11):'
  contents:
  - "3.3.12 Cookie Acknowledgement (COOKIE ACK) (11):\n   This chunk is used only\
    \ during the initialization of an association.\n   It is used to acknowledge the\
    \ receipt of a COOKIE ECHO chunk.  This\n   chunk MUST precede any DATA or SACK\
    \ chunk sent within the\n   association, but MAY be bundled with one or more DATA\
    \ chunks or SACK\n   chunk in the same SCTP packet.\n       0                \
    \   1                   2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |   Type = 11   |Chunk  Flags   |     Length = 4                |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Chunk\
    \ Flags: 8 bits\n      Set to zero on transmit and ignored on receipt.\n"
- title: '3.3.13 Shutdown Complete (SHUTDOWN COMPLETE) (14):'
  contents:
  - "3.3.13 Shutdown Complete (SHUTDOWN COMPLETE) (14):\n   This chunk MUST be used\
    \ to acknowledge the receipt of the SHUTDOWN\n   ACK chunk at the completion of\
    \ the shutdown process, see Section 9.2\n   for details.\n   The SHUTDOWN COMPLETE\
    \ chunk has no parameters.\n       0                   1                   2 \
    \                  3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |   Type = 14   |Reserved     |T|      Length = 4               |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Chunk\
    \ Flags: 8 bits\n   Reserved:  7 bits\n      Set to 0 on transmit and ignored\
    \ on receipt.\n   T bit:  1 bit\n      The T bit is set to 0 if the sender had\
    \ a TCB that it destroyed.\n      If the sender did not have a TCB it should set\
    \ this bit to 1.\n   Note: Special rules apply to this chunk for verification,\
    \ please see\n   Section 8.5.1 for details.\n"
- title: 4. SCTP Association State Diagram
  contents:
  - "4. SCTP Association State Diagram\n   During the lifetime of an SCTP association,\
    \ the SCTP endpoint's\n   association progress from one state to another in response\
    \ to various\n   events.  The events that may potentially advance an association's\n\
    \   state include:\n   o  SCTP user primitive calls, e.g., [ASSOCIATE], [SHUTDOWN],\
    \ [ABORT],\n   o  Reception of INIT, COOKIE ECHO, ABORT, SHUTDOWN, etc., control\n\
    \      chunks, or\n   o  Some timeout events.\n   The state diagram in the figures\
    \ below illustrates state changes,\n   together with the causing events and resulting\
    \ actions.  Note that\n   some of the error conditions are not shown in the state\
    \ diagram.\n   Full description of all special cases should be found in the text.\n\
    \   Note: Chunk names are given in all capital letters, while parameter\n   names\
    \ have the first letter capitalized, e.g., COOKIE ECHO chunk type\n   vs. State\
    \ Cookie parameter.  If more than one event/message can occur\n   which causes\
    \ a state transition it is labeled (A), (B) etc.\n                       -----\
    \          -------- (frm any state)\n                     /       \\      /  rcv\
    \ ABORT      [ABORT]\n    rcv INIT        |         |    |   ----------  or ----------\n\
    \    --------------- |         v    v   delete TCB     snd ABORT\n    generate\
    \ Cookie  \\    +---------+                 delete TCB\n    snd INIT ACK     \
    \  ---|  CLOSED |\n                          +---------+\n                   \
    \        /      \\      [ASSOCIATE]\n                          /        \\   \
    \  ---------------\n                         |          |    create TCB\n    \
    \                     |          |    snd INIT\n                         |   \
    \       |    strt init timer\n          rcv valid      |          |\n        COOKIE\
    \  ECHO     |          v\n    (1) ---------------- |      +------------+\n   \
    \     create TCB       |      | COOKIE-WAIT| (2)\n        snd COOKIE ACK   | \
    \     +------------+\n                         |          |\n                \
    \         |          |    rcv INIT ACK\n                         |          |\
    \    -----------------\n                         |          |    snd COOKIE ECHO\n\
    \                         |          |    stop init timer\n                  \
    \       |          |    strt cookie timer\n                         |        \
    \  v\n                         |      +--------------+\n                     \
    \    |      | COOKIE-ECHOED| (3)\n                         |      +--------------+\n\
    \                         |          |\n                         |          |\
    \    rcv COOKIE ACK\n                         |          |    -----------------\n\
    \                         |          |    stop cookie timer\n                \
    \         v          v\n                       +---------------+\n           \
    \            |  ESTABLISHED  |\n                       +---------------+\n   \
    \                   (from the ESTABLISHED state only)\n                      \
    \              |\n                                    |\n                    \
    \       /--------+--------\\\n       [SHUTDOWN]         /                   \\\
    \n       -------------------|                   |\n       check outstanding  |\
    \                   |\n       DATA chunks        |                   |\n     \
    \                     v                   |\n                     +---------+\
    \              |\n                     |SHUTDOWN-|              | rcv SHUTDOWN/check\n\
    \                     |PENDING  |              | outstanding DATA\n          \
    \           +---------+              | chunks\n                          |   \
    \                |------------------\n     No more outstanding  |            \
    \       |\n     ---------------------|                   |\n     snd SHUTDOWN\
    \         |                   |\n     strt shutdown timer  |                 \
    \  |\n                          v                   v\n                     +---------+\
    \        +-----------+\n                 (4) |SHUTDOWN-|        | SHUTDOWN- |\
    \  (5,6)\n                     |SENT     |        | RECEIVED  |\n            \
    \         +---------+        +-----------+\n                          |  \\  \
    \              |\n    (A) rcv SHUTDOWN ACK  |   \\               |\n    ----------------------|\
    \    \\              |\n    stop shutdown timer   |     \\rcv:SHUTDOWN |\n   \
    \ send SHUTDOWN COMPLETE|      \\  (B)       |\n    delete TCB            |  \
    \     \\           |\n                          |        \\          | No more\
    \ outstanding\n                          |         \\         |-----------------\n\
    \                          |          \\        | send SHUTDOWN ACK\n    (B)rcv\
    \ SHUTDOWN       |           \\       | strt shutdown timer\n    ----------------------|\
    \            \\      |\n    send SHUTDOWN ACK     |             \\     |\n   \
    \ start shutdown timer  |              \\    |\n    move to SHUTDOWN-     |  \
    \             \\   |\n    ACK-SENT              |                |  |\n      \
    \                    |                v  |\n                          |      \
    \       +-----------+\n                          |             | SHUTDOWN- | (7)\n\
    \                          |             | ACK-SENT  |\n                     \
    \     |             +----------+-\n                          |               \
    \    | (C)rcv SHUTDOWN COMPLETE\n                          |                 \
    \  |-----------------\n                          |                   | stop shutdown\
    \ timer\n                          |                   | delete TCB\n        \
    \                  |                   |\n                          |        \
    \           | (D)rcv SHUTDOWN ACK\n                          |               \
    \    |--------------\n                          |                   | stop shutdown\
    \ timer\n                          |                   | send SHUTDOWN COMPLETE\n\
    \                          |                   | delete TCB\n                \
    \          |                   |\n                          \\    +---------+\
    \    /\n                           \\-->| CLOSED  |<--/\n                    \
    \           +---------+\n              Figure 3: State Transition Diagram of SCTP\n\
    \   Notes:\n   1) If the State Cookie in the received COOKIE ECHO is invalid (i.e.,\n\
    \      failed to pass the integrity check), the receiver MUST silently\n     \
    \ discard the packet.  Or, if the received State Cookie is expired\n      (see\
    \ Section 5.1.5), the receiver MUST send back an ERROR chunk.\n      In either\
    \ case, the receiver stays in the CLOSED state.\n   2) If the T1-init timer expires,\
    \ the endpoint MUST retransmit INIT\n      and re-start the T1-init timer without\
    \ changing state.  This MUST\n      be repeated up to 'Max.Init.Retransmits' times.\
    \  After that, the\n      endpoint MUST abort the initialization process and report\
    \ the\n      error to SCTP user.\n   3) If the T1-cookie timer expires, the endpoint\
    \ MUST retransmit\n      COOKIE ECHO and re-start the T1-cookie timer without\
    \ changing\n      state.  This MUST be repeated up to 'Max.Init.Retransmits' times.\n\
    \      After that, the endpoint MUST abort the initialization process and\n  \
    \    report the error to SCTP user.\n   4) In SHUTDOWN-SENT state the endpoint\
    \ MUST acknowledge any received\n      DATA chunks without delay.\n   5) In SHUTDOWN-RECEIVED\
    \ state, the endpoint MUST NOT accept any new\n      send request from its SCTP\
    \ user.\n   6) In SHUTDOWN-RECEIVED state, the endpoint MUST transmit or\n   \
    \   retransmit data and leave this state when all data in queue is\n      transmitted.\n\
    \   7) In SHUTDOWN-ACK-SENT state, the endpoint MUST NOT accept any new\n    \
    \  send request from its SCTP user.\n   The CLOSED state is used to indicate that\
    \ an association is not\n   created (i.e., doesn't exist).\n"
- title: 5. Association Initialization
  contents:
  - "5. Association Initialization\n   Before the first data transmission can take\
    \ place from one SCTP\n   endpoint (\"A\") to another SCTP endpoint (\"Z\"), the\
    \ two endpoints must\n   complete an initialization process in order to set up\
    \ an SCTP\n   association between them.\n   The SCTP user at an endpoint should\
    \ use the ASSOCIATE primitive to\n   initialize an SCTP association to another\
    \ SCTP endpoint.\n   IMPLEMENTATION NOTE: From an SCTP-user's point of view, an\n\
    \   association may be implicitly opened, without an ASSOCIATE primitive\n   (see\
    \ 10.1 B) being invoked, by the initiating endpoint's sending of\n   the first\
    \ user data to the destination endpoint.  The initiating SCTP\n   will assume\
    \ default values for all mandatory and optional parameters\n   for the INIT/INIT\
    \ ACK.\n   Once the association is established, unidirectional streams are open\n\
    \   for data transfer on both ends (see Section 5.1.1).\n"
- title: 5.1 Normal Establishment of an Association
  contents:
  - "5.1 Normal Establishment of an Association\n   The initialization process consists\
    \ of the following steps (assuming\n   that SCTP endpoint \"A\" tries to set up\
    \ an association with SCTP\n   endpoint \"Z\" and \"Z\" accepts the new association):\n\
    \   A) \"A\" first sends an INIT chunk to \"Z\".  In the INIT, \"A\" must\n  \
    \    provide its Verification Tag (Tag_A) in the Initiate Tag field.\n      Tag_A\
    \ SHOULD be a random number in the range of 1 to 4294967295\n      (see 5.3.1\
    \ for Tag value selection).  After sending the INIT, \"A\"\n      starts the T1-init\
    \ timer and enters the COOKIE-WAIT state.\n   B) \"Z\" shall respond immediately\
    \ with an INIT ACK chunk.  The\n      destination IP address of the INIT ACK MUST\
    \ be set to the source\n      IP address of the INIT to which this INIT ACK is\
    \ responding.  In\n      the response, besides filling in other parameters, \"\
    Z\" must set\n      the Verification Tag field to Tag_A, and also provide its\
    \ own\n      Verification Tag (Tag_Z) in the Initiate Tag field.\n      Moreover,\
    \ \"Z\" MUST generate and send along with the INIT ACK a\n      State Cookie.\
    \  See Section 5.1.3 for State Cookie generation.\n      Note: After sending out\
    \ INIT ACK with the State Cookie parameter,\n      \"Z\" MUST NOT allocate any\
    \ resources, nor keep any states for the\n      new association.  Otherwise, \"\
    Z\" will be vulnerable to resource\n      attacks.\n   C) Upon reception of the\
    \ INIT ACK from \"Z\", \"A\" shall stop the T1-\n      init timer and leave COOKIE-WAIT\
    \ state.  \"A\" shall then send the\n      State Cookie received in the INIT ACK\
    \ chunk in a COOKIE ECHO\n      chunk, start the T1-cookie timer, and enter the\
    \ COOKIE-ECHOED\n      state.\n      Note: The COOKIE ECHO chunk can be bundled\
    \ with any pending\n      outbound DATA chunks, but it MUST be the first chunk\
    \ in the packet\n      and until the COOKIE ACK is returned the sender MUST NOT\
    \ send any\n      other packets to the peer.\n   D) Upon reception of the COOKIE\
    \ ECHO chunk, Endpoint \"Z\" will reply\n      with a COOKIE ACK chunk after building\
    \ a TCB and moving to the\n      ESTABLISHED state.  A COOKIE ACK chunk may be\
    \ bundled with any\n      pending DATA chunks (and/or SACK chunks), but the COOKIE\
    \ ACK chunk\n      MUST be the first chunk in the packet.\n      IMPLEMENTATION\
    \ NOTE: An implementation may choose to send the\n      Communication Up notification\
    \ to the SCTP user upon reception of a\n      valid COOKIE ECHO chunk.\n   E)\
    \ Upon reception of the COOKIE ACK, endpoint \"A\" will move from the\n      COOKIE-ECHOED\
    \ state to the ESTABLISHED state, stopping the T1-\n      cookie timer.  It may\
    \ also notify its ULP about the successful\n      establishment of the association\
    \ with a Communication Up\n      notification (see Section 10).\n   An INIT or\
    \ INIT ACK chunk MUST NOT be bundled with any other chunk.\n   They MUST be the\
    \ only chunks present in the SCTP packets that carry\n   them.\n   An endpoint\
    \ MUST send the INIT ACK to the IP address from which it\n   received the INIT.\n\
    \   Note: T1-init timer and T1-cookie timer shall follow the same rules\n   given\
    \ in Section 6.3.\n   If an endpoint receives an INIT, INIT ACK, or COOKIE ECHO\
    \ chunk but\n   decides not to establish the new association due to missing mandatory\n\
    \   parameters in the received INIT or INIT ACK, invalid parameter\n   values,\
    \ or lack of local resources, it MUST respond with an ABORT\n   chunk.  It SHOULD\
    \ also specify the cause of abort, such as the type\n   of the missing mandatory\
    \ parameters, etc., by including the error\n   cause parameters with the ABORT\
    \ chunk.  The Verification Tag field in\n   the common header of the outbound\
    \ SCTP packet containing the ABORT\n   chunk MUST be set to the Initiate Tag value\
    \ of the peer.\n   After the reception of the first DATA chunk in an association\
    \ the\n   endpoint MUST immediately respond with a SACK to acknowledge the DATA\n\
    \   chunk.  Subsequent acknowledgements should be done as described in\n   Section\
    \ 6.2.\n   When the TCB is created, each endpoint MUST set its internal\n   Cumulative\
    \ TSN Ack Point to the value of its transmitted Initial TSN\n   minus one.\n \
    \  IMPLEMENTATION NOTE:  The IP addresses and SCTP port are generally\n   used\
    \ as the key to find the TCB within an SCTP instance.\n"
- title: 5.1.1 Handle Stream Parameters
  contents:
  - "5.1.1 Handle Stream Parameters\n   In the INIT and INIT ACK chunks, the sender\
    \ of the chunk shall\n   indicate the number of outbound streams (OS) it wishes\
    \ to have in the\n   association, as well as the maximum inbound streams (MIS)\
    \ it will\n   accept from the other endpoint.\n   After receiving the stream configuration\
    \ information from the other\n   side, each endpoint shall perform the following\
    \ check:  If the peer's\n   MIS is less than the endpoint's OS, meaning that the\
    \ peer is\n   incapable of supporting all the outbound streams the endpoint wants\n\
    \   to configure, the endpoint MUST either use MIS outbound streams, or\n   abort\
    \ the association and report to its upper layer the resources\n   shortage at\
    \ its peer.\n   After the association is initialized, the valid outbound stream\n\
    \   identifier range for either endpoint shall be 0 to min(local OS,\n   remote\
    \ MIS)-1.\n"
- title: 5.1.2 Handle Address Parameters
  contents:
  - "5.1.2 Handle Address Parameters\n   During the association initialization, an\
    \ endpoint shall use the\n   following rules to discover and collect the destination\
    \ transport\n   address(es) of its peer.\n   A) If there are no address parameters\
    \ present in the received INIT or\n      INIT ACK chunk, the endpoint shall take\
    \ the source IP address from\n      which the chunk arrives and record it, in\
    \ combination with the\n      SCTP source port number, as the only destination\
    \ transport address\n      for this peer.\n   B) If there is a Host Name parameter\
    \ present in the received INIT or\n      INIT ACK chunk, the endpoint shall resolve\
    \ that host name to a\n      list of IP address(es) and derive the transport address(es)\
    \ of\n      this peer by combining the resolved IP address(es) with the SCTP\n\
    \      source port.\n      The endpoint MUST ignore any other IP address parameters\
    \ if they\n      are also present in the received INIT or INIT ACK chunk.\n  \
    \    The time at which the receiver of an INIT resolves the host name\n      has\
    \ potential security implications to SCTP.  If the receiver of\n      an INIT\
    \ resolves the host name upon the reception of the chunk,\n      and the mechanism\
    \ the receiver uses to resolve the host name\n      involves potential long delay\
    \ (e.g. DNS query), the receiver may\n      open itself up to resource attacks\
    \ for the period of time while it\n      is waiting for the name resolution results\
    \ before it can build the\n      State Cookie and release local resources.\n \
    \     Therefore, in cases where the name translation involves potential\n    \
    \  long delay, the receiver of the INIT MUST postpone the name\n      resolution\
    \ till the reception of the COOKIE ECHO chunk from the\n      peer.  In such a\
    \ case, the receiver of the INIT SHOULD build the\n      State Cookie using the\
    \ received Host Name (instead of destination\n      transport addresses) and send\
    \ the INIT ACK to the source IP\n      address from which the INIT was received.\n\
    \      The receiver of an INIT ACK shall always immediately attempt to\n     \
    \ resolve the name upon the reception of the chunk.\n      The receiver of the\
    \ INIT or INIT ACK MUST NOT send user data\n      (piggy-backed or stand-alone)\
    \ to its peer until the host name is\n      successfully resolved.\n      If the\
    \ name resolution is not successful, the endpoint MUST\n      immediately send\
    \ an ABORT with \"Unresolvable Address\" error cause\n      to its peer.  The\
    \ ABORT shall be sent to the source IP address\n      from which the last peer\
    \ packet was received.\n   C) If there are only IPv4/IPv6 addresses present in\
    \ the received INIT\n      or INIT ACK chunk, the receiver shall derive and record\
    \ all the\n      transport address(es) from the received chunk AND the source\
    \ IP\n      address that sent the INIT or INIT ACK.  The transport address(es)\n\
    \      are derived by the combination of SCTP source port (from the\n      common\
    \ header) and the IP address parameter(s) carried in the INIT\n      or INIT ACK\
    \ chunk and the source IP address of the IP datagram.\n      The receiver should\
    \ use only these transport addresses as\n      destination transport addresses\
    \ when sending subsequent packets to\n      its peer.\n      IMPLEMENTATION NOTE:\
    \ In some cases (e.g., when the implementation\n      doesn't control the source\
    \ IP address that is used for\n      transmitting), an endpoint might need to\
    \ include in its INIT or\n      INIT ACK all possible IP addresses from which\
    \ packets to the peer\n      could be transmitted.\n   After all transport addresses\
    \ are derived from the INIT or INIT ACK\n   chunk using the above rules, the endpoint\
    \ shall select one of the\n   transport addresses as the initial primary path.\n\
    \   Note: The INIT-ACK MUST be sent to the source address of the INIT.\n   The\
    \ sender of INIT may include a 'Supported Address Types' parameter\n   in the\
    \ INIT to indicate what types of address are acceptable.  When\n   this parameter\
    \ is present, the receiver of INIT (initiatee) MUST\n   either use one of the\
    \ address types indicated in the Supported\n   Address Types parameter when responding\
    \ to the INIT, or abort the\n   association with an \"Unresolvable Address\" error\
    \ cause if it is\n   unwilling or incapable of using any of the address types\
    \ indicated by\n   its peer.\n   IMPLEMENTATION NOTE: In the case that the receiver\
    \ of an INIT ACK\n   fails to resolve the address parameter due to an unsupported\
    \ type, it\n   can abort the initiation process and then attempt a re-initiation\
    \ by\n   using a 'Supported Address Types' parameter in the new INIT to\n   indicate\
    \ what types of address it prefers.\n"
- title: 5.1.3 Generating State Cookie
  contents:
  - "5.1.3 Generating State Cookie\n   When sending an INIT ACK as a response to an\
    \ INIT chunk, the sender\n   of INIT ACK creates a State Cookie and sends it in\
    \ the State Cookie\n   parameter of the INIT ACK.  Inside this State Cookie, the\
    \ sender\n   should include a MAC (see [RFC2104] for an example), a time stamp\
    \ on\n   when the State Cookie is created, and the lifespan of the State\n   Cookie,\
    \ along with all the information necessary for it to establish\n   the association.\n\
    \   The following steps SHOULD be taken to generate the State Cookie:\n   1) Create\
    \ an association TCB using information from both the received\n      INIT and\
    \ the outgoing INIT ACK chunk,\n   2) In the TCB, set the creation time to the\
    \ current time of day, and\n      the lifespan to the protocol parameter 'Valid.Cookie.Life',\n\
    \   3) From the TCB, identify and collect the minimal subset of\n      information\
    \ needed to re-create the TCB, and generate a MAC using\n      this subset of\
    \ information and a secret key (see [RFC2104] for an\n      example of generating\
    \ a MAC), and\n   4) Generate the State Cookie by combining this subset of information\n\
    \      and the resultant MAC.\n   After sending the INIT ACK with the State Cookie\
    \ parameter, the\n   sender SHOULD delete the TCB and any other local resource\
    \ related to\n   the new association, so as to prevent resource attacks.\n   The\
    \ hashing method used to generate the MAC is strictly a private\n   matter for\
    \ the receiver of the INIT chunk.  The use of a MAC is\n   mandatory to prevent\
    \ denial of service attacks.  The secret key\n   SHOULD be random ([RFC1750] provides\
    \ some information on randomness\n   guidelines); it SHOULD be changed reasonably\
    \ frequently, and the\n   timestamp in the State Cookie MAY be used to determine\
    \ which key\n   should be used to verify the MAC.\n   An implementation SHOULD\
    \ make the cookie as small as possible to\n   insure interoperability.\n"
- title: 5.1.4 State Cookie Processing
  contents:
  - "5.1.4 State Cookie Processing\n   When an endpoint (in the COOKIE WAIT state)\
    \ receives an INIT ACK\n   chunk with a State Cookie parameter, it MUST immediately\
    \ send a\n   COOKIE ECHO chunk to its peer with the received State Cookie.  The\n\
    \   sender MAY also add any pending DATA chunks to the packet after the\n   COOKIE\
    \ ECHO chunk.\n   The endpoint shall also start the T1-cookie timer after sending\
    \ out\n   the COOKIE ECHO chunk.  If the timer expires, the endpoint shall\n \
    \  retransmit the COOKIE ECHO chunk and restart the T1-cookie timer.\n   This\
    \ is repeated until either a COOKIE ACK is received or '\n   Max.Init.Retransmits'\
    \ is reached causing the peer endpoint to be\n   marked unreachable (and thus\
    \ the association enters the CLOSED\n   state).\n"
- title: 5.1.5 State Cookie Authentication
  contents:
  - "5.1.5 State Cookie Authentication\n   When an endpoint receives a COOKIE ECHO\
    \ chunk from another endpoint\n   with which it has no association, it shall take\
    \ the following\n   actions:\n   1) Compute a MAC using the TCB data carried in\
    \ the State Cookie and\n      the secret key (note the timestamp in the State\
    \ Cookie MAY be used\n      to determine which secret key to use).  Reference\
    \ [RFC2104] can be\n      used as a guideline for generating the MAC,\n   2) Authenticate\
    \ the State Cookie as one that it previously generated\n      by comparing the\
    \ computed MAC against the one carried in the State\n      Cookie.  If this comparison\
    \ fails, the SCTP packet, including the\n      COOKIE ECHO and any DATA chunks,\
    \ should be silently discarded,\n   3) Compare the creation timestamp in the State\
    \ Cookie to the current\n      local time.  If the elapsed time is longer than\
    \ the lifespan\n      carried in the State Cookie, then the packet, including\
    \ the COOKIE\n      ECHO and any attached DATA chunks, SHOULD be discarded and\
    \ the\n      endpoint MUST transmit an ERROR chunk with a \"Stale Cookie\" error\n\
    \      cause to the peer endpoint,\n   4) If the State Cookie is valid, create\
    \ an association to the sender\n      of the COOKIE ECHO chunk with the information\
    \ in the TCB data\n      carried in the COOKIE ECHO, and enter the ESTABLISHED\
    \ state,\n   5) Send a COOKIE ACK chunk to the peer acknowledging reception of\
    \ the\n      COOKIE ECHO.  The COOKIE ACK MAY be bundled with an outbound DATA\n\
    \      chunk or SACK chunk; however, the COOKIE ACK MUST be the first\n      chunk\
    \ in the SCTP packet.\n   6) Immediately acknowledge any DATA chunk bundled with\
    \ the COOKIE\n      ECHO with a SACK (subsequent DATA chunk acknowledgement should\n\
    \      follow the rules defined in Section 6.2).  As mentioned in step\n     \
    \ 5), if the SACK is bundled with the COOKIE ACK, the COOKIE ACK\n      MUST appear\
    \ first in the SCTP packet.\n   If a COOKIE ECHO is received from an endpoint\
    \ with which the receiver\n   of the COOKIE ECHO has an existing association,\
    \ the procedures in\n   Section 5.2 should be followed.\n"
- title: 5.1.6 An Example of Normal Association Establishment
  contents:
  - "5.1.6 An Example of Normal Association Establishment\n   In the following example,\
    \ \"A\" initiates the association and then\n   sends a user message to \"Z\",\
    \ then \"Z\" sends two user messages to \"A\"\n   later (assuming no bundling\
    \ or fragmentation occurs):\n   Endpoint A                                   \
    \       Endpoint Z\n   {app sets association with Z}\n   (build TCB)\n   INIT\
    \ [I-Tag=Tag_A\n         & other info]  --------\\\n   (Start T1-init timer) \
    \        \\\n   (Enter COOKIE-WAIT state)      \\---> (compose temp TCB and Cookie_Z)\n\
    \                                   /--- INIT ACK [Veri Tag=Tag_A,\n         \
    \                         /              I-Tag=Tag_Z,\n   (Cancel T1-init timer)\
    \ <------/               Cookie_Z, & other info]\n                           \
    \             (destroy temp TCB)\n   COOKIE ECHO [Cookie_Z] ------\\\n   (Start\
    \ T1-init timer)         \\\n   (Enter COOKIE-ECHOED state)    \\---> (build TCB\
    \ enter ESTABLISHED\n                                         state)\n       \
    \                           /---- COOKIE-ACK\n                               \
    \  /\n   (Cancel T1-init timer, <-----/\n    Enter ESTABLISHED state)\n   {app\
    \ sends 1st user data; strm 0}\n   DATA [TSN=initial TSN_A\n       Strm=0,Seq=1\
    \ & user data]--\\\n    (Start T3-rtx timer)            \\\n                 \
    \                    \\->\n                                 /----- SACK [TSN Ack=init\n\
    \                                             TSN_A,Block=0]\n   (Cancel T3-rtx\
    \ timer) <------/\n                                        ...\n             \
    \                           {app sends 2 messages;strm 0}\n                  \
    \                /---- DATA\n                                 /        [TSN=init\
    \ TSN_Z\n                             <--/          Strm=0,Seq=1 & user data 1]\n\
    \   SACK [TSN Ack=init TSN_Z,      /---- DATA\n         Block=0]     --------\\\
    \  /        [TSN=init TSN_Z +1,\n                               \\/          Strm=0,Seq=2\
    \ & user data 2]\n                        <------/\\\n                       \
    \          \\\n                                  \\------>\n                 \
    \    Figure 4: INITiation Example\n   If the T1-init timer expires at \"A\" after\
    \ the INIT or COOKIE ECHO\n   chunks are sent, the same INIT or COOKIE ECHO chunk\
    \ with the same\n   Initiate Tag (i.e., Tag_A) or State Cookie shall be retransmitted\
    \ and\n   the timer restarted.  This shall be repeated Max.Init.Retransmits\n\
    \   times before \"A\" considers \"Z\" unreachable and reports the failure to\n\
    \   its upper layer (and thus the association enters the CLOSED state).\n   When\
    \ retransmitting the INIT, the endpoint MUST follow the rules\n   defined in 6.3\
    \ to determine the proper timer value.\n"
- title: 5.2 Handle Duplicate or Unexpected INIT, INIT ACK, COOKIE ECHO, and
  contents:
  - "5.2 Handle Duplicate or Unexpected INIT, INIT ACK, COOKIE ECHO, and\n   COOKIE\
    \ ACK\n   During the lifetime of an association (in one of the possible\n   states),\
    \ an endpoint may receive from its peer endpoint one of the\n   setup chunks (INIT,\
    \ INIT ACK, COOKIE ECHO, and COOKIE ACK).  The\n   receiver shall treat such a\
    \ setup chunk as a duplicate and process it\n   as described in this section.\n\
    \   Note:  An endpoint will not receive the chunk unless the chunk was\n   sent\
    \ to a SCTP transport address and is from a SCTP transport address\n   associated\
    \ with this endpoint.  Therefore, the endpoint processes\n   such a chunk as part\
    \ of its current association.\n   The following scenarios can cause duplicated\
    \ or unexpected chunks:\n   A) The peer has crashed without being detected, re-started\
    \ itself and\n      sent out a new INIT chunk trying to restore the association,\n\
    \   B) Both sides are trying to initialize the association at about the\n    \
    \  same time,\n   C) The chunk is from a stale packet that was used to establish\
    \ the\n      present association or a past association that is no longer in\n\
    \      existence,\n   D) The chunk is a false packet generated by an attacker,\
    \ or\n   E) The peer never received the COOKIE ACK and is retransmitting its\n\
    \      COOKIE ECHO.\n   The rules in the following sections shall be applied in\
    \ order to\n   identify and correctly handle these cases.\n"
- title: 5.2.1 INIT received in COOKIE-WAIT or COOKIE-ECHOED State (Item B)
  contents:
  - "5.2.1 INIT received in COOKIE-WAIT or COOKIE-ECHOED State (Item B)\n   This usually\
    \ indicates an initialization collision, i.e., each\n   endpoint is attempting,\
    \ at about the same time, to establish an\n   association with the other endpoint.\n\
    \   Upon receipt of an INIT in the COOKIE-WAIT or COOKIE-ECHOED state, an\n  \
    \ endpoint MUST respond with an INIT ACK using the same parameters it\n   sent\
    \ in its original INIT chunk (including its Initiation Tag,\n   unchanged).  These\
    \ original parameters are combined with those from\n   the newly received INIT\
    \ chunk.  The endpoint shall also generate a\n   State Cookie with the INIT ACK.\
    \  The endpoint uses the parameters\n   sent in its INIT to calculate the State\
    \ Cookie.\n   After that, the endpoint MUST NOT change its state, the T1-init\
    \ timer\n   shall be left running and the corresponding TCB MUST NOT be\n   destroyed.\
    \  The normal procedures for handling State Cookies when a\n   TCB exists will\
    \ resolve the duplicate INITs to a single association.\n   For an endpoint that\
    \ is in the COOKIE-ECHOED state it MUST populate\n   its Tie-Tags with the Tag\
    \ information of itself and its peer (see\n   section 5.2.2 for a description\
    \ of the Tie-Tags).\n"
- title: 5.2.2 Unexpected INIT in States Other than CLOSED, COOKIE-ECHOED,
  contents:
  - "5.2.2 Unexpected INIT in States Other than CLOSED, COOKIE-ECHOED,\n         COOKIE-WAIT\
    \ and SHUTDOWN-ACK-SENT\n   Unless otherwise stated, upon reception of an unexpected\
    \ INIT for\n   this association, the endpoint shall generate an INIT ACK with\
    \ a\n   State Cookie.  In the outbound INIT ACK the endpoint MUST copy its\n \
    \  current Verification Tag and peer's Verification Tag into a reserved\n   place\
    \ within the state cookie.  We shall refer to these locations as\n   the Peer's-Tie-Tag\
    \ and the Local-Tie-Tag.  The outbound SCTP packet\n   containing this INIT ACK\
    \ MUST carry a Verification Tag value equal to\n   the Initiation Tag found in\
    \ the unexpected INIT.  And the INIT ACK\n   MUST contain a new Initiation Tag\
    \ (randomly generated see Section\n   5.3.1).  Other parameters for the endpoint\
    \ SHOULD be copied from the\n   existing parameters of the association (e.g. number\
    \ of outbound\n   streams) into the INIT ACK and cookie.\n   After sending out\
    \ the INIT ACK, the endpoint shall take no further\n   actions, i.e., the existing\
    \ association, including its current state,\n   and the corresponding TCB MUST\
    \ NOT be changed.\n   Note: Only when a TCB exists and the association is not\
    \ in a COOKIE-\n   WAIT state are the Tie-Tags populated.  For a normal association\
    \ INIT\n   (i.e. the endpoint is in a COOKIE-WAIT state), the Tie-Tags MUST be\n\
    \   set to 0 (indicating that no previous TCB existed).  The INIT ACK and\n  \
    \ State Cookie are populated as specified in section 5.2.1.\n"
- title: 5.2.3 Unexpected INIT ACK
  contents:
  - "5.2.3 Unexpected INIT ACK\n   If an INIT ACK is received by an endpoint in any\
    \ state other than the\n   COOKIE-WAIT state, the endpoint should discard the\
    \ INIT ACK chunk.\n   An unexpected INIT ACK usually indicates the processing\
    \ of an old or\n   duplicated INIT chunk.\n"
- title: 5.2.4 Handle a COOKIE ECHO when a TCB exists
  contents:
  - "5.2.4 Handle a COOKIE ECHO when a TCB exists\n   When a COOKIE ECHO chunk is\
    \ received by an endpoint in any state for\n   an existing association (i.e.,\
    \ not in the CLOSED state) the following\n   rules shall be applied:\n   1) Compute\
    \ a MAC as described in Step 1 of Section 5.1.5,\n   2) Authenticate the State\
    \ Cookie as described in Step 2 of Section\n      5.1.5 (this is case C or D above).\n\
    \   3) Compare the timestamp in the State Cookie to the current time.  If\n  \
    \    the State Cookie is older than the lifespan carried in the State\n      Cookie\
    \ and the Verification Tags contained in the State Cookie do\n      not match\
    \ the current association's Verification Tags, the packet,\n      including the\
    \ COOKIE ECHO and any DATA chunks, should be\n      discarded.  The endpoint also\
    \ MUST transmit an ERROR chunk with a\n      \"Stale Cookie\" error cause to the\
    \ peer endpoint (this is case C or\n      D in section 5.2).\n      If both Verification\
    \ Tags in the State Cookie match the\n      Verification Tags of the current association,\
    \ consider the State\n      Cookie valid (this is case E of section 5.2) even\
    \ if the lifespan\n      is exceeded.\n   4) If the State Cookie proves to be\
    \ valid, unpack the TCB into a\n      temporary TCB.\n   5) Refer to Table 2 to\
    \ determine the correct action to be taken.\n"
- title: +------------+------------+---------------+--------------+-------------+
  contents:
  - '+------------+------------+---------------+--------------+-------------+

    '
- title: '|  Local Tag | Peer''s Tag | Local-Tie-Tag |Peer''s-Tie-Tag|   Action/   |'
  contents:
  - '|  Local Tag | Peer''s Tag | Local-Tie-Tag |Peer''s-Tie-Tag|   Action/   |

    '
- title: '|            |            |               |              | Description |'
  contents:
  - '|            |            |               |              | Description |

    '
- title: +------------+------------+---------------+--------------+-------------+
  contents:
  - '+------------+------------+---------------+--------------+-------------+

    '
- title: '|    X       |     X      |      M        |      M       |     (A)     |'
  contents:
  - '|    X       |     X      |      M        |      M       |     (A)     |

    '
- title: +------------+------------+---------------+--------------+-------------+
  contents:
  - '+------------+------------+---------------+--------------+-------------+

    '
- title: '|    M       |     X      |      A        |      A       |     (B)     |'
  contents:
  - '|    M       |     X      |      A        |      A       |     (B)     |

    '
- title: +------------+------------+---------------+--------------+-------------+
  contents:
  - '+------------+------------+---------------+--------------+-------------+

    '
- title: '|    M       |     0      |      A        |      A       |     (B)     |'
  contents:
  - '|    M       |     0      |      A        |      A       |     (B)     |

    '
- title: +------------+------------+---------------+--------------+-------------+
  contents:
  - '+------------+------------+---------------+--------------+-------------+

    '
- title: '|    X       |     M      |      0        |      0       |     (C)     |'
  contents:
  - '|    X       |     M      |      0        |      0       |     (C)     |

    '
- title: +------------+------------+---------------+--------------+-------------+
  contents:
  - '+------------+------------+---------------+--------------+-------------+

    '
- title: '|    M       |     M      |      A        |      A       |     (D)     |'
  contents:
  - '|    M       |     M      |      A        |      A       |     (D)     |

    '
- title: +======================================================================+
  contents:
  - '+======================================================================+

    '
- title: '|       Table 2: Handling of a COOKIE ECHO when a TCB exists           |'
  contents:
  - '|       Table 2: Handling of a COOKIE ECHO when a TCB exists           |

    '
- title: +======================================================================+
  contents:
  - "+======================================================================+\n  \
    \ Legend:\n      X - Tag does not match the existing TCB\n      M - Tag matches\
    \ the existing TCB.\n      0 - No Tie-Tag in Cookie (unknown).\n      A - All\
    \ cases, i.e. M, X or 0.\n   Note: For any case not shown in Table 2, the cookie\
    \ should be\n   silently discarded.\n   Action\n   A) In this case, the peer may\
    \ have restarted.  When the endpoint\n      recognizes this potential 'restart',\
    \ the existing session is\n      treated the same as if it received an ABORT followed\
    \ by a new\n      COOKIE ECHO with the following exceptions:\n      -  Any SCTP\
    \ DATA Chunks MAY be retained (this is an implementation\n         specific option).\n\
    \      -  A notification of RESTART SHOULD be sent to the ULP instead of\n   \
    \      a \"COMMUNICATION LOST\" notification.\n      All the congestion control\
    \ parameters (e.g., cwnd, ssthresh)\n      related to this peer MUST be reset\
    \ to their initial values (see\n      Section 6.2.1).\n      After this the endpoint\
    \ shall enter the ESTABLISHED state.\n      If the endpoint is in the SHUTDOWN-ACK-SENT\
    \ state and recognizes\n      the peer has restarted (Action A), it MUST NOT setup\
    \ a new\n      association but instead resend the SHUTDOWN ACK and send an ERROR\n\
    \      chunk with a \"Cookie Received while Shutting Down\" error cause to\n \
    \     its peer.\n   B) In this case, both sides may be attempting to start an\
    \ association\n      at about the same time but the peer endpoint started its\
    \ INIT\n      after responding to the local endpoint's INIT.  Thus it may have\n\
    \      picked a new Verification Tag not being aware of the previous Tag\n   \
    \   it had sent this endpoint.  The endpoint should stay in or enter\n      the\
    \ ESTABLISHED state but it MUST update its peer's Verification\n      Tag from\
    \ the State Cookie, stop any init or cookie timers that may\n      running and\
    \ send a COOKIE ACK.\n   C) In this case, the local endpoint's cookie has arrived\
    \ late.\n      Before it arrived, the local endpoint sent an INIT and received\
    \ an\n      INIT-ACK and finally sent a COOKIE ECHO with the peer's same tag\n\
    \      but a new tag of its own.  The cookie should be silently\n      discarded.\
    \  The endpoint SHOULD NOT change states and should leave\n      any timers running.\n\
    \   D) When both local and remote tags match the endpoint should always\n    \
    \  enter the ESTABLISHED state, if it has not already done so. It\n      should\
    \ stop any init or cookie timers that may be running and send\n      a COOKIE\
    \ ACK.\n   Note: The \"peer's Verification Tag\" is the tag received in the\n\
    \   Initiate Tag field of the INIT or INIT ACK chunk.\n"
- title: 5.2.4.1 An Example of a Association Restart
  contents:
  - "5.2.4.1 An Example of a Association Restart\n   In the following example, \"\
    A\" initiates the association after a\n   restart has occurred.  Endpoint \"Z\"\
    \ had no knowledge of the restart\n   until the exchange (i.e. Heartbeats had\
    \ not yet detected the failure\n   of \"A\").  (assuming no bundling or fragmentation\
    \ occurs):\n"
- title: Endpoint A                                          Endpoint Z
  contents:
  - 'Endpoint A                                          Endpoint Z

    '
- title: <-------------- Association is established---------------------->
  contents:
  - '<-------------- Association is established---------------------->

    '
- title: Tag=Tag_A                                             Tag=Tag_Z
  contents:
  - 'Tag=Tag_A                                             Tag=Tag_Z

    '
- title: <--------------------------------------------------------------->
  contents:
  - '<--------------------------------------------------------------->

    '
- title: '{A crashes and restarts}'
  contents:
  - '{A crashes and restarts}

    '
- title: '{app sets up a association with Z}'
  contents:
  - '{app sets up a association with Z}

    '
- title: (build TCB)
  contents:
  - '(build TCB)

    '
- title: INIT [I-Tag=Tag_A'
  contents:
  - "INIT [I-Tag=Tag_A'\n      & other info]  --------\\\n"
- title: (Start T1-init timer)         \
  contents:
  - '(Start T1-init timer)         \

    '
- title: (Enter COOKIE-WAIT state)      \---> (find a existing TCB
  contents:
  - "(Enter COOKIE-WAIT state)      \\---> (find a existing TCB\n                \
    \                      compose temp TCB and Cookie_Z\n                       \
    \               with Tie-Tags to previous\n                                  \
    \    association)\n                                /--- INIT ACK [Veri Tag=Tag_A',\n\
    \                               /               I-Tag=Tag_Z',\n"
- title: (Cancel T1-init timer) <------/                Cookie_Z[TieTags=
  contents:
  - "(Cancel T1-init timer) <------/                Cookie_Z[TieTags=\n          \
    \                                     Tag_A,Tag_Z\n                          \
    \                      & other info]\n                                     (destroy\
    \ temp TCB,leave original\n                                      in place)\n"
- title: COOKIE ECHO [Veri=Tag_Z',
  contents:
  - "COOKIE ECHO [Veri=Tag_Z',\n             Cookie_Z\n             Tie=Tag_A,\n \
    \            Tag_Z]----------\\\n"
- title: (Start T1-init timer)         \
  contents:
  - '(Start T1-init timer)         \

    '
- title: (Enter COOKIE-ECHOED state)    \---> (Find existing association,
  contents:
  - "(Enter COOKIE-ECHOED state)    \\---> (Find existing association,\n         \
    \                             Tie-Tags match old tags,\n                     \
    \                 Tags do not match i.e.\n                                   \
    \   case X X M M above,\n                                      Announce Restart\
    \ to ULP\n                                      and reset association).\n    \
    \                           /---- COOKIE-ACK\n                              /\n"
- title: (Cancel T1-init timer, <-----/
  contents:
  - "(Cancel T1-init timer, <-----/\n Enter ESTABLISHED state)\n"
- title: '{app sends 1st user data; strm 0}'
  contents:
  - '{app sends 1st user data; strm 0}

    '
- title: DATA [TSN=initial TSN_A
  contents:
  - "DATA [TSN=initial TSN_A\n     Strm=0,Seq=1 & user data]--\\\n"
- title: (Start T3-rtx timer)            \
  contents:
  - "(Start T3-rtx timer)            \\\n                                 \\->\n \
    \                             /----- SACK [TSN Ack=init TSN_A,Block=0]\n"
- title: (Cancel T3-rtx timer) <------/
  contents:
  - "(Cancel T3-rtx timer) <------/\n                  Figure 5: A Restart Example\n"
- title: 5.2.5 Handle Duplicate COOKIE-ACK.
  contents:
  - "5.2.5 Handle Duplicate COOKIE-ACK.\n   At any state other than COOKIE-ECHOED,\
    \ an endpoint should silently\n   discard a received COOKIE ACK chunk.\n"
- title: 5.2.6 Handle Stale COOKIE Error
  contents:
  - "5.2.6 Handle Stale COOKIE Error\n   Receipt of an ERROR chunk with a \"Stale\
    \ Cookie\" error cause indicates\n   one of a number of possible events:\n   A)\
    \ That the association failed to completely setup before the State\n      Cookie\
    \ issued by the sender was processed.\n   B) An old State Cookie was processed\
    \ after setup completed.\n   C) An old State Cookie is received from someone that\
    \ the receiver is\n      not interested in having an association with and the\
    \ ABORT chunk\n      was lost.\n   When processing an ERROR chunk with a \"Stale\
    \ Cookie\" error cause an\n   endpoint should first examine if an association\
    \ is in the process of\n   being setup, i.e. the association is in the COOKIE-ECHOED\
    \ state.  In\n   all cases if the association is not in the COOKIE-ECHOED state,\
    \ the\n   ERROR chunk should be silently discarded.\n   If the association is\
    \ in the COOKIE-ECHOED state, the endpoint may\n   elect one of the following\
    \ three alternatives.\n   1) Send a new INIT chunk to the endpoint to generate\
    \ a new State\n      Cookie and re-attempt the setup procedure.\n   2) Discard\
    \ the TCB and report to the upper layer the inability to\n      setup the association.\n\
    \   3) Send a new INIT chunk to the endpoint, adding a Cookie\n      Preservative\
    \ parameter requesting an extension to the lifetime of\n      the State Cookie.\
    \  When calculating the time extension, an\n      implementation SHOULD use the\
    \ RTT information measured based on\n      the previous COOKIE ECHO / ERROR exchange,\
    \ and should add no more\n      than 1 second beyond the measured RTT, due to\
    \ long State Cookie\n      lifetimes making the endpoint more subject to a replay\
    \ attack.\n"
- title: 5.3 Other Initialization Issues
  contents:
  - '5.3 Other Initialization Issues

    '
- title: 5.3.1 Selection of Tag Value
  contents:
  - "5.3.1 Selection of Tag Value\n   Initiate Tag values should be selected from\
    \ the range of 1 to 2**32 -\n   1.  It is very important that the Initiate Tag\
    \ value be randomized to\n   help protect against \"man in the middle\" and \"\
    sequence number\"\n   attacks.  The methods described in [RFC1750] can be used\
    \ for the\n   Initiate Tag randomization.  Careful selection of Initiate Tags\
    \ is\n   also necessary to prevent old duplicate packets from previous\n   associations\
    \ being mistakenly processed as belonging to the current\n   association.\n  \
    \ Moreover, the Verification Tag value used by either endpoint in a\n   given\
    \ association MUST NOT change during the lifetime of an\n   association.  A new\
    \ Verification Tag value MUST be used each time the\n   endpoint tears-down and\
    \ then re-establishes an association to the\n   same peer.\n"
- title: 6. User Data Transfer
  contents:
  - "6. User Data Transfer\n   Data transmission MUST only happen in the ESTABLISHED,\
    \ SHUTDOWN-\n   PENDING, and SHUTDOWN-RECEIVED states.  The only exception to\
    \ this is\n   that DATA chunks are allowed to be bundled with an outbound COOKIE\n\
    \   ECHO chunk when in COOKIE-WAIT state.\n   DATA chunks MUST only be received\
    \ according to the rules below in\n   ESTABLISHED, SHUTDOWN-PENDING, SHUTDOWN-SENT.\
    \  A DATA chunk received\n   in CLOSED is out of the blue and SHOULD be handled\
    \ per 8.4.  A DATA\n   chunk received in any other state SHOULD be discarded.\n\
    \   A SACK MUST be processed in ESTABLISHED, SHUTDOWN-PENDING, and\n   SHUTDOWN-RECEIVED.\
    \  An incoming SACK MAY be processed in COOKIE-\n   ECHOED.  A SACK in the CLOSED\
    \ state is out of the blue and SHOULD be\n   processed according to the rules\
    \ in 8.4.  A SACK chunk received in\n   any other state SHOULD be discarded.\n\
    \   A SCTP receiver MUST be able to receive a minimum of 1500 bytes in\n   one\
    \ SCTP packet.  This means that a SCTP endpoint MUST NOT indicate\n   less than\
    \ 1500 bytes in its Initial a_rwnd sent in the INIT or INIT\n   ACK.\n   For transmission\
    \ efficiency, SCTP defines mechanisms for bundling of\n   small user messages\
    \ and fragmentation of large user messages.  The\n   following diagram depicts\
    \ the flow of user messages through SCTP.\n   In this section the term \"data\
    \ sender\" refers to the endpoint that\n   transmits a DATA chunk and the term\
    \ \"data receiver\" refers to the\n   endpoint that receives a DATA chunk.  A\
    \ data receiver will transmit\n   SACK chunks.\n                 +--------------------------+\n\
    \                 |      User Messages       |\n                 +--------------------------+\n\
    \       SCTP user        ^  |\n      ==================|==|=======================================\n\
    \                        |  v (1)\n             +------------------+    +--------------------+\n\
    \             | SCTP DATA Chunks |    |SCTP Control Chunks |\n             +------------------+\
    \    +--------------------+\n                        ^  |             ^  |\n \
    \                       |  v (2)         |  v (2)\n                     +--------------------------+\n\
    \                     |      SCTP packets        |\n                     +--------------------------+\n\
    \       SCTP                      ^  |\n      ===========================|==|===========================\n\
    \                                 |  v\n             Connectionless Packet Transfer\
    \ Service (e.g., IP)\n   Notes:\n      1) When converting user messages into DATA\
    \ chunks, an endpoint\n         will fragment user messages larger than the current\
    \ association\n         path MTU into multiple DATA chunks.  The data receiver\
    \ will\n         normally reassemble the fragmented message from DATA chunks\n\
    \         before delivery to the user (see Section 6.9 for details).\n      2)\
    \ Multiple DATA and control chunks may be bundled by the sender\n         into\
    \ a single SCTP packet for transmission, as long as the\n         final size of\
    \ the packet does not exceed the current path MTU.\n         The receiver will\
    \ unbundle the packet back into the original\n         chunks.  Control chunks\
    \ MUST come before DATA chunks in the\n         packet.\n                Figure\
    \ 6: Illustration of User Data Transfer\n   The fragmentation and bundling mechanisms,\
    \ as detailed in Sections\n   6.9 and 6.10, are OPTIONAL to implement by the data\
    \ sender, but they\n   MUST be implemented by the data receiver, i.e., an endpoint\
    \ MUST\n   properly receive and process bundled or fragmented data.\n"
- title: 6.1  Transmission of DATA Chunks
  contents:
  - "6.1  Transmission of DATA Chunks\n   This document is specified as if there is\
    \ a single retransmission\n   timer per destination transport address, but implementations\
    \ MAY have\n   a retransmission timer for each DATA chunk.\n   The following general\
    \ rules MUST be applied by the data sender for\n   transmission and/or retransmission\
    \ of outbound DATA chunks:\n   A) At any given time, the data sender MUST NOT\
    \ transmit new data to\n      any destination transport address if its peer's\
    \ rwnd indicates\n      that the peer has no buffer space (i.e. rwnd is 0, see\
    \ Section\n      6.2.1).  However, regardless of the value of rwnd (including\
    \ if it\n      is 0), the data sender can always have one DATA chunk in flight\
    \ to\n      the receiver if allowed by cwnd (see rule B below).  This rule\n \
    \     allows the sender to probe for a change in rwnd that the sender\n      missed\
    \ due to the SACK having been lost in transit from the data\n      receiver to\
    \ the data sender.\n   B) At any given time, the sender MUST NOT transmit new\
    \ data to a\n      given transport address if it has cwnd or more bytes of data\n\
    \      outstanding to that transport address.\n   C) When the time comes for the\
    \ sender to transmit, before sending new\n      DATA chunks, the sender MUST first\
    \ transmit any outstanding DATA\n      chunks which are marked for retransmission\
    \ (limited by the current\n      cwnd).\n   D) Then, the sender can send out as\
    \ many new DATA chunks as Rule A\n      and Rule B above allow.\n   Multiple DATA\
    \ chunks committed for transmission MAY be bundled in a\n   single packet.  Furthermore,\
    \ DATA chunks being retransmitted MAY be\n   bundled with new DATA chunks, as\
    \ long as the resulting packet size\n   does not exceed the path MTU.  A ULP may\
    \ request that no bundling is\n   performed but this should only turn off any\
    \ delays that a SCTP\n   implementation may be using to increase bundling efficiency.\
    \  It does\n   not in itself stop all bundling from occurring (i.e. in case of\n\
    \   congestion or retransmission).\n   Before an endpoint transmits a DATA chunk,\
    \ if any received DATA\n   chunks have not been acknowledged (e.g., due to delayed\
    \ ack), the\n   sender should create a SACK and bundle it with the outbound DATA\n\
    \   chunk, as long as the size of the final SCTP packet does not exceed\n   the\
    \ current MTU.  See Section 6.2.\n   IMPLEMENTATION NOTE: When the window is full\
    \ (i.e., transmission is\n   disallowed by Rule A and/or Rule B), the sender MAY\
    \ still accept send\n   requests from its upper layer, but MUST transmit no more\
    \ DATA chunks\n   until some or all of the outstanding DATA chunks are acknowledged\
    \ and\n   transmission is allowed by Rule A and Rule B again.\n   Whenever a transmission\
    \ or retransmission is made to any address, if\n   the T3-rtx timer of that address\
    \ is not currently running, the sender\n   MUST start that timer.  If the timer\
    \ for that address is already\n   running, the sender MUST restart the timer if\
    \ the earliest (i.e.,\n   lowest TSN) outstanding DATA chunk sent to that address\
    \ is being\n   retransmitted.  Otherwise, the data sender MUST NOT restart the\n\
    \   timer.\n   When starting or restarting the T3-rtx timer, the timer value must\
    \ be\n   adjusted according to the timer rules defined in Sections 6.3.2, and\n\
    \   6.3.3.\n   Note: The data sender SHOULD NOT use a TSN that is more than 2**31\
    \ -\n   1 above the beginning TSN of the current send window.\n"
- title: 6.2  Acknowledgement on Reception of DATA Chunks
  contents:
  - "6.2  Acknowledgement on Reception of DATA Chunks\n   The SCTP endpoint MUST always\
    \ acknowledge the reception of each valid\n   DATA chunk.\n   The guidelines on\
    \ delayed acknowledgement algorithm specified in\n   Section 4.2 of [RFC2581]\
    \ SHOULD be followed.  Specifically, an\n   acknowledgement SHOULD be generated\
    \ for at least every second packet\n   (not every second DATA chunk) received,\
    \ and SHOULD be generated\n   within 200 ms of the arrival of any unacknowledged\
    \ DATA chunk.  In\n   some situations it may be beneficial for an SCTP transmitter\
    \ to be\n   more conservative than the algorithms detailed in this document\n\
    \   allow. However, an SCTP transmitter MUST NOT be more aggressive than\n   the\
    \ following algorithms allow.\n   A SCTP receiver MUST NOT generate more than\
    \ one SACK for every\n   incoming packet, other than to update the offered window\
    \ as the\n   receiving application consumes new data.\n   IMPLEMENTATION NOTE:\
    \ The maximum delay for generating an\n   acknowledgement may be configured by\
    \ the SCTP administrator, either\n   statically or dynamically, in order to meet\
    \ the specific timing\n   requirement of the protocol being carried.\n   An implementation\
    \ MUST NOT allow the maximum delay to be configured\n   to be more than 500 ms.\
    \  In other words an implementation MAY lower\n   this value below 500ms but MUST\
    \ NOT raise it above 500ms.\n   Acknowledgements MUST be sent in SACK chunks unless\
    \ shutdown was\n   requested by the ULP in which case an endpoint MAY send an\n\
    \   acknowledgement in the SHUTDOWN chunk.  A SACK chunk can acknowledge\n   the\
    \ reception of multiple DATA chunks.  See Section 3.3.4 for SACK\n   chunk format.\
    \  In particular, the SCTP endpoint MUST fill in the\n   Cumulative TSN Ack field\
    \ to indicate the latest sequential TSN (of a\n   valid DATA chunk) it has received.\
    \  Any received DATA chunks with TSN\n   greater than the value in the Cumulative\
    \ TSN Ack field SHOULD also be\n   reported in the Gap Ack Block fields.\n   Note:\
    \  The SHUTDOWN chunk does not contain Gap Ack Block fields.\n   Therefore, the\
    \ endpoint should use a SACK instead of the SHUTDOWN\n   chunk to acknowledge\
    \ DATA chunks received out of order .\n   When a packet arrives with duplicate\
    \ DATA chunk(s) and with no new\n   DATA chunk(s), the endpoint MUST immediately\
    \ send a SACK with no\n   delay.  If a packet arrives with duplicate DATA chunk(s)\
    \ bundled with\n   new DATA chunks, the endpoint MAY immediately send a SACK.\
    \  Normally\n   receipt of duplicate DATA chunks will occur when the original\
    \ SACK\n   chunk was lost and the peer's RTO has expired.  The duplicate TSN\n\
    \   number(s) SHOULD be reported in the SACK as duplicate.\n   When an endpoint\
    \ receives a SACK, it MAY use the Duplicate TSN\n   information to determine if\
    \ SACK loss is occurring.  Further use of\n   this data is for future study.\n\
    \   The data receiver is responsible for maintaining its receive buffers.\n  \
    \ The data receiver SHOULD notify the data sender in a timely manner of\n   changes\
    \ in its ability to receive data.  How an implementation\n   manages its receive\
    \ buffers is dependent on many factors (e.g.,\n   Operating System, memory management\
    \ system, amount of memory, etc.).\n   However, the data sender strategy defined\
    \ in Section 6.2.1 is based\n   on the assumption of receiver operation similar\
    \ to the following:\n      A) At initialization of the association, the endpoint\
    \ tells the\n         peer how much receive buffer space it has allocated to the\n\
    \         association in the INIT or INIT ACK.  The endpoint sets a_rwnd\n   \
    \      to this value.\n      B) As DATA chunks are received and buffered, decrement\
    \ a_rwnd by\n         the number of bytes received and buffered.  This is, in\
    \ effect,\n         closing rwnd at the data sender and restricting the amount\
    \ of\n         data it can transmit.\n      C) As DATA chunks are delivered to\
    \ the ULP and released from the\n         receive buffers, increment a_rwnd by\
    \ the number of bytes\n         delivered to the upper layer.  This is, in effect,\
    \ opening up\n         rwnd on the data sender and allowing it to send more data.\
    \  The\n         data receiver SHOULD NOT increment a_rwnd unless it has\n   \
    \      released bytes from its receive buffer.  For example, if the\n        \
    \ receiver is holding fragmented DATA chunks in a reassembly\n         queue,\
    \ it should not increment a_rwnd.\n      D) When sending a SACK, the data receiver\
    \ SHOULD place the current\n         value of a_rwnd into the a_rwnd field.  The\
    \ data receiver\n         SHOULD take into account that the data sender will not\n\
    \         retransmit DATA chunks that are acked via the Cumulative TSN\n     \
    \    Ack (i.e., will drop from its retransmit queue).\n   Under certain circumstances,\
    \ the data receiver may need to drop DATA\n   chunks that it has received but\
    \ hasn't released from its receive\n   buffers (i.e., delivered to the ULP). \
    \ These DATA chunks may have\n   been acked in Gap Ack Blocks.  For example, the\
    \ data receiver may be\n   holding data in its receive buffers while reassembling\
    \ a fragmented\n   user message from its peer when it runs out of receive buffer\
    \ space.\n   It may drop these DATA chunks even though it has acknowledged them\
    \ in\n   Gap Ack Blocks.  If a data receiver drops DATA chunks, it MUST NOT\n\
    \   include them in Gap Ack Blocks in subsequent SACKs until they are\n   received\
    \ again via retransmission.  In addition, the endpoint should\n   take into account\
    \ the dropped data when calculating its a_rwnd.\n   An endpoint SHOULD NOT revoke\
    \ a SACK and discard data. Only in\n   extreme circumstance should an endpoint\
    \ use this procedure (such as\n   out of buffer space).  The data receiver should\
    \ take into account\n   that dropping data that has been acked in Gap Ack Blocks\
    \ can result\n   in suboptimal retransmission strategies in the data sender and\
    \ thus\n   in suboptimal performance.\n   The following example illustrates the\
    \ use of delayed\n   acknowledgements:\n   Endpoint A                        \
    \              Endpoint Z\n   {App sends 3 messages; strm 0}\n   DATA [TSN=7,Strm=0,Seq=3]\
    \ ------------> (ack delayed)\n   (Start T3-rtx timer)\n   DATA [TSN=8,Strm=0,Seq=4]\
    \ ------------> (send ack)\n                                 /------- SACK [TSN\
    \ Ack=8,block=0]\n   (cancel T3-rtx timer)  <-----/\n   DATA [TSN=9,Strm=0,Seq=5]\
    \ ------------> (ack delayed)\n   (Start T3-rtx timer)\n                     \
    \                     ...\n                                          {App sends\
    \ 1 message; strm 1}\n                                          (bundle SACK with\
    \ DATA)\n                                   /----- SACK [TSN Ack=9,block=0] \\\
    \n                                  /         DATA [TSN=6,Strm=1,Seq=2]\n   (cancel\
    \ T3-rtx timer)  <------/        (Start T3-rtx timer)\n   (ack delayed)\n   (send\
    \ ack)\n   SACK [TSN Ack=6,block=0] -------------> (cancel T3-rtx timer)\n   \
    \       Figure 7:  Delayed Acknowledgment Example\n   If an endpoint receives\
    \ a DATA chunk with no user data (i.e., the\n   Length field is set to 16) it\
    \ MUST send an ABORT with error cause set\n   to \"No User Data\".\n   An endpoint\
    \ SHOULD NOT send a DATA chunk with no user data part.\n"
- title: 6.2.1  Processing a Received SACK
  contents:
  - "6.2.1  Processing a Received SACK\n   Each SACK an endpoint receives contains\
    \ an a_rwnd value.  This value\n   represents the amount of buffer space the data\
    \ receiver, at the time\n   of transmitting the SACK, has left of its total receive\
    \ buffer space\n   (as specified in the INIT/INIT ACK).  Using a_rwnd, Cumulative\
    \ TSN\n   Ack and Gap Ack Blocks, the data sender can develop a representation\n\
    \   of the peer's receive buffer space.\n   One of the problems the data sender\
    \ must take into account when\n   processing a SACK is that a SACK can be received\
    \ out of order.  That\n   is, a SACK sent by the data receiver can pass an earlier\
    \ SACK and be\n   received first by the data sender.  If a SACK is received out\
    \ of\n   order, the data sender can develop an incorrect view of the peer's\n\
    \   receive buffer space.\n   Since there is no explicit identifier that can be\
    \ used to detect\n   out-of-order SACKs, the data sender must use heuristics to\
    \ determine\n   if a SACK is new.\n   An endpoint SHOULD use the following rules\
    \ to calculate the rwnd,\n   using the a_rwnd value, the Cumulative TSN Ack and\
    \ Gap Ack Blocks in\n   a received SACK.\n   A) At the establishment of the association,\
    \ the endpoint initializes\n      the rwnd to the Advertised Receiver Window Credit\
    \ (a_rwnd) the\n      peer specified in the INIT or INIT ACK.\n   B) Any time\
    \ a DATA chunk is transmitted (or retransmitted) to a peer,\n      the endpoint\
    \ subtracts the data size of the chunk from the rwnd of\n      that peer.\n  \
    \ C) Any time a DATA chunk is marked for retransmission (via either\n      T3-rtx\
    \ timer expiration (Section 6.3.3)or via fast retransmit\n      (Section 7.2.4)),\
    \ add the data size of those chunks to the rwnd.\n      Note: If the implementation\
    \ is maintaining a timer on each DATA\n      chunk then only DATA chunks whose\
    \ timer expired would be marked\n      for retransmission.\n   D) Any time a SACK\
    \ arrives, the endpoint performs the following:\n         i) If Cumulative TSN\
    \ Ack is less than the Cumulative TSN Ack\n         Point, then drop the SACK.\
    \   Since Cumulative TSN Ack is\n         monotonically increasing, a SACK whose\
    \ Cumulative TSN Ack is\n         less than the Cumulative TSN Ack Point indicates\
    \ an out-of-\n         order SACK.\n         ii) Set rwnd equal to the newly received\
    \ a_rwnd minus the\n         number of bytes still outstanding after processing\
    \ the\n         Cumulative TSN Ack and the Gap Ack Blocks.\n         iii) If the\
    \ SACK is missing a TSN that was previously\n         acknowledged via a Gap Ack\
    \ Block (e.g., the data receiver\n         reneged on the data), then mark the\
    \ corresponding DATA chunk as\n         available for retransmit:  Mark it as\
    \ missing for fast\n         retransmit as described in Section 7.2.4 and if no\
    \ retransmit\n         timer is running for the destination address to which the\
    \ DATA\n         chunk was originally transmitted, then T3-rtx is started for\n\
    \         that destination address.\n"
- title: 6.3 Management of Retransmission Timer
  contents:
  - "6.3 Management of Retransmission Timer\n   An SCTP endpoint uses a retransmission\
    \ timer T3-rtx to ensure data\n   delivery in the absence of any feedback from\
    \ its peer.  The duration\n   of this timer is referred to as RTO (retransmission\
    \ timeout).\n   When an endpoint's peer is multi-homed, the endpoint will calculate\
    \ a\n   separate RTO for each different destination transport address of its\n\
    \   peer endpoint.\n   The computation and management of RTO in SCTP follows closely\
    \ how TCP\n   manages its retransmission timer.  To compute the current RTO, an\n\
    \   endpoint maintains two state variables per destination transport\n   address:\
    \ SRTT (smoothed round-trip time) and RTTVAR (round-trip time\n   variation).\n"
- title: 6.3.1 RTO Calculation
  contents:
  - "6.3.1 RTO Calculation\n   The rules governing the computation of SRTT, RTTVAR,\
    \ and RTO are as\n   follows:\n   C1) Until an RTT measurement has been made for\
    \ a packet sent to the\n       given destination transport address, set RTO to\
    \ the protocol\n       parameter 'RTO.Initial'.\n   C2) When the first RTT measurement\
    \ R is made, set SRTT <- R, RTTVAR\n       <- R/2, and RTO <- SRTT + 4 * RTTVAR.\n\
    \   C3) When a new RTT measurement R' is made, set\n       RTTVAR <- (1 - RTO.Beta)\
    \ * RTTVAR + RTO.Beta * |SRTT - R'| SRTT\n       <- (1 - RTO.Alpha) * SRTT + RTO.Alpha\
    \ * R'\n       Note: The value of SRTT used in the update to RTTVAR is its value\n\
    \       before updating SRTT itself using the second assignment.\n       After\
    \ the computation, update RTO <- SRTT + 4 * RTTVAR.\n   C4) When data is in flight\
    \ and when allowed by rule C5 below, a new\n       RTT measurement MUST be made\
    \ each round trip.  Furthermore, new\n       RTT measurements SHOULD be made no\
    \ more than once per round-trip\n       for a given destination transport address.\
    \  There are two reasons\n       for this recommendation:  First, it appears that\
    \ measuring more\n       frequently often does not in practice yield any significant\n\
    \       benefit [ALLMAN99]; second, if measurements are made more often,\n   \
    \    then the values of RTO.Alpha and RTO.Beta in rule C3 above should\n     \
    \  be adjusted so that SRTT and RTTVAR still adjust to changes at\n       roughly\
    \ the same rate (in terms of how many round trips it takes\n       them to reflect\
    \ new values) as they would if making only one\n       measurement per round-trip\
    \ and using RTO.Alpha and RTO.Beta as\n       given in rule C3.  However, the\
    \ exact nature of these adjustments\n       remains a research issue.\n   C5)\
    \ Karn's algorithm: RTT measurements MUST NOT be made using packets\n       that\
    \ were retransmitted (and thus for which it is ambiguous\n       whether the reply\
    \ was for the first instance of the packet or a\n       later instance).\n   C6)\
    \ Whenever RTO is computed, if it is less than RTO.Min seconds then\n       it\
    \ is rounded up to RTO.Min seconds.  The reason for this rule is\n       that\
    \ RTOs that do not have a high minimum value are susceptible\n       to unnecessary\
    \ timeouts [ALLMAN99].\n   C7) A maximum value may be placed on RTO provided it\
    \ is at least\n       RTO.max seconds.\n   There is no requirement for the clock\
    \ granularity G used for\n   computing RTT measurements and the different state\
    \ variables, other\n   than:\n   G1) Whenever RTTVAR is computed, if RTTVAR =\
    \ 0, then adjust RTTVAR <-\n       G.\n   Experience [ALLMAN99] has shown that\
    \ finer clock granularities (<=\n   100 msec) perform somewhat better than more\
    \ coarse granularities.\n"
- title: 6.3.2 Retransmission Timer Rules
  contents:
  - "6.3.2 Retransmission Timer Rules\n   The rules for managing the retransmission\
    \ timer are as follows:\n   R1) Every time a DATA chunk is sent to any address\
    \ (including a\n       retransmission), if the T3-rtx timer of that address is\
    \ not\n       running, start it running so that it will expire after the RTO of\n\
    \       that address.  The RTO used here is that obtained after any\n       doubling\
    \ due to previous T3-rtx timer expirations on the\n       corresponding destination\
    \ address as discussed in rule E2 below.\n   R2) Whenever all outstanding data\
    \ sent to an address have been\n       acknowledged, turn off the T3-rtx timer\
    \ of that address.\n   R3) Whenever a SACK is received that acknowledges the DATA\
    \ chunk with\n       the earliest outstanding TSN for that address, restart T3-rtx\n\
    \       timer for that address with its current RTO (if there is still\n     \
    \  outstanding data on that address).\n   R4) Whenever a SACK is received missing\
    \ a TSN that was previously\n       acknowledged via a Gap Ack Block, start T3-rtx\
    \ for the\n       destination address to which the DATA chunk was originally\n\
    \       transmitted if it is not already running.\n   The following example shows\
    \ the use of various timer rules (assuming\n   the receiver uses delayed acks).\n\
    \   Endpoint A                                         Endpoint Z\n   {App begins\
    \ to send}\n   Data [TSN=7,Strm=0,Seq=3] ------------> (ack delayed)\n   (Start\
    \ T3-rtx timer)\n                                           {App sends 1 message;\
    \ strm 1}\n                                           (bundle ack with data)\n\
    \   DATA [TSN=8,Strm=0,Seq=4] ----\\     /-- SACK [TSN Ack=7,Block=0]\n      \
    \                            \\   /      DATA [TSN=6,Strm=1,Seq=2]\n         \
    \                          \\ /     (Start T3-rtx timer)\n                   \
    \                 \\\n                                   / \\\n   (Re-start T3-rtx\
    \ timer) <------/   \\--> (ack delayed)\n   (ack delayed)\n   {send ack}\n   SACK\
    \ [TSN Ack=6,Block=0] --------------> (Cancel T3-rtx timer)\n                \
    \                           ..\n                                           (send\
    \ ack)\n   (Cancel T3-rtx timer)  <-------------- SACK [TSN Ack=8,Block=0]\n \
    \                Figure 8 - Timer Rule Examples\n"
- title: 6.3.3 Handle T3-rtx Expiration
  contents:
  - "6.3.3 Handle T3-rtx Expiration\n   Whenever the retransmission timer T3-rtx expires\
    \ for a destination\n   address, do the following:\n   E1) For the destination\
    \ address for which the timer expires, adjust\n       its ssthresh with rules\
    \ defined in Section 7.2.3 and set the cwnd\n       <- MTU.\n   E2) For the destination\
    \ address for which the timer expires, set RTO\n       <- RTO * 2 (\"back off\
    \ the timer\").  The maximum value discussed\n       in rule C7 above (RTO.max)\
    \ may be used to provide an upper bound\n       to this doubling operation.\n\
    \   E3) Determine how many of the earliest (i.e., lowest TSN) outstanding\n  \
    \     DATA chunks for the address for which the T3-rtx has expired will\n    \
    \   fit into a single packet, subject to the MTU constraint for the\n       path\
    \ corresponding to the destination transport address to which\n       the retransmission\
    \ is being sent (this may be different from the\n       address for which the\
    \ timer expires [see Section 6.4]).  Call\n       this value K.  Bundle and retransmit\
    \ those K DATA chunks in a\n       single packet to the destination endpoint.\n\
    \   E4) Start the retransmission timer T3-rtx on the destination address\n   \
    \    to which the retransmission is sent, if rule R1 above indicates\n       to\
    \ do so.  The RTO to be used for starting T3-rtx should be the\n       one for\
    \ the destination address to which the retransmission is\n       sent, which,\
    \ when the receiver is multi-homed, may be different\n       from the destination\
    \ address for which the timer expired (see\n       Section 6.4 below).\n   After\
    \ retransmitting, once a new RTT measurement is obtained (which\n   can happen\
    \ only when new data has been sent and acknowledged, per\n   rule C5, or for a\
    \ measurement made from a HEARTBEAT [see Section\n   8.3]), the computation in\
    \ rule C3 is performed, including the\n   computation of RTO, which may result\
    \ in \"collapsing\" RTO back down\n   after it has been subject to doubling (rule\
    \ E2).\n   Note: Any DATA chunks that were sent to the address for which the\n\
    \   T3-rtx timer expired but did not fit in one MTU (rule E3 above),\n   should\
    \ be marked for retransmission and sent as soon as cwnd allows\n   (normally when\
    \ a SACK arrives).\n   The final rule for managing the retransmission timer concerns\n\
    \   failover (see Section 6.4.1):\n   F1) Whenever an endpoint switches from the\
    \ current destination\n       transport address to a different one, the current\
    \ retransmission\n       timers are left running.  As soon as the endpoint transmits\
    \ a\n       packet containing DATA chunk(s) to the new transport address,\n  \
    \     start the timer on that transport address, using the RTO value of\n    \
    \   the destination address to which the data is being sent, if rule\n       R1\
    \ indicates to do so.\n"
- title: 6.4 Multi-homed SCTP Endpoints
  contents:
  - "6.4 Multi-homed SCTP Endpoints\n   An SCTP endpoint is considered multi-homed\
    \ if there are more than one\n   transport address that can be used as a destination\
    \ address to reach\n   that endpoint.\n   Moreover, the ULP of an endpoint shall\
    \ select one of the multiple\n   destination addresses of a multi-homed peer endpoint\
    \ as the primary\n   path (see Sections 5.1.2 and 10.1 for details).\n   By default,\
    \ an endpoint SHOULD always transmit to the primary path,\n   unless the SCTP\
    \ user explicitly specifies the destination transport\n   address (and possibly\
    \ source transport address) to use.\n   An endpoint SHOULD transmit reply chunks\
    \ (e.g., SACK, HEARTBEAT ACK,\n   etc.) to the same destination transport address\
    \ from which it\n   received the DATA or control chunk to which it is replying.\
    \  This\n   rule should also be followed if the endpoint is bundling DATA chunks\n\
    \   together with the reply chunk.\n   However, when acknowledging multiple DATA\
    \ chunks received in packets\n   from different source addresses in a single SACK,\
    \ the SACK chunk may\n   be transmitted to one of the destination transport addresses\
    \ from\n   which the DATA or control chunks being acknowledged were received.\n\
    \   When a receiver of a duplicate DATA chunk sends a SACK to a multi-\n   homed\
    \ endpoint it MAY be beneficial to vary the destination address\n   and not use\
    \ the source address of the DATA chunk.  The reason being\n   that receiving a\
    \ duplicate from a multi-homed endpoint might indicate\n   that the return path\
    \ (as specified in the source address of the DATA\n   chunk) for the SACK is broken.\n\
    \   Furthermore, when its peer is multi-homed, an endpoint SHOULD try to\n   retransmit\
    \ a chunk to an active destination transport address that is\n   different from\
    \ the last destination address to which the DATA chunk\n   was sent.\n   Retransmissions\
    \ do not affect the total outstanding data count.\n   However, if the DATA chunk\
    \ is retransmitted onto a different\n   destination address, both the outstanding\
    \ data counts on the new\n   destination address and the old destination address\
    \ to which the data\n   chunk was last sent shall be adjusted accordingly.\n"
- title: 6.4.1 Failover from Inactive Destination Address
  contents:
  - "6.4.1 Failover from Inactive Destination Address\n   Some of the transport addresses\
    \ of a multi-homed SCTP endpoint may\n   become inactive due to either the occurrence\
    \ of certain error\n   conditions (see Section 8.2) or adjustments from SCTP user.\n\
    \   When there is outbound data to send and the primary path becomes\n   inactive\
    \ (e.g., due to failures), or where the SCTP user explicitly\n   requests to send\
    \ data to an inactive destination transport address,\n   before reporting an error\
    \ to its ULP, the SCTP endpoint should try to\n   send the data to an alternate\
    \ active destination transport address if\n   one exists.\n   When retransmitting\
    \ data, if the endpoint is multi-homed, it should\n   consider each source-destination\
    \ address pair in its retransmission\n   selection policy.  When retransmitting\
    \ the endpoint should attempt to\n   pick the most divergent source-destination\
    \ pair from the original\n   source-destination pair to which the packet was transmitted.\n\
    \   Note: Rules for picking the most divergent source-destination pair\n   are\
    \ an implementation decision and is not specified within this\n   document.\n"
- title: 6.5 Stream Identifier and Stream Sequence Number
  contents:
  - "6.5 Stream Identifier and Stream Sequence Number\n   Every DATA chunk MUST carry\
    \ a valid stream identifier.  If an\n   endpoint receives a DATA chunk with an\
    \ invalid stream identifier, it\n   shall acknowledge the reception of the DATA\
    \ chunk following the\n   normal procedure, immediately send an ERROR chunk with\
    \ cause set to\n   \"Invalid Stream Identifier\" (see Section 3.3.10) and discard\
    \ the DATA\n   chunk. The endpoint may bundle the ERROR chunk in the same packet\
    \ as\n   the SACK as long as the ERROR follows the SACK.\n   The stream sequence\
    \ number in all the streams shall start from 0 when\n   the association is established.\
    \  Also, when the stream sequence\n   number reaches the value 65535 the next\
    \ stream sequence number shall\n   be set to 0.\n"
- title: 6.6 Ordered and Unordered Delivery
  contents:
  - "6.6 Ordered and Unordered Delivery\n   Within a stream, an endpoint MUST deliver\
    \ DATA chunks received with\n   the U flag set to 0 to the upper layer according\
    \ to the order of\n   their stream sequence number.  If DATA chunks arrive out\
    \ of order of\n   their stream sequence number, the endpoint MUST hold the received\n\
    \   DATA chunks from delivery to the ULP until they are re-ordered.\n   However,\
    \ an SCTP endpoint can indicate that no ordered delivery is\n   required for a\
    \ particular DATA chunk transmitted within the stream by\n   setting the U flag\
    \ of the DATA chunk to 1.\n   When an endpoint receives a DATA chunk with the\
    \ U flag set to 1, it\n   must bypass the ordering mechanism and immediately deliver\
    \ the data\n   to the upper layer (after re-assembly if the user data is fragmented\n\
    \   by the data sender).\n   This provides an effective way of transmitting \"\
    out-of-band\" data in\n   a given stream.  Also, a stream can be used as an \"\
    unordered\" stream\n   by simply setting the U flag to 1 in all DATA chunks sent\
    \ through\n   that stream.\n   IMPLEMENTATION NOTE: When sending an unordered\
    \ DATA chunk, an\n   implementation may choose to place the DATA chunk in an outbound\n\
    \   packet that is at the head of the outbound transmission queue if\n   possible.\n\
    \   The 'Stream Sequence Number' field in a DATA chunk with U flag set to\n  \
    \ 1 has no significance.  The sender can fill it with arbitrary value,\n   but\
    \ the receiver MUST ignore the field.\n   Note:  When transmitting ordered and\
    \ unordered data, an endpoint does\n   not increment its Stream Sequence Number\
    \ when transmitting a DATA\n   chunk with U flag set to 1.\n"
- title: 6.7 Report Gaps in Received DATA TSNs
  contents:
  - "6.7 Report Gaps in Received DATA TSNs\n   Upon the reception of a new DATA chunk,\
    \ an endpoint shall examine the\n   continuity of the TSNs received.  If the endpoint\
    \ detects a gap in\n   the received DATA chunk sequence, it SHOULD send a SACK\
    \ with Gap Ack\n   Blocks immediately.  The data receiver continues sending a\
    \ SACK after\n   receipt of each SCTP packet that doesn't fill the gap.\n   Based\
    \ on the Gap Ack Block from the received SACK, the endpoint can\n   calculate\
    \ the missing DATA chunks and make decisions on whether to\n   retransmit them\
    \ (see Section 6.2.1 for details).\n   Multiple gaps can be reported in one single\
    \ SACK (see Section 3.3.4).\n   When its peer is multi-homed, the SCTP endpoint\
    \ SHOULD always try to\n   send the SACK to the same destination address from\
    \ which the last\n   DATA chunk was received.\n   Upon the reception of a SACK,\
    \ the endpoint MUST remove all DATA\n   chunks which have been acknowledged by\
    \ the SACK's Cumulative TSN Ack\n   from its transmit queue.  The endpoint MUST\
    \ also treat all the DATA\n   chunks with TSNs not included in the Gap Ack Blocks\
    \ reported by the\n   SACK as \"missing\".  The number of \"missing\" reports\
    \ for each\n   outstanding DATA chunk MUST be recorded by the data sender in order\n\
    \   to make retransmission decisions.  See Section 7.2.4 for details.\n   The\
    \ following example shows the use of SACK to report a gap.\n      Endpoint A \
    \                                   Endpoint Z\n      {App sends 3 messages; strm\
    \ 0}\n      DATA [TSN=6,Strm=0,Seq=2] ---------------> (ack delayed)\n      (Start\
    \ T3-rtx timer)\n      DATA [TSN=7,Strm=0,Seq=3] --------> X (lost)\n      DATA\
    \ [TSN=8,Strm=0,Seq=4] ---------------> (gap detected,\n                     \
    \                             immediately send ack)\n                        \
    \              /----- SACK [TSN Ack=6,Block=1,\n                             \
    \        /             Strt=2,End=2]\n                              <-----/\n\
    \      (remove 6 from out-queue,\n       and mark 7 as \"1\" missing report)\n\
    \                 Figure 9 - Reporting a Gap using SACK\n   The maximum number\
    \ of Gap Ack Blocks that can be reported within a\n   single SACK chunk is limited\
    \ by the current path MTU.  When a single\n   SACK can not cover all the Gap Ack\
    \ Blocks needed to be reported due\n   to the MTU limitation, the endpoint MUST\
    \ send only one SACK,\n   reporting the Gap Ack Blocks from the lowest to highest\
    \ TSNs, within\n   the size limit set by the MTU, and leave the remaining highest\
    \ TSN\n   numbers unacknowledged.\n"
- title: 6.8 Adler-32 Checksum Calculation
  contents:
  - "6.8 Adler-32 Checksum Calculation\n   When sending an SCTP packet, the endpoint\
    \ MUST strengthen the data\n   integrity of the transmission by including the\
    \ Adler-32 checksum\n   value calculated on the packet, as described below.\n\
    \   After the packet is constructed (containing the SCTP common header\n   and\
    \ one or more control or DATA chunks), the transmitter shall:\n   1) Fill in the\
    \ proper Verification Tag in the SCTP common header and\n      initialize the\
    \ checksum field to 0's.\n   2) Calculate the Adler-32 checksum of the whole packet,\
    \ including the\n      SCTP common header and all the chunks.  Refer to appendix\
    \ B for\n      details of the Adler-32 algorithm.  And,\n   3) Put the resultant\
    \ value into the checksum field in the common\n      header, and leave the rest\
    \ of the bits unchanged.\n   When an SCTP packet is received, the receiver MUST\
    \ first check the\n   Adler-32 checksum:\n   1) Store the received Adler-32 checksum\
    \ value aside,\n   2) Replace the 32 bits of the checksum field in the received\
    \ SCTP\n      packet with all '0's and calculate an Adler-32 checksum value of\n\
    \      the whole received packet.  And,\n   3) Verify that the calculated Adler-32\
    \ checksum is the same as the\n      received Adler-32 checksum.  If not, the\
    \ receiver MUST treat the\n      packet as an invalid SCTP packet.\n   The default\
    \ procedure for handling invalid SCTP packets is to\n   silently discard them.\n"
- title: 6.9 Fragmentation and Reassembly
  contents:
  - "6.9 Fragmentation and Reassembly\n   An endpoint MAY support fragmentation when\
    \ sending DATA chunks, but\n   MUST support reassembly when receiving DATA chunks.\
    \  If an endpoint\n   supports fragmentation, it MUST fragment a user message\
    \ if the size\n   of the user message to be sent causes the outbound SCTP packet\
    \ size\n   to exceed the current MTU.  If an implementation does not support\n\
    \   fragmentation of outbound user messages, the endpoint must return an\n   error\
    \ to its upper layer and not attempt to send the user message.\n   IMPLEMENTATION\
    \ NOTE:  In this error case, the Send primitive\n   discussed in Section 10.1\
    \ would need to return an error to the upper\n   layer.\n   If its peer is multi-homed,\
    \ the endpoint shall choose a size no\n   larger than the association Path MTU.\
    \  The association Path MTU is\n   the smallest Path MTU of all destination addresses.\n\
    \   Note: Once a message is fragmented it cannot be re-fragmented.\n   Instead\
    \ if the PMTU has been reduced, then IP fragmentation must be\n   used.  Please\
    \ see Section 7.3 for details of PMTU discovery.\n   When determining when to\
    \ fragment, the SCTP implementation MUST take\n   into account the SCTP packet\
    \ header as well as the DATA chunk\n   header(s).  The implementation MUST also\
    \ take into account the space\n   required for a SACK chunk if bundling a SACK\
    \ chunk with the DATA\n   chunk.\n   Fragmentation takes the following steps:\n\
    \   1) The data sender MUST break the user message into a series of DATA\n   \
    \   chunks such that each chunk plus SCTP overhead fits into an IP\n      datagram\
    \ smaller than or equal to the association Path MTU.\n   2) The transmitter MUST\
    \ then assign, in sequence, a separate TSN to\n      each of the DATA chunks in\
    \ the series.  The transmitter assigns\n      the same SSN to each of the DATA\
    \ chunks.  If the user indicates\n      that the user message is to be delivered\
    \ using unordered delivery,\n      then the U flag of each DATA chunk of the user\
    \ message MUST be set\n      to 1.\n   3) The transmitter MUST also set the B/E\
    \ bits of the first DATA chunk\n      in the series to '10', the B/E bits of the\
    \ last DATA chunk in the\n      series to '01', and the B/E bits of all other\
    \ DATA chunks in the\n      series to '00'.\n   An endpoint MUST recognize fragmented\
    \ DATA chunks by examining the\n   B/E bits in each of the received DATA chunks,\
    \ and queue the\n   fragmented DATA chunks for re-assembly.  Once the user message\
    \ is\n   reassembled, SCTP shall pass the re-assembled user message to the\n \
    \  specific stream for possible re-ordering and final dispatching.\n   Note: If\
    \ the data receiver runs out of buffer space while still\n   waiting for more\
    \ fragments to complete the re-assembly of the\n   message, it should dispatch\
    \ part of its inbound message through a\n   partial delivery API (see Section\
    \ 10), freeing some of its receive\n   buffer space so that the rest of the message\
    \ may be received.\n"
- title: 6.10 Bundling
  contents:
  - "6.10 Bundling\n   An endpoint bundles chunks by simply including multiple chunks\
    \ in one\n   outbound SCTP packet.  The total size of the resultant IP datagram,\n\
    \   including the SCTP packet and IP headers, MUST be less or equal to\n   the\
    \ current Path MTU.\n   If its peer endpoint is multi-homed, the sending endpoint\
    \ shall\n   choose a size no larger than the latest MTU of the current primary\n\
    \   path.\n   When bundling control chunks with DATA chunks, an endpoint MUST\
    \ place\n   control chunks first in the outbound SCTP packet.  The transmitter\n\
    \   MUST transmit DATA chunks within a SCTP packet in increasing order of\n  \
    \ TSN.\n   Note:  Since control chunks must be placed first in a packet and\n\
    \   since DATA chunks must be transmitted before SHUTDOWN or SHUTDOWN ACK\n  \
    \ chunks, DATA chunks cannot be bundled with SHUTDOWN or SHUTDOWN ACK\n   chunks.\n\
    \   Partial chunks MUST NOT be placed in an SCTP packet.\n   An endpoint MUST\
    \ process received chunks in their order in the\n   packet. The receiver uses\
    \ the chunk length field to determine the end\n   of a chunk and beginning of\
    \ the next chunk taking account of the fact\n   that all chunks end on a 4 byte\
    \ boundary.  If the receiver detects a\n   partial chunk, it MUST drop the chunk.\n\
    \   An endpoint MUST NOT bundle INIT, INIT ACK or SHUTDOWN COMPLETE with\n   any\
    \ other chunks.\n"
- title: 7. Congestion control
  contents:
  - "7. Congestion control\n   Congestion control is one of the basic functions in\
    \ SCTP.  For some\n   applications, it may be likely that adequate resources will\
    \ be\n   allocated to SCTP traffic to assure prompt delivery of time-critical\n\
    \   data - thus it would appear to be unlikely, during normal operations,\n  \
    \ that transmissions encounter severe congestion conditions.  However\n   SCTP\
    \ must operate under adverse operational conditions, which can\n   develop upon\
    \ partial network failures or unexpected traffic surges.\n   In such situations\
    \ SCTP must follow correct congestion control steps\n   to recover from congestion\
    \ quickly in order to get data delivered as\n   soon as possible.  In the absence\
    \ of network congestion, these\n   preventive congestion control algorithms should\
    \ show no impact on the\n   protocol performance.\n   IMPLEMENTATION NOTE: As\
    \ far as its specific performance requirements\n   are met, an implementation\
    \ is always allowed to adopt a more\n   conservative congestion control algorithm\
    \ than the one defined below.\n   The congestion control algorithms used by SCTP\
    \ are based on\n   [RFC2581].  This section describes how the algorithms defined\
    \ in\n   RFC2581 are adapted for use in SCTP.  We first list differences in\n\
    \   protocol designs between TCP and SCTP, and then describe SCTP's\n   congestion\
    \ control scheme.  The description will use the same\n   terminology as in TCP\
    \ congestion control whenever appropriate.\n   SCTP congestion control is always\
    \ applied to the entire association,\n   and not to individual streams.\n"
- title: 7.1 SCTP Differences from TCP Congestion control
  contents:
  - "7.1 SCTP Differences from TCP Congestion control\n   Gap Ack Blocks in the SCTP\
    \ SACK carry the same semantic meaning as\n   the TCP SACK.  TCP considers the\
    \ information carried in the SACK as\n   advisory information only.  SCTP considers\
    \ the information carried in\n   the Gap Ack Blocks in the SACK chunk as advisory.\
    \  In SCTP, any DATA\n   chunk that has been acknowledged by SACK, including DATA\
    \ that arrived\n   at the receiving end out of order, are not considered fully\
    \ delivered\n   until the Cumulative TSN Ack Point passes the TSN of the DATA\
    \ chunk\n   (i.e., the DATA chunk has been acknowledged by the Cumulative TSN\
    \ Ack\n   field in the SACK).  Consequently, the value of cwnd controls the\n\
    \   amount of outstanding data, rather than (as in the case of non-SACK\n   TCP)\
    \ the upper bound between the highest acknowledged sequence number\n   and the\
    \ latest DATA chunk that can be sent within the congestion\n   window.  SCTP SACK\
    \ leads to different implementations of fast-\n   retransmit and fast-recovery\
    \ than non-SACK TCP.  As an example see\n   [FALL96].\n   The biggest difference\
    \ between SCTP and TCP, however, is multi-\n   homing.  SCTP is designed to establish\
    \ robust communication\n   associations between two endpoints each of which may\
    \ be reachable by\n   more than one transport address.  Potentially different\
    \ addresses may\n   lead to different data paths between the two endpoints, thus\
    \ ideally\n   one may need a separate set of congestion control parameters for\
    \ each\n   of the paths.  The treatment here of congestion control for multi-\n\
    \   homed receivers is new with SCTP and may require refinement in the\n   future.\
    \  The current algorithms make the following assumptions:\n   o  The sender usually\
    \ uses the same destination address until being\n      instructed by the upper\
    \ layer otherwise; however, SCTP may change\n      to an alternate destination\
    \ in the event an address is marked\n      inactive (see Section 8.2).  Also,\
    \ SCTP may retransmit to a\n      different transport address than the original\
    \ transmission.\n   o  The sender keeps a separate congestion control parameter\
    \ set for\n      each of the destination addresses it can send to (not each\n\
    \      source-destination pair but for each destination).  The parameters\n  \
    \    should decay if the address is not used for a long enough time\n      period.\n\
    \   o  For each of the destination addresses, an endpoint does slow-start\n  \
    \    upon the first transmission to that address.\n   Note:  TCP guarantees in-sequence\
    \ delivery of data to its upper-layer\n   protocol within a single TCP session.\
    \  This means that when TCP\n   notices a gap in the received sequence number,\
    \ it waits until the gap\n   is filled before delivering the data that was received\
    \ with sequence\n   numbers higher than that of the missing data.  On the other\
    \ hand,\n   SCTP can deliver data to its upper-layer protocol even if there is\
    \ a\n   gap in TSN if the Stream Sequence Numbers are in sequence for a\n   particular\
    \ stream (i.e., the missing DATA chunks are for a different\n   stream) or if\
    \ unordered delivery is indicated.  Although this does\n   not affect cwnd, it\
    \ might affect rwnd calculation.\n"
- title: 7.2 SCTP Slow-Start and Congestion Avoidance
  contents:
  - "7.2 SCTP Slow-Start and Congestion Avoidance\n   The slow start and congestion\
    \ avoidance algorithms MUST be used by an\n   endpoint to control the amount of\
    \ data being injected into the\n   network. The congestion control in SCTP is\
    \ employed in regard to the\n   association, not to an individual stream.  In\
    \ some situations it may\n   be beneficial for an SCTP sender to be more conservative\
    \ than the\n   algorithms allow; however, an SCTP sender MUST NOT be more aggressive\n\
    \   than the following algorithms allow.\n   Like TCP, an SCTP endpoint uses the\
    \ following three control variables\n   to regulate its transmission rate.\n \
    \  o  Receiver advertised window size (rwnd, in bytes), which is set by\n    \
    \  the receiver based on its available buffer space for incoming\n      packets.\n\
    \      Note: This variable is kept on the entire association.\n   o  Congestion\
    \ control window (cwnd, in bytes), which is adjusted by\n      the sender based\
    \ on observed network conditions.\n      Note: This variable is maintained on\
    \ a per-destination address\n      basis.\n   o  Slow-start threshold (ssthresh,\
    \ in bytes), which is used by the\n      sender to distinguish slow start and\
    \ congestion avoidance phases.\n      Note: This variable is maintained on a per-destination\
    \ address\n      basis.\n   SCTP also requires one additional control variable,\n\
    \   partial_bytes_acked, which is used during congestion avoidance phase\n   to\
    \ facilitate cwnd adjustment.\n   Unlike TCP, an SCTP sender MUST keep a set of\
    \ these control variables\n   cwnd, ssthresh and partial_bytes_acked for EACH\
    \ destination address\n   of its peer (when its peer is multi-homed).  Only one\
    \ rwnd is kept\n   for the whole association (no matter if the peer is multi-homed\
    \ or\n   has a single address).\n"
- title: 7.2.1 Slow-Start
  contents:
  - "7.2.1 Slow-Start\n   Beginning data transmission into a network with unknown\
    \ conditions or\n   after a sufficiently long idle period requires SCTP to probe\
    \ the\n   network to determine the available capacity.  The slow start\n   algorithm\
    \ is used for this purpose at the beginning of a transfer, or\n   after repairing\
    \ loss detected by the retransmission timer.\n   o  The initial cwnd before DATA\
    \ transmission or after a sufficiently\n      long idle period MUST be <= 2*MTU.\n\
    \   o  The initial cwnd after a retransmission timeout MUST be no more\n     \
    \ than 1*MTU.\n   o  The initial value of ssthresh MAY be arbitrarily high (for\n\
    \      example, implementations MAY use the size of the receiver\n      advertised\
    \ window).\n   o  Whenever cwnd is greater than zero, the endpoint is allowed\
    \ to\n      have cwnd bytes of data outstanding on that transport address.\n \
    \  o  When cwnd is less than or equal to ssthresh an SCTP endpoint MUST\n    \
    \  use the slow start algorithm to increase cwnd (assuming the\n      current\
    \ congestion window is being fully utilized).  If an\n      incoming SACK advances\
    \ the Cumulative TSN Ack Point, cwnd MUST be\n      increased by at most the lesser\
    \ of 1) the total size of the\n      previously outstanding DATA chunk(s) acknowledged,\
    \ and 2) the\n      destination's path MTU. This protects against the ACK-Splitting\n\
    \      attack outlined in [SAVAGE99].\n   In instances where its peer endpoint\
    \ is multi-homed, if an endpoint\n   receives a SACK that advances its Cumulative\
    \ TSN Ack Point, then it\n   should update its cwnd (or cwnds) apportioned to\
    \ the destination\n   addresses to which it transmitted the acknowledged data.\
    \  However if\n   the received SACK does not advance the Cumulative TSN Ack Point,\
    \ the\n   endpoint MUST NOT adjust the cwnd of any of the destination\n   addresses.\n\
    \   Because an endpoint's cwnd is not tied to its Cumulative TSN Ack\n   Point,\
    \ as duplicate SACKs come in, even though they may not advance\n   the Cumulative\
    \ TSN Ack Point an endpoint can still use them to clock\n   out new data.  That\
    \ is, the data newly acknowledged by the SACK\n   diminishes the amount of data\
    \ now in flight to less than cwnd; and so\n   the current, unchanged value of\
    \ cwnd now allows new data to be sent.\n   On the other hand, the increase of\
    \ cwnd must be tied to the\n   Cumulative TSN Ack Point advancement as specified\
    \ above.  Otherwise\n   the duplicate SACKs will not only clock out new data,\
    \ but also will\n   adversely clock out more new data than what has just left\
    \ the\n   network, during a time of possible congestion.\n   o  When the endpoint\
    \ does not transmit data on a given transport\n      address, the cwnd of the\
    \ transport address should be adjusted to\n      max(cwnd/2, 2*MTU) per RTO.\n"
- title: 7.2.2 Congestion Avoidance
  contents:
  - "7.2.2 Congestion Avoidance\n   When cwnd is greater than ssthresh, cwnd should\
    \ be incremented by\n   1*MTU per RTT if the sender has cwnd or more bytes of\
    \ data\n   outstanding for the corresponding transport address.\n   In practice\
    \ an implementation can achieve this goal in the following\n   way:\n   o  partial_bytes_acked\
    \ is initialized to 0.\n   o  Whenever cwnd is greater than ssthresh, upon each\
    \ SACK arrival\n      that advances the Cumulative TSN Ack Point, increase\n \
    \     partial_bytes_acked by the total number of bytes of all new chunks\n   \
    \   acknowledged in that SACK including chunks acknowledged by the new\n     \
    \ Cumulative TSN Ack and by Gap Ack Blocks.\n   o  When partial_bytes_acked is\
    \ equal to or greater than cwnd and\n      before the arrival of the SACK the\
    \ sender had cwnd or more bytes\n      of data outstanding (i.e., before arrival\
    \ of the SACK, flightsize\n      was greater than or equal to cwnd), increase\
    \ cwnd by MTU, and\n      reset partial_bytes_acked to (partial_bytes_acked -\
    \ cwnd).\n   o  Same as in the slow start, when the sender does not transmit DATA\n\
    \      on a given transport address, the cwnd of the transport address\n     \
    \ should be adjusted to max(cwnd / 2, 2*MTU) per RTO.\n   o  When all of the data\
    \ transmitted by the sender has been\n      acknowledged by the receiver, partial_bytes_acked\
    \ is initialized\n      to 0.\n"
- title: 7.2.3 Congestion Control
  contents:
  - "7.2.3 Congestion Control\n   Upon detection of packet losses from SACK  (see\
    \ Section 7.2.4), An\n   endpoint should do the following:\n      ssthresh = max(cwnd/2,\
    \ 2*MTU)\n      cwnd = ssthresh\n   Basically, a packet loss causes cwnd to be\
    \ cut in half.\n   When the T3-rtx timer expires on an address, SCTP should perform\
    \ slow\n   start by:\n      ssthresh = max(cwnd/2, 2*MTU)\n      cwnd = 1*MTU\n\
    \   and assure that no more than one SCTP packet will be in flight for\n   that\
    \ address until the endpoint receives acknowledgement for\n   successful delivery\
    \ of data to that address.\n"
- title: 7.2.4 Fast Retransmit on Gap Reports
  contents:
  - "7.2.4 Fast Retransmit on Gap Reports\n   In the absence of data loss, an endpoint\
    \ performs delayed\n   acknowledgement.  However, whenever an endpoint notices\
    \ a hole in the\n   arriving TSN sequence, it SHOULD start sending a SACK back\
    \ every time\n   a packet arrives carrying data until the hole is filled.\n  \
    \ Whenever an endpoint receives a SACK that indicates some TSN(s)\n   missing,\
    \ it SHOULD wait for 3 further miss indications (via\n   subsequent SACK's) on\
    \ the same TSN(s) before taking action with\n   regard to Fast Retransmit.\n \
    \  When the TSN(s) is reported as missing in the fourth consecutive\n   SACK,\
    \ the data sender shall:\n   1) Mark the missing DATA chunk(s) for retransmission,\n\
    \   2) Adjust the ssthresh and cwnd of the destination address(es) to\n      which\
    \ the missing DATA chunks were last sent, according to the\n      formula described\
    \ in Section 7.2.3.\n   3) Determine how many of the earliest (i.e., lowest TSN)\
    \ DATA chunks\n      marked for retransmission will fit into a single packet,\
    \ subject\n      to constraint of the path MTU of the destination transport address\n\
    \      to which the packet is being sent.  Call this value K. Retransmit\n   \
    \   those K DATA chunks in a single packet.\n   4) Restart T3-rtx timer only if\
    \ the last SACK acknowledged the lowest\n      outstanding TSN number sent to\
    \ that address, or the endpoint is\n      retransmitting the first outstanding\
    \ DATA chunk sent to that\n      address.\n   Note: Before the above adjustments,\
    \ if the received SACK also\n   acknowledges new DATA chunks and advances the\
    \ Cumulative TSN Ack\n   Point, the cwnd adjustment rules defined in Sections\
    \ 7.2.1 and 7.2.2\n   must be applied first.\n   A straightforward implementation\
    \ of the above keeps a counter for\n   each TSN hole reported by a SACK. The counter\
    \ increments for each\n   consecutive SACK reporting the TSN hole.  After reaching\
    \ 4 and\n   starting the fast retransmit procedure, the counter resets to 0.\n\
    \   Because cwnd in SCTP indirectly bounds the number of outstanding\n   TSN's,\
    \ the effect of TCP fast-recovery is achieved automatically with\n   no adjustment\
    \ to the congestion control window size.\n"
- title: 7.3 Path MTU Discovery
  contents:
  - "7.3 Path MTU Discovery\n   [RFC1191] specifies \"Path MTU Discovery\", whereby\
    \ an endpoint\n   maintains an estimate of the maximum transmission unit (MTU)\
    \ along a\n   given Internet path and refrains from sending packets along that\
    \ path\n   which exceed the MTU, other than occasional attempts to probe for a\n\
    \   change in the Path MTU (PMTU).  RFC 1191 is thorough in its\n   discussion\
    \ of the MTU discovery mechanism and strategies for\n   determining the current\
    \ end-to-end MTU setting as well as detecting\n   changes in this value.  [RFC1981]\
    \ specifies the same mechanisms for\n   IPv6.  An SCTP sender using IPv6 MUST\
    \ use Path MTU Discovery unless\n   all packets are less than the minimum IPv6\
    \ MTU [RFC2460].\n   An endpoint SHOULD apply these techniques, and SHOULD do\
    \ so on a\n   per-destination-address basis.\n   There are 4 ways in which SCTP\
    \ differs from the description in RFC\n   1191 of applying MTU discovery to TCP:\n\
    \   1) SCTP associations can span multiple addresses.  An endpoint MUST\n    \
    \  maintain separate MTU estimates for each destination address of\n      its\
    \ peer.\n   2) Elsewhere in this document, when the term \"MTU\" is discussed,\
    \ it\n      refers to the MTU associated with the destination address\n      corresponding\
    \ to the context of the discussion.\n   3) Unlike TCP, SCTP does not have a notion\
    \ of \"Maximum Segment Size\".\n      Accordingly, the MTU for each destination\
    \ address SHOULD be\n      initialized to a value no larger than the link MTU\
    \ for the local\n      interface to which packets for that remote destination\
    \ address\n      will be routed.\n   4) Since data transmission in SCTP is naturally\
    \ structured in terms\n      of TSNs rather than bytes (as is the case for TCP),\
    \ the discussion\n      in Section 6.5 of RFC 1191 applies: When retransmitting\
    \ an IP\n      datagram to a remote address for which the IP datagram appears\
    \ too\n      large for the path MTU to that address, the IP datagram SHOULD be\n\
    \      retransmitted without the DF bit set, allowing it to possibly be\n    \
    \  fragmented.  Transmissions of new IP datagrams MUST have DF set.\n   5) The\
    \ sender should track an association PMTU which will be the\n      smallest PMTU\
    \ discovered for all of the peer's destination\n      addresses.  When fragmenting\
    \ messages into multiple parts this\n      association PMTU should be used to\
    \ calculate the size of each\n      fragment.  This will allow retransmissions\
    \ to be seamlessly sent\n      to an alternate address without encountering IP\
    \ fragmentation.\n   Other than these differences, the discussion of TCP's use\
    \ of MTU\n   discovery in RFCs 1191 and 1981 applies to SCTP on a per-\n   destination-address\
    \ basis.\n   Note: For IPv6 destination addresses the DF bit does not exist,\n\
    \   instead the IP datagram must be fragmented as described in [RFC2460].\n"
- title: 8.  Fault Management
  contents:
  - '8.  Fault Management

    '
- title: 8.1 Endpoint Failure Detection
  contents:
  - "8.1 Endpoint Failure Detection\n   An endpoint shall keep a counter on the total\
    \ number of consecutive\n   retransmissions to its peer (including retransmissions\
    \ to all the\n   destination transport addresses of the peer if it is multi-homed).\n\
    \   If the value of this counter exceeds the limit indicated in the\n   protocol\
    \ parameter 'Association.Max.Retrans', the endpoint shall\n   consider the peer\
    \ endpoint unreachable and shall stop transmitting\n   any more data to it (and\
    \ thus the association enters the CLOSED\n   state).  In addition, the endpoint\
    \ shall report the failure to the\n   upper layer, and optionally report back\
    \ all outstanding user data\n   remaining in its outbound queue. The association\
    \ is automatically\n   closed when the peer endpoint becomes unreachable.\n  \
    \ The counter shall be reset each time a DATA chunk sent to that peer\n   endpoint\
    \ is acknowledged (by the reception of a SACK), or a\n   HEARTBEAT-ACK is received\
    \ from the peer endpoint.\n"
- title: 8.2 Path Failure Detection
  contents:
  - "8.2 Path Failure Detection\n   When its peer endpoint is multi-homed, an endpoint\
    \ should keep a\n   error counter for each of the destination transport addresses\
    \ of the\n   peer endpoint.\n   Each time the T3-rtx timer expires on any address,\
    \ or when a\n   HEARTBEAT sent to an idle address is not acknowledged within a\
    \ RTO,\n   the error counter of that destination address will be incremented.\n\
    \   When the value in the error counter exceeds the protocol parameter\n   'Path.Max.Retrans'\
    \ of that destination address, the endpoint should\n   mark the destination transport\
    \ address as inactive, and a\n   notification SHOULD be sent to the upper layer.\n\
    \   When an outstanding TSN is acknowledged or a HEARTBEAT sent to that\n   address\
    \ is acknowledged with a HEARTBEAT ACK, the endpoint shall\n   clear the error\
    \ counter of the destination transport address to which\n   the DATA chunk was\
    \ last sent (or HEARTBEAT was sent).  When the peer\n   endpoint is multi-homed\
    \ and the last chunk sent to it was a\n   retransmission to an alternate address,\
    \ there exists an ambiguity as\n   to whether or not the acknowledgement should\
    \ be credited to the\n   address of the last chunk sent.  However, this ambiguity\
    \ does not\n   seem to bear any significant consequence to SCTP behavior.  If\
    \ this\n   ambiguity is undesirable, the transmitter may choose not to clear the\n\
    \   error counter if the last chunk sent was a retransmission.\n   Note: When\
    \ configuring the SCTP endpoint, the user should avoid\n   having the value of\
    \ 'Association.Max.Retrans' larger than the\n   summation of the 'Path.Max.Retrans'\
    \ of all the destination addresses\n   for the remote endpoint.  Otherwise, all\
    \ the destination addresses\n   may become inactive while the endpoint still considers\
    \ the peer\n   endpoint reachable.  When this condition occurs, how the SCTP chooses\n\
    \   to function is implementation specific.\n   When the primary path is marked\
    \ inactive (due to excessive\n   retransmissions, for instance), the sender MAY\
    \ automatically transmit\n   new packets to an alternate destination address if\
    \ one exists and is\n   active.  If more than one alternate address is active\
    \ when the\n   primary path is marked inactive only ONE transport address SHOULD\
    \ be\n   chosen and used as the new destination transport address.\n"
- title: 8.3 Path Heartbeat
  contents:
  - "8.3 Path Heartbeat\n   By default, an SCTP endpoint shall monitor the reachability\
    \ of the\n   idle destination transport address(es) of its peer by sending a\n\
    \   HEARTBEAT chunk periodically to the destination transport\n   address(es).\n\
    \   A destination transport address is considered \"idle\" if no new chunk\n \
    \  which can be used for updating path RTT (usually including first\n   transmission\
    \ DATA, INIT, COOKIE ECHO, HEARTBEAT etc.) and no\n   HEARTBEAT has been sent\
    \ to it within the current heartbeat period of\n   that address.  This applies\
    \ to both active and inactive destination\n   addresses.\n   The upper layer can\
    \ optionally initiate the following functions:\n   A) Disable heartbeat on a specific\
    \ destination transport address of a\n      given association,\n   B) Change the\
    \ HB.interval,\n   C) Re-enable heartbeat on a specific destination transport\
    \ address of\n      a given association, and,\n   D) Request an on-demand HEARTBEAT\
    \ on a specific destination transport\n      address of a given association.\n\
    \   The endpoint should increment the respective error counter of the\n   destination\
    \ transport address each time a HEARTBEAT is sent to that\n   address and not\
    \ acknowledged within one RTO.\n   When the value of this counter reaches the\
    \ protocol parameter '\n   Path.Max.Retrans', the endpoint should mark the corresponding\n\
    \   destination address as inactive if it is not so marked, and may also\n   optionally\
    \ report to the upper layer the change of reachability of\n   this destination\
    \ address.  After this, the endpoint should continue\n   HEARTBEAT on this destination\
    \ address but should stop increasing the\n   counter.\n   The sender of the HEARTBEAT\
    \ chunk should include in the Heartbeat\n   Information field of the chunk the\
    \ current time when the packet is\n   sent out and the destination address to\
    \ which the packet is sent.\n   IMPLEMENTATION NOTE: An alternative implementation\
    \ of the heartbeat\n   mechanism that can be used is to increment the error counter\
    \ variable\n   every time a HEARTBEAT is sent to a destination.  Whenever a\n\
    \   HEARTBEAT ACK arrives, the sender SHOULD clear the error counter of\n   the\
    \ destination that the HEARTBEAT was sent to.  This in effect would\n   clear\
    \ the previously stroked error (and any other error counts as\n   well).\n   The\
    \ receiver of the HEARTBEAT should immediately respond with a\n   HEARTBEAT ACK\
    \ that contains the Heartbeat Information field copied\n   from the received HEARTBEAT\
    \ chunk.\n   Upon the receipt of the HEARTBEAT ACK, the sender of the HEARTBEAT\n\
    \   should clear the error counter of the destination transport address\n   to\
    \ which the HEARTBEAT was sent, and mark the destination transport\n   address\
    \ as active if it is not so marked.  The endpoint may\n   optionally report to\
    \ the upper layer when an inactive destination\n   address is marked as active\
    \ due to the reception of the latest\n   HEARTBEAT ACK.  The receiver of the HEARTBEAT\
    \ ACK must also clear the\n   association overall error count as well (as defined\
    \ in section 8.1).\n   The receiver of the HEARTBEAT ACK should also perform an\
    \ RTT\n   measurement for that destination transport address using the time\n\
    \   value carried in the HEARTBEAT ACK chunk.\n   On an idle destination address\
    \ that is allowed to heartbeat, a\n   HEARTBEAT chunk is RECOMMENDED to be sent\
    \ once per RTO of that\n   destination address plus the protocol parameter 'HB.interval'\
    \ , with\n   jittering of +/- 50%, and exponential back-off of the RTO if the\n\
    \   previous HEARTBEAT is unanswered.\n   A primitive is provided for the SCTP\
    \ user to change the HB.interval\n   and turn on or off the heartbeat on a given\
    \ destination address.  The\n   heartbeat interval set by the SCTP user is added\
    \ to the RTO of that\n   destination (including any exponential backoff).  Only\
    \ one heartbeat\n   should be sent each time the heartbeat timer expires (if multiple\n\
    \   destinations are idle).  It is a implementation decision on how to\n   choose\
    \ which of the candidate idle destinations to heartbeat to (if\n   more than one\
    \ destination is idle).\n   Note: When tuning the heartbeat interval, there is\
    \ a side effect that\n   SHOULD be taken into account.  When this value is increased,\
    \ i.e.\n   the HEARTBEAT takes longer, the detection of lost ABORT messages\n\
    \   takes longer as well.  If a peer endpoint ABORTs the association for\n   any\
    \ reason and the ABORT chunk is lost, the local endpoint will only\n   discover\
    \ the lost ABORT by sending a DATA chunk or HEARTBEAT chunk\n   (thus causing\
    \ the peer to send another ABORT).  This must be\n   considered when tuning the\
    \ HEARTBEAT timer.  If the HEARTBEAT is\n   disabled only sending DATA to the\
    \ association will discover a lost\n   ABORT from the peer.\n"
- title: 8.4 Handle "Out of the blue" Packets
  contents:
  - "8.4 Handle \"Out of the blue\" Packets\n   An SCTP packet is called an \"out\
    \ of the blue\" (OOTB) packet if it is\n   correctly formed, i.e., passed the\
    \ receiver's Adler-32 check (see\n   Section 6.8), but the receiver is not able\
    \ to identify the\n   association to which this packet belongs.\n   The receiver\
    \ of an OOTB packet MUST do the following:\n   1) If the OOTB packet is to or\
    \ from a non-unicast address, silently\n      discard the packet.  Otherwise,\n\
    \   2) If the OOTB packet contains an ABORT chunk, the receiver MUST\n      silently\
    \ discard the OOTB packet and take no further action.\n      Otherwise,\n   3)\
    \ If the packet contains an INIT chunk with a Verification Tag set\n      to '0',\
    \ process it as described in Section 5.1.  Otherwise,\n   4) If the packet contains\
    \ a COOKIE ECHO in the first chunk, process\n      it as described in Section\
    \ 5.1.  Otherwise,\n   5) If the packet contains a SHUTDOWN ACK chunk, the receiver\
    \ should\n      respond to the sender of the OOTB packet with a SHUTDOWN COMPLETE.\n\
    \      When sending the SHUTDOWN COMPLETE, the receiver of the OOTB\n      packet\
    \ must fill in the Verification Tag field of the outbound\n      packet with the\
    \ Verification Tag received in the SHUTDOWN ACK and\n      set the T-bit in the\
    \ Chunk Flags to indicate that no TCB was\n      found. Otherwise,\n   6) If the\
    \ packet contains a SHUTDOWN COMPLETE chunk, the receiver\n      should silently\
    \ discard the packet and take no further action.\n      Otherwise,\n   7) If the\
    \ packet contains a \"Stale cookie\" ERROR or a COOKIE ACK the\n      SCTP Packet\
    \ should be silently discarded.  Otherwise,\n   8) The receiver should respond\
    \ to the sender of the OOTB packet with\n      an ABORT.  When sending the ABORT,\
    \ the receiver of the OOTB packet\n      MUST fill in the Verification Tag field\
    \ of the outbound packet\n      with the value found in the Verification Tag field\
    \ of the OOTB\n      packet and set the T-bit in the Chunk Flags to indicate that\
    \ no\n      TCB was found.  After sending this ABORT, the receiver of the OOTB\n\
    \      packet shall discard the OOTB packet and take no further action.\n"
- title: 8.5 Verification Tag
  contents:
  - "8.5 Verification Tag\n   The Verification Tag rules defined in this section apply\
    \ when sending\n   or receiving SCTP packets which do not contain an INIT, SHUTDOWN\n\
    \   COMPLETE, COOKIE ECHO (see Section 5.1), ABORT or SHUTDOWN ACK chunk.\n  \
    \ The rules for sending and receiving SCTP packets containing one of\n   these\
    \ chunk types are discussed separately in Section 8.5.1.\n   When sending an SCTP\
    \ packet, the endpoint MUST fill in the\n   Verification Tag field of the outbound\
    \ packet with the tag value in\n   the Initiate Tag parameter of the INIT or INIT\
    \ ACK received from its\n   peer.\n   When receiving an SCTP packet, the endpoint\
    \ MUST ensure that the\n   value in the Verification Tag field of the received\
    \ SCTP packet\n   matches its own Tag.  If the received Verification Tag value\
    \ does not\n   match the receiver's own tag value, the receiver shall silently\n\
    \   discard the packet and shall not process it any further except for\n   those\
    \ cases listed in Section 8.5.1 below.\n"
- title: 8.5.1 Exceptions in Verification Tag Rules
  contents:
  - "8.5.1 Exceptions in Verification Tag Rules\n   A) Rules for packet carrying INIT:\n\
    \      -  The sender MUST set the Verification Tag of the packet to 0.\n     \
    \ -  When an endpoint receives an SCTP packet with the Verification\n        \
    \ Tag set to 0, it should verify that the packet contains only an\n         INIT\
    \ chunk.  Otherwise, the receiver MUST silently discard the\n         packet.\n\
    \   B) Rules for packet carrying ABORT:\n      -  The endpoint shall always fill\
    \ in the Verification Tag field of\n         the outbound packet with the destination\
    \ endpoint's tag value\n         if it is known.\n      -  If the ABORT is sent\
    \ in response to an OOTB packet, the\n         endpoint MUST follow the procedure\
    \ described in Section 8.4.\n      -  The receiver MUST accept the packet if the\
    \ Verification Tag\n         matches either its own tag, OR the tag of its peer.\
    \  Otherwise,\n         the receiver MUST silently discard the packet and take\
    \ no\n         further action.\n   C) Rules for packet carrying SHUTDOWN COMPLETE:\n\
    \      -  When sending a SHUTDOWN COMPLETE, if the receiver of the\n         SHUTDOWN\
    \ ACK has a TCB then the destination endpoint's tag MUST\n         be used.  Only\
    \ where no TCB exists should the sender use the\n         Verification Tag from\
    \ the SHUTDOWN ACK.\n      -  The receiver of a SHUTDOWN COMPLETE shall accept\
    \ the packet if\n         the Verification Tag field of the packet matches its\
    \ own tag OR\n         it is set to its peer's tag and the T bit is set in the\
    \ Chunk\n         Flags. Otherwise, the receiver MUST silently discard the packet\n\
    \         and take no further action.  An endpoint MUST ignore the\n         SHUTDOWN\
    \ COMPLETE if it is not in the SHUTDOWN-ACK-SENT state.\n   D) Rules for packet\
    \ carrying a COOKIE ECHO\n      -  When sending a COOKIE ECHO, the endpoint MUST\
    \ use the value of\n         the Initial Tag received in the INIT ACK.\n     \
    \ -  The receiver of a COOKIE ECHO follows the procedures in Section\n       \
    \  5.\n   E) Rules for packet carrying a SHUTDOWN ACK\n      -  If the receiver\
    \ is in COOKIE-ECHOED or COOKIE-WAIT state the\n         procedures in section\
    \ 8.4 SHOULD be followed, in other words it\n         should be treated as an\
    \ Out Of The Blue packet.\n"
- title: 9. Termination of Association
  contents:
  - "9. Termination of Association\n   An endpoint should terminate its association\
    \ when it exits from\n   service.  An association can be terminated by either\
    \ abort or\n   shutdown.  An abort of an association is abortive by definition\
    \ in\n   that any data pending on either end of the association is discarded\n\
    \   and not delivered to the peer.  A shutdown of an association is\n   considered\
    \ a graceful close where all data in queue by either\n   endpoint is delivered\
    \ to the respective peers.  However, in the case\n   of a shutdown, SCTP does\
    \ not support a half-open state (like TCP)\n   wherein one side may continue sending\
    \ data while the other end is\n   closed.  When either endpoint performs a shutdown,\
    \ the association on\n   each peer will stop accepting new data from its user\
    \ and only deliver\n   data in queue at the time of sending or receiving the SHUTDOWN\
    \ chunk.\n"
- title: 9.1 Abort of an Association
  contents:
  - "9.1 Abort of an Association\n   When an endpoint decides to abort an existing\
    \ association, it shall\n   send an ABORT chunk to its peer endpoint.  The sender\
    \ MUST fill in\n   the peer's Verification Tag in the outbound packet and MUST\
    \ NOT\n   bundle any DATA chunk with the ABORT.\n   An endpoint MUST NOT respond\
    \ to any received packet that contains an\n   ABORT chunk (also see Section 8.4).\n\
    \   An endpoint receiving an ABORT shall apply the special Verification\n   Tag\
    \ check rules described in Section 8.5.1.\n   After checking the Verification\
    \ Tag, the receiving endpoint shall\n   remove the association from its record,\
    \ and shall report the\n   termination to its upper layer.\n"
- title: 9.2 Shutdown of an Association
  contents:
  - "9.2 Shutdown of an Association\n   Using the SHUTDOWN primitive (see Section\
    \ 10.1), the upper layer of\n   an endpoint in an association can gracefully close\
    \ the association.\n   This will allow all outstanding DATA chunks from the peer\
    \ of the\n   shutdown initiator to be delivered before the association terminates.\n\
    \   Upon receipt of the SHUTDOWN primitive from its upper layer, the\n   endpoint\
    \ enters SHUTDOWN-PENDING state and remains there until all\n   outstanding data\
    \ has been acknowledged by its peer.  The endpoint\n   accepts no new data from\
    \ its upper layer, but retransmits data to the\n   far end if necessary to fill\
    \ gaps.\n   Once all its outstanding data has been acknowledged, the endpoint\n\
    \   shall send a SHUTDOWN chunk to its peer including in the Cumulative\n   TSN\
    \ Ack field the last sequential TSN it has received from the peer.\n   It shall\
    \ then start the T2-shutdown timer and enter the SHUTDOWN-SENT\n   state.  If\
    \ the timer expires, the endpoint must re-send the SHUTDOWN\n   with the updated\
    \ last sequential TSN received from its peer.\n   The rules in Section 6.3 MUST\
    \ be followed to determine the proper\n   timer value for T2-shutdown.  To indicate\
    \ any gaps in TSN, the\n   endpoint may also bundle a SACK with the SHUTDOWN chunk\
    \ in the same\n   SCTP packet.\n   An endpoint should limit the number of retransmissions\
    \ of the\n   SHUTDOWN chunk to the protocol parameter 'Association.Max.Retrans'.\n\
    \   If this threshold is exceeded the endpoint should destroy the TCB and\n  \
    \ MUST report the peer endpoint unreachable to the upper layer (and\n   thus the\
    \ association enters the CLOSED state).  The reception of any\n   packet from\
    \ its peer (i.e. as the peer sends all of its queued DATA\n   chunks) should clear\
    \ the endpoint's retransmission count and restart\n   the T2-Shutdown timer, \
    \ giving its peer ample opportunity to transmit\n   all of its queued DATA chunks\
    \ that have not yet been sent.\n   Upon the reception of the SHUTDOWN, the peer\
    \ endpoint shall\n   -  enter the SHUTDOWN-RECEIVED state,\n   -  stop accepting\
    \ new data from its SCTP user\n   -  verify, by checking the Cumulative TSN Ack\
    \ field of the chunk,\n      that all its outstanding DATA chunks have been received\
    \ by the\n      SHUTDOWN sender.\n   Once an endpoint as reached the SHUTDOWN-RECEIVED\
    \ state it MUST NOT\n   send a SHUTDOWN in response to a ULP request, and should\
    \ discard\n   subsequent SHUTDOWN chunks.\n   If there are still outstanding DATA\
    \ chunks left, the SHUTDOWN\n   receiver shall continue to follow normal data\
    \ transmission procedures\n   defined in Section 6 until all outstanding DATA\
    \ chunks are\n   acknowledged; however, the SHUTDOWN receiver MUST NOT accept\
    \ new data\n   from its SCTP user.\n   While in SHUTDOWN-SENT state, the SHUTDOWN\
    \ sender MUST immediately\n   respond to each received packet containing one or\
    \ more DATA chunk(s)\n   with a SACK, a SHUTDOWN chunk, and restart the T2-shutdown\
    \ timer. If\n   it has no more outstanding DATA chunks, the SHUTDOWN receiver\
    \ shall\n   send a SHUTDOWN ACK and start a T2-shutdown timer of its own,\n  \
    \ entering the SHUTDOWN-ACK-SENT state.  If the timer expires, the\n   endpoint\
    \ must re-send the SHUTDOWN ACK.\n   The sender of the SHUTDOWN ACK should limit\
    \ the number of\n   retransmissions of the SHUTDOWN ACK chunk to the protocol\
    \ parameter '\n   Association.Max.Retrans'.  If this threshold is exceeded the\
    \ endpoint\n   should destroy the TCB and may report the peer endpoint unreachable\n\
    \   to the upper layer (and thus the association enters the CLOSED\n   state).\n\
    \   Upon the receipt of the SHUTDOWN ACK, the SHUTDOWN sender shall stop\n   the\
    \ T2-shutdown timer, send a SHUTDOWN COMPLETE chunk to its peer,\n   and remove\
    \ all record of the association.\n   Upon reception of the SHUTDOWN COMPLETE chunk\
    \ the endpoint will\n   verify that it is in SHUTDOWN-ACK-SENT state, if it is\
    \ not the chunk\n   should be discarded.  If the endpoint is in the SHUTDOWN-ACK-SENT\n\
    \   state the endpoint should stop the T2-shutdown timer and remove all\n   knowledge\
    \ of the association (and thus the association enters the\n   CLOSED state).\n\
    \   An endpoint SHOULD assure that all its outstanding DATA chunks have\n   been\
    \ acknowledged before initiating the shutdown procedure.\n   An endpoint should\
    \ reject any new data request from its upper layer\n   if it is in SHUTDOWN-PENDING,\
    \ SHUTDOWN-SENT, SHUTDOWN-RECEIVED, or\n   SHUTDOWN-ACK-SENT state.\n   If an\
    \ endpoint is in SHUTDOWN-ACK-SENT state and receives an INIT\n   chunk (e.g.,\
    \ if the SHUTDOWN COMPLETE was lost) with source and\n   destination transport\
    \ addresses (either in the IP addresses or in the\n   INIT chunk) that belong\
    \ to this association, it should discard the\n   INIT chunk and retransmit the\
    \ SHUTDOWN ACK chunk.\n   Note: Receipt of an INIT with the same source and destination\
    \ IP\n   addresses as used in transport addresses assigned to an endpoint but\n\
    \   with a different port number indicates the initialization of a\n   separate\
    \ association.\n   The sender of the INIT or COOKIE ECHO should respond to the\
    \ receipt\n   of a SHUTDOWN-ACK with a stand-alone SHUTDOWN COMPLETE in an SCTP\n\
    \   packet with the Verification Tag field of its common header set to\n   the\
    \ same tag that was received in the SHUTDOWN ACK packet.  This is\n   considered\
    \ an Out of the Blue packet as defined in Section 8.4.  The\n   sender of the\
    \ INIT lets T1-init continue running and remains in the\n   COOKIE-WAIT or COOKIE-ECHOED\
    \ state.  Normal T1-init timer expiration\n   will cause the INIT or COOKIE chunk\
    \ to be retransmitted and thus\n   start a new association.\n   If a SHUTDOWN\
    \ is received in COOKIE WAIT or COOKIE ECHOED states the\n   SHUTDOWN chunk SHOULD\
    \ be silently discarded.\n   If an endpoint is in SHUTDOWN-SENT state and receives\
    \ a SHUTDOWN\n   chunk from its peer, the endpoint shall respond immediately with\
    \ a\n   SHUTDOWN ACK to its peer, and move into a SHUTDOWN-ACK-SENT state\n  \
    \ restarting its T2-shutdown timer.\n   If an endpoint is in the SHUTDOWN-ACK-SENT\
    \ state and receives a\n   SHUTDOWN ACK, it shall stop the T2-shutdown timer,\
    \ send a SHUTDOWN\n   COMPLETE chunk to its peer, and remove all record of the\
    \ association.\n"
- title: 10. Interface with Upper Layer
  contents:
  - "10. Interface with Upper Layer\n   The Upper Layer Protocols (ULP) shall request\
    \ for services by passing\n   primitives to SCTP and shall receive notifications\
    \ from SCTP for\n   various events.\n   The primitives and notifications described\
    \ in this section should be\n   used as a guideline for implementing SCTP.  The\
    \ following functional\n   description of ULP interface primitives is shown for\
    \ illustrative\n   purposes.  Different SCTP implementations may have different\
    \ ULP\n   interfaces.  However, all SCTPs must provide a certain minimum set of\n\
    \   services to guarantee that all SCTP implementations can support the\n   same\
    \ protocol hierarchy.\n"
- title: 10.1 ULP-to-SCTP
  contents:
  - "10.1 ULP-to-SCTP\n   The following sections functionally characterize a ULP/SCTP\n\
    \   interface.  The notation used is similar to most procedure or\n   function\
    \ calls in high level languages.\n   The ULP primitives described below specify\
    \ the basic functions the\n   SCTP must perform to support inter-process communication.\
    \  Individual\n   implementations must define their own exact format, and may\
    \ provide\n   combinations or subsets of the basic functions in single calls.\n\
    \   A) Initialize\n   Format: INITIALIZE ([local port], [local eligible address\
    \ list]) ->\n   local SCTP instance name\n   This primitive allows SCTP to initialize\
    \ its internal data structures\n   and allocate necessary resources for setting\
    \ up its operation\n   environment.  Once SCTP is initialized, ULP can communicate\
    \ directly\n   with other endpoints without re-invoking this primitive.\n   SCTP\
    \ will return a local SCTP instance name to the ULP.\n   Mandatory attributes:\n\
    \   None.\n   Optional attributes:\n   The following types of attributes may be\
    \ passed along with the\n   primitive:\n   o  local port - SCTP port number, if\
    \ ULP wants it to be specified;\n   o  local eligible address list - An address\
    \ list that the local SCTP\n      endpoint should bind.  By default, if an address\
    \ list is not\n      included, all IP addresses assigned to the host should be\
    \ used by\n      the local endpoint.\n   IMPLEMENTATION NOTE: If this optional\
    \ attribute is supported by an\n   implementation, it will be the responsibility\
    \ of the implementation\n   to enforce that the IP source address field of any\
    \ SCTP packets sent\n   out by this endpoint contains one of the IP addresses\
    \ indicated in\n   the local eligible address list.\n   B) Associate\n   Format:\
    \ ASSOCIATE(local SCTP instance name, destination transport addr,\n          \
    \ outbound stream count)\n   -> association id [,destination transport addr list]\
    \ [,outbound stream\n      count]\n   This primitive allows the upper layer to\
    \ initiate an association to a\n   specific peer endpoint.\n   The peer endpoint\
    \ shall be specified by one of the transport\n   addresses which defines the endpoint\
    \ (see Section 1.4).  If the local\n   SCTP instance has not been initialized,\
    \ the ASSOCIATE is considered\n   an error.\n   An association id, which is a\
    \ local handle to the SCTP association,\n   will be returned on successful establishment\
    \ of the association.  If\n   SCTP is not able to open an SCTP association with\
    \ the peer endpoint,\n   an error is returned.\n   Other association parameters\
    \ may be returned, including the complete\n   destination transport addresses\
    \ of the peer as well as the outbound\n   stream count of the local endpoint.\
    \  One of the transport address\n   from the returned destination addresses will\
    \ be selected by the local\n   endpoint as default primary path for sending SCTP\
    \ packets to this\n   peer.  The returned \"destination transport addr list\"\
    \ can be used by\n   the ULP to change the default primary path or to force sending\
    \ a\n   packet to a specific transport address.\n   IMPLEMENTATION NOTE: If ASSOCIATE\
    \ primitive is implemented as a\n   blocking function call, the ASSOCIATE primitive\
    \ can return\n   association parameters in addition to the association id upon\n\
    \   successful establishment.  If ASSOCIATE primitive is implemented as a\n  \
    \ non-blocking call, only the association id shall be returned and\n   association\
    \ parameters shall be passed using the COMMUNICATION UP\n   notification.\n  \
    \ Mandatory attributes:\n   o  local SCTP instance name - obtained from the INITIALIZE\
    \ operation.\n   o  destination transport addr - specified as one of the transport\n\
    \      addresses of the peer endpoint with which the association is to be\n  \
    \    established.\n   o  outbound stream count - the number of outbound streams\
    \ the ULP\n      would like to open towards this peer endpoint.\n   Optional attributes:\n\
    \   None.\n   C) Shutdown\n   Format: SHUTDOWN(association id)\n   -> result\n\
    \   Gracefully closes an association.  Any locally queued user data will\n   be\
    \ delivered to the peer.  The association will be terminated only\n   after the\
    \ peer acknowledges all the SCTP packets sent.  A success\n   code will be returned\
    \ on successful termination of the association.\n   If attempting to terminate\
    \ the association results in a failure, an\n   error code shall be returned.\n\
    \   Mandatory attributes:\n   o  association id - local handle to the SCTP association\n\
    \   Optional attributes:\n   None.\n   D) Abort\n   Format: ABORT(association\
    \ id [, cause code])\n   -> result\n   Ungracefully closes an association.  Any\
    \ locally queued user data\n   will be discarded and an ABORT chunk is sent to\
    \ the peer.  A success\n   code will be returned on successful abortion of the\
    \ association.  If\n   attempting to abort the association results in a failure,\
    \ an error\n   code shall be returned.\n   Mandatory attributes:\n   o  association\
    \ id - local handle to the SCTP association\n   Optional attributes:\n   o  cause\
    \ code - reason of the abort to be passed to the peer.\n   None.\n   E) Send\n\
    \   Format: SEND(association id, buffer address, byte count [,context]\n     \
    \      [,stream id] [,life time] [,destination transport address]\n          \
    \ [,unorder flag] [,no-bundle flag] [,payload protocol-id] )\n   -> result\n \
    \  This is the main method to send user data via SCTP.\n   Mandatory attributes:\n\
    \   o  association id - local handle to the SCTP association\n   o  buffer address\
    \ - the location where the user message to be\n      transmitted is stored;\n\
    \   o  byte count - The size of the user data in number of bytes;\n   Optional\
    \ attributes:\n   o  context - an optional 32 bit integer that will be carried\
    \ in the\n      sending failure notification to the ULP if the transportation\
    \ of\n      this User Message fails.\n   o  stream id - to indicate which stream\
    \ to send the data on.  If not\n      specified, stream 0 will be used.\n   o\
    \  life time - specifies the life time of the user data.  The user\n      data\
    \ will not be sent by SCTP after the life time expires.  This\n      parameter\
    \ can be used to avoid efforts to transmit stale user\n      messages.  SCTP notifies\
    \ the ULP if the data cannot be initiated\n      to transport (i.e. sent to the\
    \ destination via SCTP's send\n      primitive) within the life time variable.\
    \  However, the user data\n      will be transmitted if SCTP has attempted to\
    \ transmit a chunk\n      before the life time expired.\n   IMPLEMENTATION NOTE:\
    \ In order to better support the data lifetime\n   option, the transmitter may\
    \ hold back the assigning of the TSN number\n   to an outbound DATA chunk to the\
    \ last moment.  And, for\n   implementation simplicity, once a TSN number has\
    \ been assigned the\n   sender should consider the send of this DATA chunk as\
    \ committed,\n   overriding any lifetime option attached to the DATA chunk.\n\
    \   o  destination transport address - specified as one of the\n      destination\
    \ transport addresses of the peer endpoint to which this\n      packet should\
    \ be sent.  Whenever possible, SCTP should use this\n      destination transport\
    \ address for sending the packets, instead of\n      the current primary path.\n\
    \   o  unorder flag - this flag, if present, indicates that the user\n      would\
    \ like the data delivered in an unordered fashion to the peer\n      (i.e., the\
    \ U flag is set to 1 on all DATA chunks carrying this\n      message).\n   o \
    \ no-bundle flag - instructs SCTP not to bundle this user data with\n      other\
    \ outbound DATA chunks.  SCTP MAY still bundle even when this\n      flag is present,\
    \ when faced with network congestion.\n   o  payload protocol-id - A 32 bit unsigned\
    \ integer that is to be\n      passed to the peer indicating the type of payload\
    \ protocol data\n      being transmitted.  This value is passed as opaque data\
    \ by SCTP.\n   F) Set Primary\n   Format: SETPRIMARY(association id, destination\
    \ transport address,\n                      [source transport address] )\n   ->\
    \ result\n   Instructs the local SCTP to use the specified destination transport\n\
    \   address as primary path for sending packets.\n   The result of attempting\
    \ this operation shall be returned.  If the\n   specified destination transport\
    \ address is not present in the\n   \"destination transport address list\" returned\
    \ earlier in an associate\n   command or communication up notification, an error\
    \ shall be returned.\n   Mandatory attributes:\n   o  association id - local handle\
    \ to the SCTP association\n   o  destination transport address - specified as\
    \ one of the transport\n      addresses of the peer endpoint, which should be\
    \ used as primary\n      address for sending packets.  This overrides the current\
    \ primary\n      address information maintained by the local SCTP endpoint.\n\
    \   Optional attributes:\n   o  source transport address - optionally, some implementations\
    \ may\n      allow you to set the default source address placed in all outgoing\n\
    \      IP datagrams.\n   G) Receive\n   Format: RECEIVE(association id, buffer\
    \ address, buffer size\n           [,stream id])\n   -> byte count [,transport\
    \ address] [,stream id] [,stream sequence\n      number] [,partial flag] [,delivery\
    \ number] [,payload protocol-id]\n   This primitive shall read the first user\
    \ message in the SCTP in-queue\n   into the buffer specified by ULP, if there\
    \ is one available.  The\n   size of the message read, in bytes, will be returned.\
    \  It may,\n   depending on the specific implementation, also return other\n \
    \  information such as the sender's address, the stream id on which it\n   is\
    \ received, whether there are more messages available for retrieval,\n   etc.\
    \  For ordered messages, their stream sequence number may also be\n   returned.\n\
    \   Depending upon the implementation, if this primitive is invoked when\n   no\
    \ message is available the implementation should return an\n   indication of this\
    \ condition or should block the invoking process\n   until data does become available.\n\
    \   Mandatory attributes:\n   o  association id - local handle to the SCTP association\n\
    \   o  buffer address - the memory location indicated by the ULP to store\n  \
    \    the received message.\n   o  buffer size - the maximum size of data to be\
    \ received, in bytes.\n   Optional attributes:\n   o  stream id - to indicate\
    \ which stream to receive the data on.\n   o  stream sequence number - the stream\
    \ sequence number assigned by\n      the sending SCTP peer.\n   o  partial flag\
    \ - if this returned flag is set to 1, then this\n      Receive contains  a partial\
    \ delivery of the whole message.  When\n      this flag is set, the stream id\
    \ and stream sequence number MUST\n      accompany this receive.  When this flag\
    \ is set to 0, it indicates\n      that no more deliveries will be received for\
    \ this stream sequence\n      number.\n   o  payload protocol-id - A 32 bit unsigned\
    \ integer that is received\n      from the peer indicating the type of payload\
    \ protocol of the\n      received data.  This value is passed as opaque data by\
    \ SCTP.\n   H) Status\n   Format: STATUS(association id)\n   -> status data\n\
    \   This primitive should return a data block containing the following\n   information:\n\
    \     association connection state,\n     destination transport address list,\n\
    \     destination transport address reachability states,\n     current receiver\
    \ window size,\n     current congestion window sizes,\n     number of  unacknowledged\
    \ DATA chunks,\n     number of DATA chunks pending receipt,\n     primary path,\n\
    \     most recent SRTT on primary path,\n     RTO on primary path,\n     SRTT\
    \ and RTO on other destination addresses, etc.\n   Mandatory attributes:\n   o\
    \ association id - local handle to the SCTP association\n   Optional attributes:\n\
    \    None.\n   I) Change Heartbeat\n   Format: CHANGEHEARTBEAT(association id,\
    \ destination transport address,\n           new state [,interval])\n   -> result\n\
    \   Instructs the local endpoint to enable or disable heartbeat on the\n   specified\
    \ destination transport address.\n   The result of attempting this operation shall\
    \ be returned.\n   Note: Even when enabled, heartbeat will not take place if the\n\
    \   destination transport address is not idle.\n   Mandatory attributes:\n   o\
    \  association id - local handle to the SCTP association\n   o  destination transport\
    \ address - specified as one of the transport\n      addresses of the peer endpoint.\n\
    \   o  new state - the new state of heartbeat for this destination\n      transport\
    \ address (either enabled or disabled).\n   Optional attributes:\n   o  interval\
    \ - if present, indicates the frequency of the heartbeat if\n      this is to\
    \ enable heartbeat on a destination transport address.\n      This value is added\
    \ to the RTO of the destination transport\n      address. This value, if present,\
    \ effects all destinations.\n   J) Request HeartBeat\n   Format: REQUESTHEARTBEAT(association\
    \ id, destination transport\n           address)\n   -> result\n   Instructs the\
    \ local endpoint to perform a HeartBeat on the specified\n   destination transport\
    \ address of the given association.  The returned\n   result should indicate whether\
    \ the transmission of the HEARTBEAT\n   chunk to the destination address is successful.\n\
    \   Mandatory attributes:\n   o  association id - local handle to the SCTP association\n\
    \   o  destination transport address - the transport address of the\n      association\
    \ on which a heartbeat should be issued.\n   K) Get SRTT Report\n   Format: GETSRTTREPORT(association\
    \ id, destination transport address)\n   -> srtt result\n   Instructs the local\
    \ SCTP to report the current SRTT measurement on\n   the specified destination\
    \ transport address of the given association.\n   The returned result can be an\
    \ integer containing the most recent SRTT\n   in milliseconds.\n   Mandatory attributes:\n\
    \   o  association id - local handle to the SCTP association\n   o  destination\
    \ transport address - the transport address of the\n      association on which\
    \ the SRTT measurement is to be reported.\n   L) Set Failure Threshold\n   Format:\
    \ SETFAILURETHRESHOLD(association id, destination transport\n           address,\
    \ failure threshold)\n   -> result\n   This primitive allows the local SCTP to\
    \ customize the reachability\n   failure detection threshold 'Path.Max.Retrans'\
    \ for the specified\n   destination address.\n   Mandatory attributes:\n   o \
    \ association id - local handle to the SCTP association\n   o  destination transport\
    \ address - the transport address of the\n      association on which the failure\
    \ detection threshold is to be set.\n   o  failure threshold - the new value of\
    \ 'Path.Max.Retrans' for the\n      destination address.\n   M) Set Protocol Parameters\n\
    \   Format: SETPROTOCOLPARAMETERS(association id, [,destination transport\n  \
    \         address,] protocol parameter list)\n   -> result\n   This primitive\
    \ allows the local SCTP to customize the protocol\n   parameters.\n   Mandatory\
    \ attributes:\n   o  association id - local handle to the SCTP association\n \
    \  o  protocol parameter list - The specific names and values of the\n      protocol\
    \ parameters (e.g., Association.Max.Retrans [see Section\n      14]) that the\
    \ SCTP user wishes to customize.\n   Optional attributes:\n   o  destination transport\
    \ address - some of the protocol parameters\n      may be set on a per destination\
    \ transport address basis.\n   N) Receive unsent message\n   Format: RECEIVE_UNSENT(data\
    \ retrieval id, buffer address, buffer size\n           [,stream id] [, stream\
    \ sequence number] [,partial flag]\n           [,payload protocol-id])\n   o \
    \ data retrieval id - The identification passed to the ULP in the\n      failure\
    \ notification.\n   o  buffer address - the memory location indicated by the ULP\
    \ to store\n      the received message.\n   o  buffer size - the maximum size\
    \ of data to be received, in bytes.\n   Optional attributes:\n   o  stream id\
    \ - this is a return value that is set to  indicate\n      which stream the data\
    \ was sent to.\n   o  stream sequence number - this value is returned indicating\n\
    \      the stream sequence number that was associated with the message.\n   o\
    \  partial flag - if this returned flag is set to 1, then this\n      message\
    \ is a partial delivery of the whole message.  When\n      this flag is set, the\
    \ stream id and stream sequence number MUST\n      accompany this receive.  When\
    \ this flag is set to 0, it indicates\n      that no more deliveries will be received\
    \ for this stream sequence\n      number.\n   o  payload protocol-id - The 32\
    \ bit unsigned integer that was sent to\n      be sent to the peer indicating\
    \ the type of payload protocol of the\n      received data.\n   O)  Receive unacknowledged\
    \ message\n   Format: RECEIVE_UNACKED(data retrieval id, buffer address, buffer\
    \ size,\n           [,stream id] [, stream sequence number] [,partial flag]\n\
    \           [,payload protocol-id])\n   o  data retrieval id - The identification\
    \ passed to the ULP in the\n      failure notification.\n   o  buffer address\
    \ - the memory location indicated by the ULP to store\n      the received message.\n\
    \   o  buffer size - the maximum size of data to be received, in bytes.\n   Optional\
    \ attributes:\n   o  stream id - this is a return value that is set to  indicate\
    \ which\n      stream the data was sent to.\n   o  stream sequence number - this\
    \ value is returned indicating the\n      stream sequence number that was associated\
    \ with the message.\n   o  partial flag - if this returned flag is set to 1, then\
    \ this\n      message is a partial delivery of the whole message.  When this\n\
    \      flag is set, the stream id and stream sequence number MUST\n      accompany\
    \ this receive.  When this flag is set to 0, it indicates\n      that no more\
    \ deliveries will be received for this stream sequence\n      number.\n   o  payload\
    \ protocol-id - The 32 bit unsigned integer that was sent to\n      be sent to\
    \ the peer indicating the type of payload protocol of the\n      received data.\n\
    \   P) Destroy SCTP instance\n   Format: DESTROY(local SCTP instance name)\n \
    \  o  local SCTP instance name - this is the value that was passed to\n      the\
    \ application in the initialize primitive and it indicates which\n      SCTP instance\
    \ to be destroyed.\n"
- title: 10.2 SCTP-to-ULP
  contents:
  - "10.2 SCTP-to-ULP\n   It is assumed that the operating system or application environment\n\
    \   provides a means for the SCTP to asynchronously signal the ULP\n   process.\
    \  When SCTP does signal an ULP process, certain information\n   is passed to\
    \ the ULP.\n   IMPLEMENTATION NOTE: In some cases this may be done through a\n\
    \   separate socket or error channel.\n   A) DATA ARRIVE notification\n   SCTP\
    \ shall invoke this notification on the ULP when a user message is\n   successfully\
    \ received and ready for retrieval.\n   The following may be optionally be passed\
    \ with the notification:\n   o  association id - local handle to the SCTP association\n\
    \   o  stream id - to indicate which stream the data is received on.\n   B) SEND\
    \ FAILURE notification\n   If a message can not be delivered SCTP shall invoke\
    \ this notification\n   on the ULP.\n   The following may be optionally be passed\
    \ with the notification:\n   o  association id - local handle to the SCTP association\n\
    \   o  data retrieval id - an identification used to retrieve unsent and\n   \
    \   unacknowledged data.\n   o  cause code - indicating the reason of the failure,\
    \ e.g., size too\n      large, message life-time expiration, etc.\n   o  context\
    \ - optional information associated with this message (see D\n      in Section\
    \ 10.1).\n   C) NETWORK STATUS CHANGE notification\n   When a destination transport\
    \ address is marked inactive (e.g., when\n   SCTP detects a failure), or marked\
    \ active (e.g., when SCTP detects a\n   recovery), SCTP shall invoke this notification\
    \ on the ULP.\n   The following shall be passed with the notification:\n   o \
    \ association id - local handle to the SCTP association\n   o  destination transport\
    \ address - This indicates the destination\n      transport address of the peer\
    \ endpoint affected by the change;\n   o  new-status - This indicates the new\
    \ status.\n   D) COMMUNICATION UP notification\n   This notification is used when\
    \ SCTP becomes ready to send or receive\n   user messages, or when a lost communication\
    \ to an endpoint is\n   restored.\n   IMPLEMENTATION NOTE: If ASSOCIATE primitive\
    \ is implemented as a\n   blocking function call, the association parameters are\
    \ returned as a\n   result of the ASSOCIATE primitive itself.  In that case,\n\
    \   COMMUNICATION UP notification is optional at the association\n   initiator's\
    \ side.\n   The following shall be passed with the notification:\n   o  association\
    \ id - local handle to the SCTP association\n   o  status - This indicates what\
    \ type of event has occurred\n   o  destination transport address list - the complete\
    \ set of transport\n      addresses of the peer\n   o  outbound stream count -\
    \ the maximum number of streams allowed to\n      be used in this association\
    \ by the ULP\n   o  inbound stream count - the number of streams the peer endpoint\
    \ has\n      requested with this association (this may not be the same number\n\
    \      as 'outbound stream count').\n   E) COMMUNICATION LOST notification\n \
    \  When SCTP loses communication to an endpoint completely (e.g., via\n   Heartbeats)\
    \ or detects that the endpoint has performed an abort\n   operation, it shall\
    \ invoke this notification on the ULP.\n   The following shall be passed with\
    \ the notification:\n   o  association id - local handle to the SCTP association\n\
    \   o status - This indicates what type of event has occurred; The status\n  \
    \            may indicate a failure OR a normal termination event\n          \
    \    occurred in response to a shutdown or abort request.\n   The following may\
    \ be passed with the notification:\n   o  data retrieval id - an identification\
    \ used to retrieve unsent and\n      unacknowledged data.\n   o  last-acked -\
    \ the TSN last acked by that peer endpoint;\n   o  last-sent - the TSN last sent\
    \ to that peer endpoint;\n   F) COMMUNICATION ERROR notification\n   When SCTP\
    \ receives an ERROR chunk from its peer and decides to notify\n   its ULP, it\
    \ can invoke this notification on the ULP.\n   The following can be passed with\
    \ the notification:\n   o  association id - local handle to the SCTP association\n\
    \   o  error info - this indicates the type of error and optionally some\n   \
    \   additional information received through the ERROR chunk.\n   G) RESTART notification\n\
    \   When SCTP detects that the peer has restarted, it may send this\n   notification\
    \ to its ULP.\n   The following can be passed with the notification:\n   o  association\
    \ id - local handle to the SCTP association\n   H) SHUTDOWN COMPLETE notification\n\
    \   When SCTP completes the shutdown procedures (section 9.2) this\n   notification\
    \ is passed to the upper layer.\n   The following can be passed with the notification:\n\
    \   o  association id - local handle to the SCTP association\n"
- title: 11. Security Considerations
  contents:
  - '11. Security Considerations

    '
- title: 11.1 Security Objectives
  contents:
  - "11.1 Security Objectives\n   As a common transport protocol designed to reliably\
    \ carry time-\n   sensitive user messages, such as billing or signaling messages\
    \ for\n   telephony services, between two networked endpoints, SCTP has the\n\
    \   following security objectives.\n   -  availability of reliable and timely\
    \ data transport services\n   -  integrity of the user-to-user information carried\
    \ by SCTP\n"
- title: 11.2 SCTP Responses To Potential Threats
  contents:
  - "11.2 SCTP Responses To Potential Threats\n   SCTP may potentially be used in\
    \ a wide variety of risk situations.\n   It is important for operator(s) of systems\
    \ running SCTP to analyze\n   their particular situations and decide on the appropriate\
    \ counter-\n   measures.\n   Operators of systems running SCTP should consult\
    \ [RFC2196] for\n   guidance in securing their site.\n"
- title: 11.2.1 Countering Insider Attacks
  contents:
  - "11.2.1 Countering Insider Attacks\n   The principles of [RFC2196] should be applied\
    \ to minimize the risk of\n   theft of information or sabotage by insiders.  Such\
    \ procedures\n   include publication of security policies, control of access at\
    \ the\n   physical, software, and network levels, and separation of services.\n"
- title: 11.2.2 Protecting against Data Corruption in the Network
  contents:
  - "11.2.2 Protecting against Data Corruption in the Network\n   Where the risk of\
    \ undetected errors in datagrams delivered by the\n   lower layer transport services\
    \ is considered to be too great,\n   additional integrity protection is required.\
    \  If this additional\n   protection were provided in the application-layer, the\
    \ SCTP header\n   would remain vulnerable to deliberate integrity attacks.  While\
    \ the\n   existing SCTP mechanisms for detection of packet replays are\n   considered\
    \ sufficient for normal operation, stronger protections are\n   needed to protect\
    \ SCTP when the operating environment contains\n   significant risk of deliberate\
    \ attacks from a sophisticated\n   adversary.\n   In order to promote software\
    \ code-reuse, to avoid re-inventing the\n   wheel, and to avoid gratuitous complexity\
    \ to SCTP, the IP\n   Authentication Header [RFC2402] SHOULD be used when the\
    \ threat\n   environment requires stronger integrity protections, but does not\n\
    \   require confidentiality.\n   A widely implemented BSD Sockets API extension\
    \ exists for\n   applications to request IP security services, such as AH or ESP\
    \ from\n   an operating system kernel.  Applications can use such an API to\n\
    \   request AH whenever AH use is appropriate.\n"
- title: 11.2.3 Protecting Confidentiality
  contents:
  - "11.2.3 Protecting Confidentiality\n   In most cases, the risk of breach of confidentiality\
    \ applies to the\n   signaling data payload, not to the SCTP or lower-layer protocol\n\
    \   overheads.  If that is true, encryption of the SCTP user data only\n   might\
    \ be considered.  As with the supplementary checksum service,\n   user data encryption\
    \ MAY be performed by the SCTP user application.\n   Alternately, the user application\
    \ MAY use an implementation-specific\n   API to request that the IP Encapsulating\
    \ Security Payload (ESP)\n   [RFC2406] be used to provide confidentiality and\
    \ integrity.\n   Particularly for mobile users, the requirement for confidentiality\n\
    \   might include the masking of IP addresses and ports.  In this case\n   ESP\
    \ SHOULD be used instead of application-level confidentiality.  If\n   ESP is\
    \ used to protect confidentiality of SCTP traffic, an ESP\n   cryptographic transform\
    \ that includes cryptographic integrity\n   protection MUST be used, because if\
    \ there is a confidentiality threat\n   there will also be a strong integrity\
    \ threat.\n   Whenever ESP is in use, application-level encryption is not generally\n\
    \   required.\n   Regardless of where confidentiality is provided, the ISAKMP\
    \ [RFC2408]\n   and the Internet Key Exchange (IKE) [RFC2409] SHOULD be used for\
    \ key\n   management.\n   Operators should consult [RFC2401] for more information\
    \ on the\n   security services available at and immediately above the Internet\n\
    \   Protocol layer.\n"
- title: 11.2.4 Protecting against Blind Denial of Service Attacks
  contents:
  - "11.2.4 Protecting against Blind Denial of Service Attacks\n   A blind attack\
    \ is one where the attacker is unable to intercept or\n   otherwise see the content\
    \ of data flows passing to and from the\n   target SCTP node.  Blind denial of\
    \ service attacks may take the form\n   of flooding, masquerade, or improper monopolization\
    \ of services.\n"
- title: 11.2.4.1 Flooding
  contents:
  - "11.2.4.1 Flooding\n   The objective of flooding is to cause loss of service and\
    \ incorrect\n   behavior at target systems through resource exhaustion, interference\n\
    \   with legitimate transactions, and exploitation of buffer-related\n   software\
    \ bugs.  Flooding may be directed either at the SCTP node or\n   at resources\
    \ in the intervening IP Access Links or the Internet.\n   Where the latter entities\
    \ are the target, flooding will manifest\n   itself as loss of network services,\
    \ including potentially the breach\n   of any firewalls in place.\n   In general,\
    \ protection against flooding begins at the equipment\n   design level, where\
    \ it includes measures such as:\n   -  avoiding commitment of limited resources\
    \ before determining that\n      the request for service is legitimate\n   - \
    \ giving priority to completion of processing in progress over the\n      acceptance\
    \ of new work\n   -  identification and removal of duplicate or stale queued requests\n\
    \      for service.\n   -  not responding to unexpected packets sent to non-unicast\n\
    \      addresses.\n   Network equipment should be capable of generating an alarm\
    \ and log if\n   a suspicious increase in traffic occurs.  The log should provide\n\
    \   information such as the identity of the incoming link and source\n   address(es)\
    \ used which will help the network or SCTP system operator\n   to take protective\
    \ measures.  Procedures should be in place for the\n   operator to act on such\
    \ alarms if a clear pattern of abuse emerges.\n   The design of SCTP is resistant\
    \ to flooding attacks, particularly in\n   its use of a four-way start-up handshake,\
    \ its use of a cookie to\n   defer commitment of resources at the responding SCTP\
    \ node until the\n   handshake is completed, and its use of a Verification Tag\
    \ to prevent\n   insertion of extraneous packets into the flow of an established\n\
    \   association.\n   The IP Authentication Header and Encapsulating Security Payload\
    \ might\n   be useful in reducing the risk of certain kinds of denial of service\n\
    \   attacks.\"\n   The use of the Host Name feature in the INIT chunk could be\
    \ used to\n   flood a target DNS server.  A large backlog of DNS queries, resolving\n\
    \   the Host Name received in the INIT chunk to IP addresses, could be\n   accomplished\
    \ by sending INIT's to multiple hosts in a given domain.\n   In addition, an attacker\
    \ could use the Host Name feature in an\n   indirect attack on a third party by\
    \ sending large numbers of INITs to\n   random hosts containing the host name\
    \ of the target.  In addition to\n   the strain on DNS resources, this could also\
    \ result in large numbers\n   of INIT ACKs being sent to the target.  One method\
    \ to protect against\n   this type of attack is to verify that the IP addresses\
    \ received from\n   DNS include the source IP address of the original INIT.  If\
    \ the list\n   of IP addresses received from DNS does not include the source IP\n\
    \   address of the INIT, the endpoint MAY silently discard the INIT.\n   This\
    \ last option will not protect against the attack against the DNS.\n"
- title: 11.2.4.2 Blind Masquerade
  contents:
  - "11.2.4.2 Blind Masquerade\n   Masquerade can be used to deny service in several\
    \ ways:\n   -  by tying up resources at the target SCTP node to which the\n  \
    \    impersonated node has limited access.  For example, the target\n      node\
    \ may by policy permit a maximum of one SCTP association with\n      the impersonated\
    \ SCTP node.  The masquerading attacker may attempt\n      to establish an association\
    \ purporting to come from the\n      impersonated node so that the latter cannot\
    \ do so when it requires\n      it.\n   -  by deliberately allowing the impersonation\
    \ to be detected, thereby\n      provoking counter-measures which cause the impersonated\
    \ node to be\n      locked out of the target SCTP node.\n   -  by interfering\
    \ with an established association by inserting\n      extraneous content such\
    \ as a SHUTDOWN request.\n   SCTP reduces the risk of blind masquerade attacks\
    \ through IP spoofing\n   by use of the four-way startup handshake.  Man-in-the-middle\n\
    \   masquerade attacks are discussed in Section 11.3 below.  Because the\n   initial\
    \ exchange is memoryless, no lockout mechanism is triggered by\n   blind masquerade\
    \ attacks.  In addition, the INIT ACK containing the\n   State Cookie is transmitted\
    \ back to the IP address from which it\n   received the INIT.  Thus the attacker\
    \ would not receive the INIT ACK\n   containing the State Cookie.  SCTP protects\
    \ against insertion of\n   extraneous packets into the flow of an established\
    \ association by use\n   of the Verification Tag.\n   Logging of received INIT\
    \ requests and abnormalities such as\n   unexpected INIT ACKs might be considered\
    \ as a way to detect patterns\n   of hostile activity.  However, the potential\
    \ usefulness of such\n   logging must be weighed against the increased SCTP startup\
    \ processing\n   it implies, rendering the SCTP node more vulnerable to flooding\n\
    \   attacks.  Logging is pointless without the establishment of operating\n  \
    \ procedures to review and analyze the logs on a routine basis.\n"
- title: 11.2.4.3 Improper Monopolization of Services
  contents:
  - "11.2.4.3 Improper Monopolization of Services\n   Attacks under this heading are\
    \ performed openly and legitimately by\n   the attacker.  They are directed against\
    \ fellow users of the target\n   SCTP node or of the shared resources between\
    \ the attacker and the\n   target node.  Possible attacks include the opening\
    \ of a large number\n   of associations between the attacker's node and the target,\
    \ or\n   transfer of large volumes of information within a legitimately-\n   established\
    \ association.\n   Policy limits should be placed on the number of associations\
    \ per\n   adjoining SCTP node.  SCTP user applications should be capable of\n\
    \   detecting large volumes of illegitimate or \"no-op\" messages within a\n \
    \  given association and either logging or terminating the association\n   as\
    \ a result, based on local policy.\n"
- title: 11.3 Protection against Fraud and Repudiation
  contents:
  - "11.3 Protection against Fraud and Repudiation\n   The objective of fraud is to\
    \ obtain services without authorization\n   and specifically without paying for\
    \ them.  In order to achieve this\n   objective, the attacker must induce the\
    \ SCTP user application at the\n   target SCTP node to provide the desired service\
    \ while accepting\n   invalid billing data or failing to collect it.  Repudiation\
    \ is a\n   related problem, since it may occur as a deliberate act of fraud or\n\
    \   simply because the repudiating party kept inadequate records of\n   service\
    \ received.\n   Potential fraudulent attacks include interception and misuse of\n\
    \   authorizing information such as credit card numbers, blind masquerade\n  \
    \ and replay, and man-in-the middle attacks which modify the packets\n   passing\
    \ through a target SCTP association in real time.\n   The interception attack\
    \ is countered by the confidentiality measures\n   discussed in Section 11.2.3\
    \ above.\n   Section 11.2.4.2 describes how SCTP is resistant to blind masquerade\n\
    \   attacks, as a result of the four-way startup handshake and the\n   Verification\
    \ Tag.  The Verification Tag and TSN together are\n   protections against blind\
    \ replay attacks, where the replay is into an\n   existing association.\n   However,\
    \ SCTP does not protect against man-in-the-middle attacks\n   where the attacker\
    \ is able to intercept and alter the packets sent\n   and received in an association.\
    \  For example, the INIT ACK will have\n   sufficient information sent on the\
    \ wire for an adversary in the\n   middle to hijack an existing SCTP association.\
    \  Where a significant\n   possibility of such attacks is seen to exist, or where\
    \ possible\n   repudiation is an issue, the use of the IPSEC AH service is\n \
    \  recommended to ensure both the integrity and the authenticity of the\n   SCTP\
    \ packets passed.\n   SCTP also provides no protection against attacks originating\
    \ at or\n   beyond the SCTP node and taking place within the context of an\n \
    \  existing association.  Prevention of such attacks should be covered\n   by\
    \ appropriate security policies at the host site, as discussed in\n   Section\
    \ 11.2.1.\n"
- title: 12. Recommended Transmission Control Block (TCB) Parameters
  contents:
  - "12. Recommended Transmission Control Block (TCB) Parameters\n   This section\
    \ details a recommended set of parameters that should be\n   contained within\
    \ the TCB for an implementation.  This section is for\n   illustrative purposes\
    \ and should not be deemed as requirements on an\n   implementation or as an exhaustive\
    \ list of all parameters inside an\n   SCTP TCB.  Each implementation may need\
    \ its own additional parameters\n   for optimization.\n"
- title: 12.1 Parameters necessary for the SCTP instance
  contents:
  - "12.1 Parameters necessary for the SCTP instance\n   Associations: A list of current\
    \ associations and mappings to the data\n                 consumers for each association.\
    \  This may be in the\n                 form of a hash table or other implementation\
    \ dependent\n                 structure.  The data consumers may be process\n\
    \                 identification information such as file descriptors,\n     \
    \            named pipe pointer, or table pointers dependent on how\n        \
    \         SCTP is implemented.\n   Secret Key:   A secret key used by this endpoint\
    \ to compute the MAC.\n                 This SHOULD be a cryptographic quality\
    \ random number\n                 with a sufficient length.  Discussion in [RFC1750]\
    \ can\n                 be helpful in selection of the key.\n   Address List:\
    \ The list of IP addresses that this instance has bound.\n                 This\
    \ information is passed to one's peer(s) in INIT and\n                 INIT ACK\
    \ chunks.\n   SCTP Port:    The local SCTP port number the endpoint is bound to.\n"
- title: 12.2 Parameters necessary per association (i.e. the TCB)
  contents:
  - "12.2 Parameters necessary per association (i.e. the TCB)\n   Peer        : Tag\
    \ value to be sent in every packet and is received\n   Verification: in the INIT\
    \ or INIT ACK chunk.\n   Tag         :\n   My          : Tag expected in every\
    \ inbound packet and sent in the\n   Verification: INIT or INIT ACK chunk.\n \
    \  Tag         :\n   State       : A state variable indicating what state the\
    \ association\n               : is in, i.e. COOKIE-WAIT, COOKIE-ECHOED, ESTABLISHED,\n\
    \               : SHUTDOWN-PENDING, SHUTDOWN-SENT, SHUTDOWN-RECEIVED,\n      \
    \         : SHUTDOWN-ACK-SENT.\n                 Note: No \"CLOSED\" state is\
    \ illustrated since if a\n                 association is \"CLOSED\" its TCB SHOULD\
    \ be removed.\n   Peer        : A list of SCTP transport addresses that the peer\
    \ is\n   Transport   : bound to.  This information is derived from the INIT or\n\
    \   Address     : INIT ACK and is used to associate an inbound packet\n   List\
    \        : with a given association.  Normally this information is\n         \
    \      : hashed or keyed for quick lookup and access of the TCB.\n   Primary \
    \    : This is the current primary destination transport\n   Path        : address\
    \ of the peer endpoint.  It may also specify a\n               : source transport\
    \ address on this endpoint.\n   Overall     : The overall association error count.\n\
    \   Error Count :\n   Overall     : The threshold for this association that if\
    \ the Overall\n   Error       : Error Count reaches will cause this association\
    \ to be\n   Threshold   : torn down.\n   Peer Rwnd   : Current calculated value\
    \ of the peer's rwnd.\n   Next TSN    : The next TSN number to be assigned to\
    \ a new DATA chunk.\n               : This is sent in the INIT or INIT ACK chunk\
    \ to the peer\n               : and incremented each time a DATA chunk is assigned\
    \ a\n               : TSN (normally just prior to transmit or during\n       \
    \        : fragmentation).\n   Last Rcvd   : This is the last TSN received in\
    \ sequence.  This value\n   TSN         : is set initially by taking the peer's\
    \ Initial TSN,\n               : received in the INIT or INIT ACK chunk, and\n\
    \               : subtracting one from it.\n   Mapping     : An array of bits\
    \ or bytes indicating which out of\n   Array       : order TSN's have been received\
    \ (relative to the\n               : Last Rcvd TSN).  If no gaps exist, i.e. no\
    \ out of order\n               : packets have been received, this array will be\
    \ set to\n               : all zero.  This structure may be in the form of a\n\
    \               : circular buffer or bit array.\n   Ack State   : This flag indicates\
    \ if the next received packet\n               : is to be responded to with a SACK.\
    \  This is initialized\n               : to 0.  When a packet is received it is\
    \ incremented.\n               : If this value reaches 2 or more, a SACK is sent\
    \ and the\n               : value is reset to 0.  Note: This is used only when\
    \ no\n               : DATA chunks are received out of order.  When DATA chunks\n\
    \               : are out of order, SACK's are not delayed (see Section\n    \
    \           : 6).\n   Inbound     : An array of structures to track the inbound\
    \ streams.\n   Streams     : Normally including the next sequence number expected\n\
    \               : and possibly the stream number.\n   Outbound    : An array of\
    \ structures to track the outbound streams.\n   Streams     : Normally including\
    \ the next sequence number to\n               : be sent on the stream.\n   Reasm\
    \ Queue : A re-assembly queue.\n   Local       : The list of local IP addresses\
    \ bound in to this\n   Transport   : association.\n   Address     :\n   List \
    \       :\n   Association : The smallest PMTU discovered for all of the\n   PMTU\
    \        : peer's transport addresses.\n"
- title: 12.3 Per Transport Address Data
  contents:
  - "12.3 Per Transport Address Data\n   For each destination transport address in\
    \ the peer's address list\n   derived from the INIT or INIT ACK chunk, a number\
    \ of data elements\n   needs to be maintained including:\n   Error count : The\
    \ current error count for this destination.\n   Error       : Current error threshold\
    \ for this destination i.e.\n   Threshold   : what value marks the destination\
    \ down if Error count\n               : reaches this value.\n   cwnd        :\
    \ The current congestion window.\n   ssthresh    : The current ssthresh value.\n\
    \   RTO         : The current retransmission timeout value.\n   SRTT        :\
    \ The current smoothed round trip time.\n   RTTVAR      : The current RTT variation.\n\
    \   partial     : The tracking method for increase of cwnd when in\n   bytes acked\
    \ : congestion avoidance mode (see Section 6.2.2)\n   state       : The current\
    \ state of this destination, i.e. DOWN, UP,\n               : ALLOW-HB, NO-HEARTBEAT,\
    \ etc.\n   PMTU        : The current known path MTU.\n   Per         : A timer\
    \ used by each destination.\n   Destination :\n   Timer       :\n   RTO-Pending\
    \ : A flag used to track if one of the DATA chunks sent to\n                 this\
    \ address is currently being used to compute a\n                 RTT.  If this\
    \ flag is 0, the next DATA chunk sent to this\n                 destination should\
    \ be used to compute a RTT and this\n                 flag should be set.  Every\
    \ time the RTT calculation\n                 completes (i.e. the DATA chunk is\
    \ SACK'd) clear this\n                 flag.\n   last-time   : The time this destination\
    \ was last sent to.  This can be\n   used        : used to determine if a HEARTBEAT\
    \ is needed.\n"
- title: 12.4 General Parameters Needed
  contents:
  - "12.4 General Parameters Needed\n   Out Queue   : A queue of outbound DATA chunks.\n\
    \   In Queue    : A queue of inbound DATA chunks.\n"
- title: 13. IANA Considerations
  contents:
  - "13. IANA Considerations\n   This protocol will require port reservation like\
    \ TCP for the use of\n   \"well known\" servers within the Internet.  All current\
    \ TCP ports\n   shall be automatically reserved in the SCTP port address space.\
    \  New\n   requests should follow IANA's current mechanisms for TCP.\n   This\
    \ protocol may also be extended through IANA in three ways:\n    -- through definition\
    \ of additional chunk types,\n    -- through definition of additional parameter\
    \ types, or\n    -- through definition of additional cause codes within\n    \
    \   ERROR chunks\n   In the case where a particular ULP using SCTP desires to\
    \ have its own\n   ports, the ULP should be responsible for registering with IANA\
    \ for\n   getting its ports assigned.\n"
- title: 13.1 IETF-defined Chunk Extension
  contents:
  - "13.1 IETF-defined Chunk Extension\n   The definition and use of new chunk types\
    \ is an integral part of\n   SCTP.  Thus, new chunk types are assigned by IANA\
    \ through an IETF\n   Consensus action as defined in [RFC2434].\n   The documentation\
    \ for a new chunk code type must include the\n   following information:\n   a)\
    \ A long and short name for the new chunk type;\n   b) A detailed description\
    \ of the structure of the chunk, which MUST\n      conform to the basic structure\
    \ defined in Section 3.2;\n   c) A detailed definition and description of intended\
    \ use of each\n      field within the chunk, including the chunk flags if any;\n\
    \   d) A detailed procedural description of the use of the new chunk type\n  \
    \    within the operation of the protocol.\n   The last chunk type (255) is reserved\
    \ for future extension if\n   necessary.\n"
- title: 13.2 IETF-defined Chunk Parameter Extension
  contents:
  - "13.2 IETF-defined Chunk Parameter Extension\n   The assignment of new chunk parameter\
    \ type codes is done through an\n   IETF Consensus action as defined in [RFC2434].\
    \  Documentation of the\n   chunk parameter MUST contain the following information:\n\
    \   a) Name of the parameter type.\n   b) Detailed description of the structure\
    \ of the parameter field.\n      This structure MUST conform to the general type-length-value\n\
    \      format described in Section 3.2.1.\n   c) Detailed definition of each component\
    \ of the parameter value.\n   d) Detailed description of the intended use of this\
    \ parameter type,\n      and an indication of whether and under what circumstances\
    \ multiple\n      instances of this parameter type may be found within the same\n\
    \      chunk.\n"
- title: 13.3 IETF-defined Additional Error Causes
  contents:
  - "13.3 IETF-defined Additional Error Causes\n   Additional cause codes may be allocated\
    \ in the range 11 to 65535\n   through a Specification Required action as defined\
    \ in [RFC2434].\n   Provided documentation must include the following information:\n\
    \   a) Name of the error condition.\n   b) Detailed description of the conditions\
    \ under which an SCTP\n      endpoint should issue an ERROR (or ABORT) with this\
    \ cause code.\n   c) Expected action by the SCTP endpoint which receives an ERROR\
    \ (or\n      ABORT) chunk containing this cause code.\n   d) Detailed description\
    \ of the structure and content of data fields\n      which accompany this cause\
    \ code.\n   The initial word (32 bits) of a cause code parameter MUST conform\
    \ to\n   the format shown in Section 3.3.10, i.e.:\n   -- first two bytes contain\
    \ the cause code value\n   -- last two bytes contain length of the Cause Parameter.\n"
- title: 13.4 Payload Protocol Identifiers
  contents:
  - "13.4 Payload Protocol Identifiers\n   Except for value 0 which is reserved by\
    \ SCTP to indicate an\n   unspecified payload protocol identifier in a DATA chunk,\
    \ SCTP will\n   not be responsible for standardizing or verifying any payload\n\
    \   protocol identifiers; SCTP simply receives the identifier from the\n   upper\
    \ layer and carries it with the corresponding payload data.\n   The upper layer,\
    \ i.e., the SCTP user, SHOULD standardize any specific\n   protocol identifier\
    \ with IANA if it is so desired.  The use of any\n   specific payload protocol\
    \ identifier is out of the scope of SCTP.\n"
- title: 14. Suggested SCTP Protocol Parameter Values
  contents:
  - "14. Suggested SCTP Protocol Parameter Values\n   The following protocol parameters\
    \ are RECOMMENDED:\n   RTO.Initial              - 3  seconds\n   RTO.Min     \
    \             - 1  second\n   RTO.Max                 -  60 seconds\n   RTO.Alpha\
    \                - 1/8\n   RTO.Beta                 - 1/4\n   Valid.Cookie.Life\
    \        - 60  seconds\n   Association.Max.Retrans  - 10 attempts\n   Path.Max.Retrans\
    \         - 5  attempts (per destination address)\n   Max.Init.Retransmits   \
    \  - 8  attempts\n   HB.interval              - 30 seconds\n   IMPLEMENTATION\
    \ NOTE: The SCTP implementation may allow ULP to\n   customize some of these protocol\
    \ parameters (see Section 10).\n   Note: RTO.Min SHOULD be set as recommended\
    \ above.\n"
- title: 15. Acknowledgements
  contents:
  - "15. Acknowledgements\n   The authors wish to thank Mark Allman, R.J. Atkinson,\
    \ Richard Band,\n   Scott Bradner, Steve Bellovin, Peter Butler, Ram Dantu, R.\n\
    \   Ezhirpavai, Mike Fisk, Sally Floyd, Atsushi Fukumoto, Matt Holdrege,\n   Henry\
    \ Houh, Christian Huitema, Gary Lehecka, Jonathan Lee, David\n   Lehmann, John\
    \ Loughney, Daniel Luan, Barry Nagelberg, Thomas Narten,\n   Erik Nordmark, Lyndon\
    \ Ong, Shyamal Prasad, Kelvin Porter, Heinz\n   Prantner, Jarno Rajahalme, Raymond\
    \ E. Reeves, Renee Revis, Ivan Arias\n   Rodriguez, A. Sankar, Greg Sidebottom,\
    \ Brian Wyld, La Monte Yarroll,\n   and many others for their invaluable comments.\n"
- title: 16.  Authors' Addresses
  contents:
  - "16.  Authors' Addresses\n   Randall R. Stewart\n   24 Burning Bush Trail.\n \
    \  Crystal Lake, IL 60012\n   USA\n   Phone: +1-815-477-2127\n   EMail: rrs@cisco.com\n\
    \   Qiaobing Xie\n   Motorola, Inc.\n   1501 W. Shure Drive, #2309\n   Arlington\
    \ Heights, IL 60004\n   USA\n   Phone: +1-847-632-3028\n   EMail: qxie1@email.mot.com\n\
    \   Ken Morneault\n   Cisco Systems Inc.\n   13615 Dulles Technology Drive\n \
    \  Herndon, VA. 20171\n   USA\n   Phone: +1-703-484-3323\n   EMail: kmorneau@cisco.com\n\
    \   Chip Sharp\n   Cisco Systems Inc.\n   7025 Kit Creek Road\n   Research Triangle\
    \ Park, NC  27709\n   USA\n   Phone: +1-919-392-3121\n   EMail: chsharp@cisco.com\n\
    \   Hanns Juergen Schwarzbauer\n   SIEMENS AG\n   Hofmannstr. 51\n   81359 Munich\n\
    \   Germany\n   Phone: +49-89-722-24236\n   EMail: HannsJuergen.Schwarzbauer@icn.siemens.de\n\
    \   Tom Taylor\n   Nortel Networks\n   1852 Lorraine Ave.\n   Ottawa, Ontario\n\
    \   Canada K1H 6Z8\n   Phone: +1-613-736-0961\n   EMail: taylor@nortelnetworks.com\n\
    \   Ian Rytina\n   Ericsson Australia\n   37/360 Elizabeth Street\n   Melbourne,\
    \ Victoria 3000\n   Australia\n   Phone: +61-3-9301-6164\n   EMail: ian.rytina@ericsson.com\n\
    \   Malleswar Kalla\n   Telcordia Technologies\n   3 Corporate Place\n   PYA-2J-341\n\
    \   Piscataway, NJ  08854\n   USA\n   Phone: +1-732-699-3728\n   EMail: mkalla@telcordia.com\n\
    \   Lixia Zhang\n   UCLA Computer Science Department\n   4531G Boelter Hall\n\
    \   Los Angeles, CA 90095-1596\n   USA\n   Phone: +1-310-825-2695\n   EMail: lixia@cs.ucla.edu\n\
    \   Vern Paxson\n   ACIRI\n   1947 Center St., Suite 600,\n   Berkeley, CA 94704-1198\n\
    \   USA\n   Phone: +1-510-666-2882\n   EMail: vern@aciri.org\n"
- title: 17. References
  contents:
  - "17. References\n   [RFC768]   Postel, J. (ed.), \"User Datagram Protocol\", STD\
    \ 6, RFC\n              768, August 1980.\n   [RFC793]   Postel, J. (ed.), \"\
    Transmission Control Protocol\", STD 7,\n              RFC 793, September 1981.\n\
    \   [RFC1123]  Braden, R., \"Requirements for Internet hosts - application\n \
    \             and support\", STD 3, RFC 1123, October 1989.\n   [RFC1191]  Mogul,\
    \ J. and S. Deering, \"Path MTU Discovery\", RFC 1191,\n              November\
    \ 1990.\n   [RFC1700]  Reynolds, J. and J. Postel, \"Assigned Numbers\", STD 2,\
    \ RFC\n              1700, October 1994.\n   [RFC1981]  McCann, J., Deering, S.\
    \ and J. Mogul, \"Path MTU Discovery\n              for IP version 6\", RFC 1981,\
    \ August 1996.\n   [RFC1982]  Elz, R. and R. Bush, \"Serial Number Arithmetic\"\
    , RFC 1982,\n              August 1996.\n   [RFC2026]  Bradner, S., \"The Internet\
    \ Standards Process -- Revision\n              3\", BCP 9, RFC 2026, October 1996.\n\
    \   [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n        \
    \      Requirement Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC2401]  Kent,\
    \ S. and R. Atkinson, \"Security Architecture for the\n              Internet\
    \ Protocol\", RFC 2401,  November 1998.\n   [RFC2402]  Kent, S. and R. Atkinson,\
    \ \"IP Authentication Header\", RFC\n              2402, November 1998.\n   [RFC2406]\
    \  Kent, S. and R. Atkinson, \"IP Encapsulating Security\n              Payload\
    \ (ESP)\", RFC 2406, November 1998.\n   [RFC2408]  Maughan, D., Schertler, M.,\
    \ Schneider, M. and J. Turner,\n              \"Internet Security Association\
    \ and Key Management\n              Protocol\", RFC 2408, November 1998.\n   [RFC2409]\
    \  Harkins, D. and D. Carrel, \"The Internet Key Exchange\n              (IKE)\"\
    , RFC 2409, November 1998.\n   [RFC2434]  Narten, T. and H. Alvestrand, \"Guidelines\
    \ for Writing an\n              IANA Considerations Section in RFCs\", BCP 26,\
    \ RFC 2434,\n              October 1998.\n   [RFC2460]  Deering, S. and R. Hinden,\
    \ \"Internet Protocol, Version 6\n              (IPv6) Specification\", RFC 2460,\
    \ December 1998.\n   [RFC2581]  Allman, M., Paxson, V. and W. Stevens, \"TCP Congestion\n\
    \              Control\", RFC 2581, April 1999.\n"
- title: 18. Bibliography
  contents:
  - "18. Bibliography\n   [ALLMAN99] Allman, M. and Paxson, V., \"On Estimating End-to-End\n\
    \              Network Path Properties\", Proc. SIGCOMM'99, 1999.\n   [FALL96]\
    \   Fall, K. and Floyd, S., Simulation-based Comparisons of\n              Tahoe,\
    \ Reno, and SACK TCP, Computer Communications Review,\n              V. 26 N.\
    \ 3, July 1996, pp. 5-21.\n   [RFC1750]  Eastlake, D. (ed.), \"Randomness Recommendations\
    \ for\n              Security\", RFC 1750, December 1994.\n   [RFC1950]  Deutsch\
    \ P. and J. Gailly, \"ZLIB Compressed Data Format\n              Specification\
    \ version 3.3\", RFC 1950, May 1996.\n   [RFC2104]  Krawczyk, H., Bellare, M.\
    \ and R. Canetti, \"HMAC:  Keyed-\n              Hashing for Message Authentication\"\
    , RFC 2104, March 1997.\n   [RFC2196]  Fraser, B., \"Site Security Handbook\"\
    , FYI 8, RFC 2196,\n              September 1997.\n   [RFC2522]  Karn, P. and\
    \ W. Simpson, \"Photuris: Session-Key Management\n              Protocol\", RFC\
    \ 2522, March 1999.\n   [SAVAGE99] Savage, S., Cardwell, N., Wetherall, D., and\
    \ Anderson, T.,\n              \"TCP Congestion Control with a Misbehaving Receiver\"\
    ,  ACM\n              Computer Communication Review, 29(5), October 1999.\n"
- title: 'Appendix A: Explicit Congestion Notification'
  contents:
  - "Appendix A: Explicit Congestion Notification\n   ECN (Ramakrishnan, K., Floyd,\
    \ S., \"Explicit Congestion Notification\",\n   RFC 2481, January 1999) describes\
    \ a proposed extension to IP that\n   details a method to become aware of congestion\
    \ outside of datagram\n   loss.  This is an optional feature that an implementation\
    \ MAY choose\n   to add to SCTP.  This appendix details the minor differences\n\
    \   implementers will need to be aware of if they choose to implement\n   this\
    \ feature.  In general RFC 2481 should be followed with the\n   following exceptions.\n\
    \   Negotiation:\n   RFC2481 details negotiation of ECN during the SYN and SYN-ACK\
    \ stages\n   of a TCP connection.  The sender of the SYN sets two bits in the\
    \ TCP\n   flags, and the sender of the SYN-ACK sets only 1 bit.  The reasoning\n\
    \   behind this is to assure both sides are truly ECN capable.  For SCTP\n   this\
    \ is not necessary.  To indicate that an endpoint is ECN capable\n   an endpoint\
    \ SHOULD add to the INIT and or INIT ACK chunk the TLV\n   reserved for ECN. \
    \ This TLV contains no parameters, and thus has the\n   following format:\n  \
    \     0                   1                   2                   3\n       0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |   Parameter Type = 32768      |     Parameter Length = 4      |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   ECN-Echo:\n\
    \   RFC 2481 details a specific bit for a receiver to send back in its\n   TCP\
    \ acknowledgements to notify the sender of the Congestion\n   Experienced (CE)\
    \ bit having arrived from the network.  For SCTP this\n   same indication is made\
    \ by including the ECNE chunk.  This chunk\n   contains one data element, i.e.\
    \ the lowest TSN associated with the IP\n   datagram marked with the CE bit, and\
    \ looks as follows:\n       0                   1                   2        \
    \           3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      | Chunk Type=12 | Flags=00000000|    Chunk Length = 8           |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                      Lowest TSN Number                        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Note: The ECNE is considered a Control chunk.\n   CWR:\n   RFC 2481 details\
    \ a specific bit for a sender to send in the header of\n   its next outbound TCP\
    \ segment to indicate to its peer that it has\n   reduced its congestion window.\
    \  This is termed the CWR bit.  For\n   SCTP the same indication is made by including\
    \ the CWR chunk.\n   This chunk contains one data element, i.e. the TSN number\
    \ that\n   was sent in the ECNE chunk.  This element represents the lowest\n \
    \  TSN number in the datagram that was originally marked with the\n   CE bit.\n\
    \       0                   1                   2                   3\n      \
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      | Chunk Type=13 | Flags=00000000|    Chunk Length = 8           |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                      Lowest TSN Number                        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Note: The CWR is considered a Control chunk.\n"
- title: Appendix B Alder 32 bit checksum calculation
  contents:
  - "Appendix B Alder 32 bit checksum calculation\n   The Adler-32 checksum calculation\
    \ given in this appendix is copied from\n   [RFC1950].\n   Adler-32 is composed\
    \ of two sums accumulated per byte: s1 is the sum\n   of all bytes, s2 is the\
    \ sum of all s1 values.  Both sums are done\n   modulo 65521.  s1 is initialized\
    \ to 1, s2 to zero.  The Adler-32\n   checksum is stored as s2*65536 + s1 in network\
    \ byte order.\n   The following C code computes the Adler-32 checksum of a data\
    \ buffer.\n   It is written for clarity, not for speed.  The sample code is in\
    \ the\n   ANSI C programming language.  Non C users may find it easier to read\n\
    \   with these hints:\n   &      Bitwise AND operator.\n   >>     Bitwise right\
    \ shift operator.  When applied to an\n          unsigned quantity, as here, right\
    \ shift inserts zero bit(s)\n          at the left.\n   <<     Bitwise left shift\
    \ operator.  Left shift inserts zero\n          bit(s) at the right.\n   ++  \
    \   \"n++\" increments the variable n.\n   %      modulo operator: a % b is the\
    \ remainder of a divided by b.\n    #define BASE 65521 /* largest prime smaller\
    \ than 65536 */\n    /*\n      Update a running Adler-32 checksum with the bytes\
    \ buf[0..len-1]\n      and return the updated checksum.  The Adler-32 checksum\
    \ should be\n      initialized to 1.\n       Usage example:\n         unsigned\
    \ long adler = 1L;\n         while (read_buffer(buffer, length) != EOF) {\n  \
    \         adler = update_adler32(adler, buffer, length);\n         }\n       \
    \  if (adler != original_adler) error();\n      */\n      unsigned long update_adler32(unsigned\
    \ long adler,\n         unsigned char *buf, int len)\n      {\n        unsigned\
    \ long s1 = adler & 0xffff;\n        unsigned long s2 = (adler >> 16) & 0xffff;\n\
    \        int n;\n        for (n = 0; n < len; n++) {\n          s1 = (s1 + buf[n])\
    \ % BASE;\n          s2 = (s2 + s1)     % BASE;\n        }\n        return (s2\
    \ << 16) + s1;\n      }\n      /* Return the adler32 of the bytes buf[0..len-1]\
    \ */\n      unsigned long adler32(unsigned char *buf, int len)\n      {\n    \
    \    return update_adler32(1L, buf, len);\n      }\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2000).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
