- title: __initial_text__
  contents:
  - '         A More Loss-Tolerant RTP Payload Format for MP3 Audio

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2001).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes a RTP (Real-Time Protocol) payload format\
    \ for\n   transporting MPEG (Moving Picture Experts Group) 1 or 2, layer III\n\
    \   audio (commonly known as \"MP3\").  This format is an alternative to\n   that\
    \ described in RFC 2250, and performs better if there is packet\n   loss.\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   While the RTP payload format defined in RFC 2250 [2] is generally\n\
    \   applicable to all forms of MPEG audio or video, it is sub-optimal for\n  \
    \ MPEG 1 or 2, layer III audio (commonly known as \"MP3\").  The reason\n   for\
    \ this is that an MP3 frame is not a true \"Application Data Unit\" -\n   it contains\
    \ a back-pointer to data in earlier frames, and so cannot\n   be decoded independently\
    \ of these earlier frames.  Because RFC 2250\n   defines that packet boundaries\
    \ coincide with frame boundaries, it\n   handles packet loss inefficiently when\
    \ carrying MP3 data.  The loss\n   of an MP3 frame will render some data in previous\
    \ (or future) frames\n   useless, even if they are received without loss.\n  \
    \ In this document we define an alternative RTP payload format for MP3\n   audio.\
    \  This format uses a data-preserving rearrangement of the\n   original MPEG frames,\
    \ so that packet boundaries now coincide with\n   true MP3 \"Application Data\
    \ Units\", which can also (optionally) be\n   rearranged in an interleaving pattern.\
    \  This new format is therefore\n   more data-efficient than RFC 2250 in the face\
    \ of packet loss.\n"
- title: 2. The Structure of MP3 Frames
  contents:
  - "2. The Structure of MP3 Frames\n   In this section we give a brief overview of\
    \ the structure of a MP3\n   frame.  (For more detailed description, see the MPEG\
    \ 1 audio [3] and\n   MPEG 2 audio [4] specifications.)\n   Each MPEG audio frame\
    \ begins with a 4-byte header.  Information\n   defined by this header includes:\n\
    \   -  Whether the audio is MPEG 1 or MPEG 2.\n   -  Whether the audio is layer\
    \ I, II, or III.\n      (The remainder of this document assumes layer III, i.e.,\
    \ \"MP3\"\n      frames)\n   -  Whether the audio is mono or stereo.\n   -  Whether\
    \ or not there is a 2-byte CRC field following the header.\n   -  (indirectly)\
    \ The size of the frame.\n   The following structures appear after the header:\n\
    \   -  (optionally) A 2-byte CRC field\n   -  A \"side info\" structure.  This\
    \ has the following length:\n      -  32 bytes for MPEG 1 stereo\n      -  17\
    \ bytes for MPEG 1 mono, or for MPEG 2 stereo\n      -  9 bytes for MPEG 2 mono\n\
    \   -  Encoded audio data, plus optional ancillary data (filling out the\n   \
    \   rest of the frame)\n   For the purpose of this document, the \"side info\"\
    \ structure is the\n   most important, because it defines the location and size\
    \ of the\n   \"Application Data Unit\" (ADU) that an MP3 decoder will process.\
    \  In\n   particular, the \"side info\" structure defines:\n   -  \"main_data_begin\"\
    : This is a back-pointer (in bytes) to the start\n      of the ADU.  The back-pointer\
    \ is counted from the beginning of the\n      frame, and counts only encoded audio\
    \ data and any ancillary data\n      (i.e., ignoring any header, CRC, or \"side\
    \ info\" fields).\n   An MP3 decoder processes each ADU independently.  The ADUs\
    \ will\n   generally vary in length, but their average length will, of course,\n\
    \   be that of the of the MP3 frames (minus the length of the header,\n   CRC,\
    \ and \"side info\" fields).  (In MPEG literature, this ADU is\n   sometimes referred\
    \ to as a \"bit reservoir\".)\n"
- title: 3. A New Payload Format
  contents:
  - "3. A New Payload Format\n   As noted in [5], a payload format should be designed\
    \ so that packet\n   boundaries coincide with \"codec frame boundaries\" - i.e.,\
    \ with ADUs.\n   In the RFC 2250 payload format for MPEG audio [2], each RTP packet\n\
    \   payload contains MP3 frames.  In this new payload format for MP3\n   audio,\
    \ however, each RTP packet payload contains \"ADU frames\", each\n   preceded\
    \ by an \"ADU descriptor\".\n"
- title: 3.1 ADU frames
  contents:
  - "3.1 ADU frames\n   An \"ADU frame\" is defined as:\n      -  The 4-byte MPEG\
    \ header\n         (the same as the original MP3 frame, except that the first\
    \ 11\n         bits are (optionally) replaced by an \"Interleaving Sequence\n\
    \         Number\", as described in section 6 below)\n      -  The optional 2-byte\
    \ CRC field\n         (the same as the original MP3 frame)\n      -  The \"side\
    \ info\" structure\n         (the same as the original MP3 frame)\n      -  The\
    \ complete sequence of encoded audio data (and any ancillary\n         data) for\
    \ the ADU (i.e., running from the start of this MP3\n         frame's \"main_data_begin\"\
    \ back-pointer, up to the start of the\n         next MP3 frame's back-pointer)\n"
- title: 3.2 ADU descriptors
  contents:
  - "3.2 ADU descriptors\n   Within each RTP packet payload, each \"ADU frame\" is\
    \ preceded by a 1\n   or 2-byte \"ADU descriptor\", which gives the size of the\
    \ ADU, and\n   indicates whether or not this packet's data is a continuation of\
    \ the\n   previous packet's data.  (This occurs only when a single \"ADU\n   descriptor\"\
    +\"ADU frame\" is too large to fit within a RTP packet.)\n   An ADU descriptor\
    \ consists of the following fields\n   -  \"C\": Continuation flag (1 bit):  1\
    \ if the data following the ADU\n           descriptor is a continuation of an\
    \ ADU frame that was too\n           large to fit within a single RTP packet;\
    \ 0 otherwise.\n   -  \"T\": Descriptor Type flag (1 bit):\n           0 if this\
    \ is a 1-byte ADU descriptor;\n           1 if this is a 2-byte ADU descriptor.\n\
    \   -  \"ADU size\" (6 or 14 bits):\n           The size (in bytes) of the ADU\
    \ frame that will follow this\n           ADU descriptor (i.e., NOT including\
    \ the size of the\n           descriptor itself).  A 2-byte ADU descriptor (with\
    \ a 14-bit\n           \"ADU size\" field) is used for ADU frames sizes of 64\
    \ bytes or\n           more.  For smaller ADU frame sizes, senders MAY alternatively\n\
    \           use a 1-byte ADU descriptor (with a 6-bit \"ADU size\" field).\n \
    \          Receivers MUST be able to accept an ADU descriptor of either\n    \
    \       size.\n   Thus, a 1-byte ADU descriptor is formatted as follows:\n   \
    \       0 1 2 3 4 5 6 7\n         +-+-+-+-+-+-+-+-+\n         |C|0|  ADU size\
    \ |\n         +-+-+-+-+-+-+-+-+\n   and a 2-byte ADU descriptor is formatted as\
    \ follows:\n          0                   1\n          0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5\n         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         |C|1|     ADU\
    \ size (14 bits)    |\n         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 3.3 Packing rules
  contents:
  - "3.3 Packing rules\n   Each RTP packet payload begins with a \"ADU descriptor\"\
    , followed by\n   \"ADU frame\" data.  Normally, this \"ADU descriptor\"+\"ADU\
    \ frame\" will\n   fit completely within the RTP packet.  In this case, more than\
    \ one\n   successive \"ADU descriptor\"+\"ADU frame\" MAY be packed into a single\n\
    \   RTP packet, provided that they all fit completely.\n   If, however, a single\
    \ \"ADU descriptor\"+\"ADU frame\" is too large to\n   fit within an RTP packet,\
    \ then the \"ADU frame\" is split across two or\n   more successive RTP packets.\
    \  Each such packet begins with an ADU\n   descriptor.  The first packet's descriptor\
    \ has a \"C\" (continuation)\n   flag of 0; the following packets' descriptors\
    \ each have a \"C\" flag of\n   1.  Each descriptor, in this case, has the same\
    \ \"ADU size\" value: the\n   size of the entire \"ADU frame\" (not just the portion\
    \ that will fit\n   within a single RTP packet).  Each such packet (even the last\
    \ one)\n   contains only one \"ADU descriptor\".\n"
- title: 3.4 RTP header fields
  contents:
  - "3.4 RTP header fields\n      Payload Type: The (static) payload type 14 that\
    \ was defined for\n         MPEG audio [6] MUST NOT be used.  Instead, a different,\
    \ dynamic\n         payload type MUST be used - i.e., one in the range [96,127].\n\
    \      M bit: This payload format defines no use for this bit.  Senders\n    \
    \     SHOULD set this bit to zero in each outgoing packet.\n      Timestamp: This\
    \ is a 32-bit 90 kHz timestamp, representing the\n         presentation time of\
    \ the first ADU packed within the packet.\n"
- title: 3.5 Handling received data
  contents:
  - "3.5 Handling received data\n   Note that no information is lost by converting\
    \ a sequence of MP3\n   frames to a corresponding sequence of \"ADU frames\",\
    \ so a receiving\n   RTP implementation can either feed the ADU frames directly\
    \ to an\n   appropriately modified MP3 decoder, or convert them back into a\n\
    \   sequence of MP3 frames, as described in appendix A.2 below.\n"
- title: 4. Handling Multiple MPEG Audio Layers
  contents:
  - "4. Handling Multiple MPEG Audio Layers\n   The RTP payload format described here\
    \ is intended only for MPEG 1 or\n   2, layer III audio (\"MP3\").  In contrast,\
    \ layer I and layer II frames\n   are self-contained, without a back-pointer to\
    \ earlier frames.\n   However, it is possible (although unusual) for a sequence\
    \ of audio\n   frames to consist of a mixture of layer III frames and layer I\
    \ or II\n   frames.  When such a sequence is transmitted, only layer III frames\n\
    \   are converted to ADUs; layer I or II frames are sent 'as is' (except\n   for\
    \ the prepending of an \"ADU descriptor\").  Similarly, the receiver\n   of a\
    \ sequence of frames - using this payload format - leaves layer I\n   and II frames\
    \ untouched (after removing the prepended \"ADU\n   descriptor), but converts\
    \ layer III frames from \"ADU frames\" to\n   regular MP3 frames.  (Recall that\
    \ each frame's layer is identified\n   from its 4-byte MPEG header.)\n   If you\
    \ are transmitting a stream consists *only* of layer I or layer\n   II frames\
    \ (i.e., without any MP3 data), then there is no benefit to\n   using this payload\
    \ format, *unless* you are using the interleaving\n   mechanism.\n"
- title: 5. Frame Packetizing and Depacketizing
  contents:
  - "5. Frame Packetizing and Depacketizing\n   The transmission of a sequence of\
    \ MP3 frames takes the following\n   steps:\n         MP3 frames\n           \
    \      -1-> ADU frames\n                     -2-> interleaved ADU frames\n   \
    \                        -3-> RTP packets\n   Step 1, the conversion of a sequence\
    \ of MP3 frames to a corresponding\n   sequence of ADU frames, takes place as\
    \ described in sections 2 and\n   3.1 above.  (Note also the pseudo-code in appendix\
    \ A.1.)\n   Step 2 is the reordering of the sequence of ADU frames in an\n   (optional)\
    \ interleaving pattern, prior to packetization, as described\n   in section 6\
    \ below.  (Note also the pseudo-code in appendix B.1.)\n   Interleaving helps\
    \ reduce the effect of packet loss, by distributing\n   consecutive ADU frames\
    \ over non-consecutive packets.  (Note that\n   because of the back-pointer in\
    \ MP3 frames, interleaving can be\n   applied - in general - only to ADU frames.\
    \  Thus, interleaving was\n   not possible for RFC 2250.)\n   Step 3 is the packetizing\
    \ of a sequence of (interleaved) ADU frames\n   into RTP packets - as described\
    \ in section 3.3 above.  Each packet's\n   RTP timestamp is the presentation time\
    \ of the first ADU that is\n   packed within it.  Note that, if interleaving was\
    \ done in step 2, the\n   RTP timestamps on outgoing packets will not necessarily\
    \ be\n   monotonically nondecreasing.\n   Similarly, a sequence of received RTP\
    \ packets is handled as follows:\n         RTP packets\n               -4-> RTP\
    \ packets ordered by RTP sequence number\n                     -5-> interleaved\
    \ ADU frames\n                           -6-> ADU frames\n                   \
    \              -7-> MP3 frames\n   Step 4 is the usual sorting of incoming RTP\
    \ packets using the RTP\n   sequence number.\n   Step 5 is the depacketizing of\
    \ ADU frames from RTP packets - i.e.,\n   the reverse of step 3.  As part of this\
    \ process, a receiver uses the\n   \"C\" (continuation) flag in the ADU descriptor\
    \ to notice when an ADU\n   frame is split over more than one packet (and to discard\
    \ the ADU\n   frame entirely if one of these packets is lost).\n   Step 6 is the\
    \ rearranging of the sequence of ADU frames back to its\n   original order (except\
    \ for ADU frames missing due to packet loss), as\n   described in section 6 below.\
    \  (Note also the pseudo-code in appendix\n   B.2.)\n   Step 7 is the conversion\
    \ of the sequence of ADU frames into a\n   corresponding sequence of MP3 frames\
    \ - i.e., the reverse of step 1.\n   (Note also the pseudo-code in appendix A.2.)\
    \  With an appropriately\n   modified MP3 decoder, an implementation may omit\
    \ this step; instead,\n   it could feed ADU frames directly to the (modified)\
    \ MP3 decoder.\n"
- title: 6. ADU Frame Interleaving
  contents:
  - "6. ADU Frame Interleaving\n   In MPEG audio frames (MPEG 1 or 2; all layers)\
    \ the high-order 11 bits\n   of the 4-byte MPEG header ('syncword') are always\
    \ all-one (i.e.,\n   0xFFE).  When reordering a sequence of ADU frames for transmission,\n\
    \   we reuse these 11 bits as an \"Interleaving Sequence Number\" (ISN).\n   (Upon\
    \ reception, they are replaced with 0xFFE once again.)\n   The structure of the\
    \ ISN is (a,b), where:\n         - a == bits 0-7:      8-bit Interleave Index\
    \ (within Cycle)\n         - b == bits 8-10:     3-bit Interleave Cycle Count\n\
    \   I.e., the 4-byte MPEG header is reused as follows:\n       0             \
    \      1                   2                   3\n       0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |Interleave Idx |CycCt|   The rest of the original MPEG header  |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Example:\
    \ Consider the following interleave cycle (of size 8):\n            1,3,5,7,0,2,4,6\n\
    \   (This particular pattern has the property that any loss of up to four\n  \
    \ consecutive ADUs in the interleaved stream will lead to a\n   deinterleaved\
    \ stream with no gaps greater than one [7].)  This\n   produces the following\
    \ sequence of ISNs:\n   (1,0) (3,0) (5,0) (7,0) (0,0) (2,0) (4,0) (6,0) (1,1)\
    \ (3,1)\n   (5,1) etc.\n   So, in this example, a sequence of ADU frames\n   f0\
    \ f1 f2 f3 f4 f5 f6 f7 f8 f9 (etc.)\n   would get reordered, in step 2, into:\n\
    \   (1,0)f1 (3,0)f3 (5,0)f5 (7,0)f7 (0,0)f0 (2,0)f2 (4,0)f4 (6,0)f6\n   (1,1)f9\
    \ (3,1)f11 (5,1)f13 (etc.)\n   and the reverse reordering (along with replacement\
    \ of the 0xFFE)\n   would occur upon reception.\n   The reason for breaking the\
    \ ISN into \"Interleave Cycle Count\" and\n   \"Interleave Index\" (rather than\
    \ just treating it as a single 11-bit\n   counter) is to give receivers a way\
    \ of knowing when an ADU frame\n   should be 'released' to the ADU->MP3 conversion\
    \ process (step 7\n   above), rather than waiting for more interleaved ADU frames\
    \ to\n   arrive.  E.g., in the example above, when the receiver sees a frame\n\
    \   with ISN (<something>,1), it knows that it can release all\n   previously-seen\
    \ frames with ISN (<something>,0), even if some other\n   (<something>,0) frames\
    \ remain missing due to packet loss.  A 8-bit\n   Interleave Index allows interleave\
    \ cycles of size up to 256.\n   The choice of an interleaving order can be made\
    \ independently of RTP\n   packetization.  Thus, a simple implementation could\
    \ choose an\n   interleaving order first, reorder the ADU frames accordingly (step\n\
    \   2), then simply pack them sequentially into RTP packets (step 3).\n   However,\
    \ the size of ADU frames - and thus the number of ADU frames\n   that will fit\
    \ in each RTP packet - will typically vary in size, so a\n   more optimal implementation\
    \ would combine steps 2 and 3, by choosing\n   an interleaving order that better\
    \ reflected the number of ADU frames\n   packed within each RTP packet.\n   Each\
    \ receiving implementation of this payload format MUST recognize\n   the ISN and\
    \ be able to perform deinterleaving of incoming ADU frames\n   (step 6).  However,\
    \ a sending implementation of this payload format\n   MAY choose not to perform\
    \ interleaving - i.e., by omitting step 2.\n   In this case, the high-order 11\
    \ bits in each 4-byte MPEG header would\n   remain at 0xFFE.  Receiving implementations\
    \ would thus see a sequence\n   of identical ISNs (all 0xFFE).  They would handle\
    \ this in the same\n   way as if the Interleave Cycle Count changed with each\
    \ ADU frame, by\n   simply releasing the sequence of incoming ADU frames sequentially\
    \ to\n   the ADU->MP3 conversion process (step 7), without reordering.  (Note\n\
    \   also the pseudo-code in appendix B.2.)\n"
- title: 7. MIME registration
  contents:
  - "7. MIME registration\n      MIME media type name: audio\n      MIME subtype:\
    \ mpa-robust\n      Required parameters: none\n      Optional parameters: none\n\
    \      Encoding considerations:\n         This type is defined only for transfer\
    \ via RTP as specified in\n         \"RFC 3119\".\n      Security considerations:\n\
    \         See the \"Security Considerations\" section of\n         \"RFC 3119\"\
    .\n      Interoperability considerations:\n         This encoding is incompatible\
    \ with both the \"audio/mpa\"\n         and \"audio/mpeg\" mime types.\n     \
    \ Published specification:\n         The ISO/IEC MPEG-1 [3] and MPEG-2 [4] audio\
    \ specifications,\n         and \"RFC 3119\".\n      Applications which use this\
    \ media type:\n         Audio streaming tools (transmitting and receiving)\n \
    \     Additional information: none\n      Person & email address to contact for\
    \ further information:\n         Ross Finlayson\n         finlayson@live.com\n\
    \      Intended usage: COMMON\n      Author/Change controller:\n         Author:\
    \ Ross Finlayson\n         Change controller: IETF AVT Working Group\n"
- title: 8. SDP usage
  contents:
  - "8. SDP usage\n   When conveying information by SDP [8], the encoding name SHALL\
    \ be\n   \"mp3\" (the same as the MIME subtype).  An example of the media\n  \
    \ representation in SDP is:\n         m=audio 49000 RTP/AVP 121\n         a=rtpmap:121\
    \ mpa-robust/90000\n"
- title: 9. Security Considerations
  contents:
  - "9. Security Considerations\n   If a session using this payload format is being\
    \ encrypted, and\n   interleaving is being used, then the sender SHOULD ensure\
    \ that any\n   change of encryption key coincides with a start of a new interleave\n\
    \   cycle.  Apart from this, the security considerations for this payload\n  \
    \ format are identical to those noted for RFC 2250 [2].\n"
- title: 10. Acknowledgements
  contents:
  - "10. Acknowledgements\n   The suggestion of adding an interleaving option (using\
    \ the first bits\n   of the MPEG 'syncword' - which would otherwise be all-ones\
    \ - as an\n   interleaving index) is due to Dave Singer and Stefan Gewinner. \
    \ In\n   addition, Dave Singer provided valuable feedback that helped clarify\n\
    \   and improve the description of this payload format.  Feedback from\n   Chris\
    \ Sloan led to the addition of an \"ADU descriptor\" preceding each\n   ADU frame\
    \ in the RTP packet.\n"
- title: 11. References
  contents:
  - "11. References\n   [1] Bradner, S., \"Key words for use in RFCs to Indicate Requirement\n\
    \       Levels\", BCP 14, RFC 2119, March 1997.\n   [2] Hoffman, D., Fernando,\
    \ G., Goyal, V. and M. Civanlar, \"RTP\n       Payload Format for MPEG1/MPEG2\
    \ Video\", RFC 2250, January 1998.\n   [3] ISO/IEC International Standard 11172-3;\
    \ \"Coding of moving\n       pictures and associated audio for digital storage\
    \ media up to\n       about 1,5 Mbits/s - Part 3: Audio\", 1993.\n   [4] ISO/IEC\
    \ International Standard 13818-3; \"Generic coding of moving\n       pictures\
    \ and associated audio information - Part 3: Audio\", 1998.\n   [5] Handley, M.,\
    \ \"Guidelines for Writers of RTP Payload Format\n       Specifications\", BCP\
    \ 36, RFC 2736, December 1999.\n   [6] Schulzrinne, H., \"RTP Profile for Audio\
    \ and Video Conferences\n       with Minimal Control\", RFC 1890, January 1996.\n\
    \   [7] Marshall Eubanks, personal communication, December 2000.\n   [8] Handley,\
    \ M. and V. Jacobson, \"SDP: Session Description Protocol\",\n       RFC 2327,\
    \ April 1998.\n"
- title: 11. Author's Address
  contents:
  - "11. Author's Address\n   Ross Finlayson,\n   Live Networks, Inc. (LIVE.COM)\n\
    \   EMail: finlayson@live.com\n   WWW: http://www.live.com/\n"
- title: Appendix A. Translating Between "MP3 Frames" and "ADU Frames"
  contents:
  - "Appendix A. Translating Between \"MP3 Frames\" and \"ADU Frames\"\n   The following\
    \ 'pseudo code' describes how a sender using this payload\n   format can translate\
    \ a sequence of regular \"MP3 Frames\" to \"ADU\n   Frames\", and how a receiver\
    \ can perform the reverse translation: from\n   \"ADU Frames\" to \"MP3 Frames\"\
    .\n   We first define the following abstract data structures:\n   -  \"Segment\"\
    : A record that represents either a \"MP3 Frame\" or an\n      \"ADU Frame\".\
    \  It consists of the following fields:\n      -  \"header\": the 4-byte MPEG\
    \ header\n      -  \"headerSize\": a constant (== 4)\n      -  \"sideInfo\": the\
    \ 'side info' structure, *including* the optional\n         2-byte CRC field,\
    \ if present\n      -  \"sideInfoSize\": the size (in bytes) of the above structure\n\
    \      -  \"frameData\": the remaining data in this frame\n      -  \"frameDataSize\"\
    : the size (in bytes) of the above data\n      -  \"backpointer\": the size (in\
    \ bytes) of the backpointer for this\n         frame\n      -  \"aduDataSize\"\
    : the size (in bytes) of the ADU associated with\n         this frame.  (If the\
    \ frame is already an \"ADU Frame\", then\n         aduDataSize == frameDataSize)\n\
    \      -  \"mp3FrameSize\": the total size (in bytes) that this frame would\n\
    \         have if it were a regular \"MP3 Frame\".  (If it is already a\n    \
    \     \"MP3 Frame\", then mp3FrameSize == headerSize + sideInfoSize +\n      \
    \   frameDataSize) Note that this size can be derived completely\n         from\
    \ \"header\".\n   -  \"SegmentQueue\": A FIFO queue of \"Segment\"s, with operations\n\
    \      -  void enqueue(Segment)\n      -  Segment dequeue()\n      -  Boolean\
    \ isEmpty()\n      -  Segment head()\n      -  Segment tail()\n      -  Segment\
    \ previous(Segment):  returns the segment prior to a\n         given one\n   \
    \   -  Segment next(Segment): returns the segment after a given one\n      - \
    \ unsigned totalDataSize(): returns the sum of the\n         \"frameDataSize\"\
    \ fields of each entry in the queue\n"
- title: 'A.1 Converting a sequence of "MP3 Frames" to a sequence of "ADU Frames":'
  contents:
  - 'A.1 Converting a sequence of "MP3 Frames" to a sequence of "ADU Frames":

    '
- title: SegmentQueue pendingMP3Frames; // initially empty
  contents:
  - 'SegmentQueue pendingMP3Frames; // initially empty

    '
- title: while (1) {
  contents:
  - "while (1) {\n        // Enqueue new MP3 Frames, until we have enough data to\
    \ generate\n        // the ADU for a frame:\n        do {\n                int\
    \ totalDataSizeBefore\n                        = pendingMP3Frames.totalDataSize();\n\
    \                Segment newFrame = 'the next MP3 Frame';\n                pendingMP3Frames.enqueue(newFrame);\n\
    \                int totalDataSizeAfter\n                        = pendingMP3Frames.totalDataSize();\n\
    \        } while (totalDataSizeBefore < newFrame.backpointer ||\n            \
    \      totalDataSizeAfter < newFrame.aduDataSize);\n        // We now have enough\
    \ data to generate the ADU for the most\n        // recently enqueued frame (i.e.,\
    \ the tail of the queue).\n        // (The earlier frames in the queue - if any\
    \ - must be\n        // discarded, as we don't have enough data to generate\n\
    \        // their ADUs.)\n        Segment tailFrame = pendingMP3Frames.tail();\n\
    \        // Output the header and side info:\n        output(tailFrame.header);\n\
    \        output(tailFrame.sideInfo);\n        // Go back to the frame that contains\
    \ the start of our ADU data:\n        int offset = 0;\n        Segment curFrame\
    \ = tailFrame;\n        int prevBytes = tailFrame.backpointer;\n        while\
    \ (prevBytes > 0) {\n                curFrame = pendingMP3Frames.previous(curFrame);\n\
    \                int dataHere = curFrame.frameDataSize;\n                if (dataHere\
    \ < prevBytes) {\n                        prevBytes -= dataHere;\n           \
    \     } else {\n                        offset = dataHere - prevBytes;\n     \
    \                   break;\n                }\n        }\n        // Dequeue any\
    \ frames that we no longer need:\n        while (pendingMP3Frames.head() != curFrame)\
    \ {\n                pendingMP3Frames.dequeue();\n        }\n        // Output,\
    \ from the remaining frames, the ADU data that we want:\n        int bytesToUse\
    \ = tailFrame.aduDataSize;\n        while (bytesToUse > 0) {\n               \
    \ int dataHere = curFrame.frameDataSize - offset;\n                int bytesUsedHere\n\
    \                        = dataHere < bytesToUse ? dataHere : bytesToUse;\n  \
    \              output(\"bytesUsedHere\" bytes from curFrame.frameData,\n     \
    \                   starting from \"offset\");\n                bytesToUse -=\
    \ bytesUsedHere;\n                offset = 0;\n                curFrame = pendingMP3Frames.next(curFrame);\n\
    \        }\n"
- title: '}'
  contents:
  - '}

    '
- title: 'A.2 Converting a sequence of "ADU Frames" to a sequence of "MP3 Frames":'
  contents:
  - 'A.2 Converting a sequence of "ADU Frames" to a sequence of "MP3 Frames":

    '
- title: SegmentQueue pendingADUFrames; // initially empty
  contents:
  - 'SegmentQueue pendingADUFrames; // initially empty

    '
- title: while (1) {
  contents:
  - "while (1) {\n        while (needToGetAnADU()) {\n                Segment newADU\
    \ = 'the next ADU Frame';\n                pendingADUFrames.enqueue(newADU);\n\
    \                insertDummyADUsIfNecessary();\n        }\n        generateFrameFromHeadADU();\n"
- title: '}'
  contents:
  - '}

    '
- title: Boolean needToGetAnADU() {
  contents:
  - "Boolean needToGetAnADU() {\n        // Checks whether we need to enqueue one\
    \ or more new ADUs before\n        // we have enough data to generate a frame\
    \ for the head ADU.\n        Boolean needToEnqueue = True;\n        if (!pendingADUFrames.isEmpty())\
    \ {\n                Segment curADU = pendingADUFrames.head();\n             \
    \   int endOfHeadFrame = curADU.mp3FrameSize\n                        - curADU.headerSize\
    \ - curADU.sideInfoSize;\n                int frameOffset = 0;\n             \
    \   while (1) {\n                        int endOfData = frameOffset\n       \
    \                         - curADU.backpointer +\n                           \
    \       curADU.aduDataSize;\n                        if (endOfData >= endOfHeadFrame)\
    \ {\n                                // We have enough data to generate a\n  \
    \                              // frame.\n                                needToEnqueue\
    \ = False;\n                                break;\n                        }\n\
    \                        frameOffset += curADU.mp3FrameSize\n                \
    \                - curADU.headerSize\n                                - curADU.sideInfoSize;\n\
    \                        if (curADU == pendingADUFrames.tail()) break;\n     \
    \                   curADU = pendingADUFrames.next(curADU);\n                }\n\
    \        }\n    return needToEnqueue;\n"
- title: '}'
  contents:
  - '}

    '
- title: void generateFrameFromHeadADU() {
  contents:
  - "void generateFrameFromHeadADU() {\n        Segment curADU = pendingADUFrames.head();\n\
    \        // Output the header and side info:\n        output(curADU.header);\n\
    \        output(curADU.sideInfo);\n        // Begin by zeroing out the rest of\
    \ the frame, in case the ADU\n        // data doesn't fill it in completely:\n\
    \        int endOfHeadFrame = curADU.mp3FrameSize\n                - curADU.headerSize\
    \ - curADU.sideInfoSize;\n        output(\"endOfHeadFrame\" zero bytes);\n   \
    \     // Fill in the frame with appropriate ADU data from this and\n        //\
    \ subsequent ADUs:\n        int frameOffset = 0;\n        int toOffset = 0;\n\
    \        while (toOffset < endOfHeadFrame) {\n                int startOfData\
    \ = frameOffset - curADU.backpointer;\n                if (startOfData > endOfHeadFrame)\
    \ {\n                        break; // no more ADUs are needed\n             \
    \   }\n                int endOfData = startOfData + curADU.aduDataSize;\n   \
    \             if (endOfData > endOfHeadFrame) {\n                        endOfData\
    \ = endOfHeadFrame;\n                }\n                int fromOffset;\n    \
    \            if (startOfData <= toOffset) {\n                        fromOffset\
    \ = toOffset - startOfData;\n                        startOfData = toOffset;\n\
    \                        if (endOfData < startOfData) {\n                    \
    \            endOfData = startOfData;\n                        }\n           \
    \     } else {\n                        fromOffset = 0;\n                    \
    \    // leave some zero bytes beforehand:\n                        toOffset =\
    \ startOfData;\n                }\n                int bytesUsedHere = endOfData\
    \ - startOfData;\n                output(starting at offset \"toOffset, \"bytesUsedHere\"\
    \n                        bytes from \"&curADU.frameData[fromOffset]\");\n   \
    \             toOffset += bytesUsedHere;\n                frameOffset += curADU.mp3FrameSize\n\
    \                        - curADU.headerSize - curADU.sideInfoSize;\n        \
    \        curADU = pendingADUFrames.next(curADU);\n        }\n        pendingADUFrames.dequeue();\n"
- title: '}'
  contents:
  - '}

    '
- title: void insertDummyADUsIfNecessary() {
  contents:
  - "void insertDummyADUsIfNecessary() {\n        // The tail segment (ADU) is assumed\
    \ to have been recently\n        // enqueued.  If its backpointer would overlap\
    \ the data\n        // of the previous ADU, then we need to insert one or more\n\
    \        // empty, 'dummy' ADUs ahead of it.  (This situation should\n       \
    \ // occur only if an intermediate ADU was missing - e.g., due\n        // to\
    \ packet loss.)\n        while (1) {\n                Segment tailADU = pendingADUFrames.tail();\n\
    \                int prevADUend; // relative to the start of the tail ADU\n  \
    \              if (pendingADUFrames.head() != tailADU) {\n                   \
    \     // there is a previous ADU\n                        Segment prevADU\n  \
    \                              = pendingADUFrames.previous(tailADU);\n       \
    \                 prevADUend\n                                = prevADU.mp3FrameSize\
    \ +\n                                  prevADU.backpointer\n                 \
    \                 - prevADU.headerSize\n                                  - curADU.sideInfoSize;\n\
    \                        if (prevADU.aduDataSize > prevADUend) {\n           \
    \                     // this shouldn't happen if the previous\n             \
    \                   // ADU was well-formed\n                                prevADUend\
    \ = 0;\n                        } else {\n                                prevADUend\
    \ -= prevADU.aduDataSize;\n                        }\n                } else {\n\
    \                        prevADUend = 0;\n                }\n                if\
    \ (tailADU.backpointer > prevADUend) {\n                        // Insert a 'dummy'\
    \ ADU in front of the tail.\n                        // This ADU can have the\
    \ same \"header\" (and thus\n                        // \"mp3FrameSize\") as the\
    \ tail ADU, but should\n                        // have an \"aduDataSize\" of\
    \ zero.  The simplest\n                        // way to do this is to copy the\
    \ \"sideInfo\" from\n                        // the tail ADU, and zero out the\n\
    \                        // \"main_data_begin\" and all of the\n             \
    \           // \"part2_3_length\" fields.\n                } else {\n        \
    \                break; // no more dummy ADUs need to be inserted\n          \
    \      }\n        }\n"
- title: '}'
  contents:
  - '}

    '
- title: 'Appendix B: Interleaving and Deinterleaving'
  contents:
  - "Appendix B: Interleaving and Deinterleaving\n   The following 'pseudo code' describes\
    \ how a sender can reorder a\n   sequence of \"ADU Frames\" according to an interleaving\
    \ pattern (step\n   2), and how a receiver can perform the reverse reordering\
    \ (step 6).\n"
- title: 'B.1 Interleaving a sequence of "ADU Frames":'
  contents:
  - "B.1 Interleaving a sequence of \"ADU Frames\":\n   We first define the following\
    \ abstract data structures:\n   -  \"interleaveCycleSize\": an integer in the\
    \ range [1,256] -\n      \"interleaveCycle\": an array, of size \"interleaveCycleSize\"\
    ,\n      containing some permutation of the integers from the set [0 ..\n    \
    \  interleaveCycleSize-1]\n      e.g., if \"interleaveCycleSize\" == 8, \"interleaveCycle\"\
    \ might\n      contain: 1,3,5,7,0,2,4,6\n   -  \"inverseInterleaveCycle\": an\
    \ array containing the inverse of the\n      permutation in \"interleaveCycle\"\
    \ - i.e., such that\n      interleaveCycle[inverseInterleaveCycle[i]] == i\n \
    \  -  \"ii\": the current Interleave Index (initially 0)\n   -  \"icc\": the current\
    \ Interleave Cycle Count (initially 0)\n   -  \"aduFrameBuffer\": an array, of\
    \ size \"interleaveCycleSize\", of ADU\n      Frames that are awaiting packetization\n"
- title: while (1) {
  contents:
  - "while (1) {\n        int positionOfNextFrame = inverseInterleaveCycle[ii];\n\
    \        aduFrameBuffer[positionOfNextFrame] = the next ADU frame;\n        replace\
    \ the high-order 11 bits of this frame's MPEG header\n            with (ii,icc);\n\
    \                // Note: Be sure to leave the remaining 21 bits as is\n     \
    \   if (++ii == interleaveCycleSize) {\n                // We've finished this\
    \ cycle, so pass all\n                // pending frames to the packetizing step\n\
    \                for (int i = 0; i < interleaveCycleSize; ++i) {\n           \
    \             pass aduFrameBuffer[i] to the packetizing step;\n              \
    \  }\n                ii = 0;\n                icc = (icc+1)%8;\n        }\n"
- title: '}'
  contents:
  - '}

    '
- title: 'B.2 Deinterleaving a sequence of (interleaved) "ADU Frames":'
  contents:
  - "B.2 Deinterleaving a sequence of (interleaved) \"ADU Frames\":\n   We first define\
    \ the following abstract data structures:\n   -  \"ii\": the Interleave Index\
    \ from the current incoming ADU frame\n   -  \"icc\": the Interleave Cycle Count\
    \ from the current incoming ADU\n      frame\n   -  \"iiLastSeen\": the most recently\
    \ seen Interleave Index (initially,\n      some integer *not* in the range [0,255])\n\
    \   -  \"iccLastSeen\": the most recently seen Interleave Cycle Count\n      (initially,\
    \ some integer *not* in the range [0,7])\n   -  \"aduFrameBuffer\": an array,\
    \ of size 32, of (pointers to) ADU\n      Frames that have just been depacketized\
    \ (initially, all entries\n      are NULL)\n"
- title: while (1) {
  contents:
  - "while (1) {\n        aduFrame = the next ADU frame from the depacketizing step;\n\
    \        (ii,icc) = \"the high-order 11 bits of aduFrame's MPEG header\";\n  \
    \      \"the high-order 11 bits of aduFrame's MPEG header\" = 0xFFE;\n       \
    \         // Note: Be sure to leave the remaining 21 bits as is\n        if (icc\
    \ != iccLastSeen || ii == iiLastSeen) {\n                // We've started a new\
    \ interleave cycle\n                // (or interleaving was not used).  Release\
    \ all\n                // pending ADU frames to the ADU->MP3 conversion step:\n\
    \                for (int i = 0; i < 32; ++i) {\n                        if (aduFrameBuffer[i]\
    \ != NULL) {\n                                release aduFrameBuffer[i];\n   \
    \                             aduFrameBuffer[i] = NULL;\n                    \
    \    }\n                }\n        }\n        iiLastSeen = ii;\n        iccLastSeen\
    \ = icc;\n        aduFrameBuffer[ii] = aduFrame;\n"
- title: '}'
  contents:
  - '}

    '
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2001).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
