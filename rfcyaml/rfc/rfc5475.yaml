- contents:
  - '       Sampling and Filtering Techniques for IP Packet Selection

    '
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2009 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents
    in effect on the date of\n   publication of this document (http://trustee.ietf.org/license-info).\n
    \  Please review these documents carefully, as they describe your rights\n   and
    restrictions with respect to this document.\n   This document may contain material
    from IETF Documents or IETF\n   Contributions published or made publicly available
    before November\n   10, 2008.  The person(s) controlling the copyright in some
    of this\n   material may not have granted the IETF Trust the right to allow\n
    \  modifications of such material outside the IETF Standards Process.\n   Without
    obtaining an adequate license from the person(s) controlling\n   the copyright
    in such materials, this document may not be modified\n   outside the IETF Standards
    Process, and derivative works of it may\n   not be created outside the IETF Standards
    Process, except to format\n   it for publication as an RFC or to translate it
    into languages other\n   than English.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document describes Sampling and Filtering techniques for IP\n
    \  packet selection.  It provides a categorization of schemes and\n   defines
    what parameters are needed to describe the most common\n   selection schemes.
    \ Furthermore, it shows how techniques can be\n   combined to build more elaborate
    packet Selectors.  The document\n   provides the basis for the definition of information
    models for\n   configuring selection techniques in Metering Processes and for\n
    \  reporting the technique in use to a Collector.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n
    \     1.1. Conventions Used in This Document ..........................4\n   2.
    PSAMP Documents Overview ........................................4\n   3. Terminology
    .....................................................4\n      3.1. Observation
    Points, Packet Streams, and Packet Content .....4\n      3.2. Selection Process
    ..........................................5\n      3.3. Reporting ..................................................7\n
    \     3.4. Metering Process ...........................................7\n      3.5.
    Exporting Process ..........................................8\n      3.6. PSAMP
    Device ...............................................8\n      3.7. Collector
    ..................................................8\n      3.8. Selection Methods
    ..........................................8\n   4. Categorization of Packet Selection
    Techniques ..................11\n   5. Sampling .......................................................12\n
    \     5.1. Systematic Sampling .......................................13\n      5.2.
    Random Sampling ...........................................14\n           5.2.1.
    n-out-of-N Sampling ................................14\n           5.2.2. Probabilistic
    Sampling .............................14\n   6. Filtering ......................................................16\n
    \     6.1. Property Match Filtering ..................................16\n      6.2.
    Hash-Based Filtering ......................................19\n           6.2.1.
    Application Examples for Coordinated Packet\n                  Selection ..........................................19\n
    \          6.2.2. Desired Properties of Hash Functions ...............21\n           6.2.3.
    Security Considerations for Hash Functions .........22\n           6.2.4. Choice
    of Hash Function ............................26\n   7. Parameters for the Description
    of Selection Techniques .........29\n      7.1. Description of Sampling Techniques
    ........................30\n      7.2. Description of Filtering Techniques .......................31\n
    \  8. Composite Techniques ...........................................34\n      8.1.
    Cascaded Filtering->Sampling or Sampling->Filtering .......34\n      8.2. Stratified
    Sampling .......................................34\n   9. Security Considerations
    ........................................35\n   10. Contributors ..................................................36\n
    \  11. Acknowledgments ...............................................36\n   12.
    References ....................................................36\n      12.1.
    Normative References .....................................36\n      12.2. Informative
    References ...................................36\n   Appendix A. Hash Functions
    ........................................40\n   A.1 IP Shift-XOR (IPSX) Hash Function..............................40\n
    \  A.2 BOB Hash Function..............................................41\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   There are two main drivers for the evolution in measurement\n
    \  infrastructures and their underlying technology.  First, network data\n   rates
    are increasing, with a concomitant growth in measurement data.\n   Second, the
    growth is compounded by the demand of measurement-based\n   applications for increasingly
    fine-grained traffic measurements.\n   Devices that perform the measurements,
    require increasingly\n   sophisticated and resource-intensive measurement capabilities,\n
    \  including the capture of packet headers or even parts of the payload,\n   and
    classification for flow analysis.  All these factors can lead to\n   an overwhelming
    amount of measurement data, resulting in high demands\n   on resources for measurement,
    storage, transfer, and post processing.\n   The sustained capture of network traffic
    at line rate can be\n   performed by specialized measurement hardware.  However,
    the cost of\n   the hardware and the measurement infrastructure required to\n
    \  accommodate the measurements preclude this as a ubiquitous approach.\n   Instead,
    some form of data reduction at the point of measurement is\n   necessary.\n   This
    can be achieved by an intelligent packet selection through\n   Sampling or Filtering.
    \ Another way to reduce the amount of data is\n   to use aggregation techniques
    (not addressed in this document).  The\n   motivation for Sampling is to select
    a representative subset of\n   packets that allow accurate estimates of properties
    of the unsampled\n   traffic to be formed.  The motivation for Filtering is to
    remove all\n   packets that are not of interest.  Aggregation combines data and\n
    \  allows compact pre-defined views of the traffic.  Examples of\n   applications
    that benefit from packet selection are given in\n   [RFC5474].  Aggregation techniques
    are out of scope of this document.\n"
  - contents:
    - "1.1.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST
      NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\",
      \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted
      as described in RFC 2119 [RFC2119].\n"
    title: 1.1.  Conventions Used in This Document
  title: 1.  Introduction
- contents:
  - "2.  PSAMP Documents Overview\n   This document is one out of a series of documents
    from the PSAMP\n   group.\n   [RFC5474]: \"A Framework for Packet Selection and
    Reporting\" describes\n   the PSAMP framework for network elements to select subsets
    of packets\n   by statistical and other methods, and to export a stream of reports\n
    \  on the selected packets to a Collector.\n   RFC 5475 (this document): \"Sampling
    and Filtering Techniques for IP\n   Packet Selection\" describes the set of packet
    selection techniques\n   supported by PSAMP.\n   [RFC5476]: \"Packet Sampling
    (PSAMP) Protocol Specifications\"\n   specifies the export of packet information
    from a PSAMP Exporting\n   Process to a PSAMP Collecting Process.\n   [RFC5477]:
    \"Information Model for Packet Sampling Exports\" defines an\n   information and
    data model for PSAMP.\n"
  title: 2.  PSAMP Documents Overview
- contents:
  - "3.  Terminology\n   The PSAMP terminology defined here is fully consistent with
    all terms\n   listed in [RFC5474] but includes additional terms required for the\n
    \  description of packet selection methods.  An architecture overview\n   and
    possible configurations of PSAMP elements can be found in\n   [RFC5474].  PSAMP
    terminology also aims at consistency with terms\n   used in [RFC3917].  The relationship
    between PSAMP and IPFIX terms is\n   described in [RFC5474].\n   In the PSAMP
    documents, all defined PSAMP terms are written\n   capitalized.  This document
    uses the same convention.\n"
  - contents:
    - "3.1.  Observation Points, Packet Streams, and Packet Content\n   * Observation
      Point\n      An Observation Point [RFC5101] is a location in the network where\n
      \     packets can be observed.  Examples include:\n         (i)  A line to which
      a probe is attached;\n        (ii) a shared medium, such as an Ethernet-based
      LAN;\n       (iii) a single port of a router, or set of interfaces (physical\n
      \            or logical) of a router;\n        (iv) an embedded measurement
      subsystem within an interface.\n      Note that one Observation Point may be
      a superset of several other\n      Observation Points.  For example, one Observation
      Point can be an\n      entire line card.  This would be the superset of the
      individual\n      Observation Points at the line card's interfaces.\n   * Observed
      Packet Stream\n      The Observed Packet Stream is the set of all packets observed
      at\n      the Observation Point.\n   * Packet Stream\n      A Packet Stream
      denotes a set of packets from the Observed Packet\n      Stream that flows past
      some specified point within the Metering\n      Process.  An example of a Packet
      Stream is the output of the\n      selection process.  Note that packets selected
      from a stream,\n      e.g., by Sampling, do not necessarily possess a property
      by which\n      they can be distinguished from packets that have not been\n
      \     selected.  For this reason, the term \"stream\" is favored over\n      \"flow\",
      which is defined as a set of packets with common\n      properties [RFC3917].\n
      \  * Packet Content\n      The Packet Content denotes the union of the packet
      header (which\n      includes link layer, network layer, and other encapsulation\n
      \     headers) and the packet payload.  At some Observation Points, the\n      link
      header information may not be available.\n"
    title: 3.1.  Observation Points, Packet Streams, and Packet Content
  - contents:
    - "3.2.  Selection Process\n   * Selection Process\n      A Selection Process
      takes the Observed Packet Stream as its input\n      and selects a subset of
      that stream as its output.\n   * Selection State\n      A Selection Process
      may maintain state information for use by the\n      Selection Process.  At
      a given time, the Selection State may\n      depend on packets observed at and
      before that time, and other\n      variables.  Examples include:\n         (i)
      sequence numbers of packets at the input of Selectors;\n        (ii) a timestamp
      of observation of the packet at the Observation\n             Point;\n       (iii)
      iterators for pseudorandom number generators;\n        (iv) hash values calculated
      during selection;\n         (v) indicators of whether the packet was selected
      by a given\n             Selector.\n      Selection Processes may change portions
      of the Selection State as\n      a result of processing a packet.  Selection
      State for a packet is\n      to reflect the state after processing the packet.\n
      \  * Selector\n      A Selector defines what kind of action a Selection Process\n
      \     performs on a single packet of its input.  If selected, the packet\n      becomes
      an element of the output Packet Stream.\n      The Selector can make use of
      the following information in\n      determining whether a packet is selected:\n
      \        (i) the Packet Content;\n        (ii) information derived from the
      packet's treatment at the\n             Observation Point;\n       (iii) any
      Selection State that may be maintained by the Selection\n             Process.\n
      \  * Composite Selector\n      A Composite Selector is an ordered composition
      of Selectors, in\n      which the output Packet Stream issuing from one Selector
      forms the\n      input Packet Stream to the succeeding Selector.\n   * Primitive
      Selector\n      A Selector is primitive if it is not a Composite Selector.\n
      \  * Selection Sequence\n      From all the packets observed at an Observation
      Point, only a few\n      packets are selected by one or more Selectors.  The
      Selection\n      Sequence is a unique value per Observation Domain describing
      the\n      Observation Point and the Selector IDs through which the packets\n
      \     are selected.\n"
    title: 3.2.  Selection Process
  - contents:
    - "3.3.  Reporting\n   * Packet Reports\n      Packet Reports comprise a configurable
      subset of a packet's input\n      to the Selection Process, including the Packet's
      Content,\n      information relating to its treatment (for example, the output\n
      \     interface), and its associated Selection State (for example, a\n      hash
      of the Packet's Content).\n   * Report Interpretation\n      Report Interpretation
      comprises subsidiary information, relating\n      to one or more packets, that
      is used for interpretation of their\n      Packet Reports.  Examples include
      configuration parameters of the\n      Selection Process.\n   * Report Stream\n
      \     The Report Stream is the output of a Metering Process, comprising\n      two
      distinguished types of information: Packet Reports and Report\n      Interpretation.\n"
    title: 3.3.  Reporting
  - contents:
    - "3.4.  Metering Process\n   A Metering Process selects packets from the Observed
      Packet Stream\n   using a Selection Process, and produces as output a Report
      Stream\n   concerning the selected packets.\n   The PSAMP Metering Process can
      be viewed as analogous to the IPFIX\n   Metering Process [RFC5101], which produces
      Flow Records as its\n   output, with the difference that the PSAMP Metering
      Process always\n   contains a Selection Process.  The relationship between PSAMP
      and\n   IPFIX is further described in [RFC5477] and [RFC5474].\n"
    title: 3.4.  Metering Process
  - contents:
    - "3.5.  Exporting Process\n   * Exporting Process\n      An Exporting Process
      sends, in the form of Export Packets, the\n      output of one or more Metering
      Processes to one or more\n      Collectors.\n   * Export Packet\n      An Export
      Packet is a combination of Report Interpretations and/or\n      one or more
      Packet Reports that are bundled by the Exporting\n      Process into an Export
      Packet for exporting to a Collector.\n"
    title: 3.5.  Exporting Process
  - contents:
    - "3.6.  PSAMP Device\n   * PSAMP Device\n      A PSAMP Device is a device hosting
      at least an Observation Point,\n      a Metering Process (which includes a Selection
      Process), and an\n      Exporting Process.  Typically, corresponding Observation
      Point(s),\n      Metering Process(es), and Exporting Process(es) are colocated
      at\n      this device, for example, at a router.\n"
    title: 3.6.  PSAMP Device
  - contents:
    - "3.7.  Collector\n   * Collector\n      A Collector receives a Report Stream
      exported by one or more\n      Exporting Processes.  In some cases, the host
      of the Metering\n      and/or Exporting Processes may also serve as the Collector.\n"
    title: 3.7.  Collector
  - contents:
    - "3.8.  Selection Methods\n   * Filtering\n      A filter is a Selector that
      selects a packet deterministically\n      based on the Packet Content, or its
      treatment, or functions of\n      these occurring in the Selection State.  Two
      examples are:\n         (i) Property Match Filtering: A packet is selected if
      a\n             specific field in the packet equals a predefined value.\n        (ii)
      Hash-based Selection: A Hash Function is applied to the\n             Packet
      Content, and the packet is selected if the result\n             falls in a specified
      range.\n   * Sampling\n      A Selector that is not a filter is called a Sampling
      operation.\n      This reflects the intuitive notion that if the selection of
      a\n      packet cannot be determined from its content alone, there must be\n
      \     some type of Sampling taking place.  Sampling operations can be\n      divided
      into two subtypes:\n         (i) Content-independent Sampling, which does not
      use Packet\n             Content in reaching Sampling decisions.  Examples include\n
      \            systematic Sampling, and uniform pseudorandom Sampling\n             driven
      by a pseudorandom number whose generation is\n             independent of Packet
      Content.  Note that in content-\n             independent Sampling, it is not
      necessary to access the\n             Packet Content in order to make the selection
      decision.\n        (ii) Content-dependent Sampling, in which the Packet Content
      is\n             used in reaching selection decisions.  An application is\n
      \            pseudorandom selection according to a probability that\n             depends
      on the contents of a packet field, e.g., Sampling\n             packets with
      a probability dependent on their TCP/UDP port\n             numbers.  Note that
      this is not a Filter.\n   * Hash Domain\n      A Hash Domain is a subset of
      the Packet Content and the packet\n      treatment, viewed as an N-bit string
      for some positive integer N.\n   * Hash Range\n      A Hash Range is a set of
      M-bit strings for some positive integer M\n      that defines the range of values
      that the result of the hash\n      operation can take.\n   * Hash Function\n
      \     A Hash Function defines a deterministic mapping from the Hash\n      Domain
      into the Hash Range.\n   * Hash Selection Range\n      A Hash Selection Range
      is a subset of the Hash Range.  The packet\n      is selected if the action
      of the Hash Function on the Hash Domain\n      for the packet yields a result
      in the Hash Selection Range.\n   * Hash-based Selection\n      A Hash-based
      Selection is Filtering specified by a Hash Domain, a\n      Hash Function, a
      Hash Range, and a Hash Selection Range.\n   * Approximative Selection\n      Selectors
      in any of the above categories may be approximated by\n      operations in the
      same or another category for the purposes of\n      implementation.  For example,
      uniform pseudorandom Sampling may be\n      approximated by Hash-based Selection,
      using a suitable Hash\n      Function and Hash Domain.  In this case, the closeness
      of the\n      approximation depends on the choice of Hash Function and Hash\n
      \     Domain.\n   * Population\n      A Population is a Packet Stream or a subset
      of a Packet Stream.  A\n      Population can be considered as a base set from
      which packets are\n      selected.  An example is all packets in the Observed
      Packet Stream\n      that are observed within some specified time interval.\n
      \  * Population Size\n      The Population Size is the number of all packets
      in the\n      Population.\n   * Sample Size\n      The Sample Size is a number
      of packets selected from the\n      Population by a Selector.\n   * Configured
      Selection Fraction\n      The Configured Selection Fraction is the expected
      ratio of the\n      Sample Size to the Population Size, as based on the configured\n
      \     selection parameters.\n   * Attained Selection Fraction\n      The Attained
      Selection Fraction is the ratio of the actual Sample\n      Size to the Population
      Size.  For some Sampling methods, the\n      Attained Selection Fraction can
      differ from the Configured\n      Selection Fraction due to, for example, the
      inherent statistical\n      variability in Sampling decisions of probabilistic
      Sampling and\n      Hash-based Selection.  Nevertheless, for large Population
      Sizes\n      and properly configured Selectors, the Attained Selection Fraction\n
      \     usually approaches the Configured Selection Fraction.\n"
    title: 3.8.  Selection Methods
  title: 3.  Terminology
- contents:
  - "4.  Categorization of Packet Selection Techniques\n   Packet selection techniques
    generate a subset of packets from an\n   Observed Packet Stream at an Observation
    Point.  We distinguish\n   between Sampling and Filtering.\n   Sampling is targeted
    at the selection of a representative subset of\n   packets.  The subset is used
    to infer knowledge about the whole set\n   of observed packets without processing
    them all.  The selection can\n   depend on packet position, and/or on Packet Content,
    and/or on\n   (pseudo) random decisions.\n   Filtering selects a subset with common
    properties.  This is used if\n   only a subset of packets is of interest.  The
    properties can be\n   directly derived from the Packet Content, or depend on the
    treatment\n   given by the router to the packet.  Filtering is a deterministic\n
    \  operation.  It depends on Packet Content or router treatment.  It\n   never
    depends on packet position or on (pseudo) random decisions.\n   Note that a common
    technique to select packets is to compute a Hash\n   Function on some bits of
    the packet header and/or content and to\n   select it if the hash value falls
    in the Hash Selection Range.  Since\n   hashing is a deterministic operation on
    the Packet Content, it is a\n   Filtering technique according to our categorization.
    \ Nevertheless,\n   Hash Functions are sometimes used to emulate random Sampling.\n
    \  Depending on the chosen input bits, the Hash Function, and the Hash\n   Selection
    Range, this technique can be used to emulate the random\n   selection of packets
    with a given probability p.  It is also a\n   powerful technique to consistently
    select the same packet subset at\n   multiple Observation Points [DuGr00].\n   The
    following table gives an overview of the schemes described in\n   this document
    and their categorization.  X means that the\n   characteristic applies to the
    selection scheme.  (X) denotes schemes\n   for which content-dependent and content-independent
    variants exist.\n   For instance, Property Match Filtering is typically based
    on Packet\n   Content and therefore is content dependent.  But as explained in\n
    \  Section 6.1, it may also depend on router state and then would be\n   independent
    of the content.  It easily can be seen that only schemes\n   with both properties,
    content dependence and deterministic selection,\n   are considered as Filters.\n
    \       Selection Scheme   | Deterministic | Content -| Category\n                           |
    \ Selection    | Dependent|\n   ------------------------+---------------+----------+----------\n
    \   Systematic             |       X       |     _    | Sampling\n    Count-based
    \           |               |          |\n   ------------------------+---------------+----------+----------\n
    \   Systematic             |       X       |     -    | Sampling\n    Time-based
    \            |               |          |\n   ------------------------+---------------+----------+----------\n
    \   Random                 |       -       |     -    | Sampling\n    n-out-of-N
    \            |               |          |\n   ------------------------+---------------+----------+----------\n
    \   Random                 |       -       |     -    | Sampling\n    uniform
    probabilistic  |               |          |\n   ------------------------+---------------+----------+----------\n
    \   Random                 |       -       |    (X)   | Sampling\n    non-uniform
    probabil.  |               |          |\n   ------------------------+---------------+----------+----------\n
    \   Random                 |       -       |    (X)   | Sampling\n    non-uniform
    Flow-State |               |          |\n   ------------------------+---------------+----------+----------\n
    \   Property Match         |       X       |    (X)   | Filtering\n    Filtering
    \             |               |          |\n   ------------------------+---------------+----------+----------\n
    \   Hash function          |       X       |     X    | Filtering\n   ------------------------+---------------+----------+----------\n
    \  The categorization just introduced is mainly useful for the\n   definition
    of an information model describing Primitive Selectors.\n   More complex selection
    techniques can be described through the\n   composition of cascaded Sampling and
    Filtering operations.  For\n   example, a packet selection that weights the selection
    probability on\n   the basis of the packet length can be described as a cascade
    of a\n   Filtering and a Sampling scheme.  However, this descriptive approach\n
    \  is not intended to be rigid: if a common and consolidated selection\n   practice
    turns out to be too complex to be described as a composition\n   of the mentioned
    building blocks, an ad hoc description can be\n   specified instead and added
    as a new scheme to the information model.\n"
  title: 4.  Categorization of Packet Selection Techniques
- contents:
  - "5.  Sampling\n   The deployment of Sampling techniques aims at the provisioning
    of\n   information about a specific characteristic of the parent Population\n
    \  at a lower cost than a full census would demand.  In order to plan a\n   suitable
    Sampling strategy, it is therefore crucial to determine the\n   needed type of
    information and the desired degree of accuracy in\n   advance.\n   First of all,
    it is important to know the type of metric that should\n   be estimated.  The
    metric of interest can range from simple packet\n   counts [JePP92] up to the
    estimation of whole distributions of flow\n   characteristics (e.g., packet sizes)
    [ClPB93].\n   Second, the required accuracy of the information and with this,
    the\n   confidence that is aimed at, should be known in advance.  For\n   instance,
    for usage-based accounting the required confidence for the\n   estimation of packet
    counters can depend on the monetary value that\n   corresponds to the transfer
    of one packet.  That means that a higher\n   confidence could be required for
    expensive packet flows (e.g.,\n   premium IP service) than for cheaper flows (e.g.,
    best effort).  The\n   accuracy requirements for validating a previously agreed
    quality can\n   also vary extremely with the customer demands.  These requirements\n
    \  are usually determined by the service level agreement (SLA).\n   The Sampling
    method and the parameters in use must be clearly\n   communicated to all applications
    that use the measurement data.  Only\n   with this knowledge a correct interpretation
    of the measurement\n   results can be ensured.\n   Sampling methods can be characterized
    by the Sampling algorithm, the\n   trigger type used for starting a Sampling interval,
    and the length of\n   the Sampling interval.  These parameters are described here
    in\n   detail.  The Sampling algorithm describes the basic process for\n   selection
    of samples.  In accordance to [AmCa89] and [ClPB93], we\n   define the following
    basic Sampling processes.\n"
  - contents:
    - "5.1.  Systematic Sampling\n   Systematic Sampling describes the process of
      selecting the start\n   points and the duration of the selection intervals according
      to a\n   deterministic function.  This can be for instance the periodic\n   selection
      of every k-th element of a trace but also the selection of\n   all packets that
      arrive at predefined points in time.  Even if the\n   selection process does
      not follow a periodic function (e.g., if the\n   time between the Sampling intervals
      varies over time), we consider\n   this as systematic Sampling as long as the
      selection is\n   deterministic.\n   The use of systematic Sampling always involves
      the risk of biasing\n   the results.  If the systematics in the Sampling process
      resemble\n   systematics in the observed stochastic process (occurrence of the\n
      \  characteristic of interest in the network), there is a high\n   probability
      that the estimation will be biased.  Systematics in the\n   observed process
      might not be known in advance.\n   Here only equally spaced schemes are considered,
      where triggers for\n   Sampling are periodic, either in time or in packet count.
      \ All\n   packets occurring in a selection interval (either in time or packet\n
      \  count) beyond the trigger are selected.\n   Systematic count-based\n   In
      systematic count-based Sampling, the start and stop triggers for\n   the Sampling
      interval are defined in accordance to the spatial packet\n   position (packet
      count).\n   Systematic time-based\n   In systematic time-based Sampling, time-based
      start and stop triggers\n   are used to define the Sampling intervals.  All
      packets are selected\n   that arrive at the Observation Point within the time
      intervals\n   defined by the start and stop triggers (i.e., arrival time of
      the\n   packet is larger than the start time and smaller than the stop time).\n
      \  Both schemes are content-independent selection schemes.  Content-\n   dependent
      deterministic Selectors are categorized as filters.\n"
    title: 5.1.  Systematic Sampling
  - contents:
    - "5.2.  Random Sampling\n   Random Sampling selects the starting points of the
      Sampling intervals\n   in accordance to a random process.  The selection of
      elements is an\n   independent experiment.  With this, unbiased estimations
      can be\n   achieved.  In contrast to systematic Sampling, random Sampling\n
      \  requires the generation of random numbers.  One can differentiate two\n   methods
      of random Sampling: n-out-of-N Sampling and probabilistic\n   Sampling.\n"
    - contents:
      - "5.2.1.  n-out-of-N Sampling\n   In n-out-of-N Sampling, n elements are selected
        out of the parent\n   Population that consists of N elements.  One example
        would be to\n   generate n different random numbers in the range [1,N] and
        select all\n   packets that have a packet position equal to one of the random\n
        \  numbers.  For this kind of Sampling, the Sample Size n is fixed.\n"
      title: 5.2.1.  n-out-of-N Sampling
    - contents:
      - "5.2.2.  Probabilistic Sampling\n   In probabilistic Sampling, the decision
        whether or not an element is\n   selected is made in accordance to a predefined
        selection probability.\n   An example would be to flip a coin for each packet
        and select all\n   packets for which the coin showed the head.  For this kind
        of\n   Sampling, the Sample Size can vary for different trials.  The\n   selection
        probability does not necessarily have to be the same for\n   each packet.
        \ Therefore, we distinguish between uniform probabilistic\n   Sampling (with
        the same selection probability for all packets) and\n   non-uniform probabilistic
        Sampling (where the selection probability\n   can vary for different packets).\n"
      - contents:
        - "5.2.2.1.  Uniform Probabilistic Sampling\n   For Uniform Probabilistic
          Sampling, packets are selected\n   independently with a uniform probability
          p.  This Sampling can be\n   count-driven, and is sometimes referred to
          as geometric random\n   Sampling, since the difference in count between
          successive selected\n   packets is an independent random variable with a
          geometric\n   distribution of mean 1/p.  A time-driven analog, exponential
          random\n   Sampling, has the time between triggers exponentially distributed.\n
          \  Both geometric and exponential random Sampling are examples of what\n
          \  is known as additive random Sampling, defined as Sampling where the\n
          \  intervals or counts between successive samples are independent\n   identically
          distributed random variables.\n"
        title: 5.2.2.1.  Uniform Probabilistic Sampling
      - contents:
        - "5.2.2.2.  Non-Uniform Probabilistic Sampling\n   This is a variant of Probabilistic
          Sampling in which the Sampling\n   probabilities can depend on the selection
          process input.  This can be\n   used to weight Sampling probabilities in
          order, e.g., to boost the\n   chance of Sampling packets that are rare but
          are deemed important.\n   Unbiased estimators for quantitative statistics
          are recovered by\n   re-normalization of sample values; see [HT52].\n"
        title: 5.2.2.2.  Non-Uniform Probabilistic Sampling
      - contents:
        - "5.2.2.3.  Non-Uniform Flow State Dependent Sampling\n   Another type of
          Sampling that can be classified as probabilistic\n   Non-Uniform is closely
          related to the flow concept as defined in\n   [RFC3917], and it is only
          used jointly with a flow monitoring\n   function (IPFIX Metering Process).
          \ Packets are selected, dependent\n   on a Selection State.  The point,
          here, is that the Selection State\n   is determined also by the state of
          the flow the packet belongs to\n   and/or by the state of the other flows
          currently being monitored by\n   the associated flow monitoring function.
          \ An example for such an\n   algorithm is the \"sample and hold\" method
          described in [EsVa01]:\n   - If a packet accounts for a Flow Record that
          already exists in the\n     IPFIX flow recording process, it is selected
          (i.e., the Flow Record\n     is updated).\n   - If a packet doesn't account
          for any existing Flow Record, it is\n     selected with probability p.  If
          it has been selected, a new Flow\n     Record has to be created.\n   A further
          algorithm that fits into the category of non-uniform flow\n   state dependent
          Sampling is described in [Moli03].\n   This type of Sampling is content
          dependent because the identification\n   of the flow the packet belongs
          to requires analyzing part of the\n   Packet Content.  If the packet is
          selected, then it is passed as an\n   input to the IPFIX monitoring function
          (this is called \"Local Export\"\n   in [RFC5474]).  Selecting the packet
          depending on the state of a flow\n   cache is useful when memory resources
          of the flow monitoring function\n   are scarce (i.e., there is no room to
          keep all the flows that have\n   been scheduled for monitoring).\n"
        title: 5.2.2.3.  Non-Uniform Flow State Dependent Sampling
      - contents:
        - "5.2.2.4.  Configuration of Non-Uniform Probabilistic and Flow State\n          Sampling\n
          \  Many different specific methods can be grouped under the terms\n   non-uniform
          probabilistic and flow state Sampling.  Dependent on the\n   Sampling goal
          and the implemented scheme, a different number and type\n   of input parameters
          are required to configure such a scheme.\n   Some concrete proposals for
          such methods exist from the research\n   community (e.g., [EsVa01], [DuLT01],
          [Moli03]).  Some of these\n   proposals are still in an early stage and
          need further investigations\n   to prove their usefulness and applicability.
          \ It is not our aim to\n   indicate preference among these methods.  Instead,
          we only describe\n   here the basic methods and leave the specification
          of explicit\n   schemes and their parameters up to vendors (e.g., as an
          extension of\n   the information model).\n"
        title: 5.2.2.4.  Configuration of Non-Uniform Probabilistic and Flow State
      title: 5.2.2.  Probabilistic Sampling
    title: 5.2.  Random Sampling
  title: 5.  Sampling
- contents:
  - "6.  Filtering\n   Filtering is the deterministic selection of packets based on
    the\n   Packet Content, the treatment of the packet at the Observation Point,\n
    \  or deterministic functions of these occurring in the Selection State.\n   The
    packet is selected if these quantities fall into a specified\n   range.  The role
    of Filtering, as the word itself suggest, is to\n   separate all the packets having
    a certain property from those not\n   having it.  A distinguishing characteristic
    from Sampling is that the\n   selection decision does not depend on the packet
    position in time or\n   in space, or on a random process.\n   We identify and
    describe in the following two Filtering techniques.\n"
  - contents:
    - "6.1.  Property Match Filtering\n   With this Filtering method, a packet is
      selected if specific fields\n   within the packet and/or properties of the router
      state equal a\n   predefined value.  Possible filter fields are all IPFIX flow\n
      \  attributes specified in [RFC5102].  Further fields can be defined by\n   proposing
      new information elements or defining vendor-specific\n   extensions.\n   A packet
      is selected if Field=Value.  Masks and ranges are only\n   supported to the
      extent to which [RFC5102] allows them, e.g., by\n   providing explicit fields
      like the netmasks for source and\n   destination addresses.\n   AND operations
      are possible by concatenating filters, thus producing\n   a composite selection
      operation.  In this case, the ordering in which\n   the Filtering happens is
      implicitly defined (outer filters come after\n   inner filters).  However, as
      long as the concatenation is on filters\n   only, the result of the cascaded
      filter is independent from the\n   order, but the order may be important for
      implementation purposes, as\n   the first filter will have to work at a higher
      rate.  In any case, an\n   implementation is not constrained to respect the
      filter ordering, as\n   long as the result is the same, and it may even implement
      the\n   composite Filtering in one single step.\n   OR operations are not supported
      with this basic model.  More\n   sophisticated filters (e.g., supporting bitmasks,
      ranges, or OR\n   operations) can be realized as vendor-specific schemes.\n
      \  All IPFIX flow attributes defined in [RFC5102] can be used for\n   Property
      Match Filtering.  Further information elements can be easily\n   defined.  Property
      match operations should be available for different\n   protocol portions of
      the packet header:\n         (i) IP header (excluding options in IPv4, stacked
      headers in\n             IPv6)\n        (ii) transport protocol header (e.g.,
      TCP, UDP)\n       (iii) encapsulation headers (e.g., the MPLS label stack, if\n
      \            present)\n   When the PSAMP Device offers Property Match Filtering,
      and, in its\n   usual capacity other than in performing PSAMP functions, identifies\n
      \  or processes information from IP, transport protocol or encapsulation\n   protocols,
      then the information should be made available for\n   Filtering.  For example,
      when a PSAMP Device routes based on\n   destination IP address, that field should
      be made available for\n   Filtering.  Conversely, a PSAMP Device that does not
      route is not\n   expected to be able to locate an IP address within a packet,
      or make\n   it available for Filtering, although it may do so.\n   Since packet
      encryption conceals the real values of encrypted fields,\n   Property Match
      Filtering must be configurable to ignore encrypted\n   packets, when detected.\n
      \  The Selection Process may support Filtering based on the properties\n   of
      the router state:\n         (i) Ingress interface at which a packet arrives
      equals a\n             specified value\n        (ii) Egress interface to which
      a packet is routed to equals a\n             specified value\n       (iii) Packet
      violated Access Control List (ACL) on the router\n        (iv) Failed Reverse
      Path Forwarding (RPF)\n         (v) Failed Resource Reservation Protocol (RSVP)\n
      \       (vi) No route found for the packet\n       (vii) Origin Border Gateway
      Protocol (BGP) Autonomous System (AS)\n             [RFC4271] equals a specified
      value or lies within a given\n             range\n      (viii) Destination BGP
      AS equals a specified value or lies within\n             a given range\n   Packets
      that match the failed Reverse Path Forwarding (RPF) condition\n   are packets
      for which ingress Filtering failed as defined in\n   [RFC3704].\n   Packets
      that match the failed Resource Reservation Protocol (RSVP)\n   condition are
      packets that do not fulfill the RSVP specification as\n   defined in [RFC2205].\n
      \  Router architectural considerations may preclude some information\n   concerning
      the packet treatment being available at line rate for\n   selection of packets.
      \ For example, the Selection Process may not be\n   implemented in the fast
      path that is able to access router state at\n   line rate.  However, when Filtering
      follows Sampling (or some other\n   selection operation) in a Composite Selector,
      the rate of the Packet\n   Stream output from the sampler and input to the filter
      may be\n   sufficiently slow that the filter could select based on router state.\n"
    title: 6.1.  Property Match Filtering
  - contents:
    - "6.2.  Hash-Based Filtering\n   A Hash Function h maps the Packet Content c,
      or some portion of it,\n   onto a Hash Range R.  The packet is selected if h(c)
      is an element of\n   S, which is a subset of R called the Hash Selection Range.
      \ Thus,\n   Hash-Based selection is a particular case of Filtering.  The object\n
      \  is selected if c is in inv(h(S)).  But for desirable Hash Functions,\n   the
      inverse image inv(h(S)) will be extremely complex, and hence h\n   would not
      be expressible as, say, a Property Match Filter or a simple\n   combination
      of these.\n   Hash-based Selection is mainly used to realize a coordinated packet\n
      \  selection.  That means that the same packets are selected at\n   different
      Observation Points.  This is useful for instance to observe\n   the path (trajectory)
      that a packet took through the network or to\n   apply packet selection to passive
      one-way measurements.\n   A prerequisite for the method to work and to ensure
      interoperability\n   is that the same Hash Function with the same parameters
      (e.g., input\n   vector) is used at the Observation Points.\n   A consistent
      packet selection is also possible with Property Match\n   Filtering.  Nevertheless,
      Hash-based Selection can be used to\n   approximate a random selection.  The
      desired statistical properties\n   are discussed in Section 6.2.2.\n   In the
      following subsections, we give some application examples for\n   coordinated
      packet selection.\n"
    - contents:
      - '6.2.1.  Application Examples for Coordinated Packet Selection

        '
      - contents:
        - "6.2.1.1.  Trajectory Sampling\n   Trajectory Sampling is the consistent
          selection of a subset of\n   packets at either all of a set of Observation
          Points or none of them.\n   Trajectory Sampling is realized by Hash-based
          Selection if all\n   Observation Points in the set use a common Hash Function,
          Hash\n   Domain, and Selection Range.  The Hash Domain comprises all or
          part\n   of the Packet Content that is invariant along the packet path.\n
          \  Fields such as Time-to-Live, which is decremented per hop, and header\n
          \  CRC [RFC1624], which is recalculated per hop, are thus excluded from\n
          \  the Hash Domain.  The Hash Domain needs to be wider than just a flow\n
          \  key, if packets are to be selected quasi-randomly within flows.\n   The
          trajectory (or path) followed by a packet is reconstructed from\n   PSAMP
          reports on it that reach a Collector.  Reports on a given\n   packet originating
          from different Observation Points are associated\n   by matching a label
          from the reports.  The label may comprise that\n   portion of the invariant
          Packet Content that is reported, or possibly\n   some digest of the invariant
          Packet Content that is inserted into the\n   packet report at the Observation
          Point.  Such a digest may be\n   constructed by applying a second Hash Function
          to the invariant\n   Packet Content.  The reconstruction of trajectories
          and methods for\n   dealing with possible ambiguities due to label collisions
          (identical\n   labels reported for different packets) and potential loss
          of reports\n   in transmission are dealt with in [DuGr00], [DuGG02], and
          [DuGr04].\n   Applications of trajectory Sampling include (i) estimation
          of the\n   network path matrix, i.e., the traffic intensities according
          to\n   network path, broken down by flow key; (ii) detection of routing\n
          \  loops, as indicated by self-intersecting trajectories; (iii) passive\n
          \  performance measurement: prematurely terminating trajectories\n   indicate
          packet loss, packet one-way delay can be determined if\n   reports include
          (synchronized) timestamps of packet arrival at the\n   Observation Point;
          and (iv) network attack tracing, of the actual\n   paths taken by attack
          packets with spoofed source addresses.\n"
        title: 6.2.1.1.  Trajectory Sampling
      - contents:
        - "6.2.1.2.  Passive One-Way Measurements\n   Coordinated packet selection
          can be applied for instance to one-way\n   delay measurements in order to
          reduce the required resources.  In\n   one-way delay measurements, packets
          are collected at different\n   Observation Points in the network.  A packet
          digest is generated for\n   each packet that helps to identify the packet.
          \ The packet digest and\n   the arrival time of the packet at the Observation
          Point are reported\n   to a process that calculates the delay.  The delay
          is calculated by\n   subtracting the arrival time of the same packet at
          the Observation\n   Points (e.g., [ZsZC01]).  With high data rates, capturing
          all packets\n   can require a lot of resources for storage, transfer, and
          processing.\n   To reduce resource consumption, packet selection methods
          can be\n   applied.  But for such selection techniques, it has to be ensured\n
          \  that the same packets are collected at different Observation Points.\n
          \  Hash-based Selection provides this feature.\n"
        title: 6.2.1.2.  Passive One-Way Measurements
      - contents:
        - "6.2.1.3.  Generation of Pseudorandom Numbers\n   Although pseudorandom
          number generators with well-understood\n   properties have been developed,
          they may not be the method of choice\n   in settings where computational
          resources are scarce.  A convenient\n   alternative is to use Hash Functions
          of Packet Content as a source of\n   randomness.  The hash (suitably re-normalized)
          is a pseudorandom\n   variate in the interval [0,1].  Other schemes may
          use packet fields\n   in iterators for pseudorandom numbers.  However, the
          statistical\n   properties of an ideal packet selection law (such as independent\n
          \  Sampling for different packets, or independence on Packet Content)\n
          \  may not be exactly rendered by an implementation, but only\n   approximately
          so.\n   Use of Packet Content to generate pseudorandom variates shares with\n
          \  non-uniform probabilistic Sampling (see Section 5.2.2.2 above) the\n
          \  property that selection decisions depend on Packet Content.  However,\n
          \  there is a fundamental difference between the two.  In the former\n   case,
          the content determines pseudorandom variates.  In the latter\n   case, the
          content only determines the selection probabilities:\n   selection could
          then proceed, e.g., by use of random variates\n   obtained by an independent
          pseudorandom number generator.\n"
        title: 6.2.1.3.  Generation of Pseudorandom Numbers
      title: 6.2.1.  Application Examples for Coordinated Packet Selection
    - contents:
      - "6.2.2.  Desired Properties of Hash Functions\n   Here we formulate desired
        properties for Hash Functions.  For this,\n   we have to distinguish whether
        a Hash Function is used for packet\n   selection or just as a packet digest.
        \ The main focus of this\n   document is on packet selection.  Nevertheless,
        we also provide some\n   requirements for the use of Hash Functions as packet
        digest.\n   First of all, we need to define suitable input fields from the\n
        \  packet.  In accordance to [DuGr00], input field should be:\n      - invariant
        on the path\n      - variable among packets\n   Only if the input fields are
        the same at different Observation Points\n   is it possible to recognize the
        packet.  The input fields should be\n   variable among packets in order to
        distribute the hash results over\n   the selection range.\n"
      - contents:
        - "6.2.2.1.  Requirements for Packet Selection\n   In accordance to considerations
          in [MoND05] and [Henk08], we define\n   the following desired properties
          of Hash Functions used for packet\n   selection:\n         (i) Speed: The
          Hash Function has to be applied to each packet\n             that traverses
          the Observation Point.  Therefore, it has to\n             be fast in order
          to cope with the high packet rates.  In\n             the ideal case, the
          hash operation should not influence the\n             performance on the
          PSAMP Device.\n        (ii) Uniformity: The Hash Function h should have
          good mixing\n             properties, in the sense that small changes in
          the input\n             (e.g., the flipping of a single bit) cause large
          changes in\n             the output (many bits change).  Then any local
          clump of\n             values of c is spread widely over R by h, and so
          the\n             distribution of h(c) is fairly uniform even if the\n             distribution
          of c is not.  Then the Attained Selection\n             Fraction gets close
          to the Configured Selection Fraction\n             (#S/#R), which can be
          tuned by choice of S.\n       (iii) Unbiasedness: The selection decision
          should be as\n             independent of packet attributes as possible.
          \ The set of\n             selected packets should not be biased towards
          a specific\n             type of packets.\n        (iv) Representativeness
          of sample: The sample should be as\n             representative as possible
          for the observed traffic.\n         (v) Non-linearity: The function should
          not be linear.  This\n             increases the mixing properties (uniformity
          criterion).  In\n             addition to this, it decreases the predictability
          of the\n             output and therefore the vulnerabilities against attacks.\n
          \       (vi) Robustness against vulnerabilities: The Hash Function\n             should
          be robust against attacks.  Potential\n             vulnerabilities are
          described in Section 6.2.3.\n"
        title: 6.2.2.1.  Requirements for Packet Selection
      - contents:
        - "6.2.2.2.  Requirements for Packet Digesting\n   For digesting Packet Content
          for inclusion in a reported label, the\n   most important property is a
          low collision frequency.  A secondary\n   requirement is the ability to
          accept variable-length input, in order\n   to allow inclusion of maximal
          amount of packet as input.  Execution\n   speed is of secondary importance,
          since the digest need only be\n   formed from selected packets.\n"
        title: 6.2.2.2.  Requirements for Packet Digesting
      title: 6.2.2.  Desired Properties of Hash Functions
    - contents:
      - "6.2.3.  Security Considerations for Hash Functions\n   A concern for Hash-based
        Selection is whether some large set of\n   related packets could be disproportionately
        sampled, i.e., that the\n   Attained Selection Fraction is significantly different
        from the\n   Configured Selection Fraction.  This can happen either\n         (i)
        \ through unanticipated behavior in the Hash Function, or\n        (ii) because
        the packets had been deliberately crafted to have\n             this property.\n
        \  The first point underlines the importance of using a Hash Function\n   with
        good mixing properties.  For this, the statistical properties of\n   candidate
        Hash Functions need to be evaluated.  Since the hash output\n   depends on
        the traffic mix, the evaluation should be done preferably\n   on up-to-date
        packet traces from the network in which the Hash-based\n   Selection will
        be deployed.\n   However, Hash Functions that perform well on typical traffic
        may not\n   be sufficiently strong to withstand attacks specifically targeted\n
        \  against them.  Such potential attacks have been described in\n   [GoRe07].\n
        \  In the following subsections, we point out different potential attack\n
        \  scenarios.  We encourage the use of standardized Hash Functions.\n   Therefore,
        we assume that the Hash Function itself is public and\n   hence known to an
        attacker.\n   Nevertheless, we also assume the possibility of using a private
        input\n   parameter for the Hash Function that is kept secret.  Such an input\n
        \  parameter can for instance be attached to the hash input before the\n   hash
        operation is applied.  With this, at least parts of the hash\n   operation
        remain secret.\n   For the attack scenarios, we assume that an attacker uses
        its\n   knowledge of the Hash Function to craft packets that are then\n   dispatched,
        either as the attack itself or to elicit further\n   information that can
        be used to refine the attack.\n   Two scenarios are considered.  In the first
        scenario, the attacker\n   has no knowledge about whether or not the crafted
        packets are\n   selected.  In the second scenario, the attacker uses some
        knowledge\n   of Sampling outcomes.  The means by which this might be acquired
        is\n   discussed below.  Some additional attacks that involve tampering with\n
        \  Export Packets in transit, as opposed to attacking the PSAMP Device,\n
        \  are discussed in [GoRe07].\n"
      - contents:
        - "6.2.3.1.  Vulnerabilities of Hash-Based Selection without Knowledge of\n
          \         Selection Outcomes\n      (i) The Hash Function does not use a
          private parameter.\n   If no private input parameter is used, potential
          attackers can easily\n   calculate which packets result in which hash values.
          \ If the\n   selection range is public, an attacker can craft packets whose\n
          \  selection properties are known in advance.  If the selection range is\n
          \  private, an attacker cannot determine whether a crafted packet is\n   selected.
          \ However, by computing the hash on different trial crafted\n   packets,
          and selecting those yielding a given hash value, the\n   attacker can construct
          an arbitrarily large set of distinct packets\n   with a common selection
          properties, i.e., packets that will be either\n   all selected or all not
          selected.  This can be done whatever the\n   strength of the Hash Function.\n
          \     (ii) The Hash Function is not cryptographically strong.\n   If the
          Hash Function is not cryptographically strong, it may be\n   possible to
          construct sequences of distinct packets with the common\n   selection property
          even if a private parameter is used.\n   An example is the standard CRC-32
          Hash Function used with a private\n   modulus (but without a private string
          post-pended to the input).  It\n   has weak mixing properties for low-order
          bits.  Consequently, simply\n   by incrementing the hash input, one obtains
          distinct packets whose\n   hashes mostly fall in a narrow range, and hence
          are likely commonly\n   selected; see [GoRe07].\n   Suitable parameterization
          of the Hash Function can make such attacks\n   more difficult.  For example,
          post-pending a private string to the\n   input before hashing with CRC-32
          will give stronger mixing properties\n   over all bits of the input.  However,
          with a Hash Function, such as\n   CRC-32, that is not cryptographically
          strong, the possibility of\n   discovering a method to construct packet
          sets with the common\n   selected property cannot be ruled out, even when
          a private modulus or\n   post-pended string is used.\n"
        title: 6.2.3.1.  Vulnerabilities of Hash-Based Selection without Knowledge
          of
      - contents:
        - "6.2.3.2.  Vulnerabilities of Hash-Based Selection Using Knowledge of\n
          \         Selection Outcomes\n   Knowledge of the selection outcomes of
          crafted packets can be used by\n   an attacker to more easily construct
          sets of packets that are\n   disproportionately sampled and/or are commonly
          selected.  For this,\n   the attacker does not need any a priori knowledge
          about the Hash\n   Function or selection range.\n   There are several ways
          an attacker might acquire this knowledge about\n   the selection outcome:\n
          \        (i) Billing Reports: If samples are used for billing purposes,\n
          \            then the selection outcomes of packets may be able to be\n
          \            inferred by correlating a crafted Packet Stream with the\n
          \            billing reports that it generates.  However, the rate at\n
          \            which knowledge of selection outcomes can be acquired\n             depends
          on the temporal and spatial granularity of the\n             billing reports;
          being slower the more aggregated the\n             reports are.\n        (ii)
          Feedback from an Intrusion Detection System: e.g., a\n             botmaster
          adversary learns if his packets were detected by\n             the intrusion
          detection system by seeing if one of his bots\n             is blocked by
          the network.\n       (iii) Observation of the Report Stream: Export Packets
          sent\n             across a public network may be eavesdropped on by an\n
          \            adversary.  Encryption of the Export Packets provides only\n
          \            a partial defense, since it may be possible to infer the\n
          \            selection outcomes of packets by correlating a crafted\n             Packet
          Stream with the occurrence (not the content) of\n             packets in
          the export stream that it generates.  The rate\n             at which such
          knowledge could be acquired is limited by the\n             temporal resolution
          at which reports can be associated with\n             packets, e.g., due
          to processing and propagation\n             variability, and difficulty
          in distinguishing report on\n             attack packets from those of background
          traffic, if\n             present.  The association between packets and
          their reports\n             on which this depends could be removed by padding
          Export\n             Packets to a constant length and sending them at a
          constant\n             rate.\n   We now turn to attacks that can exploit
          knowledge of selection\n   outcomes.  First, with a non-cryptographic Hash
          Function, knowledge\n   of selection outcomes for a trial stream may be
          used to further craft\n   a packet set with the common selection property.
          \ This has been\n   demonstrated for the modular hash f(x) = a x + b mod
          k, for private\n   parameters a, b, and k.  With Sampling rate p, knowledge
          of the\n   Sampling outcomes of roughly 2/p is sufficient for the attack
          to\n   succeed, independent of the values of a, b, and k.  With knowledge
          of\n   the selection outcomes of a larger number of packets, the parameters\n
          \  a, b, and k can be determined; see [GoRe07].\n   A cryptographic Hash
          Function employing a private parameter and\n   operating in one of the pseudorandom
          function modes specified above\n   is not vulnerable to these attacks, even
          if the selection range is\n   known.\n"
        title: 6.2.3.2.  Vulnerabilities of Hash-Based Selection Using Knowledge of
      - contents:
        - "6.2.3.3.  Vulnerabilities to Replay Attacks\n   Since Hash-based Selection
          is deterministic, any packet or set of\n   packets with known selection
          properties can be replayed into a\n   network and experience the same selection
          outcomes provide the Hash\n   Function and its parameters are not changed.
          \ Repetition of a single\n   packet may be noticeable to other measurement
          methods if employed\n   (e.g., collection of flow statistics), whereas a
          set of distinct\n   packets that appears statistically similar to regular
          traffic may be\n   less noticeable.\n   Replay attacks may be mitigated
          by repeated changing of Hash Function\n   parameters.  This also prevents
          attacks that exploit knowledge of\n   Sampling outcomes, at least if the
          parameters are changed at least as\n   fast as the knowledge can be acquired
          by an attacker.  In order to\n   preserve the ability to perform trajectory
          Sampling, parameter change\n   would have to be simultaneous (or approximately
          so) across all\n   Observation Points.\n"
        title: 6.2.3.3.  Vulnerabilities to Replay Attacks
      title: 6.2.3.  Security Considerations for Hash Functions
    - contents:
      - "6.2.4.  Choice of Hash Function\n   The specific choice of Hash Function
        represents a trade-off between\n   complexity and ease of implementation.
        \ Ideally, a cryptographically\n   strong Hash Function employing a private
        parameter and operating in\n   pseudorandom function mode as specified above
        would be used, yielding\n   a good emulation of a random packet selection
        at a target Sampling\n   rate, and giving maximal robustness against the attacks
        described in\n   the previous section.  Unfortunately, there is currently
        no single\n   Hash Function that fulfills all the requirements.\n   As detailed
        in Section 6.2.3, only cryptographic Hash Functions\n   employing a private
        parameter operating in pseudorandom function mode\n   are sufficiently strong
        to withstand the range of conceivable\n   attacks.  For example, fixed- or
        variable-length inputs could be\n   hashed using a block cipher (like Advanced
        Encryption Standard (AES))\n   in cipher-block-chaining mode.  Fixed-length
        inputs could also be\n   hashed using an iterated cryptographic Hash Function
        (like MD5 or\n   SHA1), with a private initial vector.  For variable-length
        inputs, an\n   iterated cryptographic Hash Function (like MD5 or SHA1) should
        employ\n   private string post-pended to the data in addition to a private\n
        \  initial vector.  For more details, see the \"append-cascade\"\n   construction
        of [BeCK96].  We encourage the use of such\n   cryptographically strong Hash
        Functions wherever possible.\n   However, a problem with using such functions
        is the low performance.\n   As shown for instance in [Henk08], the computation
        times for MD5 and\n   SHA are about 7-10 times higher compared to non-cryptographic\n
        \  functions.  The difference increases for small hash input lengths.\n   Therefore,
        it is not assumed that all PSAMP Devices will be capable\n   of applying a
        cryptographically strong Hash Function to every packet\n   at line rate.  For
        this reason, the Hash Functions listed in this\n   section will be of a weaker
        variety.  Future protocol extensions that\n   employ stronger Hash Functions
        are highly welcome.\n   Comparisons of Hash Functions for packet selection
        and packet\n   digesting with regard to various criteria can be found in [MoND05]\n
        \  and [Henk08].\n"
      - contents:
        - "6.2.4.1.  Hash Functions for Packet Selection\n   If Hash-based packet
          Selection is applied, the BOB function MUST be\n   used for packet selection
          operations in order to be compliant with\n   PSAMP.  The specification of
          BOB is given in the appendix.  Both the\n   parameter (the init value) and
          the selection range should be kept\n   private.  The initial vector of the
          Hash Function MUST be\n   configurable out of band to prevent security breaches
          like exposure\n   of the initial vector content.\n   Other functions, such
          as CRC-32 and IPSX, MAY be used.  The IPSX\n   function is described in
          the appendix, and the CRC-32 function is\n   described in [RFC1141].  If
          CRC-32 is used, the input should first be\n   post-pended with a private
          string that acts as a parameter, and the\n   modulus of the CRC should also
          be kept private.\n   IPSX is simple to implement and was correspondingly
          about an order of\n   magnitude faster to execute per packet than BOB or
          CRC-32 [MoND05].\n   All three Hash Functions evaluated showed relatively
          poor uniformity\n   with 16-byte input that was drawn from only invariant
          fields in the\n   IP and TCP/UDP headers (i.e., header fields that do not
          change from\n   hop to hop).  IPSX is inherently limited to 16 bytes.\n
          \  BOB and CRC-32 exhibit noticeably better uniformity when 4 or more\n
          \  bytes from the payload are also included in the input [MoND05].  Also\n
          \  with other criteria BOB performed quite well [Henk08].\n   Although the
          characteristics have been checked for different traffic\n   traces, results
          cannot be generalized to arbitrary traffic.  Since\n   Hash-based Selection
          is a deterministic function on the Packet\n   Content, it can always be
          biased towards packets with specific\n   attributes.  Furthermore, it should
          be noted that all Hash Functions\n   were evaluated only for IPv4.\n   None
          of these Hash Functions is recommended for cryptographic\n   purposes.  Please
          also note that the use of a private parameter only\n   slightly reduces
          the vulnerabilities against attacks.  As shown in\n   Section 6.2.3, functions
          that are not cryptographically strong (e.g.,\n   BOB and CRC) cannot prevent
          attackers from crafting packets that are\n   disproportionally selected
          even if a private parameter is used and\n   the selection range is kept
          secret.\n   As described in Section 6.2.2, the input bytes for the Hash
          Function\n   need to be invariant along the path the packet is traveling.
          \ Only\n   with this it is ensured that the same packets are selected at\n
          \  different Observation Points.  Furthermore, they should have a high\n
          \  variability between different packets to generate a high variation in\n
          \  the Hash Range.  An evaluation of the variability of different packet\n
          \  header fields can be found in [DuGr00], [HeSZ08], and [Henk08].\n   If
          a Hash-based Selection with the BOB function is used with IPv4\n   traffic,
          the following input bytes MUST be used.\n      - IP identification field\n
          \     - Flags field\n      - Fragment offset\n      - Source IP address\n
          \     - Destination IP address\n      - A configurable number of bytes from
          the IP payload, starting at\n        a configurable offset\n   Due to the
          lack of suitable IPv6 packet traces, all candidate Hash\n   Functions in
          [DuGr00], [MoND05], and [Henk08] were evaluated only for\n   IPv4.  Due
          to the IPv6 header fields and address structure, it is\n   expected that
          there is less randomness in IPv6 packet headers than in\n   IPv4 headers.
          \ Nevertheless, the randomness of IPv6 traffic has not\n   yet been evaluated
          sufficiently to get any evidence.  In addition to\n   this, IPv6 traffic
          profiles may change significantly in the future\n   when IPv6 is used by
          a broader community.\n   If a Hash-based Selection with the BOB function
          is used with IPv6\n   traffic, the following input bytes MUST be used.\n
          \     - Payload length (2 bytes)\n      - Byte number 10,11,14,15,16 of
          the IPv6 source address\n      - Byte number 10,11,14,15,16 of the IPv6
          destination address\n      - A configurable number of bytes from the IP
          payload, starting at\n        a configurable offset.  It is recommended
          to use at least 4\n        bytes from the IP payload.\n   The payload itself
          is not changing during the path.  Even if some\n   routers process some
          extension headers, they are not going to strip\n   them from the packet.
          \ Therefore, the payload length is invariant\n   along the path.  Furthermore,
          it usually differs for different\n   packets.  The IPv6 address has 16 bytes.
          \ The first part is the\n   network part and contains low variation.  The
          second part is the host\n   part and contains higher variation.  Therefore,
          the second part of\n   the address is used.  Nevertheless, the uniformity
          has not been\n   checked for IPv6 traffic.\n"
        title: 6.2.4.1.  Hash Functions for Packet Selection
      - contents:
        - "6.2.4.2.  Hash Functions Suitable for Packet Digesting\n   For this purpose
          also the BOB function SHOULD be used.  Other\n   functions (such as CRC-32)
          MAY be used.  Among the functions capable\n   of operating with variable-length
          input, BOB and CRC-32 have the\n   fastest execution, BOB being slightly
          faster.  IPSX is not\n   recommended for digesting because it has a significantly
          higher\n   collision rate and takes only a fixed-length input.\n"
        title: 6.2.4.2.  Hash Functions Suitable for Packet Digesting
      title: 6.2.4.  Choice of Hash Function
    title: 6.2.  Hash-Based Filtering
  title: 6.  Filtering
- contents:
  - "7.  Parameters for the Description of Selection Techniques\n   This section gives
    an overview of different alternative selection\n   schemes and their required
    parameters.  In order to be compliant with\n   PSAMP, at least one of proposed
    schemes MUST be implemented.\n   The decision whether or not to select a packet
    is based on a function\n   that is performed when the packet arrives at the selection
    process.\n   Packet selection schemes differ in the input parameters for the\n
    \  selection process and the functions they require to do the packet\n   selection.
    \ The following table gives an overview.\n     Scheme       |   Input parameters
    \    |     Functions\n   ---------------+------------------------+-------------------\n
    \   systematic    |    packet position     |  packet counter\n    count-based
    \  |    Sampling pattern    |\n   ---------------+------------------------+-------------------\n
    \   systematic    |      arrival time      |  clock or timer\n    time-based    |
    \    Sampling pattern   |\n   ---------------+------------------------+-------------------\n
    \   random        |  packet position       |  packet counter,\n    n-out-of-N
    \   |  Sampling pattern      |  random numbers\n                  | (random number
    list)   |\n   ---------------+------------------------+-------------------\n    uniform
    \      |        Sampling        |  random function\n    probabilistic |      probability
    \      |\n   ---------------+------------------------+-------------------\n    non-uniform
    \  |e.g., packet position,  | selection function,\n    probabilistic |  Packet
    Content(parts) |  probability calc.\n   ---------------+------------------------+-------------------\n
    \   non-uniform   |e.g., flow state,       | selection function,\n    flow-state
    \   |  Packet Content(parts) |  probability calc.\n   ---------------+------------------------+-------------------\n
    \   property      | Packet Content(parts)  |  filter function or\n    match         |
    or router state        |  state discovery\n   ---------------+------------------------+-------------------\n
    \   hash-based    |  Packet Content(parts) |  Hash Function\n   ---------------+------------------------+-------------------\n"
  - contents:
    - "7.1.   Description of Sampling Techniques\n   In this section, we define what
      elements are needed to describe the\n   most common Sampling techniques.  Here
      the selection function is\n   predefined and given by the Selector ID.\n   Sampler
      Description:\n        SELECTOR_ID\n        SELECTOR_TYPE\n        SELECTOR_PARAMETERS\n
      \  Where:\n   SELECTOR_ID:\n   Unique ID for the packet sampler.\n   SELECTOR_TYPE:\n
      \  For Sampling processes, the SELECTOR TYPE defines what Sampling\n   algorithm
      is used.\n   Values: Systematic count-based | Systematic time-based | Random\n
      \  |n-out-of-N | uniform probabilistic | Non-uniform probabilistic |\n   Non-uniform
      flow state\n   SELECTOR_PARAMETERS:\n   For Sampling processes, the SELECTOR
      PARAMETERS define the input\n   parameters for the process.  Interval length
      in systematic Sampling\n   means that all packets that arrive in this interval
      are selected.\n   The spacing parameter defines the spacing in time or number
      of\n   packets between the end of one Sampling interval and the start of the\n
      \  next succeeding interval.\n   Case n-out-of-N:\n      - Population Size N,
      Sample size n\n   Case systematic time-based:\n      - Interval length (in usec),
      Spacing (in usec)\n   Case systematic count-based:\n      - Interval length
      (in packets), Spacing (in packets)\n   Case uniform probabilistic (with equal
      probability per packet):\n      - Sampling probability p\n   Case non-uniform
      probabilistic:\n      - Calculation function for Sampling probability p (see
      also\n        Section 5.2.2.4)\n   Case flow state:\n      - Information reported
      for flow state Sampling is not defined in\n        this document (see also Section
      5.2.2.4)\n"
    title: 7.1.   Description of Sampling Techniques
  - contents:
    - "7.2.  Description of Filtering Techniques\n   In this section, we define what
      elements are needed to describe the\n   most common Filtering techniques.  The
      structure closely parallels\n   the one presented for the Sampling techniques.\n
      \  Filter Description:\n      SELECTOR_ID\n      SELECTOR_TYPE\n      SELECTOR_PARAMETERS\n
      \  Where:\n   SELECTOR_ID:\n   Unique ID for the packet filter.  The ID can
      be calculated under\n   consideration of the SELECTION SEQUENCE and a local
      ID.\n   SELECTOR_TYPE:\n   For Filtering processes, the SELECTOR TYPE defines
      what Filtering\n   type is used.\n   Values: Matching | Hashing | Router_state\n
      \  SELECTOR_PARAMETERS:\n   For Filtering processes, the SELECTOR PARAMETERS
      define formally the\n   common property of the packet being filtered.  For the
      filters of\n   type matching and hashing, the definitions have a lot of points
      in\n   common.\n   Values:\n   Case matching:\n      - Information Element (from
      [RFC5102])\n      - Value (type in accordance to [RFC5102])\n   In case of multiple
      match criteria, multiple \"case matching\" has to\n   be bound by a logical
      AND.\n   Case hashing:\n      - Hash Domain (input bits from packet)\n           -
      <Header type = IPv4>\n           - <Input bit specification, header part>\n
      \          - <Header type =  IPv6>\n           - <Input bit specification, header
      part>\n           - <payload byte number N>\n           - <Input bit specification,
      payload part>\n      - Hash Function\n           - Hash Function name\n           -
      Length of input key (eliminate 0x bytes)\n           - Output value (length
      M and bitmask)\n           - Hash Selection Range, as a list of non-overlapping\n
      \            intervals [start value, end value] where value is in\n             [0,2^M-1]\n
      \          - Additional parameters are dependent on specific Hash\n             Function
      (e.g., hash input bits (seed))\n   Notes to input bits for case hashing:\n   -
      Input bits can be from header part only, from the payload part\n     only, or
      from both.\n   - The bit specification, for the header part, can be specified
      for\n     IPv4 or IPv6 only, or both.\n   - In case of IPv4, the bit specification
      is a sequence of 20\n     hexadecimal numbers [00,FF] specifying a 20-byte bitmask
      to be\n     applied to the header.\n   - In case of IPv6, it is a sequence of
      40 hexadecimal numbers [00,FF]\n     specifying a 40-byte bitmask to be applied
      to the header.\n   - The bit specification, for the payload part, is a sequence
      of\n     hexadecimal numbers [00,FF] specifying the bitmask to be applied to\n
      \    the first N bytes of the payload, as specified by the previous\n     field.
      \ In case the hexadecimal number sequence is longer than N,\n     only the first
      N numbers are considered.\n   - In case the payload is shorter than N, the Hash
      Function cannot be\n     applied.  Other options, like padding with zeros, may
      be considered\n     in the future.\n   - A Hash Function cannot be defined on
      the options field of the IPv4\n     header, neither on stacked headers of IPv6.\n
      \  - The Hash Selection Range defines a range of hash values (out of all\n     possible
      results of the hash operation).  If the hash result for a\n     specific packet
      falls in this range, the packet is selected.  If\n     the value is outside
      the range, the packet is not selected.  For\n     example, if the selection
      interval specification is [1:3], [6:9]\n     all packets are selected for which
      the hash result is 1,2,3,6,7,8,\n     or 9.  In all other cases, the packet
      is not selected.\n   Case router state:\n   - Ingress interface at which the
      packet arrives equals a specified\n     value\n   - Egress interface to which
      the packet is routed equals a specified\n     value\n   - Packet violated Access
      Control List (ACL) on the router\n   - Reverse Path Forwarding (RPF) failed
      for the packet\n   - Resource Reservation is insufficient for the packet\n   -
      No route is found for the packet\n   - Origin AS equals a specified value or
      lies within a given range\n   - Destination AS equals a specified value or lies
      within a given\n     range\n   Note to case router state:\n   - All router state
      entries can be linked by AND operators\n"
    title: 7.2.  Description of Filtering Techniques
  title: 7.  Parameters for the Description of Selection Techniques
- contents:
  - "8.  Composite Techniques\n   Composite schemes are realized by combining the
    Selector IDs into a\n   Selection Sequence.  The Selection Sequence contains all
    Selector IDs\n   that are applied to the Packet Stream subsequently.  Some examples
    of\n   composite schemes are reported below.\n"
  - contents:
    - "8.1.  Cascaded Filtering->Sampling or Sampling->Filtering\n   If a filter precedes
      a Sampling process, the role of Filtering is to\n   create a set of \"parent
      populations\" from a single stream that can\n   then be fed independently to
      different Sampling functions, with\n   different parameters tuned for the Population
      itself (e.g., if\n   streams of different intensity result from Filtering, it
      may be good\n   to have different Sampling rates).  If Filtering follows a Sampling\n
      \  process, the same Selection Fraction and type are applied to the\n   whole
      stream, independently of the relative size of the streams\n   resulting from
      the Filtering function.  Moreover, also packets not\n   destined to be selected
      in the Filtering operation will \"load\" the\n   Sampling function.  So, in
      principle, Filtering before Sampling\n   allows a more accurate tuning of the
      Sampling procedure, but if\n   filters are too complex to work at full line
      rate (e.g., because they\n   have to access router state information), Sampling
      before Filtering\n   may be a need.\n"
    title: 8.1.  Cascaded Filtering->Sampling or Sampling->Filtering
  - contents:
    - "8.2.  Stratified Sampling\n   Stratified Sampling is one example for using
      a composite technique.\n   The basic idea behind stratified Sampling is to increase
      the\n   estimation accuracy by using a priori information about correlations\n
      \  of the investigated characteristic with some other characteristic\n   that
      is easier to obtain.  The a priori information is used to\n   perform an intelligent
      grouping of the elements of the parent\n   Population.  In this manner, a higher
      estimation accuracy can be\n   achieved with the same sample size or the sample
      size can be reduced\n   without reducing the estimation accuracy.\n   Stratified
      Sampling divides the Sampling process into multiple steps.\n   First, the elements
      of the parent Population are grouped into subsets\n   in accordance to a given
      characteristic.  This grouping can be done\n   in multiple steps.  Then samples
      are taken from each subset.\n   The stronger the correlation between the characteristic
      used to\n   divide the parent Population (stratification variable) and the\n
      \  characteristic of interest (for which an estimate is sought after),\n   the
      easier is the consecutive Sampling process and the higher is the\n   stratification
      gain.  For instance, if the dividing characteristic\n   were equal to the investigated
      characteristic, each element of the\n   subgroup would be a perfect representative
      of that characteristic.\n   In this case, it would be sufficient to take one
      arbitrary element\n   out of each subgroup to get the actual distribution of
      the\n   characteristic in the parent Population.  Therefore, stratified\n   Sampling
      can reduce the costs for the Sampling process (i.e., the\n   number of samples
      needed to achieve a given level of confidence).\n   For stratified Sampling,
      one has to specify classification rules for\n   grouping the elements into subgroups
      and the Sampling scheme that is\n   used within the subgroups.  The classification
      rules can be expressed\n   by multiple filters.  For the Sampling scheme within
      the subgroups,\n   the parameters have to be specified as described above.  The
      use of\n   stratified Sampling methods for measurement purposes is described
      for\n   instance in [ClPB93] and [Zseb03].\n"
    title: 8.2.  Stratified Sampling
  title: 8.  Composite Techniques
- contents:
  - "9.  Security Considerations\n   Security considerations concerning the choice
    of a Hash Function for\n   Hash-based Selection have been discussed in Section
    6.2.3.  That\n   section discussed a number of potential attacks to craft Packet\n
    \  Streams that are disproportionately detected and/or discover the Hash\n   Function
    parameters, the vulnerabilities of different Hash Functions\n   to these attacks,
    and practices to minimize these vulnerabilities.\n   In addition to this, a user
    can gain knowledge about the start and\n   stop triggers in time-based systematic
    Sampling, e.g., by sending\n   test packets.  This knowledge might allow users
    to modify their send\n   schedule in a way that their packets are disproportionately
    selected\n   or not selected [GoRe07].\n   For random Sampling, a cryptographically
    strong random number\n   generator should be used in order to prevent that an
    advisory can\n   predict the selection decision [GoRe07].\n   Further security
    threats can occur when Sampling parameters are\n   configured or communicated
    to other entities.  The configuration and\n   reporting of Sampling parameters
    are out of scope of this document.\n   Therefore, the security threats that originate
    from this kind of\n   communication cannot be assessed with the information given
    in this\n   document.\n   Some of these threats can probably be addressed by keeping\n
    \  configuration information confidential and by authenticating entities\n   that
    configure Sampling.  Nevertheless, a full analysis and\n   assessment of threats
    for configuration and reporting has to be done\n   if configuration or reporting
    methods are proposed.\n"
  title: 9.  Security Considerations
- contents:
  - "10.  Contributors\n   Sharon Goldberg contributed to the security considerations
    for Hash-\n   based Selection.\n   Sharon Goldberg\n   Department of Electrical
    Engineering\n   Princeton University\n   F210-K EQuad\n   Princeton, NJ 08544,\n
    \  USA\n   EMail: goldbe@princeton.edu\n"
  title: 10.  Contributors
- contents:
  - "11.  Acknowledgments\n   We would like to thank the PSAMP group, especially Benoit
    Claise and\n   Stewart Bryant, for fruitful discussions and for proofreading the\n
    \  document.  We thank Sharon Goldberg for her input on security issues\n   concerning
    Hash-based Selection.\n"
  title: 11.  Acknowledgments
- contents:
  - '12.  References

    '
  - contents:
    - "12.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March
      1997.\n"
    title: 12.1.  Normative References
  - contents:
    - "12.2.  Informative References\n   [AmCa89]   Paul D. Amer, Lillian N. Cassel,
      \"Management of Sampled\n              Real-Time Network Measurements\", 14th
      Conference on Local\n              Computer Networks, October 1989, Minneapolis,
      pages 62-68,\n              IEEE, 1989.\n   [BeCK96]   M. Bellare, R. Canetti
      and H. Krawczyk, \"Pseudorandom\n              Functions Revisited: The Cascade
      Construction and its\n              Concrete Security\", Symposium on Foundations
      of Computer\n              Science, 1996.\n   [ClPB93]   K.C. Claffy, George
      C. Polyzos, Hans-Werner Braun,\n              \"Application of Sampling Methodologies
      to Network Traffic\n              Characterization\", Proceedings of ACM SIGCOMM'93,
      San\n              Francisco, CA, USA, September 13 - 17, 1993.\n   [DuGG02]
      \  N.G. Duffield, A. Gerber, M. Grossglauser, \"Trajectory\n              Engine:
      A Backend for Trajectory Sampling\", IEEE Network\n              Operations
      and Management Symposium 2002, Florence, Italy,\n              April 15-19,
      2002.\n   [DuGr00]   N.G. Duffield, M. Grossglauser, \"Trajectory Sampling for\n
      \             Direct Traffic Observation\", Proceedings of ACM SIGCOMM\n              2000,
      Stockholm, Sweden, August 28 - September 1, 2000.\n   [DuGr04]   N.G. Duffield
      and M. Grossglauser \"Trajectory Sampling\n              with Unreliable Reporting\",
      Proc IEEE Infocom 2004, Hong\n              Kong, March 2004.\n   [DuLT01]   N.G.
      Duffield, C. Lund, and M. Thorup, \"Charging from\n              Sampled Network
      Usage\", ACM Internet Measurement Workshop\n              IMW 2001, San Francisco,
      USA, November 1-2, 2001.\n   [EsVa01]   C. Estan and G. Varghese, \"New Directions
      in Traffic\n              Measurement and Accounting\", ACM SIGCOMM Internet\n
      \             Measurement Workshop 2001, San Francisco (CA) Nov. 2001.\n   [GoRe07]
      \  S. Goldberg, J. Rexford, \"Security Vulnerabilities and\n              Solutions
      for Packet Sampling\", IEEE Sarnoff Symposium,\n              Princeton, NJ,
      May 2007.\n   [HT52]     D.G. Horvitz and D.J. Thompson, \"A Generalization
      of\n              Sampling without replacement from a Finite Universe\" J.\n
      \             Amer. Statist. Assoc. Vol. 47, pp. 663-685, 1952.\n   [Henk08]
      \  Christian Henke, Evaluation of Hash Functions for\n              Multipoint
      Sampling in IP Networks, Diploma Thesis, TU\n              Berlin, April 2008.\n
      \  [HeSZ08]   Christian Henke, Carsten Schmoll, Tanja Zseby, Evaluation\n              of
      Header Field Entropy for Hash-Based Packet Selection,\n              Proceedings
      of Passive and Active Measurement Conference\n              PAM 2008, Cleveland,
      Ohio, USA, April 2008.\n   [Jenk97]   B. Jenkins, \"Algorithm Alley\", Dr. Dobb's
      Journal,\n              September 1997.\n              http://burtleburtle.net/bob/hash/doobs.html.\n
      \  [JePP92]   Jonathan Jedwab, Peter Phaal, Bob Pinna, \"Traffic\n              Estimation
      for the Largest Sources on a Network, Using\n              Packet Sampling with
      Limited Storage\", HP technical\n              report, Managemenr, Mathematics
      and Security Department,\n              HP Laboratories, Bristol, March 1992,\n
      \             http://www.hpl.hp.com/techreports/92/HPL-92-35.html.\n   [Moli03]
      \  M. Molina, \"A scalable and efficient methodology for flow\n              monitoring
      in the Internet\", International Teletraffic\n              Congress (ITC-18),
      Berlin, Sep. 2003.\n   [MoND05]   M. Molina, S. Niccolini, N.G. Duffield, \"A
      Comparative\n              Experimental Study of Hash Functions Applied to Packet\n
      \             Sampling\", International Teletraffic Congress (ITC-19),\n              Beijing,
      August 2005.\n   [RFC1141]  Mallory, T. and A. Kullberg, \"Incremental updating
      of the\n              Internet checksum\", RFC 1141, January 1990.\n   [RFC1624]
      \ Rijsinghani, A., Ed., \"Computation of the Internet\n              Checksum
      via Incremental Update\", RFC 1624, May 1994.\n   [RFC2205]  Braden, R., Ed.,
      Zhang, L., Berson, S., Herzog, S., and S.\n              Jamin, \"Resource ReSerVation
      Protocol (RSVP) -- Version 1\n              Functional Specification\", RFC
      2205, September 1997.\n   [RFC3704]  Baker, F. and P. Savola, \"Ingress Filtering
      for Multihomed\n              Networks\", BCP 84, RFC 3704, March 2004.\n   [RFC3917]
      \ Quittek, J., Zseby, T., Claise, B., and S. Zander,\n              \"Requirements
      for IP Flow Information Export (IPFIX)\", RFC\n              3917, October 2004.\n
      \  [RFC4271]  Rekhter, Y., Ed., Li, T., Ed., and S. Hares, Ed., \"A\n              Border
      Gateway Protocol 4 (BGP-4)\", RFC 4271, January\n              2006.\n   [RFC5101]
      \ Claise, B., Ed., \"Specification of the IP Flow Information\n              Export
      (IPFIX) Protocol for the Exchange of IP Traffic\n              Flow Information\",
      RFC 5101, January 2008.\n   [RFC5102]  Quittek, J., Bryant, S., Claise, B.,
      Aitken, P., and J.\n              Meyer, \"Information Model for IP Flow Information
      Export\",\n              RFC 5102, January 2008.\n   [RFC5474]  Duffield, N.,
      Ed., \"A Framework for Packet Selection and\n              Reporting\", RFC
      5474, March 2009.\n   [RFC5476]  Claise, B., Ed., \"Packet Sampling (PSAMP)
      Protocol\n              Specifications\", RFC 5476, March 2009.\n   [RFC5477]
      \ Dietz, T., Claise, B., Aitken, P., Dressler, F., and G.\n              Carle,
      \"Information Model for Packet Sampling Exports\",\n              RFC 5477,
      March 2009.\n   [Zseb03]   T. Zseby, \"Stratification Strategies for Sampling-based\n
      \             Non-intrusive Measurement of One-way Delay\", Proceedings\n              of
      Passive and Active Measurement Workshop (PAM 2003), La\n              Jolla,
      CA, USA, pp. 171-179, April 2003.\n   [ZsZC01]   Tanja Zseby, Sebastian Zander,
      Georg Carle.  Evaluation of\n              Building Blocks for Passive One-way-delay
      Measurements.\n              Proceedings of Passive and Active Measurement Workshop\n
      \             (PAM 2001), Amsterdam, The Netherlands, April 23-24, 2001.\n"
    title: 12.2.  Informative References
  title: 12.  References
- contents:
  - 'Appendix A.  Hash Functions

    '
  - contents:
    - "A.1.  IP Shift-XOR (IPSX) Hash Function\n   The IPSX Hash Function is tailored
      for acting on IP version 4\n   packets.  It exploits the structure of IP packets
      and in particular\n   the variability expected to be exhibited within different
      fields of\n   the IP packet in order to furnish a hash value with little apparent\n
      \  correlation with individual packet fields.  Fields from the IPv4 and\n   TCP/UDP
      headers are used as input.  The IPSX Hash Function uses a\n   small number of
      simple instructions.\n   Input parameters: None\n   Built-in parameters: None\n
      \  Output: The output of the IPSX is a 16-bit number\n   Functioning:\n   The
      functioning can be divided into two parts: input selection, whose\n   forms
      are composite input from various portions of the IP packet,\n   followed by
      computation of the hash on the composite.\n   Input Selection:\n   The raw input
      is drawn from the first 20 bytes of the IP packet\n   header and the first 8
      bytes of the IP payload.  If IP options are\n   not used, the IP header has
      20 bytes, and hence the two portions\n   adjoin and comprise the first 28 bytes
      of the IP packet.  We now use\n   the raw input as four 32-bit subportions of
      these 28 bytes.  We\n   specify the input by bit offsets from the start of IP
      header or\n   payload.\n   f1 = bits 32 to 63 of the IP header, comprising the
      IP identification\n        field, flags, and fragment offset.\n   f2 = bits
      96 to 127 of the IP header, the source IP address.\n   f3 = bits 128 to 159
      of the IP header, the destination IP address.\n   f4 = bits 32 to 63 of the
      IP payload.  For a TCP packet, f4 comprises\n        the TCP sequence number
      followed by the message length.  For a\n        UDP packet, f4 comprises the
      UDP checksum.\n   Hash Computation:\n   The hash is computed from f1, f2, f3,
      and f4 by a combination of XOR\n   (^), right shift (>>), and left shift (<<)
      operations.  The\n   intermediate quantities h1, v1, and v2 are 32-bit numbers.\n
      \     1.    v1 = f1 ^ f2;\n      2.    v2 = f3 ^ f4;\n      3.    h1 = v1 <<
      8;\n      4.    h1 ^= v1 >> 4;\n      5.    h1 ^= v1 >> 12;\n      6.    h1
      ^= v1 >> 16;\n      7.    h1 ^= v2 << 6;\n      8.    h1 ^= v2 << 10;\n      9.
      \   h1 ^= v2 << 14;\n      10.   h1 ^= v2 >> 7;\n   The output of the hash is
      the least significant 16 bits of h1.\n"
    title: A.1.  IP Shift-XOR (IPSX) Hash Function
  - contents:
    - "A.2.  BOB Hash Function\n   The BOB Hash Function is a Hash Function designed
      for having each bit\n   of the input affecting every bit of the return value
      and using both\n   1-bit and 2-bit deltas to achieve the so-called avalanche
      effect\n   [Jenk97].  This function was originally built for hash table lookup\n
      \  with fast software implementation.\n   Input parameters:\n   The input parameters
      of such a function are:\n      - the length of the input string (key) to be
      hashed, in bytes.\n        The elementary input blocks of BOB hash are the single
      bytes;\n        therefore, no padding is needed.\n      - an init value (an
      arbitrary 32-bit number).\n   Built-in parameters:\n   The BOB hash uses the
      following built-in parameter:\n      - the golden ratio (an arbitrary 32-bit
      number used in the Hash\n        Function computation: its purpose is to avoid
      mapping all zeros\n        to all zeros).\n   Note: The mix sub-function (see
      mix (a,b,c) macro in the reference\n   code below) has a number of parameters
      governing the shifts in the\n   registers.  The one presented is not the only
      possible choice.\n   It is an open point whether these may be considered additional\n
      \  built-in parameters to specify at function configuration.\n   Output:\n   The
      output of the BOB function is a 32-bit number.  It should be\n   specified:\n
      \     - A 32-bit mask to apply to the output\n      - The Selection Range as
      a list of non-overlapping intervals\n        [start value, end value] where
      value is in [0,2^32]\n   Functioning:\n   The hash value is obtained computing
      first an initialization of an\n   internal state (composed of three 32-bit numbers,
      called a, b, c in\n   the reference code below), then, for each input byte of
      the key the\n   internal state is combined by addition and mixed using the mix
      sub-\n   function.  Finally, the internal state mixed one last time and the\n
      \  third number of the state (c) is chosen as the return value.\n   typedef
      unsigned long int  ub4;   /* unsigned 4-byte quantities\n   */\n   typedef unsigned
      \     char ub1;   /* unsigned 1-byte quantities\n   */\n   #define hashsize(n)
      ((ub4)1<<(n))\n   #define hashmask(n) (hashsize(n)-1)\n   /* ------------------------------------------------------\n
      \    mix -- mix three 32-bit values reversibly.\n     For every delta with one
      or two bits set, and the deltas of\n   all three high bits or all three low
      bits, whether the original\n   value of a,b,c is almost all zero or is uniformly
      distributed,\n     * If mix() is run forward or backward, at least 32 bits in\n
      \  a,b,c have at least 1/4 probability of changing.\n     * If mix() is run
      forward, every bit of c will change between\n   1/3 and 2/3 of the time (well,
      22/100 and 78/100 for some 2-\n   bit deltas) mix() was built out of 36 single-cycle
      latency\n   instructions in a structure that could support 2x parallelism,\n
      \  like so:\n           a -= b;\n           a -= c; x = (c>>13);\n           b
      -= c; a ^= x;\n           b -= a; x = (a<<8);\n           c -= a; b ^= x;\n
      \          c -= b; x = (b>>13);\n           ...\n   Unfortunately, superscalar
      Pentiums and Sparcs can't take\n   advantage of that parallelism.  They've also
      turned some of\n   those single-cycle latency instructions into multi-cycle
      latency\n   instructions\n   ------------------------------------------------------------*/\n
      \    #define mix(a,b,c)  \\\n     { \\\n       a -= b; a -= c; a ^= (c>>13);
      \\\n       b -= c; b -= a; b ^= (a<<8); \\\n       c -= a; c -= b; c ^= (b>>13);
      \\\n       a -= b; a -= c; a ^= (c>>12);  \\\n       b -= c; b -= a; b ^= (a<<16);
      \\\n       c -= a; c -= b; c ^= (b>>5); \\\n       a -= b; a -= c; a ^= (c>>3);
      \ \\\n       b -= c; b -= a; b ^= (a<<10); \\\n       c -= a; c -= b; c ^= (b>>15);
      \\\n     }\n     /* -----------------------------------------------------------\n
      \  hash() -- hash a variable-length key into a 32-bit value\n   k       : the
      key (the unaligned variable-length array of bytes)\n   len     : the length
      of the key, counting by bytes\n   initval : can be any 4-byte value\n   Returns
      a 32-bit value.  Every bit of the key affects every bit\n   of the return value.
      \ Every 1-bit and 2-bit delta achieves\n   avalanche.  About 6*len+35 instructions.\n
      \  The best hash table sizes are powers of 2.  There is no need to do\n   mod
      a prime (mod is so slow!).  If you need less than 32 bits, use a\n   bitmask.
      \ For example, if you need only 10 bits, do h = (h &\n   hashmask(10)), in which
      case, the hash table should have hashsize(10)\n   elements.\n   If you are hashing
      n strings (ub1 **)k, do it like this: for (i=0,\n   h=0; i<n; ++i) h = hash(
      k[i], len[i], h);\n   By Bob Jenkins, 1996.  bob_jenkins@burtleburtle.net.  You
      may use\n   this code any way you wish, private, educational, or commercial.\n
      \  It's free.  See http://burtleburtle.net/bob/hash/evahash.html.\n   Use for
      hash table lookup, or anything where one collision in 2^^32\n   is acceptable.
      \ Do NOT use for cryptographic purposes.\n    -----------------------------------------------------------
      */\n     ub4 bob_hash(k, length, initval)\n     register ub1 *k;        /* the
      key */\n     register ub4  length;   /* the length of the key */\n     register
      ub4  initval;  /* an arbitrary value */\n     {\n        register ub4 a,b,c,len;\n
      \       /* Set up the internal state */\n        len = length;\n        a =
      b = 0x9e3779b9; /*the golden ratio; an arbitrary value\n   */\n        c = initval;
      \        /* another arbitrary value */\n   /*------------------------------------
      handle most of the key */\n        while (len >= 12)\n        {\n           a
      += (k[0] +((ub4)k[1]<<8) +((ub4)k[2]<<16)\n   +((ub4)k[3]<<24));\n           b
      += (k[4] +((ub4)k[5]<<8) +((ub4)k[6]<<16)\n   +((ub4)k[7]<<24));\n           c
      += (k[8] +((ub4)k[9]<<8)\n   +((ub4)k[10]<<16)+((ub4)k[11]<<24));\n           mix(a,b,c);\n
      \          k += 12; len -= 12;\n        }\n        /*----------------------------
      handle the last 11 bytes */\n        c += length;\n        switch(len)       /*
      all the case statements fall through*/\n        {\n        case 11: c+=((ub4)k[10]<<24);\n
      \       case 10: c+=((ub4)k[9]<<16);\n        case 9 : c+=((ub4)k[8]<<8);\n
      \          /* the first byte of c is reserved for the length */\n        case
      8 : b+=((ub4)k[7]<<24);\n        case 7 : b+=((ub4)k[6]<<16);\n        case
      6 : b+=((ub4)k[5]<<8);\n        case 5 : b+=k[4];\n        case 4 : a+=((ub4)k[3]<<24);\n
      \       case 3 : a+=((ub4)k[2]<<16);\n        case 2 : a+=((ub4)k[1]<<8);\n
      \       case 1 : a+=k[0];\n          /* case 0: nothing left to add */\n        }\n
      \       mix(a,b,c);\n        /*-------------------------------- report the result
      */\n        return c;\n     }\n"
    title: A.2.  BOB Hash Function
  title: Appendix A.  Hash Functions
- contents:
  - "Authors' Addresses\n   Tanja Zseby\n   Fraunhofer Institute for Open Communication
    Systems\n   Kaiserin-Augusta-Allee 31\n   10589 Berlin\n   Germany\n   Phone:
    +49-30-34 63 7153\n   EMail: tanja.zseby@fokus.fraunhofer.de\n   Maurizio Molina\n
    \  DANTE\n   City House\n   126-130 Hills Road\n   Cambridge CB21PQ\n   United
    Kingdom\n   Phone: +44 1223 371 300\n   EMail: maurizio.molina@dante.org.uk\n
    \  Nick Duffield\n   AT&T Labs - Research\n   Room B-139\n   180 Park Ave\n   Florham
    Park, NJ 07932\n   USA\n   Phone: +1 973-360-8726\n   EMail: duffield@research.att.com\n
    \  Saverio Niccolini\n   Network Laboratories, NEC Europe Ltd.\n   Kurfuerstenanlage
    36\n   69115 Heidelberg\n   Germany\n   Phone: +49-6221-9051118\n   EMail:  saverio.niccolini@netlab.nec.de\n
    \  Frederic Raspall\n   EPSC-UPC\n   Dept. of Telematics\n   Av. del Canal Olimpic,
    s/n\n   Edifici C4\n   E-08860 Castelldefels, Barcelona\n   Spain\n   EMail: fredi@entel.upc.es\n"
  title: Authors' Addresses
