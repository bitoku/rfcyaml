- title: __initial_text__
  contents:
  - ''
- title: Independent Submission                                     J. Chroboczek
  contents:
  - "Independent Submission                                     J. Chroboczek\n  \
    \                     The Babel Routing Protocol\n"
- title: Abstract
  contents:
  - "Abstract\n   Babel is a loop-avoiding distance-vector routing protocol that is\n\
    \   robust and efficient both in ordinary wired networks and in wireless\n   mesh\
    \ networks.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for examination, experimental implementation, and\n   evaluation.\n\
    \   This document defines an Experimental Protocol for the Internet\n   community.\
    \  This is a contribution to the RFC Series, independently\n   of any other RFC\
    \ stream.  The RFC Editor has chosen to publish this\n   document at its discretion\
    \ and makes no statement about its value for\n   implementation or deployment.\
    \  Documents approved for publication by\n   the RFC Editor are not a candidate\
    \ for any level of Internet\n   Standard; see Section 2 of RFC 5741.\n   Information\
    \ about the current status of this document, any errata,\n   and how to provide\
    \ feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6126.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2011 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  3\n     1.1.  Features . . . . . . . . . . . . . . . . . . . .\
    \ . . . . .  3\n     1.2.  Limitations  . . . . . . . . . . . . . . . . . . .\
    \ . . . .  4\n     1.3.  Specification of Requirements  . . . . . . . . . . .\
    \ . . .  4\n   2.  Conceptual Description of the Protocol . . . . . . . . . .\
    \ . .  4\n     2.1.  Costs, Metrics, and Neighbourship  . . . . . . . . . . .\
    \ .  5\n     2.2.  The Bellman-Ford Algorithm . . . . . . . . . . . . . . . .\
    \  5\n     2.3.  Transient Loops in Bellman-Ford  . . . . . . . . . . . . .  6\n\
    \     2.4.  Feasibility Conditions . . . . . . . . . . . . . . . . . .  6\n  \
    \   2.5.  Solving Starvation: Sequencing Routes  . . . . . . . . . .  8\n    \
    \ 2.6.  Requests . . . . . . . . . . . . . . . . . . . . . . . . .  9\n     2.7.\
    \  Multiple Routers . . . . . . . . . . . . . . . . . . . . . 10\n     2.8.  Overlapping\
    \ Prefixes . . . . . . . . . . . . . . . . . . . 11\n   3.  Protocol Operation\
    \ . . . . . . . . . . . . . . . . . . . . . . 11\n     3.1.  Message Transmission\
    \ and Reception . . . . . . . . . . . . 11\n     3.2.  Data Structures  . . .\
    \ . . . . . . . . . . . . . . . . . . 12\n     3.3.  Acknowledged Packets . .\
    \ . . . . . . . . . . . . . . . . . 15\n     3.4.  Neighbour Acquisition  . .\
    \ . . . . . . . . . . . . . . . . 15\n     3.5.  Routing Table Maintenance  .\
    \ . . . . . . . . . . . . . . . 17\n     3.6.  Route Selection  . . . . . . .\
    \ . . . . . . . . . . . . . . 21\n     3.7.  Sending Updates  . . . . . . . .\
    \ . . . . . . . . . . . . . 22\n     3.8.  Explicit Route Requests  . . . . .\
    \ . . . . . . . . . . . . 24\n   4.  Protocol Encoding  . . . . . . . . . . .\
    \ . . . . . . . . . . . 27\n     4.1.  Data Types . . . . . . . . . . . . . .\
    \ . . . . . . . . . . 28\n     4.2.  Packet Format  . . . . . . . . . . . . .\
    \ . . . . . . . . . 29\n     4.3.  TLV Format . . . . . . . . . . . . . . . .\
    \ . . . . . . . . 29\n     4.4.  Details of Specific TLVs . . . . . . . . . .\
    \ . . . . . . . 30\n   5.  IANA Considerations  . . . . . . . . . . . . . . .\
    \ . . . . . . 39\n   6.  Security Considerations  . . . . . . . . . . . . . .\
    \ . . . . . 39\n   7.  References . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . 40\n     7.1.  Normative References . . . . . . . . . . . . . . . .\
    \ . . . 40\n     7.2.  Informative References . . . . . . . . . . . . . . . .\
    \ . . 40\n   Appendix A.  Cost and Metric Computation . . . . . . . . . . . .\
    \ . 41\n     A.1.  Maintaining Hello History  . . . . . . . . . . . . . . . .\
    \ 41\n     A.2.  Cost Computation . . . . . . . . . . . . . . . . . . . . . 42\n\
    \     A.3.  Metric Computation . . . . . . . . . . . . . . . . . . . . 43\n  \
    \ Appendix B.  Constants . . . . . . . . . . . . . . . . . . . . . . 43\n   Appendix\
    \ C.  Simplified Implementations  . . . . . . . . . . . . . 44\n   Appendix D.\
    \  Software Availability . . . . . . . . . . . . . . . . 45\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Babel is a loop-avoiding distance-vector routing protocol\
    \ that is\n   designed to be robust and efficient both in networks using prefix-\n\
    \   based routing and in networks using flat routing (\"mesh networks\"),\n  \
    \ and both in relatively stable wired networks and in highly dynamic\n   wireless\
    \ networks.\n"
- title: 1.1.  Features
  contents:
  - "1.1.  Features\n   The main property that makes Babel suitable for unstable networks\
    \ is\n   that, unlike naive distance-vector routing protocols [RIP], it\n   strongly\
    \ limits the frequency and duration of routing pathologies\n   such as routing\
    \ loops and black-holes during reconvergence.  Even\n   after a mobility event\
    \ is detected, a Babel network usually remains\n   loop-free.  Babel then quickly\
    \ reconverges to a configuration that\n   preserves the loop-freedom and connectedness\
    \ of the network, but is\n   not necessarily optimal; in many cases, this operation\
    \ requires no\n   packet exchanges at all.  Babel then slowly converges, in a\
    \ time on\n   the scale of minutes, to an optimal configuration.  This is achieved\n\
    \   by using sequenced routes, a technique pioneered by Destination-\n   Sequenced\
    \ Distance-Vector routing [DSDV].\n   More precisely, Babel has the following\
    \ properties:\n   o  when every prefix is originated by at most one router, Babel\
    \ never\n      suffers from routing loops;\n   o  when a prefix is originated\
    \ by multiple routers, Babel may\n      occasionally create a transient routing\
    \ loop for this particular\n      prefix; this loop disappears in a time proportional\
    \ to its\n      diameter, and never again (up to an arbitrary garbage-collection\n\
    \      (GC) time) will the routers involved participate in a routing loop\n  \
    \    for the same prefix;\n   o  assuming reasonable packet loss rates, any routing\
    \ black-holes\n      that may appear after a mobility event are corrected in a\
    \ time at\n      most proportional to the network's diameter.\n   Babel has provisions\
    \ for link quality estimation and for fairly\n   arbitrary metrics.  When configured\
    \ suitably, Babel can implement\n   shortest-path routing, or it may use a metric\
    \ based, for example, on\n   measured packet loss.\n   Babel nodes will successfully\
    \ establish an association even when they\n   are configured with different parameters.\
    \  For example, a mobile node\n   that is low on battery may choose to use larger\
    \ time constants (hello\n   and update intervals, etc.) than a node that has access\
    \ to wall\n   power.  Conversely, a node that detects high levels of mobility\
    \ may\n   choose to use smaller time constants.  The ability to build such\n \
    \  heterogeneous networks makes Babel particularly adapted to the\n   wireless\
    \ environment.\n   Finally, Babel is a hybrid routing protocol, in the sense that\
    \ it can\n   carry routes for multiple network-layer protocols (IPv4 and IPv6),\n\
    \   whichever protocol the Babel packets are themselves being carried\n   over.\n"
- title: 1.2.  Limitations
  contents:
  - "1.2.  Limitations\n   Babel has two limitations that make it unsuitable for use\
    \ in some\n   environments.  First, Babel relies on periodic routing table updates\n\
    \   rather than using a reliable transport; hence, in large, stable\n   networks\
    \ it generates more traffic than protocols that only send\n   updates when the\
    \ network topology changes.  In such networks,\n   protocols such as OSPF [OSPF],\
    \ IS-IS [IS-IS], or the Enhanced\n   Interior Gateway Routing Protocol (EIGRP)\
    \ [EIGRP] might be more\n   suitable.\n   Second, Babel does impose a hold time\
    \ when a prefix is retracted\n   (Section 3.5.5).  While this hold time does not\
    \ apply to the exact\n   prefix being retracted, and hence does not prevent fast\
    \ reconvergence\n   should it become available again, it does apply to any shorter\
    \ prefix\n   that covers it.  Hence, if a previously deaggregated prefix becomes\n\
    \   aggregated, it will be unreachable for a few minutes.  This makes\n   Babel\
    \ unsuitable for use in mobile networks that implement automatic\n   prefix aggregation.\n"
- title: 1.3.  Specification of Requirements
  contents:
  - "1.3.  Specification of Requirements\n   The key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in [RFC2119].\n"
- title: 2.  Conceptual Description of the Protocol
  contents:
  - "2.  Conceptual Description of the Protocol\n   Babel is a mostly loop-free distance\
    \ vector protocol: it is based on\n   the Bellman-Ford protocol, just like the\
    \ venerable RIP [RIP], but\n   includes a number of refinements that either prevent\
    \ loop formation\n   altogether, or ensure that a loop disappears in a timely\
    \ manner and\n   doesn't form again.\n   Conceptually, Bellman-Ford is executed\
    \ in parallel for every source\n   of routing information (destination of data\
    \ traffic).  In the\n   following discussion, we fix a source S; the reader will\
    \ recall that\n   the same algorithm is executed for all sources.\n"
- title: 2.1.  Costs, Metrics, and Neighbourship
  contents:
  - "2.1.  Costs, Metrics, and Neighbourship\n   As many routing algorithms, Babel\
    \ computes costs of links between any\n   two neighbouring nodes, abstract values\
    \ attached to the edges between\n   two nodes.  We write C(A, B) for the cost\
    \ of the edge from node A to\n   node B.\n   Given a route between any two nodes,\
    \ the metric of the route is the\n   sum of the costs of all the edges along the\
    \ route.  The goal of the\n   routing algorithm is to compute, for every source\
    \ S, the tree of the\n   routes of lowest metric to S.\n   Costs and metrics need\
    \ not be integers.  In general, they can be\n   values in any algebra that satisfies\
    \ two fairly general conditions\n   (Section 3.5.2).\n   A Babel node periodically\
    \ broadcasts Hello messages to all of its\n   neighbours; it also periodically\
    \ sends an IHU (\"I Heard You\") message\n   to every neighbour from which it\
    \ has recently heard a Hello.  From\n   the information derived from Hello and\
    \ IHU messages received from its\n   neighbour B, a node A computes the cost C(A,\
    \ B) of the link from A to\n   B.\n"
- title: 2.2.  The Bellman-Ford Algorithm
  contents:
  - "2.2.  The Bellman-Ford Algorithm\n   Every node A maintains two pieces of data:\
    \ its estimated distance to\n   S, written D(A), and its next-hop router to S,\
    \ written NH(A).\n   Initially, D(S) = 0, D(A) is infinite, and NH(A) is undefined.\n\
    \   Periodically, every node B sends to all of its neighbours a route\n   update,\
    \ a message containing D(B).  When a neighbour A of B receives\n   the route update,\
    \ it checks whether B is its selected next hop; if\n   that is the case, then\
    \ NH(A) is set to B, and D(A) is set to C(A, B)\n   + D(B).  If that is not the\
    \ case, then A compares C(A, B) + D(B) to\n   its current value of D(A).  If that\
    \ value is smaller, meaning that\n   the received update advertises a route that\
    \ is better than the\n   currently selected route, then NH(A) is set to B, and\
    \ D(A) is set to\n   C(A, B) + D(B).\n   A number of refinements to this algorithm\
    \ are possible, and are used\n   by Babel.  In particular, convergence speed may\
    \ be increased by\n   sending unscheduled \"triggered updates\" whenever a major\
    \ change in\n   the topology is detected, in addition to the regular, scheduled\n\
    \   updates.  Additionally, a node may maintain a number of alternate\n   routes,\
    \ which are being advertised by neighbours other than its\n   selected neighbour,\
    \ and which can be used immediately if the selected\n   route were to fail.\n"
- title: 2.3.  Transient Loops in Bellman-Ford
  contents:
  - "2.3.  Transient Loops in Bellman-Ford\n   It is well known that a naive application\
    \ of Bellman-Ford to\n   distributed routing can cause transient loops after a\
    \ topology\n   change.  Consider for example the following diagram:\n        \
    \    B\n         1 /|\n      1   / |\n   S --- A  |1\n          \\ |\n       \
    \  1 \\|\n            C\n   After convergence, D(B) = D(C) = 2, with NH(B) = NH(C)\
    \ = A.\n   Suppose now that the link between S and A fails:\n            B\n \
    \        1 /|\n          / |\n   S     A  |1\n          \\ |\n         1 \\|\n\
    \            C\n   When it detects the failure of the link, A switches its next\
    \ hop to B\n   (which is still advertising a route to S with metric 2), and\n\
    \   advertises a metric equal to 3, and then advertises a new route with\n   metric\
    \ 3.  This process of nodes changing selected neighbours and\n   increasing their\
    \ metric continues until the advertised metric reaches\n   \"infinity\", a value\
    \ larger than all the metrics that the routing\n   protocol is able to carry.\n"
- title: 2.4.  Feasibility Conditions
  contents:
  - "2.4.  Feasibility Conditions\n   Bellman-Ford is a very robust algorithm: its\
    \ convergence properties\n   are preserved when routers delay route acquisition\
    \ or when they\n   discard some updates.  Babel routers discard received route\n\
    \   announcements unless they can prove that accepting them cannot\n   possibly\
    \ cause a routing loop.\n   More formally, we define a condition over route announcements,\
    \ known\n   as the feasibility condition, that guarantees the absence of routing\n\
    \   loops whenever all routers ignore route updates that do not satisfy\n   the\
    \ feasibility condition.  In effect, this makes Bellman-Ford into a\n   family\
    \ of routing algorithms, parameterised by the feasibility\n   condition.\n   Many\
    \ different feasibility conditions are possible.  For example, BGP\n   can be\
    \ modelled as being a distance-vector protocol with a (rather\n   drastic) feasibility\
    \ condition: a routing update is only accepted\n   when the receiving node's AS\
    \ number is not included in the update's\n   AS-Path attribute (note that BGP's\
    \ feasibility condition does not\n   ensure the absence of transitory \"micro-loops\"\
    \ during reconvergence).\n   Another simple feasibility condition, used in Destination-Sequenced\n\
    \   Distance-Vector (DSDV) routing [DSDV] and in Ad hoc On-Demand\n   Distance\
    \ Vector (AODV) routing, stems from the following observation:\n   a routing loop\
    \ can only arise after a router has switched to a route\n   with a larger metric\
    \ than the route that it had previously selected.\n   Hence, one could decide\
    \ that a route is feasible only when its metric\n   at the local node would be\
    \ no larger than the metric of the currently\n   selected route, i.e., an announcement\
    \ carrying a metric D(B) is\n   accepted by A when C(A, B) + D(B) <= D(A).  If\
    \ all routers obey this\n   constraint, then the metric at every router is nonincreasing,\
    \ and the\n   following invariant is always preserved: if A has selected B as\
    \ its\n   successor, then D(B) < D(A), which implies that the forwarding graph\n\
    \   is loop-free.\n   Babel uses a slightly more refined feasibility condition,\
    \ used in\n   EIGRP [DUAL].  Given a router A, define the feasibility distance\
    \ of\n   A, written FD(A), as the smallest metric that A has ever advertised\n\
    \   for S to any of its neighbours.  An update sent by a neighbour B of A\n  \
    \ is feasible when the metric D(B) advertised by B is strictly smaller\n   than\
    \ A's feasibility distance, i.e., when D(B) < FD(A).\n   It is easy to see that\
    \ this latter condition is no more restrictive\n   than DSDV-feasibility.  Suppose\
    \ that node A obeys DSDV-feasibility;\n   then D(A) is nonincreasing, hence at\
    \ all times D(A) <= FD(A).\n   Suppose now that A receives a DSDV-feasible update\
    \ that advertises a\n   metric D(B).  Since the update is DSDV-feasible, C(A,\
    \ B) + D(B) <=\n   D(A), hence D(B) < D(A), and since D(A) <= FD(A), D(B) < FD(A).\n\
    \   To see that it is strictly less restrictive, consider the following\n   diagram,\
    \ where A has selected the route through B, and D(A) = FD(A) =\n   2.  Since D(C)\
    \ = 1 < FD(A), the alternate route through C is feasible\n   for A, although its\
    \ metric C(A, C) + D(C) = 5 is larger than that of\n   the currently selected\
    \ route:\n      B\n   1 / \\ 1\n    /   \\\n   S     A\n    \\   /\n   1 \\ /\
    \ 4\n      C\n   To show that this feasibility condition still guarantees loop-\n\
    \   freedom, recall that at the time when A accepts an update from B, the\n  \
    \ metric D(B) announced by B is no smaller than FD(B); since it is\n   smaller\
    \ than FD(A), at that point in time FD(B) < FD(A).  Since this\n   property is\
    \ preserved when A sends updates, it remains true at all\n   times, which ensures\
    \ that the forwarding graph has no loops.\n"
- title: '2.5.  Solving Starvation: Sequencing Routes'
  contents:
  - "2.5.  Solving Starvation: Sequencing Routes\n   Obviously, the feasibility conditions\
    \ defined above cause starvation\n   when a router runs out of feasible routes.\
    \  Consider the following\n   diagram, where both A and B have selected the direct\
    \ route to S:\n      A\n   1 /|        D(A) = 1\n    / |       FD(A) = 1\n   S\
    \  |1\n    \\ |        D(B) = 2\n   2 \\|       FD(B) = 2\n      B\n   Suppose\
    \ now that the link between A and S breaks:\n      A\n      |\n      |       FD(A)\
    \ = 1\n   S  |1\n    \\ |        D(B) = 2\n   2 \\|       FD(B) = 2\n      B\n\
    \   The only route available from A to S, the one that goes through B, is\n  \
    \ not feasible: A suffers from a spurious starvation.\n   At this point, the whole\
    \ network must be rebooted in order to solve\n   the starvation; this is essentially\
    \ what EIGRP does when it performs\n   a global synchronisation of all the routers\
    \ in the network with the\n   source (the \"active\" phase of EIGRP).\n   Babel\
    \ reacts to starvation in a less drastic manner, by using\n   sequenced routes,\
    \ a technique introduced by DSDV and adopted by AODV.\n   In addition to a metric,\
    \ every route carries a sequence number, a\n   nondecreasing integer that is propagated\
    \ unchanged through the\n   network and is only ever incremented by the source;\
    \ a pair (s, m),\n   where s is a sequence number and m a metric, is called a\
    \ distance.\n   A received update is feasible when either it is more recent than\
    \ the\n   feasibility distance maintained by the receiving node, or it is\n  \
    \ equally recent and the metric is strictly smaller.  More formally, if\n   FD(A)\
    \ = (s, m), then an update carrying the distance (s', m') is\n   feasible when\
    \ either s' > s, or s = s' and m' < m.\n   Assuming the sequence number of S is\
    \ 137, the diagram above becomes:\n      A\n      |\n      |       FD(A) = (137,\
    \ 1)\n   S  |1\n    \\ |        D(B) = (137, 2)\n   2 \\|       FD(B) = (137,\
    \ 2)\n      B\n   After S increases its sequence number, and the new sequence\
    \ number is\n   propagated to B, we have:\n      A\n      |\n      |       FD(A)\
    \ = (137, 1)\n   S  |1\n    \\ |        D(B) = (138, 2)\n   2 \\|       FD(B)\
    \ = (138, 2)\n      B\n   at which point the route through B becomes feasible\
    \ again.\n   Note that while sequence numbers are used for determining\n   feasibility,\
    \ they are not necessarily used in route selection: a node\n   will normally ignore\
    \ the sequence number when selecting a route\n   (Section 3.6).\n"
- title: 2.6.  Requests
  contents:
  - "2.6.  Requests\n   In DSDV, the sequence number of a source is increased periodically.\n\
    \   A route becomes feasible again after the source increases its\n   sequence\
    \ number, and the new sequence number is propagated through\n   the network, which\
    \ may, in general, require a significant amount of\n   time.\n   Babel takes a\
    \ different approach.  When a node detects that it is\n   suffering from a potentially\
    \ spurious starvation, it sends an\n   explicit request to the source for a new\
    \ sequence number.  This\n   request is forwarded hop by hop to the source, with\
    \ no regard to the\n   feasibility condition.  Upon receiving the request, the\
    \ source\n   increases its sequence number and broadcasts an update, which is\n\
    \   forwarded to the requesting node.\n   Note that after a change in network\
    \ topology not all such requests\n   will, in general, reach the source, as some\
    \ will be sent over links\n   that are now broken.  However, if the network is\
    \ still connected,\n   then at least one among the nodes suffering from spurious\
    \ starvation\n   has an (unfeasible) route to the source; hence, in the absence\
    \ of\n   packet loss, at least one such request will reach the source.\n   (Resending\
    \ requests a small number of times compensates for packet\n   loss.)\n   Since\
    \ requests are forwarded with no regard to the feasibility\n   condition, they\
    \ may, in general, be caught in a forwarding loop; this\n   is avoided by having\
    \ nodes perform duplicate detection for the\n   requests that they forward.\n"
- title: 2.7.  Multiple Routers
  contents:
  - "2.7.  Multiple Routers\n   The above discussion assumes that every prefix is\
    \ originated by a\n   single router.  In real networks, however, it is often necessary\
    \ to\n   have a single prefix originated by multiple routers; for example, the\n\
    \   default route will be originated by all of the edge routers of a\n   routing\
    \ domain.\n   Since synchronising sequence numbers between distinct routers is\n\
    \   problematic, Babel treats routes for the same prefix as distinct\n   entities\
    \ when they are originated by different routers: every route\n   announcement\
    \ carries the router-id of its originating router, and\n   feasibility distances\
    \ are not maintained per prefix, but per source,\n   where a source is a pair\
    \ of a router-id and a prefix.  In effect,\n   Babel guarantees loop-freedom for\
    \ the forwarding graph to every\n   source; since the union of multiple acyclic\
    \ graphs is not in general\n   acyclic, Babel does not in general guarantee loop-freedom\
    \ when a\n   prefix is originated by multiple routers, but any loops will be\n\
    \   broken in a time at most proportional to the diameter of the loop --\n   as\
    \ soon as an update has \"gone around\" the routing loop.\n   Consider for example\
    \ the following diagram, where A has selected the\n   default route through S,\
    \ and B has selected the one through S':\n              1     1     1\n   ::/0\
    \ -- S --- A --- B --- S' -- ::/0\n   Suppose that both default routes fail at\
    \ the same time; then nothing\n   prevents A from switching to B, and B simultaneously\
    \ switching to A.\n   However, as soon as A has successfully advertised the new\
    \ route to B,\n   the route through A will become unfeasible for B.  Conversely,\
    \ as\n   soon as B will have advertised the route through A, the route through\n\
    \   B will become unfeasible for A.\n   In effect, the routing loop disappears\
    \ at the latest when routing\n   information has gone around the loop.  Since\
    \ this process can be\n   delayed by lost packets, Babel makes certain efforts\
    \ to ensure that\n   updates are sent reliably after a router-id change.\n   Additionally,\
    \ after the routers have advertised the two routes, both\n   sources will be in\
    \ their source tables, which will prevent them from\n   ever again participating\
    \ in a routing loop involving routes from S\n   and S' (up to the source GC time,\
    \ which, available memory permitting,\n   can be set to arbitrarily large values).\n"
- title: 2.8.  Overlapping Prefixes
  contents:
  - "2.8.  Overlapping Prefixes\n   In the above discussion, we have assumed that\
    \ all prefixes are\n   disjoint, as is the case in flat (\"mesh\") routing.  In\
    \ practice,\n   however, prefixes may overlap: for example, the default route\n\
    \   overlaps with all of the routes present in the network.\n   After a route\
    \ fails, it is not correct in general to switch to a\n   route that subsumes the\
    \ failed route.  Consider for example the\n   following configuration:\n     \
    \         1     1\n   ::/0 -- A --- B --- C\n   Suppose that node C fails.  If\
    \ B forwards packets destined to C by\n   following the default route, a routing\
    \ loop will form, and persist\n   until A learns of B's retraction of the direct\
    \ route to C.  Babel\n   avoids this pitfall by maintaining an \"unreachable\"\
    \ route for a few\n   minutes after a route is retracted; the time for which such\
    \ a route\n   must be maintained should be the worst-case propagation time of\
    \ the\n   retraction of the route to C.\n"
- title: 3.  Protocol Operation
  contents:
  - "3.  Protocol Operation\n   Every Babel speaker is assigned a router-id, which\
    \ is an arbitrary\n   string of 8 octets that is assumed unique across the routing\
    \ domain.\n   We suggest that router-ids should be assigned in modified EUI-64\n\
    \   format [ADDRARCH].  (As a matter of fact, the protocol encoding is\n   slightly\
    \ more compact when router-ids are assigned in the same manner\n   as the IPv6\
    \ layer assigns host IDs.)\n"
- title: 3.1.  Message Transmission and Reception
  contents:
  - "3.1.  Message Transmission and Reception\n   Babel protocol packets are sent\
    \ in the body of a UDP datagram.  Each\n   Babel packet consists of one or more\
    \ TLVs.\n   The source address of a Babel packet is always a unicast address,\n\
    \   link-local in the case of IPv6.  Babel packets may be sent to a well-\n  \
    \ known (link-local) multicast address (this is the usual case) or to a\n   (link-local)\
    \ unicast address.  In normal operation, a Babel speaker\n   sends both multicast\
    \ and unicast packets to its neighbours.\n   With the exception of Hello TLVs\
    \ and acknowledgements, all Babel TLVs\n   can be sent to either unicast or multicast\
    \ addresses, and their\n   semantics does not depend on whether the destination\
    \ was a unicast or\n   multicast address.  Hence, a Babel speaker does not need\
    \ to determine\n   the destination address of a packet that it receives in order\
    \ to\n   interpret it.\n   A moderate amount of jitter is applied to packets sent\
    \ by a Babel\n   speaker: outgoing TLVs are buffered and SHOULD be sent with a\
    \ small\n   random delay.  This is done for two purposes: it avoids\n   synchronisation\
    \ of multiple Babel speakers across a network [JITTER],\n   and it allows for\
    \ the aggregation of multiple TLVs into a single\n   packet.\n   The exact delay\
    \ and amount of jitter applied to a packet depends on\n   whether it contains\
    \ any urgent TLVs.  Acknowledgement TLVs MUST be\n   sent before the deadline\
    \ specified in the corresponding request.  The\n   particular class of updates\
    \ specified in Section 3.7.2 MUST be sent\n   in a timely manner.  The particular\
    \ class of request and update TLVs\n   specified in Section 3.8.2 SHOULD be sent\
    \ in a timely manner.\n"
- title: 3.2.  Data Structures
  contents:
  - "3.2.  Data Structures\n   Every Babel speaker maintains a number of data structures.\n"
- title: 3.2.1.  Sequence Number
  contents:
  - "3.2.1.  Sequence Number\n   A node's sequence number is a 16-bit integer that\
    \ is included in\n   route updates sent for routes originated by this node.  A\
    \ node\n   increments its sequence number (modulo 2^16) whenever it receives a\n\
    \   request for a new sequence number (Section 3.8.1.2).\n   A node SHOULD NOT\
    \ increment its sequence number (seqno)\n   spontaneously, since increasing seqnos\
    \ makes it less likely that\n   other nodes will have feasible alternate routes\
    \ when their selected\n   routes fail.\n"
- title: 3.2.2.  The Interface Table
  contents:
  - "3.2.2.  The Interface Table\n   The interface table contains the list of interfaces\
    \ on which the node\n   speaks the Babel protocol.  Every interface table entry\
    \ contains the\n   interface's Hello seqno, a 16-bit integer that is sent with\
    \ each\n   Hello TLV on this interface and is incremented (modulo 2^16) whenever\n\
    \   a Hello is sent.  (Note that an interface's Hello seqno is unrelated\n   to\
    \ the node's seqno.)\n   There are two timers associated with each interface table\
    \ entry --\n   the Hello timer, which governs the sending of periodic Hello and\
    \ IHU\n   packets, and the update timer, which governs the sending of periodic\n\
    \   route updates.\n"
- title: 3.2.3.  The Neighbour Table
  contents:
  - "3.2.3.  The Neighbour Table\n   The neighbour table contains the list of all\
    \ neighbouring interfaces\n   from which a Babel packet has been recently received.\
    \  The neighbour\n   table is indexed by pairs of the form (interface, address),\
    \ and every\n   neighbour table entry contains the following data:\n   o  the\
    \ local node's interface over which this neighbour is reachable;\n   o  the address\
    \ of the neighbouring interface;\n   o  a history of recently received Hello packets\
    \ from this neighbour;\n      this can, for example, be a sequence of n bits,\
    \ for some small\n      value n, indicating which of the n hellos most recently\
    \ sent by\n      this neighbour have been received by the local node;\n   o  the\
    \ \"transmission cost\" value from the last IHU packet received\n      from this\
    \ neighbour, or FFFF hexadecimal (infinity) if the IHU\n      hold timer for this\
    \ neighbour has expired;\n   o  the neighbour's expected Hello sequence number,\
    \ an integer modulo\n      2^16.\n   There are two timers associated with each\
    \ neighbour entry -- the\n   hello timer, which is initialised from the interval\
    \ value carried by\n   Hello TLVs, and the IHU timer, which is initialised to\
    \ a small\n   multiple of the interval carried in IHU TLVs.\n   Note that the\
    \ neighbour table is indexed by IP addresses, not by\n   router-ids: neighbourship\
    \ is a relationship between interfaces, not\n   between nodes.  Therefore, two\
    \ nodes with multiple interfaces can\n   participate in multiple neighbourship\
    \ relationships, a fairly common\n   situation when wireless nodes with multiple\
    \ radios are involved.\n"
- title: 3.2.4.  The Source Table
  contents:
  - "3.2.4.  The Source Table\n   The source table is used to record feasibility distances.\
    \  It is\n   indexed by triples of the form (prefix, plen, router-id), and every\n\
    \   source table entry contains the following data:\n   o  the prefix (prefix,\
    \ plen), where plen is the prefix length, that\n      this entry applies to;\n\
    \   o  the router-id of a router originating this prefix;\n   o  a pair (seqno,\
    \ metric), this source's feasibility distance.\n   There is one timer associated\
    \ with each entry in the source table --\n   the source garbage-collection timer.\
    \  It is initialised to a time on\n   the order of minutes and reset as specified\
    \ in Section 3.7.3.\n"
- title: 3.2.5.  The Route Table
  contents:
  - "3.2.5.  The Route Table\n   The route table contains the routes known to this\
    \ node.  It is\n   indexed by triples of the form (prefix, plen, neighbour), and\
    \ every\n   route table entry contains the following data:\n   o  the source (prefix,\
    \ plen, router-id) for which this route is\n      advertised;\n   o  the neighbour\
    \ that advertised this route;\n   o  the metric with which this route was advertised\
    \ by the neighbour,\n      or FFFF hexadecimal (infinity) for a recently retracted\
    \ route;\n   o  the sequence number with which this route was advertised;\n  \
    \ o  the next-hop address of this route;\n   o  a boolean flag indicating whether\
    \ this route is selected, i.e.,\n      whether it is currently being used for\
    \ forwarding and is being\n      advertised.\n   There is one timer associated\
    \ with each route table entry -- the\n   route expiry timer.  It is initialised\
    \ and reset as specified in\n   Section 3.5.4.\n"
- title: 3.2.6.  The Table of Pending Requests
  contents:
  - "3.2.6.  The Table of Pending Requests\n   The table of pending requests contains\
    \ a list of seqno requests that\n   the local node has sent (either because they\
    \ have been originated\n   locally, or because they were forwarded) and to which\
    \ no reply has\n   been received yet.  This table is indexed by prefixes, and\
    \ every\n   entry in this table contains the following data:\n   o  the prefix,\
    \ router-id, and seqno being requested;\n   o  the neighbour, if any, on behalf\
    \ of which we are forwarding this\n      request;\n   o  a small integer indicating\
    \ the number of times that this request\n      will be resent if it remains unsatisfied.\n\
    \   There is one timer associated with each pending request; it governs\n   both\
    \ the resending of requests and their expiry.\n"
- title: 3.3.  Acknowledged Packets
  contents:
  - "3.3.  Acknowledged Packets\n   A Babel speaker may request that any neighbour\
    \ receiving a given\n   packet reply with an explicit acknowledgement within a\
    \ given time.\n   While the use of acknowledgement requests is optional, every\
    \ Babel\n   speaker MUST be able to reply to such a request.\n   An acknowledgement\
    \ MUST be sent to a unicast destination.  On the\n   other hand, acknowledgement\
    \ requests may be sent to either unicast or\n   multicast destinations, in which\
    \ case they request an acknowledgement\n   from all of the receiving nodes.\n\
    \   When to request acknowledgements is a matter of local policy; the\n   simplest\
    \ strategy is to never request acknowledgements and to rely on\n   periodic updates\
    \ to ensure that any reachable routes are eventually\n   propagated throughout\
    \ the routing domain.  For increased efficiency,\n   we suggest that acknowledged\
    \ packets should be used in order to send\n   urgent updates (Section 3.7.2) when\
    \ the number of neighbours on a\n   given interface is small.  Since Babel is\
    \ designed to deal gracefully\n   with packet loss on unreliable media, sending\
    \ all packets with\n   acknowledgement requests is not necessary, and not even\
    \ recommended,\n   as the acknowledgements cause additional traffic and may force\n\
    \   additional Address Resolution Protocol (ARP) or Neighbour Discovery\n   exchanges.\n"
- title: 3.4.  Neighbour Acquisition
  contents:
  - "3.4.  Neighbour Acquisition\n   Neighbour acquisition is the process by which\
    \ a Babel node discovers\n   the set of neighbours heard over each of its interfaces\
    \ and\n   ascertains bidirectional reachability.  On unreliable media,\n   neighbour\
    \ acquisition additionally provides some statistics that MAY\n   be used in link\
    \ quality computation.\n"
- title: 3.4.1.  Reverse Reachability Detection
  contents:
  - "3.4.1.  Reverse Reachability Detection\n   Every Babel node sends periodic Hellos\
    \ over each of its interfaces.\n   Each Hello TLV carries an increasing (modulo\
    \ 2^16) sequence number\n   and the interval between successive periodic packets\
    \ sent on this\n   particular interface.\n   In addition to the periodic Hello\
    \ packets, a node MAY send\n   unscheduled Hello packets, e.g., to accelerate\
    \ link cost estimation\n   when a new neighbour is discovered, or when link conditions\
    \ have\n   suddenly changed.\n   A node MAY change its Hello interval.  The Hello\
    \ interval MAY be\n   decreased at any time; it SHOULD NOT be increased, except\
    \ immediately\n   before sending a Hello packet.  (Equivalently, a node SHOULD\
    \ send an\n   unscheduled Hello immediately after increasing its Hello interval.)\n\
    \   How to deal with received Hello TLVs and what statistics to maintain\n   are\
    \ considered local implementation matters; typically, a node will\n   maintain\
    \ some sort of history of recently received Hellos.  A\n   possible algorithm\
    \ is described in Appendix A.1.\n   After receiving a Hello, or determining that\
    \ it has missed one, the\n   node recomputes the association's cost (Section 3.4.3)\
    \ and runs the\n   route selection procedure (Section 3.6).\n"
- title: 3.4.2.  Bidirectional Reachability Detection
  contents:
  - "3.4.2.  Bidirectional Reachability Detection\n   In order to establish bidirectional\
    \ reachability, every node sends\n   periodic IHU (\"I Heard You\") TLVs to each\
    \ of its neighbours.  Since\n   IHUs carry an explicit interval value, they MAY\
    \ be sent less often\n   than Hellos in order to reduce the amount of routing\
    \ traffic in dense\n   networks; in particular, they SHOULD be sent less often\
    \ than Hellos\n   over links with little packet loss.  While IHUs are conceptually\n\
    \   unicast, they SHOULD be sent to a multicast address in order to avoid\n  \
    \ an ARP or Neighbour Discovery exchange and to aggregate multiple IHUs\n   in\
    \ a single packet.\n   In addition to the periodic IHUs, a node MAY, at any time,\
    \ send an\n   unscheduled IHU packet.  It MAY also, at any time, decrease its\
    \ IHU\n   interval, and it MAY increase its IHU interval immediately before\n\
    \   sending an IHU.\n   Every IHU TLV contains two pieces of data: the link's\
    \ rxcost\n   (reception cost) from the sender's perspective, used by the neighbour\n\
    \   for computing link costs (Section 3.4.3), and the interval between\n   periodic\
    \ IHU packets.  A node receiving an IHU updates the value of\n   the sending neighbour's\
    \ txcost (transmission cost), from its\n   perspective, to the value contained\
    \ in the IHU, and resets this\n   neighbour's IHU timer to a small multiple of\
    \ the value received in\n   the IHU.\n   When a neighbour's IHU timer expires,\
    \ its txcost is set to infinity.\n   After updating a neighbour's txcost, the\
    \ receiving node recomputes\n   the neighbour's cost (Section 3.4.3) and runs\
    \ the route selection\n   procedure (Section 3.6).\n"
- title: 3.4.3.  Cost Computation
  contents:
  - "3.4.3.  Cost Computation\n   A neighbourship association's link cost is computed\
    \ from the values\n   maintained in the neighbour table -- namely, the statistics\
    \ kept in\n   the neighbour table about the reception of Hellos, and the txcost\n\
    \   computed from received IHU packets.\n   For every neighbour, a Babel node\
    \ computes a value known as this\n   neighbour's rxcost.  This value is usually\
    \ derived from the Hello\n   history, which may be combined with other data, such\
    \ as statistics\n   maintained by the link layer.  The rxcost is sent to a neighbour\
    \ in\n   each IHU.\n   How the txcost and rxcost are combined in order to compute\
    \ a link's\n   cost is a matter of local policy; as far as Babel's correctness\
    \ is\n   concerned, only the following conditions MUST be satisfied:\n   o  the\
    \ cost is strictly positive;\n   o  if no hellos were received recently, then\
    \ the cost is infinite;\n   o  if the txcost is infinite, then the cost is infinite.\n\
    \   Note that while this document does not constrain cost computation any\n  \
    \ further, not all cost computation strategies will give good results.\n   We\
    \ give a few examples of strategies for computing a link's cost that\n   are known\
    \ to work well in practice in Appendix A.2.\n"
- title: 3.5.  Routing Table Maintenance
  contents:
  - "3.5.  Routing Table Maintenance\n   Conceptually, a Babel update is a quintuple\
    \ (prefix, plen, router-id,\n   seqno, metric), where (prefix, plen) is the prefix\
    \ for which a route\n   is being advertised, router-id is the router-id of the\
    \ router\n   originating this update, seqno is a nondecreasing (modulo 2^16)\n\
    \   integer that carries the originating router seqno, and metric is the\n   announced\
    \ metric.\n   Before being accepted, an update is checked against the feasibility\n\
    \   condition (Section 3.5.1), which ensures that the route does not\n   create\
    \ a routing loop.  If the feasibility condition is not\n   satisfied, the update\
    \ is either ignored or treated as a retraction,\n   depending on some other conditions\
    \ (Section 3.5.4).  If the\n   feasibility condition is satisfied, then the update\
    \ cannot possibly\n   cause a routing loop, and the update is accepted.\n"
- title: 3.5.1.  The Feasibility Condition
  contents:
  - "3.5.1.  The Feasibility Condition\n   The feasibility condition is applied to\
    \ all received updates.  The\n   feasibility condition compares the metric in\
    \ the received update with\n   the metrics of the updates previously sent by the\
    \ receiving node;\n   updates with finite metrics large enough to cause a loop\
    \ are\n   discarded.\n   A feasibility distance is a pair (seqno, metric), where\
    \ seqno is an\n   integer modulo 2^16 and metric is a positive integer.  Feasibility\n\
    \   distances are compared lexicographically, with the first component\n   inverted:\
    \ we say that a distance (seqno, metric) is strictly better\n   than a distance\
    \ (seqno', metric'), written\n      (seqno, metric) < (seqno', metric')\n   when\n\
    \      seqno > seqno' or (seqno = seqno' and metric < metric')\n   where sequence\
    \ numbers are compared modulo 2^16.\n   Given a source (p, plen, id), a node's\
    \ feasibility distance for this\n   source is the minimum, according to the ordering\
    \ defined above, of\n   the distances of all the finite updates ever sent by this\
    \ particular\n   node for the prefix (p, plen) carrying the router-id id.  Feasibility\n\
    \   distances are maintained in the source table; the exact procedure is\n   given\
    \ in Section 3.7.3.\n   A received update is feasible when either it is a retraction\
    \ (its\n   metric is FFFF hexadecimal), or the advertised distance is strictly\n\
    \   better, in the sense defined above, than the feasibility distance for\n  \
    \ the corresponding source.  More precisely, a route advertisement\n   carrying\
    \ the quintuple (prefix, plen, router-id, seqno, metric) is\n   feasible if one\
    \ of the following conditions holds:\n   o  metric is infinite; or\n   o  no entry\
    \ exists in the source table indexed by (id, prefix, plen);\n      or\n   o  an\
    \ entry (prefix, plen, router-id, seqno', metric') exists in the\n      source\
    \ table, and either\n      *  seqno' < seqno or\n      *  seqno = seqno' and metric\
    \ < metric'.\n   Note that the feasibility condition considers the metric advertised\n\
    \   by the neighbour, not the route's metric; hence, a fluctuation in a\n   neighbour's\
    \ cost cannot render a selected route unfeasible.\n"
- title: 3.5.2.  Metric Computation
  contents:
  - "3.5.2.  Metric Computation\n   A route's metric is computed from the metric advertised\
    \ by the\n   neighbour and the neighbour's link cost.  Just like cost computation,\n\
    \   metric computation is considered a local policy matter; as far as\n   Babel\
    \ is concerned, the function M(c, m) used for computing a metric\n   from a locally\
    \ computed link cost and the metric advertised by a\n   neighbour MUST only satisfy\
    \ the following conditions:\n   o  if c is infinite, then M(c, m) is infinite;\n\
    \   o  M is strictly monotonic: M(c, m) > m.\n   Additionally, the metric SHOULD\
    \ satisfy the following condition:\n   o  M is isotonic: if m <= m', then M(c,\
    \ m) <= M(c, m').\n   Note that while strict monotonicity is essential to the\
    \ integrity of\n   the network (persistent routing loops may appear if it is not\n\
    \   satisfied), isotonicity is not: if it is not satisfied, Babel will\n   still\
    \ converge to a locally optimal routing table, but might not\n   reach a global\
    \ optimum (in fact, such a global optimum may not even\n   exist).\n   As with\
    \ cost computation, not all strategies for computing route\n   metrics will give\
    \ good results.  In particular, some metrics are more\n   likely than others to\
    \ lead to routing instabilities (route flapping).\n   In Appendix A.3, we give\
    \ a number of examples of strictly monotonic,\n   isotonic routing metrics that\
    \ are known to work well in practice.\n"
- title: 3.5.3.  Encoding of Updates
  contents:
  - "3.5.3.  Encoding of Updates\n   In a large network, the bulk of Babel traffic\
    \ consists of route\n   updates; hence, some care has been given to encoding them\n\
    \   efficiently.  An Update TLV itself only contains the prefix, seqno,\n   and\
    \ metric, while the next hop is derived either from the network-\n   layer source\
    \ address of the packet or from an explicit Next Hop TLV\n   in the same packet.\
    \  The router-id is derived from a separate\n   Router-Id TLV in the same packet,\
    \ which optimises the case when\n   multiple updates are sent with the same router-id.\n\
    \   Additionally, a prefix of the advertised prefix can be omitted in an\n   Update\
    \ TLV, in which case it is copied from a previous Update TLV in\n   the same packet\
    \ -- this is known as address compression [PACKETBB].\n   Finally, as a special\
    \ optimisation for the case when a router-id\n   coincides with the interface-id\
    \ part of an IPv6 address, the\n   router-id can optionally be derived from the\
    \ low-order bits of the\n   advertised prefix.\n   The encoding of updates is\
    \ described in detail in Section 4.4.\n"
- title: 3.5.4.  Route Acquisition
  contents:
  - "3.5.4.  Route Acquisition\n   When a Babel node receives an update (id, prefix,\
    \ seqno, metric) from\n   a neighbour neigh with a link cost value equal to cost,\
    \ it checks\n   whether it already has a routing table entry indexed by (neigh,\
    \ id,\n   prefix).\n   If no such entry exists:\n   o  if the update is unfeasible,\
    \ it is ignored;\n   o  if the metric is infinite (the update is a retraction),\
    \ the update\n      is ignored;\n   o  otherwise, a new route table entry is created,\
    \ indexed by (neigh,\n      id, prefix), with seqno equal to seqno and an advertised\
    \ metric\n      equal to the metric carried by the update.\n   If such an entry\
    \ exists:\n   o  if the entry is currently installed and the update is unfeasible,\n\
    \      then the behaviour depends on whether the router-ids of the two\n     \
    \ entries match.  If the router-ids are different, the update is\n      treated\
    \ as though it were a retraction (i.e., as though the metric\n      were FFFF\
    \ hexadecimal).  If the router-ids are equal, the update\n      is ignored;\n\
    \   o  otherwise (i.e., if either the update is feasible or the entry is\n   \
    \   not currently installed), then the entry's sequence number,\n      advertised\
    \ metric, metric, and router-id are updated and, unless\n      the advertised\
    \ metric is infinite, the route's expiry timer is\n      reset to a small multiple\
    \ of the Interval value included in the\n      update.\n   When a route's expiry\
    \ timer triggers, the behaviour depends on\n   whether the route's metric is finite.\
    \  If the metric is finite, it is\n   set to infinity and the expiry timer is\
    \ reset.  If the metric is\n   already infinite, the route is flushed from the\
    \ route table.\n   After the routing table is updated, the route selection procedure\n\
    \   (Section 3.6) is run.\n"
- title: 3.5.5.  Hold Time
  contents:
  - "3.5.5.  Hold Time\n   When a prefix p is retracted, because all routes are unfeasible,\
    \ too\n   old, or have an infinite metric, and a shorter prefix p' that covers\n\
    \   p is reachable, p' cannot in general be used for routing packets\n   destined\
    \ to p without running the risk of creating a routing loop\n   (Section 2.8).\n\
    \   To avoid this issue, whenever a prefix is retracted, a routing table\n   entry\
    \ with infinite metric is maintained as described in\n   Section 3.5.4 above,\
    \ and packets destined for that prefix MUST NOT be\n   forwarded by following\
    \ a route for a shorter prefix.  The infinite\n   metric entry is maintained until\
    \ it is superseded by a feasible\n   update; if no such update arrives within\
    \ the route hold time, the\n   entry is flushed.\n"
- title: 3.6.  Route Selection
  contents:
  - "3.6.  Route Selection\n   Route selection is the process by which a single route\
    \ for a given\n   prefix is selected to be used for forwarding packets and to\
    \ be\n   re-advertised to a node's neighbours.\n   Babel is designed to allow\
    \ flexible route selection policies.  As far\n   as the protocol's correctness\
    \ is concerned, the route selection\n   policy MUST only satisfy the following\
    \ properties:\n   o  a route with infinite metric (a retracted route) is never\n\
    \      selected;\n   o  an unfeasible route is never selected.\n   Note, however,\
    \ that Babel does not naturally guarantee the stability\n   of routing, and configuring\
    \ conflicting route selection policies on\n   different routers may lead to persistent\
    \ route oscillation.\n   Defining a good route selection policy for Babel is an\
    \ open research\n   problem.  Route selection can take into account multiple mutually\n\
    \   contradictory criteria; in roughly decreasing order of importance,\n   these\
    \ are:\n   o  routes with a small metric should be preferred over routes with\
    \ a\n      large metric;\n   o  switching router-ids should be avoided;\n   o\
    \  routes through stable neighbours should be preferred over routes\n      through\
    \ unstable ones;\n   o  stable routes should be preferred over unstable ones;\n\
    \   o  switching next hops should be avoided.\n   A simple strategy is to choose\
    \ the feasible route with the smallest\n   metric, with a small amount of hysteresis\
    \ applied to avoid switching\n   router-ids.\n   After the route selection procedure\
    \ is run, triggered updates\n   (Section 3.7.2) and requests (Section 3.8.2) are\
    \ sent.\n"
- title: 3.7.  Sending Updates
  contents:
  - "3.7.  Sending Updates\n   A Babel speaker advertises to its neighbours its set\
    \ of selected\n   routes.  Normally, this is done by sending one or more multicast\n\
    \   packets containing Update TLVs on all of its connected interfaces;\n   however,\
    \ on link technologies where multicast is significantly more\n   expensive than\
    \ unicast, a node MAY choose to send multiple copies of\n   updates in unicast\
    \ packets when the number of neighbours is small.\n   Additionally, in order to\
    \ ensure that any black-holes are reliably\n   cleared in a timely manner, a Babel\
    \ node sends retractions (updates\n   with an infinite metric) for any recently\
    \ retracted prefixes.\n   If an update is for a route injected into the Babel\
    \ domain by the\n   local node (e.g., the address of a local interface, the prefix\
    \ of a\n   directly attached network, or redistributed from a different routing\n\
    \   protocol), the router-id is set to the local id, the metric is set to\n  \
    \ some arbitrary finite value (typically 0), and the seqno is set to\n   the local\
    \ router's sequence number.\n   If an update is for a route learned from another\
    \ Babel speaker, the\n   router-id and sequence number are copied from the routing\
    \ table\n   entry, and the metric is computed as specified in Section 3.5.2.\n"
- title: 3.7.1.  Periodic Updates
  contents:
  - "3.7.1.  Periodic Updates\n   Every Babel speaker periodically advertises all\
    \ of its selected\n   routes on all of its interfaces, including any recently\
    \ retracted\n   routes.  Since Babel doesn't suffer from routing loops (there\
    \ is no\n   \"counting to infinity\") and relies heavily on triggered updates\n\
    \   (Section 3.7.2), this full dump only needs to happen infrequently.\n"
- title: 3.7.2.  Triggered Updates
  contents:
  - "3.7.2.  Triggered Updates\n   In addition to the periodic routing updates, a\
    \ Babel speaker sends\n   unscheduled, or triggered, updates in order to inform\
    \ its neighbours\n   of a significant change in the network topology.\n   A change\
    \ of router-id for the selected route to a given prefix may be\n   indicative\
    \ of a routing loop in formation; hence, a node MUST send a\n   triggered update\
    \ in a timely manner whenever it changes the selected\n   router-id for a given\
    \ destination.  Additionally, it SHOULD make a\n   reasonable attempt at ensuring\
    \ that all neighbours receive this\n   update.\n   There are two strategies for\
    \ ensuring that.  If the number of\n   neighbours is small, then it is reasonable\
    \ to send the update\n   together with an acknowledgement request; the update\
    \ is resent until\n   all neighbours have acknowledged the packet, up to some\
    \ number of\n   times.  If the number of neighbours is large, however, requesting\n\
    \   acknowledgements from all of them might cause a non-negligible amount\n  \
    \ of network traffic; in that case, it may be preferable to simply\n   repeat\
    \ the update some reasonable number of times (say, 5 for\n   wireless and 2 for\
    \ wired links).\n   A route retraction is somewhat less worrying: if the route\
    \ retraction\n   doesn't reach all neighbours, a black-hole might be created,\
    \ which,\n   unlike a routing loop, does not endanger the integrity of the\n \
    \  network.  When a route is retracted, a node SHOULD send a triggered\n   update\
    \ and SHOULD make a reasonable attempt at ensuring that all\n   neighbours receive\
    \ this retraction.\n   Finally, a node MAY send a triggered update when the metric\
    \ for a\n   given prefix changes in a significant manner, either due to a\n  \
    \ received update or because a link cost has changed.  A node SHOULD\n   NOT send\
    \ triggered updates for other reasons, such as when there is a\n   minor fluctuation\
    \ in a route's metric, when the selected next hop\n   changes, or to propagate\
    \ a new sequence number (except to satisfy a\n   request, as specified in Section\
    \ 3.8).\n"
- title: 3.7.3.  Maintaining Feasibility Distances
  contents:
  - "3.7.3.  Maintaining Feasibility Distances\n   Before sending an update (prefix,\
    \ plen, router-id, seqno, metric)\n   with finite metric (i.e., not a route retraction),\
    \ a Babel node\n   updates the feasibility distance maintained in the source table.\n\
    \   This is done as follows.\n   If no entry indexed by (prefix, plen, router-id)\
    \ exists in the source\n   table, then one is created with value (prefix, plen,\
    \ router-id,\n   seqno, metric).\n   If an entry (prefix, plen, router-id, seqno',\
    \ metric') exists, then\n   it is updated as follows:\n   o  if seqno > seqno',\
    \ then seqno' := seqno, metric' := metric;\n   o  if seqno = seqno' and metric'\
    \ > metric, then metric' := metric;\n   o  otherwise, nothing needs to be done.\n\
    \   The garbage-collection timer for the modified entry is then reset.\n   Note\
    \ that the garbage-collection timer is not reset when a retraction\n   is sent.\n"
- title: 3.7.4.  Split Horizon
  contents:
  - "3.7.4.  Split Horizon\n   When running over a transitive, symmetric link technology,\
    \ e.g., a\n   point-to-point link or a wired LAN technology such as Ethernet,\
    \ a\n   Babel node SHOULD use an optimisation known as split horizon.  When\n\
    \   split horizon is used on a given interface, a routing update is not\n   sent\
    \ on this particular interface when the advertised route was\n   learnt from a\
    \ neighbour over the same interface.\n   Split horizon SHOULD NOT be applied to\
    \ an interface unless the\n   interface is known to be symmetric and transitive;\
    \ in particular,\n   split horizon is not applicable to decentralised wireless\
    \ link\n   technologies (e.g., IEEE 802.11 in ad hoc mode).\n"
- title: 3.8.  Explicit Route Requests
  contents:
  - "3.8.  Explicit Route Requests\n   In normal operation, a node's routing table\
    \ is populated by the\n   regular and triggered updates sent by its neighbours.\
    \  Under some\n   circumstances, however, a node sends explicit requests to cause\
    \ a\n   resynchronisation with the source after a mobility event or to\n   prevent\
    \ a route from spuriously expiring.\n   The Babel protocol provides two kinds\
    \ of explicit requests: route\n   requests, which simply request an update for\
    \ a given prefix, and\n   seqno requests, which request an update for a given\
    \ prefix with a\n   specific sequence number.  The former are never forwarded;\
    \ the latter\n   are forwarded if they cannot be satisfied by a neighbour.\n"
- title: 3.8.1.  Handling Requests
  contents:
  - "3.8.1.  Handling Requests\n   Upon receiving a request, a node either forwards\
    \ the request or sends\n   an update in reply to the request, as described in\
    \ the following\n   sections.  If this causes an update to be sent, the update\
    \ is either\n   sent to a multicast address on the interface on which the request\
    \ was\n   received, or to the unicast address of the neighbour that sent the\n\
    \   update.\n   The exact behaviour is different for route requests and seqno\n\
    \   requests.\n"
- title: 3.8.1.1.  Route Requests
  contents:
  - "3.8.1.1.  Route Requests\n   When a node receives a route request for a prefix\
    \ (prefix, plen), it\n   checks its route table for a selected route to this exact\
    \ prefix.  If\n   such a route exists, it MUST send an update; if such a route\
    \ does\n   not, it MUST send a retraction for that prefix.\n   When a node receives\
    \ a wildcard route request, it SHOULD send a full\n   routing table dump.\n"
- title: 3.8.1.2.  Seqno Requests
  contents:
  - "3.8.1.2.  Seqno Requests\n   When a node receives a seqno request for a given\
    \ router-id and\n   sequence number, it checks whether its routing table contains\
    \ a\n   selected entry for that prefix; if no such entry exists, or the entry\n\
    \   has infinite metric, it ignores the request.\n   If a selected route for the\
    \ given prefix exists, and either the\n   router-ids are different or the router-ids\
    \ are equal and the entry's\n   sequence number is no smaller than the requested\
    \ sequence number, it\n   MUST send an update for the given prefix.\n   If the\
    \ router-ids match but the requested seqno is larger than the\n   route entry's,\
    \ the node compares the router-id against its own\n   router-id.  If the router-id\
    \ is its own, then it increases its\n   sequence number by 1 and sends an update.\
    \  A node MUST NOT increase\n   its sequence number by more than 1 in response\
    \ to a route request.\n   If the requested router-id is not its own, the received\
    \ request's hop\n   count is 2 or more, and the node has a route (not necessarily\
    \ a\n   feasible one) for the requested prefix that does not use the\n   requestor\
    \ as a next hop, the node SHOULD forward the request.  It\n   does so by decreasing\
    \ the hop count and sending the request in a\n   unicast packet destined to a\
    \ neighbour that advertises the given\n   prefix (not necessarily the selected\
    \ neighbour) and that is distinct\n   from the neighbour from which the request\
    \ was received.\n   A node SHOULD maintain a list of recently forwarded requests\
    \ and\n   forward the reply in a timely manner.  A node SHOULD compare every\n\
    \   incoming request against its list of recently forwarded requests and\n   avoid\
    \ forwarding it if it is redundant.\n   Since the request-forwarding mechanism\
    \ does not necessarily obey the\n   feasibility condition, it may get caught in\
    \ routing loops; hence,\n   requests carry a hop count to limit the time for which\
    \ they remain in\n   the network.  However, since requests are only ever forwarded\
    \ as\n   unicast packets, the initial hop count need not be kept particularly\n\
    \   low, and performing an expanding horizon search is not necessary.  A\n   request\
    \ MUST NOT be forwarded to a multicast address, and it MUST be\n   forwarded to\
    \ a single neighbour only.\n"
- title: 3.8.2.  Sending Requests
  contents:
  - "3.8.2.  Sending Requests\n   A Babel node MAY send a route or seqno request at\
    \ any time, to a\n   multicast or a unicast address; there is only one case when\n\
    \   originating requests is required (Section 3.8.2.1).\n"
- title: 3.8.2.1.  Avoiding Starvation
  contents:
  - "3.8.2.1.  Avoiding Starvation\n   When a route is retracted or expires, a Babel\
    \ node usually switches\n   to another feasible route for the same prefix.  It\
    \ may be the case,\n   however, that no such routes are available.\n   A node\
    \ that has lost all feasible routes to a given destination MUST\n   send a seqno\
    \ request.  The router-id of the request is set to the\n   router-id of the route\
    \ that it has just lost, and the requested seqno\n   is the value contained in\
    \ the source table, plus 1.\n   Such a request SHOULD be multicast over all of\
    \ the node's attached\n   interfaces.  Similar requests will be sent by other\
    \ nodes that are\n   affected by the route's loss and will be forwarded by neighbouring\n\
    \   nodes up to the source.  If the network is connected, and there is no\n  \
    \ packet loss, this will result in a route being advertised with a new\n   sequence\
    \ number.  (Note that, due to duplicate suppression, only a\n   small number of\
    \ such requests will actually reach the source.)\n   In order to compensate for\
    \ packet loss, a node SHOULD repeat such a\n   request a small number of times\
    \ if no route becomes feasible within a\n   short time.  Under heavy packet loss,\
    \ however, all such requests may\n   be lost; in that case, the second mechanism\
    \ in the next section will\n   eventually ensure that a new seqno is received.\n"
- title: 3.8.2.2.  Dealing with Unfeasible Updates
  contents:
  - "3.8.2.2.  Dealing with Unfeasible Updates\n   When a route's metric increases,\
    \ a node might receive an unfeasible\n   update for a route that it has currently\
    \ selected.  As specified in\n   Section 3.5.1, the receiving node will either\
    \ ignore the update or\n   retract the route.\n   In order to keep routes from\
    \ spuriously expiring because they have\n   become unfeasible, a node SHOULD send\
    \ a unicast seqno request\n   whenever it receives an unfeasible update for a\
    \ route that is\n   currently selected.  The requested sequence number is computed\
    \ from\n   the source table as above.\n   Additionally, a node SHOULD send a unicast\
    \ seqno request whenever it\n   receives an unfeasible update from a currently\
    \ unselected neighbour\n   that is \"good enough\", i.e., that would lead to the\
    \ received route\n   becoming selected were it feasible.\n"
- title: 3.8.2.3.  Preventing Routes from Expiring
  contents:
  - "3.8.2.3.  Preventing Routes from Expiring\n   In normal operation, a route's\
    \ expiry timer should never trigger:\n   since a route's hold time is computed\
    \ from an explicit interval\n   included in Update TLVs, a new update should arrive\
    \ in time to\n   prevent a route from expiring.\n   In the presence of packet\
    \ loss, however, it may be the case that no\n   update is successfully received\
    \ for an extended period of time,\n   causing a route to expire.  In order to\
    \ avoid such spurious expiry,\n   shortly before a selected route expires, a Babel\
    \ node SHOULD send a\n   unicast route request to the neighbour that advertised\
    \ this route;\n   since nodes always send retractions in response to non-wildcard\
    \ route\n   requests (Section 3.8.1.1), this will usually result in either the\n\
    \   route being refreshed or a retraction being received.\n"
- title: 3.8.2.4.  Acquiring New Neighbours
  contents:
  - "3.8.2.4.  Acquiring New Neighbours\n   In order to speed up convergence after\
    \ a mobility event, a node MAY\n   send a unicast wildcard request after acquiring\
    \ a new neighbour.\n   Additionally, a node MAY send a small number of multicast\
    \ wildcard\n   requests shortly after booting.\n"
- title: 4.  Protocol Encoding
  contents:
  - "4.  Protocol Encoding\n   A Babel packet is sent as the body of a UDP datagram,\
    \ with network-\n   layer hop count set to 1, destined to a well-known multicast\
    \ address\n   or to a unicast address, over IPv4 or IPv6; in the case of IPv6,\n\
    \   these addresses are link-local.  Both the source and destination UDP\n   port\
    \ are set to a well-known port number.  A Babel packet MUST be\n   silently ignored\
    \ unless its source address is either a link-local\n   IPv6 address, or an IPv4\
    \ address belonging to the local network, and\n   its source port is the well-known\
    \ Babel port.  Babel packets MUST NOT\n   be sent as IPv6 Jumbograms.\n   In order\
    \ to minimise the number of packets being sent while avoiding\n   lower-layer\
    \ fragmentation, a Babel node SHOULD attempt to maximise\n   the size of the packets\
    \ it sends, up to the outgoing interface's MTU\n   adjusted for lower-layer headers\
    \ (28 octets for UDP/IPv4, 48 octets\n   for UDP/IPv6).  It MUST NOT send packets\
    \ larger than the attached\n   interface's MTU (adjusted for lower-layer headers)\
    \ or 512 octets,\n   whichever is larger, but not exceeding 2^16 - 1 adjusted\
    \ for lower-\n   layer headers.  Every Babel speaker MUST be able to receive packets\n\
    \   that are as large as any attached interface's MTU (adjusted for\n   lower-layer\
    \ headers) or 512 octets, whichever is larger.\n   In order to avoid global synchronisation\
    \ of a Babel network and to\n   aggregate multiple TLVs into large packets, a\
    \ Babel node MUST buffer\n   every TLV and delay sending a UDP packet by a small,\
    \ randomly chosen\n   delay [JITTER].  In order to allow accurate computation\
    \ of packet\n   loss rates, this delay MUST NOT be larger than half the advertised\n\
    \   Hello interval.\n"
- title: 4.1.  Data Types
  contents:
  - '4.1.  Data Types

    '
- title: 4.1.1.  Interval
  contents:
  - "4.1.1.  Interval\n   Relative times are carried as 16-bit values specifying a\
    \ number of\n   centiseconds (hundredths of a second).  This allows times up to\n\
    \   roughly 11 minutes with a granularity of 10 ms, which should cover\n   all\
    \ reasonable applications of Babel.\n"
- title: 4.1.2.  Router-Id
  contents:
  - "4.1.2.  Router-Id\n   A router-id is an arbitrary 8-octet value.  Router-ids\
    \ SHOULD be\n   assigned in modified EUI-64 format [ADDRARCH].\n"
- title: 4.1.3.  Address
  contents:
  - "4.1.3.  Address\n   Since the bulk of the protocol is taken by addresses, multiple\
    \ ways\n   of encoding addresses are defined.  Additionally, a common subnet\n\
    \   prefix may be omitted when multiple addresses are sent in a single\n   packet\
    \ -- this is known as address compression [PACKETBB].\n   Address encodings:\n\
    \   o  AE 0: wildcard address.  The value is 0 octets long.\n   o  AE 1: IPv4\
    \ address.  Compression is allowed. 4 octets or less.\n   o  AE 2: IPv6 address.\
    \  Compression is allowed. 16 octets or less.\n   o  AE 3: link-local IPv6 address.\
    \  The value is 8 octets long, a\n      prefix of fe80::/64 is implied.\n   The\
    \ address family of an address is either IPv4 or IPv6; it is\n   undefined for\
    \ AE 0, IPv4 for AE 1, and IPv6 for AE 2 and 3.\n"
- title: 4.1.4.  Prefixes
  contents:
  - "4.1.4.  Prefixes\n   A network prefix is encoded just like a network address,\
    \ but it is\n   stored in the smallest number of octets that are enough to hold\
    \ the\n   significant bits (up to the prefix length).\n"
- title: 4.2.  Packet Format
  contents:
  - "4.2.  Packet Format\n   A Babel packet consists of a 4-octet header, followed\
    \ by a sequence\n   of TLVs.\n   0                   1                   2   \
    \                3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     Magic     |    Version    |        Body length            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   Packet Body ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-\n   Fields :\n   Magic\
    \     The arbitrary but carefully chosen value 42 (decimal);\n             packets\
    \ with a first octet different from 42 MUST be\n             silently ignored.\n\
    \   Version   This document specifies version 2 of the Babel protocol.\n     \
    \        Packets with a second octet different from 2 MUST be\n             silently\
    \ ignored.\n   Body length  The length in octets of the body following the packet\n\
    \                header.\n   Body      The packet body; a sequence of TLVs.\n\
    \   Any data following the body MUST be silently ignored.\n"
- title: 4.3.  TLV Format
  contents:
  - "4.3.  TLV Format\n   With the exception of Pad1, all TLVs have the following\
    \ structure:\n   0                   1                   2                   3\n\
    \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     Type      |    Length     |     Body...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\n\
    \   Fields :\n   Type      The type of the TLV.\n   Length    The length of the\
    \ body, exclusive of the Type and Length\n             fields.  If the body is\
    \ longer than the expected length of\n             a given type of TLV, any extra\
    \ data MUST be silently\n             ignored.\n   Body      The TLV body, the\
    \ interpretation of which depends on the\n             type.\n   TLVs with an\
    \ unknown type value MUST be silently ignored.\n"
- title: 4.4.  Details of Specific TLVs
  contents:
  - '4.4.  Details of Specific TLVs

    '
- title: 4.4.1.  Pad1
  contents:
  - "4.4.1.  Pad1\n   0\n   0 1 2 3 4 5 6 7\n   +-+-+-+-+-+-+-+-+\n   |   Type = 0\
    \    |\n   +-+-+-+-+-+-+-+-+\n   Fields :\n   Type      Set to 0 to indicate a\
    \ Pad1 TLV.\n   This TLV is silently ignored on reception.\n"
- title: 4.4.2.  PadN
  contents:
  - "4.4.2.  PadN\n   0                   1                   2                  \
    \ 3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    Type = 1   |    Length     |      MBZ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\n\
    \   Fields :\n   Type      Set to 1 to indicate a PadN TLV.\n   Length    The\
    \ length of the body, exclusive of the Type and Length\n             fields.\n\
    \   MBZ       Set to 0 on transmission.\n   This TLV is silently ignored on reception.\n"
- title: 4.4.3.  Acknowledgement Request
  contents:
  - "4.4.3.  Acknowledgement Request\n   0                   1                   2\
    \                   3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    Type = 2   |    Length     |          Reserved             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Nonce              |          Interval             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   This TLV requests that the receiver send an Acknowledgement TLV\n   within\
    \ the number of centiseconds specified by the Interval field.\n   Fields :\n \
    \  Type      Set to 2 to indicate an Acknowledgement Request TLV.\n   Length \
    \   The length of the body, exclusive of the Type and Length\n             fields.\n\
    \   Reserved  Sent as 0 and MUST be ignored on reception.\n   Nonce     An arbitrary\
    \ value that will be echoed in the receiver's\n             Acknowledgement TLV.\n\
    \   Interval  A time interval in centiseconds after which the sender will\n  \
    \           assume that this packet has been lost.  This MUST NOT be 0.\n    \
    \         The receiver MUST send an acknowledgement before this time\n       \
    \      has elapsed (with a margin allowing for propagation time).\n"
- title: 4.4.4.  Acknowledgement
  contents:
  - "4.4.4.  Acknowledgement\n   0                   1                   2       \
    \            3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    Type = 3   |    Length     |            Nonce              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   This TLV is sent by a node upon receiving an Acknowledgement Request.\n  \
    \ Fields :\n   Type      Set to 3 to indicate an Acknowledgement TLV.\n   Length\
    \    The length of the body, exclusive of the Type and Length\n             fields.\n\
    \   Nonce     Set to the Nonce value of the Acknowledgement Request that\n   \
    \          prompted this Acknowledgement.\n   Since nonce values are not globally\
    \ unique, this TLV MUST be sent to\n   a unicast address.\n"
- title: 4.4.5.  Hello
  contents:
  - "4.4.5.  Hello\n   0                   1                   2                 \
    \  3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    Type = 4   |    Length     |          Reserved             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Seqno              |          Interval             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   This TLV is used for neighbour discovery and for determining a link's\n  \
    \ reception cost.\n   Fields :\n   Type      Set to 4 to indicate a Hello TLV.\n\
    \   Length    The length of the body, exclusive of the Type and Length\n     \
    \        fields.\n   Reserved  Sent as 0 and MUST be ignored on reception.\n \
    \  Seqno     The value of the sending node's Hello seqno for this\n          \
    \   interface.\n   Interval  An upper bound, expressed in centiseconds, on the\
    \ time\n             after which the sending node will send a new Hello TLV.\n\
    \             This MUST NOT be 0.\n   Since there is a single seqno counter for\
    \ all the Hellos sent by a\n   given node over a given interface, this TLV MUST\
    \ be sent to a\n   multicast destination.  In order to avoid large discontinuities\
    \ in\n   link quality, multiple Hello TLVs SHOULD NOT be sent in the same\n  \
    \ packet.\n"
- title: 4.4.6.  IHU
  contents:
  - "4.4.6.  IHU\n   0                   1                   2                   3\n\
    \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    Type = 5   |    Length     |       AE      |    Reserved   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Rxcost             |          Interval             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |       Address...\n   +-+-+-+-+-+-+-+-+-+-+-+-\n   An IHU (\"I Heard You\"\
    ) TLV is used for confirming bidirectional\n   reachability and carrying a link's\
    \ transmission cost.\n   Fields :\n   Type      Set to 5 to indicate an IHU TLV.\n\
    \   Length    The length of the body, exclusive of the Type and Length\n     \
    \        fields.\n   AE        The encoding of the Address field.  This should\
    \ be 1 or 3\n             in most cases.  As an optimisation, it MAY be 0 if the\
    \ TLV\n             is sent to a unicast address, if the association is over a\n\
    \             point-to-point link, or when bidirectional reachability is\n   \
    \          ascertained by means outside of the Babel protocol.\n   Reserved  Sent\
    \ as 0 and MUST be ignored on reception.\n   Rxcost    The rxcost according to\
    \ the sending node of the interface\n             whose address is specified in\
    \ the Address field.  The value\n             FFFF hexadecimal (infinity) indicates\
    \ that this interface\n             is unreachable.\n   Interval  An upper bound,\
    \ expressed in centiseconds, on the time\n             after which the sending\
    \ node will send a new IHU; this MUST\n             NOT be 0.  The receiving node\
    \ will use this value in order\n             to compute a hold time for this symmetric\
    \ association.\n   Address   The address of the destination node, in the format\n\
    \             specified by the AE field.  Address compression is not\n       \
    \      allowed.\n   Conceptually, an IHU is destined to a single neighbour.  However,\
    \ IHU\n   TLVs contain an explicit destination address, and it SHOULD be sent\n\
    \   to a multicast address, as this allows aggregation of IHUs destined\n   to\
    \ distinct neighbours into a single packet and avoids the need for\n   an ARP\
    \ or Neighbour Discovery exchange when a neighbour is not being\n   used for data\
    \ traffic.\n   IHU TLVs with an unknown value for the AE field MUST be silently\n\
    \   ignored.\n"
- title: 4.4.7.  Router-Id
  contents:
  - "4.4.7.  Router-Id\n   0                   1                   2             \
    \      3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |  \
    \  Type = 6   |    Length     |          Reserved             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                         Router-Id                           +\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   A Router-Id TLV establishes a router-id that is implied by subsequent\n  \
    \ Update TLVs.\n   Fields :\n   Type      Set to 6 to indicate a Router-Id TLV.\n\
    \   Length    The length of the body, exclusive of the Type and Length\n     \
    \        fields.\n   Reserved  Sent as 0 and MUST be ignored on reception.\n \
    \  Router-Id The router-id for routes advertised in subsequent Update\n      \
    \       TLVs\n"
- title: 4.4.8.  Next Hop
  contents:
  - "4.4.8.  Next Hop\n   0                   1                   2              \
    \     3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |  \
    \  Type = 7   |    Length     |      AE       |   Reserved    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |       Next hop...\n   +-+-+-+-+-+-+-+-+-+-+-+-\n   A Next Hop TLV establishes\
    \ a next-hop address for a given address\n   family (IPv4 or IPv6) that is implied\
    \ by subsequent Update TLVs.\n   Fields :\n   Type      Set to 7 to indicate a\
    \ Next Hop TLV.\n   Length    The length of the body, exclusive of the Type and\
    \ Length\n             fields.\n   AE        The encoding of the Address field.\
    \  This SHOULD be 1 or 3\n             and MUST NOT be 0.\n   Reserved  Sent as\
    \ 0 and MUST be ignored on reception.\n   Next hop  The next-hop address advertised\
    \ by subsequent Update TLVs,\n             for this address family.\n   When the\
    \ address family matches the network-layer protocol that this\n   packet is transported\
    \ over, a Next Hop TLV is not needed: in that\n   case, the next hop is taken\
    \ to be the source address of the packet.\n   Next Hop TLVs with an unknown value\
    \ for the AE field MUST be silently\n   ignored.\n"
- title: 4.4.9.  Update
  contents:
  - "4.4.9.  Update\n   0                   1                   2                \
    \   3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n  \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |    Type\
    \ = 8   |    Length     |       AE      |    Flags      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     Plen      |    Omitted    |            Interval           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             Seqno             |            Metric             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      Prefix...\n   +-+-+-+-+-+-+-+-+-+-+-+-\n   An Update TLV advertises\
    \ or retracts a route.  As an optimisation,\n   this can also have the side effect\
    \ of establishing a new implied\n   router-id and a new default prefix.\n   Fields\
    \ :\n   Type      Set to 8 to indicate an Update TLV.\n   Length    The length\
    \ of the body, exclusive of the Type and Length\n             fields.\n   AE \
    \       The encoding of the Prefix field.\n   Flags     The individual bits of\
    \ this field specify special handling\n             of this TLV (see below). \
    \ Every node MUST be able to\n             interpret the flags with values 80\
    \ and 40 hexadecimal;\n             unknown flags MUST be silently ignored.\n\
    \   Plen      The length of the advertised prefix.\n   Omitted   The number of\
    \ octets that have been omitted at the\n             beginning of the advertised\
    \ prefix and that should be taken\n             from a preceding Update TLV with\
    \ the flag with value 80\n             hexadecimal set.\n   Interval  An upper\
    \ bound, expressed in centiseconds, on the time\n             after which the\
    \ sending node will send a new update for\n             this prefix.  This MUST\
    \ NOT be 0 and SHOULD NOT be less\n             than 10.  The receiving node will\
    \ use this value to compute\n             a hold time for this routing table entry.\
    \  The value FFFF\n             hexadecimal (infinity) expresses that this announcement\n\
    \             will not be repeated unless a request is received\n            \
    \ (Section 3.8.2.3).\n   Seqno     The originator's sequence number for this update.\n\
    \   Metric    The sender's metric for this route.  The value FFFF\n          \
    \   hexadecimal (infinity) means that this is a route\n             retraction.\n\
    \   Prefix    The prefix being advertised.  This field's size is (Plen/8\n   \
    \          - Omitted) rounded upwards.\n   The Flags field is interpreted as follows:\n\
    \   o  if the bit with value 80 hexadecimal is set, then this Update\n      establishes\
    \ a new default prefix for subsequent Update TLVs with a\n      matching address\
    \ family within the same packet;\n   o  if the bit with value 40 hexadecimal is\
    \ set, then the low-order 8\n      octets of the advertised prefix establish a\
    \ new default router-id\n      for this TLV and subsequent Update TLVs in the\
    \ same packet.\n   The prefix being advertised by an Update TLV is computed as\
    \ follows:\n   o  the first Omitted octets of the prefix are taken from the previous\n\
    \      Update TLV with flag 80 hexadecimal set and the same address\n      family;\n\
    \   o  the next (Plen/8 - Omitted) (rounded upwards) octets are taken\n      from\
    \ the Prefix field;\n   o  the remaining octets are set to 0.\n   If the Metric\
    \ field is finite, the router-id of the originating node\n   for this announcement\
    \ is taken from the low-order 8 octets of the\n   prefix advertised by this Update\
    \ if the bit with value 40 hexadecimal\n   is set in the Flags field.  Otherwise,\
    \ it is taken either from the\n   preceding Router-Id packet, or the preceding\
    \ Update packet with flag\n   40 hexadecimal set, whichever comes last.\n   The\
    \ next-hop address for this update is taken from the last preceding\n   Next Hop\
    \ TLV with a matching address family in the same packet; if no\n   such TLV exists,\
    \ it is taken from the network-layer source address of\n   this packet.\n   If\
    \ the metric field is FFFF hexadecimal, this TLV specifies a\n   retraction. \
    \ In that case, the current router-id and the Seqno are\n   not used.  AE MAY\
    \ then be 0, in which case this Update retracts all\n   of the routes previously\
    \ advertised on this interface.\n   Update TLVs with an unknown value for the\
    \ AE field MUST be silently\n   ignored.\n"
- title: 4.4.10.  Route Request
  contents:
  - "4.4.10.  Route Request\n   0                   1                   2        \
    \           3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    Type = 9   |    Length     |      AE       |     Plen      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      Prefix...\n   +-+-+-+-+-+-+-+-+-+-+-+-\n   A Route Request TLV prompts\
    \ the receiver to send an update for a\n   given prefix, or a full routing table\
    \ dump.\n   Fields :\n   Type      Set to 9 to indicate a Route Request TLV.\n\
    \   Length    The length of the body, exclusive of the Type and Length\n     \
    \        fields.\n   AE        The encoding of the Prefix field.  The value 0\
    \ specifies\n             that this is a request for a full routing table dump\
    \ (a\n             wildcard request).\n   Plen      The length of the requested\
    \ prefix.\n   Prefix    The prefix being requested.  This field's size is Plen/8\n\
    \             rounded upwards.\n   A Request TLV prompts the receiving node to\
    \ send an update message\n   for the prefix specified by the AE, Plen, and Prefix\
    \ fields, or a\n   full dump of its routing table if AE is 0 (in which case Plen\
    \ MUST be\n   0, and Prefix is of length 0).  A Request may be sent to a unicast\n\
    \   address if it is destined to a single node, or to a multicast address\n  \
    \ if the request is destined to all of the neighbours of the sending\n   interface.\n"
- title: 4.4.11.  Seqno Request
  contents:
  - "4.4.11.  Seqno Request\n   0                   1                   2        \
    \           3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    Type = 10  |    Length     |      AE       |    Plen       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             Seqno             |  Hop Count    |   Reserved    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                        Router-Id                            +\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   Prefix...\n   +-+-+-+-+-+-+-+-+-+-+\n   A Seqno Request TLV prompts the\
    \ receiver to send an Update for a\n   given prefix with a given sequence number,\
    \ or to forward the request\n   further if it cannot be satisfied locally.\n \
    \  Fields :\n   Type      Set to 10 to indicate a Seqno Request message.\n   Length\
    \    The length of the body, exclusive of the Type and Length\n             fields.\n\
    \   AE        The encoding of the Prefix field.  This MUST NOT be 0.\n   Plen\
    \      The length of the requested prefix.\n   Seqno     The sequence number that\
    \ is being requested.\n   Hop Count The maximum number of times that this TLV\
    \ may be forwarded,\n             plus 1.  This MUST NOT be 0.\n   Prefix    The\
    \ prefix being requested.  This field's size is Plen/8\n             rounded upwards.\n\
    \   A Seqno Request TLV prompts the receiving node to send an Update for\n   the\
    \ prefix specified by the AE, Plen, and Prefix fields, with either\n   a router-id\
    \ different from what is specified by the Router-Id field,\n   or a Seqno no less\
    \ than what is specified by the Seqno field.  If\n   this request cannot be satisfied\
    \ locally, then it is forwarded\n   according to the rules set out in Section\
    \ 3.8.1.2.\n   While a Seqno Request MAY be sent to a multicast address, it MUST\
    \ NOT\n   be forwarded to a multicast address and MUST NOT be forwarded to more\n\
    \   than one neighbour.  A request MUST NOT be forwarded if its Hop Count\n  \
    \ field is 1.\n"
- title: 5.  IANA Considerations
  contents:
  - "5.  IANA Considerations\n   IANA has registered the UDP port number 6697, called\
    \ \"babel\", for use\n   by the Babel protocol.\n   IANA has registered the IPv6\
    \ multicast group ff02:0:0:0:0:0:1:6 and\n   the IPv4 multicast group 224.0.0.111\
    \ for use by the Babel protocol.\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   As defined in this document, Babel is a completely\
    \ insecure protocol.\n   Any attacker can attract data traffic by advertising\
    \ routes with a\n   low metric.  This particular issue can be solved either by\
    \ lower-\n   layer security mechanisms (e.g., IPsec or link-layer security), or\
    \ by\n   appending a cryptographic key to Babel packets; the provision of\n  \
    \ ignoring any data contained within a Babel packet beyond the body\n   length\
    \ declared by the header is designed for just such a purpose.\n   The information\
    \ that a Babel node announces to the whole routing\n   domain is often sufficient\
    \ to determine a mobile node's physical\n   location with reasonable precision.\
    \  The privacy issues that this\n   causes can be mitigated somewhat by using\
    \ randomly chosen router-ids\n   and randomly chosen IP addresses, and changing\
    \ them periodically.\n   When carried over IPv6, Babel packets are ignored unless\
    \ they are\n   sent from a link-local IPv6 address; since routers don't forward\n\
    \   link-local IPv6 packets, this provides protection against spoofed\n   Babel\
    \ packets being sent from the global Internet.  No such natural\n   protection\
    \ exists when Babel packets are carried over IPv4.\n"
- title: 7.  References
  contents:
  - '7.  References

    '
- title: 7.1.  Normative References
  contents:
  - "7.1.  Normative References\n   [ADDRARCH]  Hinden, R. and S. Deering, \"IP Version\
    \ 6 Addressing\n               Architecture\", RFC 4291, February 2006.\n   [RFC2119]\
    \   Bradner, S., \"Key words for use in RFCs to Indicate\n               Requirement\
    \ Levels\", BCP 14, RFC 2119, March 1997.\n"
- title: 7.2.  Informative References
  contents:
  - "7.2.  Informative References\n   [DSDV]      Perkins, C. and P. Bhagwat, \"Highly\
    \ Dynamic Destination-\n               Sequenced Distance-Vector Routing (DSDV)\
    \ for Mobile\n               Computers\", ACM SIGCOMM'94 Conference on Communications\n\
    \               Architectures, Protocols and Applications 234-244, 1994.\n   [DUAL]\
    \      Garcia Luna Aceves, J., \"Loop-Free Routing Using\n               Diffusing\
    \ Computations\", IEEE/ACM Transactions on\n               Networking 1:1, February\
    \ 1993.\n   [EIGRP]     Albrightson, B., Garcia Luna Aceves, J., and J. Boyle,\n\
    \               \"EIGRP -- a Fast Routing Protocol Based on Distance\n       \
    \        Vectors\", Proc. Interop 94, 1994.\n   [ETX]       De Couto, D., Aguayo,\
    \ D., Bicket, J., and R. Morris, \"A\n               high-throughput path metric\
    \ for multi-hop wireless\n               networks\", Proc. MobiCom 2003, 2003.\n\
    \   [IS-IS]     \"Information technology -- Telecommunications and\n         \
    \      information exchange between systems -- Intermediate\n               System\
    \ to Intermediate System intra-domain routeing\n               information exchange\
    \ protocol for use in conjunction with\n               the protocol for providing\
    \ the connectionless-mode\n               network service (ISO 8473)\", ISO/IEC\
    \ 10589:2002.\n   [JITTER]    Floyd, S. and V. Jacobson, \"The synchronization\
    \ of\n               periodic routing messages\", IEEE/ACM Transactions on\n \
    \              Networking 2, 2, 122-136, April 1994.\n   [OSPF]      Moy, J.,\
    \ \"OSPF Version 2\", STD 54, RFC 2328, April 1998.\n   [PACKETBB]  Clausen, T.,\
    \ Dearlove, C., Dean, J., and C. Adjih,\n               \"Generalized Mobile Ad\
    \ Hoc Network (MANET) Packet/Message\n               Format\", RFC 5444, February\
    \ 2009.\n   [RIP]       Malkin, G., \"RIP Version 2\", STD 56, RFC 2453,\n   \
    \            November 1998.\n"
- title: Appendix A.  Cost and Metric Computation
  contents:
  - "Appendix A.  Cost and Metric Computation\n   The strategy for computing link\
    \ costs and route metrics is a local\n   matter; Babel itself only requires that\
    \ it comply with the conditions\n   given in Sections 3.4.3 and 3.5.2.  Different\
    \ nodes MAY use different\n   strategies in a single network and MAY use different\
    \ strategies on\n   different interface types.  This section gives a few examples\
    \ of such\n   strategies.\n   The sample implementation of Babel maintains statistics\
    \ about the\n   last 16 received Hello TLVs (Appendix A.1), computes costs by\
    \ using\n   the 2-out-of-3 strategy (Appendix A.2.1) on wired links, and ETX\n\
    \   [ETX] on wireless links.  It uses an additive algebra for metric\n   computation\
    \ (Appendix A.3.1).\n"
- title: A.1.  Maintaining Hello History
  contents:
  - "A.1.  Maintaining Hello History\n   For each neighbour, the sample implementation\
    \ of Babel maintains a\n   Hello history and an expected sequence number.  The\
    \ Hello history is\n   a vector of 16 bits, where a 1 value represents a received\
    \ Hello, and\n   a 0 value a missed Hello.  The expected sequence number, written\
    \ ne,\n   is the sequence number that is expected to be carried by the next\n\
    \   received hello from this neighbour.\n   Whenever it receives a Hello packet\
    \ from a neighbour, a node compares\n   the received sequence number nr with its\
    \ expected sequence number ne.\n   Depending on the outcome of this comparison,\
    \ one of the following\n   actions is taken:\n   o  if the two differ by more\
    \ than 16 (modulo 2^16), then the sending\n      node has probably rebooted and\
    \ lost its sequence number; the\n      associated neighbour table entry is flushed;\n\
    \   o  otherwise, if the received nr is smaller (modulo 2^16) than the\n     \
    \ expected sequence number ne, then the sending node has increased\n      its\
    \ Hello interval without our noticing; the receiving node\n      removes the last\
    \ (ne - nr) entries from this neighbour's Hello\n      history (we \"undo history\"\
    );\n   o  otherwise, if nr is larger (modulo 2^16) than ne, then the sending\n\
    \      node has decreased its Hello interval, and some Hellos were lost;\n   \
    \   the receiving node adds (nr - ne) 0 bits to the Hello history (we\n      \"\
    fast-forward\").\n   The receiving node then appends a 1 bit to the neighbour's\
    \ Hello\n   history, resets the neighbour's Hello timer, and sets ne to (nr +\
    \ 1).\n   It then resets the neighbour's Hello timer to 1.5 times the value\n\
    \   advertised in the received Hello (the extra margin allows for the\n   delay\
    \ due to jitter).\n   Whenever the Hello timer associated to a neighbour expires,\
    \ the local\n   node adds a 0 bit to this neighbour's Hello history, and increments\n\
    \   the expected Hello number.  If the Hello history is empty (it\n   contains\
    \ 0 bits only), the neighbour entry is flushed; otherwise, it\n   resets the neighbour's\
    \ Hello timer to the value advertised in the\n   last Hello received from this\
    \ neighbour (no extra margin is necessary\n   in this case).\n"
- title: A.2.  Cost Computation
  contents:
  - 'A.2.  Cost Computation

    '
- title: A.2.1.  k-out-of-j
  contents:
  - "A.2.1.  k-out-of-j\n   K-out-of-j link sensing is suitable for wired links that\
    \ are either\n   up, in which case they only occasionally drop a packet, or down,\
    \ in\n   which case they drop all packets.\n   The k-out-of-j strategy is parameterised\
    \ by two small integers k and\n   j, such that 0 < k <= j, and the nominal link\
    \ cost, a constant K >=\n   1.  A node keeps a history of the last j hellos; if\
    \ k or more of\n   those have been correctly received, the link is assumed to\
    \ be up, and\n   the rxcost is set to K; otherwise, the link is assumed to be\
    \ down,\n   and the rxcost is set to infinity.\n   The cost of such a link is\
    \ defined as\n   o  cost = FFFF hexadecimal if rxcost = FFFF hexadecimal;\n  \
    \ o  cost = txcost otherwise.\n"
- title: A.2.2.  ETX
  contents:
  - "A.2.2.  ETX\n   The Estimated Transmission Cost metric [ETX] estimates the number\
    \ of\n   times that a unicast frame will be retransmitted by the IEEE 802.11\n\
    \   MAC, assuming infinite persistence.\n   A node uses a neighbour's Hello history\
    \ to compute an estimate,\n   written beta, of the probability that a Hello TLV\
    \ is successfully\n   received.  The rxcost is defined as 256/beta.\n   Let alpha\
    \ be MIN(1, 256/txcost), an estimate of the probability of\n   successfully sending\
    \ a Hello TLV.  The cost is then computed by\n      cost = 256/(alpha * beta)\n\
    \   or, equivalently,\n      cost = (MAX(txcost, 256) * rxcost) / 256.\n"
- title: A.3.  Metric Computation
  contents:
  - 'A.3.  Metric Computation

    '
- title: A.3.1.  Additive Metrics
  contents:
  - "A.3.1.  Additive Metrics\n   The simplest approach for obtaining a monotonic,\
    \ isotonic metric is\n   to define the metric of a route as the sum of the costs\
    \ of the\n   component links.  More formally, if a neighbour advertises a route\n\
    \   with metric m over a link with cost c, then the resulting route has\n   metric\
    \ M(c, m) = c + m.\n   A multiplicative metric can be converted to an additive\
    \ one by taking\n   the logarithm (in some suitable base) of the link costs.\n"
- title: A.3.2.  External Sources of Willingness
  contents:
  - "A.3.2.  External Sources of Willingness\n   A node may want to vary its willingness\
    \ to forward packets by taking\n   into account information that is external to\
    \ the Babel protocol, such\n   as the monetary cost of a link, the node's battery\
    \ status, CPU load,\n   etc.  This can be done by adding to every route's metric\
    \ a value k\n   that depends on the external data.  For example, if a battery-powered\n\
    \   node receives an update with metric m over a link with cost c, it\n   might\
    \ compute a metric M(c, m) = k + c + m, where k depends on the\n   battery status.\n\
    \   In order to preserve strict monotonicity (Section 3.5.2), the value k\n  \
    \ must be greater than -c.\n"
- title: Appendix B.  Constants
  contents:
  - "Appendix B.  Constants\n   The choice of time constants is a trade-off between\
    \ fast detection of\n   mobility events and protocol overhead.  Two implementations\
    \ of Babel\n   with different time constants will interoperate, although the\n\
    \   resulting convergence time will most likely be dictated by the\n   slowest\
    \ of the two implementations.\n   Experience with the sample implementation of\
    \ Babel indicates that the\n   Hello interval is the most important time constant:\
    \ a mobility event\n   is detected within 1.5 to 3 Hello intervals.  Due to Babel's\
    \ reliance\n   on triggered updates and explicit requests, the Update interval\
    \ only\n   has an effect on the time it takes for accurate metrics to be\n   propagated\
    \ after variations in link costs too small to trigger an\n   unscheduled update.\n\
    \   At the time of writing, the sample implementation of Babel uses the\n   following\
    \ default values:\n      Hello Interval: 4 seconds on wireless links, 20 seconds\
    \ on wired\n      links.\n      IHU Interval: the advertised IHU interval is always\
    \ 3 times the\n      Hello interval.  IHUs are actually sent with each Hello on\
    \ lossy\n      links (as determined from the Hello history), but only with every\n\
    \      third Hello on lossless links.\n      Update Interval: 4 times the Hello\
    \ interval.\n      IHU Hold Time: 3.5 times the advertised IHU interval.\n   \
    \   Route Expiry Time: 3.5 times the advertised update interval.\n      Source\
    \ GC time: 3 minutes.\n   The amount of jitter applied to a packet depends on\
    \ whether it\n   contains any urgent TLVs or not.  Urgent triggered updates and\
    \ urgent\n   requests are delayed by no more than 200 ms; other TLVs are delayed\n\
    \   by no more than one-half the Hello interval.\n"
- title: Appendix C.  Simplified Implementations
  contents:
  - "Appendix C.  Simplified Implementations\n   Babel is a fairly economic protocol.\
    \  Route updates take between 12\n   and 40 octets per destination, depending\
    \ on how successful\n   compression is; in a double-stack mesh network, an average\
    \ of less\n   than 24 octets is typical.  The route table occupies about 35 octets\n\
    \   per IPv6 entry.  To put these values into perspective, a single full-\n  \
    \ size Ethernet frame can carry some 65 route updates, and a megabyte\n   of memory\
    \ can contain a 20000-entry routing table and the associated\n   source table.\n\
    \   Babel is also a reasonably simple protocol.  The sample\n   implementation\
    \ consists of less than 8000 lines of C code, and it\n   compiles to less than\
    \ 60 kB of text on a 32-bit CISC architecture.\n   Nonetheless, in some very constrained\
    \ environments, such as PDAs,\n   microwave ovens, or abacuses, it may be desirable\
    \ to have subset\n   implementations of the protocol.\n   A parasitic implementation\
    \ is one that uses a Babel network for\n   routing its packets but does not announce\
    \ any of the routes that it\n   has learnt from its neighbours.  (This is slightly\
    \ more than a\n   passive implementation, which doesn't even announce routes to\n\
    \   itself.)  It may either maintain a full routing table or simply\n   select\
    \ a gateway amongst any one of its neighbours that announces a\n   default route.\
    \  Since a parasitic implementation never forwards\n   packets, it cannot possibly\
    \ participate in a routing loop; hence, it\n   need not evaluate the feasibility\
    \ condition and need not maintain a\n   source table.\n   A parasitic implementation\
    \ MUST answer acknowledgement requests and\n   MUST participate in the Hello/IHU\
    \ protocol.  Finally, it MUST be able\n   to reply to seqno requests for routes\
    \ that it announces and SHOULD be\n   able to reply to route requests.\n"
- title: Appendix D.  Software Availability
  contents:
  - "Appendix D.  Software Availability\n   The sample implementation of Babel is\
    \ available from\n   <http://www.pps.jussieu.fr/~jch/software/babel/>.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Juliusz Chroboczek\n   PPS, University of Paris 7\n   Case\
    \ 7014\n   75205 Paris Cedex 13,\n   France\n   EMail: jch@pps.jussieu.fr\n"
