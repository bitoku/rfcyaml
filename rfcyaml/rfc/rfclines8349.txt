Abstract This document specifies three YANG modules and one submodule.
Together, they form the core routing data model that serves as a framework for configuring and managing a routing subsystem.
It is expected that these modules will be augmented by additional YANG modules defining data models for control plane protocols, route filters, and other functions.
The core routing data model provides common building blocks for such extensions   routes, Routing Information Bases (RIBs), and control plane protocols.
The YANG modules in this document conform to the Network Management Datastore Architecture (NMDA).
This document obsoletes RFC 8022.
This document specifies the following YANG modules:  The "ietf routing" module provides generic components of a routing data model.
The "ietf ipv4 unicast routing" module augments the "ietf routing" module with additional data specific to IPv4 unicast.
The "ietf ipv6 unicast routing" module augments the "ietf routing" module with additional data specific to IPv6 unicast.
Its submodule, "ietf ipv6 router advertisements", also augments the "ietf interfaces"  [RFC8343] and "ietf ip" [RFC8344] modules with IPv6 router configuration variables required by [RFC4861].
These modules together define the core routing data model, which is intended as a basis for future data model development covering more sophisticated routing systems.
While these three modules can be directly used for simple IP devices with static routing (see Appendix B), their main purpose is to provide essential building blocks for more complicated data models involving multiple control plane protocols, multicast routing, additional address families, and advanced functions such as route filtering or policy routing.
To this end, it is expected that the core routing data model will be augmented by numerous modules developed by various IETF working groups.
The YANG modules in this document conform to the Network Management Datastore Architecture (NMDA) [RFC8342].
This document obsoletes RFC 8022
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14
when, and only when, they appear in all capitals, as shown here.
The following terms are defined in [RFC8342]:  client  server  configuration
system state  operational state  intended configuration
The following terms are defined in [RFC7950]:  action  augment  container  data model
presence container  schema tree  RPC (Remote Procedure Call) operation 2.1.
core routing data model:  YANG data model comprising "ietf routing", "ietf ipv4 unicast routing", and "ietf ipv6 unicast routing" modules.
direct route:  A route to a directly connected network.
An object containing a list of routes, together with other information.
See Section 5.2 for details.
system controlled entry:  An entry in a list in the operational state ("config false") that is created by the system independently of what has been explicitly configured.
See Section 4.1 for details.
An entry in a list in the operational state ("config false") that is created and deleted as a direct consequence of certain configuration changes.
See Section 4.1 for details.
Tree Diagrams Tree diagrams used in this document follow the notation defined in [RFC8340].
Prefixes in Data Node Names
In this document, names of data nodes, actions, and other data model objects are often used without a prefix, as long as it is clear from the context in which YANG module each name is defined.
Otherwise, names are prefixed using the standard prefix associated with the corresponding YANG module, as shown in Table 1.
ietf ipv4 unicast routing   Section 8
ietf ipv6 unicast routing   Section 9
The initial design of the core routing data model was driven by the following objectives:
The data model should be suitable for the common address families   in particular, IPv4 and IPv6   and for unicast and multicast routing, as well as Multiprotocol Label Switching (MPLS).
A simple IP routing system, such as one that uses only static routing, should be configurable in a simple way, ideally without any need to develop additional YANG modules.
On the other hand, the core routing framework must allow for complicated implementations involving multiple RIBs and multiple control plane protocols, as well as controlled redistributions of routing information.
Because device vendors will want to map the data models built on this generic framework to their proprietary data models and configuration interfaces, the framework should be flexible enough to facilitate such mapping and accommodate data models with different logic.
The Design of the Core Routing Data Model
The core routing data model consists of three YANG modules and one submodule.
The first module, "ietf routing", defines the generic components of a routing system.
"ietf ipv4 unicast routing" and "ietf ipv6 unicast routing"
augment the "ietf routing" module with additional data nodes that are needed for IPv4 and IPv6 unicast routing, respectively.
The "ietf ipv6 unicast routing
" module has a submodule, "ietf ipv6 router advertisements", that augments the "ietf interfaces" [RFC8343] and "ietf ip" [RFC8344] modules with configuration variables for IPv6 Router Advertisements as required by [RFC4861].
Figure 1 shows abridged views of the hierarchies.
See Appendix A for the complete data trees.
rw routing  rw router id?
string Figure 1: Data Hierarchy
As can be seen from Figure 1, the core routing data model introduces several generic components of a routing framework: routes, RIBs containing lists of routes, and control plane protocols.
Section 5 describes these components in more detail.
System Controlled and User Controlled List
The core routing data model defines several lists in the schema tree, such as "rib", that have to be populated with at least one entry in any properly functioning device, and additional entries may be configured by a client.
In such a list, the server creates the required item as a "system controlled entry" in the operational state, i.e., inside read only lists in the "routing" container.
An example can be seen in Appendix D: the "/routing/ribs/rib" list has two system controlled entries
"ipv4 master" and "ipv6 master".
Additional entries called "user controlled entries" may be created in the configuration by a client, e.g., via the Network Configuration Protocol (NETCONF).
If the server accepts a configured user controlled entry, then this entry also appears in the operational state version of the list.
Corresponding entries in both versions of the list (in the intended configuration and the operational state)
[RFC8342] have the same value of the list key.
A client may also provide supplemental configuration of system  controlled entries.
To do so, the client creates a new entry in the configuration with the desired contents.
In order to bind this entry to the corresponding entry in the operational state, the key of the configuration entry has to be set to the same value as the key of the operational state entry.
Deleting a user controlled entry from the intended configuration results in the removal of the corresponding entry in the operational state list.
In contrast, if a client deletes a system controlled entry from the intended configuration, only the extra configuration specified in that entry is removed; the corresponding operational state entry is not removed.
This section describes the essential components of the core routing data model.
Routes Routes are basic elements of information in a routing system.
The core routing data model defines only the following minimal set of route attributes:  "destination prefix": address prefix specifying the set of destination addresses for which the route may be used.
"route preference": an integer value (also known as "administrative distance") that is used for selecting a preferred route among routes with the same destination prefix.
A lower value indicates a route that is more preferred.
"next hop": determines the outgoing interface and/or next hop address(es), or a special operation to be performed on a packet.
Routes are primarily system state and appear as entries in RIBs (Section 5.2), but they may also be found in configuration data   for example, as manually configured static routes.
In the latter case, configurable route attributes are generally a subset of attributes defined for RIB routes.
Every implementation of the core routing data model manages one or more RIBs.
A RIB is a list of routes complemented with administrative data.
Each RIB contains only routes of one address family.
An address family is represented by an identity derived from the "rt:address family" base identity.
In the core routing data model, RIBs are represented as entries in the list "/routing/ribs/rib" in the operational state.
The contents of RIBs are controlled and manipulated by control plane protocol operations that may result in route additions, removals, and modifications.
This also includes manipulations via the "static" and/or "direct" pseudo protocols; see Section 5.3.1.
For every supported address family, exactly one RIB MUST be marked as the "default RIB", in which control plane protocols place their routes by default.
Simple router implementations that do not advertise the "multiple ribs" feature will typically create one system controlled RIB per supported address family and mark it as the default RIB.
More complex router implementations advertising the "multiple ribs" feature support multiple RIBs per address family that can be used for policy routing and other purposes.
The following action (see Section 7.15 of [RFC7950]) is defined for the "rib" list:  active route   return the active RIB route for the destination address that is specified as the action's input parameter.
The core routing data model provides an open ended framework for defining multiple control plane protocol instances, e.g., for Layer 3 routing protocols.
Each control plane protocol instance MUST be assigned a type, which is an identity derived from the "rt:control plane protocol" base identity.
The core routing data model defines two identities for the "direct" and "static" pseudo protocols (Section 5.3.1).
Multiple control plane protocol instances of the same type MAY be configured.
The core routing data model defines two special routing protocol types
Both are in fact pseudo protocols, which means that they are confined to the local device and do not exchange any routing information with adjacent routers.
Every implementation of the core routing data model MUST provide exactly one instance of the "direct" pseudo protocol type.
It is the source of direct routes for all configured address families.
Direct routes are normally supplied by the operating system kernel, based on the configuration of network interface addresses; see Section 6.2.
A pseudo protocol of the type "static" allows for specifying routes manually.
It MAY be configured in zero or multiple instances, although a typical configuration will have exactly one instance.
Defining New Control Plane Protocols It is expected that future YANG modules will create data models for additional control plane protocol types.
Such new modules will have to define the protocol specific data nodes, and they will have to integrate into the core routing framework in the following way:  A new identity MUST be defined for the control plane protocol, and its base identity MUST be set to "rt:control plane protocol" or to an identity derived from "rt:control plane protocol".
Additional route attributes MAY be defined, preferably in one place by means of defining a YANG grouping.
The new attributes have to be inserted by augmenting the definitions of the node /rt:routing/
route and possibly other places in the schema tree.
Data nodes for the new protocol can be defined by augmenting the "control plane protocol" data node under "/routing".
By using a "when" statement, the augmented data nodes specific to the new protocol SHOULD be made conditional and valid only if the value of "rt:type" or "rt:source protocol" is equal to (or derived from) the new protocol's identity.
It is also RECOMMENDED that protocol specific data nodes be encapsulated in an appropriately named container with presence.
Such a container may contain mandatory data nodes that are otherwise forbidden at the top level of an augment.
The above steps are implemented by the example YANG module for the Routing Information Protocol (RIP); see Appendix C. 5.4.
Parameters of IPv6 Router Advertisements
The YANG module "ietf ipv6 router advertisements" (Section 9.1), which is a submodule of the "ietf ipv6 unicast routing" module, augments the schema tree of IPv6 interfaces with definitions of the following variables as required by Section 6.2.1 of [RFC4861]:  send advertisements  max rtr adv interval  min rtr adv interval
default lifetime  prefix list: a list of prefixes to be advertised.
The "IsRouter" flag, which is also required by [RFC4861], is implemented in the "ietf ip" module [RFC8344] (leaf "ip:forwarding").
The Neighbor Discovery specification [RFC4861] allows the implementations to decide whether the "valid lifetime" and "preferred lifetime" parameters remain the same in consecutive advertisements or decrement in real time.
However, the latter behavior seems problematic because the values might be reset again to the (higher) configured values after a configuration is reloaded.
Moreover, no implementation is known to use the decrementing behavior.
The "ietf ipv6 router advertisements" submodule therefore stipulates the former behavior with constant values.
Interactions with Other YANG Modules
The semantics of the core routing data model also depends on several configuration parameters that are defined in other YANG modules.
The following boolean switch is defined in the "ietf interfaces" YANG module [RFC8343]:
if:interface/if:enabled If this switch is set to "false" for a network layer interface, then all routing and forwarding functions MUST be disabled on this interface.
The following boolean switches are defined in the "ietf ip" YANG module [RFC8344]:
if:interface/ip:ipv4/ip:enabled If this switch is set to "false" for a network layer interface, then all IPv4 routing and forwarding functions MUST be disabled on this interface.
:forwarding If this switch is set to "false" for a network layer interface, then the forwarding of IPv4 datagrams through this interface MUST be disabled.
However, the interface MAY participate in other IPv4 routing functions, such as routing protocols.
enabled If this switch is set to "false" for a network layer interface, then all IPv6 routing and forwarding functions MUST be disabled on this interface.
If this switch is set to "false" for a network layer interface, then the forwarding of IPv6 datagrams through this interface MUST be disabled.
However, the interface MAY participate in other IPv6 routing functions, such as routing protocols.
In addition, the "ietf ip" module allows for configuring IPv4 and IPv6 addresses and network prefixes or masks on network layer interfaces.
Configuration of these parameters on an enabled interface MUST result in an immediate creation of the corresponding direct route.
The destination prefix of this route is set according to the configured IP address and network prefix/mask, and the interface is set as the outgoing interface for that route.
Routing Management YANG Module <CODE BEGINS> file
module ietf routing { yang version "1.1"; namespace "urn:ietf:params:xml:
<mailto:yingzhen.qu@huawei.com>"; description "This YANG module defines essential components for the management of a routing subsystem.
The model fully conforms to the Network Management Datastore Architecture (NMDA).
IETF Trust and the persons identified as authors of the code.
Redistribution and use in source and binary forms, with or without modification, is permitted pursuant to, and subject to the license terms contained in, the Simplified BSD License set forth in Section 4.c of the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license info).
This version of this YANG module is part of RFC 8349; see the RFC itself for full legal notices."; revision 2018 03 13 { description "Network Management Datastore Architecture (NMDA) revision."
This feature indicates that the server supports user defined RIBs.
Servers that do not advertise this feature SHOULD provide exactly one system controlled RIB per supported address family and also make it the default RIB.
Servers that do not advertise this feature set a router ID algorithmically, usually to one of the configured IPv4 addresses.
However, this algorithm is implementation specific."
This grouping provides a leaf identifying an address family."
This grouping provides a router ID."; leaf router id { type yang:dotted quad; description "A 32 bit number in the form of a dotted quad that is used by some routing protocols identifying a router."
This grouping provides a leaf with an enumeration of special next hops."
; leaf special next hop { type enumeration { enum blackhole { description "Silently discard the packet."
"The packet will be received by the local system."
It is expected that further cases will be added through augments from other modules."; case simple next hop { description "This case represents a simple next hop consisting of the next hop address and/or outgoing interface.
Modules for address families MUST augment this case with a leaf containing a next hop address of that address family."; leaf outgoing interface { type if:interface ref
; description "Name of the outgoing interface."
; list next hop { key "index"; description "An entry in a next hop list.
Modules for address families MUST augment this list with a leaf containing a next hop address of that address family."; leaf index { type string; description "A user specified identifier utilized to uniquely reference the next hop entry in the next hop list.
The value of this index has no semantic meaning other than for referencing the entry."
; } leaf outgoing interface { type if:interface ref
; description "Name of the outgoing interface."
It is expected that further cases will be added through augments from other modules, e.g., for recursive next hops."; case simple next hop { description "This case represents a simple next hop consisting of the next hop address and/or outgoing interface.
Modules for address families MUST augment this case with a leaf containing a next hop address of that address family."; leaf outgoing interface { type if:interface ref
; description "Name of the outgoing interface."
; list next hop { description "
An entry in a next hop list.
Modules for address families MUST augment this list with a leaf containing a next hop address of that address family."; leaf outgoing interface { type if:interface ref
; description "Name of the outgoing interface."
{ if feature "router id"; description "Support for the global router ID.
Routing protocols that use a router ID can use this parameter or override it with another value."
; } container interfaces { config false; description "Network layer interfaces used for routing."; leaf list interface { type if:interface ref;
Each entry contains a control plane protocol instance."; leaf type { type identityref { base control plane protocol; } description "Type of the control plane protocol   an identity derived from the 'control plane protocol' base identity."
; list rib { key "name"; description "Each entry contains a configuration for a RIB identified by the 'name' key.
Entries having the same key as a system controlled entry in the list '/routing/ribs/rib' are used for configuring parameters of that entry.
Other entries define additional user controlled RIBs."; leaf name { type string; description "The name of the RIB.
For system controlled entries, the value of this leaf must be the same as the name of the corresponding entry in the operational state.
This flag has the value of 'true' if and only if the RIB is the default RIB for the given address family.
This data node MUST be augmented with information specific to routes of each address family."; leaf route preference { type route preference; description "This route attribute, also known as 'administrative distance', allows for selecting the preferred route among routes with the same destination prefix.
If no route exists in the RIB for the destination address, no output is returned.
/ container routing state { config false; status obsolete; description "State data of the routing subsystem."; uses router id { status obsolete; description "Global router ID.
It may be either configured or assigned algorithmically by the implementation."
; } container interfaces { status obsolete; description "Network layer interfaces used for routing."; leaf list interface { type if:interface state ref; status obsolete; description "
An implementation MUST provide exactly one system controlled instance of the 'direct' pseudo protocol.
For system controlled instances, this name is persistent, i.e., it SHOULD NOT change across reboots."
Each entry represents a RIB identified by the 'name' key.
All routes in a RIB MUST belong to the same address family.
; } leaf default rib { if feature "multiple ribs"; type boolean; default "true"; status obsolete; description "
This flag has the value of 'true' if and only if the RIB is the default RIB for the given address family.
This data node MUST be augmented with information specific to routes of each address family."
; leaf route preference { type route preference; status obsolete; description "This route attribute, also known as 'administrative distance', allows for selecting the preferred route among routes with the same destination prefix.
If no route exists in the RIB for the destination address, no output is returned.
Address family specific modules MUST augment this container with appropriate route contents."
; container next hop { status obsolete; description "Route's next hop attribute."; uses next hop state content { status obsolete; description "Active route state data."
IPv4 Unicast Routing Management YANG Module <CODE BEGINS>
file "ietf ipv4 unicast routing@2018 03 13.yang"
module ietf ipv4 unicast routing { yang version "1.1"; namespace "urn:ietf:params:xml:
yang:ietf ipv4 unicast routing"; prefix "v4ur"; import ietf routing { prefix "rt"; description "An 'ietf routing' module version that is compatible with the Network Management Datastore Architecture (NMDA) is required."
This YANG module augments the 'ietf routing' module with basic parameters for IPv4 unicast routing.
The model fully conforms to the Network Management Datastore Architecture (NMDA).
IETF Trust and the persons identified as authors of the code.
Redistribution and use in source and binary forms, with or without modification, is permitted pursuant to, and subject to the license terms contained in, the Simplified BSD License set forth in Section 4.c of the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license info).
This version of this YANG module is part of RFC 8349; see the RFC itself for full legal notices."; revision 2018 03 13 { description "Network Management Datastore Architecture (NMDA) revision."
/ identity ipv4 unicast { base rt:
/rt:route" { when "derived from or self(..
This augment is valid only for IPv4 unicast."
active route/rt:input" { when "derived from or
This augment is valid only for IPv4 unicast RIBs.
/rt:route" { when "derived from or self(..
This augment is valid only for IPv4 unicast."
This augment is valid only for IPv4 unicast."
ipv4 address; description "IPv4 address of the next hop."
The subsequent data nodes are obviated and obsoleted   by the Network Management Datastore Architecture   as described in RFC 8342.
/rt:route" { when "derived from or self(..
This augment is valid only for IPv4 unicast."
This augment is valid only for IPv4 unicast."
; } status obsolete; description "Augments the 'simple next hop' case in IPv4 unicast routes."; leaf next hop address { type inet:
ipv4 address; status obsolete; description "IPv4 address of the next hop."
This augment is valid only for IPv4 unicast."
This augment is valid only for IPv4 unicast RIBs."
/rt:route" { when "derived from or self(..
This augment is valid only for IPv4 unicast."
This augment is valid only for IPv4 unicast."
; } status obsolete; description "Augments
the 'simple next hop' case in the reply to the 'active route' action."; leaf next hop address { type inet:
ipv4 address; status obsolete; description "IPv4 address of the next hop."
This augment is valid only for IPv4 unicast."
; } status obsolete; description "Augments the 'next hop list' case in the reply to the 'active route' action."; leaf next hop address { type inet:
Unicast Routing Management YANG Module <CODE BEGINS> file "ietf
ipv6 unicast routing@2018 03 13.yang"
ipv6 unicast routing { yang version "1.1"; namespace "urn:ietf:params:xml:
This YANG module augments the 'ietf routing' module with basic parameters for IPv6 unicast routing.
The model fully conforms to the Network Management Datastore Architecture (NMDA).
IETF Trust and the persons identified as authors of the code.
Redistribution and use in source and binary forms, with or without modification, is permitted pursuant to, and subject to the license terms contained in, the Simplified BSD License set forth in Section 4.c of the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license info).
This version of this YANG module is part of RFC 8349; see the RFC itself for full legal notices."; revision 2018 03 13 { description "Network Management Datastore Architecture (NMDA) revision."
/rt:route" { when "derived from or self(..
This augment is valid only for IPv6 unicast."
active route/rt:input" { when "derived from or
This augment is valid only for IPv6 unicast RIBs.
/rt:route" { when "derived from or self(..
This augment is valid only for IPv6 unicast."
This augment is valid only for IPv6 unicast."
; leaf next hop address { type inet:
ipv6 address; description "IPv6 address of the next hop."
The subsequent data nodes are obviated and obsoleted   by the Network Management Datastore Architecture   as described in RFC 8342.
/rt:route" { when "derived from or self(..
This augment is valid only for IPv6 unicast."
This augment is valid only for IPv6 unicast."
; } status obsolete; description "Augments the 'simple next hop' case in IPv6 unicast routes."; leaf next hop address { type inet:
This augment is valid only for IPv6 unicast."
This augment is valid only for IPv6 unicast RIBs."
/rt:route" { when "derived from or self(..
This augment is valid only for IPv6 unicast."
This augment is valid only for IPv6 unicast."
; } status obsolete; description "Augments
the 'simple next hop' case in the reply to the 'active route' action."; leaf next hop address { type inet:
This augment is valid only for IPv6 unicast."
; } status obsolete; description "Augments the 'next hop list' case in the reply to the 'active route' action."; leaf next hop address { type inet:
Router Advertisements Submodule <CODE BEGINS
03 13.yang" submodule ietf ipv6 router advertisements { yang version "1.1"; belongs to ietf
This YANG module augments the 'ietf ip' module with parameters for IPv6 Router Advertisements.
The model fully conforms to the Network Management Datastore Architecture (NMDA).
IETF Trust and the persons identified as authors of the code.
Redistribution and use in source and binary forms, with or without modification, is permitted pursuant to, and subject to the license terms contained in, the Simplified BSD License set forth in Section 4.c of the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license info).
This version of this YANG module is part of RFC 8349; see the RFC itself for full legal notices."; reference "RFC 4861: Neighbor Discovery for IP version 6 (IPv6)"; revision 2018 03 13 { description "Network Management Datastore Architecture (NMDA) revision."
/max rtr adv interval" { description "
The value MUST NOT be greater than 75% of 'max rtr adv interval'."
; } description "The minimum time allowed between sending unsolicited multicast Router Advertisements from the interface.
The default value to be used operationally if this leaf is not configured is determined as follows: if max rtr adv interval
9 seconds, the default value is 0.33   max rtr adv interval; otherwise, it is 0.75   max rtr adv interval."; reference "RFC 4861: Neighbor Discovery for IP version 6
A value of zero indicates that no MTU options are sent."; reference "RFC 4861: Neighbor Discovery for IP version 6 (IPv6)
A value of zero means unspecified (by this router).
If this parameter is not configured, the device SHOULD use the IANA specified value for the default IPv4 Time to Live (TTL) parameter that was in effect at the time of implementation."
RFC 1700 is Replaced by an On line Database RFC 4861: Neighbor Discovery for IP version 6
It MUST be either zero or between max rtr adv interval and 9000 seconds.
A value of zero indicates that the router is not to be used as a default router.
These limits may be overridden by specific documents that describe how IPv6 operates over different link layers.
If this parameter is not configured, the device SHOULD use a value of 3   max rtr adv interval."; reference "RFC 4861: Neighbor Discovery for IP version 6
; } container prefix list { description "Support for prefixes to be placed in Prefix Information options in Router Advertisement messages sent from the interface.
Prefixes that are advertised by default but do not have their entries in the child 'prefix' list are advertised with the default values of all parameters.
The link local prefix SHOULD NOT be included in the list of advertised prefixes."
(2) the parameters with which the prefix is advertised are specified (default case)."
; leaf no advertise { type empty; description "The prefix will not be advertised.
This can be used for removing the prefix from the default set of advertised prefixes."
; } case advertise { leaf valid lifetime { type uint32; units "seconds"; default "2592000"; description "The value to be placed in the Valid Lifetime in the Prefix Information option.
This value MUST NOT be greater than valid lifetime."
; } default "604800"; description "The value to be placed in the Preferred Lifetime in the Prefix Information option.
The subsequent data nodes are obviated and obsoleted   by the Network Management Datastore Architecture   as described in RFC 8342.
if:interface/ip:ipv6" { status obsolete; description "Augments interface state data with parameters of IPv6 Router Advertisements."; container ipv6 router advertisements { status obsolete; description "Parameters of IPv6 Router Advertisements."; leaf send advertisements { type boolean; status obsolete; description "
A flag indicating whether or not the router sends periodic Router Advertisements and responds to Router Solicitations."
The value that is placed in the Reachable Time field in the Router Advertisement messages sent by the router.
A value of zero means unspecified (by this router)."
; } leaf retrans timer { type uint32; units "milliseconds"; status obsolete; description "The value that is placed in the Retrans Timer field in the Router Advertisement messages sent by the router.
The value that is placed in the Cur Hop Limit field in the Router Advertisement messages sent by the router.
The value that is placed in the Router Lifetime field of Router Advertisements sent from the interface, in seconds.
A value of zero indicates that the router is not to be used as a default router."
; } container prefix list { status obsolete; description "A list of prefixes that are placed in Prefix Information options in Router Advertisement messages sent from the interface.
The value that is placed in the Valid Lifetime in the Prefix Information option.
The designated value of all 1's (0xffffffff) represents infinity.
The value that is placed in the Preferred Lifetime in the Prefix Information option, in seconds.
The designated value of all 1's (0xffffffff) represents infinity.
An implementation SHOULD keep this value constant in consecutive advertisements, except when it is explicitly changed in configuration.";
[RFC8022] registered the following namespace URIs in the "IETF XML Registry" [RFC3688].
IANA has updated the references to refer to this document.
yang:ietf routing Registrant Contact: The IESG.
N/A; the requested URI is an XML namespace.
yang:ietf ipv4 unicast routing Registrant Contact: The IESG.
N/A; the requested URI is an XML namespace.
ietf ipv6 unicast routing Registrant Contact
N/A; the requested URI is an XML namespace.
[RFC8022] registered the following YANG modules in the "YANG Module Names" registry [RFC6020].
IANA has updated (1) the modules per this document and (2) the references to refer to this document.
ietf ipv4 unicast routing Namespace
ietf ipv6 unicast routing Namespace
ietf ipv6 unicast routing Prefix:
This document registers the following YANG submodule in the "YANG Module Names" registry [RFC6020]:
ietf ipv6 unicast routing Reference:
The YANG modules specified in this document define a schema for data that is designed to be accessed via network management protocols such as NETCONF [RFC6241] or RESTCONF [RFC8040].
The lowest NETCONF layer is the secure transport layer, and the mandatory to implement secure transport is Secure Shell (SSH) [RFC6242].
The lowest RESTCONF layer is HTTPS, and the mandatory to implement secure transport is TLS [RFC5246].
The NETCONF access control model [RFC8341] provides the means to restrict access for particular NETCONF or RESTCONF users to a preconfigured subset of all available NETCONF or RESTCONF protocol operations and content.
There are a number of data nodes defined in these YANG modules that are writable/creatable/deletable (i.e., config true, which is the default).
These data nodes may be considered sensitive or vulnerable in some network environments.
Write operations (e.g., edit config) to these data nodes without proper protection can have a negative effect on network operations.
These are the subtrees and data nodes and their sensitivity/vulnerability: /routing/control plane protocols/control plane protocol:
This list specifies the control plane protocols configured on a device.
This list specifies the RIBs configured for the device.
Some of the readable data nodes in these YANG modules may be considered sensitive or vulnerable in some network environments.
It is thus important to control
read access (e.g., via get, get config, or notification) to these data nodes.
These are the subtrees and data nodes and their sensitivity/vulnerability: /routing/control plane protocols/control plane protocol:
This list specifies the control plane protocols configured on a device.
Refer to the control plane models for a list of sensitive information.
This list specifies the RIBs and their contents for the device.
Access to this information may disclose the network topology and/or other information.
Some of the RPC operations in this YANG module may be considered sensitive or vulnerable in some network environments.
It is thus important to control access to these operations.
These are the operations and their sensitivity/vulnerability: /routing/ribs/rib/active route:
The output from this RPC operation returns the route that is being used for a specified destination.
Access to this information may disclose the network topology or relationship (e.g., client/provider).
Additionally, the routes used by a network device may be used to mount a subsequent attack on traffic traversing the network device.
This appendix presents the complete tree of the core routing data model.
See [RFC8340] for an explanation of the symbols used.
The data type of every leaf node is shown near the right end of the corresponding line.
module: ietf routing  rw routing
dotted quad o ro interfaces
string o ro address family    identityref o ro default rib?
o ro (next hop options)
o ro special next hop?
o ro next hop list
inet:ipv6 prefix o x active route o w input
o ro (next hop options)
o ro special next hop?
ipv6 address o ro source protocol
inet:ipv4 prefix o ro v6ur:destination prefix?
ietf ipv6 unicast routing augment
rw max rtr adv interval?
rw min rtr adv interval?
o ro max rtr adv interval?
o ro min rtr adv interval?
o ro other config flag?
o ro cur hop limit?
uint32 o ro on link flag?
boolean o ro preferred lifetime?
Appendix B.  Minimum Implementation Some parts and options of the core routing model, such as user defined RIBs, are intended only for advanced routers.
This appendix gives basic non normative guidelines for implementing a bare minimum of available functions.
Such an implementation may be used for hosts or very simple routers.
A minimum implementation does not support the "multiple ribs" feature.
This means that a single system controlled RIB is available for each supported address family   IPv4, IPv6, or both.
These RIBs are also the default RIBs.
No user controlled RIBs are allowed.
In addition to the mandatory instance of the "direct" pseudo protocol, a minimum implementation should support configuring instance(s) of the "static" pseudo protocol.
For hosts that are never intended to act as routers, the ability to turn on sending IPv6 Router Advertisements (Section 5.4) should be removed.
Platforms with severely constrained resources may use deviations for restricting the data model, e.g., limiting the number of "static" control plane protocol instances.
Adding a New Control Plane Protocol
This appendix demonstrates how the core routing data model can be extended to support a new control plane protocol.
The YANG module "example rip" shown below is intended as an illustration rather than a real definition of a data model for the Routing Information Protocol (RIP).
For the sake of brevity, this module does not obey all the guidelines specified in [YANG Guidelines].
/rt:route" { when "derived from or self(rt:source protocol, 'rip:rip')
/rt:route" { description "RIP specific route attributes in the output of an 'active route' RPC."
Appendix D.  Data Tree Example
This section contains an example of an instance data tree from the operational state, in JSON encoding [RFC7951].
(This example includes "iana if type", which is defined in [RFC7224].)
IPv6 Router Advertisements are configured only on the "eth1" interface and disabled on the upstream "eth0" interface.
db8:0:2::1   Figure 2: Example of Network Configuration
Static routing is used for the internal network.
This section gives an example of an XML [W3C.REC xml 20081126] reply to the NETCONF <get data> request for <operational> for a device that implements the example data models above.
base:1.0" message id "101"> <data
<control plane protocols or:origin "or:intended"> <control plane protocol> <type>ietf routing:static</type> <name
<route> <destination prefix>0.0.0.0/0</destination prefix> <next hop
<destination prefix>::/0</destination prefix> <next hop
address>2001:db8:0:1::2</next hop address> </next hop
ipv6> </static routes> </control plane protocol> </control plane protocols>
<ribs> <rib or:origin "or:intended"> <name>ipv4 master</name
> ietf ipv4 unicast routing:
<route preference>0</route preference> <source protocol
updated>2015 10 24T17:11:27 02:00</last updated> </route
<ietf ipv4 unicast routing:destination prefix> 198.51.100.0/24 </ietf
> <route preference>0</route preference> <source protocol
updated>2015 10 24T17:11:27 02:00</last updated> </route
> <ietf ipv4 unicast routing:next hop address>192.0.2.2 </ietf
next hop address> </next hop
> <route preference>5</route preference> <source protocol
updated>2015 10 24T18:02:45 02:00</last updated> </route> </routes
<route preference>0</route preference> <source protocol
updated>2015 10 24T17:11:27 02:00</last updated> </route
> <route preference>0</route preference> <source protocol
updated>2015 10 24T17:11:27 02:00</last updated> </route
destination prefix> <next hop> <ietf
next hop address> </next hop
> <route preference>5</route preference> <source protocol
updated>2015 10 24T18:02:45 02:00</last updated> </route> </routes
