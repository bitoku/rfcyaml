- contents:
  - '                    Telephony Routing over IP (TRIP)

    '
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2002).  All Rights Reserved.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document presents the Telephony Routing over IP (TRIP).  TRIP
    is\n   a policy driven inter-administrative domain protocol for advertising\n
    \  the reachability of telephony destinations between location servers,\n   and
    for advertising attributes of the routes to those destinations.\n   TRIP's operation
    is independent of any signaling protocol, hence TRIP\n   can serve as the telephony
    routing protocol for any signaling\n   protocol.\n   The Border Gateway Protocol
    (BGP-4) is used to distribute routing\n   information between administrative domains.
    \ TRIP is used to\n   distribute telephony routing information between telephony\n
    \  administrative domains.  The similarity between the two protocols is\n   obvious,
    and hence TRIP is modeled after BGP-4.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1    Terminology and Definitions  ..............................
    \  3\n   2    Introduction  .............................................   4\n
    \  3    Summary of Operation  .....................................   5\n   3.1
    \ Peering Session Establishment and Maintenance  ............   5\n   3.2  Database
    Exchanges  .......................................   6\n   3.3  Internal Versus
    External Synchronization  .................   6\n   3.4  Advertising TRIP Routes
    \ ..................................   6\n   3.5  Telephony Routing Information
    Bases  ......................   7\n   3.6  Routes in TRIP  ...........................................
    \  9\n   3.7  Aggregation  ..............................................   9\n
    \  4    Message Formats  ..........................................  10\n   4.1
    \ Message Header Format  ....................................  10\n   4.2  OPEN
    Message Format  ......................................  11\n   4.3  UPDATE Message
    Format  ....................................  15\n   4.4  KEEPALIVE Message Format
    \  ................................  22\n   4.5  NOTIFICATION Message Format   .............................
    \ 23\n   5    TRIP Attributes   .........................................  24\n
    \  5.1  WithdrawnRoutes  ..........................................  24\n   5.2
    \ ReachableRoutes  ..........................................  28\n   5.3  NextHopServer
    \  ...........................................  29\n   5.4  AdvertisementPath
    \  .......................................  31\n   5.5  RoutedPath  ...............................................
    \ 35\n   5.6  AtomicAggregate   .........................................  36\n
    \  5.7  LocalPreference   .........................................  37\n   5.8
    \ MultiExitDisc  ............................................  38\n   5.9  Communities
    \ ..............................................  39\n   5.10 ITAD Topology    ..........................................
    \ 41\n   5.11 ConvertedRoute  ...........................................  43\n
    \  5.12 Considerations for Defining New TRIP Attributes   .........  44\n   6
    \   TRIP Error Detection and Handling   .......................  44\n   6.1  Message
    Header Error Detection and Handling   .............  45\n   6.2  OPEN Message
    Error Detection and Handling   ...............  45\n   6.3  UPDATE Message Error
    Detection and Handling   .............  46\n   6.4  NOTIFICATION Message Error
    Detection and Handling   .......  48\n   6.5  Hold Timer Expired Error Handling
    \  .......................  48\n   6.6  Finite State Machine Error Handling   .....................
    \ 48\n   6.7  Cease   ...................................................  48\n
    \  6.8  Connection Collision Detection   ..........................  48\n   7
    \   TRIP Version Negotiation   ................................  49\n   8    TRIP
    Capability Negotiation   .............................  50\n   9    TRIP Finite
    State Machine   ...............................  50\n   10   UPDATE Message Handling
    \  .................................  55\n   10.1 Flooding Process   ........................................
    \ 56\n   10.2 Decision Process   ........................................  58\n
    \  10.3  Update-Send Process   ..................................... 62\n   10.4
    \ Route Selection Criteria   ................................ 67\n   10.5  Originating
    TRIP Routes   ................................. 67\n   11    TRIP Transport   ..........................................
    68\n   12    ITAD Topology   ........................................... 68\n
    \  13    IANA Considerations  ...................................... 68\n   13.1
    \ TRIP Capabilities   ....................................... 68\n   13.2  TRIP
    Attributes    ........................................ 69\n   13.3  Destination
    Address Families   ............................ 69\n   13.4  TRIP Application
    Protocols   .............................. 69\n   13.5  ITAD Numbers   ............................................
    70\n   14    Security Considerations   ................................. 70\n
    \  A1    Appendix 1: TRIP FSM State Transitions and Actions   ...... 71\n   A2
    \   Appendix 2: Implementation Recommendations   .............. 73\n   Acknowledgments
    \ ................................................ 75\n   References  .....................................................
    75\n   Intellectual Property Notice  ................................... 77\n
    \  Authors' Addresses  ............................................. 78\n   Full
    Copyright Statement  ....................................... 79\n"
  title: Table of Contents
- contents:
  - "1. Terminology and Definitions\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
    \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",
    and \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC
    2119 [1].\n   A framework for Telephony Routing over IP (TRIP) is described in
    [2].\n   We assume the reader is familiar with the framework and terminology\n
    \  of [2].  We define and use the following terms in addition to those\n   defined
    in [2].\n   Telephony Routing Information Base (TRIB): The database of reachable\n
    \  telephony destinations built and maintained at an LS as a result of\n   its
    participation in TRIP.\n   IP Telephony Administrative Domain (ITAD): The set
    of resources\n   (gateways, location servers, etc.) under the control of a single\n
    \  administrative authority.  End users are customers of an ITAD.\n   Less/More
    Specific Route: A route X is said to be less specific than\n   a route Y if every
    destination in Y is also a destination in X, and X\n   and Y are not equal.  In
    this case, Y is also said to be more\n   specific than X.\n   Aggregation: Aggregation
    is the process by which multiple routes are\n   combined into a single less specific
    route that covers the same set\n   of destinations.  Aggregation is used to reduce
    the size of the TRIB\n   being synchronized with peer LSs by reducing the number
    of exported\n   TRIP routes.\n   Peers: Two LSs that share a logical association
    (a transport\n   connection).  If the LSs are in the same ITAD, they are internal\n
    \  peers.  Otherwise, they are external peers.  The logical association\n   between
    two peer LSs is called a peering session.\n   Telephony Routing Information Protocol
    (TRIP): The protocol defined\n   in this specification.  The function of TRIP
    is to advertise the\n   reachability of telephony destinations, attributes associated
    with\n   the destinations, as well as the attributes of the path towards those\n
    \  destinations.\n   TRIP destination: TRIP can be used to manage routing tables
    for\n   multiple protocols (SIP, H323, etc.).  In TRIP, a destination is the\n
    \  combination of (a) a set of addresses (given by an address family and\n   address
    prefix), and (b) an application protocol (SIP, H323, etc).\n"
  title: 1. Terminology and Definitions
- contents:
  - "2. Introduction\n   The gateway location and routing problem has been introduced
    in [2].\n   It is considered one of the more difficult problems in IP telephony.\n
    \  The selection of an egress gateway for a telephony call, traversing\n   an
    IP network towards an ultimate destination in the PSTN, is driven\n   in large
    part by the policies of the various parties along the path,\n   and by the relationships
    established between these parties.  As such,\n   a global directory of egress
    gateways in which users look up\n   destination phone numbers is not a feasible
    solution.  Rather,\n   information about the availability of egress gateways is
    exchanged\n   between providers, and subject to policy, made available locally
    and\n   then propagated to other providers in other ITADs, thus creating\n   routes
    towards these egress gateways.  This would allow each provider\n   to create its
    own database of reachable phone numbers and the\n   associated routes - such a
    database could be very different for each\n   provider depending on policy.\n
    \  TRIP is an inter-domain (i.e., inter-ITAD) gateway location and\n   routing
    protocol.  The primary function of a TRIP speaker, called a\n   location server
    (LS), is to exchange information with other LSs.\n   This information includes
    the reachability of telephony destinations,\n   the routes towards these destinations,
    and information about gateways\n   towards those telephony destinations residing
    in the PSTN.  The TRIP\n   requirements are set forth in [2].\n   LSs exchange
    sufficient routing information to construct a graph of\n   ITAD connectivity so
    that routing loops may be prevented.  In\n   addition, TRIP can be used to exchange
    attributes necessary to\n   enforce policies and to select routes based on path
    or gateway\n   characteristics.  This specification defines TRIP's transport and\n
    \  synchronization mechanisms, its finite state machine, and the TRIP\n   data.
    \ This specification defines the basic attributes of TRIP.  The\n   TRIP attribute
    set is extendible, so additional attributes may be\n   defined in future documents.\n
    \  TRIP is modeled after the Border Gateway Protocol 4 (BGP-4) [3] and\n   enhanced
    with some link state features, as in the Open Shortest Path\n   First (OSPF) protocol
    [4], IS-IS [5], and the Server Cache\n   Synchronization Protocol (SCSP) [6].
    \ TRIP uses BGP's inter-domain\n   transport mechanism, BGP's peer communication,
    BGP's finite state\n   machine, and similar formats and attributes as BGP.  Unlike
    BGP\n   however, TRIP permits generic intra-domain LS topologies, which\n   simplifies
    configuration and increases scalability in contrast to\n   BGP's full mesh requirement
    of internal BGP speakers.  TRIP uses an\n   intra-domain flooding mechanism similar
    to that used in OSPF [4],\n   IS-IS [5], and SCSP [6].\n   TRIP permits aggregation
    of routes as they are advertised through the\n   network.  TRIP does not define
    a specific route selection algorithm.\n   TRIP runs over a reliable transport
    protocol.  This eliminates the\n   need to implement explicit fragmentation, retransmission,\n
    \  acknowledgment, and sequencing.  The error notification mechanism\n   used
    in TRIP assumes that the transport protocol supports a graceful\n   close, i.e.,
    that all outstanding data will be delivered before the\n   connection is closed.\n
    \  TRIP's operation is independent of any particular telephony signaling\n   protocol.
    \ Therefore, TRIP can be used as the routing protocol for\n   any of these protocols,
    e.g., H.323 [7] and SIP [8].\n   The LS peering topology is independent of the
    physical topology of\n   the network.  In addition, the boundaries of an ITAD
    are independent\n   of the boundaries of the layer 3 routing autonomous systems.
    \ Neither\n   internal nor external TRIP peers need to be physically adjacent.\n"
  title: 2. Introduction
- contents:
  - "3. Summary of Operation\n   This section summarizes the operation of TRIP.  Details
    are provided\n   in later sections.\n"
  - contents:
    - "3.1. Peering Session Establishment and Maintenance\n   Two peer LSs form a
      transport protocol connection between one\n   another.  They exchange messages
      to open and confirm the connection\n   parameters, and to negotiate the capabilities
      of each LS as well as\n   the type of information to be advertised over this
      connection.\n   KeepAlive messages are sent periodically to ensure adjacent
      peers are\n   operational.  Notification messages are sent in response to errors
      or\n   special conditions.  If a connection encounters an error condition, a\n
      \  Notification message is sent and the connection is closed.\n"
    title: 3.1. Peering Session Establishment and Maintenance
  - contents:
    - "3.2. Database Exchanges\n   Once the peer connection has been established,
      the initial data flow\n   is a dump of all routes relevant to the new peer (In
      the case of an\n   external peer, all routes in the LS's Adj-TRIB-Out for that
      external\n   peer.  In the case of an internal peer, all routes in the Ext-TRIB\n
      \  and all Adj-TRIBs-In).  Note that the different TRIBs are defined in\n   Section
      3.5.\n   Incremental updates are sent as the TRIP routing tables (TRIBs)\n   change.
      \ TRIP does not require periodic refresh of the routes.\n   Therefore, an LS
      must retain the current version of all routing\n   entries.\n   If a particular
      ITAD has multiple LSs and is providing transit\n   service for other ITADs,
      then care must be taken to ensure a\n   consistent view of routing within the
      ITAD.  When synchronized the\n   TRIP routing tables, i.e., the Loc-TRIBs, of
      all internal peers are\n   identical.\n"
    title: 3.2. Database Exchanges
  - contents:
    - "3.3. Internal Versus External Synchronization\n   As with BGP, TRIP distinguishes
      between internal and external peers.\n   Within an ITAD, internal TRIP uses
      link-state mechanisms to flood\n   database updates over an arbitrary topology.
      \ Externally, TRIP uses\n   point-to-point peering relationships to exchange
      database\n   information.\n   To achieve internal synchronization, internal
      peer connections are\n   configured between LSs of the same ITAD such that the
      resulting\n   intra-domain LS topology is connected and sufficiently redundant.\n
      \  This is different from BGP's approach that requires all internal\n   peers
      to be connected in a full mesh topology, which may result in\n   scaling problems.
      \ When an update is received from an internal peer,\n   the routes in the update
      are checked to determine if they are newer\n   than the version already in the
      database.  Newer routes are then\n   flooded to all other peers in the same
      domain.\n"
    title: 3.3. Internal Versus External Synchronization
  - contents:
    - "3.4. Advertising TRIP Routes\n   In TRIP, a route is defined as the combination
      of (a) a set of\n   destination addresses (given by an address family indicator
      and an\n   address prefix), and (b) an application protocol (e.g. SIP, H323,\n
      \  etc.).  Generally, there are additional attributes associated with\n   each
      route (for example, the next-hop server).\n   TRIP routes are advertised between
      a pair of LSs in UPDATE messages.\n   The destination addresses are included
      in the ReachableRoutes\n   attribute of the UPDATE, while other attributes describe
      things like\n   the path or egress gateway.\n   If an LS chooses to advertise
      a TRIP route, it may add to or modify\n   the attributes of the route before
      advertising it to a peer.  TRIP\n   provides mechanisms by which an LS can inform
      its peer that a\n   previously advertised route is no longer available for use.
      \ There\n   are three methods by which a given LS can indicate that a route
      has\n   been withdrawn from service:\n      -  Include the route in the WithdrawnRoutes
      Attribute in an UPDATE\n         message, thus marking the associated destinations
      as being no\n         longer available for use.\n      -  Advertise a replacement
      route with the same set of destinations\n         in the ReachableRoutes Attribute.\n
      \     -  For external peers where flooding is not in use, the LS-to-LS\n         peer
      connection can be closed, which implicitly removes from\n         service all
      routes which the pair of LSs had advertised to each\n         other over that
      peer session.  Note that terminating an\n         internal peering session does
      not necessarily remove the routes\n         advertised by the peer LS as the
      same routes may have been\n         received from multiple internal peers because
      of flooding.  If\n         an LS determines that another internal LS is no longer
      active\n         (from the ITAD Topology attributes of the UPDATE messages from\n
      \        other internal peers), then it MUST remove all routes\n         originated
      into the LS by that LS and rerun its decision\n         process.\n"
    title: 3.4. Advertising TRIP Routes
  - contents:
    - "3.5. Telephony Routing Information Bases\n   A TRIP LS processes three types
      of routes:\n      -  External routes: An external route is a route received
      from an\n         external peer LS\n      -  Internal routes: An internal route
      is a route received from an\n         internal LS in the same ITAD.\n      -
      \ Local routes: A local route is a route locally injected into\n         TRIP,
      e.g. by configuration or by route redistribution from\n         another routing
      protocol.\n   The Telephony Routing Information Base (TRIB) within an LS consists\n
      \  of four distinct parts:\n      -  Adj-TRIBs-In: The Adj-TRIBs-In store routing
      information that\n         has been learned from inbound UPDATE messages.  Their
      contents\n         represent TRIP routes that are available as an input to the\n
      \        Decision Process.  These are the \"unprocessed\" routes received.\n
      \        The routes from each external peer LS and each internal LS are\n         maintained
      in this database independently, so that updates from\n         one peer do not
      affect the routes received from another LS.\n         Note that there is an
      Adj-TRIB-In for every LS within the\n         domain, even those with which
      the LS is not directly peered.\n      -  Ext-TRIB: There is only one Ext-TRIB
      database per LS.  The LS\n         runs the route selection algorithm on all
      external routes\n         (stored in the Adj-TRIBs-In of the external peers)
      and local\n         routes (may be stored in an Adj-TRIB-In representing the
      local\n         LS) and selects the best route for a given destination and\n
      \        stores it in the Ext-TRIB.  The use of Ext-TRIB will be\n         explained
      further in Section 10.3.1\n      -  Loc-TRIB: The Loc-TRIB contains the local
      TRIP routing\n         information that the LS has selected by applying its
      local\n         policies to the routing information contained in its Adj-\n
      \        TRIBs-In of internal LSs and the Ext-TRIB.\n      -  Adj-TRIBs-Out:
      \ The Adj-TRIBs-Out store the information that\n         the local LS has selected
      for advertisement to its external\n         peers.  The routing information
      stored in the Adj-TRIBs-Out\n         will be carried in the local LS's UPDATE
      messages and\n         advertised to its peers.\n   Figure 1 illustrates the
      relationship between the four parts of the\n   routing information base.\n                            Loc-TRIB\n
      \                               ^\n                                |\n                        Decision
      Process\n                         ^      ^      |\n                         |
      \     |      |\n                Adj-TRIBs-In    |      V\n               (Internal
      LSs)   |   Adj-TRIBs-Out\n                                |\n                                |\n
      \                               |\n                             Ext-TRIB\n                            ^
      \       ^\n                            |        |\n                   Adj-TRIB-In
      \     Local Routes\n               (External Peers)\n                     Figure
      1: TRIB Relationships\n   Although the conceptual model distinguishes between
      Adj-TRIBs-In,\n   Ext-TRIB, Loc-TRIB, and Adj-TRIBs-Out, this neither implies
      nor\n   requires that an implementation must maintain four separate copies of\n
      \  the routing information.  The choice of implementation (for example,\n   4
      copies of the information vs. 1 copy with pointers) is not\n   constrained by
      the protocol.\n"
    title: 3.5. Telephony Routing Information Bases
  - contents:
    - "3.6. Routes in TRIP\n   A route in TRIP specifies a range of numbers by being
      a prefix of\n   those numbers (the exact definition & syntax of route are in
      5.1.1).\n   Arbitrary ranges of numbers are not atomically representable by
      a\n   route in TRIP.  A prefix range is the only type of range supported\n   atomically.
      \ An arbitrary range can be accomplished by using multiple\n   prefixes in a
      ReachableRoutes attribute (see Section 5.1 & 5.2).  For\n   example, 222-xxxx
      thru 999-xxxx could be represented by including the\n   prefixes 222, 223, 224,...,23,24,...,3,4,...,9
      in a ReachableRoutes\n   attribute.\n"
    title: 3.6. Routes in TRIP
  - contents:
    - "3.7. Aggregation\n   Aggregation is a scaling enhancement used by an LS to
      reduce the\n   number of routing entries that it has to synchronize with its
      peers.\n   Aggregation may be performed by an LS when there is a set of routes\n
      \  {R1, R2, ...} in its TRIB such that there exists a less specific\n   route
      R where every valid destination in R is also a valid\n   destination in {R1,
      R2, ...} and vice-versa.  Section 5 includes a\n   description of how to combine
      each attribute (by type) on the {R1,\n   R2, ...} routes into an attribute for
      R.\n   Note that there is no mechanism within TRIP to communicate that a\n   particular
      address prefix is not used or valid within a particular\n   address family,
      and thus that these addresses could be skipped during\n   aggregation.  LSs
      may use methods outside of TRIP to learn of invalid\n   prefixes that may be
      ignored during aggregation.\n   An LS is not required to perform aggregation,
      however it is\n   recommended whenever maintaining a smaller TRIB is important.
      \ An LS\n   decides based on its local policy whether or not to aggregate a
      set\n   of routes into a single aggregate route.\n   Whenever an LS aggregates
      multiple routes where the NextHopServer is\n   not identical in all aggregated
      routes, the NextHopServer attribute\n   of the aggregate route must be set to
      a signalling server in the\n   aggregating LS's domain.\n   When an LS resets
      the NextHopServer of any route, and this may be\n   performed because of aggregation
      or other reasons, it has the effect\n   of adding another signalling server
      along the signalling path to\n   these destinations.  The end result is that
      the signalling path\n   between two destinations may consist of multiple signalling
      servers\n   across multiple domains.\n"
    title: 3.7. Aggregation
  title: 3. Summary of Operation
- contents:
  - "4. Message Formats\n   This section describes message formats used by TRIP.  Messages
    are\n   sent over a reliable transport protocol connection.  A message MUST\n
    \  be processed only after it is entirely received.  The maximum message\n   size
    is 4096 octets.  All implementations MUST support this maximum\n   message size.
    \ The smallest message that MAY be sent consists of a\n   TRIP header without
    a data portion, or 3 octets.\n"
  - contents:
    - "4.1. Message Header Format\n   Each message has a fixed-size header.  There
      may or may not be a data\n   portion following the header, depending on the
      message type.  The\n   layout of the header fields is shown in Figure 2.\n         0
      \                  1                   2\n         0 1 2 3 4 5 6 7 8 9 0 1 2
      3 4 5 6 7 8 9 0 1 2 3\n         +--------------+----------------+---------------+\n
      \        |          Length               |      Type     |\n         +--------------+----------------+---------------+\n
      \                     Figure 2: TRIP Header\n   Length:  This 2-octet unsigned
      integer indicates the total length of\n   the message, including the header,
      in octets.  Thus, it allows one to\n   locate, in the transport-level stream,
      the beginning of the next\n   message.  The value of the Length field must always
      be at least 3 and\n   no greater than 4096, and may be further constrained depending
      on the\n   message type.  No padding of extra data after the message is allowed,\n
      \  so the Length field must have the smallest value possible given the\n   rest
      of the message.\n   Type:  This 1-octet unsigned integer indicates the type
      code of the\n   message.  The following type codes are defined:\n      1 - OPEN\n
      \     2 - UPDATE\n      3 - NOTIFICATION\n      4 - KEEPALIVE\n"
    title: 4.1. Message Header Format
  - contents:
    - "4.2. OPEN Message Format\n   After a transport protocol connection is established,
      the first\n   message sent by each side is an OPEN message.  If the OPEN message
      is\n   acceptable, a KEEPALIVE message confirming the OPEN is sent back.\n   Once
      the OPEN is confirmed, UPDATE, KEEPALIVE, and NOTIFICATION\n   messages may
      be exchanged.\n   The minimum length of the OPEN message is 17 octets (including\n
      \  message header).  OPEN messages not meeting this minimum requirement\n   are
      handled as defined in Section 6.2.\n   In addition to the fixed-size TRIP header,
      the OPEN message contains\n   the following fields:\n       0                   1
      \                  2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3
      4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +---------------+---------------+--------------+----------------+\n
      \     |    Version    |    Reserved   |          Hold Time            |\n      +---------------+---------------+--------------+----------------+\n
      \     |                            My ITAD                            |\n      +---------------+---------------+--------------+----------------+\n
      \     |                        TRIP Identifier                        |\n      +---------------+---------------+--------------+----------------+\n
      \     |    Optional Parameters Len    |Optional Parameters (variable)...\n      +---------------+---------------+--------------+----------------+\n
      \                       Figure 3: TRIP OPEN Header\n   Version:\n   This 1-octet
      unsigned integer indicates the protocol version of the\n   message.  The current
      TRIP version number is 1.\n   Hold Time:\n   This 2-octet unsigned integer indicates
      the number of seconds that\n   the sender proposes for the value of the Hold
      Timer.  Upon receipt of\n   an OPEN message, an LS MUST calculate the value
      of the Hold Timer by\n   using the smaller of its configured Hold Time and the
      Hold Time\n   received in the OPEN message.  The Hold Time MUST be either zero
      or\n   at least three seconds.  An implementation MAY reject connections on\n
      \  the basis of the Hold Time.  The calculated value indicates the\n   maximum
      number of seconds that may elapse between the receipt of\n   successive KEEPALIVE
      and/or UPDATE messages by the sender.\n   This 4-octet unsigned integer indicates
      the ITAD number of the\n   sender.  The ITAD number must be unique for this
      domain within this\n   confederation of cooperating LSs.\n   ITAD numbers are
      assigned by IANA as specified in Section 13.  This\n   document reserves ITAD
      number 0.  ITAD numbers from 1 to 255 are\n   designated for private use.\n
      \  TRIP Identifier:\n   This 4-octet unsigned integer indicates the TRIP Identifier
      of the\n   sender.  The TRIP Identifier MUST uniquely identify this LS within\n
      \  its ITAD.  A given LS MAY set the value of its TRIP Identifier to an\n   IPv4
      address assigned to that LS.  The value of the TRIP Identifier\n   is determined
      on startup and MUST be the same for all peer\n   connections.  When comparing
      two TRIP identifiers, the TRIP\n   Identifier is interpreted as a numerical
      4-octet unsigned integer.\n   Optional Parameters Length:\n   This 2-octet unsigned
      integer indicates the total length of the\n   Optional Parameters field in octets.
      \ If the value of this field is\n   zero, no Optional Parameters are present.\n
      \  Optional Parameters:\n   This field may contain a list of optional parameters,
      where each\n   parameter is encoded as a <Parameter Type, Parameter Length,\n
      \  Parameter Value> triplet.\n       0                   1                   2\n
      \      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +---------------+---------------+--------------+----------------+\n
      \     |       Parameter Type          |       Parameter Length        |\n      +---------------+---------------+--------------+----------------+\n
      \     |                  Parameter Value (variable)...\n      +---------------+---------------+--------------+----------------+\n
      \                   Figure 4: Optional Parameter Encoding\n   Parameter Type:\n
      \  This is a 2-octet field that unambiguously identifies individual\n   parameters.\n
      \  Parameter Length:\n   This is a 2-octet field that contains the length of
      the Parameter\n   Value field in octets.\n   Parameter Value:\n   This is a
      variable length field that is interpreted according to the\n   value of the
      Parameter Type field.\n"
    - contents:
      - "4.2.1. Open Message Optional Parameters\n   This document defines the following
        Optional Parameters for the OPEN\n   message.\n"
      - contents:
        - "4.2.1.1. Capability Information\n   Capability Information uses Optional
          Parameter type 1.  This is an\n   optional parameter used by an LS to convey
          to its peer the list of\n   capabilities supported by the LS.  This permits
          an LS to learn of the\n   capabilities of its peer LSs.  Capability negotiation
          is defined in\n   Section 8.\n   The parameter contains one or more triples
          <Capability Code,\n   Capability Length, Capability Value>, where each triple
          is encoded as\n   shown below:\n    0                   1                   2\n
          \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +---------------+---------------+--------------+----------------+\n
          \  |       Capability Code         |       Capability Length       |\n   +---------------+---------------+--------------+----------------+\n
          \  |       Capability Value (variable)...\n   +---------------+---------------+--------------+----------------+\n
          \          Figure 5:  Capability Optional Parameter\n   Capability Code:\n
          \  Capability Code is a 2-octet field that unambiguously identifies\n   individual
          capabilities.\n   Capability Length:\n   Capability Length is a 2-octet
          field that contains the length of the\n   Capability Value field in octets.\n
          \  Capability Value:\n   Capability Value is a variable length field that
          is interpreted\n   according to the value of the Capability Code field.\n
          \  Any particular capability, as identified by its Capability Code, may\n
          \  appear more than once within the Optional Parameter.\n   This document
          reserves Capability Codes 32768-65535 for vendor-\n   specific applications
          (these are the codes with the first bit of the\n   code value equal to 1).
          \ This document reserves value 0.  Capability\n   Codes (other than those
          reserved for vendor specific use) are\n   controlled by IANA.  See Section
          13 for IANA considerations.\n   The following Capability Codes are defined
          by this specification:\n      Code           Capability\n      1              Route
          Types Supported\n      2              Send Receive Capability\n"
        - contents:
          - "4.2.1.1.1. Route Types Supported\n   The Route Types Supported Capability
            Code lists the route types\n   supported in this peering session by the
            transmitting LS.  An LS MUST\n   NOT use route types that are not supported
            by the peer LS in any\n   particular peering session.  If the route types
            supported by a peer\n   are not satisfactory, an LS SHOULD terminate the
            peering session.\n   The format for a Route Type is:\n    0                   1
            \                  2\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
            2 3 4 5 6 7 8 9 0 1\n   +---------------+---------------+--------------+----------------+\n
            \  |        Address Family         |     Application Protocol      |\n
            \  +---------------+---------------+--------------+----------------+\n
            \           Figure 6: Route Types Supported Capability\n   The Address
            Family and Application Protocol are as defined in Section\n   5.1.1.  Address
            Family gives the address family being routed (within\n   the ReachableRoutes
            attribute).  The application protocol lists the\n   application for which
            the routes apply.  As an example, a route type\n   for TRIP could be <E.164,
            SIP>, indicating a set of E.164\n   destinations for the SIP protocol.\n
            \  The Route Types Supported Capability MAY contain multiple route types\n
            \  in the capability.  The number of route types within the capability\n
            \  is the maximum number that can fit given the capability length.  The\n
            \  Capability Code is 1 and the length is variable.\n"
          title: 4.2.1.1.1. Route Types Supported
        - contents:
          - "4.2.1.1.2. Send Receive Capability\n   This capability specifies the
            mode in which the LS will operate with\n   this particular peer.  The
            possible modes are: Send Only mode,\n   Receive Only mode, or Send Receive
            mode.  The default mode is Send\n   Receive mode.\n   In Send Only mode,
            an LS transmits UPDATE messages to its peer, but\n   the peer MUST NOT
            transmit UPDATE messages to that LS.  If an LS in\n   Send Only mode receives
            an UPDATE message from its peer, it MUST\n   discard that message, but
            no further action should be taken.\n   The UPDATE messages sent by an
            LS in Send Only mode to its intra-\n   domain peer MUST include the ITAD
            Topology attribute whenever the\n   topology changes.  A useful application
            of an LS in Send Only mode\n   with an external peer is to enable gateway
            registration services.\n   If a service provider terminates calls to a
            set of gateways it owns,\n   but never initiates calls, it can set its
            LSs to operate in Send Only\n   mode, since they only ever need to generate
            UPDATE messages, not\n   receive them.  If an LS in Send Receive mode
            has a peering session\n   with a peer in Send Only mode, that LS MUST
            set its route\n   dissemination policy such that it does not send any
            UPDATE messages\n   to its peer.\n   In Receive Only mode, the LS acts
            as a passive TRIP listener.  It\n   receives and processes UPDATE messages
            from its peer, but it MUST NOT\n   transmit any UPDATE messages to its
            peer.  This is useful for\n   management stations that wish to collect
            topology information for\n   display purposes.\n   The behavior of an
            LS in Send Receive mode is the default TRIP\n   operation specified throughout
            this document.\n   The Send Receive capability is a 4-octet unsigned numeric
            value.  It\n   can only take one of the following three values:\n      1
            - Send Receive mode\n      2 - Send only mode\n      3 - Receive Only
            mode\n   A peering session MUST NOT be established between two LSs if
            both of\n   them are  in Send Only mode or if both of them are in Receive
            Only\n   mode.  If a peer LS detects such a capability mismatch when\n
            \  processing an OPEN message, it MUST respond with a NOTIFICATION\n   message
            and close the peer session.  The error code in the\n   NOTIFICATION message
            must be set to \"Capability Mismatch.\"\n   An LS MUST be configured in
            the same Send Receive mode for all peers.\n"
          title: 4.2.1.1.2. Send Receive Capability
        title: 4.2.1.1. Capability Information
      title: 4.2.1. Open Message Optional Parameters
    title: 4.2. OPEN Message Format
  - contents:
    - "4.3. UPDATE Message Format\n   UPDATE messages are used to transfer routing
      information between LSs.\n   The information in the UPDATE packet can be used
      to construct a graph\n   describing the relationships between the various ITADs.
      \ By applying\n   rules to be discussed, routing information loops and some
      other\n   anomalies can be prevented.\n   An UPDATE message is used to both
      advertise and withdraw routes from\n   service.  An UPDATE message may simultaneously
      advertise and withdraw\n   TRIP routes.\n   In addition to the TRIP header,
      the TRIP UPDATE contains a list of\n   routing attributes as shown in Figure
      7.  There is no padding between\n   routing attributes.\n         +------------------------------------------------+--...\n
      \        | First Route Attribute | Second Route Attribute |  ...\n         +------------------------------------------------+--...\n
      \                   Figure 7: TRIP UPDATE Format\n   The minimum length of an
      UPDATE message is 3 octets (there are no\n   mandatory attributes in TRIP).\n"
    - contents:
      - "4.3.1. Routing Attributes\n   A variable length sequence of routing attributes
        is present in every\n   UPDATE message.  Each attribute is a triple <attribute
        type,\n   attribute length, attribute value> of variable length.\n       0
        \                  1                   2                   3\n       0 1 2
        3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +---------------+---------------+--------------+----------------+\n
        \     |  Attr. Flags  |Attr. Type Code|         Attr. Length          |\n
        \     +---------------+---------------+--------------+----------------+\n
        \     |                   Attribute Value (variable)                  |\n
        \     +---------------+---------------+--------------+----------------+\n
        \                   Figure 8: Routing Attribute Format\n   Attribute Type
        is a two-octet field that consists of the Attribute\n   Flags octet followed
        by the Attribute Type Code octet.\n   The Attribute Type Code defines the
        type of attribute.  The basic\n   TRIP-defined Attribute Type Codes are discussed
        later in this\n   section.  Attributes MUST appear in the UPDATE message in
        numerical\n   order of the Attribute Type Code.  An attribute MUST NOT be
        included\n   more than once in the same UPDATE message.  Attribute Flags are
        used\n   to control attribute processing when the attribute type is unknown.\n
        \  Attribute Flags are further defined in Section 4.3.2.\n   This document
        reserves Attribute Type Codes 224-255 for vendor-\n   specific applications
        (these are the codes with the first three bits\n   of the code equal to 1).
        \ This document reserves value 0.  Attribute\n   Type Codes (other than those
        reserved for vendor specific use) are\n   controlled by IANA.  See Section
        13 for IANA considerations.\n   The third and the fourth octets of the route
        attribute contain the\n   length of the attribute value field in octets.\n
        \  The remaining octets of the attribute represent the Attribute Value\n   and
        are interpreted according to the Attribute Flags and the\n   Attribute Type
        Code.  The basic supported attribute types, their\n   values, and their uses
        are defined in this specification.  These are\n   the attributes necessary
        for proper loop free operation of TRIP, both\n   inter-domain and intra-domain.
        \ Additional attributes may be defined\n   in future documents.\n"
      title: 4.3.1. Routing Attributes
    - contents:
      - "4.3.2. Attribute Flags\n   It is clear that the set of attributes for TRIP
        will evolve over\n   time.  Hence it is essential that mechanisms be provided
        to handle\n   attributes with unrecognized types.  The handling of unrecognized\n
        \  attributes is controlled via the flags field of the attribute.\n   Recognized
        attributes should be processed according to their specific\n   definition.\n
        \  The following are the attribute flags defined by this specification:\n
        \           Bit       Flag\n            0         Well-Known Flag\n            1
        \        Transitive Flag\n            2         Dependent Flag\n            3
        \        Partial Flag\n            4         Link-state Encapsulated Flag\n
        \  The high-order bit (bit 0) of the Attribute Flags octet is the Well-\n
        \  Known Bit.  It defines whether the attribute is not well-known (if\n   set
        to 1) or well-known (if set to 0).  Implementations are not\n   required to
        support not well-known attributes, but MUST support\n   well-known attributes.\n
        \  The second high-order bit (bit 1) of the Attribute Flags octet is the\n
        \  Transitive bit.  It defines whether a not well-known attribute is\n   transitive
        (if set to 1) or non-transitive (if set to 0).  For well-\n   known attributes,
        the Transitive bit MUST be zero on transmit and\n   MUST be ignored on receipt.\n
        \  The third high-order bit (bit 2) of the Attribute Flags octet is the\n
        \  Dependent bit.  It defines whether a transitive attribute is\n   dependent
        (if set to 1) or independent (if set to 0).  For well-known\n   attributes
        and for non-transitive attributes, the Dependent bit is\n   irrelevant, and
        MUST be set to zero on transmit and MUST be ignored\n   on receipt.\n   The
        fourth high-order bit (bit 3) of the Attribute Flags octet is the\n   Partial
        bit.  It defines whether the information contained in the not\n   well-known
        transitive attribute is partial (if set to 1) or complete\n   (if set to 0).
        \ For well-known attributes and for non-transitive\n   attributes the Partial
        bit MUST be set to 0 on transmit and MUST be\n   ignored on receipt.\n   The
        fifth high-order bit (bit 4) of the Attribute Flags octet is the\n   Link-state
        Encapsulation bit.  This bit is only applicable to certain\n   attributes
        (ReachableRoutes and WithdrawnRoutes) and determines the\n   encapsulation
        of the routes within those attributes.  If this bit is\n   set, link-state
        encapsulation is used within the attribute.\n   Otherwise, standard encapsulation
        is used within the attribute.  The\n   Link-state Encapsulation technique
        is described in Section 4.3.2.4.\n   This flag is only valid on the ReachableRoutes
        and WithdrawnRoutes\n   attributes.  It MUST be cleared on transmit and MUST
        be ignored on\n   receipt for all other attributes.\n   The other bits of
        the Attribute Flags octet are unused.  They MUST be\n   zeroed on transmit
        and ignored on receipt.\n"
      - contents:
        - "4.3.2.1. Attribute Flags and Route Selection\n   Any recognized attribute
          can be used as input to the route selection\n   process, although the utility
          of some attributes in route selection\n   is minimal.\n"
        title: 4.3.2.1. Attribute Flags and Route Selection
      - contents:
        - "4.3.2.2. Attribute Flags and Route Dissemination\n   TRIP provides for
          two variations of transitivity due to the fact that\n   intermediate LSs
          need not modify the NextHopServer when propagating\n   routes.  Attributes
          may be non-transitive, dependent transitive, or\n   independent transitive.
          \ An attribute cannot be both dependent\n   transitive and independent transitive.\n
          \  Unrecognized independent transitive attributes may be propagated by\n
          \  any intermediate LS.  Unrecognized dependent transitive attributes\n
          \  MAY only be propagated if the LS is NOT changing the next-hop server.\n
          \  The transitivity variations permit some unrecognized attributes to be\n
          \  carried end-to-end (independent transitive), some to be carried\n   between
          adjacent next-hop servers (dependent transitive), and other\n   to be restricted
          to peer LSs (non-transitive).\n   An LS that passes an unrecognized transitive
          attribute to a peer MUST\n   set the Partial flag on that attribute.  Any
          LS along a path MAY\n   insert a transitive attribute into a route.  If
          any LS except the\n   originating LS inserts a new independent transitive
          attribute into a\n   route, then it MUST set the Partial flag on that attribute.
          \ If any\n   LS except an LS that modifies the NextHopServer inserts a new\n
          \  dependent transitive attribute into a route, then it MUST set the\n   Partial
          flag on that attribute.  The Partial flag indicates that not\n   every LS
          along the relevant path has processed and understood the\n   attribute.
          \ For independent transitive attributes, the \"relevant\n   path\" is the
          path given in the AdvertisementPath attribute.  For\n   dependent transitive
          attributes, the relevant path consists only of\n   those domains thru which
          this object has passed since the\n   NextHopServer was last modified.  The
          Partial flag in an independent\n   transitive attribute MUST NOT be unset
          by any other LS along the\n   path.  The Partial flag in a dependent transitive
          attribute MUST be\n   reset whenever the NextHopServer is changed, but MUST
          NOT be unset by\n   any LS that is not changing the NextHopServer.\n   The
          rules governing the addition of new non-transitive attributes are\n   defined
          independently for each non-transitive attribute.  Any\n   attribute MAY
          be updated by an LS in the path.\n"
        title: 4.3.2.2. Attribute Flags and Route Dissemination
      - contents:
        - "4.3.2.3. Attribute Flags and Route Aggregation\n   Each attribute defines
          how it is to be handled during route\n   aggregation.\n   The rules governing
          the handling of unknown attributes are guided by\n   the Attribute Flags.
          \ Unrecognized transitive attributes are dropped\n   during aggregation.
          \ There should be no unrecognized non-transitive\n   attributes during aggregation
          because non-transitive attributes must\n   be processed by the local LS
          in order to be propagated.\n"
        title: 4.3.2.3. Attribute Flags and Route Aggregation
      - contents:
        - "4.3.2.4. Attribute Flags and Encapsulation\n   Normally attributes have
          the simple format as described in Section\n   4.3.1.  If the Link-state
          Encapsulation Flag is set, then the two\n   additional fields are added
          to the attribute header as shown in\n   Figure 9.\n    0                   1
          \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2
          3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +---------------+---------------+--------------+----------------+\n
          \  |  Attr. Flags  |Attr. Type Code|          Attr. Length         |\n   +---------------+---------------+--------------+----------------+\n
          \  |                  Originator TRIP Identifier                   |\n   +---------------+---------------+--------------+----------------+\n
          \  |                        Sequence Number                        |\n   +---------------+---------------+--------------+----------------+\n
          \  |                   Attribute Value (variable)                  |\n   +---------------+---------------+--------------+----------------+\n
          \                Figure 9: Link State Encapsulation\n   The Originator TRIP
          ID and Sequence Number are used to control the\n   flooding of routing updates
          within a collection of servers.  These\n   fields are used to detect duplicate
          and old routes so that they are\n   not further propagated to other LSs.
          \ The use of these fields is\n   defined in Section 10.1.\n"
        title: 4.3.2.4. Attribute Flags and Encapsulation
      title: 4.3.2. Attribute Flags
    - contents:
      - "4.3.3. Mandatory Attributes\n   There are no Mandatory attributes in TRIP.
        \ However, there are\n   Conditional Mandatory attributes.  A conditional
        mandatory attribute\n   is an attribute, which MUST be included in an UPDATE
        message if\n   another attribute is included in that message.  For example,
        if an\n   UPDATE message includes a ReachableRoutes attribute, it MUST include\n
        \  an AdvertisementPath attribute as well.\n   The three base attributes in
        TRIP are WithdrawnRoutes,\n   ReachableRoutes, and ITAD Topology.  Their presence
        in an UPDATE\n   message is entirely optional and independent of any other
        attributes.\n"
      title: 4.3.3. Mandatory Attributes
    - contents:
      - "4.3.4. TRIP UPDATE Attributes\n   This section summarizes the attributes
        that may be carried in an\n   UPDATE message.  Attributes MUST appear in the
        UPDATE message in\n   increasing order of the Attribute Type Code.  Additional
        details are\n   provided in Section 5.\n"
      - contents:
        - "4.3.4.1. WithdrawnRoutes\n   This attribute lists a set of routes that
          are being withdrawn from\n   service.  The transmitting LS has determined
          that these routes should\n   no longer be advertised, and is propagating
          this information to its\n   peers.\n"
        title: 4.3.4.1. WithdrawnRoutes
      - contents:
        - "4.3.4.2. ReachableRoutes\n   This attribute lists a set of routes that
          are being added to service.\n   These routes will have the potential to
          be inserted into the Adj-\n   TRIBs-In of the receiving LS and the route
          selection process will be\n   applied to them.\n"
        title: 4.3.4.2. ReachableRoutes
      - contents:
        - "4.3.4.3. NextHopServer\n   This attribute gives the identity of the entity
          to which messages\n   should be sent along this routed path.  It specifies
          the identity of\n   the next hop server as either a host domain name or
          an IP address.\n   It MAY optionally specify the UDP/TCP port number for
          the next hop\n   signaling server.  If not specified, then the default port
          SHOULD be\n   used.  The NextHopServer is specific to the set of destinations
          and\n   application protocol defined in the ReachableRoutes attribute.  Note\n
          \  that this is NOT necessarily the address to which media (voice,\n   video,
          etc.)  should be transmitted, it is only for the application\n   protocol
          as given in the ReachableRoutes attribute.\n"
        title: 4.3.4.3. NextHopServer
      - contents:
        - "4.3.4.4. AdvertisementPath\n   The AdvertisementPath is analogous to the
          AS_PATH in BGP4 [3].  The\n   attribute records the sequence of domains
          through which this\n   advertisement has passed.  The attribute is used
          to detect when the\n   routing advertisement is looping.  This attribute
          does NOT reflect\n   the path through which messages following this route
          would traverse.\n   Since the next-hop need not be modified by each LS,
          the actual path\n   to the destination might not have to traverse every
          domain in the\n   AdvertisementPath.\n"
        title: 4.3.4.4. AdvertisementPath
      - contents:
        - "4.3.4.5. RoutedPath\n   The RoutedPath attribute is analogous to the AdvertisementPath\n
          \  attribute, except that it records the actual path (given by the list\n
          \  of domains) *to* the destinations.  Unlike AdvertisementPath, which\n
          \  is modified each time the route is propagated, RoutedPath is only\n   modified
          when the NextHopServer attribute changes.  Thus, it records\n   the subset
          of the AdvertisementPath which signaling messages\n   following this particular
          route would traverse.\n"
        title: 4.3.4.5. RoutedPath
      - contents:
        - "4.3.4.6. AtomicAggregate\n   The AtomicAggregate attribute indicates that
          a route may actually\n   include domains not listed in the RoutedPath.  If
          an LS, when\n   presented with a set of overlapping routes from a peer LS,
          selects a\n   less specific route without selecting the more specific route,
          then\n   the LS MUST include the AtomicAggregate attribute with the route.
          \ An\n   LS receiving a route with an AtomicAggregate attribute MUST NOT
          make\n   the set of destinations more specific when advertising it to other\n
          \  LSs.\n"
        title: 4.3.4.6. AtomicAggregate
      - contents:
        - "4.3.4.7. LocalPreference\n   The LocalPreference attribute is an intra-domain
          attribute used to\n   inform other LSs of the local LS's preference for
          a given route.  The\n   preference of a route is calculated at the ingress
          to a domain and\n   passed as an attribute with that route throughout the
          domain.  Other\n   LSs within the same ITAD use this attribute in their
          route selection\n   process.  This attribute has no significance between
          domains.\n"
        title: 4.3.4.7. LocalPreference
      - contents:
        - "4.3.4.8. MultiExitDisc\n   There may be more than one LS peering relationship
          between\n   neighboring domains.  The MultiExitDisc attribute is used by
          an LS to\n   express a preference for one link between the domains over
          another\n   link between the domains.  The use of the MultiExitDisc attribute
          is\n   controlled by local policy.\n"
        title: 4.3.4.8. MultiExitDisc
      - contents:
        - "4.3.4.9. Communities\n   The Communities attribute is not a well-known
          attribute.  It is used\n   to facilitate and simplify the control of routing
          information by\n   grouping destinations into communities.\n"
        title: 4.3.4.9. Communities
      - contents:
        - "4.3.4.10. ITAD Topology\n   The ITAD topology attribute is an intra-domain
          attribute that is used\n   by LSs to indicate their intra-domain topology
          to other LSs in the\n   domain.\n"
        title: 4.3.4.10. ITAD Topology
      - contents:
        - "4.3.4.11. ConvertedRoute\n   The ConvertedRoute attribute indicates that
          an intermediate LS has\n   altered the route by changing the route's Application
          Protocol.\n"
        title: 4.3.4.11. ConvertedRoute
      title: 4.3.4. TRIP UPDATE Attributes
    title: 4.3. UPDATE Message Format
  - contents:
    - "4.4. KEEPALIVE Message Format\n   TRIP does not use any transport-based keep-alive
      mechanism to\n   determine if peers are reachable.  Instead, KEEPALIVE messages
      are\n   exchanged between peers often enough as not to cause the Hold Timer\n
      \  to expire.  A reasonable maximum time between KEEPALIVE messages\n   would
      be one third of the Hold Time interval.  KEEPALIVE messages\n   MUST NOT be
      sent more than once every 3 seconds.  An implementation\n   SHOULD adjust the
      rate at which it sends KEEPALIVE messages as a\n   function of the negotiated
      Hold Time interval.\n   If the negotiated Hold Time interval is zero, then periodic
      KEEPALIVE\n   messages MUST NOT be sent.\n   The KEEPALIVE message consists
      of only a message header and has a\n   length of 3 octets.\n"
    title: 4.4. KEEPALIVE Message Format
  - contents:
    - "4.5. NOTIFICATION Message Format\n   A NOTIFICATION message is sent when an
      error condition is detected.\n   The TRIP transport connection is closed immediately
      after sending a\n   NOTIFICATION message.\n   In addition to the fixed-size
      TRIP header, the NOTIFICATION message\n   contains the following fields:\n    0
      \                  1                   2                   3\n    0 1 2 3 4
      5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +---------------+---------------+--------------+----------------+\n
      \  |  Error Code   | Error Subcode |       Data... (variable)\n   +---------------+---------------+--------------+----------------+\n
      \               Figure 10: TRIP NOTIFICATION Format\n   Error Code:\n   This
      1-octet unsigned integer indicates the type of NOTIFICATION.\n   The following
      Error Codes have been defined:\n   Error Code       Symbolic Name               Reference\n
      \    1         Message Header Error             Section 6.1\n     2         OPEN
      Message Error               Section 6.2\n     3         UPDATE Message Error
      \            Section 6.3\n     4         Hold Timer Expired               Section
      6.5\n     5         Finite State Machine Error       Section 6.6\n     6         Cease
      \                           Section 6.7\n   Error Subcode:\n   This 1-octet
      unsigned integer provides more specific information\n   about the nature of
      the reported error.  Each Error Code may have one\n   or more Error Subcodes
      associated with it.  If no appropriate Error\n   Subcode is defined, then a
      zero (Unspecific) value is used for the\n   Error Subcode field.\n   Message
      Header Error Subcodes:\n      1  - Bad Message Length.\n      2  - Bad Message
      Type.\n   OPEN Message Error Subcodes:\n      1  - Unsupported Version Number.\n
      \     2  - Bad Peer ITAD.\n      3  - Bad TRIP Identifier.\n      4  - Unsupported
      Optional Parameter.\n      5  - Unacceptable Hold Time.\n      6  - Unsupported
      Capability.\n      7  - Capability Mismatch.\n   UPDATE Message Error Subcodes:\n
      \     1 - Malformed Attribute List.\n      2 - Unrecognized Well-known Attribute.\n
      \     3 - Missing Well-known Mandatory Attribute.\n      4 - Attribute Flags
      Error.\n      5 - Attribute Length Error.\n      6 - Invalid Attribute.\n   Data:\n
      \  This variable-length field is used to diagnose the reason for the\n   NOTIFICATION.
      \ The contents of the Data field depend upon the Error\n   Code and Error Subcode.\n
      \  Note that the length of the data can be determined from the message\n   length
      field by the formula:\n            Data Length = Message Length - 5\n   The
      minimum length of the NOTIFICATION message is 5 octets (including\n   message
      header).\n"
    title: 4.5. NOTIFICATION Message Format
  title: 4. Message Formats
- contents:
  - "5. TRIP Attributes\n   This section provides details on the syntax and semantics
    of each\n   TRIP UPDATE attribute.\n"
  - contents:
    - "5.1. WithdrawnRoutes\n   Conditional Mandatory: False.\n   Required Flags:
      Well-known.\n   Potential Flags: Link-State Encapsulation (when flooding).\n
      \  TRIP Type Code: 1\n   The WithdrawnRoutes specifies a set of routes that
      are to be removed\n   from service by the receiving LS(s).  The set of routes
      MAY be empty,\n   indicated by a length field of zero.\n"
    - contents:
      - "5.1.1. Syntax of WithdrawnRoutes\n   The WithdrawnRoutes Attribute encodes
        a sequence of routes in its\n   value field.  The format for individual routes
        is given in Section\n   5.1.1.1.  The WithdrawnRoutes Attribute lists the
        individual routes\n   sequentially with no padding as shown in Figure 11.
        \ Each route\n   includes a length field so that the individual routes within
        the\n   attribute can be delineated.\n            +---------------------+---------------------+...\n
        \           |  WithdrawnRoute1... |  WithdrawnRoute2... |...\n            +---------------------+---------------------+...\n
        \                Figure 11: WithdrawnRoutes Format\n"
      - contents:
        - "5.1.1.1. Generic TRIP Route Format\n   The generic format for a TRIP route
          is given in Figure 12.\n    0                   1                   2                   3\n
          \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +---------------+---------------+--------------+----------------+\n
          \  |       Address Family          |      Application Protocol     |\n   +---------------+---------------+--------------+----------------+\n
          \  |            Length             |       Address (variable)     ...\n
          \  +---------------+---------------+--------------+----------------+\n                Figure
          12: Generic TRIP Route Format\n   Address Family:\n   The address family
          field gives the type of address for the route.\n   Three address families
          are defined in this Section:\n            Code              Address Family\n
          \           1                 Decimal Routing Numbers\n            2                 PentaDecimal
          Routing Numbers\n            3                 E.164 Numbers\n   This document
          reserves address family code 0.  This document reserves\n   address family
          codes 32768-65535 for vendor-specific applications\n   (these are the codes
          with the first bit of the code value equal to\n   1).  Additional address
          families may be defined in the future.\n   Assignment of address family
          codes is controlled by IANA.  See\n   Section 13 for IANA considerations.\n
          \  Application Protocol:\n   The application protocol gives the protocol
          for which this routing\n   table is maintained.  The currently defined application
          protocols\n   are:\n            Code              Protocol\n            1
          \                SIP\n            2                 H.323-H.225.0-Q.931\n
          \           3                 H.323-H.225.0-RAS\n            4                 H.323-H.225.0-Annex-G\n
          \  This document reserves application protocol code 0.  This document\n
          \  reserves application protocol codes 32768-65535 for vendor-specific\n
          \  applications (these are the codes with the first bit of the code\n   value
          equal to 1).  Additional application protocols may be defined\n   in the
          future.  Assignment of application protocol codes is\n   controlled by IANA.
          \ See Section 13 for IANA considerations.\n   Length:\n   The length of
          the address field, in bytes.\n   Address:\n   This is an address (prefix)
          of the family type given by Address\n   Family.  The octet length of the
          address is variable and is\n   determined by the length field of the route.\n"
        title: 5.1.1.1. Generic TRIP Route Format
      - contents:
        - "5.1.1.2. Decimal Routing Numbers\n   The Decimal Routing Numbers address
          family is a super set of all\n   E.164 numbers, national numbers, local
          numbers, and private numbers.\n   It can also be used to represent the decimal
          routing numbers used in\n   conjunction with Number Portability in some
          countries/regions.  A set\n   of telephone numbers is specified by a Decimal
          Routing Number prefix.\n   Decimal Routing Number prefixes are represented
          by a string of\n   digits, each digit encoded by its ASCII character representation.\n
          \  This routing object covers all phone numbers starting with this\n   prefix.
          \ The syntax for the Decimal Routing Number prefix is:\n      Decimal-routing-number
          \ = *decimal-digit\n      decimal-digit           = DECIMAL-DIGIT\n      DECIMAL-DIGIT
          \          = \"0\"|\"1\"|\"2\"|\"3\"|\"4\"|\"5\"|\"6\"|\"7\"|\"8\"|\"9\"\n
          \  This DECIMAL Routing Number prefix is not bound in length.  This\n   format
          is similar to the format for a global telephone number as\n   defined in
          SIP [8] without visual separators and without the \"+\"\n   prefix for international
          numbers.  This format facilitates efficient\n   comparison when using TRIP
          to route SIP or H323, both of which use\n   character based representations
          of phone numbers.  The prefix length\n   is determined from the length field
          of the route.  The type of\n   Decimal Routing Number (private, local, national,
          or international)\n   can be deduced from the first few digits of the prefix.\n"
        title: 5.1.1.2. Decimal Routing Numbers
      - contents:
        - "5.1.1.3. PentaDecimal Routing Numbers\n   This address family is used to
          represent PentaDecimal Routing Numbers\n   used in conjunction with Number
          Portability in some\n   countries/regions.  PentaDecimal Routing Number
          prefixes are\n   represented by a string of digits, each digit encoded by
          its ASCII\n   character representation.  This routing object covers all
          routing\n   numbers starting with this prefix.  The syntax for the PentaDecimal\n
          \  Routing Number prefix is:\n      PentaDecimal-routing-number   = *pentadecimal-digit\n
          \     pentadecimal-routing-digit    = PENTADECIMAL-DIGIT\n      PENTADECIMAL-DIGIT
          \           = \"0\"|\"1\"|\"2\"|\"3\"|\"4\"|\"5\"|\"6\"|\"7\"|\n                                      \"8\"|\"9\"|\"A\"|\"B\"|\"C\"|\"D\"|\"E\"\n
          \  Note the difference in alphabets between Decimal Routing Numbers and\n
          \  PentaDecimal Routing Numbers.  A PentaDecimal Routing Number prefix\n
          \  is not bound in length.\n   Note that the address family, which suits
          the routing numbers of a\n   specific country/region depends on the alphabets
          used for routing\n   numbers in that country/region.  For example, North
          American routing\n   numbers SHOULD use the Decimal Routing Numbers address
          family,\n   because their alphabet is limited to the digits \"0\" through
          \"9\".\n   Another example, in most European countries routing numbers use
          the\n   alphabet \"0\" through \"9\" and \"A\" through \"E\", and hence
          these\n   countries SHOULD use the PentaDecimal Routing Numbers address
          family.\n"
        title: 5.1.1.3. PentaDecimal Routing Numbers
      - contents:
        - "5.1.1.4. E.164 Numbers\n   The E.164 Numbers address family is dedicated
          to fully qualified\n   E.164 numbers.  A set of telephone numbers is specified
          by a E.164\n   prefix.  E.164 prefixes are represented by a string of digits,
          each\n   digit encoded by its ASCII character representation.  This routing\n
          \  object covers all phone numbers starting with this prefix.  The\n   syntax
          for the E.164 prefix is:\n      E164-number          = *e164-digit\n      E164-digit
          \          = E164-DIGIT\n      E164-DIGIT           = \"0\"|\"1\"|\"2\"|\"3\"|\"4\"|\"5\"|\"6\"|\"7\"|\"8\"|\"9\"\n
          \  This format facilitates efficient comparison when using TRIP to route\n
          \  SIP or H323, both of which use character based representations of\n   phone
          numbers.  The prefix length is determined from the length field\n   of the
          route.\n   The E.164 Numbers address family and the Decimal Routing Numbers\n
          \  address family have the same alphabet.  The E.164 Numbers address\n   family
          SHOULD be used whenever possible.  The Decimal Routing Numbers\n   address
          family can be used in case of private numbering plans or\n   applications
          that do not desire to advertise fully expanded, fully\n   qualified telephone
          numbers.  If Decimal Routing Numbers are used to\n   advertise non-fully
          qualified prefixes, the prefixes may have to be\n   manipulated (e.g. expanded)
          at the boundary between ITADs.  This adds\n   significant complexity to
          the ITAD-Border LS, because, it has to map\n   the prefixes from the format
          used in its own ITAD to the format used\n   in the peer ITAD.\n"
        title: 5.1.1.4. E.164 Numbers
      title: 5.1.1. Syntax of WithdrawnRoutes
    title: 5.1. WithdrawnRoutes
  - contents:
    - "5.2. ReachableRoutes\n   Conditional Mandatory: False.\n   Required Flags:
      Well-known.\n   Potential Flags: Link-State Encapsulation (when flooding).\n
      \  TRIP Type Code: 2\n   The ReachableRoutes attribute specifies a set of routes
      that are to\n   be added to service by the receiving LS(s).  The set of routes
      MAY be\n   empty, as indicated by setting the length field to zero.\n"
    - contents:
      - "5.2.1. Syntax of ReachableRoutes\n   The ReachableRoutes Attribute has the
        same syntax as the\n   WithdrawnRoutes Attribute.  See Section 5.1.1.\n"
      title: 5.2.1. Syntax of ReachableRoutes
    - contents:
      - "5.2.2. Route Origination and ReachableRoutes\n   Routes are injected into
        TRIP by a method outside the scope of this\n   specification.  Possible methods
        include a front-end protocol, an\n   intra-domain routing protocol, or static
        configuration.\n"
      title: 5.2.2. Route Origination and ReachableRoutes
    - contents:
      - "5.2.3. Route Selection and ReachableRoutes\n   The routes in ReachableRoutes
        are necessary for route selection.\n"
      title: 5.2.3. Route Selection and ReachableRoutes
    - contents:
      - "5.2.4. Aggregation and ReachableRoutes\n   To aggregate multiple routes,
        the set of ReachableRoutes to be\n   aggregated MUST combine to form a less
        specific set.\n   There is no mechanism within TRIP to communicate that a
        particular\n   address prefix is not used and thus that these addresses could
        be\n   skipped during aggregation.  LSs MAY use methods outside of TRIP to\n
        \  learn of invalid prefixes that may be ignored during aggregation.\n   If
        an LS advertises an aggregated route, it MUST include the\n   AtomicAggregate
        attribute.\n"
      title: 5.2.4. Aggregation and ReachableRoutes
    - contents:
      - "5.2.5. Route Dissemination and ReachableRoutes\n   The ReachableRoutes attribute
        is recomputed at each LS except where\n   flooding is being used (e.g., within
        a domain).  It is therefore\n   possible for an LS to change the Application
        Protocol field of a\n   route before advertising that route to an external
        peer.\n   If an LS changes the Application Protocol of a route it advertises,\n
        \  it MUST include the ConvertedRoute attribute in the UPDATE message.\n"
      title: 5.2.5. Route Dissemination and ReachableRoutes
    - contents:
      - "5.2.6. Aggregation Specifics for Decimal Routing Numbers, E.164 Numbers,\n
        \      and PentaDecimal Routing Numbers\n   An LS that has routes to all valid
        numbers in a specific prefix\n   SHOULD advertise that prefix as the ReachableRoutes,
        even if there\n   are more specific prefixes that do not actually exist on
        the PSTN.\n   Generally, it takes 10 Decimal Routing/E.164 prefixes, or 15\n
        \  PentaDecimal Routing prefixes, of length n to aggregate into a prefix\n
        \  of length n-1.  However, if an LS is aware that a prefix is an\n   invalid
        Decimal Routing/E.164 prefix, or PentaDecimal Routing prefix,\n   then the
        LS MAY aggregate by skipping this prefix.  For example, if\n   the Decimal
        Routing prefix 19191 is known not to exist, then an LS\n   can aggregate to
        1919 without 19191.  A prefix representing an\n   invalid set of PSTN destinations
        is sometimes referred to as a\n   \"black-hole.\"  The method by which an
        LS is aware of black-holes is\n   not within the scope of TRIP, but if an
        LS has such knowledge, it can\n   use the knowledge when aggregating.\n"
      title: 5.2.6. Aggregation Specifics for Decimal Routing Numbers, E.164 Numbers,
    title: 5.2. ReachableRoutes
  - contents:
    - "5.3. NextHopServer\n   Conditional Mandatory: True (if ReachableRoutes and/or\n
      \  WithdrawnRoutes attribute is present).\n   Required Flags: Well-known.\n
      \  Potential Flags: None.\n   TRIP Type Code: 3.\n   Given a route with application
      protocol A and destinations D, the\n   NextHopServer indicates to the next-hop
      that messages of protocol A\n   destined for D should be sent to it.  This may
      or may not represent\n   the ultimate destination of those messages.\n"
    - contents:
      - "5.3.1. NextHopServer Syntax\n   For generality, the address of the next-hop
        server may be of various\n   types (domain name, IPv4, IPv6, etc).  The NextHopServer
        attribute\n   includes the ITAD number of next-hop server, a length field,
        and a\n   next-hop name or address.\n   The syntax for the NextHopServer is
        given in Figure 13.\n    0                   1                   2                   3\n
        \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +---------------+---------------+--------------+----------------+\n
        \  |                         Next Hop ITAD                         |\n   +---------------+---------------+--------------+----------------+\n
        \  |             Length            |         Server (variable)    ...\n   +---------------+---------------+--------------+----------------+\n
        \                 Figure 13: NextHopServer Syntax\n   The Next-Hop ITAD indicates
        the domain of the next-hop.  Length field\n   gives the number of octets in
        the Server field, and the Server field\n   contains the name or address of
        the next-hop server.  The server\n   field is represented as a string of ASCII
        characters.  It is defined\n   as follows:\n   Server  = host [\":\" port
        ]\n   host    = <   A legal Internet host domain name\n              or an
        IPv4 address using the textual representation\n                 defined in
        Section 2.1 of RFC 1123 [9]\n              or an IPv6 address using the textual
        representation\n                 defined in Section 2.2 of RFC 2373 [10].
        \ The IPv6\n                 address MUST be enclosed in \"[\" and \"]\"\n
        \                characters.>\n   port    = *DIGIT\n   If the port is empty
        or not given, the default port is assumed (e.g.,\n   port 5060 if the application
        protocol is SIP).\n"
      title: 5.3.1. NextHopServer Syntax
    - contents:
      - "5.3.2. Route Origination and NextHopServer\n   When an LS originates a routing
        object into TRIP, it MUST include a\n   NextHopServer within its domain.  The
        NextHopServer could be an\n   address of the egress gateway or of a signaling
        proxy.\n"
      title: 5.3.2. Route Origination and NextHopServer
    - contents:
      - "5.3.3. Route Selection and NextHopServer\n   LS policy may prefer certain
        next-hops or next-hop domains over\n   others.\n"
      title: 5.3.3. Route Selection and NextHopServer
    - contents:
      - "5.3.4. Aggregation and NextHopServer\n   When aggregating multiple routing
        objects into a single routing\n   object, an LS MUST insert a new signaling
        server from within its\n   domain as the new NextHopServer unless all of the
        routes being\n   aggregated have the same next-hop.\n"
      title: 5.3.4. Aggregation and NextHopServer
    - contents:
      - "5.3.5. Route Dissemination and NextHopServer\n   When propagating routing
        objects to peers, an LS may choose to insert\n   a signaling proxy within
        its domain as the new next-hop, or it may\n   leave the next-hop unchanged.
        \ Inserting a new next-hop will cause\n   the signaling messages to be sent
        to that address, and will provide\n   finer control over the signaling path.
        \ Leaving the next-hop\n   unchanged will yield a more efficient signaling
        path (fewer hops).\n   It is a local policy decision of the LS to decide whether
        to\n   propagate or change the NextHopServer.\n"
      title: 5.3.5. Route Dissemination and NextHopServer
    title: 5.3. NextHopServer
  - contents:
    - "5.4. AdvertisementPath\n   Conditional Mandatory: True (if ReachableRoutes
      and/or\n   WithdrawnRoutes attribute is present).\n   Required Flags: Well-known.\n
      \  Potential Flags: None.\n   TRIP Type Code: 4.\n   This attribute identifies
      the ITADs through which routing information\n   carried in an advertisement
      has passed.  The AdvertisementPath\n   attribute is analogous to the AS_PATH
      attribute in BGP.  The\n   attributes differ in that BGP's AS_PATH also reflects
      the path to the\n   destination.  In TRIP, not every domain need modify the
      next-hop, so\n   the AdvertisementPath may include many more hops than the actual
      path\n   to the destination.  The RoutedPath attribute (Section 5.5) reflects\n
      \  the actual signaling path to the destination.\n"
    - contents:
      - "5.4.1. AdvertisementPath Syntax\n   AdvertisementPath is a variable length
        attribute that is composed of\n   a sequence of ITAD path segments.  Each
        ITAD path segment is\n   represented by a type-length-value triple.\n   The
        path segment type is a 1-octet long field with the following\n   values defined:\n
        \     Value      Segment Type\n      1          AP_SET: unordered set of ITADs
        a route in the\n                 advertisement message has traversed\n      2
        \         AP_SEQUENCE: ordered set of ITADs a route in\n                 the
        advertisement message has traversed\n   The path segment length is a 1-octet
        long field containing the number\n   of ITADs in the path segment value field.\n
        \  The path segment value field contains one or more ITAD numbers, each\n
        \  encoded as a 4-octets long field.  ITAD numbers uniquely identify an\n
        \  Internet Telephony Administrative Domain, and must be obtained from\n   IANA.
        \ See Section 13 for procedures to obtain an ITAD number from\n   IANA.\n"
      title: 5.4.1. AdvertisementPath Syntax
    - contents:
      - "5.4.2. Route Origination and AdvertisementPath\n   When an LS originates
        a route then:\n      -  The originating LS shall include its own ITAD number
        in the\n         AdvertisementPath attribute of all advertisements sent to
        LSs\n         located in neighboring ITADs.  In this case, the ITAD number
        of\n         the originating LS's ITAD will be the only entry in the\n         AdvertisementPath
        attribute.\n      -  The originating LS shall include an empty AdvertisementPath\n
        \        attribute in all advertisements sent to LSs located in its own\n
        \        ITAD.  An empty AdvertisementPath attribute is one whose length\n
        \        field contains the value zero.\n"
      title: 5.4.2. Route Origination and AdvertisementPath
    - contents:
      - "5.4.3. Route Selection and AdvertisementPath\n   The AdvertisementPath may
        be used for route selection.  Possible\n   criteria to be used are the number
        of hops on the path and the\n   presence or absence of particular ITADs on
        the path.\n   As discussed in Section 10, the AdvertisementPath is used to
        prevent\n   routing information from looping.  If an LS receives a route with
        its\n   own ITAD already in the AdvertisementPath, the route MUST be\n   discarded.\n"
      title: 5.4.3. Route Selection and AdvertisementPath
    - contents:
      - "5.4.4. Aggregation and AdvertisementPath\n   The rules for aggregating AdvertisementPath
        attributes are given in\n   the following sections, where the term \"path\"
        used in Section 5.4.4.1\n   and 5.4.4.2 is understood to mean AdvertisementPath.\n"
      - contents:
        - "5.4.4.1. Aggregating Routes with Identical Paths\n   If all routes to be
          aggregated have identical path attributes, then\n   the aggregated route
          has the same path attribute as the individual\n   routes.\n"
        title: 5.4.4.1. Aggregating Routes with Identical Paths
      - contents:
        - "5.4.4.2. Aggregating Routes with Different Paths\n   For the purpose of
          aggregating path attributes we model each ITAD\n   within the path as a
          pair <type, value>, where \"type\" identifies a\n   type of the path segment
          (AP_SEQUENCE or AP_SET), and \"value\" is the\n   ITAD number.  Two ITADs
          are said to be the same if their\n   corresponding <type, value> are the
          same.\n   If the routes to be aggregated have different path attributes,
          then\n   the aggregated path attribute shall satisfy all of the following\n
          \  conditions:\n      -  All pairs of the type AP_SEQUENCE in the aggregated
          path MUST\n         appear in all of the paths of routes to be aggregated.\n
          \     -  All pairs of the type AP_SET in the aggregated path MUST appear\n
          \        in at least one of the paths of the initial set (they may\n         appear
          as either AP_SET or AP_SEQUENCE types).\n      -  For any pair X of the
          type AP_SEQUENCE that precedes pair Y in\n         the aggregated path,
          X precedes Y in each path of the initial\n         set that contains Y,
          regardless of the type of Y.\n      -  No pair with the same value shall
          appear more than once in the\n         aggregated path, regardless of the
          pair's type.\n   An implementation may choose any algorithm that conforms
          to these\n   rules.  At a minimum, a conformant implementation MUST be able
          to\n   perform the following algorithm that meets all of the above\n   conditions:\n
          \     -  Determine the longest leading sequence of tuples (as defined\n
          \        above) common to all the paths of the routes to be aggregated.\n
          \        Make this sequence the leading sequence of the aggregated path.\n
          \     -  Set the type of the rest of the tuples from the paths of the\n
          \        routes to be aggregated to AP_SET, and append them to the\n         aggregated
          path.\n      -  If the aggregated path has more than one tuple with the
          same\n         value (regardless of tuple's type), eliminate all but one
          such\n         tuple by deleting tuples of the type AP_SET from the aggregated\n
          \        path.\n   An implementation that chooses to provide a path aggregation\n
          \  algorithm that retains significant amounts of path information may\n
          \  wish to use the procedure of Section 5.4.4.3.\n"
        title: 5.4.4.2. Aggregating Routes with Different Paths
      - contents:
        - "5.4.4.3. Example Path Aggregation Algorithm\n   An example algorithm to
          aggregate two paths works as follows:\n      -  Identify the ITADs (as defined
          in Section 5.4.1) within each\n         path attribute that are in the same
          relative order within both\n         path attributes.  Two ITADs, X and
          Y, are said to be in the\n         same order if either X precedes Y in
          both paths, or if Y\n         precedes X in both paths.\n      -  The aggregated
          path consists of ITADs identified in (a) in\n         exactly the same order
          as they appear in the paths to be\n         aggregated.  If two consecutive
          ITADs identified in (a) do not\n         immediately follow each other in
          both of the paths to be\n         aggregated, then the intervening ITADs
          (ITADs that are between\n         the two consecutive ITADs that are the
          same) in both attributes\n         are combined into an AP_SET path segment
          that consists of the\n         intervening ITADs from both paths; this segment
          is then placed\n         in between the two consecutive ITADs identified
          in (a) of the\n         aggregated attribute.  If two consecutive ITADs
          identified in\n         (a) immediately follow each other in one attribute,
          but do not\n         follow in another, then the intervening ITADs of the
          latter are\n         combined into an AP_SET path segment; this segment
          is then\n         placed in between the two consecutive ITADs identified
          in (a)\n         of the aggregated path.\n   If as a result of the above
          procedure a given ITAD number appears\n   more than once within the aggregated
          path, all but the last instance\n   (rightmost occurrence) of that ITAD
          number should be removed from the\n   aggregated path.\n"
        title: 5.4.4.3. Example Path Aggregation Algorithm
      title: 5.4.4. Aggregation and AdvertisementPath
    - contents:
      - "5.4.5. Route Dissemination and AdvertisementPath\n   When an LS propagates
        a route which it has learned from another LS,\n   it shall modify the route's
        AdvertisementPath attribute based on the\n   location of the LS to which the
        route will be sent.\n      -  When a LS advertises a route to another LS located
        in its own\n         ITAD, the advertising LS MUST NOT modify the AdvertisementPath\n
        \        attribute associated with the route.\n      -  When a LS advertises
        a route to an LS located in a neighboring\n         ITAD, then the advertising
        LS MUST update the AdvertisementPath\n         attribute as follows:\n         *
        \ If the first path segment of the AdvertisementPath is of\n            type
        AP_SEQUENCE, the local system shall prepend its own\n            ITAD number
        as the last element of the sequence (put it in\n            the leftmost position).\n
        \        *  If the first path segment of the AdvertisementPath is of\n            type
        AP_SET, the local system shall prepend a new path\n            segment of
        type AP_SEQUENCE to the AdvertisementPath,\n            including its own
        ITAD number in that segment.\n"
      title: 5.4.5. Route Dissemination and AdvertisementPath
    title: 5.4. AdvertisementPath
  - contents:
    - "5.5. RoutedPath\n   Conditional Mandatory: True\n   (if ReachableRoutes attribute
      is present).\n   Required Flags: Well-known.\n   Potential Flags: None.\n   TRIP
      Type Code: 5.\n   This attribute identifies the ITADs through which messages
      sent using\n   this route would pass.  The ITADs in this path are a subset of
      those\n   in the AdvertisementPath.\n"
    - contents:
      - "5.5.1. RoutedPath Syntax\n   The syntax of the RoutedPath attribute is the
        same as that of the\n   AdvertisementPath attribute.  See Section 5.4.1.\n"
      title: 5.5.1. RoutedPath Syntax
    - contents:
      - "5.5.2. Route Origination and RoutedPath\n   When an LS originates a route
        it MUST include the RoutedPath\n   attribute.\n      -  The originating LS
        shall include its own ITAD number in the\n         RoutedPath attribute of
        all advertisements sent to LSs located\n         in neighboring ITADs.  In
        this case, the ITAD number of the\n         originating LS's ITAD will be
        the only entry in the RoutedPath\n         attribute.\n      -  The originating
        LS shall include an empty RoutedPath attribute\n         in all advertisements
        sent to LSs located in its own ITAD.  An\n         empty RoutedPath attribute
        is one whose length field contains\n         the value zero.\n"
      title: 5.5.2. Route Origination and RoutedPath
    - contents:
      - "5.5.3. Route Selection and RoutedPath\n   The RoutedPath MAY be used for
        route selection, and in most cases is\n   preferred over the AdvertisementPath
        for this role.  Some possible\n   criteria to be used are the number of hops
        on the path and the\n   presence or absence of particular ITADs on the path.\n"
      title: 5.5.3. Route Selection and RoutedPath
    - contents:
      - "5.5.4. Aggregation and RoutedPath\n   The rules for aggregating RoutedPath
        attributes are given in Section\n   5.4.4.1 and 5.4.4.2, where the term \"path\"
        used in Section 5.4.4.1\n   and 5.4.4.2 is understood to mean RoutedPath.\n"
      title: 5.5.4. Aggregation and RoutedPath
    - contents:
      - "5.5.5. Route Dissemination and RoutedPath\n   When an LS propagates a route
        that it learned from another LS, it\n   modifies the route's RoutedPath attribute
        based on the location of\n   the LS to which the route is sent.\n      -  When
        an LS advertises a route to another LS located in its own\n         ITAD,
        the advertising LS MUST NOT modify the RoutedPath\n         attribute associated
        with the route.\n      -  If the LS has not changed the NextHopServer attribute,
        then the\n         LS MUST NOT change the RoutedPath attribute.\n      -  Otherwise,
        the LS changed the NextHopServer and is advertising\n         the route to
        an LS in another ITAD.  The advertising LS MUST\n         update the RoutedPath
        attribute as follows:\n         *  If the first path segment of the RoutedPath
        is of type\n            AP_SEQUENCE, the local system shall prepend its own
        ITAD\n            number as the last element of the sequence (put it in the\n
        \           leftmost position).\n         *  If the first path segment of
        the RoutedPath is of type\n            AP_SET, the local system shall prepend
        a new path segment of\n            type AP_SEQUENCE to the RoutedPath, including
        its own ITAD\n            number in that segment.\n"
      title: 5.5.5. Route Dissemination and RoutedPath
    title: 5.5. RoutedPath
  - contents:
    - "5.6. AtomicAggregate\n   Conditional Mandatory: False.\n   Required Flags:
      Well-known.\n   Potential Flags: None.\n   TRIP Type Code: 6.\n   The AtomicAggregate
      attribute indicates that a route may traverse\n   domains not listed in the
      RoutedPath.  If an LS, when presented with\n   a set of overlapping routes from
      a peer LS, selects the less specific\n   route without selecting the more specific
      route, then the LS includes\n   the AtomicAggregate attribute with the routing
      object.\n"
    - contents:
      - "5.6.1. AtomicAggregate Syntax\n   This attribute has length zero (0); the
        value field is empty.\n"
      title: 5.6.1. AtomicAggregate Syntax
    - contents:
      - "5.6.2. Route Origination and AtomicAggregate\n   Routes are never originated
        with the AtomicAggregate attribute.\n"
      title: 5.6.2. Route Origination and AtomicAggregate
    - contents:
      - "5.6.3. Route Selection and AtomicAggregate\n   The AtomicAggregate attribute
        may be used in route selection - it\n   indicates that the RoutedPath may
        be incomplete.\n"
      title: 5.6.3. Route Selection and AtomicAggregate
    - contents:
      - "5.6.4. Aggregation and AtomicAggregate\n   If any of the routes to aggregate
        has the AtomicAggregate attribute,\n   then so MUST the resultant aggregate.\n"
      title: 5.6.4. Aggregation and AtomicAggregate
    - contents:
      - "5.6.5. Route Dissemination and AtomicAggregate\n   If an LS, when presented
        with a set of overlapping routes from a peer\n   LS, selects the less specific
        route (see Section 0) without selecting\n   the more specific route, then
        the LS MUST include the AtomicAggregate\n   attribute with the routing object
        (if it is not already present).\n   An LS receiving a routing object with
        an AtomicAggregate attribute\n   MUST NOT make the set of destinations more
        specific when advertising\n   it to other LSs, and MUST NOT remove the attribute
        when propagating\n   this object to a peer LS.\n"
      title: 5.6.5. Route Dissemination and AtomicAggregate
    title: 5.6. AtomicAggregate
  - contents:
    - "5.7. LocalPreference\n   Conditional Mandatory: False.\n   Required Flags:
      Well-known.\n   Potential Flags: None.\n   TRIP Type Code: 7.\n   The LocalPreference
      attribute is only used intra-domain, it indicates\n   the local LS's preference
      for the routing object to other LSs within\n   the same domain.  This attribute
      MUST NOT be included when\n   communicating to an LS in another domain, and
      MUST be included over\n   intra-domain links.\n"
    - contents:
      - "5.7.1. LocalPreference Syntax\n   The LocalPreference attribute is a 4-octet
        unsigned numeric value.  A\n   higher value indicates a higher preference.\n"
      title: 5.7.1. LocalPreference Syntax
    - contents:
      - "5.7.2. Route Origination and LocalPreference\n   Routes MUST NOT be originated
        with the LocalPreference attribute to\n   inter-domain peers.  Routes to intra-domain
        peers MUST be originated\n   with the LocalPreference attribute.\n"
      title: 5.7.2. Route Origination and LocalPreference
    - contents:
      - "5.7.3. Route Selection and LocalPreference\n   The LocalPreference attribute
        allows one LS in a domain to calculate\n   a preference for a route, and to
        communicate this preference to other\n   LSs within the domain.\n"
      title: 5.7.3. Route Selection and LocalPreference
    - contents:
      - "5.7.4. Aggregation and LocalPreference\n   The LocalPreference attribute
        is not affected by aggregation.\n"
      title: 5.7.4. Aggregation and LocalPreference
    - contents:
      - "5.7.5. Route Dissemination and LocalPreference\n   An LS MUST include the
        LocalPreference attribute when communicating\n   with peer LSs within its
        own domain.  An LS MUST NOT include the\n   LocalPreference attribute when
        communicating with LSs in other\n   domains.  LocalPreference attributes received
        from inter-domain peers\n   MUST be ignored.\n"
      title: 5.7.5. Route Dissemination and LocalPreference
    title: 5.7. LocalPreference
  - contents:
    - "5.8. MultiExitDisc\n   Conditional Mandatory: False.\n   Required Flags: Well-known.\n
      \  Potential Flags: None.\n   TRIP Type Code: 8.\n   When two ITADs are connected
      by more than one set of peers, the\n   MultiExitDisc attribute may be used to
      specify preferences for routes\n   received over one of those links versus routes
      received over other\n   links.  The MultiExitDisc parameter is used only for
      route selection.\n"
    - contents:
      - "5.8.1. MultiExitDisc Syntax\n   The MultiExitDisc attribute carries a 4-octet
        unsigned numeric value.\n   A higher value represents a more preferred routing
        object.\n"
      title: 5.8.1. MultiExitDisc Syntax
    - contents:
      - "5.8.2. Route Origination and MultiExitDisc\n   Routes originated to intra-domain
        peers MUST NOT be originated with\n   the MultiExitDisc attribute.  When originating
        a route to an inter-\n   domain peer, the MultiExitDisc attribute may be included.\n"
      title: 5.8.2. Route Origination and MultiExitDisc
    - contents:
      - "5.8.3. Route Selection and MultiExitDisc\n   The MultiExitDisc attribute
        is used to express a preference when\n   there are multiple links between
        two domains.  If all other factors\n   are equal, then a route with a higher
        MultiExitDisc attribute is\n   preferred over a route with a lower MultiExitDisc
        attribute.\n"
      title: 5.8.3. Route Selection and MultiExitDisc
    - contents:
      - "5.8.4. Aggregation and MultiExitDisc\n   Routes with differing MultiExitDisc
        parameters MUST NOT be\n   aggregated.  Routes with the same value in the
        MultiExitDisc\n   attribute MAY be aggregated and the same MultiExitDisc attribute\n
        \  attached to the aggregated object.\n"
      title: 5.8.4. Aggregation and MultiExitDisc
    - contents:
      - "5.8.5. Route Dissemination and MultiExitDisc\n   If received from a peer
        LS in another domain, an LS MAY propagate the\n   MultiExitDisc to other LSs
        within its domain.  The MultiExitDisc\n   attribute MUST NOT be propagated
        to LSs in other domains.\n   An LS may add the MultiExitDisc attribute when
        propagating routing\n   objects to an LS in another domain.  The inclusion
        of the\n   MultiExitDisc attribute is a matter of policy, as is the value
        of the\n   attribute.\n"
      title: 5.8.5. Route Dissemination and MultiExitDisc
    title: 5.8. MultiExitDisc
  - contents:
    - "5.9. Communities\n   Conditional Mandatory: False.\n   Required Flags: Not
      Well-Known, Independent Transitive.\n   Potential Flags: None.\n   TRIP Type
      Code: 9.\n   A community is a group of destinations that share some common\n
      \  property.\n   The Communities attribute is used to group destinations so
      that the\n   routing decision can be based on the identity of the group.  Using\n
      \  the Communities attribute should significantly simplify the\n   distribution
      of routing information by providing an administratively\n   defined aggregation
      unit.\n   Each ITAD administrator may define the communities to which a\n   particular
      route belongs.  By default, all routes belong to the\n   general Internet Telephony
      community.\n   As an example, the Communities attribute could be used to define
      an\n   alliance between a group of Internet Telephony service providers for\n
      \  a specific subset of routing information.  In this case, members of\n   that
      alliance would accept only routes for destinations in this group\n   that are
      advertised by other members of the alliance.  Other\n   destinations would be
      more freely accepted.  To achieve this, a\n   member would tag each route with
      a designated Community attribute\n   value before disseminating it.  This relieves
      the members of such an\n   alliance, from the responsibility of keeping track
      of the identities\n   of all other members of that alliance.\n   Another example
      use of the Communities attribute is with aggregation.\n   It is often useful
      to advertise both the aggregate route and the\n   component more-specific routes
      that were used to form the aggregate.\n   These information components are only
      useful to the neighboring TRIP\n   peer, and perhaps the ITAD of the neighboring
      TRIP peer, so it is\n   desirable to filter out the component routes.  This
      can be achieved\n   by specifying a Community attribute value that the neighboring
      peers\n   will match and filter on.  That way it can be assured that the more\n
      \  specific routes will not propagate beyond their desired scope.\n"
    - contents:
      - "5.9.1. Syntax of Communities\n   The Communities attribute is of variable
        length.  It consists of a\n   set of 8-octet values, each of which specifies
        a community.  The\n   first 4 octets of the Community value are the Community
        ITAD Number\n   and the next 4 octets are the Community ID.\n   0                   1
        \                  2                   3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
        5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +---------------+---------------+--------------+----------------+\n
        \  |                       Community ITAD Number 1                 |\n   +---------------+---------------+--------------+----------------+\n
        \  |                         Community ID 1                        |\n   +---------------+---------------+--------------+----------------+\n
        \  |                       . . . . . . . . .\n   +---------------+---------------+--------------+----------------+\n
        \                   Figure 14: Communities Syntax\n   For administrative assignment,
        the following assumptions may be made:\n      The Community attribute values
        starting with a Community ITAD\n      Number of 0x00000000 are hereby reserved.\n
        \  The following communities have global significance and their\n   operation
        MUST be implemented in any Community attribute-aware TRIP\n   LS.\n      -
        \ NO_EXPORT (Community ITAD Number = 0x00000000 and Community ID\n         =
        0xFFFFFF01).  Any received route with a community attribute\n         containing
        this value MUST NOT be advertised outside of the\n         receiving TRIP
        ITAD.\n   Other community values MUST be encoded using an ITAD number in the\n
        \  four most significant octets.  The semantics of the final four octets\n
        \  (the Community ID octets) may be defined by the ITAD (e.g., ITAD 690\n
        \  may define research, educational, and commercial community IDs that\n   may
        be used for policy routing as defined by the operators of that\n   ITAD).\n"
      title: 5.9.1. Syntax of Communities
    - contents:
      - "5.9.2. Route Origination and Communities\n   The Communities attribute is
        not well-known.  If a route has a\n   Communities attribute associated with
        it, the LS MUST include that\n   attribute in the advertisement it originates.\n"
      title: 5.9.2. Route Origination and Communities
    - contents:
      - "5.9.3. Route Selection and Communities\n   The Communities attribute may
        be used for route selection.  A route\n   that is a member of a certain community
        may be preferred over another\n   route that is not a member of that community.
        \ Likewise, routes\n   without a certain community value may be excluded from
        consideration.\n"
      title: 5.9.3. Route Selection and Communities
    - contents:
      - "5.9.4. Aggregation and Communities\n   If a set of routes is to be aggregated
        and the resultant aggregate\n   does not carry an Atomic_Aggregate attribute,
        then the resulting\n   aggregate should have a Communities attribute that
        contains the union\n   of the Community attributes of the aggregated routes.\n"
      title: 5.9.4. Aggregation and Communities
    - contents:
      - "5.9.5. Route Dissemination and Communities\n   An LS may manipulate the Communities
        attribute before disseminating a\n   route to a peer.  Community attribute
        manipulation may include adding\n   communities, removing communities, adding
        a Communities attribute (if\n   none exists), deleting the Communities attribute,
        etc.\n"
      title: 5.9.5. Route Dissemination and Communities
    title: 5.9. Communities
  - contents:
    - "5.10. ITAD Topology\n   Conditional Mandatory: False.\n   Required Flags: Well-known,
      Link-State encapsulated.\n   Potential Flags: None.\n   TRIP Type Code: 10.\n
      \  Within an ITAD, each LS must know the status of other LSs so that LS\n   failure
      can be detected.  To do this, each LS advertises its internal\n   topology to
      other LSs within the domain.  When an LS detects that\n   another LS is no longer
      active, the information sourced by that LS\n   can be deleted (the Adj-TRIB-In
      for that peer may be cleared).  The\n   ITAD Topology attribute is used to communicate
      this information to\n   other LSs within the domain.\n   An LS MUST send a topology
      update each time it detects a change in\n   its internal peer set.  The topology
      update may be sent in an UPDATE\n   message by itself or it may be piggybacked
      on an UPDATE message which\n   includes ReachableRoutes and/or WithdrawnRoutes
      information.\n   When an LS receives a topology update from an internal LS,
      it MUST\n   recalculate which LSs are active within the ITAD via a connectivity\n
      \  algorithm on the topology.\n"
    - contents:
      - "5.10.1. ITAD Topology Syntax\n   The ITAD Topology attribute indicates the
        LSs with which the LS is\n   currently peering.  The attribute consists of
        a list of the TRIP\n   Identifiers with which the LS is currently peering,
        the format is\n   given in  Figure 15.  This attribute MUST use the link-state\n
        \  encapsulation as defined in Section 4.3.2.4.\n    0                   1
        \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +---------------+---------------+--------------+----------------+\n
        \  |                        TRIP Identifier 1                      |\n   +---------------+---------------+--------------+----------------+\n
        \  |                        TRIP Identifier 2 ...                  |\n   +---------------+---------------+--------------+----------------+\n
        \                  Figure 15: ITAD Topology Syntax\n"
      title: 5.10.1. ITAD Topology Syntax
    - contents:
      - "5.10.2. Route Origination and ITAD Topology\n   The ITAD Topology attribute
        is independent of any routes in the\n   UPDATE.  Whenever the set of internal
        peers of an LS changes, it MUST\n   create an UPDATE with the ITAD Topology
        Attribute included listing\n   the current set of internal peers.  The LS
        MUST include this\n   attribute in the first UPDATE it sends to a peer after
        the peering\n   session is established.\n"
      title: 5.10.2. Route Origination and ITAD Topology
    - contents:
      - "5.10.3. Route Selection and ITAD Topology\n   This attribute is independent
        of any routing information in the\n   UPDATE.  When an LS receives an UPDATE
        with an ITAD Topology\n   attribute, it MUST compute the set of LSs currently
        active in the\n   domain by performing a connectivity test on the ITAD topology
        as\n   given by the set of originated ITAD Topology attributes.  The LS MUST\n
        \  locally purge the Adj-TRIB-In for any LS that is no longer active in\n
        \  the domain.  The LS MUST NOT propagate this purging information to\n   other
        LSs as they will make a similar decision.\n"
      title: 5.10.3. Route Selection and ITAD Topology
    - contents:
      - "5.10.4. Aggregation and ITAD Topology\n   This information is not aggregated.\n"
      title: 5.10.4. Aggregation and ITAD Topology
    - contents:
      - "5.10.5. Route Dissemination and ITAD Topology\n   An LS MUST ignore the attribute
        if received from a peer in another\n   domain.  An LS MUST NOT send this attribute
        to an inter-domain peer.\n"
      title: 5.10.5. Route Dissemination and ITAD Topology
    title: 5.10. ITAD Topology
  - contents:
    - "5.11. ConvertedRoute\n   Conditional Mandatory: False.\n   Required Flags:
      Well-known.\n   Potential Flags: None.\n   TRIP Type Code: 12.\n   The ConvertedRoute
      attribute indicates that an intermediate LS has\n   altered the route by changing
      the route's Application Protocol.  For\n   example, if an LS receives a route
      with Application Protocol X and\n   changes the Application Protocol to Y before
      advertising the route to\n   an external peer, the LS MUST include the ConvertedRoute
      attribute.\n   The attribute is an indication that the advertised application\n
      \  protocol will not be used end-to-end, i.e., the information\n   advertised
      about this route is not complete.\n"
    - contents:
      - "5.11.1. ConvertedRoute Syntax\n   This attribute has length zero (0); the
        value field is empty.\n"
      title: 5.11.1. ConvertedRoute Syntax
    - contents:
      - "5.11.2. Route Origination and ConvertedRoute\n   Routes are never originated
        with the ConvertedRoute attribute.\n"
      title: 5.11.2. Route Origination and ConvertedRoute
    - contents:
      - "5.11.3. Route Selection and ConvertedRoute\n   The ConvertedRoute attribute
        may be used in route selection - it\n   indicates that advertised routing
        information is not complete.\n"
      title: 5.11.3. Route Selection and ConvertedRoute
    - contents:
      - "5.11.4. Aggregation and ConvertedRoute\n   If any of the routes to aggregate
        has the ConvertedRoute attribute,\n   then so MUST the resultant aggregate.\n"
      title: 5.11.4. Aggregation and ConvertedRoute
    - contents:
      - "5.11.5. Route Dissemination and ConvertedRoute\n   If an LS changes the Application
        Protocol of a route before\n   advertising the route to an external peer,
        the LS MUST include the\n   ConvertedRoute attribute.\n"
      title: 5.11.5. Route Dissemination and ConvertedRoute
    title: 5.11. ConvertedRoute
  - contents:
    - "5.12. Considerations for Defining New TRIP Attributes\n   Any proposal for
      defining new TRIP attributes should specify the\n   following:\n      -  the
      use of this attribute,\n      -  the attribute's flags,\n      -  the attribute's
      syntax,\n      -  how the attribute works with route origination,\n      -  how
      the attribute works with route aggregation, and\n      -  how the attribute
      works with route dissemination and the\n         attribute's scope (e.g., intra-domain
      only like\n         LocalPreference)\n   IANA will manage the assignment of
      TRIP attribute type codes to new\n   attributes.\n"
    title: 5.12. Considerations for Defining New TRIP Attributes
  title: 5. TRIP Attributes
- contents:
  - "6. TRIP Error Detection and Handling\n   This section describes errors to be
    detected and the actions to be\n   taken while processing TRIP messages.\n   When
    any of the conditions described here are detected, a\n   NOTIFICATION message
    with the indicated Error Code, Error Subcode,\n   and Data fields MUST be sent,
    and the TRIP connection MUST be closed.\n   If no Error Subcode is specified,
    then a zero Subcode MUST be used.\n   The phrase \"the TRIP connection is closed\"
    means that the transport\n   protocol connection has been closed and that all
    resources for that\n   TRIP connection have been de-allocated.  If the connection
    was\n   inter-domain, then routing table entries associated with the remote\n
    \  peer MUST be marked as invalid.  Routing table entries MUST NOT be\n   marked
    as invalid if an internal peering session is terminated.  The\n   fact that the
    routes have been marked as invalid is passed to other\n   TRIP peers before the
    routes are deleted from the system.\n   Unless specified explicitly, the Data
    field of the NOTIFICATION\n   message that is sent to indicate an error MUST be
    empty.\n"
  - contents:
    - "6.1. Message Header Error Detection and Handling\n   All errors detected while
      processing the Message Header are indicated\n   by sending the NOTIFICATION
      message with the Error Code Message\n   Header Error.  The Error Subcode elaborates
      on the specific nature of\n   the error.  The error checks in this section MUST
      be performed by\n   each LS upon receipt of every message.\n   If the Length
      field of the message header is less than 3 or greater\n   than 4096, or if the
      Length field of an OPEN message is less than the\n   minimum length of the OPEN
      message, or if the Length field of an\n   UPDATE message is less than the minimum
      length of the UPDATE message,\n   or if the Length field of a KEEPALIVE message
      is not equal to 3, or\n   if the Length field of a NOTIFICATION message is less
      than the\n   minimum length of the NOTIFICATION message, then the Error Subcode\n
      \  MUST be set to Bad Message Length.  The Data field contains the\n   erroneous
      Length field.\n   If the Type field of the message header is not recognized,
      then the\n   Error Subcode MUST be set to \"Bad Message Type.\"  The Data field\n
      \  contains the erroneous Type field.\n"
    title: 6.1. Message Header Error Detection and Handling
  - contents:
    - "6.2. OPEN Message Error Detection and Handling\n   All errors detected while
      processing the OPEN message are indicated\n   by sending the NOTIFICATION message
      with the Error Code \"OPEN Message\n   Error.\"  The Error Subcode elaborates
      on the specific nature of the\n   error.  The error checks in this section MUST
      be performed by each LS\n   upon receipt of every OPEN message.\n   If the version
      number contained in the Version field of the received\n   OPEN message is not
      supported, then the Error Subcode MUST be set to\n   \"Unsupported Version Number.\"
      \ The Data field is a 1-octet unsigned\n   integer, which indicates the largest
      locally supported version\n   number, which is less than the version of the
      remote TRIP peer bid\n   (as indicated in the received OPEN message).\n   If
      the ITAD field of the OPEN message is unacceptable, then the Error\n   Subcode
      MUST be set to \"Bad Peer ITAD.\"  The determination of\n   acceptable ITAD
      numbers is outside the scope of this protocol.\n   If the Hold Time field of
      the OPEN message is unacceptable, then the\n   Error Subcode MUST be set to
      \"Unacceptable Hold Time.\"  An\n   implementation MUST reject Hold Time values
      of one or two seconds.\n   An implementation MAY reject any proposed Hold Time.
      \ An\n   implementation that accepts a Hold Time MUST use the negotiated value\n
      \  for the Hold Time.\n   If the TRIP Identifier field of the OPEN message is
      not valid, then\n   the Error Subcode MUST be set to \"Bad TRIP Identifier.\"
      \ A TRIP\n   identifier is 4-octets in length and can take any value.  An LS\n
      \  considers the TRIP Identifier invalid if it already has an open\n   connection
      with another peer LS that has the same ITAD and TRIP\n   Identifier.\n   Any
      two LSs within the same ITAD MUST NOT have equal TRIP Identifier\n   values.
      \ This restriction does not apply to LSs in different ITADs\n   since the purpose
      is to uniquely identify an LS using its TRIP\n   Identifier and its ITAD number.\n
      \  If one of the Optional Parameters in the OPEN message is not\n   recognized,
      then the Error Subcode MUST be set to \"Unsupported\n   Optional Parameters.\"\n
      \  If the Optional Parameters of the OPEN message include Capability\n   Information
      with an unsupported capability (unsupported in either\n   capability type or
      value), then the Error Subcode MUST be set to\n   \"Unsupported Capability,\"
      and the entirety of the unsupported\n   capabilities MUST be listed in the Data
      field of the NOTIFICATION\n   message.\n   If the Optional Parameters of the
      OPEN message include Capability\n   Information which does not match the receiving
      LS's capabilities,\n   then the Error Subcode MUST be set to \"Capability Mismatch,\"
      and the\n   entirety of the mismatched capabilities MUST be listed in the Data\n
      \  field of the NOTIFICATION message.\n"
    title: 6.2. OPEN Message Error Detection and Handling
  - contents:
    - "6.3. UPDATE Message Error Detection and Handling\n   All errors detected while
      processing the UPDATE message are indicated\n   by sending the NOTIFICATION
      message with the Error Code \"UPDATE\n   Message Error.\"  The Error Subcode
      elaborates on the specific nature\n   of the error.  The error checks in this
      section MUST be performed by\n   each LS upon receipt of every UPDATE message.
      \ These error checks\n   MUST occur before flooding procedures are invoked with
      internal\n   peers.\n   If any recognized attribute has Attribute Flags that
      conflict with\n   the Attribute Type Code, then the Error Subcode MUST be set
      to\n   \"Attribute Flags Error.\"  The Data field contains the erroneous\n   attribute
      (type, length and value).\n   If any recognized attribute has an Attribute Length
      that conflicts\n   with the expected length (based on the attribute type code),
      then the\n   Error Subcode MUST be set to \"Attribute Length Error.\"  The Data\n
      \  field contains the erroneous attribute (type, length and value).\n   If any
      of the mandatory (i.e., conditional mandatory attribute and\n   the conditions
      for including it in the UPDATE message are fulfilled)\n   well-known attributes
      are not present, then the Error Subcode MUST be\n   set to \"Missing Well-known
      Mandatory Attribute.\"  The Data field\n   contains the Attribute Type Code
      of the missing well-known\n   conditional mandatory attributes.\n   If any of
      the well-known attributes are not recognized, then the\n   Error Subcode MUST
      be set to \"Unrecognized Well-known Attribute.\"\n   The Data field contains
      the unrecognized attribute (type, length and\n   value).\n   If any attribute
      has a syntactically incorrect value, or an undefined\n   value, then the Error
      Subcode is set to \"Invalid Attribute.\"  The\n   Data field contains the incorrect
      attribute (type, length and value).\n   Such a NOTIFICATION message is sent,
      for example, when a\n   NextHopServer attribute is received with an invalid
      address.\n   The information carried by the AdvertisementPath attribute is checked\n
      \  for ITAD loops.  ITAD loop detection is done by scanning the full\n   AdvertisementPath,
      and checking that the ITAD number of the local\n   ITAD does not appear in the
      AdvertisementPath.  If the local ITAD\n   number appears in the AdvertisementPath,
      then the route MAY be stored\n   in the Adj-TRIB-In.  However unless the LS
      is configured to accept\n   routes with its own ITAD in the advertisement path,
      the route MUST\n   not be passed to the TRIP Decision Process.  The operation
      of an LS\n   that is configured to accept routes with its own ITAD number in
      the\n   advertisement path are outside the scope of this document.\n   If the
      UPDATE message was received from an internal peer and either\n   the WithdrawnRoutes,
      ReachableRoutes, or ITAD Topology attribute does\n   not have the Link-State
      Encapsulation flag set, then the Error\n   Subcode is set to \"Invalid Attribute\"
      and the data field contains the\n   attribute.  Likewise, the attribute is invalid
      if received from an\n   external peer and the Link-State Flag is set.\n   If
      any attribute appears more than once in the UPDATE message, then\n   the Error
      Subcode is set to \"Malformed Attribute List.\"\n"
    title: 6.3. UPDATE Message Error Detection and Handling
  - contents:
    - "6.4. NOTIFICATION Message Error Detection and Handling\n   If a peer sends
      a NOTIFICATION message, and there is an error in that\n   message, there is
      unfortunately no means of reporting this error via\n   a subsequent NOTIFICATION
      message.  Any such error, such as an\n   unrecognized Error Code or Error Subcode,
      should be noticed, logged\n   locally, and brought to the attention of the administration
      of the\n   peer.  The means to do this, however, are outside the scope of this\n
      \  document.\n"
    title: 6.4. NOTIFICATION Message Error Detection and Handling
  - contents:
    - "6.5. Hold Timer Expired Error Handling\n   If a system does not receive successive
      messages within the period\n   specified by the negotiated Hold Time, then a
      NOTIFICATION message\n   with a \"Hold Timer Expired\" Error Code MUST be sent
      and the TRIP\n   connection MUST be closed.\n"
    title: 6.5. Hold Timer Expired Error Handling
  - contents:
    - "6.6. Finite State Machine Error Handling\n   An error detected by the TRIP
      Finite State Machine (e.g., receipt of\n   an unexpected event) MUST result
      in sending a NOTIFICATION message\n   with the Error Code \"Finite State Machine
      Error\" and the TRIP\n   connection MUST be closed.\n"
    title: 6.6. Finite State Machine Error Handling
  - contents:
    - "6.7. Cease\n   In the absence of any fatal errors (that are indicated in this\n
      \  section), a TRIP peer MAY choose at any given time to close its TRIP\n   connection
      by sending the NOTIFICATION message with the Error Code\n   \"Cease.\"  However,
      the Cease NOTIFICATION message MUST NOT be used\n   when a fatal error indicated
      by this section exists.\n"
    title: 6.7. Cease
  - contents:
    - "6.8. Connection Collision Detection\n   If a pair of LSs try simultaneously
      to establish a transport\n   connection to each other, then two parallel connections
      between this\n   pair of speakers might well be formed.  We refer to this situation
      as\n   connection collision.  Clearly, one of these connections must be\n   closed.\n
      \  Based on the value of the TRIP Identifier, a convention is\n   established
      for detecting which TRIP connection is to be preserved\n   when a collision
      occurs.  The convention is to compare the TRIP\n   Identifiers of the peers
      involved in the collision and to retain only\n   the connection initiated by
      the LS with the higher-valued TRIP\n   Identifier.\n   Upon receipt of an OPEN
      message, the local LS MUST examine all of its\n   connections that are in the
      OpenConfirm state.  An LS MAY also\n   examine connections in an OpenSent state
      if it knows the TRIP\n   Identifier of the peer by means outside of the protocol.
      \ If among\n   these connections there is a connection to a remote LS, whose
      TRIP\n   Identifier equals the one in the OPEN message, then the local LS MUST\n
      \  perform the following collision resolution procedure:\n   The TRIP Identifier
      and ITAD of the local LS is compared to the TRIP\n   Identifier and ITAD of
      the remote LS (as specified in the OPEN\n   message).  TRIP Identifiers are
      treated as 4-octet unsigned integers\n   for comparison.\n   If the value of
      the local TRIP Identifier is less than the remote\n   one, or if the two TRIP
      Identifiers are equal and the value of the\n   ITAD of the local LS is less
      than value of the ITAD of the remote LS,\n   then the local LS MUST close the
      TRIP connection that already exists\n   (the one that is already in the OpenConfirm
      state), and accept the\n   TRIP connection initiated by the remote LS:\n      1.
      Otherwise, the local LS closes the newly created TRIP\n         connection and
      continues to use the existing one (the one that\n         is already in the
      OpenConfirm state).\n      2. If a connection collision occurs with an existing
      TRIP\n         connection that is in the Established state, then the LS MUST\n
      \        unconditionally close off the newly created connection.  Note\n         that
      a connection collision cannot be detected with connections\n         in Idle,
      Connect, or Active states.\n      3. To close the TRIP connection (that results
      from the collision\n         resolution procedure), an LS MUST send a NOTIFICATION
      message\n         with the Error Code \"Cease\" and the TRIP connection MUST
      be\n         closed.\n"
    title: 6.8. Connection Collision Detection
  title: 6. TRIP Error Detection and Handling
- contents:
  - "7. TRIP Version Negotiation\n   Peer LSs may negotiate the version of the protocol
    by making multiple\n   attempts to open a TRIP connection, starting with the highest
    version\n   number each supports.  If an open attempt fails with an Error Code\n
    \  \"OPEN Message Error\" and an Error Subcode \"Unsupported Version\n   Number,\"
    then the LS has available the version number it tried, the\n   version number
    its peer tried, the version number passed by its peer\n   in the NOTIFICATION
    message, and the version numbers that it\n   supports.  If the two peers support
    one or more common versions, then\n   this will allow them to rapidly determine
    the highest common version.\n   In order to support TRIP version negotiation,
    future versions of TRIP\n   must retain the format of the OPEN and NOTIFICATION
    messages.\n"
  title: 7. TRIP Version Negotiation
- contents:
  - "8. TRIP Capability Negotiation\n   An LS MAY include the Capabilities Option
    in its OPEN message to a\n   peer to indicate the capabilities supported by the
    LS.  An LS\n   receiving an OPEN message MUST NOT use any capabilities that were
    not\n   included in the OPEN message of the peer when communicating with that\n
    \  peer.\n"
  title: 8. TRIP Capability Negotiation
- contents:
  - "9. TRIP Finite State Machine\n   This section specifies TRIP operation in terms
    of a Finite State\n   Machine (FSM).  Following is a brief summary and overview
    of TRIP\n   operations by state as determined by this FSM.  A condensed version\n
    \  of the TRIP FSM is found in Appendix 1.  There is one TRIP FSM per\n   peer
    and these FSMs operate independently.\n   Idle state:\n   Initially TRIP is in
    the Idle state for each peer.  In this state,\n   TRIP refuses all incoming connections.
    \ No resources are allocated to\n   the peer.  In response to the Start event
    (initiated by either the\n   system or the operator), the local system initializes
    all TRIP\n   resources, starts the ConnectRetry timer, initiates a transport\n
    \  connection to the peer, starts listening for a connection that may be\n   initiated
    by the remote TRIP peer, and changes its state to Connect.\n   The exact value
    of the ConnectRetry timer is a local matter, but\n   should be sufficiently large
    to allow TCP initialization.\n   If an LS detects an error, it closes the transport
    connection and\n   changes its state to Idle.  Transitioning from the Idle state\n
    \  requires generation of the Start event.  If such an event is\n   generated
    automatically, then persistent TRIP errors may result in\n   persistent flapping
    of the LS.  To avoid such a condition, Start\n   events MUST NOT be generated
    immediately for a peer that was\n   previously transitioned to Idle due to an
    error.  For a peer that was\n   previously transitioned to Idle due to an error,
    the time between\n   consecutive Start events, if such events are generated automatically,\n
    \  MUST exponentially increase.  The value of the initial timer SHOULD\n   be
    60 seconds, and the time SHOULD be at least doubled for each\n   consecutive retry
    up to some maximum value.\n   Any other event received in the Idle state is ignored.\n
    \  Connect State:\n   In this state, an LS is waiting for a transport protocol
    connection\n   to be completed to the peer, and is listening for inbound transport\n
    \  connections from the peer.\n   If the transport protocol connection succeeds,
    the local LS clears\n   the ConnectRetry timer, completes initialization, sends
    an OPEN\n   message to its peer, sets its Hold Timer to a large value, and\n   changes
    its state to OpenSent.  A Hold Timer value of 4 minutes is\n   suggested.\n   If
    the transport protocol connect fails (e.g., retransmission\n   timeout), the local
    system restarts the ConnectRetry timer, continues\n   to listen for a connection
    that may be initiated by the remote LS,\n   and changes its state to Active state.\n
    \  In response to the ConnectRetry timer expired event, the local LS\n   cancels
    any outstanding transport connection to the peer, restarts\n   the ConnectRetry
    timer, initiates a transport connection to the\n   remote LS, continues to listen
    for a connection that may be initiated\n   by the remote LS, and stays in the
    Connect state.\n   If the local LS detects that a remote peer is trying to establish
    a\n   connection to it and the IP address of the peer is not an expected\n   one,
    then the local LS rejects the attempted connection and continues\n   to listen
    for a connection from its expected peers without changing\n   state.\n   If an
    inbound transport protocol connection succeeds, the local LS\n   clears the ConnectRetry
    timer, completes initialization, sends an\n   OPEN message to its peer, sets its
    Hold Timer to a large value, and\n   changes its state to OpenSent.  A Hold Timer
    value of 4 minutes is\n   suggested.\n   The Start event is ignored in the Connect
    state.\n   In response to any other event (initiated by either the system or the\n
    \  operator), the local system releases all TRIP resources associated\n   with
    this connection and changes its state to Idle.\n   Active state:\n   In this state,
    an LS is listening for an inbound connection from the\n   peer, but is not in
    the process of initiating a connection to the\n   peer.\n   If an inbound transport
    protocol connection succeeds, the local LS\n   clears the ConnectRetry timer,
    completes initialization, sends an\n   OPEN message to its peer, sets its Hold
    Timer to a large value, and\n   changes its state to OpenSent.  A Hold Timer value
    of 4 minutes is\n   suggested.\n   In response to the ConnectRetry timer expired
    event, the local system\n   restarts the ConnectRetry timer, initiates a transport
    connection to\n   the TRIP peer, continues to listen for a connection that may
    be\n   initiated by the remote TRIP peer, and changes its state to Connect.\n
    \  If the local LS detects that a remote peer is trying to establish a\n   connection
    to it and the IP address of the peer is not an expected\n   one, then the local
    LS rejects the attempted connection and continues\n   to listen for a connection
    from its expected peers without changing\n   state.\n   Start event is ignored
    in the Active state.\n   In response to any other event (initiated by either the
    system or the\n   operator), the local system releases all TRIP resources associated\n
    \  with this connection and changes its state to Idle.\n   OpenSent state:\n   In
    this state, an LS has sent an OPEN message to its peer and is\n   waiting for
    an OPEN message from its peer.  When an OPEN message is\n   received, all fields
    are checked for correctness.  If the TRIP\n   message header checking or OPEN
    message checking detects an error\n   (see Section 6.2) or a connection collision
    (see Section 6.8), the\n   local system sends a NOTIFICATION message and changes
    its state to\n   Idle.\n   If there are no errors in the OPEN message, TRIP sends
    a KEEPALIVE\n   message and sets a KeepAlive timer.  The Hold Timer, which was\n
    \  originally set to a large value (see above), is replaced with the\n   negotiated
    Hold Time value (see Section 4.2).  If the negotiated Hold\n   Time value is zero,
    then the Hold Time timer and KeepAlive timers are\n   not started.  If the value
    of the ITAD field is the same as the local\n   ITAD number, then the connection
    is an \"internal\" connection;\n   otherwise, it is \"external\" (this will affect
    UPDATE processing).\n   Finally, the state is changed to OpenConfirm.\n   If the
    local LS detects that a remote peer is trying to establish a\n   connection to
    it and the IP address of the peer is not an expected\n   one, then the local LS
    rejects the attempted connection and continues\n   to listen for a connection
    from its expected peers without changing\n   state.\n   If a disconnect notification
    is received from the underlying\n   transport protocol, the local LS closes the
    transport connection,\n   restarts the ConnectRetry timer, continues to listen
    for a connection\n   that may be initiated by the remote TRIP peer, and goes into
    the\n   Active state.\n   If the Hold Timer expires, the local LS sends a NOTIFICATION
    message\n   with the Error Code \"Hold Timer Expired\" and changes its state to\n
    \  Idle.\n   In response to the Stop event (initiated by either system or\n   operator)
    the local LS sends a NOTIFICATION message with the Error\n   Code \"Cease\" and
    changes its state to Idle.\n   The Start event is ignored in the OpenSent state.\n
    \  In response to any other event the local LS sends a NOTIFICATION\n   message
    with the Error Code \"Finite State Machine Error\" and changes\n   its state to
    Idle.\n   Whenever TRIP changes its state from OpenSent to Idle, it closes the\n
    \  transport connection and releases all resources associated with that\n   connection.\n
    \  OpenConfirm state:\n   In this state, an LS has sent an OPEN to its peer, received
    an OPEN\n   from its peer, and sent a KEEPALIVE in response to the OPEN.  The
    LS\n   is now waiting for a KEEPALIVE or NOTIFICATION message in response to\n
    \  its OPEN.\n   If the local LS receives a KEEPALIVE message, it changes its
    state to\n   Established.\n   If the Hold Timer expires before a KEEPALIVE message
    is received, the\n   local LS sends NOTIFICATION message with the Error Code \"Hold
    Timer\n   Expired\" and changes its state to Idle.\n   If the local LS receives
    a NOTIFICATION message, it changes its state\n   to Idle.\n   If the KeepAlive
    timer expires, the local LS sends a KEEPALIVE\n   message and restarts its KeepAlive
    timer.\n   If a disconnect notification is received from the underlying\n   transport
    protocol, the local LS closes the transport connection,\n   restarts the ConnectRetry
    timer, continues to listen for a connection\n   that may be initiated by the remote
    TRIP peer, and goes into the\n   Active state.\n   In response to the Stop event
    (initiated by either the system or the\n   operator) the local LS sends NOTIFICATION
    message with the Error Code\n   \"Cease\" and changes its state to Idle.\n   The
    Start event is ignored in the OpenConfirm state.\n   In response to any other
    event the local LS sends a NOTIFICATION\n   message with the Error Code \"Finite
    State Machine Error\" and changes\n   its state to Idle.\n   Whenever TRIP changes
    its state from OpenConfirm to Idle, it closes\n   the transport connection and
    releases all resources associated with\n   that connection.\n   Established state:\n
    \  In the Established state, an LS can exchange UPDATE, NOTIFICATION,\n   and
    KEEPALIVE messages with its peer.\n   If the negotiated Hold Timer is zero, then
    no procedures are\n   necessary for keeping a peering session alive.  If the negotiated\n
    \  Hold Time value is non-zero, the procedures of this paragraph apply.\n   If
    the Hold Timer expires, the local LS sends a NOTIFICATION message\n   with the
    Error Code \"Hold Timer Expired\" and changes its state to\n   Idle.  If the KeepAlive
    Timer expires, then the local LS sends a\n   KeepAlive message and restarts the
    KeepAlive Timer.  If the local LS\n   receives an UPDATE or KEEPALIVE message,
    then it restarts its Hold\n   Timer.  Each time the LS sends an UPDATE or KEEPALIVE
    message, it\n   restarts its KeepAlive Timer.\n   If the local LS receives a NOTIFICATION
    message, it changes its state\n   to Idle.\n   If the local LS receives an UPDATE
    message and the UPDATE message\n   error handling procedure (see Section6.3) detects
    an error, the local\n   LS sends a NOTIFICATION message and changes its state
    to Idle.\n   If a disconnect notification is received from the underlying\n   transport
    protocol, the local LS changes its state to Idle.\n   In response to the Stop
    event (initiated by either the system or the\n   operator), the local LS sends
    a NOTIFICATION message with the Error\n   Code \"Cease\" and changes its state
    to Idle.\n   The Start event is ignored in the Established state.\n   In response
    to any other event, the local LS sends a NOTIFICATION\n   message with Error Code
    \"Finite State Machine Error\" and changes its\n   state to Idle.\n   Whenever
    TRIP changes its state from Established to Idle, it closes\n   the transport connection
    and releases all resources associated with\n   that connection.  Additionally,
    if the peer is an external peer, the\n   LS deletes all routes derived from that
    connection.\n"
  title: 9. TRIP Finite State Machine
- contents:
  - "10. UPDATE Message Handling\n   An UPDATE message may be received only in the
    Established state.\n   When an UPDATE message is received, each field is checked
    for\n   validity as specified in Section 6.3.  The rest of this section\n   presumes
    that the UPDATE message has passed the error-checking\n   procedures of Section
    6.3.\n   If the UPDATE message was received from an internal peer, the\n   flooding
    procedures of Section 10.1 MUST be applied.  The flooding\n   process synchronizes
    the Loc-TRIBs of all LSs within the domain.\n   Certain routes within the UPDATE
    may be marked as old or duplicates\n   by the flooding process and are ignored
    during the rest of the UPDATE\n   processing.\n   If the UPDATE message contains
    withdrawn routes, then the\n   corresponding previously advertised routes shall
    be removed from the\n   Adj-TRIB-In.  This LS MUST rerun its Decision Process
    since the\n   previously advertised route is no longer available for use.\n   If
    the UPDATE message contains a route, then the route MUST be placed\n   in the
    appropriate Adj-TRIB-In, and the following additional actions\n   MUST be taken:\n
    \     1. If its destinations are identical to those of a route currently\n         stored
    in the Adj-TRIB-In, then the new route MUST replace the\n         older route
    in the Adj-TRIB-In, thus implicitly withdrawing the\n         older route from
    service.  The LS MUST rerun its Decision\n         Process since the older route
    is no longer available for use.\n      2. If the new route is more specific than
    an earlier route\n         contained in the Adj-TRIB-In and has identical attributes,
    then\n         no further actions are necessary.\n      3. If the new route is
    more specific than an earlier route\n         contained in the Adj-TRIB-In but
    does not have identical\n         attributes, then the LS MUST run its Decision
    Process since the\n         more specific route has implicitly made a portion
    of the less\n         specific route unavailable for use.\n      4. If the new
    route has destinations that are not present in any\n         of the routes currently
    stored in the Adj-TRIB-In, then the LS\n         MUST run its Decision Process.\n
    \     5. If the new route is less specific than an earlier route\n         contained
    in the Adj-TRIB-In, the LS MUST run its Decision\n         Process on the set
    of destinations that are described only by\n         the less specific route.\n"
  - contents:
    - "10.1. Flooding Process\n   When an LS receives an UPDATE message from an internal
      peer, the LS\n   floods the new information from that message to all of its
      other\n   internal peers.  Flooding is used to efficiently synchronize all of\n
      \  the LSs within a domain without putting any constraints on the\n   domain's
      internal topology.  The flooding mechanism is based on the\n   techniques used
      in OSPF [4] and SCSP [6].  One may argue that TRIP's\n   flooding process is
      in reality a controlled broadcast mechanism.\n"
    - contents:
      - "10.1.1. Database Information\n   The LS MUST maintain the sequence number
        and originating TRIP\n   identifier for each link-state encapsulated attribute
        in an internal\n   Adj-TRIB-In.  These values are included with the route
        in the\n   ReachableRoutes, WithdrawnRoutes, and ITAD Topology attributes.
        \ The\n   originating TRIP identifier gives the internal LS that originated\n
        \  this route into the ITAD, the sequence number gives the version of\n   this
        route at the originating LS.\n"
      title: 10.1.1. Database Information
    - contents:
      - "10.1.2. Determining Newness\n   For each route in the ReachableRoutes or
        WithdrawnRoutes field, the\n   LS decides if the route is new or old.  This
        is determined by\n   comparing the Sequence Number of the route in the UPDATE
        with the\n   Sequence Number of the route saved in the Adj-TRIB-In.  The route
        is\n   new if either the route does not exist in the Adj-TRIB-In for the\n
        \  originating LS, or if the route does exist in the Adj-TRIB-In but the\n
        \  Sequence Number in the UPDATE is greater than the Sequence Number\n   saved
        in the Adj-TRIBs-In.  Note that the newness test is\n   independently applied
        to each link-state encapsulated attribute in\n   the UPDATE (WithdrawnRoutes
        or ReachableRoutes or ITAD Topology).\n"
      title: 10.1.2. Determining Newness
    - contents:
      - "10.1.3. Flooding\n   Each route in the ReachableRoutes or WithdrawnRoutes
        field that is\n   determined to be old is ignored in further processing.  If
        the route\n   is determined to be new then the following actions occur.\n
        \  If the route is being withdrawn, then the LS MUST flood the withdrawn\n
        \  route to all other internal peers, and MUST mark the route as\n   withdrawn.
        \ An LS MUST maintain routes marked as withdrawn in its\n   databases for
        MaxPurgeTime seconds.\n   If the route is being updated, then the LS MUST
        update the route in\n   the Adj-TRIB-In and MUST flood it to all other internal
        peers.\n   If these procedures result in changes to the Adj-TRIB-In, then
        the\n   route is also made available for local route processing as described\n
        \  early in Section 10.\n   To implement flooding, the following is recommended.
        \ All routes\n   received in a single UPDATE message that are determined to
        be new\n   should be forwarded to all other internal peers in a single UPDATE\n
        \  message.  Other variations of flooding are possible, but the local LS\n
        \  MUST ensure that each new route (and any associated attributes)\n   received
        from an internal peer get forwarded to every other internal\n   peer.\n"
      title: 10.1.3. Flooding
    - contents:
      - "10.1.4. Sequence Number Considerations\n   The Sequence Number is used to
        determine when one version of a Route\n   is newer than another version of
        a route.  A larger Sequence Number\n   indicates a newer version.  The Sequence
        Number is assigned by the LS\n   originating the route into the local ITAD.
        \ The Sequence Number is an\n   unsigned 4-octet integer in the range of 1
        thru 2^31-1 MinSequenceNum\n   thru MaxSequenceNum).  The value 0 is reserved.
        \ When an LS first\n   originates a route (including when the LS restarts/reboots)
        into its\n   ITAD, it MUST originate it with a Sequence Number of MinSequenceNum.\n
        \  Each time the route is updated within the ITAD by the originator, the\n
        \  Sequence Number MUST be increased.\n   If it is ever the case that the
        sequence number is MaxSequenceNum-1\n   and it needs to be increased, then
        the TRIP module of the LS MUST be\n   disabled for a period of TripDisableTime
        so that all routes\n   originated by this LS with high sequence numbers can
        be removed.\n"
      title: 10.1.4. Sequence Number Considerations
    - contents:
      - "10.1.5. Purging a Route Within the ITAD\n   To withdraw a route that it originated
        within the ITAD, an LS\n   includes the route in the WithdrawnRoutes field
        of an UPDATE message.\n   The Sequence Number MUST be greater than the last
        valid version of\n   the route.  The LS MAY choose to use a sequence number
        of\n   MaxSequenceNum when withdrawing routes within its ITAD, but this is\n
        \  not required.\n   After withdrawing a route, an LS MUST mark the route
        as \"withdrawn\"\n   in its database, and maintain the withdrawn route in
        its database for\n   MaxPurgeTime seconds.  If the LS needs to re-originate
        a route that\n   had been purged but is still in its database, it can either
        re-\n   originate the route immediately using a Sequence Number that is\n
        \  greater than that used in the withdraw, or the LS may wait until\n   MaxPurgeTime
        seconds have expired since the route was withdrawn.\n"
      title: 10.1.5. Purging a Route Within the ITAD
    - contents:
      - "10.1.6. Receiving Self-Originated Routes\n   It is common for an LS to receive
        UPDATES for routes that it\n   originated within the ITAD via the flooding
        procedure.  If the LS\n   receives an UPDATE for a route that it originated
        that is newer (has\n   a higher sequence number) than the LSs current version,
        then special\n   actions must be taken.  This should be a relatively rare
        occurrence\n   and indicates that a route still exists within the ITAD since
        the LSs\n   last restart/reboot.\n   If an LS receives a self-originated route
        update that is newer than\n   the current version of the route at the LS,
        then the following\n   actions MUST be taken.  If the LS still wishes to advertise
        the\n   information in the route, then the LS MUST increase the Sequence\n
        \  Number of the route to a value greater than that received in the\n   UPDATE
        and re-originate the route.  If the LS does not wish to\n   continue to advertise
        the route, then it MUST purge the route as\n   described in Section 10.1.5.\n"
      title: 10.1.6. Receiving Self-Originated Routes
    - contents:
      - "10.1.7. Removing Withdrawn Routes\n   An LS SHOULD ensure that routes marked
        as withdrawn are removed from\n   the database in a timely fashion after the
        MaxPurgeTime has expired.\n   This could be done, for example, by periodically
        sweeping the\n   database, and deleting those entries that were withdrawn
        more than\n   MaxPurgeTime seconds ago.\n"
      title: 10.1.7. Removing Withdrawn Routes
    title: 10.1. Flooding Process
  - contents:
    - "10.2. Decision Process\n   The Decision Process selects routes for subsequent
      advertisement by\n   applying the policies in the local Policy Information Base
      (PIB) to\n   the routes stored in its Adj-TRIBs-In.  The output of the Decision\n
      \  process is the set of routes that will be advertised to all peers;\n   the
      selected routes will be stored in the local LS's Adj-TRIBs-Out.\n   The selection
      process is formalized by defining a function that takes\n   the attributes of
      a given route as an argument and returns a non-\n   negative integer denoting
      the degree of preference for the route.\n   The function that calculates the
      degree of preference for a given\n   route shall not use as its inputs any of
      the following:  the\n   existence of other routes, the non-existence of other
      routes, or the\n   attributes of other routes.  Route selection then consists
      of an\n   individual application of the degree of preference function to each\n
      \  feasible route, followed by the choice of the one with the highest\n   degree
      of preference.\n   All internal LSs in an ITAD MUST run the Decision Process
      and apply\n   the same decision criteria, otherwise it will not be possible
      to\n   synchronize their Loc-TRIBs.\n   The Decision Process operates on routes
      contained in each Adj-TRIBs-\n   In, and is responsible for:\n      -  selection
      of routes to be advertised to internal peers\n      -  selection of routes to
      be advertised to external peers\n      -  route aggregation and route information
      reduction\n   The Decision Process takes place in three distinct phases, each\n
      \  triggered by a different event:\n      -  Phase 1 is responsible for calculating
      the degree of preference\n         for each route received from an external
      peer.\n      -  Phase 2 is invoked on completion of phase 1.  It is responsible\n
      \        for choosing the best route out of all those available for each\n         distinct
      destination, and for installing each chosen route into\n         the Loc-TRIB.\n
      \     -  Phase 3 is invoked after the Loc-TRIB has been modified.  It is\n         responsible
      for disseminating routes in the Loc-TRIB to each\n         external peer, according
      to the policies contained in the PIB.\n         Route aggregation and information
      reduction can optionally be\n         performed within this phase.\n"
    - contents:
      - "10.2.1. Phase 1: Calculation of Degree of Preference\n   The Phase 1 decision
        function shall be invoked whenever the local LS\n   receives from a peer an
        UPDATE message that advertises a new route, a\n   replacement route, or a
        withdrawn route.\n   The Phase 1 decision function is a separate process that
        is completed\n   when it has no further work to do.\n   The Phase 1 decision
        function shall lock an Adj-TRIB-In prior to\n   operating on any route contained
        within it, and shall unlock it after\n   operating on all new or replacement
        routes contained within it.\n   The local LS MUST determine a degree of preference
        for each newly\n   received or replacement route.  If the route is learned
        from an\n   internal peer, the value of the LocalPreference attribute MUST
        be\n   taken as the degree of preference.  If the route is learned from an\n
        \  external peer, then the degree of preference MUST be computed based\n   on
        pre-configured policy information and used as the LocalPreference\n   value
        in any intra-domain TRIP advertisement.  The exact nature of\n   this policy
        information and the computation involved is a local\n   matter.\n   The output
        of the degree of preference determination process is the\n   local preference
        of a route.  The local LS computes the local\n   preference of routes learned
        from external peers or originated\n   internally at that LS.  The local preference
        of a route learned from\n   an internal peer is included in the LocalPreference
        attribute\n   associated with that route.\n"
      title: '10.2.1. Phase 1: Calculation of Degree of Preference'
    - contents:
      - "10.2.2. Phase 2: Route Selection\n   The Phase 2 decision function shall
        be invoked on completion of Phase\n   1.  The Phase 2 function is a separate
        process that completes when it\n   has no further work to do.  Phase 2 consists
        of two sub-phases: 2a\n   and 2b.  The same route selection function is applied
        in both sub-\n   phases, but the inputs to each phase are different.  The
        Phase 2a\n   process MUST consider as inputs all external routes, that are
        present\n   in the Adj-TRIBs-In of external peers, and all local routes.  The\n
        \  output of Phase 2a is inserted into the Ext-TRIB.  The Phase 2b\n   process
        shall be invoked upon completion of Phase 2a and it MUST\n   consider as inputs
        all routes in the Ext-TRIB and all routes that are\n   present in the Adj-TRIBs-In
        of internal LSs.  The output of Phase 2b\n   is stored in the Loc-TRIB.\n
        \  The Phase 2 decision function MUST be blocked from running while the\n
        \  Phase 3 decision function is in process.  The Phase 2 function MUST\n   lock
        all Adj-TRIBs-In and the Ext-TRIB prior to commencing its\n   function, and
        MUST unlock them on completion.\n   If the LS determines that the NextHopServer
        listed in a route is\n   unreachable, then the route MAY be excluded from
        the Phase 2 decision\n   function.  The means by which such a determination
        is made is not\n   mandated here.\n   For each set of destinations for which
        one or more routes exist, the\n   local LS's route selection function MUST
        identify the route that has:\n      -  the highest degree of preference, or\n
        \     -  is selected as a result of the tie breaking rules specified in\n
        \        10.2.2.1.\n   Withdrawn routes MUST be removed from the Loc-TRIB,
        Ext-TRIB, and the\n   Adj-TRIBs-In.\n"
      - contents:
        - "10.2.2.1. Breaking Ties (Phase 2)\n   Several routes to the same destination
          that have the same degree of\n   preference may be input to the Phase 2
          route selection function.  The\n   local LS can select only one of these
          routes for inclusion in the\n   associated Ext-TRIB (Phase 2a) or Loc-TRIB
          (Phase 2b).  The local LS\n   considers all routes with the same degrees
          of preference.  The\n   following algorithm shall be used to break ties.\n
          \     -  If the local LS is configured to use the MultiExitDisc\n         attribute
          to break ties, and candidate routes received from the\n         same neighboring
          ITAD differ in the value of the MultiExitDisc\n         attribute, then
          select the route that has the larger value of\n         MultiExitDisc.\n
          \     -  If at least one of the routes was originated by an internal LS,\n
          \        select the route route that was advertised by the internal LS\n
          \        that has the lowest TRIP ID.\n      -  Otherwise, select the route
          that was advertised by the neighbor\n         domain that has the lowest
          ITAD number.\n"
        title: 10.2.2.1. Breaking Ties (Phase 2)
      title: '10.2.2. Phase 2: Route Selection'
    - contents:
      - "10.2.3. Phase 3: Route Dissemination\n   The Phase 3 decision function MUST
        be invoked upon completion of\n   Phase 2 if Phase 2 results in changes to
        the Loc-TRIB or when a new\n   LS-to-LS peer session is established.\n   The
        Phase 3 function is a separate process that is completed when it\n   has no
        further work to do.  The Phase 3 routing decision function\n   MUST be blocked
        from running while the Phase 2 decision function is\n   in process.\n   All
        routes in the Loc-TRIB shall be processed into a corresponding\n   entry in
        the associated Adj-TRIBs-Out.  Route aggregation and\n   information reduction
        techniques (see 10.3.4) MAY optionally be\n   applied.\n   When the updating
        of the Adj-TRIBs-Out is complete, the local LS MUST\n   run the external update
        process of 10.3.2.\n"
      title: '10.2.3. Phase 3: Route Dissemination'
    - contents:
      - "10.2.4. Overlapping Routes\n   When overlapping routes are present in the
        same Adj-TRIB-In, the more\n   specific route shall take precedence, in order,
        from most specific to\n   least specific.\n   The set of destinations described
        by the overlap represents a portion\n   of the less specific route that is
        feasible, but is not currently in\n   use.  If a more specific route is later
        withdrawn, the set of\n   destinations described by the more specific route
        will still be\n   reachable using the less specific route.\n   If an LS receives
        overlapping routes, the Decision Process MUST take\n   into account the semantics
        of the overlapping routes.  In particular,\n   if an LS accepts the less specific
        route while rejecting the more\n   specific route from the same peer, then
        the destinations represented\n   by the overlap may not forward along the
        domains listed in the\n   AdvertisementPath attribute of that route.  Therefore,
        an LS has the\n   following choices:\n      1. Install both the less and the
        more specific routes\n      2. Install the more specific route only\n      3.
        Install the non-overlapping part of the less specific route\n         only
        (that implies disaggregation of the less-specific route)\n      4. Aggregate
        the two routes and install the aggregated route\n      5. Install the less
        specific route only\n      6. Install neither route\n   If an LS chooses 5),
        then it SHOULD add AtomicAggregate attribute to\n   the route.  A route that
        carries AtomicAggregate attribute MUST NOT\n   be de-aggregated.  That is,
        the route cannot be made more specific.\n   Forwarding along such a route
        does not guarantee that route traverses\n   only domains listed in the RoutedPath
        of the route.  If an LS chooses\n   1), then it MUST NOT advertise the less
        specific route without the\n   more specific route.\n"
      title: 10.2.4. Overlapping Routes
    title: 10.2. Decision Process
  - contents:
    - "10.3. Update-Send Process\n   The Update-Send process is responsible for advertising
      UPDATE\n   messages to all peers.  For example, it distributes the routes chosen\n
      \  by the Decision Process to other LSs that may be located in either\n   the
      same ITAD or a neighboring ITAD.  Rules for information exchange\n   between
      peer LSs located in different ITADs are given in 10.3.2;\n   rules for information
      exchange between peer LSs located in the same\n   ITAD are given in 10.3.1.\n
      \  Before forwarding routes to peers, an LS MUST determine which\n   attributes
      should be forwarded along with that route.  If a not\n   well-known non-transitive
      attribute is unrecognized, it is quietly\n   ignored.  If a not well-known dependent-transitive
      attribute is\n   unrecognized, and the NextHopServer attribute has been changed
      by the\n   LS, the unrecognized attribute is quietly ignored.  If a not well-\n
      \  known dependent-transitive attribute is unrecognized, and the\n   NextHopServer
      attribute has not been modified by the LS, the Partial\n   bit in the attribute
      flags octet is set to 1, and the attribute is\n   retained for propagation to
      other TRIP speakers.  Similarly, if an\n   not well-known independent-transitive
      attribute is unrecognized, the\n   Partial bit in the attribute flags octet
      is set to 1, and the\n   attribute is retained for propagation to other TRIP
      speakers.\n   If a not well-known attribute is recognized, and has a valid value,\n
      \  then, depending on the type of the not well-known attribute, it is\n   updated,
      if necessary, for possible propagation to other TRIP\n   speakers.\n"
    - contents:
      - "10.3.1. Internal Updates\n   The Internal update process is concerned with
        the distribution of\n   routing information to internal peers.\n   When an
        LS receives an UPDATE message from another TRIP LS located in\n   its own
        ITAD, it is flooded as described in Section 10.1.\n   When an LS receives
        a new route from an LS in a neighboring ITAD, or\n   if a local route is injected
        into TRIP, the LS determines the\n   preference of that route.  If the new
        route has the highest degree of\n   preference for all external routes and
        local routes to a given\n   destination (or if the route was selected via
        a tie-breaking\n   procedure as specified in 10.3.1.1), the LS MUST insert
        that new\n   route into the Ext-TRIB database and the LS MUST advertise that
        route\n   to all other LSs in its ITAD by means of an UPDATE message.  The
        LS\n   MUST advertise itself as the Originator of that route within the\n
        \  ITAD.\n   When an LS receives an UPDATE message with a non-empty\n   WithdrawnRoutes
        attribute from an external peer, or if a local route\n   is withdrawn from
        TRIP, the LS MUST remove from its Adj-TRIB-In all\n   routes whose destinations
        were carried in this field.  If the\n   withdrawn route was previously selected
        into the Ext-TRIB, the LS\n   MUST take the following additional steps:\n
        \     -  If a new route is selected for advertisement for those\n         destinations,
        then the LS MUST insert the replacement route\n         into Ext-TRIB to replace
        the withdrawn route and advertise it\n         to all internal LSs.\n      -
        \ If a replacement route is not available for advertisement, then\n         the
        LS MUST include the destinations of the route in the\n         WithdrawnRoutes
        attribute of an UPDATE message, and MUST send\n         this message to each
        internal peer.  The LS MUST also remove\n         the withdrawn route from
        the Ext-TRIB.\n"
      - contents:
        - "10.3.1.1. Breaking Ties (Routes Received from External Peers)\n   If an
          LS has connections to several external peers, there will be\n   multiple
          Adj-TRIBs-In associated with these peers.  These databases\n   might contain
          several equally preferable routes to the same\n   destination, all of which
          were advertised by external peers.  The\n   local LS shall select one of
          these routes according to the following\n   rules:\n      -  If the LS is
          configured to use the MultiExitDisc attribute to\n         break ties, and
          the candidate routes differ in the value of the\n         MultiExitDisc
          attribute, then select the route that has the\n         lowest value of
          MultiExitDisc, else\n      -  Select the route that was advertised by the
          external LS that\n         has the lowest TRIP Identifier.\n"
        title: 10.3.1.1. Breaking Ties (Routes Received from External Peers)
      title: 10.3.1. Internal Updates
    - contents:
      - "10.3.2. External Updates\n   The external update process is concerned with
        the distribution of\n   routing information to external peers.  As part of
        the Phase 3 route\n   selection process, the LS has updated its Adj-TRIBs-Out.
        \ All newly\n   installed routes and all newly unfeasible routes for which
        there is\n   no replacement route MUST be advertised to external peers by
        means of\n   UPDATE messages.\n   Any routes in the Loc-TRIB marked as withdrawn
        MUST be removed.\n   Changes to the reachable destinations within its own
        ITAD SHALL also\n   be advertised in an UPDATE message.\n"
      title: 10.3.2. External Updates
    - contents:
      - "10.3.3. Controlling Routing Traffic Overhead\n   The TRIP protocol constrains
        the amount of routing traffic (that is,\n   UPDATE messages) in order to limit
        both the link bandwidth needed to\n   advertise UPDATE messages and the processing
        power needed by the\n   Decision Process to digest the information contained
        in the UPDATE\n   messages.\n"
      - contents:
        - "10.3.3.1. Frequency of Route Advertisement\n   The parameter MinRouteAdvertisementInterval
          determines the minimum\n   amount of time that must elapse between advertisements
          of routes to a\n   particular destination from a single LS.  This rate limiting\n
          \  procedure applies on a per-destination basis, although the value of\n
          \  MinRouteAdvertisementInterval is set on a per LS peer basis.\n   Two
          UPDATE messages sent from a single LS that advertise feasible\n   routes
          to some common set of destinations received from external\n   peers MUST
          be separated by at least MinRouteAdvertisementInterval.\n   Clearly, this
          can only be achieved precisely by keeping a separate\n   timer for each
          common set of destinations.  This would be unwarranted\n   overhead.  Any
          technique which ensures that the interval between two\n   UPDATE messages
          sent from a single LS that advertise feasible routes\n   to some common
          set of destinations received from external peers will\n   be at least MinRouteAdvertisementInterval,
          and will also ensure that\n   a constant upper bound on the interval is
          acceptable.\n   Two UPDATE messages, sent from a single LS to an external
          peer, that\n   advertise feasible routes to some common set of destinations
          received\n   from internal peers MUST be separated by at least\n   MinRouteAdvertisementInterval.\n
          \  Since fast convergence is needed within an ITAD, this rate limiting\n
          \  procedure does not apply to routes received from internal peers and\n
          \  being broadcast to other internal peers.  To avoid long-lived black\n
          \  holes, the procedure does not apply to the explicit withdrawal of\n   routes
          (that is, routes whose destinations explicitly withdrawn by\n   UPDATE messages).\n
          \  This procedure does not limit the rate of route selection, but only\n
          \  the rate of route advertisement.  If new routes are selected multiple\n
          \  times while awaiting the expiration of MinRouteAdvertisementInterval,\n
          \  the last route selected shall be advertised at the end of\n   MinRouteAdvertisementInterval.\n"
        title: 10.3.3.1. Frequency of Route Advertisement
      - contents:
        - "10.3.3.2. Frequency of Route Origination\n   The parameter MinITADOriginationInterval
          determines the minimum\n   amount of time that must elapse between successive
          advertisements of\n   UPDATE messages that report changes within the advertising
          LS's own\n   ITAD.\n"
        title: 10.3.3.2. Frequency of Route Origination
      - contents:
        - "10.3.3.3. Jitter\n   To minimize the likelihood that the distribution of
          TRIP messages by\n   a given LS will contain peaks, jitter should be applied
          to the timers\n   associated with MinITADOriginationInterval, KeepAlive,
          and\n   MinRouteAdvertisementInterval.  A given LS shall apply the same\n
          \  jitter to each of these quantities regardless of the destinations to\n
          \  which the updates are being sent; that is, jitter will not be applied\n
          \  on a \"per peer\" basis.\n   The amount of jitter to be introduced shall
          be determined by\n   multiplying the base value of the appropriate timer
          by a random\n   factor that is uniformly distributed in the range from 0.75
          to 1.0.\n"
        title: 10.3.3.3. Jitter
      title: 10.3.3. Controlling Routing Traffic Overhead
    - contents:
      - "10.3.4. Efficient Organization of Routing Information\n   Having selected
        the routing information that it will advertise, a\n   TRIP speaker may use
        methods to organize this information in an\n   efficient manner.  These methods
        are discussed in the following\n   sections.\n"
      - contents:
        - "10.3.4.1. Information Reduction\n   Information reduction may imply a reduction
          in granularity of policy\n   control - after information has collapsed,
          the same policies will\n   apply to all destinations and paths in the equivalence
          class.\n   The Decision Process may optionally reduce the amount of information\n
          \  that it will place in the Adj-TRIBs-Out by any of the following\n   methods:\n
          \     -  ReachableRoutes: A set of destinations can be usually\n         represented
          in compact form.  For example, a set of E.164 phone\n         numbers can
          be represented in more compact form using E.164\n         prefixes.\n      -
          \ AdvertisementPath: AdvertisementPath information can be\n         represented
          as ordered AP_SEQUENCEs or unordered AP_SETs.\n         AP_SETs are used
          in the route aggregation algorithm described\n         in Section 5.4.4.
          \ They reduce the size of the AP_PATH\n         information by listing each
          ITAD number only once, regardless\n         of how many times it may have
          appeared in multiple\n         advertisement paths that were aggregated.\n
          \  An AP_SET implies that the destinations advertised in the UPDATE\n   message
          can be reached through paths that traverse at least some of\n   the constituent
          ITADs.  AP_SETs provide sufficient information to\n   avoid route looping;
          however their use may prune potentially feasible\n   paths, since such paths
          are no longer listed individually as in the\n   form of AP_SEQUENCEs.  In
          practice this is not likely to be a\n   problem, since once a call arrives
          at the edge of a group of ITADs,\n   the LS at that point is likely to have
          more detailed path information\n   and can distinguish individual paths
          to destinations.\n"
        title: 10.3.4.1. Information Reduction
      - contents:
        - "10.3.4.2. Aggregating Routing Information\n   Aggregation is the process
          of combining the characteristics of\n   several different routes in such
          a way that a single route can be\n   advertised.  Aggregation can occur
          as part of the decision process to\n   reduce the amount of routing information
          that is placed in the Adj-\n   TRIBs-Out.\n   Aggregation reduces the amount
          of information an LS must store and\n   exchange with other LSs.  Routes
          can be aggregated by applying the\n   following procedure separately to
          attributes of like type.\n   Routes that have the following attributes shall
          not be aggregated\n   unless the corresponding attributes of each route
          are identical:\n   MultiExitDisc, NextHopServer.\n   Attributes that have
          different type codes cannot be aggregated.\n   Attributes of the same type
          code may be aggregated.  The rules for\n   aggregating each attribute MUST
          be provided together with attribute\n   definition.  For example, aggregation
          rules for TRIP's basic\n   attributes, e.g., ReachableRoutes and AdvertisementPath,
          are given in\n   Section 5.\n"
        title: 10.3.4.2. Aggregating Routing Information
      title: 10.3.4. Efficient Organization of Routing Information
    title: 10.3. Update-Send Process
  - contents:
    - "10.4. Route Selection Criteria\n   Generally speaking, additional rules for
      comparing routes among\n   several alternatives are outside the scope of this
      document.  There\n   are two exceptions:\n      -  If the local ITAD appears
      in the AdvertisementPath of the new\n         route being considered, then that
      new route cannot be viewed as\n         better than any other route.  If such
      a route were ever used, a\n         routing loop could result (see Section 6.3).\n
      \     -  In order to achieve successful distributed operation, only\n         routes
      with a likelihood of stability can be chosen.  Thus, an\n         ITAD must
      avoid using unstable routes, and it must not make\n         rapid spontaneous
      changes to its choice of route.  Quantifying\n         the terms \"unstable\"
      and \"rapid\" in the previous sentence will\n         require experience, but
      the principle is clear.\n"
    title: 10.4. Route Selection Criteria
  - contents:
    - "10.5. Originating TRIP Routes\n   An LS may originate local routes by injecting
      routing information\n   acquired by some other means (e.g. via an intra-domain
      routing\n   protocol or through manual configuration or some dynamic registration\n
      \  mechanism/protocol) into TRIP.  An LS that originates TRIP routes\n   shall
      assign the degree of preference to these routes by passing them\n   through
      the Decision Process (see Section 10.2).  To TRIP, local\n   routes are identical
      to external routes and are subjected to the same\n   two phase route selection
      mechanism.  A local route which is selected\n   into the Ext-TRIB MUST be advertised
      to all internal LSs.  The\n   decision whether to distribute non-TRIP acquired
      routes within an\n   ITAD via TRIP or not depends on the environment within
      the ITAD (e.g.\n   type of intra-domain routing protocol) and should be controlled
      via\n   configuration.\n"
    title: 10.5. Originating TRIP Routes
  title: 10. UPDATE Message Handling
- contents:
  - "11. TRIP Transport\n   This specification defines the use of TCP as the transport
    layer for\n   TRIP.  TRIP uses TCP port 6069.  Running TRIP over other transport\n
    \  protocols is for further study.\n"
  title: 11. TRIP Transport
- contents:
  - "12. ITAD Topology\n   There are no restrictions on the intra-domain topology
    of TRIP LSs.\n   For example, LSs in an ITAD can be configured in a full mesh,
    star,\n   or any other connected topology.  Similarly, there are no\n   restrictions
    on the topology of TRIP ITADs.  For example, the ITADs\n   can be organized in
    a flat topology (mesh or ring) or in multi-level\n   hierarchy or any other topology.\n
    \  The border between two TRIP ITADs may be located either on the link\n   between
    two TRIP LSs or it may coincide on a TRIP LS.  In the latter\n   case, the same
    TRIP LS will be member in more than one ITAD, and it\n   appears to be an internal
    peer to LSs in each ITAD it is member of.\n"
  title: 12. ITAD Topology
- contents:
  - "13. IANA Considerations\n   This document creates a new IANA registry for TRIP
    parameters.  The\n   following TRIP parameters are included in the registry:\n
    \     - TRIP Capabilities\n      - TRIP Attributes\n      - TRIP Address Families\n
    \     - TRIP Application Protocols\n      - TRIP ITAD Numbers\n   Protocol parameters
    are frequently initialized/reset to 0.  This\n   document reserves the value 0
    of each of the above TRIP parameters in\n   order to clearly distinguish between
    an unset parameter and any other\n   registered values for that parameter.\n   The
    sub-registries for each of the above parameters are discussed in\n   the sections
    below.\n"
  - contents:
    - "13.1. TRIP Capabilities\n   Requests to add TRIP capabilities other than those
      defined in Section\n   4.2.1.1 must be submitted to iana@iana.org.  Following
      the assigned\n   number policies outlined in [11], Capability Codes in the range\n
      \  32768-65535 are reserved for Private Use (these are the codes with\n   the
      first bit of the code value equal to 1).  This document reserves\n   value 0.
      \ Capability Codes 1 and 2 have been assigned in Section\n   4.2.1.1.  Capability
      Codes in the range 2-32767 are controlled by\n   IANA, and are allocated subject
      to the Specification Required (IETF\n   RFC or equivalent) condition.  The specification
      MUST include a\n   description of the capability, the possible values it may
      take, and\n   what constitutes a capability mismatch.\n"
    title: 13.1. TRIP Capabilities
  - contents:
    - "13.2. TRIP Attributes\n   This document reserves Attribute Type Codes 224-255
      for Private Use\n   (these are the codes with the first three bits of the code
      equal to\n   1).  This document reserves the value 0.  Attribute Type Codes
      1\n   through 11 have already been allocated by this document.  Attribute\n
      \  Type Codes 1 through 11 are defined in Sections 5.1 through 5.11.\n   Attribute
      Type Codes in the range 12-223 are controlled by IANA, and\n   require a Specification
      document (RFC or equivalent).  The\n   specification MUST provide all information
      required in Section 5.12\n   of this document.\n   Attribute Type Code registration
      requests must be sent to\n   iana@iana.org.  In addition to the specification
      requirement, the\n   request MUST include an indication of who has change control
      over the\n   attribute and contact information (postal and email address).\n"
    title: 13.2. TRIP Attributes
  - contents:
    - "13.3. Destination Address Families\n   This document reserves address family
      0. Requests to add TRIP address\n   families other than those defined in Section
      5.1.1.1 ( address\n   families 1, 2, and 3), i.e., in the range 4-32767, must
      be submitted\n   to iana@iana.org.  The request MUST include a brief description
      of\n   the address family, its alphabet, and special processing rules and\n
      \  guidelines, such as guidelines for aggregation, if any.  The requests\n   are
      subject to Expert Review.  This document reserves the address\n   family codes
      32768-65535 for vendor-specific applications.\n"
    title: 13.3. Destination Address Families
  - contents:
    - "13.4. TRIP Application Protocols\n   This document creates a new IANA registry
      for TRIP application\n   protocols.  This document reserves the application
      protocol code 0.\n   Requests to add TRIP application protocols other than those
      defined\n   in Section 5.1.1.1 (application protocols 1 through 4), i.e., in
      the\n   range 5-32767, must be submitted to iana@iana.org.  The request MUST\n
      \  include a brief background on the application protocol, and a\n   description
      of how TRIP can be used to advertise routes for that\n   protocol.  The requests
      are subject to Expert Review.  This document\n   reserves the application protocol
      codes 32768-65535 for vendor-\n   specific applications.\n"
    title: 13.4. TRIP Application Protocols
  - contents:
    - "13.5. ITAD Numbers\n   This document reserves the ITAD number 0.  ITAD numbers
      in the range\n   1-255 are designated for Private Use.  ITAD numbers in the
      range from\n   256 to (2**32)-1 are allocated by IANA on a First-Come-First-Serve\n
      \  basis.  Requests for ITAD numbers must be submitted to iana@iana.org.\n   The
      requests MUST include the following:\n      -  Information about the organization
      that will administer the\n         ITAD.\n      -  Contact information (postal
      and email address).\n"
    title: 13.5. ITAD Numbers
  title: 13. IANA Considerations
- contents:
  - "14. Security Considerations\n   This section covers security between peer TRIP
    LSs when TRIP runs\n   over TCP in an IP environment.\n   A security mechanism
    is clearly needed to prevent unauthorized\n   entities from using the protocol
    defined in this document for setting\n   up unauthorized peer sessions with other
    TRIP LSs or interfering with\n   authorized peer sessions.  The security mechanism
    for the protocol,\n   when transported over TCP in an IP network, is IPsec [12].
    \ IPsec\n   uses two protocols to provide traffic security: Authentication Header\n
    \  (AH) [13] and Encapsulating Security Payload (ESP) [14].\n   The AH header
    affords data origin authentication, connectionless\n   integrity and optional
    anti-replay protection of messages passed\n   between the peer LSs.  The ESP header
    provides origin authentication,\n   connectionless integrity, anti-replay protection,
    and confidentiality\n   of messages.\n   Implementations of the protocol defined
    in this document employing\n   the ESP header SHALL comply with section 5 of [14],
    which defines a\n   minimum set of algorithms for integrity checking and encryption.\n
    \  Similarly, implementations employing the AH header SHALL comply with\n   section
    5 of [13], which defines a minimum set of algorithms for\n   integrity checking
    using manual keys.\n   Implementations SHOULD use IKE [15] to permit more robust
    keying\n   options.  Implementations employing IKE SHOULD support authentication\n
    \  with RSA signatures and RSA public key encryption.\n   A Security Association
    (SA) [12] is a simplex \"connection\" that\n   affords security services to the
    traffic carried by it.  Security\n   services are afforded to a SA by the use
    of AH, or ESP, but not both.\n   Two types of SAs are defined: transport mode
    and tunnel mode [12].  A\n   transport mode SA is a security association between
    two hosts, and is\n   appropriate for protecting the TRIP session between two
    peer LSs.\n"
  - "A1. Appendix 1: TRIP FSM State Transitions and Actions\n   This Appendix discusses
    the transitions between states in the TRIP\n   FSM in response to TRIP events.
    \ The following is the list of these\n   states and events when the negotiated
    Hold Time value is non-zero.\n   TRIP States:\n      1 - Idle\n      2 - Connect\n
    \     3 - Active\n      4 - OpenSent\n      5 - OpenConfirm\n      6 - Established\n
    \  TRIP Events:\n      1 - TRIP Start\n      2 - TRIP Stop\n      3 - TRIP Transport
    connection open\n      4 - TRIP Transport connection closed\n      5 - TRIP Transport
    connection open failed\n      6 - TRIP Transport fatal error\n      7 - ConnectRetry
    timer expired\n      8 - Hold Timer expired\n      9 - KeepAlive timer expired\n
    \     10 - Receive OPEN message\n      11 - Receive KEEPALIVE message\n      12
    - Receive UPDATE messages\n      13 - Receive NOTIFICATION message\n   The following
    table describes the state transitions of the TRIP FSM\n   and the actions triggered
    by these transitions.\n   Event                Actions              Message Sent
    \   Next State\n   --------------------------------------------------------------------\n
    \  Idle (1)\n    1            Initialize resources            none             2\n
    \                Start ConnectRetry timer\n                 Initiate a transport
    connection\n    others               none                    none             1\n
    \  Connect(2)\n    1                    none                    none             2\n
    \   3            Complete initialization         OPEN             4\n                 Clear
    ConnectRetry timer\n    5            Restart ConnectRetry timer      none             3\n
    \   7            Restart ConnectRetry timer      none             2\n                 Initiate
    a transport connection\n    others       Release resources               none
    \            1\n   Active (3)\n    1                    none                    none
    \            3\n    3            Complete initialization         OPEN             4\n
    \                Clear ConnectRetry timer\n    5            Close connection                                 3\n
    \                Restart ConnectRetry timer\n    7            Restart ConnectRetry
    timer      none             2\n                 Initiate a transport connection\n
    \   others       Release resources               none             1\n   OpenSent(4)\n
    \   1                    none                    none             4\n    4            Close
    transport connection      none             3\n                 Restart ConnectRetry
    timer\n    6            Release resources               none             1\n   10
    \           Process OPEN is OK            KEEPALIVE          5\n                 Process
    OPEN failed           NOTIFICATION       1\n   others        Close transport connection
    \   NOTIFICATION       1\n                 Release resources\n   OpenConfirm (5)\n
    \   1                   none                     none             5\n    4            Release
    resources               none             1\n    6            Release resources
    \              none             1\n    9            Restart KeepAlive timer       KEEPALIVE
    \         5\n   11            Complete initialization         none             6\n
    \                Restart Hold Timer\n   13            Close transport connection
    \                      1\n                 Release resources\n   others        Close
    transport connection    NOTIFICATION       1\n                 Release resources\n
    \  Established (6)\n    1                   none                     none             6\n
    \   4            Release resources               none             1\n    6            Release
    resources               none             1\n    9            Restart KeepAlive
    timer       KEEPALIVE          6\n   11            Restart Hold Timer              none
    \            6\n   12            Process UPDATE is OK          UPDATE             6\n
    \                Process UPDATE failed         NOTIFICATION       1\n   13            Close
    transport connection                       1\n                 Release resources\n
    \  others        Close transport connection    NOTIFICATION       1\n                 Release
    resources\n   -----------------------------------------------------------------\n
    \  The following is a condensed version of the above state transition\n   table.\n
    \  Events| Idle | Connect | Active | OpenSent | OpenConfirm | Estab\n         |
    (1)  |   (2)   |  (3)   |    (4)   |     (5)     |   (6)\n         |----------------------------------------------------------\n
    \   1    |  2   |    2    |   3    |     4    |      5      |    6\n         |
    \     |         |        |          |             |\n    2    |  1   |    1    |
    \  1    |     1    |      1      |    1\n         |      |         |        |
    \         |             |\n    3    |  1   |    4    |   4    |     1    |      1
    \     |    1\n         |      |         |        |          |             |\n
    \   4    |  1   |    1    |   1    |     3    |      1      |    1\n         |
    \     |         |        |          |             |\n    5    |  1   |    3    |
    \  3    |     1    |      1      |    1\n         |      |         |        |
    \         |             |\n    6    |  1   |    1    |   1    |     1    |      1
    \     |    1\n         |      |         |        |          |             |\n
    \   7    |  1   |    2    |   2    |     1    |      1      |    1\n         |
    \     |         |        |          |             |\n    8    |  1   |    1    |
    \  1    |     1    |      1      |    1\n         |      |         |        |
    \         |             |\n    9    |  1   |    1    |   1    |     1    |      5
    \     |    6\n         |      |         |        |          |             |\n
    \  10    |  1   |    1    |   1    |  1 or 5  |      1      |    1\n         |
    \     |         |        |          |             |\n   11    |  1   |    1    |
    \  1    |     1    |      6      |    6\n         |      |         |        |
    \         |             |\n   12    |  1   |    1    |   1    |     1    |      1
    \     | 1 or 6\n         |      |         |        |          |             |\n
    \  13    |  1   |    1    |   1    |     1    |      1      |    1\n         |
    \     |         |        |          |             |\n         --------------------------------------------------------------\n"
  - "A2. Appendix 2: Implementation Recommendations\n   This section presents some
    implementation recommendations.\n"
  - contents:
    - "A.2.1: Multiple Networks Per Message\n   The TRIP protocol allows for multiple
      address prefixes with the same\n   advertisement path and next-hop server to
      be specified in one\n   message.  Making use of this capability is highly recommended.
      \ With\n   one address prefix per message there is a substantial increase in\n
      \  overhead in the receiver.  Not only does the system overhead increase\n   due
      to the reception of multiple messages, but the overhead of\n   scanning the
      routing table for updates to TRIP peers is incurred\n   multiple times as well.
      \ One method of building messages containing\n   many address prefixes per advertisement
      path and next hop from a\n   routing table that is not organized per advertisement
      path is to\n   build many messages as the routing table is scanned.  As each
      address\n   prefix is processed, a message for the associated advertisement
      path\n   and next hop is allocated, if it does not exist, and the new address\n
      \  prefix is added to it.  If such a message exists, the new address\n   prefix
      is just appended to it.  If the message lacks the space to\n   hold the new
      address prefix, it is transmitted, a new message is\n   allocated, and the new
      address prefix is inserted into the new\n   message.  When the entire routing
      table has been scanned, all\n   allocated messages are sent and their resources
      released.  Maximum\n   compression is achieved when all the destinations covered
      by the\n   address prefixes share the same next hop server and common\n   attributes,
      making it possible to send many address prefixes in one\n   4096-byte message.\n
      \  When peering with a TRIP implementation that does not compress\n   multiple
      address prefixes into one message, it may be necessary to\n   take steps to
      reduce the overhead from the flood of data received\n   when a peer is acquired
      or a significant network topology change\n   occurs.  One method of doing this
      is to limit the rate of updates.\n   This will eliminate the redundant scanning
      of the routing table to\n   provide flash updates for TRIP peers.  A disadvantage
      of this\n   approach is that it increases the propagation latency of routing\n
      \  information.  By choosing a minimum flash update interval that is not\n   much
      greater than the time it takes to process the multiple messages,\n   this latency
      should be minimized.  A better method would be to read\n   all received messages
      before sending updates.\n"
    - contents:
      - "A.2.2: Processing Messages on a Stream Protocol\n   TRIP uses TCP as a transport
        mechanism.  Due to the stream nature of\n   TCP, all the data of a received
        message does not necessarily arrive\n   at the same time.  This can make it
        difficult to process the data as\n   messages, especially on systems where
        it is not possible to determine\n   how much data has been received but not
        yet processed.\n   One method that can be used in this situation is to first
        try to read\n   just the message header.  For the KEEPALIVE message type,
        this is a\n   complete message; for other message types, the header should
        first be\n   verified, in particular the total length.  If all checks are\n
        \  successful, the specified length, minus the size of the message\n   header
        is the amount of data left to read.  An implementation that\n   would \"hang\"
        the routing information process while trying to read\n   from a peer could
        set up a message buffer (4096 bytes) per peer and\n   fill it with data as
        available until a complete message has been\n   received.\n"
      title: 'A.2.2: Processing Messages on a Stream Protocol'
    - contents:
      - "A.2.3: Reducing Route Flapping\n   To avoid excessive route flapping an LS
        which needs to withdraw a\n   destination and send an update about a more
        specific or less specific\n   route SHOULD combine them into the same UPDATE
        message.\n"
      title: 'A.2.3: Reducing Route Flapping'
    - contents:
      - "A.2.4: TRIP Timers\n   TRIP employs seven timers: ConnectRetry, Hold Time,
        KeepAlive,\n   MaxPurgeTime, TripDisableTime, MinITADOriginationInterval,
        and\n   MinRouteAdvertisementInterval.  The suggested value for the\n   ConnectRetry
        timer is 120 seconds.  The suggested value for the Hold\n   Time is 90 seconds.
        \ The suggested value for the KeepAlive timer is\n   30 seconds.  The suggested
        value for the MaxPurgeTime timer is 10\n   seconds.  The suggested value for
        the TripDisableTime timer is 180\n   seconds.  The suggested value for the
        MinITADOriginationInterval is\n   30 seconds.  The suggested value for the\n
        \  MinRouteAdvertisementInterval is 30 seconds.\n   An implementation of TRIP
        MUST allow these timers to be configurable.\n"
      title: 'A.2.4: TRIP Timers'
    - contents:
      - "A.2.5: AP_SET Sorting\n   Another useful optimization that can be done to
        simplify this\n   situation is to sort the ITAD numbers found in an AP_SET.
        \ This\n   optimization is entirely optional.\n"
      title: 'A.2.5: AP_SET Sorting'
    title: 'A.2.1: Multiple Networks Per Message'
  title: 14. Security Considerations
- contents:
  - "Acknowledgments\n   We wish to thank Dave Oran for his insightful comments and\n
    \  suggestions.\n"
  title: Acknowledgments
- contents:
  - "References\n   [1]   Bradner, S., \"Keywords for use in RFCs to Indicate Requirement\n
    \        Levels\", BCP 14, RFC 2119, March 1997.\n   [2]   Rosenberg, J. and H.
    Schulzrinne, \"A Framework for a Gateway\n         Location Protocol\", RFC 2871,
    June 2000.\n   [3]   Rekhter, Y. and T. Li, \"Border Gateway Protocol 4 (BGP-4),\"
    RFC\n         1771, March 1995.\n   [4]   Moy, J., \"Open Shortest Path First
    Version 2\", STD 54, RFC\n         2328, April 1998.\n   [5]   \"Intermediate
    System to Intermediate System Intra-Domain\n         Routing Exchange Protocol
    for use in Conjunction with the\n         Protocol for Providing the Connectionless-mode
    Network Service\n         (ISO 8473),\" ISO DP 10589, February 1990.\n   [6]   Luciani,
    J., Armitage, G., Halpern, J. and N. Doraswamy,\n         \"Server Cache Synchronization
    Protocol (SCSP)\", RFC 2334, April\n         1998.\n   [7]   International Telecommunication
    Union, \"Packet-Based Multimedia\n         Communication Systems,\" Recommendation
    H.323, Version 3\n         Telecommunication Standardization Sector of ITU, Geneva,\n
    \        Switzerland, November 2000.\n   [8]   Handley, H., Schulzrinne, H., Schooler,
    E. and J. Rosenberg,\n         \"SIP:  Session Initiation Protocol\", RFC 2543,
    March 1999.\n   [9]   Braden, R., \"Requirements for Internet Hosts -- Application
    and\n         Support\", STD 3, RFC 1123, October 1989.\n   [10]  Hinden, R. and
    S. Deering, \"IP Version 6 Addressing\n         Architecture\", RFC 2373, July
    1998.\n   [11]  Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA\n
    \        Considerations Section in RFCs\", BCP 26, RFC 2434, October\n         1998.\n
    \  [12]  Kent, S. and R. Atkinson, \"Security Architecture for the\n         Internet
    Protocol\", RFC 2401, November 1998.\n   [13]  Kent, S. and R. Atkinson, \"IP
    Authentication Header\", RFC 2402,\n         November 1998.\n   [14]  Kent, S.
    and R. Atkinson, \"IP Encapsulating Security Payload\n         (ESP)\", RFC 2406,
    November 1998.\n   [15]  Harkins, D. and D. Carrel, \"The Internet Key Exchange
    (IKE)\",\n         RFC 2409, November 1998.\n"
  title: References
- contents:
  - "Intellectual Property Notice\n   The IETF takes no position regarding the validity
    or scope of any\n   intellectual property or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; neither does it represent that it\n   has made any effort to
    identify any such rights.  Information on the\n   IETF's procedures with respect
    to rights in standards-track and\n   standards-related documentation can be found
    in BCP 11.  Copies of\n   claims of rights made available for publication and
    any assurances of\n   licenses to be made available, or the result of an attempt
    made to\n   obtain a general license or permission for the use of such\n   proprietary
    rights by implementers or users of this specification can\n   be obtained from
    the IETF Secretariat.\n   The IETF invites any interested party to bring to its
    attention any\n   copyrights, patents or patent applications, or other proprietary\n
    \  rights which may cover technology that may be required to practice\n   this
    standard.  Please address the information to the IETF Executive\n   Director.\n
    \  The IETF has been notified of intellectual property rights claimed in\n   regard
    to some or all of the specification contained in this\n   document.  For more
    information consult the online list of claimed\n   rights.\n"
  title: Intellectual Property Notice
- contents:
  - "Authors' Addresses\n   Jonathan Rosenberg\n   dynamicsoft\n   72 Eagle Rock Avenue\n
    \  First Floor\n   East Hanover, NJ 07936\n   Phone: 973-952-5000\n   EMail: jdrosen@dynamicsoft.com\n
    \  Hussein F. Salama\n   Cisco Systems\n   170 W. Tasman Drive\n   San Jose, CA
    95134\n   Phone: 408-527-7147\n   EMail: hsalama@cisco.com\n   Matt Squire\n   Hatteras
    Networks\n   639 Davis Drive\n   Suite 200\n   Durham, NC 27713\n   EMail: mattsquire@acm.org\n"
  title: Authors' Addresses
- contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2002).  All
    Rights Reserved.\n   This document and translations of it may be copied and furnished
    to\n   others, and derivative works that comment on or otherwise explain it\n
    \  or assist in its implementation may be prepared, copied, published\n   and
    distributed, in whole or in part, without restriction of any\n   kind, provided
    that the above copyright notice and this paragraph are\n   included on all such
    copies and derivative works.  However, this\n   document itself may not be modified
    in any way, such as by removing\n   the copyright notice or references to the
    Internet Society or other\n   Internet organizations, except as needed for the
    purpose of\n   developing Internet standards in which case the procedures for\n
    \  copyrights defined in the Internet Standards process must be\n   followed,
    or as required to translate it into languages other than\n   English.\n   The
    limited permissions granted above are perpetual and will not be\n   revoked by
    the Internet Society or its successors or assigns.\n   This document and the information
    contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY
    AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS
    OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
    INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES
    OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
