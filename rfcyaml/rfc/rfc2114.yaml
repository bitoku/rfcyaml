- title: __initial_text__
  contents:
  - '               Data Link Switching Client Access Protocol

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  This memo\n   does not specify an Internet standard of any kind.  Distribution\
    \ of\n   this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   This memo describes the Data Link Switching Client Access Protocol\n\
    \   that is used between workstations and routers to transport SNA/\n   NetBIOS\
    \ traffic over TCP sessions. Any questions or comments should\n   be sent to dcap@cisco.com.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction ............................................\
    \   2\n   2.  Overview ................................................   2\n\
    \   2.1  DCAP Client/Server Model ...............................   2\n   2.2\
    \  Dynamic Address Resolution .............................   3\n   2.3  TCP Connection\
    \ .........................................   4\n   2.4  Multicast and Unicast\
    \ (UDP) ............................   4\n   3.  DCAP Format .............................................\
    \   6\n   3.1  General Frame Format ...................................   6\n\
    \   3.2  Header Format ..........................................   6\n   3.3\
    \  DCAP Messages ..........................................   7\n   3.4  DCAP\
    \ Data formats ......................................   8\n   3.4.1  CAN_U_REACH,\
    \ I_CAN_REACH, and I_CANNOT_REACH Frames ..   8\n   3.4.2  START_DL, DL_STARTED,\
    \ and START_DL_FAILED Frames .....   9\n   3.4.3  HALT_DL, HALT_DL_NOACK, and\
    \ DL_HALTED Frames .........  13\n   3.4.4  XID_FRAME, CONTACT_STN, STN_CONTACTED,\
    \ INFO_FRAME,\n          FCM_FRAME, and DGRM_FRAME ............................\
    \  14\n   3.4.5  DATA_FRAME ...........................................  15\n\
    \   3.4.6  CAP_XCHANGE Frame ....................................  16\n   3.4.7\
    \  CLOSE_PEER_REQ Frames ................................  19\n   3.4.8  CLOSE_PEER_RSP,\
    \ PEER_TEST_REQ, and PEER_TEST_RSP Frames 20\n   4.  Protocol Flow Diagram ...................................\
    \  20\n   5.  Acknowledgments .........................................  22\n\
    \   6.  References ..............................................  22\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Since the Data Link Switching Protocol, RFC 1795, was published,\
    \ some\n   software vendors have begun implementing DLSw on workstations. The\n\
    \   implementation of DLSw on a large number of workstations raises\n   several\
    \ important issues that must be addressed. Scalability is the\n   major concern.\
    \ For example, the number of TCP sessions to the DLSw\n   router increases in\
    \ direct proportion to the number of workstations\n   added. Another concern is\
    \ efficiency. Since DLSw is a switch-to-\n   switch protocol, it is not efficient\
    \ when implemented on\n   workstations.\n   DCAP addresses the above issues. It\
    \ introduces a hierarchical\n   structure to resolve the scalability problems.\
    \ All workstations are\n   clients to the router (server) rather than peers to\
    \ the router. This\n   creates a client/server model. It also provides a more\
    \ efficient\n   protocol between the workstation (client) and the router (server).\n"
- title: 2.  Overview
  contents:
  - '2.  Overview

    '
- title: 2.1.  DCAP Client/Server Model
  contents:
  - "2.1.  DCAP Client/Server Model\n      +-----------+              +-----------+\
    \       +---------+\n      | Mainframe |              | IP Router +- ppp -+ DLSw\
    \    |\n      +--+--------+              +-----+-----+       | Work    |\n   \
    \      |                             |             | Station |\n         |   \
    \                          |             +---------+\n      +--+--+      +-------------+\
    \     |\n      | FEP +- TR -+ DLSw Router +-- IP Backbone\n      +-----+     \
    \ +-------------+     |\n                                       |\n          \
    \                             |\n                                 +-----------+\
    \       +---------+\n                                 | IP Router +- ppp -+ DLSw\
    \    |\n                                 +-----+-----+       | Work    |\n   \
    \                                                  | Station |\n             \
    \                                        +---------+\n                       \
    \    |         DLSw Session          |\n                           +-------------------------------+\n\
    \  Figure 2-1. Running DLSw on a large number of workstations creates a\n    \
    \                     scalability problem.\n   Figure 2-1 shows a typical DLSw\
    \ implementation on a workstation. The\n   workstations are connected to the central\
    \ site DLSw router over the\n   IP network.  As the network grows, scalability\
    \ will become an issue\n   as the number of TCP sessions increases due to the\
    \ growing number of\n   workstations.\n  +-----------+                       \
    \                 +--------+\n  | Mainframe |                                \
    \        | DCAP   |\n  +--+--------+                                  +-----+\
    \ Client |\n     |                                           |     +--------+\n\
    \     |                                          ppp\n     |                 \
    \                          |\n  +--+--+      +--------+                 +------+------+\n\
    \  | FEP +- TR -+  DLSw  +-- IP Backbone --+ DLSw Router |\n  +-----+      | Router\
    \ |                 | DCAP Server |\n               +--------+               \
    \  +------+------+\n                                                 |\n     \
    \                                           ppp\n                            \
    \                     |     +--------+\n                                     \
    \            +-----+ DCAP   |\n                                              \
    \         | Client |\n                                                       +--------+\n\
    \                    |     DLSw Session     |  | DCAP Session |\n            \
    \        +----------------------+  +--------------+\n     Figure 2-2. DLSw Client\
    \ Access Protocol solves the scalability\n                                problem.\n\
    \   In a large network, DCAP addresses the scalability problem by\n   significantly\
    \ reducing the number of peers that connect to the\n   central site router. The\
    \ workstations (DCAP clients) and the router\n   (DCAP server) behave in a Client/Server\
    \ relationship. Workstations\n   are attached to a DCAP server. A DCAP server\
    \ has a single peer\n   connection to the central site router.\n"
- title: 2.2.  Dynamic Address Resolution
  contents:
  - "2.2.  Dynamic Address Resolution\n   In a DLSw network, each workstation needs\
    \ a MAC address to\n   communicate with a FEP attached to a LAN. When DLSw is\
    \ implemented on\n   a workstation, it does not always have a MAC address defined.\
    \ For\n   example, when a workstation connects to a router through a modem via\n\
    \   PPP, it only consists of an IP address. In this case, the user must\n   define\
    \ a virtual MAC address. This is administratively intensive\n   since each workstation\
    \ must have an unique MAC address.\n   DCAP uses the Dynamic Address Resolution\
    \ protocol to solve this\n   problem. The Dynamic Address Resolution protocol\
    \ permits the server\n   to dynamically assign a MAC address to a client without\
    \ complex\n   configuration.\n   For a client to initiate a session to a server,\
    \ the workstation sends\n   a direct request to the server. The request contains\
    \ the destination\n   MAC address and the destination SAP. The workstation can\
    \ either\n   specify its own MAC address, or request the server to assign one\
    \ to\n   it. The server's IP address must be pre-configured on the\n   workstation.\
    \ If IP addresses are configured for multiple servers at a\n   workstation, the\
    \ request can be sent to these servers and the first\n   one to respond will be\
    \ used.\n   For a server to initiate a session to a client, the server sends a\n\
    \   directed request to the workstation. The workstation must pre-\n   register\
    \ its MAC address at the server. This can be done either by\n   configuration\
    \ on the server or registration at the server (both MAC\n   addresses and IP addresses\
    \ will be registered).\n"
- title: 2.3.  TCP Connection
  contents:
  - "2.3.  TCP Connection\n   The transport used between the client and the server\
    \ is TCP. A TCP\n   session must be established between the client and the server\
    \ before\n   a frame can be sent. The default parameters associated with the TCP\n\
    \   connections between the client and the server are as follows:\n   Socket Family\
    \     AF_INET        (Internet protocols)\n   Socket Type       SOCK_STREAM  \
    \  (stream socket)\n   Port Number       1973\n   There is only one TCP connection\
    \ between the client and the server.\n   It is used for both read and write operations.\n\
    \   A race condition occurs when both client and server try to establish\n   the\
    \ TCP session with each other at the same time. The TCP session of\n   the initiator\
    \ with the lower IP address will be used. The other TCP\n   session will be closed.\n"
- title: 2.4   Multicast and Unicast (UDP)
  contents:
  - "2.4   Multicast and Unicast (UDP)\n   Multicast and unicast with UDP support\
    \ are optional. In the reset of\n   this session, when multicast and unicast are\
    \ referenced, UDP is used.\n   Two multicast addresses are reserved for DCAP.\
    \ The server should\n   listen for 224.0.1.49 and the client should listen for\
    \ 224.0.1.50.\n   Not all DCAP frames can be sent via multicast or unicast. The\n\
    \   DATA_FRAME can be sent via either multicast or unicast. The\n   CAN_U_REACH\
    \ frame can be sent via multicast only and the I_CAN_REACH\n   frame can be sent\
    \ via unicast only. All other DCAP frames can only be\n   sent via TCP sessions.\n\
    \   When the multicast and unicast support is implemented, the client\n   does\
    \ not have to configure the server's IP address. When the client\n   attempts\
    \ to establish a session to the host, instead of establishing\n   a TCP session\
    \ with the pre-configured server, the client can\n   multicast the CAN_U_REACH\
    \ frame to the 224.0.1.49 group address. When\n   the server receives this multicast\
    \ frame, it will locate the\n   destination as specified in the frame. If the\
    \ destination is\n   reachable by this server, it will send back an I_CAN_REACH\
    \ frame to\n   the sender via unicast.  The client can initiate a TCP connection\
    \ to\n   the server and establish a DCAP session. If the I_CAN_REACH frame is\n\
    \   received from multiple servers, the first one who returns the\n   I_CAN_REACH\
    \ frame will be used.\n   When the host initiates a session to the client, the\
    \ client does not\n   have to pre-register its MAC address at the server. When\
    \ the server\n   attempts to reach an unknown client, it will multicast the\n\
    \   CAN_U_REACH frame to the 224.0.10.50 group address. The client whose\n   MAC\
    \ address matches the destination address in the CAN_U_REACH frame\n   will reply\
    \ with the I_CAN_REACH frame via unicast. Once the server\n   receives the I_CAN_REACH\
    \ frame, it can establish a DCAP session with\n   that client.\n   For NetBIOS\
    \ traffic, NAME_QUERY and ADD_NAME_QUERY can be\n   encapsulated in the DATA_FRAME\
    \ and sent out via multicast.\n   NAME_RECOGNIZED and ADD_NAME_RESPONSE can be\
    \ encapsulated in the\n   DATA_FRAME but sent out via unicast. No other NetBIOS\
    \ frames can be\n   encapsulated in the DATA_FRAME to be sent out via either multicast\
    \ or\n   unicast.\n   When a client tries to locate a name or check for duplicate\
    \ name on\n   the network, it can multicast a NAME_QUERY or ADD_NAME_QUERY frame\n\
    \   encapsulated in the DATA_FRAME. When a server receives these frames,\n   NetBIOS\
    \ NAME_QUERY or ADD_NAME_QUERY frames will be forwarded to LAN.\n   If the NAME_RECOGNIZED\
    \ or ADD_NAME_RESPONSE frame is received from\n   LAN, they will be encapsulated\
    \ in the DATA_FRAME and sent to the\n   client via unicast.\n   When a server\
    \ receives a NetBIOS NAME_QUERY or ADD_NAME_QUERY from\n   LAN, the server will\
    \ encapsulate it in the DATA_FRAME and send it to\n   all clients via multicast.\
    \ When a client receives the frame and\n   determines that the name specified\
    \ in the DATA_FRAME matches its own\n   name, a NAME_RECOGNIZED or ADD_NAME_RESPONSE\
    \ frame will be\n   encapsulated in the DATA_FRAME and sent back to the server\
    \ via\n   unicast.\n"
- title: 3.  DCAP Format
  contents:
  - '3.  DCAP Format

    '
- title: 3.1.  General Frame Format
  contents:
  - "3.1.  General Frame Format\n   The General format of the DCAP frame is as follows:\n\
    \                  +-------------+-----------+-----------+\n                 \
    \ | DCAP Header | DCAP Data | User Data |\n                  +-------------+-----------+-----------+\n\
    \                     Figure 3-1. DCAP Frame Format\n   The DCAP protocol is contained\
    \ in the DCAP header, which is common to\n   all frames passed between the DCAP\
    \ client and the server. This header\n   is 4 bytes long. The next section will\
    \ explain the details.\n   The next part is the DCAP Data. The structure and the\
    \ size are based\n   on the type of messages carried in the DCAP frame. The DCAP\
    \ data is\n   used to process the frame, but it is optional.\n   The third part\
    \ of the frame is the user data, which is sent by the\n   local system to the\
    \ remote system. The size of this block is variable\n   and is included in the\
    \ frame only when there is data to be sent to\n   the remote system.\n"
- title: 3.2.  Header Format
  contents:
  - "3.2.  Header Format\n   The DCAP header is used to identify the message type\
    \ and the length\n   of the frame. This is a general purpose header used for each\
    \ frame\n   that is passed between the DCAP server and the client. More\n   information\
    \ is needed for frames like CAN_U_REACH and I_CAN_REACH,\n   therefore, it is\
    \ passed to the peer as DCAP data. The structure of\n   the DCAP data depends\
    \ on the type of frames, and will be discussed in\n   detail in later sections.\n\
    \   The DCAP Header is given below:\n             +-------------------------------------------+\n\
    \             | DCAP Packet Header (Each row is one byte) |\n             +===========================================+\n\
    \           0 | Protocol ID / Version Number              |\n             +-------------------------------------------+\n\
    \           1 | Message Type                              |\n             +-------------------------------------------+\n\
    \           2 | Packet Length                             |\n             + -\
    \ - - - - - - - - - - - - - - - - - - - - +\n           3 |                  \
    \                         |\n             +-------------------------------------------+\n\
    \                     Figure 3-2. DCAP Header Format\n   o The Protocol ID uses\
    \ the first 4 bits of this field and is set to\n     \"1000\".\n   o The Version\
    \ Number uses the next 4 bits in this field and is set\n     to \"0001\".\n  \
    \ o The message type is the DCAP message type.\n   o The Total Packet length is\
    \ the length of the packet including the\n     DCAP header, DCAP data and User\
    \ Data. The minimum size of the\n     packet is 4, which is the length of the\
    \ header.\n"
- title: 3.3.  DCAP Messages
  contents:
  - "3.3.  DCAP Messages\n   Most of the DCAP frames are based on the existing DLSw\
    \ frames and\n   corresponding frames have similar names. The information in the\n\
    \   corresponding DCAP and DLSw frames may differ; but the\n   functionalities\
    \ are the same. Thus the DLSw State Machine is used to\n   handle these DCAP frames.\
    \ Some new DCAP frames were created to handle\n   special DCAP functions. For\
    \ example, the new DCAP frames,\n   I_CANNOT_REACH and START_DL_FAILED provide\
    \ negative acknowledgment.\n   The DLSw frames not needed for DCAP, are dropped.\n\
    \   The following table lists and describes all available DCAP messages:\n   DCAP\
    \ Frame Name     Code  Function\n   ---------------     ----  --------\n   CAN_U_REACH\
    \         0x01  Find if the station given is reachable\n   I_CAN_REACH       \
    \  0x02  Positive response to CAN_U_REACH\n   I_CANNOT_REACH      0x03  Negative\
    \ response to CAN_U_REACH\n   START_DL            0x04  Setup session for given\
    \ addresses\n   DL_STARTED          0x05  Session Started\n   START_DL_FAILED\
    \     0x06  Session Start failed\n   XID_FRAME           0x07  XID Frame\n   CONTACT_STN\
    \         0x08  Contact destination to establish SABME\n   STN_CONTACTED     \
    \  0x09  Station contacted - SABME mode set\n   DATA_FRAME          0x0A  Connectionless\
    \ Data Frame for a link\n   INFO_FRAME          0x0B  Connection oriented I-Frame\n\
    \   HALT_DL             0x0C  Halt Data Link session\n   HALT_DL_NOACK       0x0D\
    \  Halt Data Link session without ack\n   DL_HALTED           0x0E  Session Halted\n\
    \   FCM_FRAME           0x0F  Data Link Session Flow Control Message\n   DGRM_FRAME\
    \          0x11  Connectionless Datagram Frame for a circuit\n   CAP_XCHANGE \
    \        0x12  Capabilities Exchange Message\n   CLOSE_PEER_REQUEST  0x13  Disconnect\
    \ Peer Connection Request\n   CLOSE_PEER_RESPONSE 0x14  Disconnect Peer Connection\
    \ Response\n   PEER_TEST_REQ       0x1D  Peer keepalive test request\n   PEER_TEST_RSP\
    \       0x1E  Peer keepalive response\n                         Table 3-1. DCAP\
    \ Frames\n"
- title: 3.4.  DCAP Data formats
  contents:
  - "3.4.  DCAP Data formats\n   The DCAP data is used to carry information required\
    \ for each DCAP\n   frame. This information is used by the Server or the Client\
    \ and it\n   does not contain any user data. The DCAP data frame types are listed\n\
    \   in the following sections. Please note that the sender should set the\n  \
    \ reserved fields to zero and the receiver should ignore these fields.\n"
- title: 3.4.1.  CAN_U_REACH, I_CAN_REACH, and I_CANNOT_REACH Frames
  contents:
  - "3.4.1.  CAN_U_REACH, I_CAN_REACH, and I_CANNOT_REACH Frames\n   These frame types\
    \ are used to locate resources in a network. A\n   CAN_U_REACH frame is sent to\
    \ the server to determine if the resource\n   is reachable. When a server receives\
    \ a CAN_U_REACH frame, it should\n   send out an LLC explorer frame to locate\
    \ the destination specified in\n   the CAN_U_REACH frame. If the destination is\
    \ reachable, the server\n   responds to the client with an I_CAN_REACH frame.\
    \ If the server does\n   not receive a positive acknowledgment within a recommended\
    \ threshold\n   value of 5 seconds, the server should send an LLC explorer to\
    \ locate\n   the destination again. If the server does not receive any response\n\
    \   after sending out 5 explorers (recommended retry value), the\n   destination\
    \ is considered not reachable and an I_CANNOT_REACH frame\n   is sent back to\
    \ the client. The client should decide if retry\n   CAN_U_REACH is necessary after\
    \ the I_CANNOT_REACH frame is received\n   from the server.\n   When a server\
    \ is in the process of searching a destination and\n   receives another I_CAN_REACH\
    \ with the same destination, the server\n   should not send out another LLC explorer\
    \ for that destination.\n   The server should not send the CAN_U_REACH frame to\
    \ the clients in a\n   TCP session. When a server receives an LLC explorer whose\
    \ destination\n   is a known client, the server should respond to it directly.\n\
    \           +---------------+-----------------------+\n           | Field Name\
    \    | Information           |\n           +---------------+-----------------------+\n\
    \           | Message Type  | 0x01, 0x02, or 0x03   |\n           +---------------+-----------------------+\n\
    \           | Packet Length | 0x0C                  |\n           +---------------+-----------------------+\n\
    \    Figure 3-3. CAN_U_REACH, I_CAN_REACH, and I_CANNOT_REACH Header\n       \
    \      +-----------------------------------+\n             | Field Name (Each\
    \ row is one byte) |\n             +===================================+\n   \
    \        0 | Target MAC Address                |\n             + - - - - - - -\
    \ - - - - - - - - - - +\n           1 |                                   |\n\
    \             + - - - - - - - - - - - - - - - - - +\n           2 |          \
    \                         |\n             + - - - - - - - - - - - - - - - - -\
    \ +\n           3 |                                   |\n             + - - -\
    \ - - - - - - - - - - - - - - +\n           4 |                              \
    \     |\n             + - - - - - - - - - - - - - - - - - +\n           5 |  \
    \                                 |\n             +-----------------------------------+\n\
    \           6 | Source SAP                        |\n             +-----------------------------------+\n\
    \           7 | Reserved                          |\n             +-----------------------------------+\n\
    \     Figure 3-4. CAN_U_REACH, I_CAN_REACH, and I_CANNOT_REACH Data\n   The MAC\
    \ Address field carries the MAC address of the target\n   workstation that is\
    \ being searched. This is a six-byte MAC Address\n   field. The same MAC Address\
    \ is returned in the I_CAN_REACH and the\n   I_CANNOT_REACH frames.\n   Byte 6\
    \ is the source SAP. The destination SAP is set to zero when an\n   explorer frame\
    \ is sent to the network.\n"
- title: 3.4.2.  START_DL, DL_STARTED, and START_DL_FAILED Frames
  contents:
  - "3.4.2.  START_DL, DL_STARTED, and START_DL_FAILED Frames\n   These frame types\
    \ are used by DCAP to establish a link station\n   (circuit). The START_DL frame\
    \ is sent directly to the server that\n   responds to the CAN_U_REACH frame. When\
    \ the server receives this\n   frame, it establishes a link station using the\
    \ source and destination\n   addresses and saps provided in the START_DL frame.\
    \ If the circuit\n   establishment is successful, a DL_STARTED frame is sent back\
    \ as a\n   response. If the attempt fails within a recommended value, 5 seconds,\n\
    \   the server should retry again. If the server fails to establish a\n   circuit\
    \ for a recommended retry value, 5 times, a START_DL_FAILED\n   frame should be\
    \ sent back to the client. If the client receives a\n   START_DL_FAILED frame\
    \ from the server, it is up to the client to\n   decide if a START_DL frame needs\
    \ to be sent to the server again.\n   The server can also send START_DL frames\
    \ to clients to establish\n   circuits.\n           +---------------+-----------------------+\n\
    \           | Field Name    | Information           |\n           +---------------+-----------------------+\n\
    \           | Message Type  | 0x04, 0x05, or 0x06   |\n           +---------------+-----------------------+\n\
    \           | Packet Length | 0x18                  |\n           +---------------+-----------------------+\n\
    \      Figure 3-5. START_DL, DL_STARTED, and START_DL_FAILED Header\n        \
    \     +-----------------------------------+\n             | Field Name (Each row\
    \ is one byte) |\n             +===================================+\n       \
    \    0 | Host MAC Address                  |\n             + - - - - - - - - -\
    \ - - - - - - - - +\n           1 |                                   |\n    \
    \         + - - - - - - - - - - - - - - - - - +\n           2 |              \
    \                     |\n             + - - - - - - - - - - - - - - - - - +\n\
    \           3 |                                   |\n             + - - - - -\
    \ - - - - - - - - - - - - +\n           4 |                                  \
    \ |\n             + - - - - - - - - - - - - - - - - - +\n           5 |      \
    \                             |\n             +-----------------------------------+\n\
    \           6 | Host SAP                          |\n             +-----------------------------------+\n\
    \           7 | Client SAP                        |\n             +-----------------------------------+\n\
    \           8 | Origin Session ID                 |\n             +-----------------------------------+\n\
    \           9 |                                   |\n             + - - - - -\
    \ - - - - - - - - - - - - +\n           10|                                  \
    \ |\n             + - - - - - - - - - - - - - - - - - +\n           11|      \
    \                             |\n             +-----------------------------------+\n\
    \           12| Target Session ID                 |\n             + - - - - -\
    \ - - - - - - - - - - - - +\n           13|                                  \
    \ |\n             + - - - - - - - - - - - - - - - - - +\n           14|      \
    \                             |\n             + - - - - - - - - - - - - - - -\
    \ - - +\n           15|                                   |\n             +-----------------------------------+\n\
    \           16| Largest Frame Size                |\n             +-----------------------------------+\n\
    \           17| Initial Window size               |\n             +-----------------------------------+\n\
    \           18| Reserved                          |\n             + - - - - -\
    \ - - - - - - - - - - - - +\n           19|                                  \
    \ |\n             +-----------------------------------+\n   Figure 3-6. START_DL,\
    \ DL_STARTED, and START_DL_FAILED Data\n   The Host MAC address is the address\
    \ of the target station if the\n   session is initiated from the client, or it\
    \ is the address of the\n   originating station if the session is initiated from\
    \ the server.\n   The next two fields are the Host and Client SAPs. Each is one\
    \ byte\n   long. The Host SAP is the SAP used by the station with the Host MAC\n\
    \   address. The Client SAP is the SAP used by the client.\n   The Origin Session\
    \ ID, is the ID of the originating station that\n   initiates the circuit. The\
    \ originating station uses this ID to\n   identify the newly created circuit.\
    \ Before the START_DL frame is sent\n   to the target station, the originating\
    \ station sets up a control\n   block for the circuit. This link station information\
    \ is set because\n   DCAP does not use a three-way handshake for link station\n\
    \   establishment. In the DL_STARTED and the START_DL_FAILED frames, the\n   Origin\
    \ Session ID is returned as received in the START_DL frame.  The\n   Target Session\
    \ ID is set by the target station and returned in the\n   DL_STARTED frame.\n\
    \   The Target Session ID is not valid for the START_DL and the\n   START_DL_FAILED\
    \ frame, and should be treated as Reserved fields. In\n   the DL_STARTED frame,\
    \ it is the session ID that is used to set up\n   this circuit by the target station.\n\
    \   The Largest Frame Size field is used to indicate the maximum frame\n   size\
    \ that can be used by the client. It is valid only when it is set\n   by the server.\
    \ The Largest Frame Size field must be set to zero when\n   a frame is sent by\
    \ the client. Both START_DL and DL_STARTED use the\n   Largest Frame Size field\
    \ and only its rightmost 6 bits are used.  The\n   format is defined in the IEEE\
    \ 802.1D Standard, Annex C, Largest Frame\n   Bits (LF). Bit 3 to bit 5 are base\
    \ bits. Bit 0 to bit 2 are extended\n   bits. The Largest Frame Size field is\
    \ not used in the START_DL_FAILED\n   frame and must be set to zero.\n       \
    \    bit   7    6    5    4    3    2    1    0\n                 r    r    b\
    \    b    b    e    e    e\n                     Figure 3-7. Largest Frame Size\n\
    \   Please note that if the client is a PU 2.1 node, the client should\n   use\
    \ the maximum I-frame size negotiated in the XID3 exchange.\n   The Initial window\
    \ size in the START_DL frame specifies the receive\n   window size on the originating\
    \ side, and the target DCAP station\n   returns its receive window size in the\
    \ DL_STARTED frame. The field is\n   reserved in the START_DL_FAILED frame. The\
    \ usage of the window size\n   is the same as the one used in DLSw.  Please refer\
    \ to RFC 1795 for\n   details.\n   The last two bits are reserved for future use.\
    \ They must be set to\n   zero by the sender and ignored by the receiver.\n"
- title: 3.4.3.  HALT_DL, HALT_DL_NOACK, and DL_HALTED Frames
  contents:
  - "3.4.3.  HALT_DL, HALT_DL_NOACK, and DL_HALTED Frames\n   These frame types are\
    \ used by DCAP to disconnect a link station. A\n   HALT_DL frame is sent directly\
    \ to the remote workstation to indicate\n   that the sender wishes to disconnect\
    \ a session. When the receiver\n   receives this frame, it tears down the session\
    \ that is associated\n   with the Original Session ID and the Target Session ID\
    \ provided in\n   the HALT_DL frame. The receiver should respond with the DL_HALTED\n\
    \   frame.  The DL_HALTED frame should use the same Session ID values as\n   the\
    \ received HALT_DL frame without swapping them. The HALT_DL_NOACK\n   frame is\
    \ used when the response is not required. The TCP session\n   between the client\
    \ and server should remain up after the\n   HALT_DL/DL_HALTED/ HALT_DL_NOACK exchange.\n\
    \           +---------------+-----------------------+\n           | Field Name\
    \    | Information           |\n           +---------------+-----------------------+\n\
    \           | Message Type  | 0x0C, 0x0D, or 0x0E   |\n           +---------------+-----------------------+\n\
    \           | Packet Length | 0x10                  |\n           +---------------+-----------------------+\n\
    \        Figure 3-8. HALT_DL, HALT_DL_NOACK, and DL_HALTED Header\n          \
    \   +-----------------------------------+\n             | Field Name (Each row\
    \ is one byte) |\n             +===================================+\n       \
    \    0 | Sender Session ID                 |\n             + - - - - - - - - -\
    \ - - - - - - - - +\n           1 |                                   |\n    \
    \         + - - - - - - - - - - - - - - - - - +\n           2 |              \
    \                     |\n             + - - - - - - - - - - - - - - - - - +\n\
    \           3 |                                   |\n             +-----------------------------------+\n\
    \           4 | Receiver Session ID               |\n             + - - - - -\
    \ - - - - - - - - - - - - +\n           5 |                                  \
    \ |\n             + - - - - - - - - - - - - - - - - - +\n           6 |      \
    \                             |\n             + - - - - - - - - - - - - - - -\
    \ - - +\n           7 |                                   |\n             +-----------------------------------+\n\
    \           8 | Reserved                          |\n             + - - - - -\
    \ - - - - - - - - - - - - +\n           9 |                                  \
    \ |\n             + - - - - - - - - - - - - - - - - - +\n           10|      \
    \                             |\n             + - - - - - - - - - - - - - - -\
    \ - - +\n           11|                                   |\n             +-----------------------------------+\n\
    \       Figure 3-9. START_DL, DL_STARTED, and START_DL_FAILED Data\n"
- title: 3.4.4.  XID_FRAME, CONTACT_STN, STN_CONTACTED, INFO_FRAME, FCM_FRAME,
  contents:
  - '3.4.4.  XID_FRAME, CONTACT_STN, STN_CONTACTED, INFO_FRAME, FCM_FRAME,

    '
- title: and DGRM_FRAME
  contents:
  - "and DGRM_FRAME\n   These frame types are used to carry the end-to-end data or\
    \ establish\n   a circuit. The Destination Session ID is the Session ID created\
    \ in\n   the START_DL frame or the DL_STARTED frame by the receiver. The usage\n\
    \   of the flow control flag is the same as the one used in DLSw.  Please\n  \
    \ refer to RFC 1795 for details.\n           +---------------+----------------------------+\n\
    \           | Field Name    | Information                |\n           +---------------+----------------------------+\n\
    \           | Message Type  | Based on Message type      |\n           +---------------+----------------------------+\n\
    \           | Packet Length | 0x0C + length of user data |\n           +---------------+----------------------------+\n\
    \                    Figure 3-10. Generic DCAP Header\n             +-----------------------------------+\n\
    \             | Field Name (Each row is one byte) |\n             +===================================+\n\
    \           0 | Destination Session ID            |\n             + - - - - -\
    \ - - - - - - - - - - - - +\n           1 |                                  \
    \ |\n             + - - - - - - - - - - - - - - - - - +\n           2 |      \
    \                             |\n             + - - - - - - - - - - - - - - -\
    \ - - +\n           3 |                                   |\n             +-----------------------------------+\n\
    \           4 | Flow Control Flags                |\n             +-----------------------------------+\n\
    \           5 | Reserved                          |\n             + - - - - -\
    \ - - - - - - - - - - - - +\n           6 |                                  \
    \ |\n             + - - - - - - - - - - - - - - - - - +\n           7 |      \
    \                             |\n             +-----------------------------------+\n\
    \                 Figure 3-11. Generic DCAP Data Format\n"
- title: 3.4.5.  DATA_FRAME
  contents:
  - "3.4.5.  DATA_FRAME\n   This frame type is used to send connectionless SNA and\
    \ NetBIOS\n   Datagram (UI) frames that do not have a link station associated\
    \ with\n   the source and destination MAC/SAP pair. The difference between\n \
    \  DGRM_FRAME and DATA_FRAME is that DGRM_FRAME is used to send UI\n   frames\
    \ received for stations that have a link station opened, whereas\n   DATA_FRAME\
    \ is used for frames with no link station established.\n           +---------------+-----------------------------+\n\
    \           | Field Name    | Information                 |\n           +---------------+-----------------------------+\n\
    \           | Message Type  | 0x0A                        |\n           +---------------+-----------------------------+\n\
    \           | Packet Length | 0x10 + Length of user data  |\n           +---------------+-----------------------------+\n\
    \                     Figure 3-12. DATA_FRAME Header\n             +-----------------------------------+\n\
    \             | Field Name (Each row is one byte) |\n             +===================================+\n\
    \           0 | Host MAC Address                  |\n             + - - - - -\
    \ - - - - - - - - - - - - +\n           1 |                                  \
    \ |\n             + - - - - - - - - - - - - - - - - - +\n           2 |      \
    \                             |\n             + - - - - - - - - - - - - - - -\
    \ - - +\n           3 |                                   |\n             + -\
    \ - - - - - - - - - - - - - - - - +\n           4 |                          \
    \         |\n             + - - - - - - - - - - - - - - - - - +\n           5\
    \ |                                   |\n             +-----------------------------------+\n\
    \           6 | Host SAP                          |\n             +-----------------------------------+\n\
    \           7 | Client SAP                        |\n             +-----------------------------------+\n\
    \           8 | Broadcast Type                    |\n             +-----------------------------------+\n\
    \           9 | Reserved                          |\n             + - - - - -\
    \ - - - - - - - - - - - - +\n           10|                                  \
    \ |\n             + - - - - - - - - - - - - - - - - - +\n           11|      \
    \                             |\n             +-----------------------------------+\n\
    \                  Figure 3-13. DATA_FRAME Data Format\n   The definition of the\
    \ first 8 bytes is the same as the START_DL\n   frame. The Broadcast Type field\
    \ indicates the type of broadcast\n   frames in use; Single Route Broadcast, All\
    \ Route Broadcast, or\n   Directed. The target side will use the same broadcast\
    \ type. In the\n   case of Directed frame, if the RIF information is known, the\
    \ target\n   peer can send a directed frame. If not, a Single Route Broadcast\n\
    \   frame is sent.\n"
- title: 3.4.6.  CAP_XCHANGE Frame
  contents:
  - "3.4.6.  CAP_XCHANGE Frame\n   In DCAP, the capability exchange frame is used\
    \ to exchange the\n   capability information between a client and a server. CAP_XCHANGE\n\
    \   frames are exchanged between a client and a server as soon as the TCP\n  \
    \ session is established. The capability exchange must be completed\n   before\
    \ the other frame types can be sent. Once the capability\n   exchange is done,\
    \ CAP_XCHANGE frame should not be used again.\n   CAP_XCHANGE frame contains the\
    \ clients MAC address, if a client has\n   one. If it does not, then the MAC address\
    \ field must be set to zero.\n   When the DCAP server receives the CAP_XCHANGE\
    \ frame, it should cache\n   the MAC address if it is non zero. The DCAP server\
    \ also verifies that\n   the MAC address is unique. The server should return a\
    \ CAP_XCHANGE\n   response frame with the MAC address supplied by the client if\
    \ the MAC\n   address is accepted. If a client does not have its own MAC address,\n\
    \   the server should assign a MAC address to the client and put that\n   address\
    \ in the CAP_XCHANGE command frame.\n   A client should record the new MAC address\
    \ assigned by the server and\n   return a response with the assigned MAC address.\
    \ If the client cannot\n   accept the assigned MAC address, another CAP_XCHANGE\
    \ command with the\n   MAC address field set to zero should be sent to the server.\
    \ The\n   server should allocate a new MAC address for this client.\n   During\
    \ the capability exchange, both the client and the server can\n   send command\
    \ frames. The process stops when either side sends a\n   CAP_XCHANGE response\
    \ frame. When the response frame is sent, the MAC\n   address in the CAP_XCHANGE\
    \ frame should be the same as the one in the\n   previous received command. The\
    \ sender of the CAP_XCHANGE response\n   agrees to use the MAC address defined\
    \ in the previous command.\n   The number of CAP_XCHANGE frames that need to be\
    \ exchanged is\n   determined by the client and the server independently. When\
    \ the\n   number of exchange frames has exceeded the pre-defined number set by\n\
    \   either the server or the client, the session should be brought down.\n   The\
    \ flag is used to show the capability of the sender. The following\n   list shows\
    \ the valid flags:\n   0x01 NetBIOS support. If a client sets this bit on, the\
    \ server will\n        pass all NetBIOS explorers to this client. If this bit\
    \ is not\n        set, only SNA traffic will be sent to this client.\n   0x02\
    \ TCP Listen Mode support. If a client supports TCP listen mode,\n        the\
    \ server will keep the client's MAC and IP addresses even\n        after the TCP\
    \ session is down. The cached information will be\n        used for server to\
    \ connect out. If a client does not support\n        TCP listen mode, the cache\
    \ will be deleted as soon as the TCP\n        session is down.\n   0x04 Command/Response.\
    \ If this bit is set, it is a command,\n        otherwise, it is a response.\n\
    \   The values 0x01 and 0x02 are used only by the client. When a server\n   sends\
    \ the command/response to a client, the server does not return\n   these values.\n\
    \   Starting with the Reserved field, implementers can optionally\n   implement\
    \ the Capability Exchange Control Vector. Each Capability\n   Exchange Control\
    \ Vector consists of three fields: Length (1 byte),\n   Type (1 byte), and Data\
    \ (Length - 2 bytes). Two types of Control\n   Vectors are defined: SAP_LIST and\
    \ VENDOR_CODE (described below). To\n   ensure compatibility, implementers should\
    \ ignore the unknown Control\n   Vectors instead of treating them as errors.\n\
    \   0x01 SAP_LIST. Length: 2+n bytes, where n ranges from 1 to 16.\n        This\
    \ control vector lists the SAPs that the client can support.\n        The maximum\
    \ number of SAPs a client can define is 16. Therefore,\n        the length of\
    \ this Control Vector ranges from 3 to 18. If the\n        SAP_LIST is not specified\
    \ in the capability exchange, the server\n        assumes that the client can\
    \ support all the SAP values. For\n        example, if a client can only support\
    \ SAP 4 and 8, then the\n        following Control Vectors should be sent: \"\
    0x04, 0x01, 0x04,\n        0x08\". The first byte indicates the length of 4. The\
    \ second byte\n        indicates the control vector type of SAP_LIST. The last\
    \ two\n        bytes indicate the supported SAP values; 0x04 and 0x08. This\n\
    \        Control Vector is used only by the client. If the server accepts\n  \
    \      this Control Vector, it must return the same Control Vector to\n      \
    \  the client.\n   0x02 VENDOR_CODE. Length: 3 bytes.\n        Each vendor is\
    \ assigned a vendor code that identifies the\n        vendor. This Control Vector\
    \ does not require a response.\n   After the receiver responds to a Control Vector,\
    \ if the capability\n   exchange is not done, the sender does not have to send\
    \ the same\n   Control Vector again.\n           +---------------+-----------------------+\n\
    \           | Field Name    | Information           |\n           +---------------+-----------------------+\n\
    \           | Message Type  | 0x12                  |\n           +---------------+-----------------------+\n\
    \           | Packet Length | 0x1C                  |\n           +---------------+-----------------------+\n\
    \                    Figure 3-14. CAP_XCHANGE Header\n             +-----------------------------------+\n\
    \             | Field Name (Each row is one byte) |\n             +===================================+\n\
    \           0 | MAC Address                       |\n             + - - - - -\
    \ - - - - - - - - - - - - +\n           1 |                                  \
    \ |\n             + - - - - - - - - - - - - - - - - - +\n           2 |      \
    \                             |\n             + - - - - - - - - - - - - - - -\
    \ - - +\n           3 |                                   |\n             + -\
    \ - - - - - - - - - - - - - - - - +\n           4 |                          \
    \         |\n             + - - - - - - - - - - - - - - - - - +\n           5\
    \ |                                   |\n             +-----------------------------------+\n\
    \           6 | Flag                              |\n             +-----------------------------------+\n\
    \           7 | Reserved                          |\n             +-----------------------------------+\n\
    \                  Figure 3-15. CAP_XCHANGE Data Format\n"
- title: 3.4.7.  CLOSE_PEER_REQ Frames
  contents:
  - "3.4.7.  CLOSE_PEER_REQ Frames\n   This frame is used for peer connection management\
    \ and contains a\n   reason code field. The following list describes the valid\
    \ reason\n   codes:\n   0x01 System shutdown. This indicates shutdown in progress.\n\
    \   0x02 Suspend. This code is used when there is no traffic between the\n   \
    \     server and the client, and the server or the client wishes to\n        suspend\
    \ the TCP session. When the TCP session is suspended, all\n        circuits should\
    \ remain intact. The TCP session should be re-\n        established when new user\
    \ data needs to be sent. When the TCP\n        session is re-established, there\
    \ is no need to send the\n        CAP_XCHANGE frame again.\n   0x03 No MAC address\
    \ available. This code is sent by the server when\n        there is no MAC address\
    \ is available from the MAC address pool.\n           +---------------+-----------------------+\n\
    \           | Field Name    | Information           |\n           +---------------+-----------------------+\n\
    \           | Message Type  | 0x13                  |\n           +---------------+-----------------------+\n\
    \           | Packet Length | 0x08                  |\n           +---------------+-----------------------+\n\
    \                   Figure 3-16. CLOSE_PEER_REQ Header\n             +-----------------------------------+\n\
    \             | Field Name (Each row is one byte) |\n             +===================================+\n\
    \           0 | Reason Code                       |\n             +-----------------------------------+\n\
    \           1 | Reserved                          |\n             + - - - - -\
    \ - - - - - - - - - - - - +\n           2 |                                  \
    \ |\n             + - - - - - - - - - - - - - - - - - +\n           3 |      \
    \                             |\n             +-----------------------------------+\n\
    \                Figure 3-17. CLOSE_PEER_REQ Data Format\n"
- title: 3.4.8.  CLOSE_PEER_RSP, PEER_TEST_REQ, and PEER_TEST_RSP Frames
  contents:
  - "3.4.8.  CLOSE_PEER_RSP, PEER_TEST_REQ, and PEER_TEST_RSP Frames\n   These three\
    \ frames are used for peer connection management. There is\n   no data associated\
    \ with them.\n   o CLOSE_PEER_RSP\n     CLOSE_PEER_RSP is the response for CLOSE_PEER_REQ.\n\
    \   o PEER_TEST_REQ and PEER_TEST_RSP\n     PEER_TEST_REQ and PEER_TEST_RSP are\
    \ used for peer level keepalive.\n     Implementing PEER_TEST_REQ is optional,\
    \ but PEER_TEST_RSP must be\n     implemented to respond to the PEER_TEST_REQ\
    \ frame. When a\n     PEER_TEST_REQ frame is sent to the remote station, the sender\n\
    \     expects to receive the PEER_TEST_RSP frame in a predefined time\n     interval\
    \ (the recommended value is 60 seconds). If the\n     PEER_TEST_RSP frame is not\
    \ received in the predefined time\n     interval, the sender can send the PEER_TEST_REQ\
    \ frame again. If a\n     predefined number of PEER_TEST_REQ frames is sent to\
    \ the remote\n     station, but no PEER_TEST_RSP frame is received (the recommended\n\
    \     number is 3), the sender should close the TCP session with this\n     remote\
    \ station and terminate all associated circuits.\n           +---------------+-----------------------+\n\
    \           | Field Name    | Information           |\n           +---------------+-----------------------+\n\
    \           | Message Type  | 0x14, 0x1D, or 0x1E   |\n           +---------------+-----------------------+\n\
    \           | Packet Length | 0x04                  |\n           +---------------+-----------------------+\n\
    \   Figure 3-18. CLOSE_PEER_RSP, PEER_TEST_REQ, and PEER_TEST_RSP DCAP\n"
- title: 4.  Protocol Flow Diagram
  contents:
  - "4.  Protocol Flow Diagram\n   The following diagram shows a normal session start\
    \ up/tear down\n   sequence between a client and a server.\n                 \
    \             +-----------+                +-------+\n       +-----------+  Token\
    \   | DLSw/DCAP |                | DCAP  |\n       | Mainframe +- Ring ---+  \
    \ Router  +-- ip backbone--+ Client|\n       +-----------+          +-----------+\
    \                +-------+\n                                             TCP Session\
    \ Up\n                                             <-------------\n          \
    \                                   CAP_EXCHANGE (cmd)\n                     \
    \                        <-------------\n                                    \
    \         CAP_EXCHANGE (cmd)\n                                             ------------->\n\
    \                                             CAP_EXCHANGE (rsp)\n           \
    \                                  ------------->\n                     TEST(P)\
    \                 CAN_U_REACH\n                    <--------                <-------------\n\
    \                     TEST(F)                 I_CAN_REACH\n                  \
    \  -------->                ------------->\n                                 \
    \            START_DL\n                                             <-------------\n\
    \                                             DL_STARTED\n                   \
    \                          ------------->\n                     XID(P)       \
    \           XID_FRAME\n                    <--------                <-------------\n\
    \                     XID(F)                  XID_FRAME\n                    -------->\
    \                ------------->\n                     XID(P)                 \
    \ XID_FRAME\n                    <--------                <-------------\n   \
    \                  SABME                   CONTACT_STN\n                    -------->\
    \                ------------->\n                     UA                     \
    \ STN_CONTACTED\n                    <--------                <-------------\n\
    \                     I FRAME                 INFO_FRAME\n                   \
    \ <--------                <-------------\n                     I FRAME      \
    \           INFO_FRAME\n                    -------->                ------------->\n\
    \                     DISC                    HALT_DL\n                    <--------\
    \                <-------------\n                     UA                     \
    \ DL_HALTED\n                    -------->                ------------->\n   \
    \                                          CLOSE_PEER_REQ\n                  \
    \                           <-------------\n                                 \
    \            CLOSE_PEER_RSP\n                                             ------------->\n\
    \                                             TCP session down\n             \
    \                                <-------------\n"
- title: 5.  Acknowledgments
  contents:
  - "5.  Acknowledgments\n   The authors wish to express thanks to Rodger Erickson\
    \ of Wall Data,\n   Inc. for his helpful comments and suggestions.\n"
- title: 6.  References
  contents:
  - "6.  References\n   [1] AIW DLSw Related Interest Group, RFC 1795,\n       \"\
    DLSw: Switch-to-Switch Protocol\", April 1995\n   [2] IBM Token Ring Network Architecture\
    \ Reference\n       SC30-3374-02, September 1989.\n   [3] IBM LAN Technical Reference\
    \ IEEE 802.2 and NETBIOS Application\n       Program Interfaces SC30-3587-00,\
    \ December 1993.\n   [4] ISO 8802-2/IEEE Std 802.1D International Standard.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Steve T. Chiang\n   InterWorks Business Unit\n   Cisco\
    \ Systems, Inc.\n   170 Tasman Drive\n   San Jose, CA 95134\n   Phone: (408) 526-5189\n\
    \   EMail: schiang@cisco.com\n   Joseph S. Lee\n   InterWorks Business Unit\n\
    \   Cisco Systems, Inc.\n   170 Tasman Drive\n   San Jose, CA 95134\n   Phone:\
    \ (408) 526-5232\n   EMail: jolee@cisco.com\n   Hideaki Yasuda\n   System Product\
    \ Center\n   Network Products Department\n   Network Software Products Section\
    \ B\n   Mitsubishi Electric Corp.\n   Information Systems Engineering Center\n\
    \   325, Kamimachiya Kamakura Kanagawa 247, Japan\n   Phone: +81-467-47-2120\n\
    \   EMail: yasuda@eme068.cow.melco.co.jp\n"
