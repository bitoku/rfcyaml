- contents:
  - '             Rules for NFSv4 Extensions and Minor Versions

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This document describes the rules relating to the extension of the\n
    \  NFSv4 family of protocols.  It covers the creation of minor versions,\n   the
    addition of optional features to existing minor versions, and the\n   correction
    of flaws in features already published as Proposed\n   Standards.  The rules relating
    to the construction of minor versions\n   and the interaction of minor version
    implementations that appear in\n   this document supersede the minor versioning
    rules in RFC 5661 and\n   other RFCs defining minor versions.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    7841.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc8178.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2017 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .
    . . . . .   3\n   2.  Terminology . . . . . . . . . . . . . . . . . . . . . .
    . . .   3\n     2.1.  Use of Keywords Defined in RFCs 2119 and 8174 . . . . .
    .   4\n     2.2.  Use of Feature Statuses . . . . . . . . . . . . . . . . .   4\n
    \    2.3.  NFSv4 Versions  . . . . . . . . . . . . . . . . . . . . .   5\n   3.
    \ Consolidation of Extension Rules  . . . . . . . . . . . . . .   6\n   4.  XDR
    Considerations  . . . . . . . . . . . . . . . . . . . . .   7\n     4.1.  XDR
    Extension . . . . . . . . . . . . . . . . . . . . . .   8\n     4.2.  Rules for
    XDR Extension within NFSv4  . . . . . . . . . .   8\n     4.3.  Handling of Protocol
    Elements by Responders . . . . . . .   9\n     4.4.  Inter-version Interoperability
    \ . . . . . . . . . . . . .  11\n       4.4.1.  Requirements for Knowledge of
    Protocol Elements . . .  11\n       4.4.2.  Establishing Interoperability . .
    . . . . . . . . . .  12\n       4.4.3.  Determining Knowledge of Protocol Elements
    \ . . . . .  14\n     4.5.  XDR Overlay . . . . . . . . . . . . . . . . . . .
    . . . .  15\n   5.  Other NFSv4 Protocol Changes  . . . . . . . . . . . . . .
    . .  15\n     5.1.  Field Interpretation and Use  . . . . . . . . . . . . . .
    \ 15\n     5.2.  Behavioral Changes  . . . . . . . . . . . . . . . . . . .  16\n
    \  6.  Extending Existing Minor Versions . . . . . . . . . . . . . .  17\n   7.
    \ Minor Versions  . . . . . . . . . . . . . . . . . . . . . . .  18\n     7.1.
    \ Creation of New Minor Versions  . . . . . . . . . . . . .  18\n   8.  Minor
    Version Interaction Rules . . . . . . . . . . . . . . .  18\n     8.1.  Minor
    Version Identifier Transfer Issues  . . . . . . . .  19\n     8.2.  Minor Version
    Compatibility . . . . . . . . . . . . . . .  19\n   9.  Correction of Existing
    Minor Versions and Features  . . . . .  20\n     9.1.  XDR Changes to Implement
    Protocol Corrections . . . . . .  21\n     9.2.  XDR Corrections to OPTIONAL Features
    \ . . . . . . . . . .  21\n     9.3.  XDR Corrections to REQUIRED Features  .
    . . . . . . . . .  22\n     9.4.  Addressing XDR Corrections in Later Minor Versions
    \ . . .  24\n   10. Security Considerations . . . . . . . . . . . . . . . . .
    . .  24\n   11. IANA Considerations . . . . . . . . . . . . . . . . . . . . .
    \ 25\n   12. References  . . . . . . . . . . . . . . . . . . . . . . . . .  25\n
    \    12.1.  Normative References . . . . . . . . . . . . . . . . . .  25\n     12.2.
    \ Informative References . . . . . . . . . . . . . . . . .  25\n   Acknowledgements
    \ . . . . . . . . . . . . . . . . . . . . . . . .  25\n   Author's Address  .
    . . . . . . . . . . . . . . . . . . . . . . .  26\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   To address the requirement for an NFS protocol that can
    evolve as the\n   need arises, the Network File System (NFS) version 4 (NFSv4)
    protocol\n   provides a framework to allow for future changes via the creation
    of\n   new protocol versions, including minor versions and certain forms of\n
    \  modification of existing minor versions.  The extension rules\n   contained
    in this document allow extensions and other changes to be\n   implemented in a
    way that maintains compatibility with existing\n   clients and servers.\n   Previously,
    all protocol changes had been part of new minor versions.\n   The COMPOUND procedure
    (see Section 14.2 of [RFC7530]) specifies the\n   minor version being used by
    the client in making requests.  The\n   CB_COMPOUND procedure (see Section 15.2
    of [RFC7530]) specifies the\n   minor version being used by the server on callback
    requests.\n   Creation of a new minor version is no longer the only way in which\n
    \  protocol changes may be made.  Optional features may be added as\n   extensions
    and protocol corrections can be proposed, specified, and\n   implemented within
    the context of a single minor version.  Creation\n   of new minor versions remains
    available when needed.\n   The goal of allowing extensions within the context
    of a minor version\n   is to provide more implementation flexibility while preserving\n
    \  interoperability on protocol upgrade.  As described in Section 4.4, a\n   client
    and server may each choose a subset of available extensions.\n   Each party can
    successfully use a subset of protocol elements that\n   are known to and supported
    by both the client and server.  Support\n   for this common subset is not affected
    by the fact that extensions\n   outside this common subset may be supported by
    the server or\n   potentially used by the client.\n"
  title: 1.  Introduction
- contents:
  - "2.  Terminology\n   A basic familiarity with NFSv4 terminology is assumed in
    this\n   document and the reader is pointed to [RFC7530].\n   In this document,
    the term \"version\" is not limited to minor\n   versions.  When minor versions
    are meant, the term \"minor version\" is\n   used explicitly.  For more discussion
    of this and related terms, see\n   Section 2.3.\n   A \"feature package\" is a
    set of features that are defined together,\n   either as part of a minor version
    or as part of the same protocol\n   extension.\n"
  - contents:
    - "2.1.  Use of Keywords Defined in RFCs 2119 and 8174\n   The keywords defined
      by [RFC2119] [RFC8174] have special meanings\n   that this document intends
      to adhere to.  However, due to the nature\n   of this document and some special
      circumstances, there are some\n   complexities to take note of:\n   o  Where
      this document does not directly specify implementation\n      requirements,
      use of these capitalized terms is often not\n      appropriate since the guidance
      given in this document does not\n      directly affect interoperability.\n   o
      \ In this document, what authors of RFCs defining features and minor\n      versions
      need to do is stated without these specialized terms.\n      Although it is
      necessary to follow this guidance to provide\n      successful NFSv4 protocol
      extension, that sort of necessity is not\n      of the sort defined as applicable
      to the use of the keywords\n      defined in [RFC2119] [RFC8174].\n      The
      fact that these capitalized terms are not used should not be\n      interpreted
      as indicating that this guidance does not need to be\n      followed or is somehow
      not important.\n   o  In speaking of the possible statuses of features and feature\n
      \     elements, the terms \"OPTIONAL\" and \"REQUIRED\" are used.  For\n      further
      discussion, see Section 2.2.\n   o  When one of these upper-case keywords defined
      in [RFC2119]\n      [RFC8174] is used in this document, it is in the context
      of a rule\n      directed to an implementer of NFSv4 minor versions, the status
      of\n      a feature or protocol element, or in a quotation, sometimes\n      indirect,
      from another document.\n"
    title: 2.1.  Use of Keywords Defined in RFCs 2119 and 8174
  - contents:
    - "2.2.  Use of Feature Statuses\n   There has been some confusion during the
      history of NFSv4 about the\n   correct use of these terms, and instances in
      which the keywords\n   defined in [RFC2119] [RFC8174] were used in ways that
      appear to be at\n   variance with the definitions in that document.\n   o  In
      [RFC3530], the lower-case terms \"optional\", \"recommended\", and\n      \"required\"
      were used as feature statuses, Later, in [RFC5661] and\n      [RFC7530], the
      corresponding upper-case keywords were used.  It is\n      not clear why this
      change was made.\n   o  In the case of \"RECOMMENDED\", its use as a feature
      status is\n      inconsistent with [RFC2119] [RFC8174] and it will not be used
      for\n      this purpose in this document.\n   o  The word \"RECOMMENDED\" to
      denote the status of attributes in\n      [RFC7530] and [RFC5661] raises similar
      issues.  This has been\n      recognized in [RFC7530] with regard to NFSV4.0,
      although the\n      situation with regard to NFSv4.1 remains unresolved.\n   In
      this document, the keywords \"OPTIONAL\" and \"REQUIRED\" and the\n   phrase
      \"mandatory to not implement\" are used to denote the status of\n   features
      within a given minor version.  In using these terms, RFCs\n   that specify the
      status of features inform:\n   o  client implementations whether they need to
      deal with the absence\n      of support for these features.\n   o  server implementations
      whether they need to provide support for\n      these features.\n"
    title: 2.2.  Use of Feature Statuses
  - contents:
    - "2.3.  NFSv4 Versions\n   The term \"version\" denotes any valid protocol variant
      constructed\n   according to the rules in this document.  It includes minor
      versions,\n   but there are situations that allow multiple variant versions
      to be\n   associated with and coexist within a single minor version:\n   o  When
      there are feature specification documents published as\n      Proposed Standards
      extending a given minor version, then the\n      protocol defined by the minor
      version specification document, when\n      combined with any subset (not necessarily
      a proper subset) of the\n      feature specification documents, is a valid NFSv4
      version variant\n      that is part of the minor version in question.\n   o
      \ When there are protocol corrections published that update a given\n      minor
      version, each set of published updates, up to the date of\n      publication
      of the update, is a valid NFSv4 version variant that\n      is part of the minor
      version in question.\n   Because of the above, there can be multiple version
      variants that are\n   part of a given minor version.  Two of these are worthy
      of special\n   terms:\n   o  The term \"base minor version\" denotes the version
      variant that\n      corresponds to the minor version as originally defined,
      including\n      all protocol elements specified in the minor version definition\n
      \     document but not incorporating any extensions or protocol\n      corrections
      published after that original definition.\n   o  At any given time, the term
      \"current minor version\" denotes the\n      minor version variant including
      all extensions of and corrections\n      to the minor version made by Standards
      Track documents published\n      up to that time.\n   Each client and server
      that implements a specific minor version will\n   implement some particular
      variant of that minor version.  Each\n   variant is a subset of the current
      minor version and a superset of\n   the base minor version.  When the term \"minor
      version\" is used\n   without either of these qualifiers, it should refer to
      something that\n   is true of all variants within that minor version.  For example,
      in\n   the case of a minor version that has not had a protocol correction,\n
      \  one may refer to the set of REQUIRED features for that minor version\n   since
      it is the same for all variants within the minor version.  See\n   Section 9
      for a discussion of correcting an existing minor version.\n"
    title: 2.3.  NFSv4 Versions
  title: 2.  Terminology
- contents:
  - "3.  Consolidation of Extension Rules\n   In the past, the only existing extension
    rules were the minor\n   versioning rules that were being maintained and specified
    in the\n   Standards Track RFCs, which defined the individual minor versions.\n
    \  In the past, these minor versioning rules were modified on an ad hoc\n   basis
    for each new minor version.\n   More recently, minor versioning rules were specified
    in [RFC5661]\n   while modifications to those rules were allowed in subsequent
    minor\n   versions.\n   This document defines a set of extension rules, including
    rules for\n   minor version construction.  These rules apply to all future changes\n
    \  to the NFSv4 protocol.  The rules are subject to change but any such\n   change
    should be part of a Standards Track RFC obsoleting or updating\n   this document.\n
    \  Rather than a single list of extension rules, as was done in the\n   minor
    versioning rules in [RFC5661], this document defines multiple\n   sets of rules
    that deal with the various forms of protocol change\n   provided for in the NFSv4
    extension framework.\n   o  The kinds of changes in External Data Representation
    (XDR)\n      definitions that may be made to extend NFSv4 are addressed in the\n
    \     rules in Section 4.2.\n   o  Minor version construction, including rules
    applicable to changes\n      that cannot be made in extensions to existing minor
    versions are\n      addressed in Section 7.1.\n   o  Minor version interaction
    rules are discussed in Sections 8.1 and\n      8.2.\n   This document supersedes
    minor versioning rules appearing in the\n   minor version specification RFCs,
    including those in [RFC5661] and\n   also the modification to those rules mentioned
    in [RFC7862].  As a\n   result, potential conflicts among documents should be
    addressed as\n   follows:\n   o  The specification of the actual protocols for
    minor versions\n      previously published as Proposed Standards take precedence
    over\n      minor versioning rules in either this document or in the minor\n      version
    specification RFCs.  In other words, if the transition\n      from version A to
    version B violates a minor versioning rule, the\n      version B protocol stays
    as it is.\n   o  Since minor versioning rules #11 and #13 from [RFC5661] deal
    with\n      the interactions between multiple minor versions, the situation is\n
    \     more complicated.  See Section 8 for a discussion of these issues,\n      including
    how potential conflicts between rules are to be\n      resolved.\n   o  Otherwise,
    any conflict between the extension rules in this\n      document and those in
    minor version specification RFCs are to be\n      resolved based on the treatment
    in this document.  In particular,\n      corrections may be made as specified
    in Section 9 for all\n      previously specified minor versions, and the extensibility
    of\n      previously specified minor versions is to be handled in accord\n      with
    Section 6.\n   Future minor version specification documents should avoid specifying\n
    \  rules relating to minor versioning and reference this document in\n   connection
    with rules for NFSv4 extension.\n"
  title: 3.  Consolidation of Extension Rules
- contents:
  - "4.  XDR Considerations\n   As an extensible XDR-based protocol, NFSv4 has to
    ensure inter-\n   version compatibility in situations in which the client and
    server\n   use different XDR descriptions.  For example, the client and server\n
    \  may implement different variants of the same minor version, in that\n   they
    each might add different sets of extensions to the base minor\n   version.\n   The
    XDR extension paradigm, discussed in Section 4.1, assures that\n   these descriptions
    are compatible, with clients and servers able to\n   determine and use those portions
    of the protocol that they both share\n   according to the method described in
    Section 4.4.2.\n"
  - contents:
    - "4.1.  XDR Extension\n   When an NFSv4 version change requires a modification
      to the protocol\n   XDR, this is effected within a framework based on the idea
      of XDR\n   extension.  This is in contrast to transitions between major NFS\n
      \  versions (including that between NFSv3 and NFSv4.0) in which the XDR\n   for
      one version was replaced by a different XDR for a newer version.\n   The XDR
      extension approach allows an XDR description to be extended\n   in a way that
      retains the structure of all previously valid messages.\n   If a base XDR description
      is extended to create a second XDR\n   description, the following will be true
      for the second description to\n   be a valid extension of the first:\n   o  The
      set of valid messages described by the extended definition is\n      a superset
      of that described by the first.\n   o  Each message within the set of valid
      messages described by the\n      base definition is recognized as having exactly
      the same\n      structure/interpretation using the extended definition.\n   o
      \ Each message within the set of messages described as valid by the\n      extended
      definition but not the base definition must be\n      recognized, using the
      base definition, as part of an unknown\n      extension.\n   The use of XDR
      extension can facilitate compatibility between\n   different versions of the
      NFSv4 protocol.  When XDR extension is used\n   to implement OPTIONAL features,
      the greatest degree of inter-version\n   compatibility is obtained.  In this
      case, as long as the rules in\n   Section 6 are followed, no change in minor
      version number is needed\n   and the extension may be effected in the context
      of a single minor\n   version.\n"
    title: 4.1.  XDR Extension
  - contents:
    - "4.2.  Rules for XDR Extension within NFSv4\n   In the context of NFSv4, given
      the central role of COMPOUND and\n   CB_COMPOUND, addition of new RPC procedures
      is not allowed and the\n   enumeration of operations and callback operations
      have a special\n   role.\n   The following XDR extensions, by their nature,
      affect both messages\n   sent by requesters (i.e., requests and callbacks),
      and responders\n   (i.e., replies and callback replies).\n   o  Addition of
      previously unspecified operation codes, within the\n      framework established
      by COMPOUND and CB_COMPOUND.  These extend\n      the appropriate enumeration
      and the corresponding switches devoted\n      to requests and responses for
      the associated direction of\n      operation.\n   o  Addition of previously
      unspecified attributes.  These add\n      additional numeric constants that
      define each attribute's bit\n      position within the attribute bitmap, together
      with XDR typedefs\n      that specify the attributes' format within the nominally
      opaque\n      arrays specifying sets of attributes.\n   Other sorts of changes
      will generally affect one of requests,\n   replies, callback, or callback replies.
      \ Although all are valid XDR\n   extensions, the messages that are affected
      may determine whether the\n   extension requires a new minor version (see Section
      7) or can be made\n   as an extension within an existing minor version (see
      Section 6).\n   o  Addition of new, previously unused, values to existing enums.\n
      \  o  Addition of previously unassigned bit values to a flag word.\n   o  Addition
      of new cases to existing switches, provided that the\n      existing switch
      did not contain a default case.\n   None of the following is allowed to happen:\n
      \  o  Any change to the structure of existing requests or replies other\n      than
      those listed above.\n   o  Addition of previously unspecified RPC procedures
      for either the\n      NFSv4 program or the callback program.\n   o  Deletion
      of existing RPC procedures, operation codes, enum values,\n      flag bit values,
      and switch cases.  Note that changes may be made\n      to define use of any
      of these as causing an error, as long as the\n      XDR is unaffected.  Similarly,
      none of these items may be reused\n      for a new purpose.\n"
    title: 4.2.  Rules for XDR Extension within NFSv4
  - contents:
    - "4.3.  Handling of Protocol Elements by Responders\n   Implementations handle
      protocol elements received in requests and\n   callbacks in one of three ways.
      \ Which of the following ways are\n   valid depends on the status of the protocol
      element in the variant\n   being implemented:\n   o  The protocol element is
      not a part of definition of the variant in\n      question and so is \"unknown\".
      \ The responder, when it does not\n      report an RPC XDR decode error, reports
      an error indicative of the\n      element not being defined in the XDR such
      as NFS4ERR_OP_ILLEGAL,\n      NFS4ERR_BADXDR, or NFS4ERR_INVAL.  See Section
      4.4.3 for details.\n   o  The protocol element is a known part of the variant
      but is not\n      supported by the particular implementation.  The responder
      reports\n      an error indicative of the element being recognized as one which\n
      \     is not supported such as NFS4ERR_NOTSUPP, NFS4ERR_UNION_NOTSUPP,\n      or
      NFS4ERR_ATTRNOTSUPP.\n   o  The protocol element is a known part of the variant
      that is\n      supported by the particular implementation.  The responder reports\n
      \     success or an error other than the special ones discussed above.\n   Which
      of these are validly returned by the responder depends on the\n   status of
      the protocol element in the minor version specified in the\n   COMPOUND or CB_COMPOUND.
      \ The possibilities that can exist when\n   dealing with minor versions that
      have not been subject to corrections\n   are listed below.  See Sections 9.1
      and 9.3 for a discussion of the\n   effects of protocol correction.\n   o  The
      protocol element is not known in the minor version.  In this\n      case, all
      implementations of the minor version MUST indicate that\n      the protocol
      element is not known.\n   o  The protocol element is part of a feature specified
      as mandatory\n      to not implement in the minor version.  In this case as
      well, all\n      implementations of the minor version MUST indicate that the\n
      \     protocol element is not known.\n   o  The protocol element is defined
      as part of the current variant of\n      the minor version but is not part of
      the corresponding base\n      variant.  In this case, the requester can encounter
      situations in\n      which the protocol element is either not known to the responder,\n
      \     is known to but not supported by the responder, or is both known\n      to
      and supported by the responder.\n   o  The protocol element is defined as an
      OPTIONAL part of the base\n      minor version.  In this case, the requester
      can expect the\n      protocol element to be known but must deal with cases
      in which it\n      is supported or is not supported.\n   o  The protocol element
      is defined as a REQUIRED part of the base\n      minor version.  In this case,
      the requester can expect the\n      protocol element to be both known and supported
      by the responder.\n   The listing of possibilities above does not mean that
      a requester\n   always needs to be prepared for all such possibilities.  Often,\n
      \  depending on the scope of the feature of which the protocol element\n   is
      a part, handling of a previous request using the same or related\n   protocol
      elements will allow the requester to be sure that certain of\n   these possibilities
      cannot occur.\n   Requesters, typically clients, may test for knowledge of,
      or support\n   for, protocol elements as part of connection establishment.  This
      may\n   allow the requester to be aware of a responder's lack of knowledge of\n
      \  or support for problematic requests before they are actually used to\n   affect
      user requests.\n"
    title: 4.3.  Handling of Protocol Elements by Responders
  - contents:
    - "4.4.  Inter-version Interoperability\n   Because of NFSv4's use of XDR extension,
      any communicating client and\n   server versions have XDR definitions such that
      each is a valid\n   extension of a third version.  Once that version is determined,
      it\n   may be used by both client and server to communicate.  Each party can\n
      \  successfully use a subset of protocol elements that are both known to\n   and
      supported by both parties.\n"
    - contents:
      - "4.4.1.  Requirements for Knowledge of Protocol Elements\n   With regard to
        requirements for knowledge of protocol elements, the\n   following rules apply.
        \ These rules are the result of the use of the\n   XDR extension paradigm
        combined with the way in which extensions are\n   incorporated in existing
        minor versions (for details, see Section 6).\n   o  Any protocol element defined
        as part of the base variant of a\n      particular minor version is required
        to be known by that minor\n      version.  This occurs whether the specification
        happens in the\n      body of the minor definition document or is in a feature\n
        \     definition document that is made part of the minor version by\n      being
        normatively referenced by the minor version definition\n      document.\n
        \  o  Any protocol element required to be known in a given minor version\n
        \     is required to be known in subsequent minor versions, unless and\n      until
        a minor version has made that protocol element as mandatory\n      to not
        implement.\n   o  When a protocol element is defined as part of an extension
        to an\n      extensible minor version, it is not required to be known in that\n
        \     minor version but is required to be known by the next minor\n      version.
        \ In the earlier minor version, it might not be defined in\n      the XDR
        definition document, while in the later version it needs\n      to be defined
        in the XDR definition document.  In either case, if\n      it is defined,
        it might or might not be supported.\n   o  When knowledge of protocol elements
        is optional in a given minor\n      version, the responder's knowledge of
        such optional elements must\n      obey the rule that if one such element
        is known, then all the\n      protocol elements defined in the same minor
        version definition\n      document must be known as well.\n   For many minor
        versions, all existing protocol elements are required\n   to be known by both
        the client and the server, and so requesters do\n   not have to test for the
        presence or absence of knowledge regarding\n   protocol elements.  This is
        the case if there has been no extension\n   for the minor version in question.
        \ Extensions can be added to\n   extensible minor versions as described in
        Section 6 and can be used\n   to correct protocol flaws as described in Section
        9.\n   Requesters can ascertain the knowledge of the responder in two ways:\n
        \  o  By issuing a request using the protocol element and looking at the\n
        \     response.  Note that, even if the protocol element used is not\n      supported
        by the responder, the requester can still determine if\n      the element
        is known by the responder.\n   o  By receiving a request from the responder,
        acting in the role of\n      requester.  For example, a client may issue a
        request enabling the\n      server to infer that it is aware of a corresponding
        callback.\n   In making this determination, the requester can rely on two
        basic\n   facts:\n   o  If the responder is aware of a single protocol element
        within a\n      feature package, it must be aware of all protocol elements
        within\n      that feature package.\n   o  If a protocol element is one defined
        by the minor version\n      specified by a request (and not in an extension),
        or in a previous\n      minor version, the responder must be aware of it.\n"
      title: 4.4.1.  Requirements for Knowledge of Protocol Elements
    - contents:
      - "4.4.2.  Establishing Interoperability\n   When a client and a server interact,
        they need to able to take\n   advantage of the compatibility provided by NFSv4's
        use of XDR\n   extension.\n   In this context, the client and server would
        arrive at a common\n   variant, which the client uses to send requests that
        the server would\n   then accept.  The server would use that variant to send
        callbacks\n   that the client would then accept.  This state of affairs could
        arise\n   in a number of ways:\n   o  Client and server have been built using
        XDR variants that belong\n      to the same minor version.\n   o  The client's
        minor version is lower than that of the server.  In\n      this case the server,
        in accord with Section 8.2, accepts the\n      client's minor version, and
        acts as if it has no knowledge of\n      extensions made in subsequent minor
        versions.  It has knowledge of\n      protocol elements within the current
        (i.e., effectively final)\n      variant of the lower minor version.\n   o
        \ The client's minor version is higher than that of the server.  In\n      this
        case the client, in accord with Section 8.2, uses a lower\n      minor version
        that the server will accept.  In this case, the\n      server has no knowledge
        of extensions made in subsequent minor\n      versions.\n   There are a number
        of cases to consider based on the characteristics\n   of the minor version
        chosen.\n   o  When the minor version consists of only a single variant (no\n
        \     extension or XDR corrections), the client and the server are using\n
        \     the same XDR description and have knowledge of the same protocol\n      elements.\n
        \  o  When the minor version consists of multiple variants (i.e., there\n
        \     are one or more XDR extensions or XDR corrections), the client and\n
        \     the server are using compatible XDR descriptions.  The client is\n      aware
        of some set of extensions while the server may be aware of a\n      different
        set.  The client can use the approach described in\n      Section 4.4.3 to
        determine which of the extensions it knows about\n      are also known by
        the server.  Once this is done, the client and\n      server will both be
        using a common variant.  The variants that the\n      client and the server
        were built with will both either be\n      identical to this variant or a
        valid extension of it.  Similarly,\n      the variants that the client and
        the server actually use will be a\n      subset of this variant, in that certain
        OPTIONAL features will not\n      be used.\n   In either case, the client
        must determine which of the OPTIONAL\n   protocol elements within the common
        version are supported by the\n   server, just as it does for OPTIONAL features
        introduced as part of a\n   minor version.\n   It is best if client implementations
        make the determination as to the\n   support provided by the server before
        acting on user requests.  This\n   includes the determination of the common
        protocol variant and the\n   level of support for OPTIONAL protocol elements.\n"
      title: 4.4.2.  Establishing Interoperability
    - contents:
      - "4.4.3.  Determining Knowledge of Protocol Elements\n   A requester may test
        the responder's knowledge of particular protocol\n   elements as defined below,
        based on the type of protocol element.\n   Note that in the case of attribute
        or flag bits, use of a request\n   that refers to 2 or more bits of undetermined
        status (\"known\" versus\n   \"unknown\") may return results that are not
        particularly helpful.  In\n   such cases, when the response is NFS4ERR_INVAL,
        the requester can\n   only conclude that at least one of the bits is unknown.\n
        \  o  When a GETATTR request is made specifying an attribute bit to be\n      tested
        and that attribute is not a set-only attribute, if the\n      GETATTR returns
        with the error NFS4ERR_INVAL, then it can be\n      concluded that the responder
        has no knowledge of the attribute in\n      question.  Other responses, including
        NFS4ERR_ATTRNOTSUPP,\n      indicate that the responder is aware of the attribute
        in question.\n   o  When a SETATTR request is made specifying the attribute
        bit to be\n      tested and that attribute is not a get-only attribute, if
        the\n      SETATTR returns with the error NFS4ERR_INVAL, then it can be\n
        \     concluded that the responder has no knowledge of the attribute in\n
        \     question.  Other responses, including NFS4ERR_ATTRNOTSUPP,\n      indicate
        that the responder is aware of the attribute in question.\n   o  When a request
        is made including an operation with a new flag bit,\n      if the operation
        returns with the error NFS4ERR_INVAL, then it can\n      generally be concluded
        that the responder has no knowledge of the\n      flag bit in question, as
        long as the requester is careful to avoid\n      other error situations in
        which the operation in question is\n      defined as returning NFS4ERR_INVAL.
        \ Other responses indicate that\n      the responder is aware of the flag
        bit in question.\n   o  When a request is made including the operation to
        be tested, if\n      the responder returns an RPC XDR decode error, or a response\n
        \     indicating that the operation in question resulted in\n      NFS4ERR_OP_ILLEGAL
        or NFS4ERR_BADXDR, then it can be concluded\n      that the responder has
        no knowledge of the operation in question.\n      Other responses, including
        NFS4ERR_NOTSUPP, indicate that the\n      responder is aware of the operation
        in question.\n   o  When a request is made including the switch arm to be
        tested, if\n      the responder returns an RPC XDR decode error, or a response\n
        \     indicating that the operation in question resulted in\n      NFS4ERR_BADXDR,
        then it can be concluded that the responder has no\n      knowledge of the
        operation in question.  Other responses,\n      including NFS4ERR_UNION_NOTSUPP,
        indicate that the responder is\n      aware of the protocol element in question.\n
        \  A determination of the knowledge or lack of knowledge of a particular\n
        \  protocol element is expected to remain valid as long as the clientid\n
        \  associated with the request remains valid.\n   The above assumes, as should
        be the case, that the server will accept\n   the minor version used by the
        client.  For more detail regarding this\n   issue, see Section 8.2.\n"
      title: 4.4.3.  Determining Knowledge of Protocol Elements
    title: 4.4.  Inter-version Interoperability
  - contents:
    - "4.5.  XDR Overlay\n   XDR additions may also be made by defining XDR structures
      that\n   overlay nominally opaque fields that are defined to allow such\n   incremental
      extensions.\n   For example, each parallel NFS (pNFS) mapping type provides
      its own\n   XDR definition for various pNFS-related fields defined in [RFC5661]\n
      \  as opaque arrays.\n   Because such additions provide new interpretations
      of existing\n   fields, they may be made outside of the extension framework
      as long\n   as they obey the rules previously established when the nominally\n
      \  opaque protocol elements were added to the protocol.\n"
    title: 4.5.  XDR Overlay
  title: 4.  XDR Considerations
- contents:
  - "5.  Other NFSv4 Protocol Changes\n   There are a number of types of protocol
    changes that are outside the\n   XDR extension framework discussed in Section
    4.  These changes are\n   also managed within the NFSv4 versioning framework and
    may be of a\n   number of types, which are discussed in the sections below.\n
    \  Despite the previous emphasis on XDR changes, additions and changes\n   to
    the NFSv4 protocols have not been limited to those that involve\n   changes (in
    the form of extensions) to the protocol XDR.  Examples of\n   other sorts of changes
    have been taken from NFSv4.1.\n   All such changes that have been made in the
    past have been made as\n   part of new minor version.  Future change of these
    sorts may not be\n   done in an extension but can only be made in a new minor
    version.\n"
  - contents:
    - "5.1.  Field Interpretation and Use\n   The XDR description of a protocol does
      not constitute a complete\n   description of the protocol.  Therefore, versioning
      needs to consider\n   the role of changes in the use of fields, even when there
      is no\n   change to the underlying XDR.\n   Although any XDR element is potentially
      subject to a change in its\n   interpretation and use, the likelihood of such
      change will vary with\n   the XDR-specified type of the element, as discussed
      below:\n   o  When XDR elements are defined as strings, rules regarding the\n
      \     appropriate string values are specified in protocol specification\n      text
      with changes in such rules documented in minor version\n      definition documents.
      \ Some types of strings within NFS4 are used\n      in server names (in location-related
      attributes), user and group\n      names, and in the names of file objects within
      directories.  Rules\n      regarding what strings are acceptable appear in [RFC7530]
      and\n      [RFC5661] with the role of the XDR limited to hints regarding\n      UTF-8
      and capitalization issues via XDR typedefs.\n   o  Fields that are XDR-defined
      as opaque elements and that are truly\n      opaque, do not raise versioning
      issues, except as regards inter-\n      version use, which is effectively foreclosed
      by the rules in\n      Section 8.1.\n      Note that sometimes a field will
      seem to be opaque but not\n      actually be fully opaque when considered carefully.
      \ For example,\n      the \"other\" field of stateids is defined as an opaque
      array, while\n      the specification text specially defines appropriate treatment\n
      \     when the \"other\" field within it is either all zeros or all ones.\n
      \     Given this context, creation or deletion of reserved values for\n      \"special\"
      stateids will be a protocol change that versioning rules\n      need to deal
      with.\n   o  Some nominally opaque elements have external XDR definitions that\n
      \     overlay the nominally opaque arrays.  Such cases are discussed in\n      Section
      4.5.\n"
    title: 5.1.  Field Interpretation and Use
  - contents:
    - "5.2.  Behavioral Changes\n   Changes in the behavior of NFSv4 operations are
      possible, even if\n   there is no change in the underlying XDR or change to
      field\n   interpretation and use.\n   One class of behavioral change involves
      changes in the set of errors\n   to be returned when various failure conditions
      occur.  When the set\n   of valid requests remain the same, and the behavior
      for each of them\n   remains the same, such changes can be implemented with
      only limited\n   disruption to existing clients.\n   Many more substantial behavioral
      changes have occurred in connection\n   with the addition of the session concept
      in NFSv4.1.  Even though\n   there was no change to the XDR for existing operations,
      many existing\n   operations and COMPOUNDs consisting only of them became invalid.\n
      \  Also, changes were made regarding the required server behavior as to\n   the
      interaction of the MODE and Access Control List (ACL) attributes.\n"
    title: 5.2.  Behavioral Changes
  title: 5.  Other NFSv4 Protocol Changes
- contents:
  - "6.  Extending Existing Minor Versions\n   Extensions to the most recently published
    NFSv4 minor version may be\n   made by publishing the extension as a Proposed
    Standard, unless the\n   minor version in question has been defined as non-extensible.
    \ A\n   document need not use the \"Updates\" header specifying the RFC that\n
    \  defines the minor version, which remains a valid description of the\n   base
    variant of the minor version in question.\n   In addition to following the rules
    for XDR extensions in Section 4.2,\n   such extensions must also obey the rules
    listed below in order to\n   allow interoperability to be established, as described
    in\n   Section 4.4:\n   o  Additions to the set of callback requests and extensions
    to the\n      XDR for existing callback operations can only be made if the\n      server
    can determine, based on the client's actions, that the\n      client is aware
    of the changes.  This determination, for any\n      particular client (as defined
    by its clientid), is made before\n      sending those new or extended callbacks.\n
    \  o  XDR extensions that affect the structures of responses to existing\n      operations
    can only be made if the server can determine, based on\n      the client's actions,
    that it is aware of the existence of XDR\n      changes, before sending responses
    containing those extensions.\n      This determination can be based on the request
    being responded to,\n      but that is not required.  Use of any protocol element
    defined in\n      the extension can be the basis of the determination, provided
    that\n      the requirements for determining client awareness are clearly\n      stated.\n
    \  Corrections to protocol errors (see Section 9) may be accomplished by\n   publishing
    an extension, including a compatible XDR change that\n   follows the rules above.
    \ Such documents will update the defining\n   documents for the minor version
    to be corrected.\n   In some cases, extensions will contain elements such as new\n
    \  operations or previously invalid switch cases.  Although it is\n   possible
    to determine whether these OPTIONAL elements are supported\n   using the rules
    described above, those defining an extension that\n   contains such elements have
    the choice of defining a new attribute\n   that indicates whether the feature
    is present and supported.  Since\n   it is easy to determine whether a new attribute
    is supported using\n   the supported_attrs attribute, this can make it simple
    and convenient\n   for clients to determine whether support is present, particularly\n
    \  when a feature involves support for multiple such elements.\n"
  title: 6.  Extending Existing Minor Versions
- contents:
  - '7.  Minor Versions

    '
  - contents:
    - "7.1.  Creation of New Minor Versions\n   It is important to note that this
      section, in describing situations\n   that would require new minor versions
      to be created, does not thereby\n   imply that situations will exist in the
      future.  Judgments regarding\n   desirability of future changes will be made
      by the working group or\n   its successors and any guidance that can be offered
      at this point is\n   necessarily quite limited.\n   Creation of a new minor
      version is an option that the working group\n   retains.  The listing of situations
      below that would prompt such\n   actions is not meant to be exhaustive.\n   The
      following sorts of features are not allowed as extensions and\n   would require
      creation of a new minor version:\n   o  Features that incorporate any of the
      non-XDR-based changes\n      discussed in Sections 5.1 and 5.2.\n   o  Features
      whose XDR changes do not follow the rules in Section 6.\n   o  Addition of REQUIRED
      new features.\n   o  Changes to the status of existing features including converting\n
      \     features to be mandatory to not implement.\n"
    title: 7.1.  Creation of New Minor Versions
  title: 7.  Minor Versions
- contents:
  - "8.  Minor Version Interaction Rules\n   This section addresses issues related
    to rules #11 and #13 in the\n   minor versioning rules in [RFC5661].  With regard
    to the supersession\n   of minor versioning rules, the treatment here overrides
    that in\n   [RFC5661] when either of the potentially interacting minor versions\n
    \  has not yet been published as a Proposed Standard.\n   Note that these rules
    are the only ones directed to minor version\n   implementers, rather than to those
    specifying new minor versions.\n"
  - contents:
    - "8.1.  Minor Version Identifier Transfer Issues\n   Each relationship between
      a client instance and a server instance, as\n   represented by a clientid, is
      to be devoted to a single minor\n   version.  If a server detects that a COMPOUND
      with an inappropriate\n   minor version is being used, it MUST reject the request.
      \ In doing\n   so, it may return either NFS4ERR_BAD_CLIENTID or\n   NFS4RR_MINOR_VERS_MISMATCH.\n
      \  As a result of the above, the client has the assurance that the set\n   of
      REQUIRED and OPTIONAL features will not change within the context\n   of a single
      clientid.  Server implementations MUST ensure that the\n   set of supported
      features and protocol elements does not change\n   within such a context.\n"
    title: 8.1.  Minor Version Identifier Transfer Issues
  - contents:
    - "8.2.  Minor Version Compatibility\n   The goal of the NFSv4 extension model
      is to enable compatibility\n   including compatibility between clients and servers
      implementing\n   different minor versions.\n   Within a set of minor versions
      that define the same set of features\n   as REQUIRED and mandatory to not implement,
      it is relatively easy for\n   clients and servers to provide the needed compatibility
      by adhering\n   to the following practices:\n   o  Servers supporting a given
      minor version should support earlier\n      minor versions within that set and
      return appropriate errors for\n      use of protocol elements that were not
      a valid part of that\n      earlier minor version.  For details, see below.\n
      \  o  Clients should deal with an NFS4ERR_MINOR_VERS_MISMATCH error by\n      searching
      for a lower minor version number that the server will\n      accept.\n   Servers
      supporting a given minor version MUST, in returning errors\n   for operations
      that were a valid part of the minor version, return\n   the errors allowed for
      the current operation in the minor version\n   actually being used.\n   With
      regard to protocol elements not known in a given minor version,\n   the appropriate
      error codes are given below.  Essentially, the\n   server, although it has a
      more extensive XDR reflective of a newer\n   minor version, must act as a server
      with a more limited XDR would.\n   o  When an operation is used that is not
      known in the specified minor\n      version, NFS4ERR_OP_ILLEGAL (as opposed
      to NFS4ERR_NOTSUPP) should\n      be returned.\n   o  When an attribute is used
      that is not known in the specified minor\n      version, NFS4ERR_INVAL (as opposed
      to NFS4ERR_ATTRNOTSUPP) should\n      be returned.\n   o  When a switch case
      is used that is not known in the specified\n      minor version, NFS4ERR_BADXDR
      (as opposed to\n      NFS4ERR_UNION_NOTSUPP) should be returned.  Even though
      the\n      message may be XDR-decodable by the server's current XDR, it is\n
      \     not so according to the minor version being used.\n   o  When a flag bit
      is used that is not known in the specified minor\n      version, NFS4ERR_INVAL
      (as opposed to NFS4ERR_NOTSUPP or any other\n      error defined as indicating
      non-support of a flag bit) should be\n      returned.\n"
    title: 8.2.  Minor Version Compatibility
  title: 8.  Minor Version Interaction Rules
- contents:
  - "9.  Correction of Existing Minor Versions and Features\n   The possibility always
    exists that there will be a need to correct an\n   existing feature in some way
    after the acceptance of that feature, or\n   a minor version containing it, as
    a Proposed Standard.  While the\n   working group can reduce the probability of
    such situations arising\n   by waiting for running code before considering a feature
    as done, it\n   cannot reduce the probability to zero.  As features are used more\n
    \  extensively and interact with other features, previously unseen flaws\n   may
    be discovered and will need to be corrected.\n   Such corrections are best done
    in a document obsoleting or updating\n   the RFC defining the relevant feature
    or minor version.  In making\n   such corrections, the working group will have
    to carefully consider\n   how to assure interoperability with older clients and
    servers.\n   Often, corrections can be done without changing the protocol XDR.
    \ In\n   many cases, a change in client and server behavior can be implemented\n
    \  without taking special provision with regard to interoperability with\n   earlier
    implementations.  In those cases, and in cases in which a\n   revision merely
    clarifies an earlier protocol definition document, a\n   new document can be published
    that simply updates the earlier\n   protocol definition document.\n   In other
    cases, it is best if client or server behavior needs to\n   change in a way that
    raises interoperability concerns.  In such\n   cases, incompatible changes in
    server or client behavior should not\n   be mandated in order to avoid XDR changes.\n"
  - contents:
    - "9.1.  XDR Changes to Implement Protocol Corrections\n   When XDR changes are
      necessary as part of correcting a flaw, these\n   should be done in a manner
      similar to that used when implementing new\n   minor versions or features within
      them.  In particular:\n   o  Existing XDR structures may not be modified or
      deleted.\n   o  XDR extensions may be used to correct existing protocol facilities\n
      \     in a manner similar to those used to add additional optional\n      features.
      \ Such corrections may be done in a minor version for\n      which optional
      features may no longer be added, if the working\n      group decides that it
      is an appropriate way to compatibly effect a\n      correction.\n   o  When
      a correction is made to an OPTIONAL feature, the result is\n      similar to
      a situation in which there are two independent OPTIONAL\n      features.  A
      server may choose to implement either or both.  See\n      Section 9.2 for a
      detailed discussion of interoperability issues.\n   o  When a correction is
      made to a REQUIRED feature, the situation\n      becomes one in which the old
      version of the feature remains\n      REQUIRED while the corrected version,
      while OPTIONAL, is intended\n      to be adopted to provide correct operation.
      \ Although use of the\n      corrected version is ultimately better and may
      be recommended, it\n      should not be described as \"RECOMMENDED\" since the
      choice of\n      versions to support will depend on the needs of clients, which
      may\n      be slow to adopt the updated version.  The nature of such\n      corrections
      is such that it may result in situations in which\n      different variants
      of the same minor version may not both support\n      the corrected version.
      \ See Section 9.3 for details.\n   o  In all of the cases above, it is appropriate
      that the old version\n      of the feature be considered obsolescent, with the
      expectation\n      that the working group might, in a later minor version, change
      the\n      status of the uncorrected version.  See Section 9.4 for more\n      detail.\n"
    title: 9.1.  XDR Changes to Implement Protocol Corrections
  - contents:
    - "9.2.  XDR Corrections to OPTIONAL Features\n   By defining the corrected and
      uncorrected version as independent\n   OPTIONAL features, the protocol with
      the XDR modification can\n   accommodate clients and servers that support either
      the corrected or\n   the uncorrected version of the protocol, and also clients
      and servers\n   aware of and capable of supporting both alternatives.\n   Based
      on the type of client:\n   o  A client that uses only the earlier version of
      the feature (i.e.,\n      an older unfixed client) can determine whether the
      server it is\n      connecting to supports the older version of feature.  It
      is\n      capable of interoperating with older servers that support only the\n
      \     unfixed protocol as well as ones that support both versions.\n   o  A
      client that supports only the corrected version of the feature\n      (i.e.,
      a new or updated client) can determine whether the server\n      it is connecting
      to supports the newer version of the feature.  It\n      is capable of interoperating
      with newer servers that support only\n      the updated feature as well as ones
      that support both versions.\n   o  A client that supports both the older and
      newer version of the\n      feature can determine which version of the particular
      feature is\n      supported by the server it is working with.\n   Based on the
      type of server:\n   o  A server that supports only the earlier version of the
      feature\n      (i.e., an older unfixed server) can only successfully interoperate\n
      \     with clients implementing the older version.  However, clients\n      that
      do not implement the older version of the feature can easily\n      determine
      that the feature cannot be used on that server.\n   o  A server that supports
      only the newer version of the feature\n      (i.e., a new or updated server)
      can only successfully interoperate\n      with newer clients.  However, older
      clients can easily determine\n      that the feature cannot be used on that
      server.  In the case of\n      OPTIONAL features, clients can be expected to
      deal with non-\n      support of that particular feature.\n   o  A server that
      supports both the older and newer versions of the\n      feature can interoperate
      with all client variants.\n   By using extensions in this manner, the protocol
      creates a clear path\n   that preserves the functioning of existing clients
      and servers and\n   allows client and server implementers to adopt the new version
      of the\n   feature at a reasonable pace.\n"
    title: 9.2.  XDR Corrections to OPTIONAL Features
  - contents:
    - "9.3.  XDR Corrections to REQUIRED Features\n   Interoperability issues in this
      case are similar to those for the\n   OPTIONAL case described above (in Section
      9.2).  However, because the\n   use of the uncorrected version is REQUIRED,
      servers have to support\n   this until there is a minor version change.  Nevertheless,
      there is\n   the opportunity for clients and servers to implement the corrected\n
      \  version, while maintaining necessary interoperability with earlier\n   implementations.\n
      \  The following types of servers can exist:\n   o  Servers only aware of and
      supporting the uncorrected version, such\n      as servers developed before
      the issue requiring correction was\n      known.\n   o  Servers aware of both
      versions while only supporting the\n      uncorrected version.\n   o  Servers
      aware of and supporting both versions.\n   With the exception of clients that
      do not use the feature in\n   question, the following sorts of clients may exist:\n
      \  o  Clients only aware of and prepared to use the uncorrected version,\n      such
      as those developed before the issue requiring correction was\n      known.\n
      \     Clients developed before the correction was defined would be of\n      this
      type.  They would be capable of interoperating with all of\n      the types
      of servers listed above, but could not use the corrected\n      version.\n   o
      \ Clients aware of both versions while only prepared to use the\n      uncorrected
      version.\n      Some clients developed or modified after the correction was\n
      \     defined would be of this type, until they were modified to support\n      the
      corrected version.  They would also be capable of\n      interoperating with
      all of the types of servers listed above, but\n      could not use the corrected
      version.\n   o  Clients aware of and prepared to use either version.\n      Such
      clients would be capable of interoperating with all of the\n      types of servers
      listed above, and could use the corrected version\n      with servers that supported
      it.\n   o  Clients aware of both versions while only prepared to use the\n      newer,
      corrected version.\n      Such clients would only be capable of interoperating
      with servers\n      that supported the corrected version.  With other types
      of\n      servers, they could determine the absence of appropriate support\n
      \     at an early stage and treat the minor version in question as\n      unsupported
      by the server.  Such clients are only likely to be\n      deployed when the
      majority of servers support the corrected\n      version.\n"
    title: 9.3.  XDR Corrections to REQUIRED Features
  - contents:
    - "9.4.  Addressing XDR Corrections in Later Minor Versions\n   As described in
      Sections 9.2 and 9.3, a corrected XDR can be\n   incorporated in an existing
      minor version and be used, while an\n   existing uncorrected version is still
      supported.  Nevertheless, the\n   uncorrected version will remain part of the
      protocol until its status\n   is changed in a later minor version.\n   One possible
      change that could be made in a later minor version is to\n   define the uncorrected
      version as mandatory to not implement.\n   Because of the difficulty of determining
      that no clients depend on\n   support for the uncorrected version, it is unlikely
      that this step\n   would be appropriate for a considerable time.\n   In the
      case of a correction to a REQUIRED feature, there are a number\n   of less disruptive
      changes that could be made earlier:\n   o  Changing the uncorrected version
      from REQUIRED to OPTIONAL while\n      REQUIRING that servers support at least
      one of the two versions.\n      This would allow new server implementations
      to avoid support for\n      the uncorrected version.\n   o  Changing the corrected
      version from OPTIONAL to REQUIRED, making\n      both versions REQUIRED.\n      This
      would allow new clients to depend on support for the\n      corrected version
      being present.\n   o  Changing the uncorrected version from REQUIRED to OPTIONAL
      while\n      changing the corrected version from OPTIONAL to REQUIRED.\n      This
      would complete the shift to the corrected version once\n      clients are prepared
      to use the corrected version.\n   In making such changes, interoperability issues
      would need to be\n   carefully considered.\n"
    title: 9.4.  Addressing XDR Corrections in Later Minor Versions
  title: 9.  Correction of Existing Minor Versions and Features
- contents:
  - "10.  Security Considerations\n   Since no substantive protocol changes are proposed
    here, no security\n   considerations apply.\n"
  title: 10.  Security Considerations
- contents:
  - "11.  IANA Considerations\n   The current document does not require any IANA actions.\n"
  title: 11.  IANA Considerations
- contents:
  - '12.  References

    '
  - contents:
    - "12.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n
      \             DOI 10.17487/RFC2119, March 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n
      \  [RFC5661]  Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed.,\n              \"Network
      File System (NFS) Version 4 Minor Version 1\n              Protocol\", RFC 5661,
      DOI 10.17487/RFC5661, January 2010,\n              <http://www.rfc-editor.org/info/rfc5661>.\n
      \  [RFC7530]  Haynes, T., Ed. and D. Noveck, Ed., \"Network File System\n              (NFS)
      Version 4 Protocol\", RFC 7530, DOI 10.17487/RFC7530,\n              March 2015,
      <http://www.rfc-editor.org/info/rfc7530>.\n   [RFC7862]  Haynes, T., \"Network
      File System (NFS) Version 4 Minor\n              Version 2 Protocol\", RFC 7862,
      DOI 10.17487/RFC7862,\n              November 2016, <http://www.rfc-editor.org/info/rfc7862>.\n
      \  [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n              2119
      Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n              May 2017,
      <http://www.rfc-editor.org/info/rfc8174>.\n"
    title: 12.1.  Normative References
  - contents:
    - "12.2.  Informative References\n   [RFC3530]  Shepler, S., Callaghan, B., Robinson,
      D., Thurlow, R.,\n              Beame, C., Eisler, M., and D. Noveck, \"Network
      File System\n              (NFS) version 4 Protocol\", RFC 3530, DOI 10.17487/RFC3530,\n
      \             April 2003, <http://www.rfc-editor.org/info/rfc3530>.\n"
    title: 12.2.  Informative References
  title: 12.  References
- contents:
  - "Acknowledgements\n   The author wishes to thank Tom Haynes of Primary Data for
    his role in\n   getting the effort to revise NFSV4 version management started
    and for\n   his work in coauthoring the first draft version of this document.\n
    \  The author also wishes to thank Chuck Lever and Mike Kupfer of\n   Oracle,
    and Bruce Fields of Red Hat for their helpful reviews of this\n   and other versioning-related
    documents.\n"
  title: Acknowledgements
- contents:
  - "Author's Address\n   David Noveck\n   NetApp\n   1601 Trapelo Road\n   Waltham,
    MA  02451\n   United States of America\n   Phone: +1 781 572 8038\n   Email: davenoveck@gmail.com\n"
  title: Author's Address
