- title: __initial_text__
  contents:
  - "                           State Machines for\n   the Protocol for Carrying Authentication\
    \ for Network Access (PANA)\n"
- title: Abstract
  contents:
  - "Abstract\n   This document defines the conceptual state machines for the Protocol\n\
    \   for Carrying Authentication for Network Access (PANA).  The state\n   machines\
    \ consist of the PANA Client (PaC) state machine and the PANA\n   Authentication\
    \ Agent (PAA) state machine.  The two state machines\n   show how PANA can interface\
    \ with the Extensible Authentication\n   Protocol (EAP) state machines.  The state\
    \ machines and associated\n   models are informative only.  Implementations may\
    \ achieve the same\n   results using different methods.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2009 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\
    \ in effect on the date of\n   publication of this document (http://trustee.ietf.org/license-info).\n\
    \   Please review these documents carefully, as they describe your rights\n  \
    \ and restrictions with respect to this document.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Terminology .....................................................3\n  \
    \ 3. Interface between PANA and EAP ..................................3\n   4.\
    \ Document Authority ..............................................5\n   5. Notations\
    \ .......................................................5\n   6. Common Rules\
    \ ....................................................6\n      6.1. Common Procedures\
    \ ..........................................6\n      6.2. Common Variables ...........................................9\n\
    \      6.3. Configurable Values .......................................10\n  \
    \    6.4. Common Message Initialization Rules .......................10\n    \
    \  6.5. Common Retransmission Rules ...............................10\n      6.6.\
    \ Common State Transitions ..................................11\n   7. PaC State\
    \ Machine ..............................................12\n      7.1. Interface\
    \ between PaC and EAP Peer ........................12\n           7.1.1. Delivering\
    \ EAP Messages from PaC to EAP Peer .......12\n           7.1.2. Delivering EAP\
    \ Messages from EAP Peer to PaC .......12\n           7.1.3. EAP Restart Notification\
    \ from PaC to EAP Peer ......13\n           7.1.4. EAP Authentication Result Notification\
    \ from\n                  EAP Peer to PaC ....................................13\n\
    \           7.1.5. Alternate Failure Notification from PaC to\n              \
    \    EAP Peer ...........................................13\n      7.2. Configurable\
    \ Values .......................................13\n      7.3. Variables .................................................14\n\
    \      7.4. Procedures ................................................15\n  \
    \    7.5. PaC State Transition Table ................................15\n   8.\
    \ PAA State Machine ..............................................21\n      8.1.\
    \ Interface between PAA and EAP Authenticator ...............21\n           8.1.1.\
    \ EAP Restart Notification from PAA to EAP\n                  Authenticator ......................................21\n\
    \           8.1.2. Delivering EAP Responses from PAA to EAP\n                \
    \  Authenticator ......................................22\n           8.1.3. Delivering\
    \ EAP Messages from EAP\n                  Authenticator to PAA ...............................22\n\
    \           8.1.4. EAP Authentication Result Notification from\n             \
    \     EAP Authenticator to PAA ...........................22\n      8.2. Variables\
    \ .................................................23\n      8.3. Procedures ................................................24\n\
    \      8.4. PAA State Transition Table ................................24\n  \
    \ 9. Implementation Considerations ..................................29\n    \
    \  9.1. PAA and PaC Interface to Service Management Entity ........29\n   10.\
    \ Security Considerations .......................................29\n   11. Acknowledgments\
    \ ...............................................29\n   12. References ....................................................29\n\
    \      12.1. Normative References .....................................29\n  \
    \    12.2. Informative References ...................................30\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document defines the state machines for the Protocol\
    \ for\n   Carrying Authentication for Network Access (PANA) [RFC5191].  There\n\
    \   are state machines for the PANA Client (PaC) and for the PANA\n   Authentication\
    \ Agent (PAA).  Each state machine is specified through\n   a set of variables,\
    \ procedures, and a state transition table.  The\n   state machines and associated\
    \ models described in this document are\n   informative only.  Implementations\
    \ may achieve similar results using\n   different models and/or methods.\n   A\
    \ PANA protocol execution consists of several exchanges to carry\n   authentication\
    \ information.  Specifically, EAP PDUs are transported\n   inside PANA PDUs between\
    \ PaC and PAA; that is, PANA represents a\n   lower layer for EAP.  Thus, a PANA\
    \ state machine bases its execution\n   on an EAP state machine execution and\
    \ vice versa.  Thus, this\n   document also shows for each of PaC and PAA an interface\
    \ between an\n   EAP state machine and a PANA state machine and how this interface\n\
    \   allows to exchange information between them.  Thanks to this\n   interface,\
    \ a PANA state machine can be informed about several events\n   generated in an\
    \ EAP state machine and make its execution conditional\n   to its events.\n  \
    \ The details of EAP state machines are out of the scope of this\n   document.\
    \  Additional information can be found in [RFC4137].\n   Nevertheless, PANA state\
    \ machines presented here have been\n   coordinated with state machines shown\
    \ by [RFC4137].\n   This document, apart from defining PaC and PAA state machines\
    \ and\n   their interfaces to EAP state machines (running on top of PANA),\n \
    \  provides some implementation considerations, taking into account that\n   it\
    \ is not a specification but an implementation guideline.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   This document reuses the terminology used in [RFC5191].\n"
- title: 3.  Interface between PANA and EAP
  contents:
  - "3.  Interface between PANA and EAP\n   PANA carries EAP messages exchanged between\
    \ an EAP peer and an EAP\n   authenticator (see Figure 1).  Thus, a PANA state\
    \ machine interacts\n   with an EAP state machine.\n   Two state machines are\
    \ defined in this document: the PaC state\n   machine (see Section 7) and the\
    \ PAA state machine (see Section 8).\n   The definition of each state machine\
    \ consists of a set of variables,\n   procedures, and a state transition table.\
    \  A subset of these\n   variables and procedures defines the interface between\
    \ a PANA state\n   machine and an EAP state machine, and the state transition\
    \ table\n   defines the PANA state machine behavior based on results obtained\n\
    \   through them.\n   On the one hand, the PaC state machine interacts with an\
    \ EAP peer\n   state machine in order to carry out the PANA protocol on the PaC\n\
    \   side.  On the other hand, the PAA state machine interacts with an EAP\n  \
    \ authenticator state machine to run the PANA protocol on the PAA side.\n    \
    \                 Peer             |EAP            Auth\n                    \
    \ EAP    <---------|------------>  EAP\n                    ^ |              \
    \ |              ^ |\n                    | |               | EAP-Message  | |\
    \  EAP-Message\n       EAP-Message    | |EAP-Message  |                | |\n \
    \                     | v             |PANA            | v\n                 \
    \    PaC    <---------|------------>  PAA\n                 Figure 1: Interface\
    \ between PANA and EAP\n   Thus, two interfaces are needed between PANA state\
    \ machines and EAP\n   state machines, namely:\n   o  Interface between the PaC\
    \ state machine and the EAP peer state\n      machine\n   o  Interface between\
    \ the PAA state machine and the EAP authenticator\n      state machine\n   In\
    \ general, the PaC and PAA state machines present EAP messages to\n   the EAP\
    \ peer and authenticator state machines through the interface,\n   respectively.\
    \  The EAP peer and authenticator state machines process\n   these messages and\
    \ send EAP messages through the PaC and PAA state\n   machines that are responsible\
    \ for actually transmitting this message,\n   respectively.\n   For example, [RFC4137]\
    \ specifies four interfaces to lower layers: (i)\n   an interface between the\
    \ EAP peer state machine and a lower layer,\n   (ii) an interface between the\
    \ EAP standalone authenticator state\n   machine and a lower layer, (iii) an interface\
    \ between the EAP full\n   authenticator state machine and a lower layer, and\
    \ (iv) an interface\n   between the EAP backend authenticator state machine and\
    \ a lower\n   layer.  In this document, the PANA protocol is the lower layer of\
    \ EAP\n   and only the first three interfaces are of interest to PANA.  The\n\
    \   second and third interfaces are the same.  In this regard, the EAP\n   standalone\
    \ authenticator or the EAP full authenticator and its state\n   machine in [RFC4137]\
    \ are referred to as the EAP authenticator and the\n   EAP authenticator state\
    \ machine, respectively, in this document.  If\n   an EAP peer and an EAP authenticator\
    \ follow the state machines\n   defined in [RFC4137], the interfaces between PANA\
    \ and EAP could be\n   based on that document.  Detailed definition of interfaces\
    \ between\n   PANA and EAP are described in the subsequent sections.\n"
- title: 4.  Document Authority
  contents:
  - "4.  Document Authority\n   This document is intended to comply with the technical\
    \ contents of\n   any of the related documents ([RFC5191] and [RFC4137]).  When\
    \ there\n   is a discrepancy, the related documents are considered authoritative\n\
    \   and they take precedence over this document.\n"
- title: 5.  Notations
  contents:
  - "5.  Notations\n   The following state transition tables are completed mostly\
    \ based on\n   the conventions specified in [RFC4137].  The complete text is\n\
    \   described below.\n   State transition tables are used to represent the operation\
    \ of the\n   protocol by a number of cooperating state machines each comprising\
    \ a\n   group of connected, mutually exclusive states.  Only one state of\n  \
    \ each machine can be active at any given time.\n   All permissible transitions\
    \ from a given state to other states and\n   associated actions performed when\
    \ the transitions occur are\n   represented by using triplets of (exit condition,\
    \ exit action, exit\n   state).  All conditions are expressions that evaluate\
    \ to TRUE or\n   FALSE; if a condition evaluates to TRUE, then the condition is\
    \ met.\n   A state \"ANY\" is a wildcard state that matches any state in each\n\
    \   state machine except those explicitly enumerated as exception states.\n  \
    \ The exit conditions of a wildcard state are evaluated after all other\n   exit\
    \ conditions specific to the current state are met.\n   On exit from a state,\
    \ the exit actions defined for the state and the\n   exit condition are executed\
    \ exactly once, in the order that they\n   appear.  (Note that the procedures\
    \ defined in [RFC4137] are executed\n   on entry to a state, which is one major\
    \ difference from this\n   document.)  Each exit action is deemed to be atomic;\
    \ i.e., execution\n   of an exit action completes before the next sequential exit\
    \ action\n   starts to execute.  No exit action executes outside of a state block.\n\
    \   The exit actions in only one state block execute at a time even if\n   the\
    \ conditions for execution of state blocks in different state\n   machines are\
    \ satisfied.  All exit actions in an executing state block\n   complete execution\
    \ before the transition to and execution of any\n   other state blocks.  The execution\
    \ of any state block appears to be\n   atomic with respect to the execution of\
    \ any other state block, and\n   the transition condition to that state from the\
    \ previous state is\n   TRUE when execution commences.  The order of execution\
    \ of state\n   blocks in different state machines is undefined except as constrained\n\
    \   by their transition conditions.  A variable that is set to a\n   particular\
    \ value in a state block retains this value until a\n   subsequent state block\
    \ executes an exit action that modifies the\n   value.\n   On completion of the\
    \ transition from the previous state to the\n   current state, all exit conditions\
    \ occurring during the current state\n   (including exit conditions defined for\
    \ the wildcard state) are\n   evaluated until an exit condition for that state\
    \ is met.\n   Any event variable is set to TRUE when the corresponding event occurs\n\
    \   and set to FALSE immediately after completion of the action\n   associated\
    \ with the current state and the event.\n   The interpretation of the special\
    \ symbols and operators used is\n   defined in [RFC4137].\n"
- title: 6.  Common Rules
  contents:
  - "6.  Common Rules\n   There are following procedures, variables, message initializing\n\
    \   rules, and state transitions that are common to both the PaC and PAA\n   state\
    \ machines.\n   Throughout this document, the character string \"PANA_MESSAGE_NAME\"\
    \n   matches any one of the abbreviated PANA message names, i.e., \"PCI\",\n \
    \  \"PAR\", \"PAN\", \"PTR\", \"PTA\", \"PNR\", \"PNA\".\n"
- title: 6.1.  Common Procedures
  contents:
  - "6.1.  Common Procedures\n   void None()\n      A null procedure, i.e., nothing\
    \ is done.\n   void Disconnect()\n      A procedure to delete the PANA session\
    \ as well as the\n      corresponding EAP session and authorization state.\n \
    \  boolean Authorize()\n      A procedure to create or modify authorization state.\
    \  It returns\n      TRUE if authorization is successful.  Otherwise, it returns\
    \ FALSE.\n      It is assumed that Authorize() procedure of PaC state machine\n\
    \      always returns TRUE.  In the case that a non-key-generating EAP\n     \
    \ method is used but a PANA SA is required after successful\n      authentication\
    \ (generate_pana_sa() returns TRUE), Authorize()\n      procedure must return\
    \ FALSE.\n   void Tx:PANA_MESSAGE_NAME[flag](AVPs)\n      A procedure to send\
    \ a PANA message to its peering PANA entity.\n      The \"flag\" argument contains\
    \ one or more flags (e.g., Tx:PAR[C])\n      to be set to the message, except\
    \ for 'R' (Request) flag.  The\n      \"AVPs\" contains a list of names of optional\
    \ AVPs to be inserted in\n      the message, except for AUTH AVP.\n      This\
    \ procedure includes the following action before actual\n      transmission:\n\
    \             if (flag==S)\n               PANA_MESSAGE_NAME.S_flag=Set;\n   \
    \          if (flag==C)\n               PANA_MESSAGE_NAME.C_flag=Set;\n      \
    \       if (flag==A)\n               PANA_MESSAGE_NAME.A_flag=Set;\n         \
    \    if (flag==P)\n               PANA_MESSAGE_NAME.P_flag=Set;\n            \
    \ PANA_MESSAGE_NAME.insert_avp(AVPs);\n             if (key_available())\n   \
    \            PANA_MESSAGE_NANE.insert_avp(\"AUTH\");\n   void TxEAP()\n      A\
    \ procedure to send an EAP message to the EAP state machine to\n      which it\
    \ interfaces.\n   void RtxTimerStart()\n      A procedure to start the retransmission\
    \ timer, reset RTX_COUNTER\n      variable to zero, and set an appropriate value\
    \ to RTX_MAX_NUM\n      variable.  Note that RTX_MAX_NUM is assumed to be set\
    \ to the same\n      default value for all messages.  However, implementations\
    \ may also\n      reset RTX_MAX_NUM in this procedure and its value may vary\n\
    \      depending on the message that was sent.\n   void RtxTimerStop()\n     \
    \ A procedure to stop the retransmission timer.\n   void SessionTimerReStart(TIMEOUT)\n\
    \      A procedure to (re)start the PANA session timer.  TIMEOUT\n      specifies\
    \ the expiration time associated with the session timer.\n      Expiration of\
    \ TIMEOUT will trigger a SESS_TIMEOUT event.\n   void SessionTimerStop()\n   \
    \   A procedure to stop the current PANA session timer.\n   void Retransmit()\n\
    \      A procedure to retransmit a PANA message and increment RTX_COUNTER\n  \
    \    by one(1).\n   void EAP_Restart()\n      A procedure to (re)start an EAP\
    \ conversation resulting in the re-\n      initialization of an existing EAP session.\n\
    \   void PANA_MESSAGE_NAME.insert_avp(\"AVP_NAME1\", \"AVP_NAME2\",...)\n    \
    \  A procedure to insert AVPs for each specified AVP name in the list\n      of\
    \ AVP names in the PANA message.  When an AVP name ends with \"*\",\n      zero,\
    \ one, or more AVPs are inserted; otherwise, one AVP is\n      inserted.\n   boolean\
    \ PANA_MESSAGE_NAME.exist_avp(\"AVP_NAME\")\n      A procedure that checks whether\
    \ an AVP of the specified AVP name\n      exists in the specified PANA message\
    \ and returns TRUE if the\n      specified AVP is found, otherwise returns FALSE.\n\
    \   boolean generate_pana_sa()\n      A procedure to check whether the EAP method\
    \ being used generates\n      keys and that a PANA SA will be established on successful\n\
    \      authentication.  For the PaC, the procedure is also used to check\n   \
    \   and match the PRF and Integrity algorithm AVPs advertised by the\n      PAA\
    \ in PAR[S] message.  For the PAA, it is used to indicate\n      whether a PRF\
    \ and Integrity algorithm AVPs will be sent in the\n      PAR[S].  This procedure\
    \ will return TRUE if a PANA SA will be\n      generated.  Otherwise, it returns\
    \ FALSE.\n   boolean key_available()\n      A procedure to check whether the PANA\
    \ session has a PANA_AUTH_KEY.\n      If the state machine already has a PANA_AUTH_KEY,\
    \ it returns TRUE.\n      If the state machine does not have a PANA_AUTH_KEY,\
    \ it tries to\n      retrieve a Master Session Key (MSK) from the EAP entity.\
    \  If an\n      MSK is retrieved, it computes a PANA_AUTH_KEY from the MSK and\n\
    \      returns TRUE.  Otherwise, it returns FALSE.\n"
- title: 6.2.  Common Variables
  contents:
  - "6.2.  Common Variables\n   PAR.RESULT_CODE\n      This variable contains the\
    \ Result-Code AVP value in the PANA-Auth-\n      Request message in process. \
    \ When this variable carries\n      PANA_SUCCESS, it is assumed that the PAR message\
    \ always contains\n      an EAP-Payload AVP that carries an EAP-Success message.\n\
    \   NONCE_SENT\n      This variable is set to TRUE to indicate that a Nonce-AVP\
    \ has\n      already been sent.  Otherwise, it is set to FALSE.\n   RTX_COUNTER\n\
    \      This variable contains the current number of retransmissions of\n     \
    \ the outstanding PANA message.\n   Rx:PANA_MESSAGE_NAME[flag]\n      This event\
    \ variable is set to TRUE when the specified PANA message\n      is received from\
    \ its peering PANA entity.  The \"flag\" contains a\n      flag (e.g., Rx:PAR[C]),\
    \ except for 'R' (Request) flag.\n   RTX_TIMEOUT\n      This event variable is\
    \ set to TRUE when the retransmission timer\n      is expired.\n   REAUTH\n  \
    \    This event variable is set to TRUE when an initiation of re-\n      authentication\
    \ phase is triggered.  This event variable can only\n      be set while in the\
    \ OPEN state.\n   TERMINATE\n      This event variable is set to TRUE when initiation\
    \ of PANA session\n      termination is triggered.  This event variable can only\
    \ be set\n      while in the OPEN state.\n   PANA_PING\n      This event variable\
    \ is set to TRUE when initiation of liveness\n      test based on PANA-Notification\
    \ exchange is triggered.  This event\n      variable can only be set while in\
    \ the OPEN state.\n   SESS_TIMEOUT\n      This event is variable is set to TRUE\
    \ when the session timer has\n      expired.\n   LIFETIME_SESS_TIMEOUT\n     \
    \ Configurable value used by the PaC and PAA to close or disconnect\n      an\
    \ established session in the access phase.  This variable\n      indicates the\
    \ expiration of the session and is set to the value of\n      Session-Lifetime\
    \ AVP if present in the last PANA-Auth-Request\n      message in the case of the\
    \ PaC.  Otherwise, it is assumed that the\n      value is infinite and therefore\
    \ has no expiration.  Expiration of\n      LIFETIME_SESS_TIMEOUT will cause the\
    \ event variable SESS_TIMEOUT\n      to be set.\n   ANY\n      This event variable\
    \ is set to TRUE when any event occurs.\n"
- title: 6.3.  Configurable Values
  contents:
  - "6.3.  Configurable Values\n   RTX_MAX_NUM\n      Configurable maximum for how\
    \ many retransmissions should be\n      attempted before aborting.\n"
- title: 6.4.  Common Message Initialization Rules
  contents:
  - "6.4.  Common Message Initialization Rules\n   When a message is prepared for\
    \ sending, it is initialized as follows:\n   o  For a request message, R-flag\
    \ of the header is set.  Otherwise,\n      R-flag is not set.\n   o  Other message\
    \ header flags are not set.  They are set explicitly\n      by specific state\
    \ machine actions.\n   o  AVPs that are mandatory to be included in a message\
    \ are inserted\n      with appropriate values set.\n"
- title: 6.5.  Common Retransmission Rules
  contents:
  - "6.5.  Common Retransmission Rules\n   The state machines defined in this document\
    \ assume that the PaC and\n   the PAA cache the last transmitted answer message.\
    \  This scheme is\n   described in Section 5.2 of [RFC5191].  When the PaC or\
    \ PAA receives\n   a retransmitted or duplicate request, it would be able to resend\
    \ the\n   corresponding answer without any aid from the EAP layer.  However, to\n\
    \   simplify the state machine description, this caching scheme is\n   omitted\
    \ in the state machines below.  In the case that there is not a\n   corresponding\
    \ answer to a retransmitted request, the request will be\n   handled by the corresponding\
    \ state machine.\n"
- title: 6.6.  Common State Transitions
  contents:
  - "6.6.  Common State Transitions\n   The following transitions can occur at any\
    \ state with exemptions\n   explicitly noted.\n   ----------\n   State: ANY\n\
    \   ----------\n   Exit Condition           Exit Action                Exit State\n\
    \   ------------------------+--------------------------+------------\n   - - -\
    \ - - - - - - - - - - (Re-transmissions)- - - - - - - - - -\n   RTX_TIMEOUT &&\
    \           Retransmit();              (no change)\n   RTX_COUNTER<\n   RTX_MAX_NUM\n\
    \   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n   - - -\
    \ - - - - (Reach maximum number of transmissions)- - - - - -\n   (RTX_TIMEOUT\
    \ &&          Disconnect();              CLOSED\n    RTX_COUNTER>=\n    RTX_MAX_NUM)\
    \ ||\n   SESS_TIMEOUT\n   - - - - - - - - - - - - - - - - - - - - - - - - - -\
    \ - - - - - -\n   -------------------------\n   State: ANY except INITIAL\n  \
    \ -------------------------\n   Exit Condition           Exit Action         \
    \       Exit State\n   ------------------------+--------------------------+------------\n\
    \   - - - - - - - - - - (liveness test initiated by peer)- - - - - -\n   Rx:PNR[P]\
    \                Tx:PNA[P]();               (no change)\n   -------------------------------\n\
    \   State: ANY except WAIT_PNA_PING\n   -------------------------------\n   Exit\
    \ Condition           Exit Action                Exit State\n   ------------------------+--------------------------+------------\n\
    \   - - - - - - - - - - - - (liveness test response) - - - - - - - -\n   Rx:PNA[P]\
    \                None();                    (no change)\n   The following transitions\
    \ can occur on any exit condition within the\n   specified state.\n   -------------\n\
    \   State: CLOSED\n   -------------\n   Exit Condition           Exit Action \
    \               Exit State\n   ------------------------+--------------------------+------------\n\
    \   - - - - - - - -(Catch all event on closed state) - - - - - - - -\n   ANY \
    \                     None();                    CLOSED\n   - - - - - - - - -\
    \ - - - - - - - - - - - - - - - - - - - - - - -\n"
- title: 7.  PaC State Machine
  contents:
  - '7.  PaC State Machine

    '
- title: 7.1.  Interface between PaC and EAP Peer
  contents:
  - "7.1.  Interface between PaC and EAP Peer\n   This interface defines the interactions\
    \ between a PaC and an EAP\n   peer.  The interface serves as a mechanism to deliver\
    \ EAP messages\n   for the EAP peer.  It allows the EAP peer to receive EAP requests\
    \ and\n   send EAP responses via the PaC.  It also provides a mechanism to\n \
    \  notify the EAP peer of PaC events and a mechanism to receive\n   notification\
    \ of EAP peer events.  The EAP message delivery mechanism\n   as well as the event\
    \ notification mechanism in this interface have\n   direct correlation with the\
    \ PaC state transition table entries.\n   These message delivery and event notifications\
    \ mechanisms occur only\n   within the context of their associated states or exit\
    \ actions.\n"
- title: 7.1.1.  Delivering EAP Messages from PaC to EAP Peer
  contents:
  - "7.1.1.  Delivering EAP Messages from PaC to EAP Peer\n   TxEAP() procedure in\
    \ the PaC state machine serves as the mechanism to\n   deliver EAP messages contained\
    \ in PANA-Auth-Request messages to the\n   EAP peer.  This procedure is enabled\
    \ only after an EAP restart event\n   is notified to the EAP peer and before any\
    \ event resulting in a\n   termination of the EAP peer session.  In the case where\
    \ the EAP peer\n   follows the EAP peer state machine defined in [RFC4137], TxEAP()\n\
    \   procedure sets eapReq variable of the EAP peer state machine and puts\n  \
    \ the EAP request in eapReqData variable of the EAP peer state machine.\n"
- title: 7.1.2.  Delivering EAP Messages from EAP Peer to PaC
  contents:
  - "7.1.2.  Delivering EAP Messages from EAP Peer to PaC\n   An EAP message is delivered\
    \ from the EAP peer to the PaC via\n   EAP_RESPONSE event variable.  The event\
    \ variable is set when the EAP\n   peer passes the EAP message to its lower layer.\
    \  In the case where\n   the EAP peer follows the EAP peer state machine defined\
    \ in [RFC4137],\n   EAP_RESPONSE event variable refers to eapResp variable of\
    \ the EAP\n   peer state machine and the EAP message is contained in eapRespData\n\
    \   variable of the EAP peer state machine.\n"
- title: 7.1.3.  EAP Restart Notification from PaC to EAP Peer
  contents:
  - "7.1.3.  EAP Restart Notification from PaC to EAP Peer\n   The EAP peer state\
    \ machine defined in [RFC4137] has an initialization\n   procedure before receiving\
    \ an EAP message.  To initialize the EAP\n   state machine, the PaC state machine\
    \ defines an event notification\n   mechanism to send an EAP (re)start event to\
    \ the EAP peer.  The event\n   notification is done via EAP_Restart() procedure\
    \ in the\n   initialization action of the PaC state machine.\n"
- title: 7.1.4.  EAP Authentication Result Notification from EAP Peer to PaC
  contents:
  - "7.1.4.  EAP Authentication Result Notification from EAP Peer to PaC\n   In order\
    \ for the EAP peer to notify the PaC of an EAP authentication\n   result, EAP_SUCCESS\
    \ and EAP_FAILURE event variables are defined.  In\n   the case where the EAP\
    \ peer follows the EAP peer state machine\n   defined in [RFC4137], EAP_SUCCESS\
    \ and EAP_FAILURE event variables\n   refer to eapSuccess and eapFail variables\
    \ of the EAP peer state\n   machine, respectively.  In this case, if EAP_SUCCESS\
    \ event variable\n   is set to TRUE and an MSK is generated by the EAP authentication\n\
    \   method in use, eapKeyAvailable variable is set to TRUE and eapKeyData\n  \
    \ variable contains the MSK.  Note that EAP_SUCCESS and EAP_FAILURE\n   event\
    \ variables may be set to TRUE even before the PaC receives a PAR\n   with a 'Complete'\
    \ flag set from the PAA.\n"
- title: 7.1.5.  Alternate Failure Notification from PaC to EAP Peer
  contents:
  - "7.1.5.  Alternate Failure Notification from PaC to EAP Peer\n   alt_reject()\
    \ procedure in the PaC state machine serves as the\n   mechanism to deliver an\
    \ authentication failure event to the EAP peer\n   without accompanying an EAP\
    \ message.  In the case where the EAP peer\n   follows the EAP peer state machine\
    \ defined in [RFC4137], alt_reject()\n   procedure sets altReject variable of\
    \ the EAP peer state machine.\n   Note that the EAP peer state machine in [RFC4137]\
    \ also defines\n   altAccept variable; however, it is never used in PANA in which\
    \ EAP-\n   Success messages are reliably delivered by the last PANA-Auth\n   exchange.\n"
- title: 7.2.  Configurable Values
  contents:
  - "7.2.  Configurable Values\n   FAILED_SESS_TIMEOUT\n      This is a configurable\
    \ value that allows the PaC to determine\n      whether a PaC authentication and\
    \ authorization phase has stalled\n      without an explicit EAP success or failure\
    \ notification.\n"
- title: 7.3.  Variables
  contents:
  - "7.3.  Variables\n   AUTH_USER\n      This event variable is set to TRUE when\
    \ initiation of EAP-based\n      (re-)authentication is triggered by the application.\n\
    \   EAP_SUCCESS\n      This event variable is set to TRUE when the EAP peer determines\n\
    \      that an EAP conversation completes with success.\n   EAP_FAILURE\n    \
    \  This event variable is set to TRUE when the EAP peer determines\n      that\
    \ an EAP conversation completes with failure.\n   EAP_RESPONSE\n      This event\
    \ variable is set to TRUE when the EAP peer delivers an\n      EAP message to\
    \ the PaC.  This event accompanies an EAP message\n      received from the EAP\
    \ peer.\n   EAP_RESP_TIMEOUT\n      This event variable is set to TRUE when the\
    \ PaC that has passed an\n      EAP message to the EAP layer does not receive\
    \ a subsequent EAP\n      message from the EAP layer in a given period.  This\
    \ provides a\n      time limit for certain EAP methods where user interaction\
    \ may be\n      required.\n   EAP_DISCARD\n      This event variable is set to\
    \ TRUE when the EAP peer indicates\n      that it has silently discarded the last\
    \ received EAP-Request.\n      This event does not accompany any EAP message.\
    \  In the case where\n      the EAP peer follows the EAP peer state machine defined\
    \ in\n      [RFC4137], this event variable refers to eapNoResp.  Note that\n \
    \     this specification does not support silently discarding EAP\n      messages.\
    \  They are treated as fatal errors instead.  This may\n      have an impact on\
    \ denial-of-service resistance.\n"
- title: 7.4.  Procedures
  contents:
  - "7.4.  Procedures\n   boolean eap_piggyback()\n      This procedure returns TRUE\
    \ to indicate whether the next EAP\n      response will be carried in the pending\
    \ PAN message for\n      optimization.\n   void alt_reject()\n      This procedure\
    \ informs the EAP peer of an authentication failure\n      event without accompanying\
    \ an EAP message.\n   void EAP_RespTimerStart()\n      This is a procedure to\
    \ start a timer to receive an EAP-Response\n      from the EAP peer.\n   void\
    \ EAP_RespTimerStop()\n      This is a procedure to stop a timer to receive an\
    \ EAP-Response\n      from the EAP peer.\n"
- title: 7.5.  PaC State Transition Table
  contents:
  - "7.5.  PaC State Transition Table\n   ------------------------------\n   State:\
    \ INITIAL (Initial State)\n   ------------------------------\n   Initialization\
    \ Action:\n     NONCE_SENT=Unset;\n     RTX_COUNTER=0;\n     RtxTimerStop();\n\
    \   Exit Condition           Exit Action                Exit State\n   ------------------------+--------------------------+-----------\n\
    \   - - - - - - - - - - (PaC-initiated Handshake) - - - - - - - - -\n   AUTH_USER\
    \                Tx:PCI[]();                INITIAL\n                        \
    \    RtxTimerStart();\n                            SessionTimerReStart\n     \
    \                         (FAILED_SESS_TIMEOUT);\n   - - - - - - - - - - - - -\
    \ - - - - - - - - - - - - - - - - - - -\n   - - - - - - -(PAA-initiated Handshake,\
    \ not optimized) - - - - -\n   Rx:PAR[S] &&             EAP_Restart();       \
    \      WAIT_PAA\n   !PAR.exist_avp           SessionTimerReStart\n   (\"EAP-Payload\"\
    )              (FAILED_SESS_TIMEOUT);\n                            if (generate_pana_sa())\n\
    \                                Tx:PAN[S](\"PRF-Algorithm\",\n              \
    \                     \"Integrity-Algorithm\");\n                            else\n\
    \                                Tx:PAN[S]();\n   - - - - - - - - - - - - - -\
    \ - - - - - - - - - - - - - - - - - -\n   - - - - - - - -(PAA-initiated Handshake,\
    \ optimized) - - - - - -\n   Rx:PAR[S] &&             EAP_Restart();         \
    \    INITIAL\n   PAR.exist_avp            TxEAP();\n   (\"EAP-Payload\") &&  \
    \     SessionTimerReStart\n   eap_piggyback()            (FAILED_SESS_TIMEOUT);\n\
    \   Rx:PAR[S] &&             EAP_Restart();             WAIT_EAP_MSG\n   PAR.exist_avp\
    \            TxEAP();\n   (\"EAP-Payload\") &&       SessionTimerReStart\n   !eap_piggyback()\
    \           (FAILED_SESS_TIMEOUT);\n                            if (generate_pana_sa())\n\
    \                                Tx:PAN[S](\"PRF-Algorithm\",\n              \
    \                    \"Integrity-Algorithm\");\n                            else\n\
    \                                Tx:PAN[S]();\n   EAP_RESPONSE             if\
    \ (generate_pana_sa())    WAIT_PAA\n                                Tx:PAN[S](\"\
    EAP-Payload\",\n                                  \"PRF-Algorithm\",\n       \
    \                           \"Integrity-Algorithm\");\n                      \
    \      else\n                                Tx:PAN[S](\"EAP-Payload\");\n   -\
    \ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n   ---------------\n\
    \   State: WAIT_PAA\n   ---------------\n   Exit Condition           Exit Action\
    \                Exit State\n   ------------------------+--------------------------+------------\n\
    \   - - - - - - - - - - - - - - -(PAR-PAN exchange) - - - - - - - -\n   Rx:PAR[]\
    \ &&              RtxTimerStop();            WAIT_EAP_MSG\n   !eap_piggyback()\
    \         TxEAP();\n                            EAP_RespTimerStart();\n      \
    \                      if (NONCE_SENT==Unset) {\n                            \
    \  NONCE_SENT=Set;\n                              Tx:PAN[](\"Nonce\");\n     \
    \                       }\n                            else\n                \
    \              Tx:PAN[]();\n   Rx:PAR[] &&              RtxTimerStop();      \
    \      WAIT_EAP_MSG\n   eap_piggyback()          TxEAP();\n                  \
    \          EAP_RespTimerStart();\n   Rx:PAN[]                 RtxTimerStop();\
    \            WAIT_PAA\n   - - - - - - - - - - - - - - - - - - - - - - - - - -\
    \ - - - - - -\n   - - - - - - - - - - - - - - -(PANA result) - - - - - - - - -\
    \ -\n   Rx:PAR[C] &&             TxEAP();                   WAIT_EAP_RESULT\n\
    \   PAR.RESULT_CODE==\n     PANA_SUCCESS\n   Rx:PAR[C] &&             if (PAR.exist_avp\
    \          WAIT_EAP_RESULT_\n   PAR.RESULT_CODE!=          (\"EAP-Payload\"))\
    \         CLOSE\n     PANA_SUCCESS             TxEAP();\n                    \
    \        else\n                               alt_reject();\n   - - - - - - -\
    \ - - - - - - - - - - - - - - - - - - - - - - - - -\n   -------------------\n\
    \   State: WAIT_EAP_MSG\n   -------------------\n   Exit Condition           Exit\
    \ Action                Exit State\n   ------------------------+--------------------------+------------\n\
    \   - - - - - - - - - - (Return PAN/PAR from EAP) - - - - - - - - -\n   EAP_RESPONSE\
    \ &&          EAP_RespTimerStop()        WAIT_PAA\n   eap_piggyback()        \
    \  if (NONCE_SENT==Unset) {\n                              Tx:PAN[](\"EAP-Payload\"\
    ,\n                                       \"Nonce\");\n                      \
    \        NONCE_SENT=Set;\n                            }\n                    \
    \        else\n                              Tx:PAN[](\"EAP-Payload\");\n   EAP_RESPONSE\
    \ &&          EAP_RespTimerStop()        WAIT_PAA\n   !eap_piggyback()       \
    \  Tx:PAR[](\"EAP-Payload\");\n                            RtxTimerStart();\n\
    \   EAP_RESP_TIMEOUT &&      Tx:PAN[]();                WAIT_PAA\n   eap_piggyback()\n\
    \   EAP_DISCARD &&           Tx:PAN[]();                CLOSED\n   eap_piggyback()\
    \          SessionTimerStop();\n                            Disconnect();\n  \
    \ EAP_FAILURE ||           SessionTimerStop();        CLOSED\n   (EAP_DISCARD\
    \ &&          Disconnect();\n   !eap_piggyback())\n   - - - - - - - - - - - -\
    \ - - - - - - - - - - - - - - - - - - - -\n   ----------------------\n   State:\
    \ WAIT_EAP_RESULT\n   ----------------------\n   Exit Condition           Exit\
    \ Action                Exit State\n   ------------------------+--------------------------+------------\n\
    \   - - - - - - - - - - - - - (EAP Result) - - - - - - - - - - - - -\n   EAP_SUCCESS\
    \             if (PAR.exist_avp           OPEN\n                             \
    \ (\"Key-Id\"))\n                             Tx:PAN[C](\"Key-Id\");\n       \
    \                    else\n                             Tx:PAN[C]();\n       \
    \                    Authorize();\n                           SessionTimerReStart\n\
    \                             (LIFETIME_SESS_TIMEOUT);\n   EAP_FAILURE       \
    \      Tx:PAN[C]();                CLOSED\n                           SessionTimerStop();\n\
    \                           Disconnect();\n   - - - - - - - - - - - - - - - -\
    \ - - - - - - - - - - - - - - - -\n   ----------------------------\n   State:\
    \ WAIT_EAP_RESULT_CLOSE\n   ----------------------------\n   Exit Condition  \
    \         Exit Action                Exit State\n   ------------------------+--------------------------+------------\n\
    \   - - - - - - - - - - - - - (EAP Result) - - - - - - - - - - - - -\n   EAP_SUCCESS\
    \ ||          if (EAP_SUCCESS &&         CLOSED\n   EAP_FAILURE              \
    \ PAR.exist_avp(\"Key-Id\"))\n                             Tx:PAN[C](\"Key-Id\"\
    );\n                           else\n                             Tx:PAN[C]();\n\
    \                           SessionTimerStop();\n                           Disconnect();\n\
    \   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n   -----------\n\
    \   State: OPEN\n   -----------\n   Exit Condition           Exit Action     \
    \           Exit State\n   ------------------------+--------------------------+------------\n\
    \   - - - - - - - - - - (liveness test initiated by PaC)- - - - - -\n   PANA_PING\
    \                Tx:PNR[P]();               WAIT_PNA_PING\n                  \
    \          RtxTimerStart();\n   - - - - - - - - - - - - - - - - - - - - - - -\
    \ - - - - - - - - - -\n   - - - - - - - - - (re-authentication initiated by PaC)-\
    \ - - - - -\n   REAUTH                   NONCE_SENT=Unset;          WAIT_PNA_REAUTH\n\
    \                            Tx:PNR[A]();\n                            RtxTimerStart();\n\
    \   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n   - -\
    \ - - - - - - - (re-authentication initiated by PAA)- - - - - -\n   Rx:PAR[] \
    \                EAP_RespTimerStart();      WAIT_EAP_MSG\n                   \
    \         TxEAP();\n                            if (!eap_piggyback())\n      \
    \                        Tx:PAN[](\"Nonce\");\n                            else\n\
    \                              NONCE_SENT=Unset;\n                           \
    \ SessionTimerReStart\n                              (FAILED_SESS_TIMEOUT);\n\
    \   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n   - -\
    \ - - - - - -(Session termination initiated by PAA) - - - - - -\n   Rx:PTR[] \
    \                Tx:PTA[]();                CLOSED\n                         \
    \   SessionTimerStop();\n                            Disconnect();\n   - - - -\
    \ - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n   - - - - - - -\
    \ -(Session termination initiated by PaC) - - - - - -\n   TERMINATE          \
    \      Tx:PTR[]();                SESS_TERM\n                            RtxTimerStart();\n\
    \                            SessionTimerStop();\n   - - - - - - - - - - - - -\
    \ - - - - - - - - - - - - - - - - - - - -\n   ----------------------\n   State:\
    \ WAIT_PNA_REAUTH\n   ----------------------\n   Exit Condition           Exit\
    \ Action                Exit State\n   ------------------------+--------------------------+------------\n\
    \   - - - - - - - - -(re-authentication initiated by PaC) - - - - -\n   Rx:PNA[A]\
    \                RtxTimerStop();            WAIT_PAA\n                       \
    \     SessionTimerReStart\n                              (FAILED_SESS_TIMEOUT);\n\
    \   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n   - - -\
    \ - - - - -(Session termination initiated by PAA) - - - - - -\n   Rx:PTR[]   \
    \              RtxTimerStop();            CLOSED\n                           \
    \ Tx:PTA[]();\n                            SessionTimerStop();\n             \
    \               Disconnect();\n   - - - - - - - - - - - - - - - - - - - - - -\
    \ - - - - - - - - - -\n   --------------------\n   State: WAIT_PNA_PING\n   --------------------\n\
    \   Exit Condition           Exit Action                Exit State\n   ------------------------+--------------------------+------------\n\
    \   - - - - - - - - -(liveness test initiated by PaC) - - - - - - -\n   Rx:PNA[P]\
    \                RtxTimerStop();            OPEN\n   - - - - - - - - - - - - -\
    \ - - - - - - - - - - - - - - - - - - -\n   - - - - - - - - - (re-authentication\
    \ initiated by PAA)- - - - -\n   Rx:PAR[]                 RtxTimerStop();    \
    \        WAIT_EAP_MSG\n                            EAP_RespTimerStart();\n   \
    \                         TxEAP();\n                            if (!eap_piggyback())\n\
    \                              Tx:PAN[](\"Nonce\");\n                        \
    \    else\n                              NONCE_SENT=Unset;\n                 \
    \           SessionTimerReStart\n                              (FAILED_SESS_TIMEOUT);\n\
    \   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n   - -\
    \ - - - - - -(Session termination initiated by PAA) - - - - - -\n   Rx:PTR[] \
    \                RtxTimerStop();            CLOSED\n                         \
    \   Tx:PTA[]();\n                            SessionTimerStop();\n           \
    \                 Disconnect();\n   - - - - - - - - - - - - - - - - - - - - -\
    \ - - - - - - - - - - - -\n   ----------------\n   State: SESS_TERM\n   ----------------\n\
    \   Exit Condition           Exit Action                Exit State\n   ------------------------+--------------------------+------------\n\
    \   - - - - - - - -(Session termination initiated by PaC) - - - - -\n   Rx:PTA[]\
    \                 Disconnect();              CLOSED\n   - - - - - - - - - - -\
    \ - - - - - - - - - - - - - - - - - - - - -\n"
- title: 8.  PAA State Machine
  contents:
  - '8.  PAA State Machine

    '
- title: 8.1.  Interface between PAA and EAP Authenticator
  contents:
  - "8.1.  Interface between PAA and EAP Authenticator\n   The interface between a\
    \ PAA and an EAP authenticator provides a\n   mechanism to deliver EAP messages\
    \ for the EAP authenticator as well\n   as a mechanism to notify the EAP authenticator\
    \ of PAA events and to\n   receive notification of EAP authenticator events. \
    \ These message\n   delivery and event notification mechanisms occur only within\
    \ context\n   of their associated states or exit actions.\n"
- title: 8.1.1.  EAP Restart Notification from PAA to EAP Authenticator
  contents:
  - "8.1.1.  EAP Restart Notification from PAA to EAP Authenticator\n   An EAP authenticator\
    \ state machine defined in [RFC4137] has an\n   initialization procedure before\
    \ sending the first EAP request.  To\n   initialize the EAP state machine, the\
    \ PAA state machine defines an\n   event notification mechanism to send an EAP\
    \ (re)start event to the\n   EAP authenticator.  The event notification is done\
    \ via EAP_Restart()\n   procedure in the initialization action of the PAA state\
    \ machine.\n"
- title: 8.1.2.  Delivering EAP Responses from PAA to EAP Authenticator
  contents:
  - "8.1.2.  Delivering EAP Responses from PAA to EAP Authenticator\n   TxEAP() procedure\
    \ in the PAA state machine serves as the mechanism to\n   deliver EAP-Responses\
    \ contained in PANA-Auth-Answer messages to the\n   EAP authenticator.  This procedure\
    \ is enabled only after an EAP\n   restart event is notified to the EAP authenticator\
    \ and before any\n   event resulting in a termination of the EAP authenticator\
    \ session.\n   In the case where the EAP authenticator follows the EAP authenticator\n\
    \   state machines defined in [RFC4137], TxEAP() procedure sets eapResp\n   variable\
    \ of the EAP authenticator state machine and puts the EAP\n   response in eapRespData\
    \ variable of the EAP authenticator state\n   machine.\n"
- title: 8.1.3.  Delivering EAP Messages from EAP Authenticator to PAA
  contents:
  - "8.1.3.  Delivering EAP Messages from EAP Authenticator to PAA\n   An EAP request\
    \ is delivered from the EAP authenticator to the PAA via\n   EAP_REQUEST event\
    \ variable.  The event variable is set when the EAP\n   authenticator passes the\
    \ EAP request to its lower layer.  In the case\n   where the EAP authenticator\
    \ follows the EAP authenticator state\n   machines defined in [RFC4137], EAP_REQUEST\
    \ event variable refers to\n   eapReq variable of the EAP authenticator state\
    \ machine and the EAP\n   request is contained in eapReqData variable of the EAP\
    \ authenticator\n   state machine.\n"
- title: 8.1.4.  EAP Authentication Result Notification from EAP Authenticator to
  contents:
  - "8.1.4.  EAP Authentication Result Notification from EAP Authenticator to\n  \
    \      PAA\n   In order for the EAP authenticator to notify the PAA of the EAP\n\
    \   authentication result, EAP_SUCCESS, EAP_FAILURE, and EAP_TIMEOUT\n   event\
    \ variables are defined.  In the case where the EAP authenticator\n   follows\
    \ the EAP authenticator state machines defined in [RFC4137],\n   EAP_SUCCESS,\
    \ EAP_FAILURE, and EAP_TIMEOUT event variables refer to\n   eapSuccess, eapFail,\
    \ and eapTimeout variables of the EAP\n   authenticator state machine, respectively.\
    \  In this case, if\n   EAP_SUCCESS event variable is set to TRUE, an EAP-Success\
    \ message is\n   contained in eapReqData variable of the EAP authenticator state\n\
    \   machine, and additionally, eapKeyAvailable variable is set to TRUE\n   and\
    \ eapKeyData variable contains an MSK if the MSK is generated as a\n   result\
    \ of successful authentication by the EAP authentication method\n   in use.  Similarly,\
    \ if EAP_FAILURE event variable is set to TRUE, an\n   EAP-Failure message is\
    \ contained in eapReqData variable of the EAP\n   authenticator state machine.\
    \  The PAA uses EAP_SUCCESS and\n   EAP_FAILURE event variables as a trigger to\
    \ send a PAR message to the\n   PaC.\n"
- title: 8.2.  Variables
  contents:
  - "8.2.  Variables\n   OPTIMIZED_INIT\n      This variable indicates whether the\
    \ PAA is able to piggyback an\n      EAP-Request in the initial PANA-Auth-Request.\
    \  Otherwise, it is\n      set to FALSE.\n   PAC_FOUND\n      This variable is\
    \ set to TRUE as a result of a PAA-initiated\n      handshake.\n   REAUTH_TIMEOUT\n\
    \      This event variable is set to TRUE to indicate that the PAA\n      initiates\
    \ a re-authentication with the PaC.  The re-authentication\n      timeout should\
    \ be set to a value less than the session timeout\n      carried in the Session-Lifetime\
    \ AVP if present.\n   EAP_SUCCESS\n      This event variable is set to TRUE when\
    \ an EAP conversation\n      completes with success.  This event accompanies an\
    \ EAP-Success\n      message passed from the EAP authenticator.\n   EAP_FAILURE\n\
    \      This event variable is set to TRUE when an EAP conversation\n      completes\
    \ with failure.  This event accompanies an EAP-Failure\n      message passed from\
    \ the EAP authenticator.\n   EAP_REQUEST\n      This event variable is set to\
    \ TRUE when the EAP authenticator\n      delivers an EAP Request to the PAA. \
    \ This event accompanies an\n      EAP-Request message received from the EAP authenticator.\n\
    \   EAP_TIMEOUT\n      This event variable is set to TRUE when an EAP conversation\
    \ times\n      out without generating an EAP-Success or an EAP-Failure message.\n\
    \      This event does not accompany any EAP message.\n   EAP_DISCARD\n      This\
    \ event variable is set to TRUE when the EAP authenticator\n      indicates that\
    \ it has silently discarded the last received EAP-\n      Response message.  This\
    \ event does not accompany any EAP message.\n      In the case where the EAP authenticator\
    \ follows the EAP\n      authenticator state machines defined in [RFC4137], this\
    \ event\n      variable refers to eapNoReq.\n"
- title: 8.3.  Procedures
  contents:
  - "8.3.  Procedures\n   boolean new_key_available()\n      This is a procedure to\
    \ check whether the PANA session has a new\n      PANA_AUTH_KEY.  If the state\
    \ machine already has a PANA_AUTH_KEY,\n      it returns FALSE.  If the state\
    \ machine does not have a\n      PANA_AUTH_KEY, it tries to retrieve an MSK from\
    \ the EAP entity.\n      If an MSK has been retrieved, it computes a PANA_AUTH_KEY\
    \ from the\n      MSK and returns TRUE.  Otherwise, it returns FALSE.\n"
- title: 8.4.  PAA State Transition Table
  contents:
  - "8.4.  PAA State Transition Table\n   ------------------------------\n   State:\
    \ INITIAL (Initial State)\n   ------------------------------\n   Initialization\
    \ Action:\n     OPTIMIZED_INIT=Set|Unset;\n     NONCE_SENT=Unset;\n     RTX_COUNTER=0;\n\
    \     RtxTimerStop();\n   Exit Condition           Exit Action               \
    \ Exit State\n   ------------------------+--------------------------+------------\n\
    \    - - - - - - - - (PCI and PAA initiated PANA) - - - - - - - - -\n   (Rx:PCI[]\
    \ ||             if (OPTIMIZED_INIT ==      INITIAL\n    PAC_FOUND)          \
    \        Set) {\n                              EAP_Restart();\n              \
    \                SessionTimerReStart\n                               (FAILED_SESS_TIMEOUT);\n\
    \                            }\n                            else {\n         \
    \                     if (generate_pana_sa())\n                              \
    \     Tx:PAR[S](\"PRF-Algorithm\",\n                                      \"Integrity-Algorithm\"\
    );\n                              else\n                                   Tx:PAR[S]();\n\
    \                            }\n   EAP_REQUEST              if (generate_pana_sa())\
    \    INITIAL\n                                Tx:PAR[S](\"EAP-Payload\",\n   \
    \                                \"PRF-Algorithm\",\n                        \
    \           \"Integrity-Algorithm\");\n                            else\n    \
    \                            Tx:PAR[S](\"EAP-Payload\");\n                   \
    \         RtxTimerStart();\n   - - - - - - - - - - - - - - - - - - - - - - - -\
    \ - - - - - - - -\n   - - - - - - - - - - - - - - (PAN Handling)  - - - - - -\
    \ - - - -\n   Rx:PAN[S] &&             if (PAN.exist_avp          WAIT_EAP_MSG\n\
    \   ((OPTIMIZED_INIT ==         (\"EAP-Payload\"))\n     Unset) ||           \
    \     TxEAP();\n   PAN.exist_avp            else {\n     (\"EAP-Payload\"))  \
    \       EAP_Restart();\n                              SessionTimerReStart\n  \
    \                             (FAILED_SESS_TIMEOUT);\n                       \
    \     }\n   Rx:PAN[S] &&             None();                    WAIT_PAN_OR_PAR\n\
    \   (OPTIMIZED_INIT ==\n     Set) &&\n   ! PAN.exist_avp\n    (\"EAP-Payload\"\
    )\n   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n   -------------------\n\
    \   State: WAIT_EAP_MSG\n   -------------------\n   Exit Condition           Exit\
    \ Action                Exit State\n   ------------------------+--------------------------+------------\n\
    \   - - - - - - - - - - - -(Receiving EAP-Request)- - - - - - - - -\n   EAP_REQUEST\
    \              if (NONCE_SENT==Unset) {   WAIT_PAN_OR_PAR\n                  \
    \            Tx:PAR[](\"Nonce\",\n                                       \"EAP-Payload\"\
    );\n                              NONCE_SENT=Set;\n                          \
    \  }\n                            else\n                              Tx:PAR[](\"\
    EAP-Payload\");\n                            RtxTimerStart();\n   - - - - - -\
    \ - - - - - - - - - - - - - - - - - - - - - - - - - -\n   - - - - - - - - - -\
    \ -(Receiving EAP-Success/Failure) - - - - -\n   EAP_FAILURE              PAR.RESULT_CODE\
    \ =          WAIT_FAIL_PAN\n                              PANA_AUTHENTICATION_\n\
    \                                  REJECTED;\n                            Tx:PAR[C](\"\
    EAP-Payload\");\n                            RtxTimerStart();\n              \
    \              SessionTimerStop();\n   EAP_SUCCESS &&           PAR.RESULT_CODE\
    \ =          WAIT_SUCC_PAN\n   Authorize()                PANA_SUCCESS;\n    \
    \                        if (new_key_available())\n                          \
    \    Tx:PAR[C](\"EAP-Payload\",\n                                   \"Key-Id\"\
    );\n                            else\n                              Tx:PAR[C](\"\
    EAP-Payload\");\n                            RtxTimerStart();\n   EAP_SUCCESS\
    \ &&           PAR.RESULT_CODE =          WAIT_FAIL_PAN\n   !Authorize()     \
    \          PANA_AUTHORIZATION_\n                                REJECTED;\n  \
    \                          if (new_key_available())\n                        \
    \      Tx:PAR[C](\"EAP-Payload\",\n                                   \"Key-Id\"\
    );\n                            else\n                              Tx:PAR[C](\"\
    EAP-Payload\");\n                            RtxTimerStart();\n   - - - - - -\
    \ - - - - - - - - - - - - - - - - - - - - - - - - - -\n    - - - - - (Receiving\
    \ EAP-Timeout or invalid message) - - - - -\n   EAP_TIMEOUT ||           SessionTimerStop();\
    \        CLOSED\n   EAP_DISCARD              Disconnect();\n   - - - - - - - -\
    \ - - - - - - - - - - - - - - - - - - - - - - - -\n   --------------------\n \
    \  State: WAIT_SUCC_PAN\n   --------------------\n   Event/Condition         \
    \ Action                     Exit State\n   ------------------------+--------------------------+------------\n\
    \   - - - - - - - - - - - - - (PAN Processing)- - - - - - - - - - -\n   Rx:PAN[C]\
    \                RtxTimerStop();            OPEN\n                           \
    \ SessionTimerReStart\n                              (LIFETIME_SESS_TIMEOUT);\n\
    \   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n   --------------------\n\
    \   State: WAIT_FAIL_PAN\n   --------------------\n   Exit Condition         \
    \  Exit Action                Exit State\n   ------------------------+--------------------------+------------\n\
    \   - - - - - - - - - - - - - - (PAN Processing)- - - - - - - - - -\n   Rx:PAN[C]\
    \                RtxTimerStop();            CLOSED\n                         \
    \   Disconnect();\n   - - - - - - - - - - - - - - - - - - - - - - - - - - - -\
    \ - - - -\n   -----------\n   State: OPEN\n   -----------\n   Event/Condition\
    \          Action                     Exit State\n   ------------------------+--------------------------+------------\n\
    \   - - - - - - - - (re-authentication initiated by PaC) - - - - - -\n   Rx:PNR[A]\
    \                NONCE_SENT=Unset;          WAIT_EAP_MSG\n                   \
    \         EAP_Restart();\n                            Tx:PNA[A]();\n   - - - -\
    \ - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n   - - - - - - - -\
    \ (re-authentication initiated by PAA)- - - - - -\n   REAUTH ||              \
    \  NONCE_SENT=Unset;          WAIT_EAP_MSG\n   REAUTH_TIMEOUT           EAP_Restart();\n\
    \   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n   - - (liveness\
    \ test based on PNR-PNA exchange initiated by PAA)-\n   PANA_PING            \
    \    Tx:PNR[P]();               WAIT_PNA_PING\n                            RtxTimerStart();\n\
    \   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n   - - -\
    \ - - - - - (Session termination initiated from PAA)- - - -\n   TERMINATE    \
    \            Tx:PTR[]();                SESS_TERM\n                          \
    \  SessionTimerStop();\n                            RtxTimerStart();\n   - - -\
    \ - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n   - - - - - - -\
    \ - (Session termination initiated from PaC)- - - -\n   Rx:PTR[]             \
    \    Tx:PTA[]();                CLOSED\n                            SessionTimerStop();\n\
    \                            Disconnect();\n   - - - - - - - - - - - - - - - -\
    \ - - - - - - - - - - - - - - - -\n   --------------------\n   State: WAIT_PNA_PING\n\
    \   --------------------\n   Exit Condition           Exit Action            \
    \    Exit State\n   ------------------------+--------------------------+------------\n\
    \   - - - - - - - - - - - - - -(PNA processing) - - - - - - - - - -\n   Rx:PNA[P]\
    \                RtxTimerStop();            OPEN\n   - - - - - - - - - - - - -\
    \ - - - - - - - - - - - - - - - - - - -\n   - - - - - - - - (re-authentication\
    \ initiated by PaC) - - - - - -\n   Rx:PNR[A]                RtxTimerStop(); \
    \           WAIT_EAP_MSG\n                            NONCE_SENT=Unset;\n    \
    \                        EAP_Restart();\n                            Tx:PNA[A]();\n\
    \   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n   - - -\
    \ - - - - - (Session termination initiated from PaC)- - - -\n   Rx:PTR[]     \
    \            RtxTimerStop();            CLOSED\n                            Tx:PTA[]();\n\
    \                            SessionTimerStop();\n                           \
    \ Disconnect();\n   - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\
    \ - - -\n   ----------------------\n   State: WAIT_PAN_OR_PAR\n   ----------------------\n\
    \   Exit Condition           Exit Action                Exit State\n   ------------------------+--------------------------+------------\n\
    \   - - - - - - - - - - - - - (PAR Processing)- - - - - - - - - - -\n   Rx:PAR[]\
    \                 TxEAP();                   WAIT_EAP_MSG\n                  \
    \          RtxTimerStop();\n                            Tx:PAN[]();\n   - - -\
    \ - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n   - - - - - - (Pass\
    \ EAP Response to the EAP authenticator)- - - -\n   Rx:PAN[] &&              TxEAP();\
    \                   WAIT_EAP_MSG\n   PAN.exist_avp            RtxTimerStop();\n\
    \   (\"EAP-Payload\")\n   - - - - - - - - - - - - - - - - - - - - - - - - - -\
    \ - - - - - -\n   - - - - - - - - - - (PAN without an EAP response) - - - - -\
    \ - -\n   Rx:PAN[] &&              RtxTimerStop();            WAIT_PAN_OR_PAR\n\
    \   !PAN.exist_avp\n   (\"EAP-Payload\")\n   - - - - - - - - - - - - - - - - -\
    \ - - - - - - - - - - - - - - -\n   - - - - - - - - - - - -(EAP retransmission)\
    \ - - - - - - - - - -\n   EAP_REQUEST              RtxTimerStop();           \
    \ WAIT_PAN_OR_PAR\n                            Tx:PAR[](\"EAP-Payload\");\n  \
    \                          RtxTimerStart();\n   - - - - - - - - - - - - - - -\
    \ - - - - - - - - - - - - - - - - -\n   - - - - - - - (EAP authentication timeout\
    \ or failure)- - - - -\n   EAP_FAILURE ||           RtxTimerStop();          \
    \  CLOSED\n   EAP_TIMEOUT ||           SessionTimerStop();\n   EAP_DISCARD   \
    \           Disconnect();\n   - - - - - - - - - - - - - - - - - - - - - - - -\
    \ - - - - - - - -\n   ----------------\n   State: SESS_TERM\n   ----------------\n\
    \   Exit Condition           Exit Action                Exit State\n   ------------------------+--------------------------+------------\n\
    \   - - - - - - - - - - - - - -(PTA processing) - - - - - - - - - -\n   Rx:PTA[]\
    \                 RtxTimerStop();            CLOSED\n                        \
    \    Disconnect();\n   - - - - - - - - - - - - - - - - - - - - - - - - - - - -\
    \ - - - -\n"
- title: 9.  Implementation Considerations
  contents:
  - '9.  Implementation Considerations

    '
- title: 9.1.  PAA and PaC Interface to Service Management Entity
  contents:
  - "9.1.  PAA and PaC Interface to Service Management Entity\n   In general, it is\
    \ assumed that each device or network equipment has a\n   PANA protocol stack\
    \ available for use by other modules within the\n   device or network equipment.\
    \  One such module is the Service\n   Management Entity (SME).  The SME is a generic\
    \ term for modules that\n   manage different services (including network protocols)\
    \ that are\n   installed on a device or equipment.  To integrate the PANA protocol\n\
    \   with the SME, it is recommended that a generic interface (i.e., the\n   SME-PANA\
    \ interface) between the SME and the PANA protocol stack be\n   provided by the\
    \ implementation.  This interface should include common\n   procedures such as\
    \ startup, shutdown, and re-authenticate signals.\n   It should also provide for\
    \ extracting keying material.  For the PAA,\n   the SME-PANA interface should\
    \ also provide a method for communicating\n   filtering parameters to the Enforcement\
    \ Point(s) when cryptographic\n   filtering is used.  The filtering parameters\
    \ include keying material\n   used for bootstrapping secured transport such as\
    \ IPsec.  When a PAA\n   device interacts with the backend authentication server\
    \ using a AAA\n   protocol, its SME may also provide an interface to the AAA protocol\n\
    \   to obtain authorization parameters such as the authorization lifetime\n  \
    \ and additional filtering parameters.\n"
- title: 10.  Security Considerations
  contents:
  - "10.  Security Considerations\n   This document's intent is to describe the PANA\
    \ state machines fully.\n   To this end, any security concerns with this document\
    \ are likely a\n   reflection of security concerns with PANA itself.\n"
- title: 11.  Acknowledgments
  contents:
  - "11.  Acknowledgments\n   This work was started from state machines originally\
    \ made by Dan\n   Forsberg.\n"
- title: 12.  References
  contents:
  - '12.  References

    '
- title: 12.1.  Normative References
  contents:
  - "12.1.  Normative References\n   [RFC5191]  Forsberg, D., Ohba, Y., Patil, B.,\
    \ Tschofenig, H., and A.\n              Yegin, \"Protocol for Carrying Authentication\
    \ for Network\n              Access (PANA)\", RFC 5191, May 2008.\n"
- title: 12.2.  Informative References
  contents:
  - "12.2.  Informative References\n   [RFC4137]  Vollbrecht, J., Eronen, P., Petroni,\
    \ N., and Y. Ohba,\n              \"State Machines for Extensible Authentication\
    \ Protocol\n              (EAP) Peer and Authenticator\", RFC 4137, August 2005.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Victor Fajardo (editor)\n   Telcordia Technologies\n \
    \  1 Telcordia Drive\n   Piscataway, NJ  08854\n   USA\n   Phone: +1 732 699 5368\n\
    \   EMail: vfajardo@research.telcordia.com\n   Yoshihiro Ohba\n   Toshiba Corporate\
    \ Research and Development Center\n   1 Komukai-Toshiba-cho, Saiwai-ku\n   Kawasaki,\
    \ Kanagawa  212-8582\n   Japan\n   Phone: +81 44 549 2230\n   EMail: yoshihiro.ohba@toshiba.co.jp\n\
    \   Rafa Marin-Lopez\n   University of Murcia\n   Campus de Espinardo S/N, Facultad\
    \ de Informatica\n   Murcia  30100\n   Spain\n   Phone: +34 868 888 501\n   EMail:\
    \ rafa@um.es\n"
