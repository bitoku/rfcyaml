- title: __initial_text__
  contents:
  - '                Requirements for Federated File Systems

    '
- title: Abstract
  contents:
  - "Abstract\n   This document describes and lists the functional requirements of\
    \ a\n   federated file system and defines related terms.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It represents the consensus\
    \ of the IETF community.  It has\n   received public review and has been approved\
    \ for publication by the\n   Internet Engineering Steering Group (IESG).  Not\
    \ all documents\n   approved by the IESG are a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc5716.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2010 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n   This document\
    \ may contain material from IETF Documents or IETF\n   Contributions published\
    \ or made publicly available before November\n   10, 2008.  The person(s) controlling\
    \ the copyright in some of this\n   material may not have granted the IETF Trust\
    \ the right to allow\n   modifications of such material outside the IETF Standards\
    \ Process.\n   Without obtaining an adequate license from the person(s) controlling\n\
    \   the copyright in such materials, this document may not be modified\n   outside\
    \ the IETF Standards Process, and derivative works of it may\n   not be created\
    \ outside the IETF Standards Process, except to format\n   it for publication\
    \ as an RFC or to translate it into languages other\n   than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Overview ........................................................3\n\
    \      1.1. Requirements Language ......................................4\n  \
    \ 2. Purpose .........................................................5\n   3.\
    \ Examples and Discussion .........................................5\n      3.1.\
    \ Create a Fileset and Its FSL(s) ............................5\n           3.1.1.\
    \ Creating a Fileset and an FSN .......................6\n           3.1.2. Adding\
    \ a Replica of a Fileset .......................6\n      3.2. Junction Resolution\
    \ ........................................7\n      3.3. Junction Creation ..........................................9\n\
    \   4. Glossary ........................................................9\n  \
    \ 5. Proposed Requirements ..........................................11\n    \
    \  5.1. Basic Assumptions .........................................11\n      5.2.\
    \ Requirements ..............................................14\n   6. Non-Requirements\
    \ ...............................................20\n   7. Security Considerations\
    \ ........................................21\n   8. References .....................................................22\n\
    \      8.1. Normative References ......................................22\n  \
    \    8.2. Informative References ....................................23\n   Appendix\
    \ A.  Acknowledgments ......................................25\n"
- title: 1.  Overview
  contents:
  - "1.  Overview\n   This document describes and lists the functional requirements\
    \ of a\n   federated file system and defines related terms.\n   We do not describe\
    \ the mechanisms that might be used to implement\n   this functionality except\
    \ in cases where specific mechanisms, in our\n   opinion, follow inevitably from\
    \ the requirements.  Our focus is on\n   the interfaces between the entities of\
    \ the system, not on the\n   protocols or their implementations.\n   Today, there\
    \ are collections of fileservers that inter-operate to\n   provide a single namespace\
    \ comprised of filesystem resources provided\n   by different members of the collection,\
    \ joined together with inter-\n   filesystem references.  The namespace can either\
    \ be assembled at the\n   fileservers, the clients, or by an external namespace\
    \ service, and is\n   often not easy or uniform to manage.  The requirements in\
    \ this\n   document are meant to lead to a uniform server-based namespace that\n\
    \   is capable of spanning a whole enterprise and that is easy to manage.\n  \
    \ We define some terms to better describe the solution space.  A\n   \"fileset\"\
    \ is the abstract view of a filesystem in a uniform\n   namespace, and may be\
    \ implemented behind that abstraction by one or\n   more physical filesystems\
    \ at any given time.  Each fileset has a name\n   called an \"FSN\" (fileset name),\
    \ and each physical filesystem has a\n   fileset location (\"FSL\").  A fileset\
    \ is a directory tree containing\n   files and directories, and it may also contain\
    \ references to other\n   filesets.  These references are called \"junctions\"\
    .  To provide\n   location independence, a junction does not contain information\
    \ about\n   the location of the real resource(s), but instead contains an FSN\n\
    \   that can be used to look up the location information.  The service\n   that\
    \ can be used to map from the FSN to the FSL(s) is called a\n   namespace database\
    \ (NSDB) service.  The NSDB provides a level of\n   indirection from the virtual\
    \ paths in the uniform namespace to the\n   actual locations of files.  By design,\
    \ the NSDB does not store the\n   junctions.  This allows junction administration\
    \ and NSDB\n   administration to be separate roles.\n   The servers direct clients\
    \ to the proper locations by existing\n   mechanisms (e.g., the referrals mechanism\
    \ within [RFC3530] and\n   [RFC5661]).  Updates to the locations make it possible\
    \ to support\n   migration and replication of physical filesystems that comprise\
    \ the\n   namespace, in a way that is transparent to filesystem applications.\n\
    \   Figure 1 shows an example of a federation.  This federation has two\n   members,\
    \ named ALPHA and BETA.  Federation members may contain an\n   arbitrary number\
    \ of fileservers and NSDB nodes; in this illustration,\n   ALPHA and BETA each\
    \ have three servers, one NSDB node, and are\n   administered separately.\n  \
    \    +----------------------+       +----------------------+\n      |  Federation\
    \ Member   |       |  Federation Member   |\n      |        ALPHA         |  \
    \     |         BETA         |\n      |                      |       |       \
    \               |\n      |                      |       |                    \
    \  |\n      |    +------------+    |       |    +------------+    |\n      | \
    \   |    NSDB    |    |       |    |    NSDB    |    |\n      |    |         \
    \   |    |       |    |            |    |\n      |    +------------+    |    \
    \   |    +------------+    |\n      |                      |       |         \
    \             |\n      |                      |       |                      |\n\
    \      |                      |       |                      |\n      |      \
    \   +----------+ |       |         +----------+ |\n      |         |         \
    \ | |       |         |          | |\n      |     +-- | Servers  | |       | \
    \    +-- | Servers  | |\n      |     |   |          | |       |     |   |    \
    \      | |\n      | +-- |   |          | |       | +-- |   |          | |\n  \
    \    | |   |   +----------+ |       | |   |   +----------+ |\n      | |   |  \
    \        |     |       | |   |          |     |\n      | |   +----------+    \
    \ |       | |   +----------+     |\n      | |          |         |       | | \
    \         |         |\n      | +----------+         |       | +----------+   \
    \      |\n      +----------------------+       +----------------------+\n    \
    \                             Figure 1\n"
- title: 1.1.  Requirements Language
  contents:
  - "1.1.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in [RFC2119].\n   Note that this is a requirements document, and in many instances\n\
    \   where these words are used in this document they refer to qualities\n   of\
    \ a specification for a system that satisfies the document, or\n   requirements\
    \ of a system that matches that specification.  These\n   cases are distinguished\
    \ when there is potential for ambiguity.\n"
- title: 2.  Purpose
  contents:
  - "2.  Purpose\n   Our objective is to specify a set of protocols by which fileservers\n\
    \   or collections of fileservers, with different administrators, can\n   form\
    \ a federation of fileservers and NSDB nodes that provides a\n   namespace composed\
    \ of the filesets hosted on the different\n   fileservers and fileserver collections.\n\
    \   It should be possible, using a system that implements the protocols,\n   to\
    \ share a common namespace across all the fileservers in the\n   federation. \
    \ It should also be possible for different fileservers in\n   the federation to\
    \ project different namespaces and enable clients to\n   traverse them.\n   Such\
    \ a federation may contain an arbitrary number of NSDB nodes, each\n   belonging\
    \ to a different administrative entity, and each providing\n   the mappings that\
    \ define a part of a namespace.  Such a federation\n   may also have an arbitrary\
    \ number of administrative entities, each\n   responsible for administering a\
    \ subset of the fileservers and NSDB\n   nodes.  Acting in concert, the administrators\
    \ should be able to build\n   and administer this multi-fileserver, multi-collection\
    \ namespace.\n   It is not the intent of the federation to guarantee namespace\n\
    \   consistency across all client views.  Since different parts of the\n   namespace\
    \ may be administered by different entities, it is possible\n   that a client\
    \ could be accessing a stale area of the namespace\n   managed by one entity because\
    \ a part of the namespace above it,\n   managed by another entity, has changed.\n"
- title: 3.  Examples and Discussion
  contents:
  - "3.  Examples and Discussion\n   In this section we provide examples and discussion\
    \ of the basic\n   operations facilitated by the federated file system protocol:\n\
    \   creating a fileset, adding a replica of a fileset, resolving a\n   junction,\
    \ and creating a junction.\n"
- title: 3.1.  Create a Fileset and Its FSL(s)
  contents:
  - "3.1.  Create a Fileset and Its FSL(s)\n   A fileset is the abstraction of a set\
    \ of files and the directory tree\n   that contains them.  The fileset abstraction\
    \ is the fundamental unit\n   of data management in the federation.  This abstraction\
    \ is\n   implemented by an actual directory tree whose root location is\n   specified\
    \ by a fileset location (FSL).\n   In this section, we describe the basic requirements\
    \ for starting with\n   a directory tree and creating a fileset that can be used\
    \ in the\n   federation protocols.  Note that we do not assume that the process\
    \ of\n   creating a fileset requires any transformation of the files or the\n\
    \   directory hierarchy.  The only thing that is required by this process\n  \
    \ is assigning the fileset a fileset name (FSN) and expressing the\n   location(s)\
    \ of the implementation of the fileset as FSL(s).\n   There are many possible\
    \ variations to this procedure, depending on\n   how the FSN that binds the FSL\
    \ is created, and whether other replicas\n   of the fileset exist, are known to\
    \ the federation, and need to be\n   bound to the same FSN.\n   It is easiest\
    \ to describe this in terms of how to create the initial\n   implementation of\
    \ the fileset, and then describe how to add replicas.\n"
- title: 3.1.1.  Creating a Fileset and an FSN
  contents:
  - "3.1.1.  Creating a Fileset and an FSN\n   1.  Choose the NSDB node that will\
    \ keep track of the FSL(s) and\n       related information for the fileset.\n\
    \   2.  Request that the NSDB node register a new FSN for the fileset.\n     \
    \  The FSN may either be chosen by the NSDB node or by the server.\n       The\
    \ latter case is used if the fileset is being restored, perhaps\n       as part\
    \ of disaster recovery, and the server wishes to specify\n       the FSN in order\
    \ to permit existing junctions that reference that\n       FSN to work again.\n\
    \       At this point, the FSN exists, but its location is unspecified.\n   3.\
    \  Send the FSN, the local volume path, the export path, and the\n       export\
    \ options for the local implementation of the fileset to the\n       NSDB node.\
    \  Annotations about the FSN or the location may also be\n       sent.\n     \
    \  The NSDB node records this information and creates the initial\n       FSL\
    \ for the fileset.\n"
- title: 3.1.2.  Adding a Replica of a Fileset
  contents:
  - "3.1.2.  Adding a Replica of a Fileset\n   Adding a replica is straightforward:\
    \ the NSDB node and the FSN are\n   already known.  The only remaining step is\
    \ to add another FSL.\n   Note that the federation protocols do not include methods\
    \ for\n   creating or managing replicas: this is assumed to be a platform-\n \
    \  dependent operation (at least at this time).  The only requirement is\n   that\
    \ these fileset replicas be registered and unregistered with the\n   NSDB.\n"
- title: 3.2.  Junction Resolution
  contents:
  - "3.2.  Junction Resolution\n   A fileset may contain references to other filesets.\
    \  These references\n   are represented by junctions.  If a client requests access\
    \ to a\n   fileset object that is a junction, the server resolves the junction\n\
    \   to discover the FSL(s) that implements the referenced fileset.\n   There are\
    \ many possible variations to this procedure, depending on\n   how the junctions\
    \ are represented and how the information necessary\n   to perform resolution\
    \ is represented by the server.\n   Step 4 is the only step that interacts directly\
    \ with the federation\n   protocols.  The rest of the steps may use platform-specific\n\
    \   interfaces.\n   1.  The server determines that the object being accessed is\
    \ a\n       junction.\n   2.  Using the junction, the server does a local lookup\
    \ to find the\n       FSN of the target fileset.\n   3.  Using the FSN, the server\
    \ finds the NSDB node responsible for the\n       target object.\n   4.  The server\
    \ contacts that NSDB node and asks for the set of FSLs\n       that implement\
    \ the target FSN.  The NSDB node responds with a set\n       of FSLs.\n   5. \
    \ The server converts one or more of the FSLs to the location type\n       used\
    \ by the client (e.g., a Network File System (NFSv4)\n       fs_location, as described\
    \ in [RFC3530]).\n   6.  The server redirects (in whatever manner is appropriate\
    \ for the\n       client) the client to the location(s).\n   These steps are illustrated\
    \ in Figure 2.  The client sends request 1\n   to server X, in federation member\
    \ ALPHA, in an attempt to reference\n   an object (which appears to the client\
    \ as a directory).  Server X\n   recognizes that the referenced object is actually\
    \ a junction that\n   refers to a directory in a different fileset.  Server X\
    \ finds, from\n   the FSN in the junction, that the NSDB responsible for knowing\
    \ the\n   location of the target of the junction is the NSDB of federation\n \
    \  member BETA.  Server X sends request 2 to the NSDB of BETA, asking\n   for\
    \ the current location of the directory.  The NSDB sends response 3\n   to server\
    \ X, telling the server that the directory is located on\n   server Y.  Server\
    \ X sends response 4 to the client, indicating that\n   the directory is in a\
    \ \"new\" location on server Y.  The client then\n   sends request 5 to server\
    \ Y, repeating the initial request.\n   Given the current requirements and definitions,\
    \ this resolution\n   method MUST work.  However, there is no requirement that\
    \ this is the\n   only resolution method that can be used.  This method may be\
    \ used as\n   the fallback when all else fails (or, for a simple implementation,\
    \ it\n   could be the only method).  This is a degenerate implementation of\n\
    \   the NSDB service as a simple composition of NSDB nodes; we expect\n   that\
    \ large federations will use more sophisticated methods to share\n   the FSN and\
    \ FSL information among multiple NSDB nodes.\n          +---------------+\n  \
    \        |               |\n          |    Client     | >--------------------------+\n\
    \          |               |                            |\n          +---------------+\
    \                            |\n            v   ^                            \
    \          |\n      +-----+---+-------------+      +-----------------+-----+\n\
    \      |     |   |   Federation|      |Federation       |     |\n      |     |\
    \   |   member    |      |member           |     |\n      |     |   |   ALPHA\
    \     |      |BETA             |     |\n      |     |   |             |      |\
    \                 |     |\n      |     |   |             |      |            \
    \     |     |\n      |     |   |             |      |                 |     |\n\
    \      |     |   |             |      |                 |     |\n      |     |\
    \   |             |      |   +---------+   |     |\n      |     |   |   +---------+------+->\
    \ |         |   |     |\n      |     |   |   |         |      |   | NSDB Y  |\
    \   |     |\n      |     |   |   |   +-----+------+-< |         |   |     |\n\
    \      |     |   |   |   |     |      |   +---------+   |     |\n      |     |\
    \   |   |   |     |      |                 |     |\n      |     |   |   |   |\
    \     |      |                 |     |\n      |     |   |   |   |     |      |\
    \                 |     |\n      |    1|  4|  2|  3|     |      |            \
    \    5|     |\n      |     v   ^   ^   v     |      |                 v     |\n\
    \      |   +---------------+   |      |   +---------------+   |\n      |   | \
    \              |   |      |   |               |   |\n      |   |   Server X  \
    \  |   |      |   |   Server Y    |   |\n      |   |               |   |     \
    \ |   |               |   |\n      |   +---------------+   |      |   +---------------+\
    \   |\n      |                       |      |                       |\n      +-----------------------+\
    \      +-----------------------+\n                                 Figure 2\n"
- title: 3.3.  Junction Creation
  contents:
  - "3.3.  Junction Creation\n   Given a local path and the FSN of a remote fileset,\
    \ an administrator\n   can create a junction from the local path to the remote\
    \ fileset.\n   There are many possible variations to this procedure, depending\
    \ on\n   how the junctions are represented and how the information necessary\n\
    \   to perform resolution is represented by the server.\n   Step 1 is the only\
    \ step that uses the federation interfaces.  The\n   remaining step may use platform-specific\
    \ interfaces.\n   1.  The administrator requests the server create a junction\
    \ to the\n       FSN of the remote fileset at the given path.\n   2.  The server\
    \ inserts the junction to the FSN, at the given path,\n       into the local filesystem.\n"
- title: 4.  Glossary
  contents:
  - "4.  Glossary\n   Administrator:  user with the necessary authority to initiate\n\
    \      administrative tasks on one or more servers.\n   Admin Entity:  A server\
    \ or agent that administers a collection of\n      fileservers and persistently\
    \ stores the namespace information.\n   Client:  Any client that accesses the\
    \ fileserver data using a\n      supported filesystem access protocol.\n   Federation:\
    \  A set of server collections and singleton servers that\n      use a common\
    \ set of interfaces and protocols in order to provide\n      to their clients\
    \ a federated namespace accessible through a\n      filesystem access protocol.\n\
    \   Fileserver:  A server exporting a filesystem via a network filesystem\n  \
    \    access protocol.\n   Fileset:  The abstraction of a set of files and the\
    \ directory tree\n      that contains them.  A fileset is the fundamental unit\
    \ of data\n      management in the federation.\n      Note that all files within\
    \ a fileset are descendants of one\n      directory, and that filesets do not\
    \ span filesystems.\n   Filesystem:  A self-contained unit of export for a fileserver,\
    \ and\n      the mechanism used to implement filesets.  The fileset does not\n\
    \      need to be rooted at the root of the filesystem, nor at the export\n  \
    \    point for the filesystem.\n      A single filesystem MAY implement more than\
    \ one fileset, if the\n      client protocol and the fileserver permit this.\n\
    \   Filesystem Access Protocol:  A network filesystem access protocol\n      such\
    \ as NFSv2 [RFC1094], NFSv3 [RFC1813], NFSv4 [RFC3530], or CIFS\n      (Common\
    \ Internet File System) [MS-SMB] [MS-SMB2] [MS-CIFS].\n   FSL (Fileset Location):\
    \  The location of the implementation of a\n      fileset at a particular moment\
    \ in time.  An FSL MUST be something\n      that can be translated into a protocol-specific\
    \ description of a\n      resource that a client can access directly, such as\
    \ an fs_location\n      (for NFSv4), or share name (for CIFS).  Note that not\
    \ all FSLs\n      need to be explicitly exported as long as they are contained\n\
    \      within an exported path on the fileserver.\n   FSN (Fileset Name):  A platform-independent\
    \ and globally unique name\n      for a fileset.  Two FSLs that implement replicas\
    \ of the same\n      fileset MUST have the same FSN, and if a fileset is migrated\
    \ from\n      one location to another, the FSN of that fileset MUST remain the\n\
    \      same.\n   Junction:  A filesystem object used to link a directory name\
    \ in the\n      current fileset with an object within another fileset.  The\n\
    \      server-side \"link\" from a leaf node in one fileset to the root of\n \
    \     another fileset.\n   Namespace:  A filename/directory tree that a sufficiently\
    \ authorized\n      client can observe.\n   NSDB (Namespace Database) Service:\
    \  A service that maps FSNs to FSLs.\n      The NSDB may also be used to store\
    \ other information, such as\n      annotations for these mappings and their components.\n\
    \   NSDB Node:  The name or location of a server that implements part of\n   \
    \   the NSDB service and is responsible for keeping track of the FSLs\n      (and\
    \ related info) that implement a given partition of the FSNs.\n   Referral:  A\
    \ server response to a client access that directs the\n      client to evaluate\
    \ the current object as a reference to an object\n      at a different location\
    \ (specified by an FSL) in another fileset,\n      and possibly hosted on another\
    \ fileserver.  The client re-attempts\n      the access to the object at the new\
    \ location.\n   Replica:  A replica is a redundant implementation of a fileset.\
    \  Each\n      replica shares the same FSN, but has a different FSL.\n      Replicas\
    \ may be used to increase availability or performance.\n      Updates to replicas\
    \ of the same fileset MUST appear to occur in\n      the same order, and therefore\
    \ each replica is self-consistent at\n      any moment.\n      We do not assume\
    \ that updates to each replica occur\n      simultaneously.  If a replica is offline\
    \ or unreachable, the other\n      replicas may be updated.\n   Server Collection:\
    \  A set of fileservers administered as a unit.  A\n      server collection may\
    \ be administered with vendor-specific\n      software.\n      The namespace provided\
    \ by a server collection could be part of the\n      federated namespace.\n  \
    \ Singleton Server:  A server collection containing only one server; a\n     \
    \ stand-alone fileserver.\n"
- title: 5.  Proposed Requirements
  contents:
  - "5.  Proposed Requirements\n   The phrase \"USING THE FEDERATION INTERFACES\"\
    \ implies that the\n   subsequent requirement must be satisfied, in its entirety,\
    \ via the\n   federation interfaces.\n   Note that the requirements are described\
    \ in terms of correct behavior\n   by all entities.  We do not address the requirements\
    \ of the system in\n   the presence of faults.\n"
- title: 5.1.  Basic Assumptions
  contents:
  - "5.1.  Basic Assumptions\n   Several of the requirements are so fundamental that\
    \ we treat them as\n   basic assumptions; if any of these assumptions are violated,\
    \ the rest\n   of the requirements must be reviewed in their entirety.\n   A1:\
    \  The federation protocols do not require any changes to existing\n        client-facing\
    \ protocols, and MAY be extended to incorporate new\n        client-facing protocols.\n\
    \   A2:  A client SHOULD NOT require any a priori knowledge of the\n        general\
    \ structure or composition of the federation.\n        The client may require\
    \ some specific knowledge in order to find\n        and access an instance of\
    \ the fileset that defines the root of\n        its view of the namespace.  As\
    \ the client traverses the\n        namespace, the client discovers the information\
    \ it needs in\n        order to locate the filesets it accesses.\n   A3:  All\
    \ requirements MUST be satisfiable via the federation\n        protocols and the\
    \ standard protocols used by the fileservers\n        (i.e., NFS, CIFS, DNS, etc.).\n\
    \        USING THE FEDERATION INTERFACES, a federation operation that\n      \
    \  requires an interaction between two (or more) entities that are\n        members\
    \ of the federation MUST be possible without requiring any\n        proprietary\
    \ protocols.\n   A4:  All the entities participating in a federation operation\
    \ MUST be\n        able to authenticate each other.\n        All principals (clients,\
    \ users, administrator of a singleton or\n        server collection, hosts, NSDB\
    \ nodes, etc.) that can assume a\n        role defined by the federation protocol\
    \ can identify themselves\n        to each other via an authentication mechanism.\
    \  This mechanism\n        is not defined or further described in this document.\n\
    \        The authority of a principal to request that a second principal\n   \
    \     perform a specific operation is ultimately determined by the\n        second.\
    \  Authorization may be partitioned by server collection\n        or set of servers\
    \ as well as by operation.  For example, if a\n        user has administrative\
    \ privileges on one server in the\n        federation, this does not imply that\
    \ they have administrative\n        privileges (or, for that matter, any privileges\
    \ whatsoever) on\n        any other server in the federation.\n        In order\
    \ to access the functionality provided by the federation\n        interfaces,\
    \ it may be necessary to have elevated privileges or\n        authorization. \
    \ The authority required by different operations\n        may be different.  For\
    \ example, the authority required to query\n        the NSDB about the FSLs bound\
    \ to an FSN may be different than\n        the authority required to change the\
    \ bindings of that FSN.\n        An operation attempted by an unauthorized entity\
    \ MUST fail in a\n        manner that indicates that the failure was due to insufficient\n\
    \        authorization.\n        This document does not enumerate the authorization\
    \ necessary for\n        any operation.\n   A5:  The federation protocols MUST\
    \ NOT require changes to existing\n        authentication/authorization mechanisms\
    \ in use at the\n        fileservers for client-facing protocols.\n        A user's\
    \ view of the namespace may be limited by the\n        authentication and authorization\
    \ privileges it has on the\n        different fileservers in the federation. \
    \ As such, users may\n        only be able to traverse the parts of the namespace\
    \ to which\n        they have access.\n        The federation protocols do not\
    \ impose any restrictions on how\n        users are represented within the federation.\
    \  For example, a\n        single enterprise could employ a common identity for\
    \ users\n        across the federation.  A grid environment could utilize user\n\
    \        mapping or translations across different administrative domains.\n  \
    \ A6:  In a federated system, we assume that an FSN MUST express, or\n       \
    \ can be used to discover, the following two pieces of\n        information:\n\
    \        1.  The location of the NSDB node that is responsible for\n         \
    \   knowing the filesystem location(s) (FSLs) of the named\n            fileset.\n\
    \            The NSDB node must be specified because there may be many\n     \
    \       NSDB nodes in a federation.  We do not assume that any\n            single\
    \ entity knows the location of all of the NSDB nodes,\n            and therefore\
    \ exhaustive search is not an option.\n            There are several ways in which\
    \ a fileserver can locate the\n            NSDB node responsible for a given fileset.\
    \  One approach,\n            given a DNS infrastructure, is to specify the location\
    \ of\n            the NSDB node by the Fully-Qualified Domain Name (FQDN) of\n\
    \            the server hosting the NSDB node.  Another approach is to\n     \
    \       use a separate DNS-style hierarchy to resolve the location\n         \
    \   of the NSDB node.\n        2.  The FSN identifier.\n            The FSN identifier\
    \ is the index used by the NSDB node to\n            identify the target fileset.\n\
    \            There are several ways to represent FSN identifiers.  One\n     \
    \       approach could use 128-bit Universally Unique IDentifiers\n          \
    \  (UUIDs) as described in [RFC4122].\n        As an example, an FSN could be\
    \ represented by a URL of the form\n        nsdb://nsdb.example.com/UUID where\
    \ nsdb is the scheme name,\n        nsdb.example.com is the FQDN of the server\
    \ hosting the NSDB\n        node, and UUID is the string representation of the\
    \ identifier.\n        Note that it is not assumed that it is always required\
    \ for a\n        server to contact the NSDB node specified by the FSN in order\
    \ to\n        find the FSLs.  The relevant information stored in that NSDB\n \
    \       node may also be cached local to the server or on a proxy NSDB\n     \
    \   node \"near\" the server.\n   A7:  All federation servers and NSDB nodes are\
    \ assumed to execute the\n        federation protocols correctly.  The behavior\
    \ of the federation\n        is undefined in the case of Byzantine behavior by\
    \ any federation\n        server or NSDB node.\n   A8:  The locations of federation\
    \ services (such as NSDBs and FSLs)\n        can be specified in a manner such\
    \ that they can be correctly\n        interpreted by all members of the federation\
    \ that will access\n        them.\n        For example, if an NSDB node is specified\
    \ by an FQDN, then this\n        implies that every member of the federation that\
    \ needs to access\n        this NSDB node can resolve this FQDN to an IP address\
    \ for that\n        NSDB node.  (It is not necessary that the FQDN always resolve\
    \ to\n        the same address; the same service may appear at different\n   \
    \     addresses on different networks.)\n        It is the responsibility of each\
    \ federation member to ensure\n        that the resources it wishes to expose\
    \ have accessible network\n        locations and that the necessary resolution\
    \ mechanisms (i.e.,\n        DNS) are given the necessary data to perform the\
    \ resolution\n        correctly.\n"
- title: 5.2.  Requirements
  contents:
  - "5.2.  Requirements\n   R1:   Requirements of each FSN:\n         a.  Each FSN\
    \ MUST be unique within the scope of its NSDB (so\n             that the FSN is\
    \ globally unique).\n         b.  The FSN MUST be sufficiently descriptive to\
    \ locate an\n             instance of the fileset it names within the federation\
    \ at\n             any time.\n         c.  All FSNs MUST be invariant when their\
    \ underlying\n             filesystems move or are replicated; only mappings from\
    \ FSN\n             to FSL(s) change under these transformations.\n         d.\
    \  All files accessible from the global namespace MUST be part\n             of\
    \ a fileset that has an assigned FSN.\n         Not all filesets in the federation\
    \ are required to have an FSN\n         or be reachable by an FSL.  Only those\
    \ filesets that are the\n         target of a junction (as described in R3) are\
    \ required to have\n         an FSN.\n         The FSN format MAY be of variable\
    \ size.  If the format is\n         variable in size, fileserver implementations\
    \ MAY have a maximum\n         supported FSN size.  By bounding the FSN size,\
    \ some fileserver\n         implementations might be able to efficiently organize\
    \ FSNs in\n         stable storage.  For interoperability, the federation protocols\n\
    \         SHOULD define an FSN size that all fileservers support.\n   R2:   USING\
    \ THE FEDERATION INTERFACES, it MUST be possible to create\n         an FSN for\
    \ a fileset, and it must be possible to bind an FSL to\n         that FSN.  These\
    \ operations are NSDB operations and do not\n         require any action on the\
    \ part of a file server.\n         It is possible to create an FSN for a fileset\
    \ that has not\n         actually been created.  It is also possible to bind a\n\
    \         nonexistent FSL to an FSN.  It is also possible to create a\n      \
    \   fileset without assigning it an FSN.  The binding between an\n         FSN\
    \ and an FSL is defined entirely within the context of the\n         NSDB; the\
    \ servers do not \"know\" whether the filesets they host\n         have been assigned\
    \ FSNs (or, if so, what those FSNs are).\n         The requirement that filesets\
    \ can exist prior to being assigned\n         an FSN and the requirement that\
    \ FSNs can exist independent of\n         filesets are intended to simplify the\
    \ construction of the\n         namespace in a convenient manner.  For example,\
    \ they permit an\n         admin to assign FSNs to existing filesets and thereby\n\
    \         incorporate existing filesets into the namespace.  They also\n     \
    \    permit the structure of the namespace to be defined prior to\n         creation\
    \ of the component filesets.  In either case, it is the\n         responsibility\
    \ of the entity updating the NSDB with FSNs and\n         FSN-to-FSL mappings\
    \ to ensure that the namespace is constructed\n         in a consistent manner.\
    \  (The simplest way to accomplish this\n         is to ensure that the FSN and\
    \ FSN-to-FSL mappings are always\n         recorded in the NSDB prior to the creation\
    \ of any junctions\n         that refer to that FSN.)\n         a.  An administrator\
    \ MAY specify the entire FSN (including both\n             the NSDB node location\
    \ and the identifier) of the newly\n             created FSL, or the administrator\
    \ MAY specify only the NSDB\n             node and have the system choose the\
    \ identifier.\n             The admin can choose to specify the FSN explicitly\
    \ in order\n             to recreate a lost fileset with a given FSN (for example,\n\
    \             as part of disaster recovery).  It is an error to assign an\n  \
    \           FSN that is already in use by an active fileset.\n             Note\
    \ that creating a replica of an existing filesystem is\n             NOT accomplished\
    \ by assigning the FSN of the filesystem you\n             wish to replicate to\
    \ a new filesystem.\n         b.  USING THE FEDERATION INTERFACES, it MUST be\
    \ possible to\n             create a federation FSL by specifying a specific local\n\
    \             volume, path, export path, and export options.\n   R3:   USING THE\
    \ FEDERATION INTERFACES, and given the FSN of a target\n         fileset, it MUST\
    \ be possible to create a junction to that\n         fileset at a named place\
    \ in another fileset.\n         After a junction has been created, clients that\
    \ access the\n         junction transparently interpret it as a reference to the\n\
    \         FSL(s) that implement the FSN associated with the junction.\n      \
    \   a.  It SHOULD be possible to have more than one junction whose\n         \
    \    target is a given fileset.  In other words, it SHOULD be\n             possible\
    \ to mount a fileset at multiple named places.\n         b.  If the fileset in\
    \ which the junction is created is\n             replicated, then the junction\
    \ MUST eventually appear in all\n             of its replicas.\n             The\
    \ operation of creating a junction within a fileset is\n             treated as\
    \ an update to the fileset, and therefore obeys\n             the general rules\
    \ about updates to replicated filesets.\n   R4:   USING THE FEDERATION INTERFACES,\
    \ it MUST be possible to delete\n         a specific junction from a fileset.\n\
    \         If a junction is deleted, clients who are already viewing the\n    \
    \     fileset referred to by the junction after traversing the\n         junction\
    \ MAY continue to view the old namespace.  They might\n         not discover that\
    \ the junction no longer exists (or has been\n         deleted and replaced with\
    \ a new junction, possibly referring to\n         a different FSN).\n        \
    \ After a junction is deleted, another object with the same name\n         (another\
    \ junction, or an ordinary filesystem object) may be\n         created.\n    \
    \     The operation of deleting a junction within a fileset is\n         treated\
    \ as an update to the fileset, and therefore obeys the\n         general rules\
    \ about updates to replicated filesets.\n   R5:   USING THE FEDERATION INTERFACES,\
    \ it MUST be possible to\n         invalidate an FSN.\n         a.  If a junction\
    \ refers to an FSN that is invalid, attempting\n             to traverse the junction\
    \ MUST fail.\n         An FSN that has been invalidated MAY become valid again\
    \ if the\n         FSN is recreated (i.e., as part of a disaster recovery\n  \
    \       process).\n         If an FSN is invalidated, clients who are already\
    \ viewing the\n         fileset named by the FSN MAY continue to view the old\n\
    \         namespace.  They might not discover that the FSN is no longer\n    \
    \     valid until they try to traverse a junction that refers to it.\n   R6: \
    \  USING THE FEDERATION INTERFACES, it MUST be possible to\n         invalidate\
    \ an FSL.\n         a.  An invalid FSL MUST NOT be returned as the result of\n\
    \             resolving a junction.\n         An FSL that has been invalidated\
    \ MAY become valid again if the\n         FSL is recreated (i.e., as part of a\
    \ disaster recovery\n         process).\n         If an FSL is invalidated, clients\
    \ who are already viewing the\n         fileset implemented by the FSL MAY continue\
    \ to use that FSL.\n         They might not discover that the FSL is no longer\
    \ valid until\n         they try to traverse a junction that refers to the fileset\n\
    \         implemented by the FSL.\n         Note that invalidating an FSL does\
    \ not imply that the\n         underlying export or share (depending on the file\
    \ access\n         protocol in use) is changed in any way -- it only changes the\n\
    \         mappings from FSNs to FSLs on the NSDB.\n   R7:   It MUST be possible\
    \ for the federation of servers to provide\n         multiple namespaces.\n  \
    \ R8:   USING THE FEDERATION INTERFACES:\n         a.  It MUST be possible to\
    \ query the fileserver named in an FSL\n             to discover whether a junction\
    \ exists at a given path\n             within that FSL.\n         b.  It MAY be\
    \ possible to query the fileserver named in an FSL\n             to discover the\
    \ junctions, if any, in that FSL.  If this\n             feature is implemented,\
    \ the fileserver SHOULD report each\n             junction's path within the FSL\
    \ and the targeted FSN.\n   R9:   The projected namespace (and the objects named\
    \ by the\n         namespace) MUST be accessible to clients via at least one of\n\
    \         the following standard filesystem access protocols:\n         a.  The\
    \ namespace SHOULD be accessible to clients via versions\n             of the\
    \ CIFS (Common Internet File System) protocol as\n             described in [MS-SMB]\
    \ [MS-SMB2] [MS-CIFS].\n         b.  The namespace SHOULD be accessible to clients\
    \ via the NFSv4\n             protocol as described in [RFC3530].\n         c.\
    \  The namespace SHOULD be accessible to clients via the NFSv3\n             protocol\
    \ as described in [RFC1813].\n         d.  The namespace SHOULD be accessible\
    \ to clients via the NFSv2\n             protocol as described in [RFC1094].\n\
    \         It must be understood that some of these protocols, such as\n      \
    \   NFSv3 and NFSv2, have no innate ability to access a namespace\n         of\
    \ this kind.  Where such protocols have been augmented with\n         other protocols\
    \ and mechanisms (such as autofs or amd for\n         NFSv3) to provide an extended\
    \ namespace, we propose that these\n         protocols and mechanisms may be used,\
    \ or extended, in order to\n         satisfy the requirements given in this document,\
    \ and different\n         clients may use different mechanisms.\n   R10:  USING\
    \ THE FEDERATION INTERFACES, it MUST be possible to modify\n         the NSDB\
    \ mapping from an FSN to a set of FSLs to reflect the\n         migration from\
    \ one FSL to another.\n   R11:  FSL migration SHOULD have little or no impact\
    \ on the clients,\n         but this is not guaranteed across all federation members.\n\
    \         Whether FSL migration is performed transparently depends on\n      \
    \   whether the source and destination servers are able to do so.\n         It\
    \ is the responsibility of the administrator to recognize\n         whether or\
    \ not the migration will be transparent, and advise\n         the system accordingly.\
    \  The federation, in turn, MUST advise\n         the servers to notify their\
    \ clients, if necessary.\n         For example, on some systems, it may be possible\
    \ to migrate a\n         fileset from one system to another with minimal client\
    \ impact\n         because all client-visible metadata (inode numbers, etc.) are\n\
    \         preserved during migration.  On other systems, migration might\n   \
    \      be quite disruptive.\n   R12:  USING THE FEDERATION INTERFACES, it MUST\
    \ be possible to modify\n         the NSDB mapping from an FSN to a set of FSLs\
    \ to reflect the\n         addition/removal of a replica at a given FSL.\n   R13:\
    \  Replication SHOULD have little or no negative impact on the\n         clients.\n\
    \         Whether FSL replication is performed transparently depends on\n    \
    \     whether the source and destination servers are able to do so.\n        \
    \ It is the responsibility of the administrator initiating the\n         replication\
    \ to recognize whether or not the replication will be\n         transparent, and\
    \ advise the federation accordingly.  The\n         federation MUST advise the\
    \ servers to notify their clients, if\n         necessary.\n         For example,\
    \ on some systems, it may be possible to mount any\n         FSL of an FSN read/write,\
    \ while on other systems, there may be\n         any number of read-only replicas\
    \ but only one FSL that can be\n         mounted as read/write.\n   R14:  USING\
    \ THE FEDERATION INTERFACES, it SHOULD be possible to\n         annotate the objects\
    \ and relations managed by the federation\n         protocol with arbitrary name/value\
    \ pairs.\n         These annotations are not used by the federation protocols\
    \ --\n         they are intended for use by higher-level protocols.  For\n   \
    \      example, an annotation that might be useful for a system\n         administrator\
    \ browsing the federation would be the \"owner\" of\n         each FSN (i.e.,\
    \ \"this FSN is for the home directory of Joe\n         Smith\").  As another\
    \ example, the annotations may express hints\n         used by the clients (such\
    \ as priority information for NFSv4.1).\n         Both FSNs and FSLs may be annotated.\
    \  For example, an FSN\n         property might be \"This is Joe Smith's home\
    \ directory\", and an\n         FSL property might be \"This instance of the FSN\
    \ is at the\n         remote backup site\".\n         a.  USING THE FEDERATION\
    \ INTERFACES, it MUST be possible to\n             query the system to find the\
    \ annotations for a junction.\n         b.  USING THE FEDERATION INTERFACES, it\
    \ MUST be possible to\n             query the system to find the annotations for\
    \ an FSN.\n         c.  USING THE FEDERATION INTERFACES, it MUST be possible to\n\
    \             query the system to find the annotations for an FSL.\n   R15:  It\
    \ MUST be possible for the federation to project a namespace\n         with a\
    \ common root.\n         a.  It SHOULD be possible to define a root fileset that\
    \ is\n             exported by one or more fileservers in the federation as\n\
    \             the top level of a namespace.  (Corollary: There is one\n      \
    \       root fileset per namespace and it is possible to support\n           \
    \  multiple namespaces per federation.)\n         b.  It SHOULD be possible for\
    \ a fileserver to locate an NSDB\n             that stores the layout of a root\
    \ fileset.\n         c.  It SHOULD be possible to access, store, and update\n\
    \             information related to a root fileset using the federation\n   \
    \          protocols.\n         d.  It SHOULD be possible to replicate root fileset\
    \ information\n             across multiple repositories.\n         e.  If a root\
    \ fileset is defined, it SHOULD be possible to\n             enable a fileserver\
    \ to export that root fileset for client\n             access.\n         f.  If\
    \ a root fileset is defined, it SHOULD be possible for\n             multiple\
    \ fileservers to project a common root with defined\n             consistency\
    \ semantics.\n         g.  If a root fileset is defined, it SHOULD be stored using\
    \ a\n             compact representation that is compatible with\n           \
    \  heterogeneous fileserver implementations.  The root\n             fileset's\
    \ internal format SHOULD contain enough information\n             to generate\
    \ any attributes, including referrals, required\n             by the standard\
    \ filesystem access protocols in R9.\n"
- title: 6.  Non-Requirements
  contents:
  - "6.  Non-Requirements\n   N1:  It is not necessary for the namespace to be known\
    \ by any\n        specific fileserver.\n        In the same manner that clients\
    \ do not need to have a priori\n        knowledge of the structure of the namespace\
    \ or its mapping onto\n        federation members, the projected namespace can\
    \ exist without\n        individual fileservers knowing the entire organizational\n\
    \        structure, or, indeed, without knowing exactly where in the\n       \
    \ projected namespace the filesets they host exist.\n        Fileservers do need\
    \ to be able to handle referrals from other\n        fileservers, but they do\
    \ not need to know what path the client\n        was accessing when the referral\
    \ was generated.\n   N2:  It is not necessary for updates and accesses to the\
    \ NSDB data to\n        occur in transaction or transaction-like contexts.\n \
    \       One possible requirement that is omitted from our current list\n     \
    \   is that updates and accesses to the data stored in the NSDB (or\n        individual\
    \ NSDB nodes) occur within a transaction context.  We\n        were not able to\
    \ agree whether the benefits of transactions are\n        worth the complexity\
    \ they add (both to the specification and its\n        eventual implementation),\
    \ but this topic is open for discussion.\n        Below is the draft of a proposed\
    \ requirement that provides\n        transactional semantics:\n           There\
    \ MUST be a way to ensure that sequences of operations,\n           including\
    \ observations of the namespace (including finding\n           the locations corresponding\
    \ to a set of FSNs) and changes to\n           the namespace or related data stored\
    \ in the system (including\n           the creation, renaming, or deletion of\
    \ junctions, and the\n           creation, altering, or deletion of mappings between\
    \ FSN and\n           filesystem locations), can be performed in a manner that\n\
    \           provides predictable semantics for the relationship between\n    \
    \       the observed values and the effect of the changes.\n           It MUST\
    \ be possible to protect sequences of operations by\n           transactions with\
    \ NSDB-wide or server-wide Atomicity,\n           Consistency, Isolation, and\
    \ Durability (ACID) semantics.\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   Assuming the Internet threat model, the federated\
    \ resolution\n   mechanism described in this document MUST be implemented in such\
    \ a\n   way to prevent loss of CONFIDENTIALITY, DATA INTEGRITY, and PEER\n   ENTITY\
    \ AUTHENTICATION, as described in [RFC3552].\n   CONFIDENTIALITY may be violated\
    \ if an unauthorized party is able to\n   eavesdrop on the communication between\
    \ authorized servers and NSDB\n   nodes and thereby learn the locations or other\
    \ information about FSNs\n   that they would not be authorized to discover via\
    \ direct queries.\n   DATA INTEGRITY may be compromised if a third party is able\
    \ to\n   undetectably alter the contents of the communication between servers\n\
    \   and NSDB nodes.  PEER ENTITY AUTHENTICATION is defeated if one server\n  \
    \ can masquerade as another server without proper authority, or if an\n   arbitrary\
    \ host can masquerade as a NSDB node.\n   Well-established techniques for providing\
    \ authenticated channels may\n   be used to defeat these attacks, and the protocol\
    \ MUST support at\n   least one of them.\n   For example, if Lightweight Directory\
    \ Access Protocol (LDAP) is used\n   to implement the query mechanism [RFC4510],\
    \ then Transport Layer\n   Security (TLS) may be used to provide both authentication\
    \ and\n   integrity [RFC5246] [RFC4513].  If the query protocol is implemented\n\
    \   on top of Open Network Computing / Remote Procedure Call (ONC/RPC),\n   then\
    \ RPCSEC_GSS may be used to fill the same role [RFC2203]\n   [RFC2743].\n   A\
    \ federation could contain multiple Public Key Infrastructure (PKI)\n   trust\
    \ anchors [RFC5280].  The federation protocols SHOULD define a\n   mechanism for\
    \ managing a fileserver's NSDB trust anchors\n   [TA-MGMT-REQS].  A general purpose\
    \ trust anchor management protocol\n   [TAMP] would be appropriate, though it\
    \ might be desirable for the\n   federation protocols to facilitate trust anchor\
    \ management by, for\n   example, using trust anchor interchange formats [TA-FORMAT].\n\
    \   It is useful to note that the requirements described in this document\n  \
    \ lead naturally to a system with distributed authorization, which has\n   scalability\
    \ and manageability benefits.\n   FSNs are likely to be long-lived resources.\
    \  Therefore, the privilege\n   to create FSNs SHOULD be carefully controlled.\
    \  To assist in\n   determining if an FSN is referenced by a junction somewhere\
    \ in the\n   federation, the NSDB records SHOULD include non-authoritative\n \
    \  informational annotations recording the locations of any such\n   junctions.\
    \  These annotations are non-authoritative because a\n   junction might be created,\
    \ deleted, or modified by an individual that\n   does not have permission to modify\
    \ the NSDB records.\n"
- title: 8.  References
  contents:
  - '8.  References

    '
- title: 8.1.  Normative References
  contents:
  - "8.1.  Normative References\n   [RFC2119]       Bradner, S., \"Key words for use\
    \ in RFCs to Indicate\n                   Requirement Levels\", BCP 14, RFC 2119,\
    \ March 1997.\n   [RFC3530]       Shepler, S., Callaghan, B., Robinson, D., Thurlow,\n\
    \                   R., Beame, C., Eisler, M., and D. Noveck, \"Network\n    \
    \               File System (NFS) version 4 Protocol\", RFC 3530,\n          \
    \         April 2003.\n   [RFC3552]       Rescorla, E. and B. Korver, \"Guidelines\
    \ for Writing\n                   RFC Text on Security Considerations\", BCP 72,\n\
    \                   RFC 3552, July 2003.\n   [RFC4122]       Leach, P., Mealling,\
    \ M., and R. Salz, \"A Universally\n                   Unique IDentifier (UUID)\
    \ URN Namespace\", RFC 4122,\n                   July 2005.\n   [RFC4510]    \
    \   Zeilenga, K., \"Lightweight Directory Access Protocol\n                  \
    \ (LDAP): Technical Specification Road Map\", RFC 4510,\n                   June\
    \ 2006.\n   [RFC5280]       Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,\n\
    \                   Housley, R., and W. Polk, \"Internet X.509 Public Key\n  \
    \                 Infrastructure Certificate and Certificate Revocation\n    \
    \               List (CRL) Profile\", RFC 5280, May 2008.\n   [RFC5661]      \
    \ Shepler, S., Eisler, M., and D. Noveck, \"Network File\n                   System\
    \ Version 4 Minor Version 1\", RFC 5661,\n                   January 2010.\n"
- title: 8.2.  Informative References
  contents:
  - "8.2.  Informative References\n   [MS-CIFS]       Microsoft Corporation, \"Common\
    \ Internet File System\n                   (CIFS) Protocol Specification\", MS-CIFS\
    \ 2.0,\n                   November 2009.\n   [MS-SMB]        Microsoft Corporation,\
    \ \"Server Message Block (SMB)\n                   Protocol Specification\", MS-SMB\
    \ 17.0, November 2009.\n   [MS-SMB2]       Microsoft Corporation, \"Server Message\
    \ Block (SMB)\n                   Version 2 Protocol Specification\", MS-SMB2\
    \ 19.0,\n                   November 2009.\n   [RFC1094]       Nowicki, B., \"\
    NFS: Network File System Protocol\n                   specification\", RFC 1094,\
    \ March 1989.\n   [RFC1813]       Callaghan, B., Pawlowski, B., and P. Staubach,\
    \ \"NFS\n                   Version 3 Protocol Specification\", RFC 1813,\n  \
    \                 June 1995.\n   [RFC2203]       Eisler, M., Chiu, A., and L.\
    \ Ling, \"RPCSEC_GSS\n                   Protocol Specification\", RFC 2203, September\
    \ 1997.\n   [RFC2743]       Linn, J., \"Generic Security Service Application\n\
    \                   Program Interface Version 2, Update 1\", RFC 2743,\n     \
    \              January 2000.\n   [RFC4513]       Harrison, R., \"Lightweight Directory\
    \ Access Protocol\n                   (LDAP): Authentication Methods and Security\n\
    \                   Mechanisms\", RFC 4513, June 2006.\n   [RFC5246]       Dierks,\
    \ T. and E. Rescorla, \"The Transport Layer\n                   Security (TLS)\
    \ Protocol Version 1.2\", RFC 5246,\n                   August 2008.\n   [TA-FORMAT]\
    \     Housley, R., Ashmore, S., and C. Wallace, \"Trust\n                   Anchor\
    \ Format\", Work in Progress, October 2009.\n   [TA-MGMT-REQS]  Reddy, R. and\
    \ C. Wallace, \"Trust Anchor Management\n                   Requirements\", Work\
    \ in Progress, September 2009.\n   [TAMP]          Housley, R., Ashmore, S., and\
    \ C. Wallace, \"Trust\n                   Anchor Management Protocol (TAMP)\"\
    , Work in Progress,\n                   December 2009.\n"
- title: Appendix A.  Acknowledgments
  contents:
  - "Appendix A.  Acknowledgments\n   We would like to thank Robert Thurlow of Sun\
    \ Microsystems for helping\n   to author this document.\n   We would also like\
    \ to thank Peter McCann and Nicolas Williams for\n   their comments and suggestions.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   James Lentini\n   NetApp\n   1601 Trapelo Rd, Suite 16\n\
    \   Waltham, MA  02451\n   US\n   Phone: +1 781-768-5359\n   EMail: jlentini@netapp.com\n\
    \   Craig Everhart\n   NetApp\n   7301 Kit Creek Rd\n   Research Triangle Park,\
    \ NC  27709\n   US\n   Phone: +1 919-476-5320\n   EMail: everhart@netapp.com\n\
    \   Daniel Ellard\n   BBN Technologies\n   10 Moulton Street\n   Cambridge, MA\
    \  02138\n   US\n   Phone: +1 617-873-8000\n   EMail: dellard@bbn.com\n   Renu\
    \ Tewari\n   IBM Almaden\n   650 Harry Rd\n   San Jose, CA  95120\n   US\n   EMail:\
    \ tewarir@us.ibm.com\n   Manoj Naik\n   IBM Almaden\n   650 Harry Rd\n   San Jose,\
    \ CA  95120\n   US\n   EMail: manoj@almaden.ibm.com\n"
