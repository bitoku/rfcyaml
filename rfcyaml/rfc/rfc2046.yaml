- contents:
  - "                 Multipurpose Internet Mail Extensions\n                            (MIME)
    Part Two:\n                              Media Types\n"
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Abstract\n   STD 11, RFC 822 defines a message representation protocol specifying\n
    \  considerable detail about US-ASCII message headers, but which leaves\n   the
    message content, or message body, as flat US-ASCII text.  This\n   set of documents,
    collectively called the Multipurpose Internet Mail\n   Extensions, or MIME, redefines
    the format of messages to allow for\n    (1)   textual message bodies in character
    sets other than\n          US-ASCII,\n    (2)   an extensible set of different
    formats for non-textual\n          message bodies,\n    (3)   multi-part message
    bodies, and\n    (4)   textual header information in character sets other than\n
    \         US-ASCII.\n   These documents are based on earlier work documented in
    RFC 934, STD\n   11, and RFC 1049, but extends and revises them.  Because RFC
    822 said\n   so little about message bodies, these documents are largely\n   orthogonal
    to (rather than a revision of) RFC 822.\n   The initial document in this set,
    RFC 2045, specifies the various\n   headers used to describe the structure of
    MIME messages. This second\n   document defines the general structure of the MIME
    media typing\n   system and defines an initial set of media types. The third document,\n
    \  RFC 2047, describes extensions to RFC 822 to allow non-US-ASCII text\n   data
    in Internet mail header fields. The fourth document, RFC 2048,\n   specifies various
    IANA registration procedures for MIME-related\n   facilities.  The fifth and final
    document, RFC 2049, describes MIME\n   conformance criteria as well as providing
    some illustrative examples\n   of MIME message formats, acknowledgements, and
    the bibliography.\n   These documents are revisions of RFCs 1521 and 1522, which
    themselves\n   were revisions of RFCs 1341 and 1342.  An appendix in RFC 2049\n
    \  describes differences and changes from previous versions.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1. Introduction .........................................
    \   3\n   2. Definition of a Top-Level Media Type .................    4\n   3.
    Overview Of The Initial Top-Level Media Types ........    4\n   4. Discrete Media
    Type Values ...........................    6\n   4.1 Text Media Type .....................................
    \   6\n   4.1.1 Representation of Line Breaks .....................    7\n   4.1.2
    Charset Parameter .................................    7\n   4.1.3 Plain Subtype
    .....................................   11\n   4.1.4 Unrecognized Subtypes .............................
    \  11\n   4.2 Image Media Type ....................................   11\n   4.3
    Audio Media Type ....................................   11\n   4.4 Video Media
    Type ....................................   12\n   4.5 Application Media Type
    ..............................   12\n   4.5.1 Octet-Stream Subtype ..............................
    \  13\n   4.5.2 PostScript Subtype ................................   14\n   4.5.3
    Other Application Subtypes ........................   17\n   5. Composite Media
    Type Values ..........................   17\n   5.1 Multipart Media Type ................................
    \  17\n   5.1.1 Common Syntax .....................................   19\n   5.1.2
    Handling Nested Messages and Multiparts ...........   24\n   5.1.3 Mixed Subtype
    .....................................   24\n   5.1.4 Alternative Subtype ...............................
    \  24\n   5.1.5 Digest Subtype ....................................   26\n   5.1.6
    Parallel Subtype ..................................   27\n   5.1.7 Other Multipart
    Subtypes ..........................   28\n   5.2 Message Media Type ..................................
    \  28\n   5.2.1 RFC822 Subtype ....................................   28\n   5.2.2
    Partial Subtype ...................................   29\n   5.2.2.1 Message Fragmentation
    and Reassembly ............   30\n   5.2.2.2 Fragmentation and Reassembly Example
    ............   31\n   5.2.3 External-Body Subtype .............................
    \  33\n   5.2.4 Other Message Subtypes ............................   40\n   6.
    Experimental Media Type Values .......................   40\n   7. Summary ..............................................
    \  41\n   8. Security Considerations ..............................   41\n   9.
    Authors' Addresses ...................................   42\n   A. Collected Grammar
    ....................................   43\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The first document in this set, RFC 2045, defines a number
    of header\n   fields, including Content-Type. The Content-Type field is used to\n
    \  specify the nature of the data in the body of a MIME entity, by\n   giving
    media type and subtype identifiers, and by providing auxiliary\n   information
    that may be required for certain media types.  After the\n   type and subtype
    names, the remainder of the header field is simply a\n   set of parameters, specified
    in an attribute/value notation.  The\n   ordering of parameters is not significant.\n
    \  In general, the top-level media type is used to declare the general\n   type
    of data, while the subtype specifies a specific format for that\n   type of data.
    \ Thus, a media type of \"image/xyz\" is enough to tell a\n   user agent that
    the data is an image, even if the user agent has no\n   knowledge of the specific
    image format \"xyz\".  Such information can\n   be used, for example, to decide
    whether or not to show a user the raw\n   data from an unrecognized subtype --
    such an action might be\n   reasonable for unrecognized subtypes of \"text\",
    but not for\n   unrecognized subtypes of \"image\" or \"audio\".  For this reason,\n
    \  registered subtypes of \"text\", \"image\", \"audio\", and \"video\" should\n
    \  not contain embedded information that is really of a different type.\n   Such
    compound formats should be represented using the \"multipart\" or\n   \"application\"
    types.\n   Parameters are modifiers of the media subtype, and as such do not\n
    \  fundamentally affect the nature of the content.  The set of\n   meaningful
    parameters depends on the media type and subtype.  Most\n   parameters are associated
    with a single specific subtype.  However, a\n   given top-level media type may
    define parameters which are applicable\n   to any subtype of that type.  Parameters
    may be required by their\n   defining media type or subtype or they may be optional.
    \ MIME\n   implementations must also ignore any parameters whose names they do\n
    \  not recognize.\n   MIME's Content-Type header field and media type mechanism
    has been\n   carefully designed to be extensible, and it is expected that the
    set\n   of media type/subtype pairs and their associated parameters will grow\n
    \  significantly over time.  Several other MIME facilities, such as\n   transfer
    encodings and \"message/external-body\" access types, are\n   likely to have new
    values defined over time.  In order to ensure that\n   the set of such values
    is developed in an orderly, well-specified,\n   and public manner, MIME sets up
    a registration process which uses the\n   Internet Assigned Numbers Authority
    (IANA) as a central registry for\n   MIME's various areas of extensibility.  The
    registration process for\n   these areas is described in a companion document,
    RFC 2048.\n   The initial seven standard top-level media type are defined and\n
    \  described in the remainder of this document.\n"
  title: 1.  Introduction
- contents:
  - "2.  Definition of a Top-Level Media Type\n   The definition of a top-level media
    type consists of:\n    (1)   a name and a description of the type, including\n
    \         criteria for whether a particular type would qualify\n          under
    that type,\n    (2)   the names and definitions of parameters, if any, which\n
    \         are defined for all subtypes of that type (including\n          whether
    such parameters are required or optional),\n    (3)   how a user agent and/or
    gateway should handle unknown\n          subtypes of this type,\n    (4)   general
    considerations on gatewaying entities of this\n          top-level type, if any,
    and\n    (5)   any restrictions on content-transfer-encodings for\n          entities
    of this top-level type.\n"
  title: 2.  Definition of a Top-Level Media Type
- contents:
  - "3.  Overview Of The Initial Top-Level Media Types\n   The five discrete top-level
    media types are:\n    (1)   text -- textual information.  The subtype \"plain\"
    in\n          particular indicates plain text containing no\n          formatting
    commands or directives of any sort. Plain\n          text is intended to be displayed
    \"as-is\". No special\n          software is required to get the full meaning
    of the\n          text, aside from support for the indicated character\n          set.
    Other subtypes are to be used for enriched text in\n          forms where application
    software may enhance the\n          appearance of the text, but such software
    must not be\n          required in order to get the general idea of the\n          content.
    \ Possible subtypes of \"text\" thus include any\n          word processor format
    that can be read without\n          resorting to software that understands the
    format.  In\n          particular, formats that employ embeddded binary\n          formatting
    information are not considered directly\n          readable. A very simple and
    portable subtype,\n          \"richtext\", was defined in RFC 1341, with a further\n
    \         revision in RFC 1896 under the name \"enriched\".\n    (2)   image --
    image data.  \"Image\" requires a display device\n          (such as a graphical
    display, a graphics printer, or a\n          FAX machine) to view the information.
    An initial\n          subtype is defined for the widely-used image format\n          JPEG.
    .  subtypes are defined for two widely-used image\n          formats, jpeg and
    gif.\n    (3)   audio -- audio data.  \"Audio\" requires an audio output\n          device
    (such as a speaker or a telephone) to \"display\"\n          the contents.  An
    initial subtype \"basic\" is defined in\n          this document.\n    (4)   video
    -- video data.  \"Video\" requires the capability\n          to display moving
    images, typically including\n          specialized hardware and software.  An
    initial subtype\n          \"mpeg\" is defined in this document.\n    (5)   application
    -- some other kind of data, typically\n          either uninterpreted binary data
    or information to be\n          processed by an application.  The subtype \"octet-\n
    \         stream\" is to be used in the case of uninterpreted\n          binary
    data, in which case the simplest recommended\n          action is to offer to
    write the information into a file\n          for the user.  The \"PostScript\"
    subtype is also defined\n          for the transport of PostScript material.  Other\n
    \         expected uses for \"application\" include spreadsheets,\n          data
    for mail-based scheduling systems, and languages\n          for \"active\" (computational)
    messaging, and word\n          processing formats that are not directly readable.\n
    \         Note that security considerations may exist for some\n          types
    of application data, most notably\n          \"application/PostScript\" and any
    form of active\n          messaging.  These issues are discussed later in this\n
    \         document.\n   The two composite top-level media types are:\n    (1)
    \  multipart -- data consisting of multiple entities of\n          independent
    data types.  Four subtypes are initially\n          defined, including the basic
    \"mixed\" subtype specifying\n          a generic mixed set of parts, \"alternative\"
    for\n          representing the same data in multiple formats,\n          \"parallel\"
    for parts intended to be viewed\n          simultaneously, and \"digest\" for
    multipart entities in\n          which each part has a default type of \"message/rfc822\".\n
    \   (2)   message -- an encapsulated message.  A body of media\n          type
    \"message\" is itself all or a portion of some kind\n          of message object.
    \ Such objects may or may not in turn\n          contain other entities.  The
    \"rfc822\" subtype is used\n          when the encapsulated content is itself
    an RFC 822\n          message.  The \"partial\" subtype is defined for partial\n
    \         RFC 822 messages, to permit the fragmented transmission\n          of
    bodies that are thought to be too large to be passed\n          through transport
    facilities in one piece.  Another\n          subtype, \"external-body\", is defined
    for specifying\n          large bodies by reference to an external data source.\n
    \  It should be noted that the list of media type values given here may\n   be
    augmented in time, via the mechanisms described above, and that\n   the set of
    subtypes is expected to grow substantially.\n"
  title: 3.  Overview Of The Initial Top-Level Media Types
- contents:
  - "4.  Discrete Media Type Values\n   Five of the seven initial media type values
    refer to discrete bodies.\n   The content of these types must be handled by non-MIME
    mechanisms;\n   they are opaque to MIME processors.\n"
  - contents:
    - "4.1.  Text Media Type\n   The \"text\" media type is intended for sending material
      which is\n   principally textual in form.  A \"charset\" parameter may be used
      to\n   indicate the character set of the body text for \"text\" subtypes,\n
      \  notably including the subtype \"text/plain\", which is a generic\n   subtype
      for plain text.  Plain text does not provide for or allow\n   formatting commands,
      font attribute specifications, processing\n   instructions, interpretation directives,
      or content markup.  Plain\n   text is seen simply as a linear sequence of characters,
      possibly\n   interrupted by line breaks or page breaks.  Plain text may allow
      the\n   stacking of several characters in the same position in the text.\n   Plain
      text in scripts like Arabic and Hebrew may also include\n   facilitites that
      allow the arbitrary mixing of text segments with\n   opposite writing directions.\n
      \  Beyond plain text, there are many formats for representing what might\n   be
      known as \"rich text\".  An interesting characteristic of many such\n   representations
      is that they are to some extent readable even without\n   the software that
      interprets them.  It is useful, then, to\n   distinguish them, at the highest
      level, from such unreadable data as\n   images, audio, or text represented in
      an unreadable form. In the\n   absence of appropriate interpretation software,
      it is reasonable to\n   show subtypes of \"text\" to the user, while it is not
      reasonable to do\n   so with most nontextual data. Such formatted textual data
      should be\n   represented using subtypes of \"text\".\n"
    - contents:
      - "4.1.1.  Representation of Line Breaks\n   The canonical form of any MIME
        \"text\" subtype MUST always represent a\n   line break as a CRLF sequence.
        \ Similarly, any occurrence of CRLF in\n   MIME \"text\" MUST represent a
        line break.  Use of CR and LF outside of\n   line break sequences is also
        forbidden.\n   This rule applies regardless of format or character set or
        sets\n   involved.\n   NOTE: The proper interpretation of line breaks when
        a body is\n   displayed depends on the media type. In particular, while it
        is\n   appropriate to treat a line break as a transition to a new line when\n
        \  displaying a \"text/plain\" body, this treatment is actually incorrect\n
        \  for other subtypes of \"text\" like \"text/enriched\" [RFC-1896].\n   Similarly,
        whether or not line breaks should be added during display\n   operations is
        also a function of the media type. It should not be\n   necessary to add any
        line breaks to display \"text/plain\" correctly,\n   whereas proper display
        of \"text/enriched\" requires the appropriate\n   addition of line breaks.\n
        \  NOTE: Some protocols defines a maximum line length.  E.g. SMTP [RFC-\n
        \  821] allows a maximum of 998 octets before the next CRLF sequence.\n   To
        be transported by such protocols, data which includes too long\n   segments
        without CRLF sequences must be encoded with a suitable\n   content-transfer-encoding.\n"
      title: 4.1.1.  Representation of Line Breaks
    - contents:
      - "4.1.2.  Charset Parameter\n   A critical parameter that may be specified
        in the Content-Type field\n   for \"text/plain\" data is the character set.
        \ This is specified with a\n   \"charset\" parameter, as in:\n     Content-type:
        text/plain; charset=iso-8859-1\n   Unlike some other parameter values, the
        values of the charset\n   parameter are NOT case sensitive.  The default character
        set, which\n   must be assumed in the absence of a charset parameter, is US-ASCII.\n
        \  The specification for any future subtypes of \"text\" must specify\n   whether
        or not they will also utilize a \"charset\" parameter, and may\n   possibly
        restrict its values as well.  For other subtypes of \"text\"\n   than \"text/plain\",
        the semantics of the \"charset\" parameter should be\n   defined to be identical
        to those specified here for \"text/plain\",\n   i.e., the body consists entirely
        of characters in the given charset.\n   In particular, definers of future
        \"text\" subtypes should pay close\n   attention to the implications of multioctet
        character sets for their\n   subtype definitions.\n   The charset parameter
        for subtypes of \"text\" gives a name of a\n   character set, as \"character
        set\" is defined in RFC 2045.  The rules\n   regarding line breaks detailed
        in the previous section must also be\n   observed -- a character set whose
        definition does not conform to\n   these rules cannot be used in a MIME \"text\"
        subtype.\n   An initial list of predefined character set names can be found
        at the\n   end of this section.  Additional character sets may be registered\n
        \  with IANA.\n   Other media types than subtypes of \"text\" might choose
        to employ the\n   charset parameter as defined here, but with the CRLF/line
        break\n   restriction removed.  Therefore, all character sets that conform
        to\n   the general definition of \"character set\" in RFC 2045 can be\n   registered
        for MIME use.\n   Note that if the specified character set includes 8-bit
        characters\n   and such characters are used in the body, a Content-Transfer-Encoding\n
        \  header field and a corresponding encoding on the data are required in\n
        \  order to transmit the body via some mail transfer protocols, such as\n
        \  SMTP [RFC-821].\n   The default character set, US-ASCII, has been the subject
        of some\n   confusion and ambiguity in the past.  Not only were there some\n
        \  ambiguities in the definition, there have been wide variations in\n   practice.
        \ In order to eliminate such ambiguity and variations in the\n   future, it
        is strongly recommended that new user agents explicitly\n   specify a character
        set as a media type parameter in the Content-Type\n   header field. \"US-ASCII\"
        does not indicate an arbitrary 7-bit\n   character set, but specifies that
        all octets in the body must be\n   interpreted as characters according to
        the US-ASCII character set.\n   National and application-oriented versions
        of ISO 646 [ISO-646] are\n   usually NOT identical to US-ASCII, and in that
        case their use in\n   Internet mail is explicitly discouraged.  The omission
        of the ISO 646\n   character set from this document is deliberate in this
        regard.  The\n   character set name of \"US-ASCII\" explicitly refers to the
        character\n   set defined in ANSI X3.4-1986 [US- ASCII].  The new international\n
        \  reference version (IRV) of the 1991 edition of ISO 646 is identical\n   to
        US-ASCII.  The character set name \"ASCII\" is reserved and must not\n   be
        used for any purpose.\n   NOTE: RFC 821 explicitly specifies \"ASCII\", and
        references an earlier\n   version of the American Standard.  Insofar as one
        of the purposes of\n   specifying a media type and character set is to permit
        the receiver\n   to unambiguously determine how the sender intended the coded
        message\n   to be interpreted, assuming anything other than \"strict ASCII\"
        as the\n   default would risk unintentional and incompatible changes to the\n
        \  semantics of messages now being transmitted.  This also implies that\n
        \  messages containing characters coded according to other versions of\n   ISO
        646 than US-ASCII and the 1991 IRV, or using code-switching\n   procedures
        (e.g., those of ISO 2022), as well as 8bit or multiple\n   octet character
        encodings MUST use an appropriate character set\n   specification to be consistent
        with MIME.\n   The complete US-ASCII character set is listed in ANSI X3.4-
        1986.\n   Note that the control characters including DEL (0-31, 127) have
        no\n   defined meaning in apart from the combination CRLF (US-ASCII values\n
        \  13 and 10) indicating a new line.  Two of the characters have de\n   facto
        meanings in wide use: FF (12) often means \"start subsequent\n   text on the
        beginning of a new page\"; and TAB or HT (9) often (though\n   not always)
        means \"move the cursor to the next available column after\n   the current
        position where the column number is a multiple of 8\n   (counting the first
        column as column 0).\"  Aside from these\n   conventions, any use of the control
        characters or DEL in a body must\n   either occur\n    (1)   because a subtype
        of text other than \"plain\"\n          specifically assigns some additional
        meaning, or\n    (2)   within the context of a private agreement between the\n
        \         sender and recipient. Such private agreements are\n          discouraged
        and should be replaced by the other\n          capabilities of this document.\n
        \  NOTE: An enormous proliferation of character sets exist beyond US-\n   ASCII.
        \ A large number of partially or totally overlapping character\n   sets is
        NOT a good thing.  A SINGLE character set that can be used\n   universally
        for representing all of the world's languages in Internet\n   mail would be
        preferrable.  Unfortunately, existing practice in\n   several communities
        seems to point to the continued use of multiple\n   character sets in the
        near future.  A small number of standard\n   character sets are, therefore,
        defined for Internet use in this\n   document.\n   The defined charset values
        are:\n    (1)   US-ASCII -- as defined in ANSI X3.4-1986 [US-ASCII].\n    (2)
        \  ISO-8859-X -- where \"X\" is to be replaced, as\n          necessary, for
        the parts of ISO-8859 [ISO-8859].  Note\n          that the ISO 646 character
        sets have deliberately been\n          omitted in favor of their 8859 replacements,
        which are\n          the designated character sets for Internet mail.  As
        of\n          the publication of this document, the legitimate values\n          for
        \"X\" are the digits 1 through 10.\n   Characters in the range 128-159 has
        no assigned meaning in ISO-8859-\n   X.  Characters with values below 128
        in ISO-8859-X have the same\n   assigned meaning as they do in US-ASCII.\n
        \  Part 6 of ISO 8859 (Latin/Arabic alphabet) and part 8 (Latin/Hebrew\n   alphabet)
        includes both characters for which the normal writing\n   direction is right
        to left and characters for which it is left to\n   right, but do not define
        a canonical ordering method for representing\n   bi-directional text.  The
        charset values \"ISO-8859-6\" and \"ISO-8859-\n   8\", however, specify that
        the visual method is used [RFC-1556].\n   All of these character sets are
        used as pure 7bit or 8bit sets\n   without any shift or escape functions.
        \ The meaning of shift and\n   escape sequences in these character sets is
        not defined.\n   The character sets specified above are the ones that were
        relatively\n   uncontroversial during the drafting of MIME.  This document
        does not\n   endorse the use of any particular character set other than US-ASCII,\n
        \  and recognizes that the future evolution of world character sets\n   remains
        unclear.\n   Note that the character set used, if anything other than US-
        ASCII,\n   must always be explicitly specified in the Content-Type field.\n
        \  No character set name other than those defined above may be used in\n   Internet
        mail without the publication of a formal specification and\n   its registration
        with IANA, or by private agreement, in which case\n   the character set name
        must begin with \"X-\".\n   Implementors are discouraged from defining new
        character sets unless\n   absolutely necessary.\n   The \"charset\" parameter
        has been defined primarily for the purpose of\n   textual data, and is described
        in this section for that reason.\n   However, it is conceivable that non-textual
        data might also wish to\n   specify a charset value for some purpose, in which
        case the same\n   syntax and values should be used.\n   In general, composition
        software should always use the \"lowest common\n   denominator\" character
        set possible.  For example, if a body contains\n   only US-ASCII characters,
        it SHOULD be marked as being in the US-\n   ASCII character set, not ISO-8859-1,
        which, like all the ISO-8859\n   family of character sets, is a superset of
        US-ASCII.  More generally,\n   if a widely-used character set is a subset
        of another character set,\n   and a body contains only characters in the widely-used
        subset, it\n   should be labelled as being in that subset.  This will increase
        the\n   chances that the recipient will be able to view the resulting entity\n
        \  correctly.\n"
      title: 4.1.2.  Charset Parameter
    - contents:
      - "4.1.3.  Plain Subtype\n   The simplest and most important subtype of \"text\"
        is \"plain\".  This\n   indicates plain text that does not contain any formatting
        commands or\n   directives. Plain text is intended to be displayed \"as-is\",
        that is,\n   no interpretation of embedded formatting commands, font attribute\n
        \  specifications, processing instructions, interpretation directives,\n   or
        content markup should be necessary for proper display.  The\n   default media
        type of \"text/plain; charset=us-ascii\" for Internet\n   mail describes existing
        Internet practice.  That is, it is the type\n   of body defined by RFC 822.\n
        \  No other \"text\" subtype is defined by this document.\n"
      title: 4.1.3.  Plain Subtype
    - contents:
      - "4.1.4.  Unrecognized Subtypes\n   Unrecognized subtypes of \"text\" should
        be treated as subtype \"plain\"\n   as long as the MIME implementation knows
        how to handle the charset.\n   Unrecognized subtypes which also specify an
        unrecognized charset\n   should be treated as \"application/octet- stream\".\n"
      title: 4.1.4.  Unrecognized Subtypes
    title: 4.1.  Text Media Type
  - contents:
    - "4.2.  Image Media Type\n   A media type of \"image\" indicates that the body
      contains an image.\n   The subtype names the specific image format.  These names
      are not\n   case sensitive. An initial subtype is \"jpeg\" for the JPEG format\n
      \  using JFIF encoding [JPEG].\n   The list of \"image\" subtypes given here
      is neither exclusive nor\n   exhaustive, and is expected to grow as more types
      are registered with\n   IANA, as described in RFC 2048.\n   Unrecognized subtypes
      of \"image\" should at a miniumum be treated as\n   \"application/octet-stream\".
      \ Implementations may optionally elect to\n   pass subtypes of \"image\" that
      they do not specifically recognize to a\n   secure and robust general-purpose
      image viewing application, if such\n   an application is available.\n   NOTE:
      Using of a generic-purpose image viewing application this way\n   inherits the
      security problems of the most dangerous type supported\n   by the application.\n"
    title: 4.2.  Image Media Type
  - contents:
    - "4.3.  Audio Media Type\n   A media type of \"audio\" indicates that the body
      contains audio data.\n   Although there is not yet a consensus on an \"ideal\"
      audio format for\n   use with computers, there is a pressing need for a format
      capable of\n   providing interoperable behavior.\n   The initial subtype of
      \"basic\" is specified to meet this requirement\n   by providing an absolutely
      minimal lowest common denominator audio\n   format.  It is expected that richer
      formats for higher quality and/or\n   lower bandwidth audio will be defined
      by a later document.\n   The content of the \"audio/basic\" subtype is single
      channel audio\n   encoded using 8bit ISDN mu-law [PCM] at a sample rate of 8000
      Hz.\n   Unrecognized subtypes of \"audio\" should at a miniumum be treated as\n
      \  \"application/octet-stream\".  Implementations may optionally elect to\n
      \  pass subtypes of \"audio\" that they do not specifically recognize to a\n
      \  robust general-purpose audio playing application, if such an\n   application
      is available.\n"
    title: 4.3.  Audio Media Type
  - contents:
    - "4.4.  Video Media Type\n   A media type of \"video\" indicates that the body
      contains a time-\n   varying-picture image, possibly with color and coordinated
      sound.\n   The term 'video' is used in its most generic sense, rather than with\n
      \  reference to any particular technology or format, and is not meant to\n   preclude
      subtypes such as animated drawings encoded compactly.  The\n   subtype \"mpeg\"
      refers to video coded according to the MPEG standard\n   [MPEG].\n   Note that
      although in general this document strongly discourages the\n   mixing of multiple
      media in a single body, it is recognized that many\n   so-called video formats
      include a representation for synchronized\n   audio, and this is explicitly
      permitted for subtypes of \"video\".\n   Unrecognized subtypes of \"video\"
      should at a minumum be treated as\n   \"application/octet-stream\".  Implementations
      may optionally elect to\n   pass subtypes of \"video\" that they do not specifically
      recognize to a\n   robust general-purpose video display application, if such
      an\n   application is available.\n"
    title: 4.4.  Video Media Type
  - contents:
    - "4.5.  Application Media Type\n   The \"application\" media type is to be used
      for discrete data which do\n   not fit in any of the other categories, and particularly
      for data to\n   be processed by some type of application program.  This is\n
      \  information which must be processed by an application before it is\n   viewable
      or usable by a user.  Expected uses for the \"application\"\n   media type include
      file transfer, spreadsheets, data for mail-based\n   scheduling systems, and
      languages for \"active\" (computational)\n   material.  (The latter, in particular,
      can pose security problems\n   which must be understood by implementors, and
      are considered in\n   detail in the discussion of the \"application/PostScript\"
      media type.)\n   For example, a meeting scheduler might define a standard\n
      \  representation for information about proposed meeting dates.  An\n   intelligent
      user agent would use this information to conduct a dialog\n   with the user,
      and might then send additional material based on that\n   dialog.  More generally,
      there have been several \"active\" messaging\n   languages developed in which
      programs in a suitably specialized\n   language are transported to a remote
      location and automatically run\n   in the recipient's environment.\n   Such
      applications may be defined as subtypes of the \"application\"\n   media type.
      This document defines two subtypes:\n   octet-stream, and PostScript.\n   The
      subtype of \"application\" will often be either the name or include\n   part
      of the name of the application for which the data are intended.\n   This does
      not mean, however, that any application program name may be\n   used freely
      as a subtype of \"application\".\n"
    - contents:
      - "4.5.1.  Octet-Stream Subtype\n   The \"octet-stream\" subtype is used to
        indicate that a body contains\n   arbitrary binary data.  The set of currently
        defined parameters is:\n    (1)   TYPE -- the general type or category of
        binary data.\n          This is intended as information for the human recipient\n
        \         rather than for any automatic processing.\n    (2)   PADDING --
        the number of bits of padding that were\n          appended to the bit-stream
        comprising the actual\n          contents to produce the enclosed 8bit byte-oriented\n
        \         data.  This is useful for enclosing a bit-stream in a\n          body
        when the total number of bits is not a multiple of\n          8.\n   Both
        of these parameters are optional.\n   An additional parameter, \"CONVERSIONS\",
        was defined in RFC 1341 but\n   has since been removed.  RFC 1341 also defined
        the use of a \"NAME\"\n   parameter which gave a suggested file name to be
        used if the data\n   were to be written to a file.  This has been deprecated
        in\n   anticipation of a separate Content-Disposition header field, to be\n
        \  defined in a subsequent RFC.\n   The recommended action for an implementation
        that receives an\n   \"application/octet-stream\" entity is to simply offer
        to put the data\n   in a file, with any Content-Transfer-Encoding undone,
        or perhaps to\n   use it as input to a user-specified process.\n   To reduce
        the danger of transmitting rogue programs, it is strongly\n   recommended
        that implementations NOT implement a path-search\n   mechanism whereby an
        arbitrary program named in the Content-Type\n   parameter (e.g., an \"interpreter=\"
        parameter) is found and executed\n   using the message body as input.\n"
      title: 4.5.1.  Octet-Stream Subtype
    - contents:
      - "4.5.2.  PostScript Subtype\n   A media type of \"application/postscript\"
        indicates a PostScript\n   program.  Currently two variants of the PostScript
        language are\n   allowed; the original level 1 variant is described in [POSTSCRIPT]\n
        \  and the more recent level 2 variant is described in [POSTSCRIPT2].\n   PostScript
        is a registered trademark of Adobe Systems, Inc.  Use of\n   the MIME media
        type \"application/postscript\" implies recognition of\n   that trademark
        and all the rights it entails.\n   The PostScript language definition provides
        facilities for internal\n   labelling of the specific language features a
        given program uses.\n   This labelling, called the PostScript document structuring\n
        \  conventions, or DSC, is very general and provides substantially more\n
        \  information than just the language level.  The use of document\n   structuring
        conventions, while not required, is strongly recommended\n   as an aid to
        interoperability.  Documents which lack proper\n   structuring conventions
        cannot be tested to see whether or not they\n   will work in a given environment.
        \ As such, some systems may assume\n   the worst and refuse to process unstructured
        documents.\n   The execution of general-purpose PostScript interpreters entails\n
        \  serious security risks, and implementors are discouraged from simply\n
        \  sending PostScript bodies to \"off- the-shelf\" interpreters.  While it\n
        \  is usually safe to send PostScript to a printer, where the potential\n
        \  for harm is greatly constrained by typical printer environments,\n   implementors
        should consider all of the following before they add\n   interactive display
        of PostScript bodies to their MIME readers.\n   The remainder of this section
        outlines some, though probably not all,\n   of the possible problems with
        the transport of PostScript entities.\n    (1)   Dangerous operations in the
        PostScript language\n          include, but may not be limited to, the PostScript\n
        \         operators \"deletefile\", \"renamefile\", \"filenameforall\",\n
        \         and \"file\".  \"File\" is only dangerous when applied to\n          something
        other than standard input or output.\n          Implementations may also define
        additional nonstandard\n          file operators; these may also pose a threat
        to\n          security. \"Filenameforall\", the wildcard file search\n          operator,
        may appear at first glance to be harmless.\n          Note, however, that
        this operator has the potential to\n          reveal information about what
        files the recipient has\n          access to, and this information may itself
        be\n          sensitive.  Message senders should avoid the use of\n          potentially
        dangerous file operators, since these\n          operators are quite likely
        to be unavailable in secure\n          PostScript implementations.  Message
        receiving and\n          displaying software should either completely disable\n
        \         all potentially dangerous file operators or take\n          special
        care not to delegate any special authority to\n          their operation.
        \ These operators should be viewed as\n          being done by an outside
        agency when interpreting\n          PostScript documents.  Such disabling
        and/or checking\n          should be done completely outside of the reach
        of the\n          PostScript language itself; care should be taken to\n          insure
        that no method exists for re-enabling full-\n          function versions of
        these operators.\n    (2)   The PostScript language provides facilities for
        exiting\n          the normal interpreter, or server, loop.  Changes made\n
        \         in this \"outer\" environment are customarily retained\n          across
        documents, and may in some cases be retained\n          semipermanently in
        nonvolatile memory.  The operators\n          associated with exiting the
        interpreter loop have the\n          potential to interfere with subsequent
        document\n          processing.  As such, their unrestrained use\n          constitutes
        a threat of service denial.  PostScript\n          operators that exit the
        interpreter loop include, but\n          may not be limited to, the exitserver
        and startjob\n          operators.  Message sending software should not\n
        \         generate PostScript that depends on exiting the\n          interpreter
        loop to operate, since the ability to exit\n          will probably be unavailable
        in secure PostScript\n          implementations.  Message receiving and displaying\n
        \         software should completely disable the ability to make\n          retained
        changes to the PostScript environment by\n          eliminating or disabling
        the \"startjob\" and\n          \"exitserver\" operations.  If these operations
        cannot be\n          eliminated or completely disabled the password\n          associated
        with them should at least be set to a hard-\n          to-guess value.\n    (3)
        \  PostScript provides operators for setting system-wide\n          and device-specific
        parameters.  These parameter\n          settings may be retained across jobs
        and may\n          potentially pose a threat to the correct operation of\n
        \         the interpreter.  The PostScript operators that set\n          system
        and device parameters include, but may not be\n          limited to, the \"setsystemparams\"
        and \"setdevparams\"\n          operators.  Message sending software should
        not\n          generate PostScript that depends on the setting of\n          system
        or device parameters to operate correctly.  The\n          ability to set
        these parameters will probably be\n          unavailable in secure PostScript
        implementations.\n          Message receiving and displaying software should\n
        \         disable the ability to change system and device\n          parameters.
        \ If these operators cannot be completely\n          disabled the password
        associated with them should at\n          least be set to a hard-to-guess
        value.\n    (4)   Some PostScript implementations provide nonstandard\n          facilities
        for the direct loading and execution of\n          machine code.  Such facilities
        are quite obviously open\n          to substantial abuse.  Message sending
        software should\n          not make use of such features.  Besides being totally\n
        \         hardware-specific, they are also likely to be\n          unavailable
        in secure implementations of PostScript.\n          Message receiving and
        displaying software should not\n          allow such operators to be used
        if they exist.\n    (5)   PostScript is an extensible language, and many,
        if not\n          most, implementations of it provide a number of their\n
        \         own extensions.  This document does not deal with such\n          extensions
        explicitly since they constitute an unknown\n          factor.  Message sending
        software should not make use\n          of nonstandard extensions; they are
        likely to be\n          missing from some implementations.  Message receiving\n
        \         and displaying software should make sure that any\n          nonstandard
        PostScript operators are secure and don't\n          present any kind of threat.\n
        \   (6)   It is possible to write PostScript that consumes huge\n          amounts
        of various system resources.  It is also\n          possible to write PostScript
        programs that loop\n          indefinitely.  Both types of programs have the\n
        \         potential to cause damage if sent to unsuspecting\n          recipients.
        \ Message-sending software should avoid the\n          construction and dissemination
        of such programs, which\n          is antisocial.  Message receiving and displaying\n
        \         software should provide appropriate mechanisms to abort\n          processing
        after a reasonable amount of time has\n          elapsed. In addition, PostScript
        interpreters should be\n          limited to the consumption of only a reasonable
        amount\n          of any given system resource.\n    (7)   It is possible
        to include raw binary information inside\n          PostScript in various
        forms.  This is not recommended\n          for use in Internet mail, both
        because it is not\n          supported by all PostScript interpreters and
        because it\n          significantly complicates the use of a MIME Content-\n
        \         Transfer-Encoding.  (Without such binary, PostScript\n          may
        typically be viewed as line-oriented data.  The\n          treatment of CRLF
        sequences becomes extremely\n          problematic if binary and line-oriented
        data are mixed\n          in a single Postscript data stream.)\n    (8)   Finally,
        bugs may exist in some PostScript interpreters\n          which could possibly
        be exploited to gain unauthorized\n          access to a recipient's system.
        \ Apart from noting this\n          possibility, there is no specific action
        to take to\n          prevent this, apart from the timely correction of such\n
        \         bugs if any are found.\n"
      title: 4.5.2.  PostScript Subtype
    - contents:
      - "4.5.3.  Other Application Subtypes\n   It is expected that many other subtypes
        of \"application\" will be\n   defined in the future.  MIME implementations
        must at a minimum treat\n   any unrecognized subtypes as being equivalent
        to \"application/octet-\n   stream\".\n"
      title: 4.5.3.  Other Application Subtypes
    title: 4.5.  Application Media Type
  title: 4.  Discrete Media Type Values
- contents:
  - "5.  Composite Media Type Values\n   The remaining two of the seven initial Content-Type
    values refer to\n   composite entities.  Composite entities are handled using
    MIME\n   mechanisms -- a MIME processor typically handles the body directly.\n"
  - contents:
    - "5.1.  Multipart Media Type\n   In the case of multipart entities, in which
      one or more different\n   sets of data are combined in a single body, a \"multipart\"
      media type\n   field must appear in the entity's header.  The body must then
      contain\n   one or more body parts, each preceded by a boundary delimiter line,\n
      \  and the last one followed by a closing boundary delimiter line.\n   After
      its boundary delimiter line, each body part then consists of a\n   header area,
      a blank line, and a body area.  Thus a body part is\n   similar to an RFC 822
      message in syntax, but different in meaning.\n   A body part is an entity and
      hence is NOT to be interpreted as\n   actually being an RFC 822 message.  To
      begin with, NO header fields\n   are actually required in body parts.  A body
      part that starts with a\n   blank line, therefore, is allowed and is a body
      part for which all\n   default values are to be assumed.  In such a case, the
      absence of a\n   Content-Type header usually indicates that the corresponding
      body has\n   a content-type of \"text/plain; charset=US-ASCII\".\n   The only
      header fields that have defined meaning for body parts are\n   those the names
      of which begin with \"Content-\".  All other header\n   fields may be ignored
      in body parts.  Although they should generally\n   be retained if at all possible,
      they may be discarded by gateways if\n   necessary.  Such other fields are permitted
      to appear in body parts\n   but must not be depended on.  \"X-\" fields may
      be created for\n   experimental or private purposes, with the recognition that
      the\n   information they contain may be lost at some gateways.\n   NOTE:  The
      distinction between an RFC 822 message and a body part is\n   subtle, but important.
      \ A gateway between Internet and X.400 mail,\n   for example, must be able to
      tell the difference between a body part\n   that contains an image and a body
      part that contains an encapsulated\n   message, the body of which is a JPEG
      image.  In order to represent\n   the latter, the body part must have \"Content-Type:
      message/rfc822\",\n   and its body (after the blank line) must be the encapsulated
      message,\n   with its own \"Content-Type: image/jpeg\" header field.  The use
      of\n   similar syntax facilitates the conversion of messages to body parts,\n
      \  and vice versa, but the distinction between the two must be\n   understood
      by implementors.  (For the special case in which parts\n   actually are messages,
      a \"digest\" subtype is also defined.)\n   As stated previously, each body part
      is preceded by a boundary\n   delimiter line that contains the boundary delimiter.
      \ The boundary\n   delimiter MUST NOT appear inside any of the encapsulated
      parts, on a\n   line by itself or as the prefix of any line.  This implies that
      it is\n   crucial that the composing agent be able to choose and specify a\n
      \  unique boundary parameter value that does not contain the boundary\n   parameter
      value of an enclosing multipart as a prefix.\n   All present and future subtypes
      of the \"multipart\" type must use an\n   identical syntax.  Subtypes may differ
      in their semantics, and may\n   impose additional restrictions on syntax, but
      must conform to the\n   required syntax for the \"multipart\" type.  This requirement
      ensures\n   that all conformant user agents will at least be able to recognize\n
      \  and separate the parts of any multipart entity, even those of an\n   unrecognized
      subtype.\n   As stated in the definition of the Content-Transfer-Encoding field\n
      \  [RFC 2045], no encoding other than \"7bit\", \"8bit\", or \"binary\" is\n
      \  permitted for entities of type \"multipart\".  The \"multipart\" boundary\n
      \  delimiters and header fields are always represented as 7bit US-ASCII\n   in
      any case (though the header fields may encode non-US-ASCII header\n   text as
      per RFC 2047) and data within the body parts can be encoded\n   on a part-by-part
      basis, with Content-Transfer-Encoding fields for\n   each appropriate body part.\n"
    - contents:
      - "5.1.1.  Common Syntax\n   This section defines a common syntax for subtypes
        of \"multipart\".\n   All subtypes of \"multipart\" must use this syntax.
        \ A simple example\n   of a multipart message also appears in this section.
        \ An example of a\n   more complex multipart message is given in RFC 2049.\n
        \  The Content-Type field for multipart entities requires one parameter,\n
        \  \"boundary\". The boundary delimiter line is then defined as a line\n   consisting
        entirely of two hyphen characters (\"-\", decimal value 45)\n   followed by
        the boundary parameter value from the Content-Type header\n   field, optional
        linear whitespace, and a terminating CRLF.\n   NOTE:  The hyphens are for
        rough compatibility with the earlier RFC\n   934 method of message encapsulation,
        and for ease of searching for\n   the boundaries in some implementations.
        \ However, it should be noted\n   that multipart messages are NOT completely
        compatible with RFC 934\n   encapsulations; in particular, they do not obey
        RFC 934 quoting\n   conventions for embedded lines that begin with hyphens.
        \ This\n   mechanism was chosen over the RFC 934 mechanism because the latter\n
        \  causes lines to grow with each level of quoting.  The combination of\n
        \  this growth with the fact that SMTP implementations sometimes wrap\n   long
        lines made the RFC 934 mechanism unsuitable for use in the event\n   that
        deeply-nested multipart structuring is ever desired.\n   WARNING TO IMPLEMENTORS:
        \ The grammar for parameters on the Content-\n   type field is such that it
        is often necessary to enclose the boundary\n   parameter values in quotes
        on the Content-type line.  This is not\n   always necessary, but never hurts.
        Implementors should be sure to\n   study the grammar carefully in order to
        avoid producing invalid\n   Content-type fields.  Thus, a typical \"multipart\"
        Content-Type header\n   field might look like this:\n     Content-Type: multipart/mixed;
        boundary=gc0p4Jq0M2Yt08j34c0p\n   But the following is not valid:\n     Content-Type:
        multipart/mixed; boundary=gc0pJq0M:08jU534c0p\n   (because of the colon) and
        must instead be represented as\n     Content-Type: multipart/mixed; boundary=\"gc0pJq0M:08jU534c0p\"\n
        \  This Content-Type value indicates that the content consists of one or\n
        \  more parts, each with a structure that is syntactically identical to\n
        \  an RFC 822 message, except that the header area is allowed to be\n   completely
        empty, and that the parts are each preceded by the line\n     --gc0pJq0M:08jU534c0p\n
        \  The boundary delimiter MUST occur at the beginning of a line, i.e.,\n   following
        a CRLF, and the initial CRLF is considered to be attached\n   to the boundary
        delimiter line rather than part of the preceding\n   part.  The boundary may
        be followed by zero or more characters of\n   linear whitespace. It is then
        terminated by either another CRLF and\n   the header fields for the next part,
        or by two CRLFs, in which case\n   there are no header fields for the next
        part.  If no Content-Type\n   field is present it is assumed to be \"message/rfc822\"
        in a\n   \"multipart/digest\" and \"text/plain\" otherwise.\n   NOTE:  The
        CRLF preceding the boundary delimiter line is conceptually\n   attached to
        the boundary so that it is possible to have a part that\n   does not end with
        a CRLF (line  break).  Body parts that must be\n   considered to end with
        line breaks, therefore, must have two CRLFs\n   preceding the boundary delimiter
        line, the first of which is part of\n   the preceding body part, and the second
        of which is part of the\n   encapsulation boundary.\n   Boundary delimiters
        must not appear within the encapsulated material,\n   and must be no longer
        than 70 characters, not counting the two\n   leading hyphens.\n   The boundary
        delimiter line following the last body part is a\n   distinguished delimiter
        that indicates that no further body parts\n   will follow.  Such a delimiter
        line is identical to the previous\n   delimiter lines, with the addition of
        two more hyphens after the\n   boundary parameter value.\n     --gc0pJq0M:08jU534c0p--\n
        \  NOTE TO IMPLEMENTORS:  Boundary string comparisons must compare the\n   boundary
        value with the beginning of each candidate line.  An exact\n   match of the
        entire candidate line is not required; it is sufficient\n   that the boundary
        appear in its entirety following the CRLF.\n   There appears to be room for
        additional information prior to the\n   first boundary delimiter line and
        following the final boundary\n   delimiter line.  These areas should generally
        be left blank, and\n   implementations must ignore anything that appears before
        the first\n   boundary delimiter line or after the last one.\n   NOTE:  These
        \"preamble\" and \"epilogue\" areas are generally not used\n   because of
        the lack of proper typing of these parts and the lack of\n   clear semantics
        for handling these areas at gateways, particularly\n   X.400 gateways.  However,
        rather than leaving the preamble area\n   blank, many MIME implementations
        have found this to be a convenient\n   place to insert an explanatory note
        for recipients who read the\n   message with pre-MIME software, since such
        notes will be ignored by\n   MIME-compliant software.\n   NOTE:  Because boundary
        delimiters must not appear in the body parts\n   being encapsulated, a user
        agent must exercise care to choose a\n   unique boundary parameter value.
        \ The boundary parameter value in the\n   example above could have been the
        result of an algorithm designed to\n   produce boundary delimiters with a
        very low probability of already\n   existing in the data to be encapsulated
        without having to prescan the\n   data.  Alternate algorithms might result
        in more \"readable\" boundary\n   delimiters for a recipient with an old user
        agent, but would require\n   more attention to the possibility that the boundary
        delimiter might\n   appear at the beginning of some line in the encapsulated
        part.  The\n   simplest boundary delimiter line possible is something like
        \"---\",\n   with a closing boundary delimiter line of \"-----\".\n   As a
        very simple example, the following multipart message has two\n   parts, both
        of them plain text, one of them explicitly typed and one\n   of them implicitly
        typed:\n     From: Nathaniel Borenstein <nsb@bellcore.com>\n     To: Ned Freed
        <ned@innosoft.com>\n     Date: Sun, 21 Mar 1993 23:56:48 -0800 (PST)\n     Subject:
        Sample message\n     MIME-Version: 1.0\n     Content-type: multipart/mixed;
        boundary=\"simple boundary\"\n     This is the preamble.  It is to be ignored,
        though it\n     is a handy place for composition agents to include an\n     explanatory
        note to non-MIME conformant readers.\n     --simple boundary\n     This is
        implicitly typed plain US-ASCII text.\n     It does NOT end with a linebreak.\n
        \    --simple boundary\n     Content-type: text/plain; charset=us-ascii\n
        \    This is explicitly typed plain US-ASCII text.\n     It DOES end with
        a linebreak.\n     --simple boundary--\n     This is the epilogue.  It is
        also to be ignored.\n   The use of a media type of \"multipart\" in a body
        part within another\n   \"multipart\" entity is explicitly allowed.  In such
        cases, for obvious\n   reasons, care must be taken to ensure that each nested
        \"multipart\"\n   entity uses a different boundary delimiter.  See RFC 2049
        for an\n   example of nested \"multipart\" entities.\n   The use of the \"multipart\"
        media type with only a single body part\n   may be useful in certain contexts,
        and is explicitly permitted.\n   NOTE: Experience has shown that a \"multipart\"
        media type with a\n   single body part is useful for sending non-text media
        types.  It has\n   the advantage of providing the preamble as a place to include\n
        \  decoding instructions.  In addition, a number of SMTP gateways move\n   or
        remove the MIME headers, and a clever MIME decoder can take a good\n   guess
        at multipart boundaries even in the absence of the Content-Type\n   header
        and thereby successfully decode the message.\n   The only mandatory global
        parameter for the \"multipart\" media type is\n   the boundary parameter,
        which consists of 1 to 70 characters from a\n   set of characters known to
        be very robust through mail gateways, and\n   NOT ending with white space.
        (If a boundary delimiter line appears to\n   end with white space, the white
        space must be presumed to have been\n   added by a gateway, and must be deleted.)
        \ It is formally specified\n   by the following BNF:\n     boundary := 0*69<bchars>
        bcharsnospace\n     bchars := bcharsnospace / \" \"\n     bcharsnospace :=
        DIGIT / ALPHA / \"'\" / \"(\" / \")\" /\n                      \"+\" / \"_\"
        / \",\" / \"-\" / \".\" /\n                      \"/\" / \":\" / \"=\" / \"?\"\n
        \  Overall, the body of a \"multipart\" entity may be specified as\n   follows:\n
        \    dash-boundary := \"--\" boundary\n                      ; boundary taken
        from the value of\n                      ; boundary parameter of the\n                      ;
        Content-Type field.\n     multipart-body := [preamble CRLF]\n                       dash-boundary
        transport-padding CRLF\n                       body-part *encapsulation\n
        \                      close-delimiter transport-padding\n                       [CRLF
        epilogue]\n     transport-padding := *LWSP-char\n                          ;
        Composers MUST NOT generate\n                          ; non-zero length transport\n
        \                         ; padding, but receivers MUST\n                          ;
        be able to handle padding\n                          ; added by message transports.\n
        \    encapsulation := delimiter transport-padding\n                      CRLF
        body-part\n     delimiter := CRLF dash-boundary\n     close-delimiter := delimiter
        \"--\"\n     preamble := discard-text\n     epilogue := discard-text\n     discard-text
        := *(*text CRLF) *text\n                     ; May be ignored or discarded.\n
        \    body-part := MIME-part-headers [CRLF *OCTET]\n                  ; Lines
        in a body-part must not start\n                  ; with the specified dash-boundary
        and\n                  ; the delimiter must not appear anywhere\n                  ;
        in the body part.  Note that the\n                  ; semantics of a body-part
        differ from\n                  ; the semantics of a message, as\n                  ;
        described in the text.\n     OCTET := <any 0-255 octet value>\n   IMPORTANT:
        \ The free insertion of linear-white-space and RFC 822\n   comments between
        the elements shown in this BNF is NOT allowed since\n   this BNF does not
        specify a structured header field.\n   NOTE:  In certain transport enclaves,
        RFC 822 restrictions such as\n   the one that limits bodies to printable US-ASCII
        characters may not\n   be in force. (That is, the transport domains may exist
        that resemble\n   standard Internet mail transport as specified in RFC 821
        and assumed\n   by RFC 822, but without certain restrictions.) The relaxation
        of\n   these restrictions should be construed as locally extending the\n   definition
        of bodies, for example to include octets outside of the\n   US-ASCII range,
        as long as these extensions are supported by the\n   transport and adequately
        documented in the Content- Transfer-Encoding\n   header field.  However, in
        no event are headers (either message\n   headers or body part headers) allowed
        to contain anything other than\n   US-ASCII characters.\n   NOTE:  Conspicuously
        missing from the \"multipart\" type is a notion of\n   structured, related
        body parts. It is recommended that those wishing\n   to provide more structured
        or integrated multipart messaging\n   facilities should define subtypes of
        multipart that are syntactically\n   identical but define relationships between
        the various parts. For\n   example, subtypes of multipart could be defined
        that include a\n   distinguished part which in turn is used to specify the
        relationships\n   between the other parts, probably referring to them by their\n
        \  Content-ID field.  Old implementations will not recognize the new\n   subtype
        if this approach is used, but will treat it as\n   multipart/mixed and will
        thus be able to show the user the parts that\n   are recognized.\n"
      title: 5.1.1.  Common Syntax
    - contents:
      - "5.1.2.  Handling Nested Messages and Multiparts\n   The \"message/rfc822\"
        subtype defined in a subsequent section of this\n   document has no terminating
        condition other than running out of data.\n   Similarly, an improperly truncated
        \"multipart\" entity may not have\n   any terminating boundary marker, and
        can turn up operationally due to\n   mail system malfunctions.\n   It is essential
        that such entities be handled correctly when they are\n   themselves imbedded
        inside of another \"multipart\" structure.  MIME\n   implementations are therefore
        required to recognize outer level\n   boundary markers at ANY level of inner
        nesting.  It is not sufficient\n   to only check for the next expected marker
        or other terminating\n   condition.\n"
      title: 5.1.2.  Handling Nested Messages and Multiparts
    - contents:
      - "5.1.3.  Mixed Subtype\n   The \"mixed\" subtype of \"multipart\" is intended
        for use when the body\n   parts are independent and need to be bundled in
        a particular order.\n   Any \"multipart\" subtypes that an implementation
        does not recognize\n   must be treated as being of subtype \"mixed\".\n"
      title: 5.1.3.  Mixed Subtype
    - contents:
      - "5.1.4.  Alternative Subtype\n   The \"multipart/alternative\" type is syntactically
        identical to\n   \"multipart/mixed\", but the semantics are different.  In
        particular,\n   each of the body parts is an \"alternative\" version of the
        same\n   information.\n   Systems should recognize that the content of the
        various parts are\n   interchangeable.  Systems should choose the \"best\"
        type based on the\n   local environment and references, in some cases even
        through user\n   interaction.  As with \"multipart/mixed\", the order of body
        parts is\n   significant.  In this case, the alternatives appear in an order
        of\n   increasing faithfulness to the original content.  In general, the\n
        \  best choice is the LAST part of a type supported by the recipient\n   system's
        local environment.\n   \"Multipart/alternative\" may be used, for example,
        to send a message\n   in a fancy text format in such a way that it can easily
        be displayed\n   anywhere:\n     From: Nathaniel Borenstein <nsb@bellcore.com>\n
        \    To: Ned Freed <ned@innosoft.com>\n     Date: Mon, 22 Mar 1993 09:41:09
        -0800 (PST)\n     Subject: Formatted text mail\n     MIME-Version: 1.0\n     Content-Type:
        multipart/alternative; boundary=boundary42\n     --boundary42\n     Content-Type:
        text/plain; charset=us-ascii\n       ... plain text version of message goes
        here ...\n     --boundary42\n     Content-Type: text/enriched\n       ...
        RFC 1896 text/enriched version of same message\n           goes here ...\n
        \    --boundary42\n     Content-Type: application/x-whatever\n       ... fanciest
        version of same message goes here ...\n     --boundary42--\n   In this example,
        users whose mail systems understood the\n   \"application/x-whatever\" format
        would see only the fancy version,\n   while other users would see only the
        enriched or plain text version,\n   depending on the capabilities of their
        system.\n   In general, user agents that compose \"multipart/alternative\"
        entities\n   must place the body parts in increasing order of preference,
        that is,\n   with the preferred format last.  For fancy text, the sending
        user\n   agent should put the plainest format first and the richest format\n
        \  last.  Receiving user agents should pick and display the last format\n
        \  they are capable of displaying.  In the case where one of the\n   alternatives
        is itself of type \"multipart\" and contains unrecognized\n   sub-parts, the
        user agent may choose either to show that alternative,\n   an earlier alternative,
        or both.\n   NOTE: From an implementor's perspective, it might seem more sensible\n
        \  to reverse this ordering, and have the plainest alternative last.\n   However,
        placing the plainest alternative first is the friendliest\n   possible option
        when \"multipart/alternative\" entities are viewed\n   using a non-MIME-conformant
        viewer.  While this approach does impose\n   some burden on conformant MIME
        viewers, interoperability with older\n   mail readers was deemed to be more
        important in this case.\n   It may be the case that some user agents, if they
        can recognize more\n   than one of the formats, will prefer to offer the user
        the choice of\n   which format to view.  This makes sense, for example, if
        a message\n   includes both a nicely- formatted image version and an easily-edited\n
        \  text version.  What is most critical, however, is that the user not\n   automatically
        be shown multiple versions of the same data.  Either\n   the user should be
        shown the last recognized version or should be\n   given the choice.\n   THE
        SEMANTICS OF CONTENT-ID IN MULTIPART/ALTERNATIVE:  Each part of a\n   \"multipart/alternative\"
        entity represents the same data, but the\n   mappings between the two are
        not necessarily without information\n   loss.  For example, information is
        lost when translating ODA to\n   PostScript or plain text.  It is recommended
        that each part should\n   have a different Content-ID value in the case where
        the information\n   content of the two parts is not identical.  And when the
        information\n   content is identical -- for example, where several parts of
        type\n   \"message/external-body\" specify alternate ways to access the\n
        \  identical data -- the same Content-ID field value should be used, to\n
        \  optimize any caching mechanisms that might be present on the\n   recipient's
        end.  However, the Content-ID values used by the parts\n   should NOT be the
        same Content-ID value that describes the\n   \"multipart/alternative\" as
        a whole, if there is any such Content-ID\n   field.  That is, one Content-ID
        value will refer to the\n   \"multipart/alternative\" entity, while one or
        more other Content-ID\n   values will refer to the parts inside it.\n"
      title: 5.1.4.  Alternative Subtype
    - contents:
      - "5.1.5.  Digest Subtype\n   This document defines a \"digest\" subtype of
        the \"multipart\" Content-\n   Type.  This type is syntactically identical
        to \"multipart/mixed\", but\n   the semantics are different.  In particular,
        in a digest, the default\n   Content-Type value for a body part is changed
        from \"text/plain\" to\n   \"message/rfc822\".  This is done to allow a more
        readable digest\n   format that is largely compatible (except for the quoting
        convention)\n   with RFC 934.\n   Note: Though it is possible to specify a
        Content-Type value for a\n   body part in a digest which is other than \"message/rfc822\",
        such as a\n   \"text/plain\" part containing a description of the material
        in the\n   digest, actually doing so is undesireble. The \"multipart/digest\"\n
        \  Content-Type is intended to be used to send collections of messages.\n
        \  If a \"text/plain\" part is needed, it should be included as a seperate\n
        \  part of a \"multipart/mixed\" message.\n   A digest in this format might,
        then, look something like this:\n     From: Moderator-Address\n     To: Recipient-List\n
        \    Date: Mon, 22 Mar 1994 13:34:51 +0000\n     Subject: Internet Digest,
        volume 42\n     MIME-Version: 1.0\n     Content-Type: multipart/mixed;\n                   boundary=\"----
        main boundary ----\"\n     ------ main boundary ----\n       ...Introductory
        text or table of contents...\n     ------ main boundary ----\n     Content-Type:
        multipart/digest;\n                   boundary=\"---- next message ----\"\n
        \    ------ next message ----\n     From: someone-else\n     Date: Fri, 26
        Mar 1993 11:13:32 +0200\n     Subject: my opinion\n       ...body goes here
        ...\n     ------ next message ----\n     From: someone-else-again\n     Date:
        Fri, 26 Mar 1993 10:07:13 -0500\n     Subject: my different opinion\n       ...
        another body goes here ...\n     ------ next message ------\n     ------ main
        boundary ------\n"
      title: 5.1.5.  Digest Subtype
    - contents:
      - "5.1.6.  Parallel Subtype\n   This document defines a \"parallel\" subtype
        of the \"multipart\"\n   Content-Type.  This type is syntactically identical
        to\n   \"multipart/mixed\", but the semantics are different.  In particular,\n
        \  in a parallel entity, the order of body parts is not significant.\n   A
        common presentation of this type is to display all of the parts\n   simultaneously
        on hardware and software that are capable of doing so.\n   However, composing
        agents should be aware that many mail readers will\n   lack this capability
        and will show the parts serially in any event.\n"
      title: 5.1.6.  Parallel Subtype
    - contents:
      - "5.1.7.  Other Multipart Subtypes\n   Other \"multipart\" subtypes are expected
        in the future.  MIME\n   implementations must in general treat unrecognized
        subtypes of\n   \"multipart\" as being equivalent to \"multipart/mixed\".\n"
      title: 5.1.7.  Other Multipart Subtypes
    title: 5.1.  Multipart Media Type
  - contents:
    - "5.2.  Message Media Type\n   It is frequently desirable, in sending mail, to
      encapsulate another\n   mail message.  A special media type, \"message\", is
      defined to\n   facilitate this.  In particular, the \"rfc822\" subtype of \"message\"
      is\n   used to encapsulate RFC 822 messages.\n   NOTE:  It has been suggested
      that subtypes of \"message\" might be\n   defined for forwarded or rejected
      messages.  However, forwarded and\n   rejected messages can be handled as multipart
      messages in which the\n   first part contains any control or descriptive information,
      and a\n   second part, of type \"message/rfc822\", is the forwarded or rejected\n
      \  message.  Composing rejection and forwarding messages in this manner\n   will
      preserve the type information on the original message and allow\n   it to be
      correctly presented to the recipient, and hence is strongly\n   encouraged.\n
      \  Subtypes of \"message\" often impose restrictions on what encodings are\n
      \  allowed.  These restrictions are described in conjunction with each\n   specific
      subtype.\n   Mail gateways, relays, and other mail handling agents are commonly\n
      \  known to alter the top-level header of an RFC 822 message.  In\n   particular,
      they frequently add, remove, or reorder header fields.\n   These operations
      are explicitly forbidden for the encapsulated\n   headers embedded in the bodies
      of messages of type \"message.\"\n"
    - contents:
      - "5.2.1.  RFC822 Subtype\n   A media type of \"message/rfc822\" indicates that
        the body contains an\n   encapsulated message, with the syntax of an RFC 822
        message.\n   However, unlike top-level RFC 822 messages, the restriction that
        each\n   \"message/rfc822\" body must include a \"From\", \"Date\", and at
        least one\n   destination header is removed and replaced with the requirement
        that\n   at least one of \"From\", \"Subject\", or \"Date\" must be present.\n
        \  It should be noted that, despite the use of the numbers \"822\", a\n   \"message/rfc822\"
        entity isn't restricted to material in strict\n   conformance to RFC822, nor
        are the semantics of \"message/rfc822\"\n   objects restricted to the semantics
        defined in RFC822. More\n   specifically, a \"message/rfc822\" message could
        well be a News article\n   or a MIME message.\n   No encoding other than \"7bit\",
        \"8bit\", or \"binary\" is permitted for\n   the body of a \"message/rfc822\"
        entity.  The message header fields are\n   always US-ASCII in any case, and
        data within the body can still be\n   encoded, in which case the Content-Transfer-Encoding
        header field in\n   the encapsulated message will reflect this.  Non-US-ASCII
        text in the\n   headers of an encapsulated message can be specified using
        the\n   mechanisms described in RFC 2047.\n"
      title: 5.2.1.  RFC822 Subtype
    - contents:
      - "5.2.2.  Partial Subtype\n   The \"partial\" subtype is defined to allow large
        entities to be\n   delivered as several separate pieces of mail and automatically\n
        \  reassembled by a receiving user agent.  (The concept is similar to IP\n
        \  fragmentation and reassembly in the basic Internet Protocols.)  This\n
        \  mechanism can be used when intermediate transport agents limit the\n   size
        of individual messages that can be sent.  The media type\n   \"message/partial\"
        thus indicates that the body contains a fragment of\n   a larger entity.\n
        \  Because data of type \"message\" may never be encoded in base64 or\n   quoted-printable,
        a problem might arise if \"message/partial\" entities\n   are constructed
        in an environment that supports binary or 8bit\n   transport.  The problem
        is that the binary data would be split into\n   multiple \"message/partial\"
        messages, each of them requiring binary\n   transport.  If such messages were
        encountered at a gateway into a\n   7bit transport environment, there would
        be no way to properly encode\n   them for the 7bit world, aside from waiting
        for all of the fragments,\n   reassembling the inner message, and then encoding
        the reassembled\n   data in base64 or quoted-printable.  Since it is possible
        that\n   different fragments might go through different gateways, even this
        is\n   not an acceptable solution.  For this reason, it is specified that\n
        \  entities of type \"message/partial\" must always have a content-\n   transfer-encoding
        of 7bit (the default).  In particular, even in\n   environments that support
        binary or 8bit transport, the use of a\n   content- transfer-encoding of \"8bit\"
        or \"binary\" is explicitly\n   prohibited for MIME entities of type \"message/partial\".
        This in turn\n   implies that the inner message must not use \"8bit\" or \"binary\"\n
        \  encoding.\n   Because some message transfer agents may choose to automatically\n
        \  fragment large messages, and because such agents may use very\n   different
        fragmentation thresholds, it is possible that the pieces of\n   a partial
        message, upon reassembly, may prove themselves to comprise\n   a partial message.
        \ This is explicitly permitted.\n   Three parameters must be specified in
        the Content-Type field of type\n   \"message/partial\":  The first, \"id\",
        is a unique identifier, as close\n   to a world-unique identifier as possible,
        to be used to match the\n   fragments together. (In general, the identifier
        is essentially a\n   message-id; if placed in double quotes, it can be ANY
        message-id, in\n   accordance with the BNF for \"parameter\" given in RFC
        2045.)  The\n   second, \"number\", an integer, is the fragment number, which
        indicates\n   where this fragment fits into the sequence of fragments.  The
        third,\n   \"total\", another integer, is the total number of fragments.  This\n
        \  third subfield is required on the final fragment, and is optional\n   (though
        encouraged) on the earlier fragments.  Note also that these\n   parameters
        may be given in any order.\n   Thus, the second piece of a 3-piece message
        may have either of the\n   following header fields:\n     Content-Type: Message/Partial;
        number=2; total=3;\n                   id=\"oc=jpbe0M2Yt4s@thumper.bellcore.com\"\n
        \    Content-Type: Message/Partial;\n                   id=\"oc=jpbe0M2Yt4s@thumper.bellcore.com\";\n
        \                  number=2\n   But the third piece MUST specify the total
        number of fragments:\n     Content-Type: Message/Partial; number=3; total=3;\n
        \                  id=\"oc=jpbe0M2Yt4s@thumper.bellcore.com\"\n   Note that
        fragment numbering begins with 1, not 0.\n   When the fragments of an entity
        broken up in this manner are put\n   together, the result is always a complete
        MIME entity, which may have\n   its own Content-Type header field, and thus
        may contain any other\n   data type.\n"
      - contents:
        - "5.2.2.1.  Message Fragmentation and Reassembly\n   The semantics of a reassembled
          partial message must be those of the\n   \"inner\" message, rather than
          of a message containing the inner\n   message.  This makes it possible,
          for example, to send a large audio\n   message as several partial messages,
          and still have it appear to the\n   recipient as a simple audio message
          rather than as an encapsulated\n   message containing an audio message.
          \ That is, the encapsulation of\n   the message is considered to be \"transparent\".\n
          \  When generating and reassembling the pieces of a \"message/partial\"\n
          \  message, the headers of the encapsulated message must be merged with\n
          \  the headers of the enclosing entities.  In this process the following\n
          \  rules must be observed:\n    (1)   Fragmentation agents must split messages
          at line\n          boundaries only. This restriction is imposed because\n
          \         splits at points other than the ends of lines in turn\n          depends
          on message transports being able to preserve\n          the semantics of
          messages that don't end with a CRLF\n          sequence. Many transports
          are incapable of preserving\n          such semantics.\n    (2)   All of
          the header fields from the initial enclosing\n          message, except
          those that start with \"Content-\" and\n          the specific header fields
          \"Subject\", \"Message-ID\",\n          \"Encrypted\", and \"MIME-Version\",
          must be copied, in\n          order, to the new message.\n    (3)   The
          header fields in the enclosed message which start\n          with \"Content-\",
          plus the \"Subject\", \"Message-ID\",\n          \"Encrypted\", and \"MIME-Version\"
          fields, must be\n          appended, in order, to the header fields of the
          new\n          message.  Any header fields in the enclosed message\n          which
          do not start with \"Content-\" (except for the\n          \"Subject\", \"Message-ID\",
          \"Encrypted\", and \"MIME-\n          Version\" fields) will be ignored
          and dropped.\n    (4)   All of the header fields from the second and any\n
          \         subsequent enclosing messages are discarded by the\n          reassembly
          process.\n"
        title: 5.2.2.1.  Message Fragmentation and Reassembly
      - contents:
        - "5.2.2.2.  Fragmentation and Reassembly Example\n   If an audio message
          is broken into two pieces, the first piece might\n   look something like
          this:\n     X-Weird-Header-1: Foo\n     From: Bill@host.com\n     To: joe@otherhost.com\n
          \    Date: Fri, 26 Mar 1993 12:59:38 -0500 (EST)\n     Subject: Audio mail
          (part 1 of 2)\n     Message-ID: <id1@host.com>\n     MIME-Version: 1.0\n
          \    Content-type: message/partial; id=\"ABC@host.com\";\n                   number=1;
          total=2\n     X-Weird-Header-1: Bar\n     X-Weird-Header-2: Hello\n     Message-ID:
          <anotherid@foo.com>\n     Subject: Audio mail\n     MIME-Version: 1.0\n
          \    Content-type: audio/basic\n     Content-transfer-encoding: base64\n
          \      ... first half of encoded audio data goes here ...\n   and the second
          half might look something like this:\n     From: Bill@host.com\n     To:
          joe@otherhost.com\n     Date: Fri, 26 Mar 1993 12:59:38 -0500 (EST)\n     Subject:
          Audio mail (part 2 of 2)\n     MIME-Version: 1.0\n     Message-ID: <id2@host.com>\n
          \    Content-type: message/partial;\n                   id=\"ABC@host.com\";
          number=2; total=2\n       ... second half of encoded audio data goes here
          ...\n   Then, when the fragmented message is reassembled, the resulting\n
          \  message to be displayed to the user should look something like this:\n
          \    X-Weird-Header-1: Foo\n     From: Bill@host.com\n     To: joe@otherhost.com\n
          \    Date: Fri, 26 Mar 1993 12:59:38 -0500 (EST)\n     Subject: Audio mail\n
          \    Message-ID: <anotherid@foo.com>\n     MIME-Version: 1.0\n     Content-type:
          audio/basic\n     Content-transfer-encoding: base64\n       ... first half
          of encoded audio data goes here ...\n       ... second half of encoded audio
          data goes here ...\n   The inclusion of a \"References\" field in the headers
          of the second\n   and subsequent pieces of a fragmented message that references
          the\n   Message-Id on the previous piece may be of benefit to mail readers\n
          \  that understand and track references.  However, the generation of\n   such
          \"References\" fields is entirely optional.\n   Finally, it should be noted
          that the \"Encrypted\" header field has\n   been made obsolete by Privacy
          Enhanced Messaging (PEM) [RFC-1421,\n   RFC-1422, RFC-1423, RFC-1424], but
          the rules above are nevertheless\n   believed to describe the correct way
          to treat it if it is encountered\n   in the context of conversion to and
          from \"message/partial\" fragments.\n"
        title: 5.2.2.2.  Fragmentation and Reassembly Example
      title: 5.2.2.  Partial Subtype
    - contents:
      - "5.2.3.  External-Body Subtype\n   The external-body subtype indicates that
        the actual body data are not\n   included, but merely referenced.  In this
        case, the parameters\n   describe a mechanism for accessing the external data.\n
        \  When a MIME entity is of type \"message/external-body\", it consists of\n
        \  a header, two consecutive CRLFs, and the message header for the\n   encapsulated
        message.  If another pair of consecutive CRLFs appears,\n   this of course
        ends the message header for the encapsulated message.\n   However, since the
        encapsulated message's body is itself external, it\n   does NOT appear in
        the area that follows.  For example, consider the\n   following message:\n
        \    Content-type: message/external-body;\n                   access-type=local-file;\n
        \                  name=\"/u/nsb/Me.jpeg\"\n     Content-type: image/jpeg\n
        \    Content-ID: <id42@guppylake.bellcore.com>\n     Content-Transfer-Encoding:
        binary\n     THIS IS NOT REALLY THE BODY!\n   The area at the end, which might
        be called the \"phantom body\", is\n   ignored for most external-body messages.
        \ However, it may be used to\n   contain auxiliary information for some such
        messages, as indeed it is\n   when the access-type is \"mail- server\".  The
        only access-type defined\n   in this document that uses the phantom body is
        \"mail-server\", but\n   other access-types may be defined in the future in
        other\n   specifications that use this area.\n   The encapsulated headers
        in ALL \"message/external-body\" entities MUST\n   include a Content-ID header
        field to give a unique identifier by\n   which to reference the data.  This
        identifier may be used for caching\n   mechanisms, and for recognizing the
        receipt of the data when the\n   access-type is \"mail-server\".\n   Note
        that, as specified here, the tokens that describe external-body\n   data,
        such as file names and mail server commands, are required to be\n   in the
        US-ASCII character set.\n   If this proves problematic in practice, a new
        mechanism may be\n   required as a future extension to MIME, either as newly
        defined\n   access-types for \"message/external-body\" or by some other mechanism.\n
        \  As with \"message/partial\", MIME entities of type \"message/external-\n
        \  body\" MUST have a content-transfer-encoding of 7bit (the default).\n   In
        particular, even in environments that support binary or 8bit\n   transport,
        the use of a content- transfer-encoding of \"8bit\" or\n   \"binary\" is explicitly
        prohibited for entities of type\n   \"message/external-body\".\n"
      - contents:
        - "5.2.3.1.  General External-Body Parameters\n   The parameters that may
          be used with any \"message/external- body\"\n   are:\n    (1)   ACCESS-TYPE
          -- A word indicating the supported access\n          mechanism by which
          the file or data may be obtained.\n          This word is not case sensitive.
          \ Values include, but\n          are not limited to, \"FTP\", \"ANON-FTP\",
          \"TFTP\", \"LOCAL-\n          FILE\", and \"MAIL-SERVER\".  Future values,
          except for\n          experimental values beginning with \"X-\", must be\n
          \         registered with IANA, as described in RFC 2048.\n          This
          parameter is unconditionally mandatory and MUST be\n          present on
          EVERY \"message/external-body\".\n    (2)   EXPIRATION -- The date (in the
          RFC 822 \"date-time\"\n          syntax, as extended by RFC 1123 to permit
          4 digits in\n          the year field) after which the existence of the\n
          \         external data is not guaranteed.  This parameter may be\n          used
          with ANY access-type and is ALWAYS optional.\n    (3)   SIZE -- The size
          (in octets) of the data.  The intent\n          of this parameter is to
          help the recipient decide\n          whether or not to expend the necessary
          resources to\n          retrieve the external data.  Note that this describes\n
          \         the size of the data in its canonical form, that is,\n          before
          any Content-Transfer-Encoding has been applied\n          or after the data
          have been decoded.  This parameter\n          may be used with ANY access-type
          and is ALWAYS\n          optional.\n    (4)   PERMISSION -- A case-insensitive
          field that indicates\n          whether or not it is expected that clients
          might also\n          attempt to overwrite the data.  By default, or if\n
          \         permission is \"read\", the assumption is that they are\n          not,
          and that if the data is retrieved once, it is\n          never needed again.
          \ If PERMISSION is \"read-write\",\n          this assumption is invalid,
          and any local copy must be\n          considered no more than a cache.  \"Read\"
          and \"Read-\n          write\" are the only defined values of permission.
          \ This\n          parameter may be used with ANY access-type and is\n          ALWAYS
          optional.\n   The precise semantics of the access-types defined here are
          described\n   in the sections that follow.\n"
        title: 5.2.3.1.  General External-Body Parameters
      - contents:
        - "5.2.3.2.  The 'ftp' and 'tftp' Access-Types\n   An access-type of FTP or
          TFTP indicates that the message body is\n   accessible as a file using the
          FTP [RFC-959] or TFTP [RFC- 783]\n   protocols, respectively.  For these
          access-types, the following\n   additional parameters are mandatory:\n    (1)
          \  NAME -- The name of the file that contains the actual\n          body
          data.\n    (2)   SITE -- A machine from which the file may be obtained,\n
          \         using the given protocol.  This must be a fully\n          qualified
          domain name, not a nickname.\n    (3)   Before any data are retrieved, using
          FTP, the user will\n          generally need to be asked to provide a login
          id and a\n          password for the machine named by the site parameter.\n
          \         For security reasons, such an id and password are not\n          specified
          as content-type parameters, but must be\n          obtained from the user.\n
          \  In addition, the following parameters are optional:\n    (1)   DIRECTORY
          -- A directory from which the data named by\n          NAME should be retrieved.\n
          \   (2)   MODE -- A case-insensitive string indicating the mode\n          to
          be used when retrieving the information.  The valid\n          values for
          access-type \"TFTP\" are \"NETASCII\", \"OCTET\",\n          and \"MAIL\",
          as specified by the TFTP protocol [RFC-\n          783].  The valid values
          for access-type \"FTP\" are\n          \"ASCII\", \"EBCDIC\", \"IMAGE\",
          and \"LOCALn\" where \"n\" is a\n          decimal integer, typically 8.
          \ These correspond to the\n          representation types \"A\" \"E\" \"I\"
          and \"L n\" as specified\n          by the FTP protocol [RFC-959].  Note
          that \"BINARY\" and\n          \"TENEX\" are not valid values for MODE and
          that \"OCTET\"\n          or \"IMAGE\" or \"LOCAL8\" should be used instead.
          \ IF MODE\n          is not specified, the  default value is \"NETASCII\"
          for\n          TFTP and \"ASCII\" otherwise.\n"
        title: 5.2.3.2.  The 'ftp' and 'tftp' Access-Types
      - contents:
        - "5.2.3.3.  The 'anon-ftp' Access-Type\n   The \"anon-ftp\" access-type is
          identical to the \"ftp\" access type,\n   except that the user need not
          be asked to provide a name and password\n   for the specified site.  Instead,
          the ftp protocol will be used with\n   login \"anonymous\" and a password
          that corresponds to the user's mail\n   address.\n"
        title: 5.2.3.3.  The 'anon-ftp' Access-Type
      - contents:
        - "5.2.3.4.  The 'local-file' Access-Type\n   An access-type of \"local-file\"
          indicates that the actual body is\n   accessible as a file on the local
          machine.  Two additional parameters\n   are defined for this access type:\n
          \   (1)   NAME -- The name of the file that contains the actual\n          body
          data.  This parameter is mandatory for the\n          \"local-file\" access-type.\n
          \   (2)   SITE -- A domain specifier for a machine or set of\n          machines
          that are known to have access to the data\n          file.  This optional
          parameter is used to describe the\n          locality of reference for the
          data, that is, the site\n          or sites at which the file is expected
          to be visible.\n          Asterisks may be used for wildcard matching to
          a part\n          of a domain name, such as \"*.bellcore.com\", to indicate\n
          \         a set of machines on which the data should be directly\n          visible,
          while a single asterisk may be used to\n          indicate a file that is
          expected to be universally\n          available, e.g., via a global file
          system.\n"
        title: 5.2.3.4.  The 'local-file' Access-Type
      - contents:
        - "5.2.3.5.  The 'mail-server' Access-Type\n   The \"mail-server\" access-type
          indicates that the actual body is\n   available from a mail server.  Two
          additional parameters are defined\n   for this access-type:\n    (1)   SERVER
          -- The addr-spec of the mail server from which\n          the actual body
          data can be obtained.  This parameter\n          is mandatory for the \"mail-server\"
          access-type.\n    (2)   SUBJECT -- The subject that is to be used in the
          mail\n          that is sent to obtain the data.  Note that keying mail\n
          \         servers on Subject lines is NOT recommended, but such\n          mail
          servers are known to exist.  This is an optional\n          parameter.\n
          \  Because mail servers accept a variety of syntaxes, some of which is\n
          \  multiline, the full command to be sent to a mail server is not\n   included
          as a parameter in the content-type header field.  Instead,\n   it is provided
          as the \"phantom body\" when the media type is\n   \"message/external-body\"
          and the access-type is mail-server.\n   Note that MIME does not define a
          mail server syntax.  Rather, it\n   allows the inclusion of arbitrary mail
          server commands in the phantom\n   body.  Implementations must include the
          phantom body in the body of\n   the message it sends to the mail server
          address to retrieve the\n   relevant data.\n   Unlike other access-types,
          mail-server access is asynchronous and\n   will happen at an unpredictable
          time in the future.  For this reason,\n   it is important that there be
          a mechanism by which the returned data\n   can be matched up with the original
          \"message/external-body\" entity.\n   MIME mail servers must use the same
          Content-ID field on the returned\n   message that was used in the original
          \"message/external-body\"\n   entities, to facilitate such matching.\n"
        title: 5.2.3.5.  The 'mail-server' Access-Type
      - contents:
        - "5.2.3.6.  External-Body Security Issues\n   \"Message/external-body\" entities
          give rise to two important security\n   issues:\n    (1)   Accessing data
          via a \"message/external-body\" reference\n          effectively results
          in the message recipient performing\n          an operation that was specified
          by the message\n          originator.  It is therefore possible for the
          message\n          originator to trick a recipient into doing something\n
          \         they would not have done otherwise.  For example, an\n          originator
          could specify a action that attempts\n          retrieval of material that
          the recipient is not\n          authorized to obtain, causing the recipient
          to\n          unwittingly violate some security policy.  For this\n          reason,
          user agents capable of resolving external\n          references must always
          take steps to describe the\n          action they are to take to the recipient
          and ask for\n          explicit permisssion prior to performing it.\n          The
          'mail-server' access-type is particularly\n          vulnerable, in that
          it causes the recipient to send a\n          new message whose contents
          are specified by the\n          original message's originator.  Given the
          potential for\n          abuse, any such request messages that are constructed\n
          \         should contain a clear indication that they were\n          generated
          automatically (e.g. in a Comments: header\n          field) in an attempt
          to resolve a MIME\n          \"message/external-body\" reference.\n    (2)
          \  MIME will sometimes be used in environments that\n          provide some
          guarantee of message integrity and\n          authenticity.  If present,
          such guarantees may apply\n          only to the actual direct content of
          messages -- they\n          may or may not apply to data accessed through
          MIME's\n          \"message/external-body\" mechanism.  In particular, it\n
          \         may be possible to subvert certain access mechanisms\n          even
          when the messaging system itself is secure.\n          It should be noted
          that this problem exists either with\n          or without the availabilty
          of MIME mechanisms.  A\n          casual reference to an FTP site containing
          a document\n          in the text of a secure message brings up similar\n
          \         issues -- the only difference is that MIME provides for\n          automatic
          retrieval of such material, and users may\n          place unwarranted trust
          is such automatic retrieval\n          mechanisms.\n"
        title: 5.2.3.6.  External-Body Security Issues
      - contents:
        - "5.2.3.7.  Examples and Further Explanations\n   When the external-body
          mechanism is used in conjunction with the\n   \"multipart/alternative\"
          media type it extends the functionality of\n   \"multipart/alternative\"
          to include the case where the same entity is\n   provided in the same format
          but via different accces mechanisms.\n   When this is done the originator
          of the message must order the parts\n   first in terms of preferred formats
          and then by preferred access\n   mechanisms.  The recipient's viewer should
          then evaluate the list\n   both in terms of format and access mechanisms.\n
          \  With the emerging possibility of very wide-area file systems, it\n   becomes
          very hard to know in advance the set of machines where a file\n   will and
          will not be accessible directly from the file system.\n   Therefore it may
          make sense to provide both a file name, to be tried\n   directly, and the
          name of one or more sites from which the file is\n   known to be accessible.
          \ An implementation can try to retrieve remote\n   files using FTP or any
          other protocol, using anonymous file retrieval\n   or prompting the user
          for the necessary name and password.  If an\n   external body is accessible
          via multiple mechanisms, the sender may\n   include multiple entities of
          type \"message/external-body\" within the\n   body parts of an enclosing
          \"multipart/alternative\" entity.\n   However, the external-body mechanism
          is not intended to be limited to\n   file retrieval, as shown by the mail-server
          access-type.  Beyond\n   this, one can imagine, for example, using a video
          server for external\n   references to video clips.\n   The embedded message
          header fields which appear in the body of the\n   \"message/external-body\"
          data must be used to declare the media type\n   of the external body if
          it is anything other than plain US-ASCII\n   text, since the external body
          does not have a header section to\n   declare its type.  Similarly, any
          Content-transfer-encoding other\n   than \"7bit\" must also be declared
          here.  Thus a complete\n   \"message/external-body\" message, referring
          to an object in PostScript\n   format, might look like this:\n     From:
          Whomever\n     To: Someone\n     Date: Whenever\n     Subject: whatever\n
          \    MIME-Version: 1.0\n     Message-ID: <id1@host.com>\n     Content-Type:
          multipart/alternative; boundary=42\n     Content-ID: <id001@guppylake.bellcore.com>\n
          \    --42\n     Content-Type: message/external-body; name=\"BodyFormats.ps\";\n
          \                  site=\"thumper.bellcore.com\"; mode=\"image\";\n                   access-type=ANON-FTP;
          directory=\"pub\";\n                   expiration=\"Fri, 14 Jun 1991 19:13:14
          -0400 (EDT)\"\n     Content-type: application/postscript\n     Content-ID:
          <id42@guppylake.bellcore.com>\n     --42\n     Content-Type: message/external-body;
          access-type=local-file;\n                   name=\"/u/nsb/writing/rfcs/RFC-MIME.ps\";\n
          \                  site=\"thumper.bellcore.com\";\n                   expiration=\"Fri,
          14 Jun 1991 19:13:14 -0400 (EDT)\"\n     Content-type: application/postscript\n
          \    Content-ID: <id42@guppylake.bellcore.com>\n     --42\n     Content-Type:
          message/external-body;\n                   access-type=mail-server\n                   server=\"listserv@bogus.bitnet\";\n
          \                  expiration=\"Fri, 14 Jun 1991 19:13:14 -0400 (EDT)\"\n
          \    Content-type: application/postscript\n     Content-ID: <id42@guppylake.bellcore.com>\n
          \    get RFC-MIME.DOC\n     --42--\n   Note that in the above examples,
          the default Content-transfer-\n   encoding of \"7bit\" is assumed for the
          external postscript data.\n   Like the \"message/partial\" type, the \"message/external-body\"
          media\n   type is intended to be transparent, that is, to convey the data
          type\n   in the external body rather than to convey a message with a body
          of\n   that type.  Thus the headers on the outer and inner parts must be\n
          \  merged using the same rules as for \"message/partial\".  In particular,\n
          \  this means that the Content-type and Subject fields are overridden,\n
          \  but the From field is preserved.\n   Note that since the external bodies
          are not transported along with\n   the external body reference, they need
          not conform to transport\n   limitations that apply to the reference itself.
          In particular,\n   Internet mail transports may impose 7bit and line length
          limits, but\n   these do not automatically apply to binary external body
          references.\n   Thus a Content-Transfer-Encoding is not generally necessary,
          though\n   it is permitted.\n   Note that the body of a message of type
          \"message/external-body\" is\n   governed by the basic syntax for an RFC
          822 message.  In particular,\n   anything before the first consecutive pair
          of CRLFs is header\n   information, while anything after it is body information,
          which is\n   ignored for most access-types.\n"
        title: 5.2.3.7.  Examples and Further Explanations
      title: 5.2.3.  External-Body Subtype
    - contents:
      - "5.2.4.  Other Message Subtypes\n   MIME implementations must in general treat
        unrecognized subtypes of\n   \"message\" as being equivalent to \"application/octet-stream\".\n
        \  Future subtypes of \"message\" intended for use with email should be\n
        \  restricted to \"7bit\" encoding. A type other than \"message\" should be\n
        \  used if restriction to \"7bit\" is not possible.\n"
      title: 5.2.4.  Other Message Subtypes
    title: 5.2.  Message Media Type
  title: 5.  Composite Media Type Values
- contents:
  - "6.  Experimental Media Type Values\n   A media type value beginning with the
    characters \"X-\" is a private\n   value, to be used by consenting systems by
    mutual agreement.  Any\n   format without a rigorous and public definition must
    be named with an\n   \"X-\" prefix, and publicly specified values shall never
    begin with\n   \"X-\".  (Older versions of the widely used Andrew system use the
    \"X-\n   BE2\" name, so new systems should probably choose a different name.)\n
    \  In general, the use of \"X-\" top-level types is strongly discouraged.\n   Implementors
    should invent subtypes of the existing types whenever\n   possible. In many cases,
    a subtype of \"application\" will be more\n   appropriate than a new top-level
    type.\n"
  title: 6.  Experimental Media Type Values
- contents:
  - "7.  Summary\n   The five discrete media types provide provide a standardized\n
    \  mechanism for tagging entities as \"audio\", \"image\", or several other\n
    \  kinds of data. The composite \"multipart\" and \"message\" media types\n   allow
    mixing and hierarchical structuring of entities of different\n   types in a single
    message. A distinguished parameter syntax allows\n   further specification of
    data format details, particularly the\n   specification of alternate character
    sets.  Additional optional\n   header fields provide mechanisms for certain extensions
    deemed\n   desirable by many implementors. Finally, a number of useful media\n
    \  types are defined for general use by consenting user agents, notably\n   \"message/partial\"
    and \"message/external-body\".\n"
  title: 7.  Summary
- contents:
  - "9.  Security Considerations\n   Security issues are discussed in the context
    of the\n   \"application/postscript\" type, the \"message/external-body\" type,
    and\n   in RFC 2048.  Implementors should pay special attention to the\n   security
    implications of any media types that can cause the remote\n   execution of any
    actions in the recipient's environment.  In such\n   cases, the discussion of
    the \"application/postscript\" type may serve\n   as a model for considering other
    media types with remote execution\n   capabilities.\n"
  title: 9.  Security Considerations
- contents:
  - "9.  Authors' Addresses\n   For more information, the authors of this document
    are best contacted\n   via Internet mail:\n   Ned Freed\n   Innosoft International,
    Inc.\n   1050 East Garvey Avenue South\n   West Covina, CA 91790\n   USA\n   Phone:
    +1 818 919 3600\n   Fax:   +1 818 919 3614\n   EMail: ned@innosoft.com\n   Nathaniel
    S. Borenstein\n   First Virtual Holdings\n   25 Washington Avenue\n   Morristown,
    NJ 07960\n   USA\n   Phone: +1 201 540 8967\n   Fax:   +1 201 993 3032\n   EMail:
    nsb@nsb.fv.com\n   MIME is a result of the work of the Internet Engineering Task
    Force\n   Working Group on RFC 822 Extensions.  The chairman of that group,\n
    \  Greg Vaudreuil, may be reached at:\n   Gregory M. Vaudreuil\n   Octel Network
    Services\n   17080 Dallas Parkway\n   Dallas, TX 75248-1905\n   USA\n   EMail:
    Greg.Vaudreuil@Octel.Com\n"
  title: 9.  Authors' Addresses
- contents:
  - "Appendix A -- Collected Grammar\n   This appendix contains the complete BNF grammar
    for all the syntax\n   specified by this document.\n   By itself, however, this
    grammar is incomplete.  It refers by name to\n   several syntax rules that are
    defined by RFC 822.  Rather than\n   reproduce those definitions here, and risk
    unintentional differences\n   between the two, this document simply refers the
    reader to RFC 822\n   for the remaining definitions. Wherever a term is undefined,
    it\n   refers to the RFC 822 definition.\n     boundary := 0*69<bchars> bcharsnospace\n
    \    bchars := bcharsnospace / \" \"\n     bcharsnospace := DIGIT / ALPHA / \"'\"
    / \"(\" / \")\" /\n                      \"+\" / \"_\" / \",\" / \"-\" / \".\"
    /\n                      \"/\" / \":\" / \"=\" / \"?\"\n     body-part := <\"message\"
    as defined in RFC 822, with all\n                   header fields optional, not
    starting with the\n                   specified dash-boundary, and with the\n
    \                  delimiter not occurring anywhere in the\n                   body
    part.  Note that the semantics of a\n                   part differ from the semantics
    of a message,\n                   as described in the text.>\n     close-delimiter
    := delimiter \"--\"\n     dash-boundary := \"--\" boundary\n                      ;
    boundary taken from the value of\n                      ; boundary parameter of
    the\n                      ; Content-Type field.\n     delimiter := CRLF dash-boundary\n
    \    discard-text := *(*text CRLF)\n                     ; May be ignored or discarded.\n
    \    encapsulation := delimiter transport-padding\n                      CRLF
    body-part\n     epilogue := discard-text\n     multipart-body := [preamble CRLF]\n
    \                      dash-boundary transport-padding CRLF\n                       body-part
    *encapsulation\n                       close-delimiter transport-padding\n                       [CRLF
    epilogue]\n     preamble := discard-text\n     transport-padding := *LWSP-char\n
    \                         ; Composers MUST NOT generate\n                          ;
    non-zero length transport\n                          ; padding, but receivers
    MUST\n                          ; be able to handle padding\n                          ;
    added by message transports.\n"
  title: Appendix A -- Collected Grammar
