- contents:
  - "             RObust Header Compression Version 2 (ROHCv2):\n              Profiles
    for RTP, UDP, IP, ESP and UDP-Lite\n"
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Abstract\n   This document specifies ROHC (Robust Header Compression) profiles\n
    \  that efficiently compress RTP/UDP/IP (Real-Time Transport Protocol,\n   User
    Datagram Protocol, Internet Protocol), RTP/UDP-Lite/IP (User\n   Datagram Protocol
    Lite), UDP/IP, UDP-Lite/IP, IP and ESP/IP\n   (Encapsulating Security Payload)
    headers.\n   This specification defines a second version of the profiles found
    in\n   RFC 3095, RFC 3843 and RFC 4019; it supersedes their definition, but\n
    \  does not obsolete them.\n   The ROHCv2 profiles introduce a number of simplifications
    to the\n   rules and algorithms that govern the behavior of the compression\n
    \  endpoints.  It also defines robustness mechanisms that may be used by\n   a
    compressor implementation to increase the probability of\n   decompression success
    when packets can be lost and/or reordered on\n   the ROHC channel.  Finally, the
    ROHCv2 profiles define their own\n   specific set of header formats, using the
    ROHC formal notation.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .
    . . . . .   4\n   2.  Terminology . . . . . . . . . . . . . . . . . . . . . .
    . . .   4\n   3.  Acronyms  . . . . . . . . . . . . . . . . . . . . . . . . .
    .   7\n   4.  Background (Informative)  . . . . . . . . . . . . . . . . . .   7\n
    \    4.1.  Classification of Header Fields . . . . . . . . . . . . .   7\n     4.2.
    \ Improvements of ROHCv2 over RFC 3095 Profiles . . . . . .   8\n     4.3.  Operational
    Characteristics of ROHCv2 Profiles  . . . . .  10\n   5.  Overview of the ROHCv2
    Profiles (Informative) . . . . . . . .  10\n     5.1.  Compressor Concepts . .
    . . . . . . . . . . . . . . . . .  11\n       5.1.1.  Optimistic Approach . .
    . . . . . . . . . . . . . . .  11\n       5.1.2.  Tradeoff between Robustness
    to Losses and to\n               Reordering  . . . . . . . . . . . . . . . . .
    . . . .  11\n       5.1.3.  Interactions with the Decompressor Context  . . .
    . .  13\n     5.2.  Decompressor Concepts . . . . . . . . . . . . . . . . . .
    \ 14\n       5.2.1.  Decompressor State Machine  . . . . . . . . . . . . .  14\n
    \      5.2.2.  Decompressor Context Management . . . . . . . . . . .  17\n       5.2.3.
    \ Feedback Logic  . . . . . . . . . . . . . . . . . . .  19\n   6.  ROHCv2 Profiles
    (Normative) . . . . . . . . . . . . . . . . .  19\n     6.1.  Channel Parameters,
    Segmentation, and Reordering  . . . .  19\n     6.2.  Profile Operation, Per-context
    \ . . . . . . . . . . . . .  20\n     6.3.  Control Fields  . . . . . . . . .
    . . . . . . . . . . . .  21\n       6.3.1.  Master Sequence Number (MSN)  . .
    . . . . . . . . . .  21\n       6.3.2.  Reordering Ratio  . . . . . . . . . .
    . . . . . . . .  21\n       6.3.3.  IP-ID Behavior  . . . . . . . . . . . . .
    . . . . . .  22\n       6.3.4.  UDP-Lite Coverage Behavior  . . . . . . . . .
    . . . .  22\n       6.3.5.  Timestamp Stride  . . . . . . . . . . . . . . . .
    . .  22\n       6.3.6.  Time Stride . . . . . . . . . . . . . . . . . . . . .
    \ 22\n       6.3.7.  CRC-3 for Control Fields  . . . . . . . . . . . . . .  23\n
    \    6.4.  Reconstruction and Verification . . . . . . . . . . . . .  23\n     6.5.
    \ Compressed Header Chains  . . . . . . . . . . . . . . . .  24\n     6.6.  Header
    Formats and Encoding Methods . . . . . . . . . . .  25\n       6.6.1.  baseheader_extension_headers
    \ . . . . . . . . . . . .  26\n       6.6.2.  baseheader_outer_headers  . . .
    . . . . . . . . . . .  26\n       6.6.3.  inferred_udp_length . . . . . . . .
    . . . . . . . . .  26\n       6.6.4.  inferred_ip_v4_header_checksum  . . . .
    . . . . . . .  26\n       6.6.5.  inferred_mine_header_checksum . . . . . . .
    . . . . .  27\n       6.6.6.  inferred_ip_v4_length . . . . . . . . . . . . .
    . . .  28\n       6.6.7.  inferred_ip_v6_length . . . . . . . . . . . . . . .
    .  28\n       6.6.8.  Scaled RTP Timestamp Compression  . . . . . . . . . .  29\n
    \      6.6.9.  timer_based_lsb . . . . . . . . . . . . . . . . . . .  30\n       6.6.10.
    inferred_scaled_field . . . . . . . . . . . . . . . .  31\n       6.6.11. control_crc3_encoding
    . . . . . . . . . . . . . . . .  32\n       6.6.12. inferred_sequential_ip_id
    . . . . . . . . . . . . . .  33\n       6.6.13. list_csrc(cc_value) . . . . .
    . . . . . . . . . . . .  34\n     6.7.  Encoding Methods with External Parameters
    as Arguments  .  38\n     6.8.  Header Formats  . . . . . . . . . . . . . . .
    . . . . . .  40\n       6.8.1.  Initialization and Refresh Header Format (IR)
    . . . .  40\n       6.8.2.  Compressed Header Formats (CO)  . . . . . . . . .
    . .  41\n     6.9.  Feedback Formats and Options  . . . . . . . . . . . . . .
    100\n       6.9.1.  Feedback Formats  . . . . . . . . . . . . . . . . . . 100\n
    \      6.9.2.  Feedback Options  . . . . . . . . . . . . . . . . . . 102\n   7.
    \ Security Considerations . . . . . . . . . . . . . . . . . . . 104\n   8.  IANA
    Considerations . . . . . . . . . . . . . . . . . . . . . 105\n   9.  Acknowledgements
    \ . . . . . . . . . . . . . . . . . . . . . . 105\n   10. References  . . . .
    . . . . . . . . . . . . . . . . . . . . . 106\n     10.1. Normative References
    \ . . . . . . . . . . . . . . . . . . 106\n     10.2. Informative References  .
    . . . . . . . . . . . . . . . . 107\n   Appendix A.    Detailed Classification
    of Header Fields . . . . . 108\n     A.1.  IPv4 Header Fields  . . . . . . . .
    . . . . . . . . . . . 109\n     A.2.  IPv6 Header Fields  . . . . . . . . . .
    . . . . . . . . . 112\n     A.3.  UDP Header Fields   . . . . . . . . . . . .
    . . . . . . . 113\n     A.4.  UDP-Lite Header Fields  . . . . . . . . . . . .
    . . . . . 114\n     A.5.  RTP Header Fields . . . . . . . . . . . . . . . . .
    . . . 115\n     A.6.  ESP Header Fields . . . . . . . . . . . . . . . . . . .
    . 117\n     A.7.  IPv6 Extension Header Fields  . . . . . . . . . . . . . . 117\n
    \    A.8.  GRE Header Fields . . . . . . . . . . . . . . . . . . . . 118\n     A.9.
    \ MINE Header Fields  . . . . . . . . . . . . . . . . . . . 119\n     A.10. AH
    Header Fields  . . . . . . . . . . . . . . . . . . . . 120\n   Appendix B.    Compressor
    Implementation Guidelines . . . . . . . 121\n     B.1.  Reference Management  .
    . . . . . . . . . . . . . . . . . 121\n     B.2.  Window-based LSB Encoding (W-LSB)
    \ . . .  . . . . . . . . 121\n     B.3.  W-LSB Encoding and Timer-based Compression
    \ . . . . . . . 122\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The ROHC WG has developed a header compression framework
    on top of\n   which various profiles can be defined for different protocol sets
    or\n   compression requirements.  The ROHC framework was first documented in\n
    \  [RFC3095], together with profiles for compression of RTP/UDP/IP\n   (Real-Time
    Transport Protocol, User Datagram Protocol, Internet\n   Protocol), UDP/IP, IP
    and ESP/IP (Encapsulating Security Payload)\n   headers.  Additional profiles
    for compression of IP headers [RFC3843]\n   and UDP-Lite (User Datagram Protocol
    Lite) headers [RFC4019] were\n   later specified to complete the initial set of
    ROHC profiles.\n   This document defines an updated version for each of the above\n
    \  mentioned profiles, and the definitions depend on the ROHC framework\n   as
    found in [RFC4995].  The framework is required reading to\n   understand the profile
    definitions, rules, and their role.\n   Specifically, this document defines header
    compression schemes for:\n   o RTP/UDP/IP      : profile 0x0101\n   o UDP/IP          :
    profile 0x0102\n   o ESP/IP          : profile 0x0103\n   o IP              :
    profile 0x0104\n   o RTP/UDP-Lite/IP : profile 0x0107\n   o UDP-Lite/IP     :
    profile 0x0108\n   Each of the profiles above can compress the following type
    of\n   extension headers:\n   o  AH [RFC4302]\n   o  GRE [RFC2784][RFC2890]\n
    \  o  MINE [RFC2004]\n   o  IPv6 Destination Options header[RFC2460]\n   o  IPv6
    Hop-by-hop Options header[RFC2460]\n   o  IPv6 Routing header [RFC2460]\n"
  title: 1.  Introduction
- contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
    \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\"
    in this\n   document are to be interpreted as described in RFC 2119 [RFC2119].\n
    \  This document is consistent with the terminology found in the ROHC\n   framework
    [RFC4995] and in the formal notation for ROHC [RFC4997].\n   In addition, this
    document uses or defines the following terms:\n   Acknowledgment Number\n      The
    Acknowledgment Number identifies what packet is being\n      acknowledged in the
    RoHCv2 feedback element (See Section 6.9).\n      The value of this field normally
    corresponds to the Master\n      Sequence Number (MSN) of the header that was
    last successfully\n      decompressed, for the compression context (CID) for which
    the\n      feedback information applies.\n   Chaining of Items\n      A chain
    of items groups fields based on similar characteristics.\n      ROHCv2 defines
    chain items for static, dynamic and irregular\n      fields.  Chaining is achieved
    by appending an item to the chain\n      for each header in its order of appearance
    in the uncompressed\n      packet.  Chaining is useful to construct compressed
    headers from\n      an arbitrary number of any of the protocol headers for which
    a\n      ROHCv2 profile defines a compressed format.\n   CRC-3 Control Fields
    Validation\n      The CRC-3 control fields validation refers to the validation
    of\n      the control fields.  This validation is performed by the\n      decompressor
    when it receives a Compressed (CO) header that\n      contains a 3-bit Cyclic
    Redundancy Check (CRC) calculated over\n      control fields.  This 3-bit CRC
    covers controls fields carried in\n      the CO header as well as specific control
    fields in the context.\n      In the formal definition of the header formats,
    this 3-bit CRC is\n      labeled \"control_crc3\" and uses the control_crc3_encoding
    (See\n      also Section 6.6.11).\n   Delta\n      The delta refers to the difference
    in the absolute value of a\n      field between two consecutive packets being
    processed by the same\n      compression endpoint.\n   Reordering Depth\n      The
    number of packets by which a packet is received late within\n      its sequence
    due to reordering between the compressor and the\n      decompressor, i.e., reordering
    between packets associated with the\n      same context (CID).  See the definition
    of sequentially late\n      packet below.\n   ROHCv2 Header Types\n      ROHCv2
    profiles use two different header types: the Initialization\n      and Refresh
    (IR) header type, and the Compressed (CO) header type.\n   Sequentially Early
    Packet\n      A packet that reaches the decompressor before one or several\n      packets
    that were delayed over the channel, where all of the said\n      packets belong
    to the same header-compressed flow and are\n      associated to the same compression
    context (CID).  At the time of\n      the arrival of a sequentially early packet,
    the packet(s) delayed\n      on the link cannot be differentiated from lost packet(s).\n
    \  Sequentially Late Packet\n      A packet is late within its sequence if it
    reaches the\n      decompressor after one or several other packets belonging to
    the\n      same CID have been received, although the sequentially late packet\n
    \     was sent from the compressor before the other packet(s).  How the\n      decompressor
    detects a sequentially late packet is outside the\n      scope of this specification,
    but it can for example use the MSN\n      for this purpose.\n   Timestamp Stride
    (ts_stride)\n      The timestamp stride (ts_stride) is the expected increase in
    the\n      timestamp value between two RTP packets with consecutive sequence\n
    \     numbers.  For example, for a media encoding with a sample rate of\n      8
    kHz producing one frame every 20 ms, the RTP timestamp will\n      typically increase
    by n * 160 (= 8000 * 0.02), for some integer n.\n   Time Stride (time_stride)\n
    \     The time stride (time_stride) is the time interval equivalent to\n      one
    ts_stride, e.g., 20 ms in the example for the RTP timestamp\n      increment above.\n"
  title: 2.  Terminology
- contents:
  - "3.  Acronyms\n   This section lists most acronyms used for reference, in addition
    to\n   those defined in [RFC4995].\n   AH       Authentication Header.\n   ESP
    \     Encapsulating Security Payload.\n   GRE      Generic Routing Encapsulation.\n
    \  FC       Full Context state (decompressor).\n   IP       Internet Protocol.\n
    \  LSB      Least Significant Bits.\n   MINE     Minimal Encapsulation in IP.\n
    \  MSB      Most Significant Bits.\n   MSN      Master Sequence Number.\n   NC
    \      No Context state (decompressor).\n   OA       Optimistic Approach.\n   RC
    \      Repair Context state (decompressor).\n   ROHC     Header compression framework
    (RFC 4995).\n   ROHCv2   Set of header compression profiles defined in this document.\n
    \  RTP      Real-time Transport Protocol.\n   SSRC     Synchronization source.
    Field in RTP header.\n   CSRC     Contributing source.  The RTP header contains
    an optional\n            list of contributing sources.\n   TC       Traffic Class.
    \ Field in the IPv6 header.  See also TOS.\n   TOS      Type Of Service.  Field
    in the IPv4 header.  See also TC.\n   TS       RTP Timestamp.\n   TTL      Time
    to Live.  Field in the IPv4 header.\n   UDP      User Datagram Protocol.\n   UDP-Lite
    User Datagram Protocol Lite.\n"
  title: 3.  Acronyms
- contents:
  - "4.  Background (Informative)\n   This section provides background information
    on the compression\n   profiles defined in this document.  The fundamentals of
    general\n   header compression and of the ROHC framework may be found in sections\n
    \  3 and 4 of [RFC4995], respectively.  The fundamentals of the formal\n   notation
    for ROHC are defined in [RFC4997].  [RFC4224] describes the\n   impacts of out-of-order
    delivery on profiles based on [RFC3095].\n"
  - contents:
    - "4.1.  Classification of Header Fields\n   Section 3.1 of [RFC4995] explains
      that header compression is possible\n   due to the fact that there is much redundancy
      between field values\n   within the headers of a packet, especially between
      the headers of\n   consecutive packets.\n   Appendix A lists and classifies
      in detail all the header fields\n   relevant to this document.  The appendix
      concludes with\n   recommendations on how the various fields should be handled
      by header\n   compression algorithms.\n   The main conclusion is that most of
      the header fields can easily be\n   compressed away since they never or seldom
      change.  A small number of\n   fields however need more sophisticated mechanisms.\n
      \  These fields are:\n   - IPv4 Identification        (16 bits) - IP-ID\n   -
      ESP Sequence Number        (32 bits) - ESP SN\n   - UDP Checksum               (16
      bits) - Checksum\n   - UDP-Lite Checksum          (16 bits) - Checksum\n   -
      UDP-Lite Checksum Coverage (16 bits) - CCov\n   - RTP Marker                 (
      1 bit ) - M-bit\n   - RTP Sequence Number        (16 bits) - RTP SN\n   - RTP
      Timestamp              (32 bits) - TS\n   In particular, for RTP, the analysis
      in Appendix A reveals that the\n   values of the RTP Timestamp (TS) field usually
      have a strong\n   correlation to the RTP Sequence Number (SN), which increments
      by one\n   for each packet emitted by an RTP source.  The RTP M-bit is expected\n
      \  to have the same value most of the time, but it needs to be\n   communicated
      explicitly on occasion.\n   For UDP, the Checksum field cannot be inferred or
      recalculated at the\n   receiving end without violating its end-to-end properties,
      and is\n   thus sent as-is when enabled (mandatory with IPv6).  The same applies\n
      \  to the UDP-Lite Checksum (mandatory with both IPv4 and IPv6), while\n   the
      UDP-Lite Checksum Coverage may in some cases be compressible.\n   For IPv4,
      a similar correlation as that of the RTP TS to the RTP SN\n   is often observed
      between the Identifier field (IP-ID) and the master\n   sequence number (MSN)
      used for compression (e.g., the RTP SN when\n   compressing RTP headers).\n"
    title: 4.1.  Classification of Header Fields
  - contents:
    - "4.2.  Improvements of ROHCv2 over RFC 3095 Profiles\n   The ROHCv2 profiles
      can achieve compression efficiency and robustness\n   that are both at least
      equivalent to RFC 3095 profiles [RFC3095],\n   when used under the same operating
      conditions.  In particular, the\n   size and bit layout of the smallest compressed
      header (i.e., PT-0\n   format U/O-0 in RFC 3095, and pt_0_crc3 in ROHCv2) are
      identical.\n   There are a number of differences and improvements between profiles\n
      \  defined in this document and their earlier version defined in RFC\n   3095.
      \ This section provides an overview of some of the most\n   significant improvements:\n
      \  Tolerance to reordering\n      Profiles defined in RFC 3095 require that
      the channel between\n      compressor and decompressor provide in-order delivery
      between\n      compression endpoints.  ROHCv2 profiles, however, can handle\n
      \     robustly and efficiently a limited amount of reordering after the\n      compression
      point as part of the compression algorithm itself.  In\n      addition, this
      improved support for reordering makes it possible\n      for ROHCv2 profiles
      to handle prelink reordering more efficiently.\n   Operational logic\n      Profiles
      in RFC 3095 define multiple operational modes, each with\n      different updating
      logic and compressed header formats.  ROHCv2\n      profiles operate in unidirectional
      operation until feedback is\n      first received for a context (CID), at which
      point bidirectional\n      operation is used; the formats are independent of
      what operational\n      logic is used.\n   IP extension header\n      Profiles
      in RFC 3095 compress IP Extension headers using list\n      compression.  ROHCv2
      profiles instead treat extension headers in\n      the same manner as other
      protocol headers, i.e., using the\n      chaining mechanism; it thus assumes
      that extension headers are not\n      added or removed during the lifetime of
      a context (CID), otherwise\n      compression has to be restarted for this flow.\n
      \  IP encapsulation\n      Profiles in RFC 3095 can compress at most two levels
      of IP\n      headers.  ROHCv2 profiles can compress an arbitrary number of IP\n
      \     headers.\n   List compression\n      ROHCv2 profiles do not support reference-based
      list compression.\n   Robustness and repairs\n      ROHCv2 profiles do not define
      a format for the IR-DYN packet;\n      instead, each profile defines a compressed
      header that can be used\n      to perform a more robust context repair using
      a 7-bit CRC\n      verification.  This also implies that only the IR header
      can\n      change the association between a CID and the profile it uses.\n   Feedback\n
      \     ROHCv2 profiles mandate a CRC in the format of the FEEDBACK-2,\n      while
      this is optional in RFC 3095.  A different set of feedback\n      options is
      also used in ROHCv2 compared to RFC 3095.\n"
    title: 4.2.  Improvements of ROHCv2 over RFC 3095 Profiles
  - contents:
    - "4.3.  Operational Characteristics of ROHCv2 Profiles\n   Robust header compression
      can be used over different link\n   technologies.  Section 4.4 of [RFC4995]
      lists the operational\n   characteristics of the ROHC channel.  The ROHCv2 profiles
      address a\n   wide range of applications, and this section summarizes some of
      the\n   operational characteristics that are specific to these profiles.\n   Packet
      length\n      ROHCv2 profiles assume that the lower layer indicates the length\n
      \     of a compressed packet.  ROHCv2 compressed headers do not contain\n      length
      information for the payload.\n   Out-of-order delivery between compression endpoints\n
      \     The definition of the ROHCv2 profiles places no strict requirement\n      on
      the delivery sequence between the compression endpoints, i.e.,\n      packets
      may be received in a different order than the compressor\n      has sent them
      and still have a fair probability of being\n      successfully decompressed.\n
      \     However, frequent out-of-order delivery and/or significant\n      reordering
      depth will negatively impact the compression\n      efficiency.  More specifically,
      if the compressor can operate\n      using a proper estimate of the reordering
      characteristics of the\n      path between the compression endpoints, larger
      headers can be sent\n      more often to increase the robustness against decompression\n
      \     failures due to out-of-order delivery.  Otherwise, the compression\n      efficiency
      will be impaired from an increase in the frequency of\n      decompression failures
      and recovery attempts.\n"
    title: 4.3.  Operational Characteristics of ROHCv2 Profiles
  title: 4.  Background (Informative)
- contents:
  - "5.  Overview of the ROHCv2 Profiles (Informative)\n   This section provides an
    overview of concepts that are important and\n   useful to the ROHCv2 profiles.
    \ These concepts may be used as\n   guidelines for implementations but they are
    not part of the normative\n   definition of the profiles, as these concepts relate
    to the\n   compression efficiency of the protocol without impacting the\n   interoperability
    characteristics of an implementation.\n"
  - contents:
    - "5.1.  Compressor Concepts\n   Header compression can be conceptually characterized
      as the\n   interaction of a compressor with a decompressor state machine, one\n
      \  per context.  The responsibility of the compressor is to convey the\n   information
      needed to successfully decompress a packet, based on a\n   certain confidence
      regarding the state of the decompressor context.\n   This confidence is obtained
      from the frequency and the type of\n   information the compressor sends when
      updating the decompressor\n   context from the optimistic approach (Section
      5.1.1), and optionally\n   from feedback messages (See Section 6.9), received
      from the\n   decompressor.\n"
    - contents:
      - "5.1.1.  Optimistic Approach\n   A compressor always uses the optimistic approach
        when it performs\n   context updates.  The compressor normally repeats the
        same type of\n   update until it is fairly confident that the decompressor
        has\n   successfully received the information.  If the decompressor\n   successfully
        receives any of the headers containing this update, the\n   state will be
        available for the decompressor to process smaller\n   compressed headers.\n
        \  If field X in the uncompressed header changes value, the compressor\n   uses
        a header type that contains an encoding of field X until it has\n   gained
        confidence that the decompressor has received at least one\n   packet containing
        the new value for X.  The compressor normally\n   selects a compressed format
        with the smallest header that can convey\n   the changes needed to achieve
        confidence.\n   The number of repetitions that is needed to obtain this confidence
        is\n   normally related to the packet loss and out-of-order delivery\n   characteristics
        of the link where header compression is used; it is\n   thus not defined in
        this document.  It is outside the scope of this\n   specification and is left
        to implementors to decide.\n"
      title: 5.1.1.  Optimistic Approach
    - contents:
      - "5.1.2.  Tradeoff between Robustness to Losses and to Reordering\n   The ability
        of a header compression algorithm to handle sequentially\n   late packets
        is mainly limited by two factors: the interpretation\n   interval offset of
        the sliding window used for lsb encoded fields\n   [RFC4997], and the optimistic
        approach (See Section 5.1.1) for seldom\n   changing fields.\n   lsb encoded
        fields:\n      The interpretation interval offset specifies an upper limit
        for\n      the maximum reordering depth, by which is it possible for the\n
        \     decompressor to recover the original value of a dynamically\n      changing
        (i.e., sequentially incrementing) field that is encoded\n      using a window-based
        lsb encoding.  Its value is typically bound\n      to the number of lsb compressed
        bits in the compressed header\n      format, and thus grows with the number
        of bits transmitted.\n      However, the offset and the lsb encoding only
        provide robustness\n      for the field that it compresses, and (implicitly)
        for other\n      sequentially changing fields that are derived from that field.\n
        \     This is shown in the figure below:\n         <--- interpretation interval
        (size is 2^k) ---->\n         |------------------+---------------------------|\n
        \     v_ref-p             v_ref              v_ref + (2^k-1) - p\n       Lower
        \                                         Upper\n       Bound                                          Bound\n
        \        <--- reordering --> <--------- losses --------->\n         where
        p is the maximum negative delta, corresponding to the\n         maximum reordering
        depth for which the lsb encoding can recover\n         the original value
        of the field;\n         where (2^k-1) - p is the maximum positive delta, corresponding\n
        \        to the maximum number of consecutive losses for which the lsb\n         encoding
        can recover the original value of the field;\n         where v_ref is the
        reference value, as defined in the lsb\n         encoding method in [RFC4997].\n
        \     There is thus a tradeoff between the robustness against reordering\n
        \     and the robustness against packet losses, with respect to the\n      number
        of MSN bits needed and the distribution of the\n      interpretation interval
        between negative and positive deltas in\n      the MSN.\n   Seldom changing
        fields\n      The optimistic approach (Section 5.1.1) provides the upper limit\n
        \     for the maximum reordering depth for seldom changing fields.\n   There
        is thus a tradeoff between compression efficiency and\n   robustness.  When
        only information on the MSN needs to be conveyed to\n   the decompressor,
        the tradeoff relates to the number of compressed\n   MSN bits in the compressed
        header format.  Otherwise, the tradeoff\n   relates to the implementation
        of the optimistic approach.\n   In particular, compressor implementations
        should adjust their\n   optimistic approach strategy to match both packet
        loss and reordering\n   characteristics of the link over which header compression
        is applied.\n   For example, the number of repetitions for each update of
        a non-lsb\n   encoded field can be increased.  The compressor can ensure that
        each\n   update is repeated until it is reasonably confident that at least
        one\n   packet containing the change has reached the decompressor before the\n
        \  first packet sent after this sequence.\n"
      title: 5.1.2.  Tradeoff between Robustness to Losses and to Reordering
    - contents:
      - "5.1.3.  Interactions with the Decompressor Context\n   The compressor normally
        starts compression with the initial\n   assumption that the decompressor has
        no useful information to process\n   the new flow, and sends Initialization
        and Refresh (IR) packets.\n   Initially, when sending the first IR packet
        for a compressed flow,\n   the compressor does not expect to receive feedback
        for that flow,\n   until such feedback is first received.  At this point,
        the compressor\n   may then assume that the decompressor will continue to
        send feedback\n   in order to repair its context when necessary.  The former
        is\n   referred to as unidirectional operation, while the latter is called\n
        \  bidirectional operation.\n   The compressor can then adjust the compression
        level (i.e., what\n   header format it selects) based on its confidence that
        the\n   decompressor has the necessary information to successfully process\n
        \  the compressed headers that it selects.\n   In other words, the responsibilities
        of the compressor are to ensure\n   that the decompressor operates with state
        information that is\n   sufficient to successfully decompress the type of
        compressed\n   header(s) it receives, and to allow the decompressor to successfully\n
        \  recover that state information as soon as possible otherwise.  The\n   compressor
        therefore selects the type of compressed header based on\n   the following
        factors:\n   o  the outcome of the encoding method applied to each field;\n
        \  o  the optimistic approach, with respect to the characteristics of\n      the
        channel;\n   o  the type of operation (unidirectional or bidirectional), and
        if in\n      bidirectional operation, feedback received from the decompressor\n
        \     (ACKs, NACKs, STATIC-NACK, and options).\n   Encoding methods normally
        use previous value(s) from a history of\n   packets whose headers it has previously
        compressed.  The optimistic\n   approach is meant to ensure that at least
        one compressed header\n   containing the information to update the state for
        a field is\n   received.  Finally, feedback indicates what actions the decompressor\n
        \  has taken with respect to its assumptions regarding the validity of\n   its
        context (Section 5.2.2); it indicates what type of compressed\n   header the
        decompressor can or cannot decompress.\n   The decompressor has the means
        to detect decompression failures for\n   any compressed (CO) header format,
        using the CRC verification.\n   Depending on the frequency and/or on the type
        of the failure, it\n   might send a negative acknowledgement (NACK) or an
        explicit request\n   for a complete context update (STATIC-NACK).  However,
        the\n   decompressor does not have the means to identify the cause of the\n
        \  failure, and in particular the decompression of what field(s) is\n   responsible
        for the failure.  The compressor is thus always\n   responsible for determining
        the most suitable response to a negative\n   acknowledgement, using the confidence
        it has in the state of the\n   decompressor context, when selecting the type
        of compressed header it\n   will use when compressing a header.\n"
      title: 5.1.3.  Interactions with the Decompressor Context
    title: 5.1.  Compressor Concepts
  - contents:
    - "5.2.  Decompressor Concepts\n   The decompressor normally uses the last received
      and successfully\n   validated (IR packets) or verified (CO packets) header
      as the\n   reference for future decompression.\n   The decompressor is responsible
      for verifying the outcome of every\n   decompression attempt, to update its
      context when successful, and\n   finally to request context repairs by making
      coherent usage of\n   feedback once it has started using feedback.\n   Specifically,
      the outcome of every decompression attempt is verified\n   using the CRC present
      in the compressed header; the decompressor\n   updates the context information
      when this outcome is successfully\n   verified; finally, if the decompressor
      uses feedback once for a\n   compressed flow, then it will continue to do so
      for as long as the\n   corresponding context is associated with the same profile.\n"
    - contents:
      - "5.2.1.  Decompressor State Machine\n   The decompressor operation may be
        represented as a state machine\n   defining three states: No Context (NC),
        Repair Context (RC), and Full\n   Context (FC).\n   The decompressor starts
        without a valid context, the NC state.  Upon\n   receiving an IR packet, the
        decompressor validates the integrity of\n   its header using the CRC-8 validation.
        \ If the IR header is\n   successfully validated, the decompressor updates
        the context and uses\n   this header as the reference header, and moves to
        the FC state.  Once\n   the decompressor state machine has entered the FC
        state, it does not\n   normally leave; only repeated decompression failures
        will force the\n   decompressor to transit downwards to a lower state.  When
        context\n   damage is detected, the decompressor moves to the repair context
        (RC)\n   state, where it stays until it successfully verifies a decompression\n
        \  attempt for a compressed header with a 7-bit CRC or until it\n   successfully
        validates an IR header.  When static context damage is\n   detected, the decompressor
        moves back to the NC state.\n   Below is the state machine for the decompressor.
        \ Details of the\n   transitions between states and decompression logic are
        given in the\n   sub-sections following the figure.\n  CRC-8(IR) Validation\n
        \  +----->----->----->----->----->----->----->----->----->----->----+\n   |
        \                                                 CRC-8(IR)     |\n   |  !CRC-8(IR)
        or      CRC-7(CO) or                 or CRC-7(CO)  |\n   |  PT not allowed
        \    CRC-8(IR)                    or CRC-3(CO)  |\n   |  +--->---+         +--->----->----->----->---+
        \ +--->---->---+ |\n   |  |       |         |                         |  |
        \           | |\n   |  |       v         |                         v  |            v
        v\n  +-----------------+  +----------------------+  +--------------------+\n
        \ | No Context (NC) |  | Repair Context (RC)  |  | Full Context (FC)  |\n
        \ +-----------------+  +----------------------+  +--------------------+\n
        \   ^ ^ Static Context  | ^ !CRC-7(CO) or  | ^ Context Damage  | |\n    |
        | Damage Detected | | PT not allowed | | Detected        | |\n    | +--<-----<-----<--+
        +----<------<----+ +--<-----<-----<--+ |\n    |                                                            |\n
        \   |            Static Context Damage Detected                  |\n    +--<-----<-----<-----<-----<-----<-----<-----<-----<---------+\n
        \ where:\n    CRC-8(IR)        : Successful CRC-8 validation for the IR header.\n
        \   !CRC-8(IR)       : Unsuccessful CRC-8 validation for the IR header.\n
        \   CRC-7(CO) and/or\n    CRC-3(CO)        : Successful CRC verification for
        the decompression\n                       of a CO header, based on the number
        of CRC bits\n                       carried in the CO header.\n    !CRC-7(CO)
        \      : Failure to CRC verify the decompression of a CO\n                       header
        carrying a 7-bit CRC.\n    PT not allowed   : The decompressor has received
        a packet type (PT)\n                       for which the decompressor's current
        context does\n                       not provide enough valid state information
        to\n                       decompress the packet.\n      Static Context Damage
        Detected: See definition in Section 5.2.2.\n      Context Damage Detected:
        See definition in Section 5.2.2.\n"
      - contents:
        - "5.2.1.1.  No Context (NC) State\n   Initially, while working in the No
          Context (NC) state, the\n   decompressor has not yet successfully validated
          an IR header.\n   Attempting decompression:\n      In the NC state, only
          packets carrying sufficient information on\n      the static fields (i.e.,
          IR packets) can be decompressed.\n   Upward transition:\n      The decompressor
          can move to the Full Context (FC) state when the\n      CRC validation of
          an 8-bit CRC in an IR header is successful.\n   Feedback logic:\n      In
          the NC state, the decompressor should send a STATIC-NACK if a\n      packet
          of a type other than IR is received, or if an IR header has\n      failed
          the CRC-8 validation, subject to the feedback rate\n      limitation as
          described in Section 5.2.3.\n"
        title: 5.2.1.1.  No Context (NC) State
      - contents:
        - "5.2.1.2.  Repair Context (RC) State\n   In the Repair Context (RC) state,
          the decompressor has successfully\n   decompressed packets for this context,
          but does not have confidence\n   that the entire context is valid.\n   Attempting
          decompression:\n      In the RC state, only headers covered by an 8-bit
          CRC (i.e., IR)\n      or CO headers carrying a 7-bit CRC can be decompressed.\n
          \  Upward transition:\n      The decompressor can move to the Full Context
          (FC) state when the\n      CRC verification succeeds for a CO header carrying
          a 7-bit CRC or\n      when validation of an 8-bit CRC in an IR header succeeds.\n
          \  Downward transition:\n      The decompressor moves back to the NC state
          if it assumes static\n      context damage.\n   Feedback logic:\n      In
          the RC state, the decompressor should send a STATIC-NACK when\n      CRC-8
          validation of an IR header fails, or when a CO header\n      carrying a
          7-bit CRC fails and static context damage is assumed,\n      subject to
          the feedback rate limitation as described in\n      Section 5.2.3.  If any
          other packet type is received, the\n      decompressor should treat it as
          a CRC verification failure to\n      determine if NACK is to be sent.\n"
        title: 5.2.1.2.  Repair Context (RC) State
      - contents:
        - "5.2.1.3.  Full Context (FC) State\n   In the Full Context (FC) state, the
          decompressor assumes that its\n   entire context is valid.\n   Attempting
          decompression:\n      In the FC state, decompression can be attempted regardless
          of the\n      type of packet received.\n   Downward transition:\n      The
          decompressor moves back to the RC state if it assumes context\n      damage.
          \ If the decompressor assumes static context damage, it\n      moves directly
          to the NC state.\n   Feedback logic:\n      In the FC state, the decompressor
          should send a NACK when CRC-8\n      validation or CRC verification of any
          header type fails and if\n      context damage is assumed, or it should
          send a STATIC-NACK if\n      static context damage is assumed; this is subject
          to the feedback\n      rate limitation described in Section 5.2.3.\n"
        title: 5.2.1.3.  Full Context (FC) State
      title: 5.2.1.  Decompressor State Machine
    - contents:
      - "5.2.2.  Decompressor Context Management\n   All header formats carry a CRC
        and are context updating.  A packet\n   for which the CRC succeeds updates
        the reference values of all header\n   fields, either explicitly (from the
        information about a field carried\n   within the compressed header) or implicitly
        (fields inferred from\n   other fields).\n   The decompressor may assume that
        some or the entire context is\n   invalid, when it fails to validate or to
        verify one or more headers\n   using the CRC.  Because the decompressor cannot
        know the exact\n   reason(s) for a CRC failure or what field caused it, the
        validity of\n   the context hence does not refer to what specific part(s)
        of the\n   context is deemed valid or not.\n   Validity of the context rather
        relates to the detection of a problem\n   with the context.  The decompressor
        first assumes that the type of\n   information that most likely caused the
        failure(s) is the state that\n   normally changes for each packet, i.e., context
        damage of the dynamic\n   part of the context.  Upon repeated decompression
        failures and\n   unsuccessful repairs, the decompressor then assumes that
        the entire\n   context, including the static part, needs to be repaired, i.e.,\n
        \  static context damage.  Failure to validate the 3-bit CRC that\n   protects
        control fields should be treated as a decompression failure\n   when the decompressor
        asserts the validity of its context.\n   Context Damage Detection\n      The
        assumption of context damage means that the decompressor will\n      not attempt
        decompression of a CO header that carries only a 3-bit\n      CRC, and will
        only attempt decompression of IR headers or CO\n      headers protected by
        a CRC-7.\n   Static Context Damage Detection\n      The assumption of static
        context damage means that the\n      decompressor refrains from attempting
        decompression of any type of\n      header other than the IR header.\n   How
        these assumptions are made, i.e., how context damage is detected,\n   is open
        to implementations.  It can be based on the residual error\n   rate, where
        a low error rate makes the decompressor assume damage\n   more often than
        on a high rate link.\n   The decompressor implements these assumptions by
        selecting the type\n   of compressed header for which it will attempt decompression.
        \ In\n   other words, validity of the context refers to the ability of a\n
        \  decompressor to attempt (or not) decompression of specific packet\n   types.\n
        \  When ROHCv2 profiles are used over a channel that cannot guarantee\n   in-order
        delivery, the decompressor may refrain from updating its\n   context with
        the content of a sequentially late packet that is\n   successfully decompressed.
        \ This is to avoid updating the context\n   with information that is older
        than what the decompressor already has\n   in its context.\n"
      title: 5.2.2.  Decompressor Context Management
    - contents:
      - "5.2.3.  Feedback Logic\n   ROHCv2 profiles may be used in environments with
        or without feedback\n   capabilities from decompressor to compressor.  ROHCv2
        however assumes\n   that if a ROHC feedback channel is available and if this
        channel is\n   used at least once by the decompressor for a specific context,
        this\n   channel will be used during the entire compression operation for
        that\n   context (i.e., bidirectional operation).\n   The ROHC framework defines
        3 types of feedback messages: ACKs, NACKs,\n   and STATIC-NACKs.  The semantics
        of each message is defined in\n   Section 5.2.4.1. of [RFC4995].  What feedback
        to send is coupled with\n   the context management of the decompressor, i.e.,
        with the\n   implementation of the context damage detection algorithms as\n
        \  described in Section 5.2.2.\n   The decompressor should send a NACK when
        it assumes context damage,\n   and it should send a STATIC-NACK when it assumes
        static context\n   damage.  The decompressor is not strictly expected to send
        ACK\n   feedback upon successful decompression, other than for the purpose
        of\n   improving compression efficiency.\n   When ROHCv2 profiles are used
        over a channel that cannot guarantee\n   in-order delivery, the decompressor
        may refrain from sending ACK\n   feedback for a sequentially late packet that
        is successfully\n   decompressed.\n   The decompressor should limit the rate
        at which it sends feedback,\n   for both ACKs and STATIC-NACK/NACKs, and should
        avoid sending\n   unnecessary duplicates of the same type of feedback message
        that may\n   be associated with the same event.\n"
      title: 5.2.3.  Feedback Logic
    title: 5.2.  Decompressor Concepts
  title: 5.  Overview of the ROHCv2 Profiles (Informative)
- contents:
  - '6.  ROHCv2 Profiles (Normative)

    '
  - contents:
    - "6.1.  Channel Parameters, Segmentation, and Reordering\n   The compressor MUST
      NOT use ROHC segmentation (see Section 5.2.5 of\n   [RFC4995]), i.e., the Maximum
      Reconstructed Reception Unit (MRRU)\n   MUST be set to 0, if the configuration
      of the ROHC channel contains\n   at least one ROHCv2 profile in the list of
      supported profiles (i.e.,\n   the PROFILES parameter) and if the channel cannot
      guarantee in-order\n   delivery of packets between compression endpoints.\n"
    title: 6.1.  Channel Parameters, Segmentation, and Reordering
  - contents:
    - "6.2.  Profile Operation, Per-context\n   ROHCv2 profiles operate differently,
      per context, depending on how\n   the decompressor makes use of the feedback
      channel, if any.  Once the\n   decompressor uses the feedback channel for a
      context, it establishes\n   the feedback channel for that CID.\n   The compressor
      always starts with the assumption that the\n   decompressor will not send feedback
      when it initializes a new context\n   (see also the definition of a new context
      in Section 5.1.1. of\n   [RFC4995], i.e., there is no established feedback channel
      for the new\n   context.  At this point, despite the use of the optimistic approach,\n
      \  decompression failure is still possible because the decompressor may\n   not
      have received sufficient information to correctly decompress the\n   packets;
      therefore, until the decompressor has established a feedback\n   channel, the
      compressor SHOULD periodically send IR packets.  The\n   periodicity can be
      based on timeouts, on the number of compressed\n   packets sent for the flow,
      or any other strategy the implementer\n   chooses.\n   The reception of either
      positive feedback (ACKs) or negative feedback\n   (NACKs or STATIC-NACKs) from
      the decompressor establishes the\n   feedback channel for the context (CID)
      for which the feedback was\n   received.  Once there is an established feedback
      channel for a\n   specific context, the compressor can make use of this feedback
      to\n   estimate the current state of the decompressor.  This helps to\n   increase
      the compression efficiency by providing the information\n   needed for the compressor
      to achieve the necessary confidence level.\n   When the feedback channel is
      established, it becomes superfluous for\n   the compressor to send periodic
      refreshes, and instead it can rely\n   entirely on the optimistic approach and
      feedback from the\n   decompressor.\n   The decompressor MAY send positive feedback
      (ACKs) to initially\n   establish the feedback channel for a particular flow.
      \ Either\n   positive feedback (ACKs) or negative feedback (NACKs or STATIC-NACKs)\n
      \  establishes this channel.  Once it has established a feedback channel\n   for
      a CID, the decompressor is REQUIRED to continue sending feedback\n   for the
      lifetime of the context (i.e., until it receives an IR packet\n   that associates
      the CID to a different profile), to send error\n   recovery requests and (optionally)
      acknowledgments of significant\n   context updates.\n   Compression without
      an established feedback channel will be less\n   efficient, because of the periodic
      refreshes and the lack of feedback\n   to trigger error recovery; there will
      also be a slightly higher\n   probability of loss propagation compared to the
      case where the\n   decompressor uses feedback.\n"
    title: 6.2.  Profile Operation, Per-context
  - contents:
    - "6.3.  Control Fields\n   ROHCv2 defines a number of control fields that are
      used by the\n   decompressor in its interpretation of the header formats received\n
      \  from the compressor.  The control fields listed in the following\n   subsections
      are defined using the formal notation [RFC4997] in\n   Section 6.8.2.4 of this
      document.\n"
    - contents:
      - "6.3.1.  Master Sequence Number (MSN)\n   The Master Sequence Number (MSN)
        field is either taken from a field\n   that already exists in one of the headers
        of the protocol that the\n   profile compresses (e.g., RTP SN), or alternatively
        it is created at\n   the compressor.  There is one MSN space per context.\n
        \  The MSN field has the following two functions:\n   o  Differentiating between
        reference headers when receiving feedback\n      data;\n   o  Inferring the
        value of incrementing fields (e.g., IPv4\n      Identifier).\n   There is
        one MSN field in every ROHCv2 header, i.e., the MSN is\n   always present
        in each header type sent by the compressor.  The MSN\n   is sent in full in
        IR headers, while it can be lsb encoded within CO\n   header formats.  The
        decompressor always includes LSBs of the MSN in\n   the Acknowledgment Number
        field in feedback (see Section 6.9).  The\n   compressor can later use this
        field to infer what packet the\n   decompressor is acknowledging.\n   For
        profiles for which the MSN is created by the compressor (i.e.,\n   0x0102,
        0x0104, and 0x0108), the following applies:\n   o  The compressor only initializes
        the MSN for a context when that\n      context is first created or when the
        profile associated with a\n      context changes;\n   o  When the MSN is initialized,
        it is initialized to a random value;\n   o  The value of the MSN SHOULD be
        incremented by one for each packet\n      that the compressor sends for a
        specific CID.\n"
      title: 6.3.1.  Master Sequence Number (MSN)
    - contents:
      - "6.3.2.  Reordering Ratio\n   The control field reorder_ratio specifies how
        much reordering is\n   handled by the lsb encoding of the MSN.  This is useful
        when header\n   compression is performed over links with varying reordering\n
        \  characteristics.  The reorder_ratio control field provides the means\n
        \  for the compressor to adjust the robustness characteristics of the\n   lsb
        encoding method with respect to reordering and consecutive\n   losses, as
        described in Section 5.1.2.\n"
      title: 6.3.2.  Reordering Ratio
    - contents:
      - "6.3.3.  IP-ID Behavior\n   The IP-ID field of the IPv4 header can have different
        change\n   patterns: sequential in network byte order, sequential byte-swapped,\n
        \  random or constant (a constant value of zero, although not conformant\n
        \  with [RFC0791], has been observed in practice).  There is one IP-ID\n   behavior
        control field per IP header.  The control field for the\n   IP-ID behavior
        of the innermost IP header determines which set of\n   header formats is used.
        \ The IP-ID behavior control field is also\n   used to determine the contents
        of the irregular chain item, for each\n   IP header.\n   ROHCv2 profiles MUST
        NOT assign a sequential behavior (network byte\n   order or byte-swapped)
        to any IP-ID but the one in the innermost IP\n   header when compressing more
        than one level of IP headers.  This is\n   because only the IP-ID of the innermost
        IP header is likely to have a\n   sufficiently close correlation with the
        MSN to compress it as a\n   sequentially changing field.  Therefore, a compressor
        MUST assign\n   either the constant zero IP-ID or the random IP-ID behavior
        to\n   tunneling headers.\n"
      title: 6.3.3.  IP-ID Behavior
    - contents:
      - "6.3.4.  UDP-Lite Coverage Behavior\n   The control field coverage_behavior
        specifies how the checksum\n   coverage field of the UDP-Lite header is compressed
        with RoHCv2.  It\n   can indicate one of the following encoding methods: irregular,\n
        \  static, or inferred encoding.\n"
      title: 6.3.4.  UDP-Lite Coverage Behavior
    - contents:
      - "6.3.5.  Timestamp Stride\n   The ts_stride control field is used in scaled
        RTP timestamp encoding\n   (see Section 6.6.8).  It defines the expected increase
        in the RTP\n   timestamp between consecutive RTP sequence numbers.\n"
      title: 6.3.5.  Timestamp Stride
    - contents:
      - "6.3.6.  Time Stride\n   The time_stride control field is used in timer-based
        compression\n   encoding (see Section 6.6.9).  When timer-based compression
        is used,\n   time_stride should be set to the expected difference in arrival
        time\n   between consecutive RTP packets.\n"
      title: 6.3.6.  Time Stride
    - contents:
      - "6.3.7.  CRC-3 for Control Fields\n   ROHCv2 profiles define a CRC-3 calculated
        over a number of control\n   fields.  This 3-bit CRC protecting the control
        fields is present in\n   the header format for the co_common and co_repair
        header types.\n   The decompressor MUST always validate the integrity of the
        control\n   fields covered by this 3-bit CRC when processing a co_common or
        a\n   co_repair compressed header.\n   Failure to validate the control fields
        using this CRC should be\n   considered as a decompression failure by the
        decompressor in the\n   algorithm that assesses the validity of the context.
        \ However, if the\n   decompression attempt can be verified using either the
        CRC-3 or the\n   CRC-7 calculated over the uncompressed header, the decompressor
        MAY\n   still forward the decompressed header to upper layers.  This is\n
        \  because the protected control fields are not always used to\n   decompress
        the header (i.e., co_common or co_repair) that updates\n   their respective
        value.\n   The CRC polynomial and coverage of this CRC-3 is defined in\n   Section
        6.6.11.\n"
      title: 6.3.7.  CRC-3 for Control Fields
    title: 6.3.  Control Fields
  - contents:
    - "6.4.  Reconstruction and Verification\n   Validation of the IR header (8-bit
      CRC)\n      The decompressor MUST always validate the integrity of the IR\n
      \     header using the 8-bit CRC carried within the IR header.  When the\n      header
      is validated, the decompressor updates the context with the\n      information
      in the IR header.  Otherwise, if the IR cannot be\n      validated, the context
      MUST NOT be updated and the IR header MUST\n      NOT be delivered to upper
      layers.\n   Verification of CO headers (3-bit CRC or 7-bit CRC)\n      The decompressor
      MUST always verify the decompression of a CO\n      header using the CRC carried
      within the compressed header.  When\n      the decompression is verified and
      successful, the decompressor\n      updates the context with the information
      received in the CO\n      header; otherwise, if the reconstructed header fails
      the CRC\n      verification, these updates MUST NOT be performed.\n      A packet
      for which the decompression attempt cannot be verified\n      using the CRC
      MUST NOT be delivered to upper layers.\n      Decompressor implementations may
      attempt corrective or repair\n      measures on CO headers prior to performing
      the above actions, and\n      the result of any decompression attempt MUST be
      verified using the\n      CRC.\n"
    title: 6.4.  Reconstruction and Verification
  - contents:
    - "6.5.  Compressed Header Chains\n   Some header types use one or more chains
      containing sub-header\n   information.  The function of a chain is to group
      fields based on\n   similar characteristics, such as static, dynamic, or irregular\n
      \  fields.\n   Chaining is done by appending an item for each header to the
      chain in\n   their order of appearance in the uncompressed packet, starting
      from\n   the fields in the outermost header.\n   In the text below, the term
      <protocol_name> is used to identify\n   formal notation names corresponding
      to different protocol headers.\n   The mapping between these is defined in the
      following table:\n     +----------------------------------+---------------+\n
      \    | Protocol                         | protocol_name |\n     +----------------------------------+---------------+\n
      \    | IPv4                    RFC 0791 | ipv4          |\n     | IPv6                    RFC
      2460 | ipv6          |\n     | UDP                     RFC 0768 | udp           |\n
      \    | RTP                     RFC 3550 | rtp           |\n     | ESP                     RFC
      4303 | esp           |\n     | UDP-Lite                RFC 3828 | udp_lite      |\n
      \    | AH                      RFC 4302 | ah            |\n     | GRE           RFC
      2784, RFC 2890 | gre           |\n     | MINE                    RFC 2004 |
      mine          |\n     | IPv6 Destination Option RFC 2460 | dest_opt      |\n
      \    | IPv6 Hop-by-hop Options RFC 2460 | hop_opt       |\n     | IPv6 Routing
      Header     RFC 2460 | rout_opt      |\n     +----------------------------------+---------------+\n
      \  Static chain:\n      The static chain consists of one item for each header
      of the chain\n      of protocol headers that is compressed, starting from the\n
      \     outermost IP header.  In the formal description of the header\n      formats,
      this static chain item for each header type is labeled\n      <protocol_name>_static.
      \ The static chain is only used in the IR\n      header format.\n   Dynamic
      chain:\n      The dynamic chain consists of one item for each header of the\n
      \     chain of protocol headers that is compressed, starting from the\n      outermost
      IP header.  In the formal description of the header\n      formats, the dynamic
      chain item for each header type is labeled\n      <protocol_name>_dynamic.  The
      dynamic chain is only used in the IR\n      and co_repair header formats.\n
      \  Irregular chain:\n      The structure of the irregular chain is analogous
      to the structure\n      of the static chain.  For each compressed header that
      uses the\n      general format of Section 6.8, the irregular chain is appended
      at\n      a specific location in the general format of the compressed\n      headers.
      \ In the formal description of the header formats, the\n      irregular chain
      item for each header type is a format whose name\n      is suffixed by \"_irregular\".
      \ The irregular chain is used in all\n      CO headers, except for the co_repair
      format.\n      The format of the irregular chain for the innermost IP header\n
      \     differs from the format used for the outer IP headers, because the\n      innermost
      IP header is part of the compressed base header.  In the\n      definition of
      the header formats using the formal notation, the\n      argument \"is_innermost\",
      which is passed to the corresponding\n      encoding method (ipv4 or ipv6),
      determines what irregular chain\n      items to use.  The format of the irregular
      chain item for the\n      outer IP headers is also determined using one flag
      for TTL/Hop\n      Limit and TOS/TC.  This flag is defined in the format of
      some of\n      the compressed base headers.\n   ROHCv2 profiles compress extension
      headers as other headers, and thus\n   extension headers have a static chain,
      a dynamic chain, and an\n   irregular chain.\n   ROHCv2 profiles define chains
      for all headers that can be compressed,\n   i.e., RTP [RFC3550], UDP [RFC0768],
      ESP [RFC4303], UDP-Lite\n   [RFC3828], IPv4 [RFC0791], IPv6 [RFC2460], AH [RFC4302],
      GRE\n   [RFC2784][RFC2890], MINE [RFC2004], IPv6 Destination Options header\n
      \  [RFC2460], IPv6 Hop-by-hop Options header [RFC2460], and IPv6 Routing\n   header
      [RFC2460].\n"
    title: 6.5.  Compressed Header Chains
  - contents:
    - "6.6.  Header Formats and Encoding Methods\n   The header formats are defined
      using the ROHC formal notation.  Some\n   of the encoding methods used in the
      header formats are defined in\n   [RFC4997], while other methods are defined
      in this section.\n"
    - contents:
      - "6.6.1.  baseheader_extension_headers\n   The baseheader_extension_headers
        encoding method skips over all\n   fields of the extension headers of the
        innermost IP header, without\n   encoding any of them.  Fields in these extension
        headers are instead\n   encoded in the irregular chain.\n   This encoding
        is used in CO headers (see Section 6.8.2).  The\n   innermost IP header is
        combined with other header(s) (i.e., UDP, UDP-\n   Lite, RTP) to create the
        compressed base header.  In this case, there\n   may be a number of extension
        headers between the IP headers and the\n   other headers.\n   The base header
        defines a representation of the extension headers, to\n   comply with the
        syntax of the formal notation; this encoding method\n   provides this representation.\n"
      title: 6.6.1.  baseheader_extension_headers
    - contents:
      - "6.6.2.  baseheader_outer_headers\n   The baseheader_outer_headers encoding
        method skips over all the\n   fields of the extension header(s) that do not
        belong to the innermost\n   IP header, without encoding any of them.  Changing
        fields in outer\n   headers are instead handled by the irregular chain.\n
        \  This encoding method, similarly to the baseheader_extension_headers\n   encoding
        method above, is necessary to keep the definition of the\n   header formats
        syntactically correct.  It describes tunneling IP\n   headers and their respective
        extension headers (i.e., all headers\n   located before the innermost IP header)
        for CO headers (see\n   Section 6.8.2).\n"
      title: 6.6.2.  baseheader_outer_headers
    - contents:
      - "6.6.3.  inferred_udp_length\n   The decompressor infers the value of the
        UDP length field as being\n   the sum of the UDP header length and the UDP
        payload length.  The\n   compressor must therefore ensure that the UDP length
        field is\n   consistent with the length field(s) of preceding subheaders,
        i.e.,\n   there must not be any padding after the UDP payload that is covered\n
        \  by the IP Length.\n   This encoding method is also used for the UDP-Lite
        Checksum Coverage\n   field when it behaves in the same manner as the UDP
        length field\n   (i.e., when the checksum always covers the entire UDP-Lite
        payload).\n"
      title: 6.6.3.  inferred_udp_length
    - contents:
      - "6.6.4.  inferred_ip_v4_header_checksum\n   This encoding method compresses
        the header checksum field of the IPv4\n   header.  This checksum is defined
        in RFC 791 [RFC0791] as follows:\n      Header Checksum: 16 bits\n         A
        checksum on the header only.  Since some header fields change\n         (e.g.,
        time to live), this is recomputed and verified at each\n         point that
        the internet header is processed.\n      The checksum algorithm is:\n         The
        checksum field is the 16 bit one's complement of the one's\n         complement
        sum of all 16 bit words in the header.  For purposes\n         of computing
        the checksum, the value of the checksum field is\n         zero.\n   As described
        above, the header checksum protects individual hops from\n   processing a
        corrupted header.  As the data that this checksum\n   protects is mostly compressed
        away and is instead taken from state\n   stored in the context, this checksum
        becomes cumulative to the ROHC\n   CRC.  When using this encoding method,
        the checksum is recomputed by\n   the decompressor.\n   The inferred_ip_v4_header_checksum
        encoding method thus compresses\n   the header checksum field of the IPv4
        header down to a size of zero\n   bits, i.e., no bits are transmitted in compressed
        headers for this\n   field.  Using this encoding method, the decompressor
        infers the value\n   of this field using the computation above.\n   The compressor
        MAY use the header checksum to validate the\n   correctness of the header
        before compressing it, to avoid processing\n   a corrupted header.\n"
      title: 6.6.4.  inferred_ip_v4_header_checksum
    - contents:
      - "6.6.5.  inferred_mine_header_checksum\n   This encoding method compresses
        the minimal encapsulation header\n   checksum.  This checksum is defined in
        RFC 2004 [RFC2004] as follows:\n      Header Checksum\n         The 16-bit
        one's complement of the one's complement sum of all\n         16-bit words
        in the minimal forwarding header.  For purposes of\n         computing the
        checksum, the value of the checksum field is 0.\n         The IP header and
        IP payload (after the minimal forwarding\n         header) are not included
        in this checksum computation.\n   The inferred_mine_header_checksum encoding
        method compresses the\n   minimal encapsulation header checksum down to a
        size of zero bits,\n   i.e., no bits are transmitted in compressed headers
        for this field.\n   Using this encoding method, the decompressor infers the
        value of this\n   field using the above computation.\n   The motivations for
        inferring this checksum are similar to the ones\n   explained above in Section
        6.6.4.\n   The compressor MAY use the minimal encapsulation header checksum
        to\n   validate the correctness of the header before compressing it, to\n
        \  avoid processing a corrupted header.\n"
      title: 6.6.5.  inferred_mine_header_checksum
    - contents:
      - "6.6.6.  inferred_ip_v4_length\n   This encoding method compresses the total
        length field of the IPv4\n   header.  The total length field of the IPv4 header
        is defined in RFC\n   791 [RFC0791] as follows:\n      Total Length: 16 bits\n
        \        Total Length is the length of the datagram, measured in octets,\n
        \        including internet header and data.  This field allows the\n         length
        of a datagram to be up to 65,535 octets.\n   The inferred_ip_v4_length encoding
        method compresses the IPv4 header\n   checksum down to a size of zero bits,
        i.e., no bits are transmitted\n   in compressed headers for this field.  Using
        this encoding method,\n   the decompressor infers the value of this field
        by counting in octets\n   the length of the entire packet after decompression.\n"
      title: 6.6.6.  inferred_ip_v4_length
    - contents:
      - "6.6.7.  inferred_ip_v6_length\n   This encoding method compresses the payload
        length field in the IPv6\n   header.  This length field is defined in RFC
        2460 [RFC2460] as\n   follows:\n      Payload Length: 16-bit unsigned integer\n
        \        Length of the IPv6 payload, i.e., the rest of the packet\n         following
        this IPv6 header, in octets.  (Note that any\n         extension headers present
        are considered part of the payload,\n         i.e., included in the length
        count.)\n   The \"inferred_ip_v6_length\" encoding method compresses the payload\n
        \  length field of the IPv6 header down to a size of zero bits, i.e., no\n
        \  bits are transmitted in compressed headers for this field.  Using\n   this
        encoding method, the decompressor infers the value of this field\n   by counting
        in octets the length of the entire packet after\n   decompression.\n   IPv6
        headers using the jumbo payload option of RFC 2675 [RFC2675]\n   will not
        be compressible with this encoding method since the value of\n   the payload
        length field does not match the length of the packet.\n"
      title: 6.6.7.  inferred_ip_v6_length
    - contents:
      - "6.6.8.  Scaled RTP Timestamp Compression\n   This section provides additional
        details on encodings used to scale\n   the RTP timestamp, as defined in the
        formal notation in\n   Section 6.8.2.4.\n   The RTP timestamp (TS) usually
        increases by a multiple of the RTP\n   Sequence Number's (SN's) increase and
        is therefore a suitable\n   candidate for scaled encoding.  This scaling factor
        is labeled\n   ts_stride in the definition of the profile in the formal notation.\n
        \  The compressor sets the scaling factor based on the change in TS with\n
        \  respect to the change in the RTP SN.\n   The default value of the scaling
        factor ts_stride is 160, as defined\n   in Section 6.8.2.4.  To use a different
        value for ts_stride, the\n   compressor explicitly updates the value of ts_stride
        to the\n   decompressor using one of the header formats that can carry this\n
        \  information.\n   When the compressor uses a scaling factor that is different
        than the\n   default value of ts_stride, it can only use the new scaling factor\n
        \  once it has enough confidence that the decompressor has successfully\n
        \  calculated the residue (ts_offset) of the scaling function for the\n   timestamp.
        \ The compressor achieves this by sending unscaled\n   timestamp values, to
        allow the decompressor to establish the residue\n   based on the current ts_stride.
        \ The compressor MAY send the unscaled\n   timestamp in the same compressed
        header(s) used to establish the\n   value of ts_stride.\n   Once the compressor
        has gained enough confidence that both the value\n   of the scaling factor
        and the value of the residue have been\n   established in the decompressor,
        the compressor can start compressing\n   packets using the new scaling factor.\n
        \  When the compressor detects that the residue (ts_offset) value has\n   changed,
        it MUST NOT select a compressed header format that uses the\n   scaled timestamp
        encoding before it has re-established the residue as\n   described above.\n
        \  When the value of the timestamp field wraps around, the value of the\n
        \  residue of the scaling function is likely to change.  When this\n   occurs,
        the compressor re-establishes the new residue value as\n   described above.\n
        \  If the decompressor receives a compressed header containing scaled\n   timestamp
        bits while the ts_stride equals zero, it MUST NOT deliver\n   the packet to
        upper layers and it SHOULD treat this as a CRC\n   verification failure.\n
        \  Whether or not the scaling is applied to the RTP TS field is up to\n   the
        compressor implementation (i.e., the use of scaling is OPTIONAL),\n   and
        is indicated by the tsc_indicator control field.  In case scaling\n   is applied
        to the RTP TS field, the value of ts_stride used by the\n   compressor is
        up to the implementation.  A value of ts_stride that is\n   set to the expected
        increase in the RTP timestamp between consecutive\n   unit increases of the
        RTP SN will provide the most gain for the\n   scaled encoding.  Other values
        may provide the same gain in some\n   situations, but may reduce the gain
        in others.\n   When scaled timestamp encoding is used for header formats that
        do not\n   transmit any lsb-encoded timestamp bits at all, the\n   inferred_scaled_field
        encoding of Section 6.6.10 is used for encoding\n   the timestamp.\n"
      title: 6.6.8.  Scaled RTP Timestamp Compression
    - contents:
      - "6.6.9.  timer_based_lsb\n   The timer-based compression encoding method,
        timer_based_lsb,\n   compresses a field whose change pattern approximates
        a linear\n   function of the time of day.\n   This encoding uses the local
        clock to obtain an approximation of the\n   value that it encodes.  The approximated
        value is then used as a\n   reference value together with the num_lsbs_param
        least-significant\n   bits received as the encoded value, where num_lsbs_param
        represents a\n   number of bits that is sufficient to uniquely represent the
        encoded\n   value in the presence of jitter between compression endpoints.\n
        \    ts_scaled =:= timer_based_lsb(<time_stride_param>,\n                                   <num_lsbs_param>,
        <offset_param>)\n   The parameters \"num_lsbs_param\" and \"offset_param\"
        are the parameters\n   to use for the lsb encoding, i.e., the number of least
        significant\n   bits and the interpretation interval offset, respectively.
        \ The\n   parameter \"time_stride_param\" represents the context value of
        the\n   control field time_stride.\n   This encoding method always uses a
        scaled version of the field it\n   compresses.\n   The value of the field
        is decoded by calculating an approximation of\n   the scaled value, using:\n
        \       tsc_ref_advanced = tsc_ref + (a_n - a_ref) / time_stride.\n      where:\n
        \     - tsc_ref is a reference value of the scaled representation\n        of
        the field.\n      - a_n is the arrival time associated with the value to decode.\n
        \     - a_ref is the arrival time associated with the reference header.\n
        \     - tsc_ref_advanced is an approximation of the scaled value\n        of
        the field.\n   The lsb encoding is then applied using the num_lsbs_param bits\n
        \  received in the compressed header and the tsc_ref_advanced as\n   \"ref_value\"
        (as per Section 4.11.5 of [RFC4997]).\n   Appendix B.3 provides an example
        of how the compressor can calculate\n   jitter.\n   The control field time_stride
        controls whether or not the\n   timer_based_lsb method is used in the CO header.
        \ The decompressor\n   SHOULD send the CLOCK_RESOLUTION option with a zero
        value, if:\n   o  it receives a non-zero time_stride value, and\n   o  it
        has not previously sent a CLOCK_RESOLUTION feedback with a non-\n      zero
        value.\n   This is to allow compression to recover from the case where a\n
        \  compressor erroneously activates timer-based compression.\n   The support
        and usage of timer-based compression is OPTIONAL for both\n   the compressor
        and the decompressor; the compressor is not required\n   to set the time_stride
        control field to a non-zero value when it has\n   received a non-zero value
        for the CLOCK_RESOLUTION option.\n"
      title: 6.6.9.  timer_based_lsb
    - contents:
      - "6.6.10.  inferred_scaled_field\n   The inferred_scaled_field encoding method
        encodes a field that is\n   defined as changing in relation to the MSN, and
        for which the\n   increase with respect to the MSN can be scaled by some scaling\n
        \  factor.  This encoding method is used in compressed header formats\n   that
        do not contain any bits for the scaled field.  In this case, the\n   decompressor
        infers the unscaled value of the scaled field from the\n   MSN field.  The
        unscaled value is calculated according to the\n   following formula:\n      unscaled_value
        = delta_msn * stride + reference_unscaled_value\n   where \"delta_msn\" is
        the difference in MSN between the reference\n   value of the MSN in the context
        and the value of the MSN decompressed\n   from this packet, \"reference_unscaled_value\"
        is the value of the\n   field being scaled in the context, and \"stride\"
        is the scaling value\n   for this field.\n   For example, when this encoding
        method is applied to the RTP\n   timestamp in the RTP profile, the calculation
        above becomes:\n      timestamp = delta_msn * ts_stride + reference_timestamp\n"
      title: 6.6.10.  inferred_scaled_field
    - contents:
      - "6.6.11.  control_crc3_encoding\n   The control_crc3_encoding method provides
        a CRC calculated over a\n   number of control fields.  The definition of this
        encoding method is\n   the same as for the \"crc\" encoding method specified
        in Section 4.11.6\n   of [RFC4997], with the difference being that the data
        covered by the\n   CRC is given by a concatenated list of control fields.\n
        \  In other words, the definition of the control_crc3_encoding method is\n
        \  equivalent to the following definition:\n     control_crc_encoding(ctrl_data_value,
        ctrl_data_length)\n     {\n       UNCOMPRESSED {\n       }\n       COMPRESSED
        {\n         control_crc3 =:=\n           crc(3, 0x06, 0x07, ctrl_data_value,
        ctrl_data_length) [ 3 ];\n       }\n     }\n   where the parameter \"ctrl_data_value\"
        binds to the concatenated\n   values of the following control fields, in the
        order listed below:\n   o  reorder_ratio, 2 bits padded with 6 MSB of zeroes\n
        \  o  ts_stride, 32 bits (only for profiles 0x0101 and 0x0107)\n   o  time_stride,
        32 bits (only for profiles 0x0101 and 0x0107)\n   o  msn, 16 bits (not applicable
        for profiles 0x0101, 0x0103, and\n      0x0107)\n   o  coverage_behavior,
        2 bits padded with 6 MSB of zeroes (only for\n      profiles 0x0107 and 0x0108)\n
        \  o  ip_id_behavior, one octet for each IP header in the compressible\n      header
        chain starting from the outermost header.  Each octet\n      consists of 2
        bits padded with 6 MSBs of zeroes.\n   The \"ctrl_data_length\" binds to the
        sum of the length of the control\n   field(s) that are applicable to the specific
        profile.\n   The decompressor uses the resulting 3-bit CRC to validate the
        control\n   fields that are updated by the co_common and co_repair header\n
        \  formats; this CRC cannot be used to verify the outcome of a\n   decompression
        attempt.\n   This CRC protects the update of control fields, as the updated
        values\n   are not always used to decompress the header that carries them
        and\n   thus are not protected by the CRC-7 verification.  This prevents\n
        \  impairments that could occur if the decompression of a co_common or\n   of
        a co_repair succeeds and the decompressor sends positive feedback,\n   while
        for some reason the control fields are incorrectly updated.\n"
      title: 6.6.11.  control_crc3_encoding
    - contents:
      - "6.6.12.  inferred_sequential_ip_id\n   This encoding method is used with
        a sequential IP-ID behavior\n   (sequential or sequential byte-swapped) and
        when there are no coded\n   IP-ID bits in the compressed header.  In this
        case, the IP-ID offset\n   from the MSN is constant, and the IP-ID increases
        by the same amount\n   as the MSN (similar to the inferred_scaled_field encoding
        method).\n   The decompressor calculates the value for the IP-ID according
        to the\n   following formula:\n      IP-ID = delta_msn + reference_IP_ID_value\n
        \  where \"delta_msn\" is the difference between the reference value of\n
        \  the MSN in the context and the uncompressed value of the MSN\n   associated
        to the compressed header, and where\n   \"reference_IP_ID_value\" is the value
        of the IP-ID in the context.\n   For swapped IP-ID behavior (i.e., when ip_id_behavior_innermost
        is\n   set to IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED), \"reference_IP_ID_value\"\n
        \  and \"IP-ID\" are byte-swapped with regard to the corresponding fields\n
        \  in the context.\n   If the IP-ID behavior is random or zero, this encoding
        method does\n   not update any fields.\n"
      title: 6.6.12.  inferred_sequential_ip_id
    - contents:
      - "6.6.13.  list_csrc(cc_value)\n   This encoding method compresses the list
        of RTP CSRC identifiers\n   using list compression.  This encoding establishes
        a content for the\n   different CSRC identifiers (items) and a list describing
        the order in\n   which they appear.\n   The compressor passes an argument
        (cc_value) to this encoding method:\n   this is the value of the CC field
        taken from the RTP header.  The\n   decompressor is required to bind the value
        of this argument to the\n   number of items in the list, which will allow
        the decompressor to\n   correctly reconstruct the CC field.\n"
      - contents:
        - "6.6.13.1.  List Compression\n   The CSRC identifiers in the uncompressed
          packet can be represented as\n   an ordered list, whose order and presence
          are usually constant\n   between packets.  The generic structure of such
          a list is as follows:\n            +--------+--------+--...--+--------+\n
          \     list: | item 1 | item 2 |       | item n |\n            +--------+--------+--...--+--------+\n
          \  When performing list compression on a CSRC list, each item is the\n   uncompressed
          value of one CSRC identifier.\n   The basic principles of list-based compression
          are the following:\n   When initializing the context:\n   1) The complete
          representation of the list of CSRC identifiers is\n      transmitted.\n
          \  Then, once the context has been initialized:\n   2) When the list is
          unchanged, a compressed header that does not\n      contain information
          about the list can be used.\n   3) When the list changes, a compressed list
          is sent in the compressed\n      header, including a representation of its
          structure and order.\n      Previously unknown items are sent uncompressed
          in the list, while\n      previously known items are only represented by
          an index pointing\n      to the item stored in the context.\n"
        title: 6.6.13.1.  List Compression
      - contents:
        - "6.6.13.2.  Table-based Item Compression\n   The table-based item compression
          compresses individual items sent in\n   compressed lists.  The compressor
          assigns a unique identifier,\n   \"Index\", to each item \"Item\" of a list.\n
          \  Compressor Logic\n      The compressor conceptually maintains an item
          table containing all\n      items, indexed using \"Index\".  The (Index,
          Item) pair is sent\n      together in compressed lists until the compressor
          gains enough\n      confidence that the decompressor has observed the mapping
          between\n      items and their respective index.  Confidence is obtained
          from the\n      reception of an acknowledgment from the decompressor, or
          by\n      sending (Index, Item) pairs using the optimistic approach.  Once\n
          \     confidence is obtained, the index alone is sent in compressed\n      lists
          to indicate the presence of the item corresponding to this\n      index.\n
          \     The compressor MAY reset its item table upon receiving a negative\n
          \     acknowledgement.\n      The compressor MAY reassign an existing index
          to a new item by re-\n      establishing the mapping using the procedure
          described above.\n   Decompressor Logic\n      The decompressor conceptually
          maintains an item table that\n      contains all (Index, Item) pairs received.
          \ The item table is\n      updated whenever an (Index, Item) pair is received
          and\n      decompression is successful (CRC verification, or CRC-8\n      validation).
          \ The decompressor retrieves the item from the table\n      whenever an
          Index is received without an accompanying Item.\n      If an index is received
          without an accompanying Item and the\n      decompressor does not have any
          context for this index, the\n      decompressor MUST NOT deliver the packet
          to upper layers.\n"
        title: 6.6.13.2.  Table-based Item Compression
      - contents:
        - "6.6.13.3.  Encoding of Compressed Lists\n   Each item present in a compressed
          list is represented by:\n   o  an Index into the table of items, and a presence
          bit indicating if\n      a compressed representation of the item is present
          in the list.\n   o  an item (if the presence bit is set).\n   If the presence
          bit is not set, the item must already be known by the\n   decompressor.\n
          \  A compressed list of items uses the following encoding:\n        0   1
          \  2   3   4   5   6   7\n      +---+---+---+---+---+---+---+---+\n      |
          Reserved  |PS |       m       |\n      +---+---+---+---+---+---+---+---+\n
          \     |        XI_1, ..., XI_m        | m octets, or m * 4 bits\n      /
          \               --- --- --- ---/\n      |               :    Padding    :
          if PS = 0 and m is odd\n      +---+---+---+---+---+---+---+---+\n      |
          \                              |\n      /      Item_1, ..., Item_n      /
          variable\n      |                               |\n      +---+---+---+---+---+---+---+---+\n
          \     Reserved: MUST be set to zero; otherwise, the decompressor MUST\n
          \     discard the packet.\n      PS: Indicates size of XI fields:\n         PS
          = 0 indicates 4-bit XI fields;\n         PS = 1 indicates 8-bit XI fields.\n
          \     m: Number of XI item(s) in the compressed list.  Also, the value\n
          \     of the cc_value argument of the list_csrc encoding (see\n      Section
          6.6.13).\n      XI_1, ..., XI_m: m XI items.  Each XI represents one item
          in the\n      list of items of the uncompressed header, in the same order
          as\n      they appear in the uncompressed header.\n         The format of
          an XI item is as follows:\n                   0   1   2   3\n                 +---+---+---+---+\n
          \        PS = 0: | X |   Index   |\n                 +---+---+---+---+\n
          \                  0   1   2   3   4   5   6   7\n                 +---+---+---+---+---+---+---+---+\n
          \        PS = 1: | X | Reserved  |     Index     |\n                 +---+---+---+---+---+---+---+---+\n
          \        X: Indicates whether the item is present in the list:\n            X
          = 1 indicates that the item corresponding to the Index is\n            sent
          in the Item_1, ..., Item_n list;\n            X = 0 indicates that the item
          corresponding to the Index is\n            not sent.\n         Reserved:
          MUST be set to zero; otherwise, the decompressor MUST\n         discard
          the packet.\n         Index: An index into the item table.  See Section
          6.6.13.4\n         When 4-bit XI items are used, the XI items are placed
          in octets\n         in the following manner:\n           0   1   2   3   4
          \  5   6   7\n         +---+---+---+---+---+---+---+---+\n         |     XI_k
          \     |    XI_k + 1   |\n         +---+---+---+---+---+---+---+---+\n      Padding:
          A 4-bit Padding field is present when PS = 0 and the\n      number of XIs
          is odd.  The Padding field MUST be set to zero;\n      otherwise, the decompressor
          MUST discard the packet.\n      Item 1, ..., item n: Each item corresponds
          to an XI with X = 1 in\n      XI 1, ..., XI m.  Each entry in the Item list
          is the uncompressed\n      representation of one CSRC identifier.\n"
        title: 6.6.13.3.  Encoding of Compressed Lists
      - contents:
        - "6.6.13.4.  Item Table Mappings\n   The item table for list compression
          is limited to 16 different items,\n   since the RTP header can only carry
          at most 15 simultaneous CSRC\n   identifiers.  The effect of having more
          than 16 items in the item\n   table will only cause a slight overhead to
          the compressor when items\n   are swapped in/out of the item table.\n"
        title: 6.6.13.4.  Item Table Mappings
      - contents:
        - "6.6.13.5.  Compressed Lists in Dynamic Chain\n   A compressed list that
          is part of the dynamic chain must have all of\n   its list items present,
          i.e., all X-bits in the XI list MUST be set.\n   All items previously established
          in the item table that are not\n   present in the list decompressed from
          this packet MUST also be\n   retained in the decompressor context.\n"
        title: 6.6.13.5.  Compressed Lists in Dynamic Chain
      title: 6.6.13.  list_csrc(cc_value)
    title: 6.6.  Header Formats and Encoding Methods
  - contents:
    - "6.7.  Encoding Methods with External Parameters as Arguments\n   A number of
      encoding methods in Section 6.8.2.4 have one or more\n   arguments for which
      the derivation of the parameter's value is\n   outside the scope of the ROHC-FN
      [RFC4997] specification of the\n   header formats.\n   The following is a list
      of encoding methods with external parameters\n   as arguments, from Section
      6.8.2.4:\n   o  udp(profile_value, reorder_ratio_value)\n   o  udp_lite(profile_value,
      reorder_ratio_value,\n      coverage_behavior_value)\n   o  esp(profile_value,
      reorder_ratio_value)\n   o  rtp(profile_value, ts_stride_value, time_stride_value,\n
      \     reorder_ratio_value)\n   o  ipv4(profile_value, is_innermost, outer_ip_flag,\n
      \     ip_id_behavior_value, reorder_ratio_value))\n   o  ipv6(profile_value,
      is_innermost, outer_ip_flag,\n      reorder_ratio_value))\n   o  iponly_baseheader(profile_value,
      outer_ip_flag,\n      ip_id_behavior_value, reorder_ratio_value)\n   o  udp_baseheader(profile_value,
      outer_ip_flag, ip_id_behavior_value,\n      reorder_ratio_value)\n   o  udplite_baseheader(profile_value,
      outer_ip_flag,\n      ip_id_behavior_value, reorder_ratio_value)\n   o  esp_baseheader(profile_value,
      outer_ip_flag, ip_id_behavior_value,\n      reorder_ratio_value)\n   o  rtp_baseheader(profile_value,
      ts_stride_value, time_stride_value,\n      outer_ip_flag, ip_id_behavior_value,
      reorder_ratio_value)\n   o  udplite_rtp_baseheader(profile_value, ts_stride_value,\n
      \     time_stride_value, outer_ip_flag, ip_id_behavior_value,\n      reorder_ratio_value,
      coverage_behavior_value)\n   The following applies for all parameters listed
      below: At the\n   compressor, the value of the parameter is set according to
      the\n   recommendations for each parameter.  At the decompressor, the value\n
      \  of the parameter is set to undefined and will get bound by encoding\n   methods,
      except where otherwise noted.\n   The following is a list of external arguments
      with their respective\n   definition:\n   o  profile_value:\n         Set to
      the 16-bit number that identifies the profile used to\n         compress this
      packet.  When processing the static chain at the\n         decompressor, this
      parameter is set to the value of the profile\n         field in the IR header
      (see Section 6.8.1).\n   o  reorder_ratio_value:\n         Set to a 2-bit integer
      value, using one of the constants whose\n         name begins with the prefix
      REORDERING_ and as defined in\n         Section 6.8.2.4.\n   o  ip_id_behavior_value:\n
      \        Set to a 2-bit integer value, using one of the constants whose\n         name
      begins with the prefix IP_ID_BEHAVIOR_ and as defined in\n         Section 6.8.2.4.\n
      \  o  coverage_behavior_value:\n         Set to a 2-bit integer value, using
      one of the constants whose\n         name begins with the prefix UDP_LITE_COVERAGE_
      and as defined\n         in Section 6.8.2.4.\n   o  outer_ip_flag:\n         This
      parameter is set to 1 if at least one of the TOS/TC or\n         TTL/Hop Limit
      fields in outer IP headers has changed compared\n         to their reference
      values in the context; otherwise, it is set\n         to 0.  This flag may only
      be set to 1 for the \"co_common\"\n         header format in the different profiles.\n
      \  o  is_innermost:\n         This boolean flag is set to 1 when processing
      the innermost of\n         the compressible IP headers; otherwise, it is set
      to 0.\n   o  ts_stride_value\n         The value of this parameter should be
      set to the expected\n         increase in the RTP Timestamp between consecutive
      RTP sequence\n         numbers.  The value selected is implementation-specific.
      \ See\n         also Section 6.6.8.\n   o  time_stride_value\n         The value
      of this parameter should be set to the expected\n         inter-arrival time
      between consecutive packets for the flow.\n         The value selected is implementation-specific.
      \ This parameter\n         MUST be set to zero, unless the compressor has received
      a\n         feedback message with the CLOCK_RESOLUTION option set to a non-\n
      \        zero value.  See also Section 6.6.9.\n"
    title: 6.7.  Encoding Methods with External Parameters as Arguments
  - contents:
    - "6.8.  Header Formats\n   ROHCv2 profiles use two different header types: the
      Initialization\n   and Refresh (IR) header type, and the Compressed header type
      (CO).\n   The CO header type defines a number of header formats: there are two\n
      \  sets of base header formats, with a few additional formats that are\n   common
      to both sets.\n"
    - contents:
      - "6.8.1.  Initialization and Refresh Header Format (IR)\n   The IR header format
        uses the structure of the ROHC IR header as\n   defined in Section 5.2.2.1
        of [RFC4995].\n   Header type: IR\n      This header format communicates the
        static part and the dynamic\n      part of the context.\n   The ROHCv2 IR
        header has the following format:\n        0   1   2   3   4   5   6   7\n
        \      --- --- --- --- --- --- --- ---\n      :        Add-CID octet          :
        if for small CIDs and (CID != 0)\n      +---+---+---+---+---+---+---+---+\n
        \     | 1   1   1   1   1   1   0   1 | IR type octet\n      +---+---+---+---+---+---+---+---+\n
        \     :                               :\n      /       0-2 octets of CID       /
        1-2 octets if for large CIDs\n      :                               :\n      +---+---+---+---+---+---+---+---+\n
        \     |            Profile            | 1 octet\n      +---+---+---+---+---+---+---+---+\n
        \     |              CRC              | 1 octet\n      +---+---+---+---+---+---+---+---+\n
        \     |                               |\n      /         Static chain          /
        variable length\n      |                               |\n       - - - - -
        - - - - - - - - - - -\n      |                               |\n      /         Dynamic
        chain         / variable length\n      |                               |\n
        \      - - - - - - - - - - - - - - - -\n      CRC: 8-bit CRC over the entire
        IR-header, including any CID fields\n      and up until the end of the dynamic
        chain, using the polynomial\n      defined in [RFC4995].  For purposes of
        computing the CRC, the CRC\n      field is zero.\n      Static chain: See
        Section 6.5.\n      Dynamic chain: See Section 6.5.\n"
      title: 6.8.1.  Initialization and Refresh Header Format (IR)
    - contents:
      - '6.8.2.  Compressed Header Formats (CO)

        '
      - contents:
        - "6.8.2.1.  Design Rationale for Compressed Base Headers\n   The compressed
          header formats are defined as two separate sets for\n   each profile: one
          set for the headers where the innermost IP header\n   contains a sequential
          IP-ID (either network byte order or byte-\n   swapped), and one set for
          the headers without sequential IP-ID\n   (either random, zero, or no IP-ID).
          \ There are also a number of\n   common header formats shared between both
          sets.  In the description\n   below, the naming convention used for header
          formats that belong to\n   the sequential set is to include \"seq\" in the
          name of the format,\n   while similarly \"rnd\" is used for those that belong
          to the non-\n   sequential set.\n   The design of the header formats is
          derived from the field behavior\n   analysis found in Appendix A.\n   All
          of the compressed base headers transmit lsb-encoded MSN bits and\n   a CRC.\n
          \  The following header formats exist for all profiles defined in this\n
          \  document, and are common to both the sequential and the random header\n
          \  format sets:\n   o  co_common: This format can be used to update the
          context when the\n      established change pattern of a dynamic field changes,
          for any of\n      the dynamic fields.  However, not all dynamic fields are
          updated\n      by conveying their uncompressed value; some fields can only
          be\n      transmitted using a compressed representation.  This format is\n
          \     especially useful when a rarely changing field needs to be\n      updated.
          \ This format contains a set of flags to indicate what\n      fields are
          present in the header, and its size can vary\n      accordingly.  This format
          is protected by a 7-bit CRC.  It can\n      update control fields, and it
          thus also carries a 3-bit CRC to\n      protect those fields.  This format
          is similar in purpose to the\n      UOR-2-extension 3 format of [RFC3095].\n
          \  o  co_repair: This format can be used to update the context of all\n
          \     the dynamic fields by conveying their uncompressed value.  This is\n
          \     especially useful when context damage is assumed (e.g., from the\n
          \     reception of a NACK) and a context repair is performed.  This\n      format
          is protected by a 7-bit CRC.  It also carries a 3-bit CRC\n      over the
          control fields that it can update.  This format is\n      similar in purpose
          to the IR-DYN format of [RFC3095] when\n      performing context repairs.\n
          \  o  pt_0_crc3: This format conveys only the MSN; it can therefore only\n
          \     update the MSN and fields that are derived from the MSN, such as\n
          \     IP-ID and the RTP Timestamp (for applicable profiles).  It is\n      protected
          by a 3-bit CRC.  This format is equivalent to the UO-0\n      header format
          in [RFC3095].\n   o  pt_0_crc7: This format has the same properties as pt_0_crc3,
          but\n      is instead protected by a 7-bit CRC and contains a larger amount\n
          \     of lsb-encoded MSN bits.  This format is useful in environments\n
          \     where a high amount of reordering or a high-residual error rate\n
          \     can occur.\n   The following header format descriptions apply to profiles
          0x0101 and\n   0x0107.\n   o  pt_1_rnd: This format can convey changes to
          the MSN and to the RTP\n      Marker bit, and it can update the RTP timestamp
          using scaled\n      timestamp encoding.  It is protected by a 3-bit CRC.
          \ It is\n      similar in purpose to the UO-1 format in [RFC3095].\n   o
          \ pt_1_seq_id: This format can convey changes to the MSN and to the\n      IP-ID.
          \ It is protected by a 3-bit CRC.  It is similar in purpose\n      to the
          UO-1-ID format in [RFC3095].\n   o  pt_1_seq_ts: This format can convey
          changes to the MSN and to the\n      RTP Marker bit, and it can update the
          RTP Timestamp using scaled\n      timestamp encoding.  It is protected by
          a 3-bit CRC.  It is\n      similar in purpose to the UO-1-TS format in [RFC3095].\n
          \  o  pt_2_rnd: This format can convey changes to the MSN, to the RTP\n
          \     Marker bit, and to the RTP Timestamp.  It is protected by a 7-bit\n
          \     CRC.  It is similar in purpose to the UOR-2 format in [RFC3095].\n
          \  o  pt_2_seq_id: This format can convey changes to the MSN and to the\n
          \     IP-ID.  It is protected by a 7-bit CRC.  It is similar in purpose\n
          \     to the UO-2-ID format in [RFC3095].\n   o  pt_2_seq_ts: This format
          can convey changes to the MSN, to the RTP\n      Marker bit and it can update
          the RTP Timestamp using scaled\n      timestamp encoding.  It is protected
          by a 7-bit CRC.  It is\n      similar in purpose to the UO-2-TS format in
          [RFC3095].\n   o  pt_2_seq_both: This format can convey changes to both
          the RTP\n      Timestamp and the IP-ID, in addition to the MSN and to the
          Marker\n      bit.  It is protected by a 7-bit CRC.  It is similar in purpose
          to\n      the UOR-2-ID extension 1 format in [RFC3095].\n   The following
          header format descriptions apply to profiles 0x0102,\n   0x0103, 0x0104,
          and 0x0108.\n   o  pt_1_seq_id: This format can convey changes to the MSN
          and to the\n      IP-ID.  It is protected by a 7-bit CRC.  It is similar
          in purpose\n      to the UO-1-ID format in [RFC3095].\n   o  pt_2_seq_id:
          This format can convey changes to the MSN and to the\n      IP-ID.  It is
          protected by a 7-bit CRC.  It is similar in purpose\n      to the UO-2-ID
          format in [RFC3095].\n"
        title: 6.8.2.1.  Design Rationale for Compressed Base Headers
      - contents:
        - "6.8.2.2.  co_repair Header Format\n   The ROHCv2 co_repair header has the
          following format:\n        0   1   2   3   4   5   6   7\n       --- ---
          --- --- --- --- --- ---\n      :         Add-CID octet         : if for
          small CIDs and CID 1-15\n      +---+---+---+---+---+---+---+---+\n      |
          1   1   1   1   1   0   1   1 | discriminator\n      +---+---+---+---+---+---+---+---+\n
          \     :                               :\n      /   0, 1, or 2 octets of
          CID    / 1-2 octets if large CIDs\n      :                               :\n
          \     +---+---+---+---+---+---+---+---+\n      |r1 |         CRC-7             |\n
          \     +---+---+---+---+---+---+---+---+\n      |        r2         |   CRC-3
          \  |\n      +---+---+---+---+---+---+---+---+\n      |                               |\n
          \     /         Dynamic chain         / variable length\n      |                               |\n
          \      - - - - - - - - - - - - - - - -\n      r1: MUST be set to zero; otherwise,
          the decompressor MUST discard\n      the packet.\n      CRC-7: A 7-bit CRC
          over the entire uncompressed header, computed\n      using the crc7 (data_value,
          data_length) encoding method defined\n      in Section 6.8.2.4, where data_value
          corresponds to the entire\n      uncompressed header chain and where data_length
          corresponds to the\n      length of this header chain.\n      r2: MUST be
          set to zero; otherwise, the decompressor MUST discard\n      the packet.\n
          \     CRC-3: Encoded using the control_crc3_encoding method defined in\n
          \     Section 6.6.11.\n      Dynamic chain: See Section 6.5.\n"
        title: 6.8.2.2.  co_repair Header Format
      - contents:
        - "6.8.2.3.  General CO Header Format\n   The CO header format communicates
          irregularities in the packet\n   header.  All CO formats carry a CRC and
          can update the context.  All\n   CO header formats use the general format
          defined in this section,\n   with the exception of the co_repair format,
          which is defined in\n   Section 6.8.2.2.\n   The general format for a compressed
          header is as follows:\n        0   1   2   3   4   5   6   7\n       ---
          --- --- --- --- --- --- ---\n      :         Add-CID octet         : if
          for small CIDs and CID 1-15\n      +---+---+---+---+---+---+---+---+\n      |
          \ first octet of base header   | (with type indication)\n      +---+---+---+---+---+---+---+---+\n
          \     :                               :\n      /   0, 1, or 2 octets of
          CID    / 1-2 octets if large CIDs\n      :                               :\n
          \     +---+---+---+---+---+---+---+---+\n      /   remainder of base header
          \   / variable length\n      +---+---+---+---+---+---+---+---+\n      :
          \                              :\n      /        Irregular Chain        /
          variable length\n      :                               :\n       --- ---
          --- --- --- --- --- ---\n   The base header in the figure above is the compressed
          representation\n   of the innermost IP header and other header(s), if any,
          in the\n   uncompressed packet.  The base header formats are defined in\n
          \  Section 6.8.2.4.  In the formal description of the header formats,\n
          \  the base header for each profile is labeled\n   <profile_name>_baseheader,
          where <profile_name> is defined in the\n   following table:\n      +------------------+----------------+\n
          \     | Profile number   | profile_name   |\n      +------------------+----------------+\n
          \     | 0x0101           | rtp            |\n      | 0x0102           |
          udp            |\n      | 0x0103           | esp            |\n      | 0x0104
          \          | ip             |\n      | 0x0107           | udplite_rtp    |\n
          \     | 0x0108           | udplite        |\n      +------------------+----------------+\n"
        title: 6.8.2.3.  General CO Header Format
      - contents:
        - "6.8.2.4.  Header Formats in ROHC-FN\n   This section defines the complete
          set of base header formats for\n   ROHCv2 profiles.  The base header formats
          are defined using the ROHC\n   Formal Notation [RFC4997].\n"
        - '// NOTE: The irregular, static, and dynamic chains (see Section 6.5)

          '
        - '// are defined across multiple encoding methods and are embodied

          '
        - '// in the correspondingly named formats within those encoding

          '
        - '// methods.  In particular, note that the static and dynamic

          '
        - '// chains ordinarily go together.  The uncompressed fields are

          '
        - '// defined across these two formats combined, rather than in one

          '
        - '// or the other of them.  The irregular chain items are likewise

          '
        - '// combined with a baseheader format.

          '
        - '////////////////////////////////////////////

          '
        - '// Constants

          '
        - '////////////////////////////////////////////

          '
        - '// IP-ID behavior constants

          '
        - 'IP_ID_BEHAVIOR_SEQUENTIAL         = 0;

          '
        - 'IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED = 1;

          '
        - 'IP_ID_BEHAVIOR_RANDOM             = 2;

          '
        - 'IP_ID_BEHAVIOR_ZERO               = 3;

          '
        - '// UDP-lite checksum coverage behavior constants

          '
        - 'UDP_LITE_COVERAGE_INFERRED  = 0;

          '
        - 'UDP_LITE_COVERAGE_STATIC    = 1;

          '
        - 'UDP_LITE_COVERAGE_IRREGULAR = 2;

          '
        - '// The value 3 is reserved and cannot be used for coverage behavior

          '
        - '// Variable reordering offset

          '
        - 'REORDERING_NONE          = 0;

          '
        - 'REORDERING_QUARTER       = 1;

          '
        - 'REORDERING_HALF          = 2;

          '
        - 'REORDERING_THREEQUARTERS = 3;

          '
        - '// Profile names and versions

          '
        - 'PROFILE_RTP_0101     = 0x0101;

          '
        - 'PROFILE_UDP_0102     = 0x0102;

          '
        - 'PROFILE_ESP_0103     = 0x0103;

          '
        - 'PROFILE_IP_0104      = 0x0104;

          '
        - 'PROFILE_RTP_0107     = 0x0107; // With UDP-LITE

          '
        - 'PROFILE_UDPLITE_0108 = 0x0108; // Without RTP

          '
        - '// Default values for RTP timestamp encoding

          '
        - 'TS_STRIDE_DEFAULT    = 160;

          '
        - 'TIME_STRIDE_DEFAULT  = 0;

          '
        - '////////////////////////////////////////////

          '
        - '// Global control fields

          '
        - '////////////////////////////////////////////

          '
        - "CONTROL {\n  profile                                    [ 16 ];\n  msn
          \                                       [ 16 ];\n  reorder_ratio                              [
          \ 2 ];\n  // ip_id fields are for innermost IP header only\n  ip_id_offset
          \                              [ 16 ];\n  ip_id_behavior_innermost                   [
          \ 2 ];\n  // The following are only used in RTP-based profiles\n  ts_stride
          \                                 [ 32 ];\n  time_stride                                [
          32 ];\n  ts_scaled                                  [ 32 ];\n  ts_offset
          \                                 [ 32 ];\n  // UDP-lite-based profiles
          only\n  coverage_behavior                          [  2 ];\n"
        - '}

          '
        - '///////////////////////////////////////////////

          '
        - '// Encoding methods not specified in FN syntax:

          '
        - '///////////////////////////////////////////////

          '
        - 'baseheader_extension_headers       "defined in Section 6.6.1";

          '
        - 'baseheader_outer_headers           "defined in Section 6.6.2";

          '
        - 'control_crc3_encoding              "defined in Section 6.6.11";

          '
        - 'inferred_ip_v4_header_checksum     "defined in Section 6.6.4";

          '
        - 'inferred_ip_v4_length              "defined in Section 6.6.6";

          '
        - 'inferred_ip_v6_length              "defined in Section 6.6.7";

          '
        - 'inferred_mine_header_checksum      "defined in Section 6.6.5";

          '
        - 'inferred_scaled_field              "defined in Section 6.6.10";

          '
        - 'inferred_sequential_ip_id          "defined in Section 6.6.12";

          '
        - 'inferred_udp_length                "defined in Section 6.6.3";

          '
        - 'list_csrc(cc_value)                "defined in Section 6.6.13";

          '
        - 'timer_based_lsb(time_stride, k, p) "defined in Section 6.6.9";

          '
        - '////////////////////////////////////////////

          '
        - '// General encoding methods

          '
        - '////////////////////////////////////////////

          '
        - 'static_or_irreg(flag, width)

          '
        - "{\n  UNCOMPRESSED {\n    field [ width ];\n  }\n  COMPRESSED irreg_enc
          {\n    ENFORCE(flag == 1);\n    field =:= irregular(width) [ width ];\n
          \ }\n  COMPRESSED static_enc {\n    ENFORCE(flag == 0);\n    field =:= static
          [ 0 ];\n  }\n"
        - '}

          '
        - 'optional_32(flag)

          '
        - "{\n  UNCOMPRESSED {\n    item [ 0, 32 ];\n  }\n  COMPRESSED present {\n
          \   ENFORCE(flag == 1);\n    item =:= irregular(32) [ 32 ];\n  }\n  COMPRESSED
          not_present {\n    ENFORCE(flag == 0);\n    item =:= compressed_value(0,
          0) [ 0 ];\n  }\n"
        - '}

          '
        - '// Send the entire value, or keep previous value

          '
        - 'sdvl_or_static(flag)

          '
        - "{\n  UNCOMPRESSED {\n    field [ 32 ];\n  }\n  COMPRESSED present_7bit
          {\n    ENFORCE(flag == 1);\n    ENFORCE(field.UVALUE < 2^7);\n    ENFORCE(field.CVALUE
          == field.UVALUE);\n    discriminator =:= '0' [ 1 ];\n    field                 [
          7 ];\n  }\n  COMPRESSED present_14bit {\n    ENFORCE(flag == 1);\n    ENFORCE(field.UVALUE
          < 2^14);\n    ENFORCE(field.CVALUE == field.UVALUE);\n    discriminator
          =:= '10'   [  2 ];\n    field                    [ 14 ];\n  }\n  COMPRESSED
          present_21bit {\n    ENFORCE(flag == 1);\n    ENFORCE(field.UVALUE < 2^21);\n
          \   ENFORCE(field.CVALUE == field.UVALUE);\n    discriminator =:= '110'
          \ [  3 ];\n    field                    [ 21 ];\n  }\n  COMPRESSED present_28bit
          {\n    ENFORCE(flag == 1);\n    ENFORCE(field.UVALUE < 2^28);\n    ENFORCE(field.CVALUE
          == field.UVALUE);\n    discriminator =:= '1110'  [  4 ];\n    field                     [
          28 ];\n  }\n  COMPRESSED present_32bit {\n    ENFORCE(flag == 1);\n    ENFORCE(field.CVALUE
          == field.UVALUE);\n    discriminator =:= '11111111'  [  8 ];\n    field
          \                        [ 32 ];\n  }\n  COMPRESSED not_present {\n    ENFORCE(flag
          == 0);\n    field =:= static;\n  }\n"
        - '}

          '
        - '// Send the entire value, or revert to default value

          '
        - 'sdvl_or_default(flag, default_value)

          '
        - "{\n  UNCOMPRESSED {\n    field [ 32 ];\n  }\n  COMPRESSED present_7bit
          {\n    ENFORCE(flag == 1);\n    ENFORCE(field.UVALUE < 2^7);\n    ENFORCE(field.CVALUE
          == field.UVALUE);\n    discriminator =:= '0' [ 1 ];\n    field                 [
          7 ];\n  }\n  COMPRESSED present_14bit {\n    ENFORCE(flag == 1);\n    ENFORCE(field.UVALUE
          < 2^14);\n    ENFORCE(field.CVALUE == field.UVALUE);\n    discriminator
          =:= '10'   [  2 ];\n    field                    [ 14 ];\n  }\n  COMPRESSED
          present_21bit {\n    ENFORCE(flag == 1);\n    ENFORCE(field.UVALUE < 2^21);\n
          \   ENFORCE(field.CVALUE == field.UVALUE);\n    discriminator =:= '110'
          \ [  3 ];\n    field                    [ 21 ];\n  }\n  COMPRESSED present_28bit
          {\n    ENFORCE(flag == 1);\n    ENFORCE(field.UVALUE < 2^28);\n    ENFORCE(field.CVALUE
          == field.UVALUE);\n    discriminator =:= '1110'  [  4 ];\n    field                     [
          28 ];\n  }\n  COMPRESSED present_32bit {\n    ENFORCE(flag == 1);\n    ENFORCE(field.CVALUE
          == field.UVALUE);\n    discriminator =:= '11111111'  [  8 ];\n    field
          \                        [ 32 ];\n  }\n  COMPRESSED not_present {\n    ENFORCE(flag
          == 0);\n    field =:= uncompressed_value(32, default_value);\n  }\n"
        - '}

          '
        - 'lsb_7_or_31

          '
        - "{\n  UNCOMPRESSED {\n    item [ 32 ];\n  }\n  COMPRESSED lsb_7 {\n    discriminator
          =:= '0'                       [  1 ];\n    item          =:= lsb(7, ((2^7)
          / 4) - 1)   [  7 ];\n  }\n  COMPRESSED lsb_31 {\n    discriminator =:= '1'
          \                      [  1 ];\n    item          =:= lsb(31, ((2^31) /
          4) - 1) [ 31 ];\n  }\n"
        - '}

          '
        - 'crc3(data_value, data_length)

          '
        - "{\n  UNCOMPRESSED {\n  }\n  COMPRESSED {\n    crc_value =:= crc(3, 0x06,
          0x07, data_value, data_length) [ 3 ];\n  }\n"
        - '}

          '
        - 'crc7(data_value, data_length)

          '
        - "{\n  UNCOMPRESSED {\n  }\n  COMPRESSED {\n    crc_value =:= crc(7, 0x79,
          0x7f, data_value, data_length) [ 7 ];\n  }\n"
        - '}

          '
        - '// Encoding method for updating a scaled field and its associated

          '
        - '// control fields.  Should be used both when the value is scaled

          '
        - '// or unscaled in a compressed format.

          '
        - '// Does not have an uncompressed side.

          '
        - 'field_scaling(stride_value, scaled_value, unscaled_value, residue_value)

          '
        - "{\n  UNCOMPRESSED {\n    // Nothing\n  }\n  COMPRESSED no_scaling {\n    ENFORCE(stride_value
          == 0);\n    ENFORCE(residue_value == unscaled_value);\n    ENFORCE(scaled_value
          == 0);\n  }\n  COMPRESSED scaling_used {\n    ENFORCE(stride_value != 0);\n
          \   ENFORCE(residue_value == (unscaled_value % stride_value));\n    ENFORCE(unscaled_value
          ==\n            scaled_value * stride_value + residue_value);\n  }\n"
        - '}

          '
        - '////////////////////////////////////////////

          '
        - '// IPv6 Destination options header

          '
        - '////////////////////////////////////////////

          '
        - 'ip_dest_opt

          '
        - "{\n  UNCOMPRESSED {\n    next_header [ 8 ];\n    length      [ 8 ];\n    value
          \      [ length.UVALUE * 64 + 48 ];\n  }\n  DEFAULT {\n    length      =:=
          static;\n    next_header =:= static;\n    value       =:= static;\n  }\n
          \ COMPRESSED dest_opt_static {\n    next_header =:= irregular(8) [ 8 ];\n
          \   length      =:= irregular(8) [ 8 ];\n  }\n  COMPRESSED dest_opt_dynamic
          {\n    value =:=\n      irregular(length.UVALUE * 64 + 48) [ length.UVALUE
          * 64 + 48 ];\n  }\n  COMPRESSED dest_opt_irregular {\n  }\n"
        - '}

          '
        - '////////////////////////////////////////////

          '
        - '// IPv6 Hop-by-Hop options header

          '
        - '////////////////////////////////////////////

          '
        - 'ip_hop_opt

          '
        - "{\n  UNCOMPRESSED {\n    next_header [ 8 ];\n    length      [ 8 ];\n    value
          \      [ length.UVALUE * 64 + 48 ];\n  }\n  DEFAULT {\n    length      =:=
          static;\n    next_header =:= static;\n    value       =:= static;\n  }\n
          \ COMPRESSED hop_opt_static {\n    next_header =:= irregular(8) [ 8 ];\n
          \   length      =:= irregular(8) [ 8 ];\n  }\n  COMPRESSED hop_opt_dynamic
          {\n    value =:=\n      irregular(length.UVALUE*64+48) [ length.UVALUE *
          64 + 48 ];\n  }\n  COMPRESSED hop_opt_irregular {\n  }\n"
        - '}

          '
        - '////////////////////////////////////////////

          '
        - '// IPv6 Routing header

          '
        - '////////////////////////////////////////////

          '
        - 'ip_rout_opt

          '
        - "{\n  UNCOMPRESSED {\n    next_header [ 8 ];\n    length      [ 8 ];\n    value
          \      [ length.UVALUE * 64 + 48 ];\n  }\n  DEFAULT {\n    length      =:=
          static;\n    next_header =:= static;\n    value       =:= static;\n  }\n
          \ COMPRESSED rout_opt_static {\n    next_header =:= irregular(8)                   [
          8 ];\n    length      =:= irregular(8)                   [ 8 ];\n    value
          \      =:=\n      irregular(length.UVALUE*64+48) [ length.UVALUE * 64 +
          48 ];\n  }\n  COMPRESSED rout_opt_dynamic {\n  }\n  COMPRESSED rout_opt_irregular
          {\n  }\n"
        - '}

          '
        - '////////////////////////////////////////////

          '
        - '// GRE Header

          '
        - '////////////////////////////////////////////

          '
        - 'optional_lsb_7_or_31(flag)

          '
        - "{\n  UNCOMPRESSED {\n    item [ 0, 32 ];\n  }\n  COMPRESSED present {\n
          \   ENFORCE(flag == 1);\n    item =:= lsb_7_or_31 [ 8, 32 ];\n  }\n  COMPRESSED
          not_present {\n    ENFORCE(flag == 0);\n    item =:= compressed_value(0,
          0) [ 0 ];\n  }\n"
        - '}

          '
        - 'optional_checksum(flag_value)

          '
        - "{\n  UNCOMPRESSED {\n    value     [ 0, 16 ];\n    reserved1 [ 0, 16 ];\n
          \ }\n  COMPRESSED cs_present {\n    ENFORCE(flag_value == 1);\n    value
          \    =:= irregular(16)             [ 16 ];\n    reserved1 =:= uncompressed_value(16,
          0) [  0 ];\n  }\n  COMPRESSED not_present {\n    ENFORCE(flag_value == 0);\n
          \   value     =:= compressed_value(0, 0) [ 0 ];\n    reserved1 =:= compressed_value(0,
          0) [ 0 ];\n  }\n"
        - '}

          '
        - 'gre_proto

          '
        - "{\n  UNCOMPRESSED {\n    protocol [ 16 ];\n  }\n  COMPRESSED ether_v4 {\n
          \   discriminator =:= '0'                            [ 1 ];\n    protocol
          \     =:= uncompressed_value(16, 0x0800) [ 0 ];\n  }\n  COMPRESSED ether_v6
          {\n    discriminator =:= '1'                            [ 1 ];\n    protocol
          \     =:= uncompressed_value(16, 0x86DD) [ 0 ];\n  }\n"
        - '}

          '
        - 'gre

          '
        - "{\n  UNCOMPRESSED {\n    c_flag                                 [  1 ];\n
          \   r_flag    =:= uncompressed_value(1, 0) [  1 ];\n    k_flag                                 [
          \ 1 ];\n    s_flag                                 [  1 ];\n    reserved0
          =:= uncompressed_value(9, 0) [  9 ];\n    version   =:= uncompressed_value(3,
          0) [  3 ];\n    protocol                               [ 16 ];\n    checksum_and_res
          \                      [ 0, 32 ];\n    key                                    [
          0, 32 ];\n    sequence_number                        [ 0, 32 ];\n  }\n  DEFAULT
          {\n    c_flag           =:= static;\n    k_flag           =:= static;\n
          \   s_flag           =:= static;\n    protocol         =:= static;\n    key
          \             =:= static;\n    sequence_number  =:= static;\n  }\n  COMPRESSED
          gre_static {\n    ENFORCE((c_flag.UVALUE == 1 && checksum_and_res.ULENGTH
          == 32)\n            || checksum_and_res.ULENGTH == 0);\n    ENFORCE((s_flag.UVALUE
          == 1 && sequence_number.ULENGTH == 32)\n            || sequence_number.ULENGTH
          == 0);\n    protocol =:= gre_proto                  [ 1 ];\n    c_flag   =:=
          irregular(1)               [ 1 ];\n    k_flag   =:= irregular(1)               [
          1 ];\n    s_flag   =:= irregular(1)               [ 1 ];\n    padding  =:=
          compressed_value(4, 0)     [ 4 ];\n    key      =:= optional_32(k_flag.UVALUE)
          [ 0, 32 ];\n  }\n  COMPRESSED gre_dynamic {\n    checksum_and_res =:=\n
          \     optional_checksum(c_flag.UVALUE)              [ 0, 16 ];\n    sequence_number
          \ =:= optional_32(s_flag.UVALUE) [ 0, 32 ];\n  }\n  COMPRESSED gre_irregular
          {\n    checksum_and_res =:= optional_checksum(c_flag.UVALUE) [ 0, 16 ];\n
          \   sequence_number  =:=\n      optional_lsb_7_or_31(s_flag.UVALUE)           [
          0, 8, 32 ];\n  }\n"
        - '}

          '
        - '/////////////////////////////////////////////

          '
        - '// MINE header

          '
        - '/////////////////////////////////////////////

          '
        - 'mine

          '
        - "{\n  UNCOMPRESSED {\n    next_header [  8 ];\n    s_bit       [  1 ];\n
          \   res_bits    [  7 ];\n    checksum    [ 16 ];\n    orig_dest   [ 32 ];\n
          \   orig_src    [ 0, 32 ];\n  }\n  DEFAULT {\n    next_header =:= static;\n
          \   s_bit       =:= static;\n    res_bits    =:= static;\n    checksum    =:=
          inferred_mine_header_checksum;\n    orig_dest   =:= static;\n    orig_src
          \   =:= static;\n  }\n  COMPRESSED mine_static {\n    next_header =:= irregular(8)
          \             [  8 ];\n    s_bit       =:= irregular(1)              [  1
          ];\n    // Reserved bits are included to achieve byte-alignment\n    res_bits
          \   =:= irregular(7)              [  7 ];\n    orig_dest   =:= irregular(32)
          \            [ 32 ];\n    orig_src    =:= optional_32(s_bit.UVALUE) [ 0,
          32 ];\n  }\n  COMPRESSED mine_dynamic {\n  }\n  COMPRESSED mine_irregular
          {\n  }\n"
        - '}

          '
        - '/////////////////////////////////////////////

          '
        - '// Authentication Header (AH)

          '
        - '/////////////////////////////////////////////

          '
        - 'ah

          '
        - "{\n  UNCOMPRESSED {\n    next_header                            [  8 ];\n
          \   length                                 [  8 ];\n    res_bits =:= uncompressed_value(16,
          0) [ 16 ];\n    spi                                    [ 32 ];\n    sequence_number
          \                       [ 32 ];\n    icv                   [ length.UVALUE*32-32
          ];\n  }\n  DEFAULT {\n    next_header     =:= static;\n    length          =:=
          static;\n    spi             =:= static;\n    sequence_number =:= static;\n
          \ }\n  COMPRESSED ah_static {\n    next_header =:= irregular(8)      [  8
          ];\n    length      =:= irregular(8)      [  8 ];\n    spi         =:= irregular(32)
          \    [ 32 ];\n  }\n  COMPRESSED ah_dynamic {\n    sequence_number =:= irregular(32)
          [ 32 ];\n    icv       =:=\n      irregular(length.UVALUE*32-32)  [ length.UVALUE*32-32
          ];\n  }\n  COMPRESSED ah_irregular {\n    sequence_number =:= lsb_7_or_31
          \  [ 8, 32 ];\n    icv       =:=\n      irregular(length.UVALUE*32-32)  [
          length.UVALUE*32-32 ];\n  }\n"
        - '}

          '
        - '/////////////////////////////////////////////

          '
        - '// IPv6 Header

          '
        - '/////////////////////////////////////////////

          '
        - 'fl_enc

          '
        - "{\n  UNCOMPRESSED {\n    flow_label [ 20 ];\n  }\n  COMPRESSED fl_zero
          {\n    discriminator =:= '0'                       [ 1 ];\n    flow_label
          \   =:= uncompressed_value(20, 0) [ 0 ];\n    reserved      =:= '0000'                    [
          4 ];\n  }\n  COMPRESSED fl_non_zero {\n    discriminator =:= '1'           [
          \ 1 ];\n    flow_label    =:= irregular(20) [ 20 ];\n  }\n"
        - '}

          '
        - 'ipv6(profile_value, is_innermost, outer_ip_flag, reorder_ratio_value)

          '
        - "{\n  UNCOMPRESSED {\n    version         =:= uncompressed_value(4, 6) [
          \  4 ];\n    tos_tc                                       [   8 ];\n    flow_label
          \                                  [  20 ];\n    payload_length                               [
          \ 16 ];\n    next_header                                  [   8 ];\n    ttl_hopl
          \                                    [   8 ];\n    src_addr                                     [
          128 ];\n    dst_addr                                     [ 128 ];\n  }\n
          \ CONTROL {\n    ENFORCE(profile == profile_value);\n    ENFORCE(reorder_ratio.UVALUE
          == reorder_ratio_value);\n    ENFORCE(innermost_ip.UVALUE == is_innermost);\n
          \   innermost_ip [ 1 ];\n  }\n  DEFAULT {\n    tos_tc         =:= static;\n
          \   flow_label     =:= static;\n    payload_length =:= inferred_ip_v6_length;\n
          \   next_header    =:= static;\n    ttl_hopl       =:= static;\n    src_addr
          \      =:= static;\n    dst_addr       =:= static;\n  }\n  COMPRESSED ipv6_static
          {\n    version_flag        =:= '1'              [   1 ];\n    innermost_ip
          \       =:= irregular(1)     [   1 ];\n    reserved            =:= '0'              [
          \  1 ];\n    flow_label          =:= fl_enc           [ 5, 21 ];\n    next_header
          \        =:= irregular(8)     [   8 ];\n    src_addr            =:= irregular(128)
          \  [ 128 ];\n    dst_addr            =:= irregular(128)   [ 128 ];\n  }\n
          \ COMPRESSED ipv6_endpoint_dynamic {\n    ENFORCE((is_innermost == 1) &&\n
          \           (profile_value == PROFILE_IP_0104));\n    tos_tc        =:=
          irregular(8)           [  8 ];\n    ttl_hopl      =:= irregular(8)           [
          \ 8 ];\n    reserved      =:= compressed_value(6, 0) [  6 ];\n    reorder_ratio
          =:= irregular(2)           [  2 ];\n    msn           =:= irregular(16)
          \         [ 16 ];\n  }\n  COMPRESSED ipv6_regular_dynamic {\n    ENFORCE((is_innermost
          == 0) ||\n            (profile_value != PROFILE_IP_0104));\n    tos_tc       =:=
          irregular(8) [ 8 ];\n    ttl_hopl     =:= irregular(8) [ 8 ];\n  }\n  COMPRESSED
          ipv6_outer_irregular {\n    ENFORCE(is_innermost == 0);\n    tos_tc       =:=\n
          \       static_or_irreg(outer_ip_flag, 8) [ 0, 8 ];\n    ttl_hopl     =:=\n
          \       static_or_irreg(outer_ip_flag, 8) [ 0, 8 ];\n  }\n  COMPRESSED ipv6_innermost_irregular
          {\n    ENFORCE(is_innermost == 1);\n  }\n"
        - '}

          '
        - '/////////////////////////////////////////////

          '
        - '// IPv4 Header

          '
        - '/////////////////////////////////////////////

          '
        - 'ip_id_enc_dyn(behavior)

          '
        - "{\n  UNCOMPRESSED {\n    ip_id [ 16 ];\n  }\n  COMPRESSED ip_id_seq {\n
          \   ENFORCE((behavior == IP_ID_BEHAVIOR_SEQUENTIAL) ||\n            (behavior
          == IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n    ENFORCE(ip_id_offset.UVALUE
          == ip_id.UVALUE - msn.UVALUE);\n    ip_id =:= irregular(16) [ 16 ];\n  }\n
          \ COMPRESSED ip_id_random {\n    ENFORCE(behavior == IP_ID_BEHAVIOR_RANDOM);\n
          \   ip_id =:= irregular(16) [ 16 ];\n  }\n  COMPRESSED ip_id_zero {\n    ENFORCE(behavior
          == IP_ID_BEHAVIOR_ZERO);\n    ip_id =:= uncompressed_value(16, 0) [ 0 ];\n
          \ }\n"
        - '}

          '
        - 'ip_id_enc_irreg(behavior)

          '
        - "{\n  UNCOMPRESSED {\n    ip_id [ 16 ];\n  }\n  COMPRESSED ip_id_seq {\n
          \   ENFORCE(behavior == IP_ID_BEHAVIOR_SEQUENTIAL);\n  }\n  COMPRESSED ip_id_seq_swapped
          {\n    ENFORCE(behavior == IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED);\n  }\n  COMPRESSED
          ip_id_rand {\n    ENFORCE(behavior == IP_ID_BEHAVIOR_RANDOM);\n    ip_id
          =:= irregular(16) [ 16 ];\n  }\n  COMPRESSED ip_id_zero {\n    ENFORCE(behavior
          == IP_ID_BEHAVIOR_ZERO);\n    ip_id =:= uncompressed_value(16, 0) [ 0 ];\n
          \ }\n"
        - '}

          '
        - "ipv4(profile_value, is_innermost, outer_ip_flag, ip_id_behavior_value,\n
          \ reorder_ratio_value)\n"
        - "{\n  UNCOMPRESSED {\n    version     =:= uncompressed_value(4, 4)       [
          \ 4 ];\n    hdr_length  =:= uncompressed_value(4, 5)       [  4 ];\n    tos_tc
          \                                        [  8 ];\n    length      =:= inferred_ip_v4_length
          \         [ 16 ];\n    ip_id                                          [
          16 ];\n    rf          =:= uncompressed_value(1, 0)       [  1 ];\n    df
          \                                            [  1 ];\n    mf          =:=
          uncompressed_value(1, 0)       [  1 ];\n    frag_offset =:= uncompressed_value(13,
          0)      [ 13 ];\n    ttl_hopl                                       [  8
          ];\n    protocol                                       [  8 ];\n    checksum
          \   =:= inferred_ip_v4_header_checksum [ 16 ];\n    src_addr                                       [
          32 ];\n    dst_addr                                       [ 32 ];\n  }\n
          \ CONTROL {\n    ENFORCE(profile == profile_value);\n    ENFORCE(reorder_ratio.UVALUE
          == reorder_ratio_value);\n    ENFORCE(innermost_ip.UVALUE == is_innermost);\n
          \   ip_id_behavior_outer [ 2 ];\n    innermost_ip [ 1 ];\n  }\n  DEFAULT
          {\n    tos_tc               =:= static;\n    df                   =:= static;\n
          \   ttl_hopl             =:= static;\n    protocol             =:= static;\n
          \   src_addr             =:= static;\n    dst_addr             =:= static;\n
          \   ip_id_behavior_outer =:= static;\n  }\n  COMPRESSED ipv4_static {\n
          \   version_flag        =:= '0'                    [  1 ];\n    innermost_ip
          \       =:= irregular(1)           [  1 ];\n    reserved            =:=
          '000000'               [  6 ];\n    protocol            =:= irregular(8)
          \          [  8 ];\n    src_addr            =:= irregular(32)          [
          32 ];\n    dst_addr            =:= irregular(32)          [ 32 ];\n  }\n
          \ COMPRESSED ipv4_endpoint_innermost_dynamic {\n    ENFORCE((is_innermost
          == 1) && (profile_value == PROFILE_IP_0104));\n    ENFORCE(ip_id_behavior_innermost.UVALUE
          == ip_id_behavior_value);\n    reserved       =:= '000'                                 [
          \ 3 ];\n    reorder_ratio  =:= irregular(2)                          [  2
          ];\n    df             =:= irregular(1)                          [  1 ];\n
          \   ip_id_behavior_innermost =:= irregular(2)                [  2 ];\n    tos_tc
          \        =:= irregular(8)                          [  8 ];\n    ttl_hopl
          \      =:= irregular(8)                          [  8 ];\n    ip_id =:=
          ip_id_enc_dyn(ip_id_behavior_innermost.UVALUE) [ 0, 16 ];\n    msn            =:=
          irregular(16)                         [ 16 ];\n  }\n  COMPRESSED ipv4_regular_innermost_dynamic
          {\n    ENFORCE((is_innermost == 1) && (profile_value != PROFILE_IP_0104));\n
          \   ENFORCE(ip_id_behavior_innermost.UVALUE == ip_id_behavior_value);\n
          \   reserved       =:= '00000'                               [ 5 ];\n    df
          \            =:= irregular(1)                          [ 1 ];\n    ip_id_behavior_innermost
          =:= irregular(2)                [ 2 ];\n    tos_tc         =:= irregular(8)
          \                         [ 8 ];\n    ttl_hopl       =:= irregular(8)                          [
          8 ];\n    ip_id =:= ip_id_enc_dyn(ip_id_behavior_innermost.UVALUE) [ 0,
          16 ];\n  }\n  COMPRESSED ipv4_outer_dynamic {\n    ENFORCE(is_innermost
          == 0);\n    ENFORCE(ip_id_behavior_outer.UVALUE == ip_id_behavior_value);\n
          \   reserved       =:= '00000'                             [ 5 ];\n    df
          \            =:= irregular(1)                        [ 1 ];\n    ip_id_behavior_outer
          =:=     irregular(2)              [ 2 ];\n    tos_tc         =:= irregular(8)
          \                       [ 8 ];\n    ttl_hopl       =:= irregular(8)                        [
          8 ];\n    ip_id =:= ip_id_enc_dyn(ip_id_behavior_outer.UVALUE)   [ 0, 16
          ];\n  }\n  COMPRESSED ipv4_outer_irregular {\n    ENFORCE(is_innermost ==
          0);\n    ip_id    =:=\n      ip_id_enc_irreg(ip_id_behavior_outer.UVALUE)
          \     [ 0, 16 ];\n    tos_tc   =:= static_or_irreg(outer_ip_flag, 8)      [
          \ 0, 8 ];\n    ttl_hopl =:= static_or_irreg(outer_ip_flag, 8)      [  0,
          8 ];\n  }\n  COMPRESSED ipv4_innermost_irregular {\n    ENFORCE(is_innermost
          == 1);\n    ip_id =:=\n      ip_id_enc_irreg(ip_id_behavior_innermost.UVALUE)
          \ [ 0, 16 ];\n  }\n"
        - '}

          '
        - '/////////////////////////////////////////////

          '
        - '// UDP Header

          '
        - '/////////////////////////////////////////////

          '
        - 'udp(profile_value, reorder_ratio_value)

          '
        - "{\n  UNCOMPRESSED {\n    ENFORCE((profile_value == PROFILE_RTP_0101) ||\n
          \           (profile_value == PROFILE_UDP_0102));\n    src_port                           [
          16 ];\n    dst_port                           [ 16 ];\n    udp_length =:=
          inferred_udp_length [ 16 ];\n    checksum                           [ 16
          ];\n  }\n  CONTROL {\n    ENFORCE(profile == profile_value);\n    ENFORCE(reorder_ratio.UVALUE
          == reorder_ratio_value);\n    checksum_used [ 1 ];\n  }\n  DEFAULT {\n    src_port
          \     =:= static;\n    dst_port      =:= static;\n    checksum_used =:=
          static;\n  }\n  COMPRESSED udp_static {\n    src_port   =:= irregular(16)
          [ 16 ];\n    dst_port   =:= irregular(16) [ 16 ];\n  }\n  COMPRESSED udp_endpoint_dynamic
          {\n    ENFORCE(profile_value == PROFILE_UDP_0102);\n    ENFORCE(profile
          == PROFILE_UDP_0102);\n    ENFORCE(checksum_used.UVALUE == (checksum.UVALUE
          != 0));\n    checksum      =:= irregular(16)          [ 16 ];\n    msn           =:=
          irregular(16)          [ 16 ];\n    reserved      =:= compressed_value(6,
          0) [  6 ];\n    reorder_ratio =:= irregular(2)           [  2 ];\n  }\n
          \ COMPRESSED udp_regular_dynamic {\n    ENFORCE(profile_value == PROFILE_RTP_0101);\n
          \   ENFORCE(checksum_used.UVALUE == (checksum.UVALUE != 0));\n    checksum
          =:= irregular(16) [ 16 ];\n  }\n  COMPRESSED udp_zero_checksum_irregular
          {\n    ENFORCE(checksum_used.UVALUE == 0);\n    checksum =:= uncompressed_value(16,
          0)   [ 0 ];\n  }\n  COMPRESSED udp_with_checksum_irregular {\n    ENFORCE(checksum_used.UVALUE
          == 1);\n    checksum =:= irregular(16) [ 16 ];\n  }\n"
        - '}

          '
        - '/////////////////////////////////////////////

          '
        - '// RTP Header

          '
        - '/////////////////////////////////////////////

          '
        - 'csrc_list_dynchain(presence, cc_value)

          '
        - "{\n  UNCOMPRESSED {\n    csrc_list;\n  }\n  COMPRESSED no_list {\n    ENFORCE(cc_value
          == 0);\n    ENFORCE(presence == 0);\n    csrc_list =:= uncompressed_value(0,
          0) [ 0 ];\n  }\n  COMPRESSED list_present {\n    ENFORCE(presence == 1);\n
          \   csrc_list =:= list_csrc(cc_value) [ VARIABLE ];\n  }\n"
        - '}

          '
        - "rtp(profile_value, ts_stride_value, time_stride_value,\n    reorder_ratio_value)\n"
        - "{\n  UNCOMPRESSED {\n    ENFORCE((profile_value == PROFILE_RTP_0101) ||\n
          \           (profile_value == PROFILE_RTP_0107));\n    rtp_version =:= uncompressed_value(2,
          0) [  2 ];\n    pad_bit                                  [  1 ];\n    extension
          \                               [  1 ];\n    cc                                       [
          \ 4 ];\n    marker                                   [  1 ];\n    payload_type
          \                            [  7 ];\n    sequence_number                          [
          16 ];\n    timestamp                                [ 32 ];\n    ssrc                                     [
          32 ];\n    csrc_list                                [ cc.UVALUE * 32 ];\n
          \ }\n  CONTROL {\n    ENFORCE(profile == profile_value);\n    ENFORCE(reorder_ratio.UVALUE
          == reorder_ratio_value);\n    ENFORCE(time_stride_value == time_stride.UVALUE);\n
          \   ENFORCE(ts_stride_value == ts_stride.UVALUE);\n    dummy_field =:= field_scaling(ts_stride.UVALUE,\n
          \     ts_scaled.UVALUE, timestamp.UVALUE, ts_offset.UVALUE) [ 0 ];\n  }\n
          \ INITIAL {\n    ts_stride     =:= uncompressed_value(32, TS_STRIDE_DEFAULT);\n
          \   time_stride   =:= uncompressed_value(32, TIME_STRIDE_DEFAULT);\n  }\n
          \ DEFAULT {\n    ENFORCE(msn.UVALUE == sequence_number.UVALUE);\n    pad_bit
          \        =:= static;\n    extension       =:= static;\n    cc              =:=
          static;\n    marker          =:= static;\n    payload_type    =:= static;\n
          \   sequence_number =:= static;\n    timestamp       =:= static;\n    ssrc
          \           =:= static;\n    csrc_list       =:= static;\n    ts_stride
          \      =:= static;\n    time_stride     =:= static;\n    ts_scaled       =:=
          static;\n    ts_offset       =:= static;\n  }\n  COMPRESSED rtp_static {\n
          \   ssrc            =:= irregular(32)  [ 32 ];\n  }\n  COMPRESSED rtp_dynamic
          {\n    reserved        =:= compressed_value(1, 0)       [  1 ];\n    reorder_ratio
          \  =:= irregular(2)                 [  2 ];\n    list_present    =:= irregular(1)
          \                [  1 ];\n    tss_indicator   =:= irregular(1)                 [
          \ 1 ];\n    tis_indicator   =:= irregular(1)                 [  1 ];\n    pad_bit
          \        =:= irregular(1)                 [  1 ];\n    extension       =:=
          irregular(1)                 [  1 ];\n    marker          =:= irregular(1)
          \                [  1 ];\n    payload_type    =:= irregular(7)                 [
          \ 7 ];\n    sequence_number =:= irregular(16)                [ 16 ];\n    timestamp
          \      =:= irregular(32)                [ 32 ];\n    ts_stride       =:=
          sdvl_or_default(tss_indicator.CVALUE,\n      TS_STRIDE_DEFAULT)                             [
          VARIABLE ];\n    time_stride     =:= sdvl_or_default(tis_indicator.CVALUE,\n
          \     TIME_STRIDE_DEFAULT)                           [ VARIABLE ];\n    csrc_list
          \  =:= csrc_list_dynchain(list_present.CVALUE,\n      cc.UVALUE)                                     [
          VARIABLE ];\n  }\n  COMPRESSED rtp_irregular {\n  }\n"
        - '}

          '
        - '/////////////////////////////////////////////

          '
        - '// UDP-Lite Header

          '
        - '/////////////////////////////////////////////

          '
        - 'checksum_coverage_dynchain(behavior)

          '
        - "{\n  UNCOMPRESSED {\n    checksum_coverage [ 16 ];\n  }\n  COMPRESSED inferred_coverage
          {\n    ENFORCE(behavior == UDP_LITE_COVERAGE_INFERRED);\n    checksum_coverage
          =:= inferred_udp_length [  0 ];\n  }\n  COMPRESSED static_coverage {\n    ENFORCE(behavior
          == UDP_LITE_COVERAGE_STATIC);\n    checksum_coverage =:= irregular(16)       [
          16 ];\n  }\n  COMPRESSED irregular_coverage {\n    ENFORCE(behavior == UDP_LITE_COVERAGE_IRREGULAR);\n
          \   checksum_coverage =:= irregular(16)       [ 16 ];\n  }\n"
        - '}

          '
        - 'checksum_coverage_irregular(behavior)

          '
        - "{\n  UNCOMPRESSED {\n    checksum_coverage [ 16 ];\n  }\n  COMPRESSED inferred_coverage
          {\n    ENFORCE(behavior == UDP_LITE_COVERAGE_INFERRED);\n    checksum_coverage
          =:= inferred_udp_length [  0 ];\n  }\n  COMPRESSED static_coverage {\n    ENFORCE(behavior
          == UDP_LITE_COVERAGE_STATIC);\n    checksum_coverage =:= static              [
          \ 0 ];\n  }\n  COMPRESSED irregular_coverage {\n    ENFORCE(behavior ==
          UDP_LITE_COVERAGE_IRREGULAR);\n    checksum_coverage =:= irregular(16)       [
          16 ];\n  }\n"
        - '}

          '
        - 'udp_lite(profile_value, reorder_ratio_value, coverage_behavior_value)

          '
        - "{\n  UNCOMPRESSED {\n    ENFORCE((profile_value == PROFILE_RTP_0107) ||\n
          \           (profile_value == PROFILE_UDPLITE_0108));\n    src_port          [
          16 ];\n    dst_port          [ 16 ];\n    checksum_coverage [ 16 ];\n    checksum
          \         [ 16 ];\n  }\n  CONTROL {\n    ENFORCE(profile == profile_value);\n
          \   ENFORCE(coverage_behavior.UVALUE == coverage_behavior_value);\n    ENFORCE(reorder_ratio.UVALUE
          == reorder_ratio_value);\n  }\n  DEFAULT {\n    src_port          =:= static;\n
          \   dst_port          =:= static;\n    coverage_behavior =:= static;\n  }\n
          \ COMPRESSED udp_lite_static {\n    src_port   =:= irregular(16) [ 16 ];\n
          \   dst_port   =:= irregular(16) [ 16 ];\n  }\n  COMPRESSED udp_lite_endpoint_dynamic
          {\n    ENFORCE(profile_value == PROFILE_UDPLITE_0108);\n    reserved =:=
          compressed_value(4, 0)                      [  4 ];\n    coverage_behavior
          =:= irregular(2)                       [  2 ];\n    reorder_ratio     =:=
          irregular(2)                       [  2 ];\n    checksum_coverage =:=\n
          \     checksum_coverage_dynchain(coverage_behavior.UVALUE)   [ 16 ];\n    checksum
          \         =:= irregular(16)                      [ 16 ];\n    msn               =:=
          irregular(16)                      [ 16 ];\n  }\n  COMPRESSED udp_lite_regular_dynamic
          {\n    ENFORCE(profile_value == PROFILE_RTP_0107);\n    coverage_behavior
          =:= irregular(2)                       [  2 ];\n    reserved =:= compressed_value(6,
          0)                      [  6 ];\n    checksum_coverage =:=\n        checksum_coverage_dynchain(coverage_behavior.UVALUE)
          [ 16 ];\n    checksum =:= irregular(16)                               [
          16 ];\n  }\n  COMPRESSED udp_lite_irregular {\n    checksum_coverage =:=\n
          \     checksum_coverage_irregular(coverage_behavior.UVALUE) [ 0, 16 ];\n
          \   checksum          =:= irregular(16)                     [ 16 ];\n  }\n"
        - '}

          '
        - '/////////////////////////////////////////////

          '
        - '// ESP Header

          '
        - '/////////////////////////////////////////////

          '
        - 'esp(profile_value, reorder_ratio_value)

          '
        - "{\n  UNCOMPRESSED {\n    ENFORCE(profile_value == PROFILE_ESP_0103);\n
          \   ENFORCE(msn.UVALUE == sequence_number.UVALUE % 65536);\n    spi             [
          32 ];\n    sequence_number [ 32 ];\n  }\n  CONTROL {\n    ENFORCE(profile
          == profile_value);\n    ENFORCE(reorder_ratio.UVALUE == reorder_ratio_value);\n
          \ }\n  DEFAULT {\n    spi             =:= static;\n    sequence_number =:=
          static;\n  }\n  COMPRESSED esp_static {\n    spi =:= irregular(32)                         [
          32 ];\n  }\n  COMPRESSED esp_dynamic {\n    sequence_number =:= irregular(32)
          \            [ 32 ];\n    reserved        =:= compressed_value(6, 0)    [
          \ 6 ];\n    reorder_ratio   =:= irregular(2)              [  2 ];\n  }\n
          \ COMPRESSED esp_irregular {\n  }\n"
        - '}

          '
        - '///////////////////////////////////////////////////

          '
        - '// Encoding methods used in the profiles'' CO headers

          '
        - '///////////////////////////////////////////////////

          '
        - '// Variable reordering offset used for MSN

          '
        - 'msn_lsb(k)

          '
        - "{\n  UNCOMPRESSED {\n    master [ VARIABLE ];\n  }\n  COMPRESSED none {\n
          \   ENFORCE(reorder_ratio.UVALUE == REORDERING_NONE);\n    master =:= lsb(k,
          1);\n  }\n  COMPRESSED quarter {\n    ENFORCE(reorder_ratio.UVALUE == REORDERING_QUARTER);\n
          \   master =:= lsb(k, ((2^k) / 4) - 1);\n  }\n  COMPRESSED half {\n    ENFORCE(reorder_ratio.UVALUE
          == REORDERING_HALF);\n    master =:= lsb(k, ((2^k) / 2) - 1);\n  }\n  COMPRESSED
          threequarters {\n    ENFORCE(reorder_ratio.UVALUE == REORDERING_THREEQUARTERS);\n
          \   master =:= lsb(k, (((2^k) * 3) / 4) - 1);\n  }\n"
        - '}

          '
        - 'ip_id_lsb(behavior, k)

          '
        - "{\n  UNCOMPRESSED {\n    ip_id [ 16 ];\n  }\n  CONTROL {\n    ip_id_nbo
          \   [ 16 ];\n  }\n  COMPRESSED nbo {\n    ENFORCE(behavior == IP_ID_BEHAVIOR_SEQUENTIAL);\n
          \   ENFORCE(ip_id_offset.UVALUE == ip_id.UVALUE - msn.UVALUE);\n    ip_id_offset
          =:= lsb(k, ((2^k) / 4) - 1) [ k ];\n  }\n  COMPRESSED non_nbo {\n    ENFORCE(behavior
          == IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED);\n    ENFORCE(ip_id_nbo.UVALUE ==\n
          \           (ip_id.UVALUE / 256) + (ip_id.UVALUE % 256) * 256);\n    ENFORCE(ip_id_nbo.ULENGTH
          == 16);\n    ENFORCE(ip_id_offset.UVALUE == ip_id_nbo.UVALUE - msn.UVALUE);\n
          \   ip_id_offset =:= lsb(k, ((2^k) / 4) - 1) [ k ];\n  }\n"
        - '}

          '
        - 'ip_id_sequential_variable(behavior, indicator)

          '
        - "{\n  UNCOMPRESSED {\n    ip_id [ 16 ];\n  }\n  COMPRESSED short {\n    ENFORCE((behavior
          == IP_ID_BEHAVIOR_SEQUENTIAL) ||\n            (behavior == IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n
          \   ENFORCE(indicator == 0);\n    ip_id =:= ip_id_lsb(behavior, 8) [ 8 ];\n
          \ }\n  COMPRESSED long {\n    ENFORCE((behavior == IP_ID_BEHAVIOR_SEQUENTIAL)
          ||\n            (behavior == IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n    ENFORCE(indicator
          == 1);\n    ENFORCE(ip_id_offset.UVALUE == ip_id.UVALUE - msn.UVALUE);\n
          \   ip_id =:= irregular(16)  [ 16 ];\n  }\n  COMPRESSED not_present {\n
          \   ENFORCE((behavior == IP_ID_BEHAVIOR_RANDOM) ||\n            (behavior
          == IP_ID_BEHAVIOR_ZERO));\n  }\n"
        - '}

          '
        - 'dont_fragment(version)

          '
        - "{\n  UNCOMPRESSED {\n    df [ 0, 1 ];\n  }\n  COMPRESSED v4 {\n    ENFORCE(version
          == 4);\n    df =:= irregular(1) [ 1 ];\n  }\n  COMPRESSED v6 {\n    ENFORCE(version
          == 6);\n    unused =:= compressed_value(1, 0) [ 1 ];\n  }\n"
        - '}

          '
        - 'pt_irr_or_static(flag)

          '
        - "{\n  UNCOMPRESSED {\n    payload_type [ 7 ];\n  }\n  COMPRESSED not_present
          {\n    ENFORCE(flag == 0);\n    payload_type =:= static [ 0 ];\n  }\n  COMPRESSED
          present {\n    ENFORCE(flag == 1);\n    reserved     =:= compressed_value(1,
          0) [ 1 ];\n    payload_type =:= irregular(7)           [ 7 ];\n  }\n"
        - '}

          '
        - 'csrc_list_presence(presence, cc_value)

          '
        - "{\n  UNCOMPRESSED {\n    csrc_list;\n  }\n  COMPRESSED no_list {\n    ENFORCE(presence
          == 0);\n    csrc_list =:= static [ 0 ];\n  }\n  COMPRESSED list_present
          {\n    ENFORCE(presence == 1);\n    csrc_list =:= list_csrc(cc_value) [
          VARIABLE ];\n  }\n"
        - '}

          '
        - 'scaled_ts_lsb(time_stride_value, k)

          '
        - "{\n  UNCOMPRESSED {\n    timestamp [ 32 ];\n  }\n  COMPRESSED timerbased
          {\n    ENFORCE(time_stride_value != 0);\n    timestamp =:= timer_based_lsb(time_stride_value,
          k,\n                                  ((2^k) / 2) - 1);\n  }\n  COMPRESSED
          regular {\n    ENFORCE(time_stride_value == 0);\n    timestamp =:= lsb(k,
          ((2^k) / 4) - 1);\n  }\n"
        - '}

          '
        - '// Self-describing variable length encoding with reordering offset

          '
        - 'sdvl_sn_lsb(field_width)

          '
        - "{\n  UNCOMPRESSED {\n    field [ field_width ];\n  }\n  COMPRESSED lsb7
          {\n    discriminator =:= '0'   [ 1 ];\n    field =:= msn_lsb(7)    [ 7 ];\n
          \ }\n  COMPRESSED lsb14 {\n    discriminator =:= '10'  [  2 ];\n    field
          =:= msn_lsb(14)   [ 14 ];\n  }\n  COMPRESSED lsb21 {\n    discriminator
          =:= '110'  [  3 ];\n    field =:= msn_lsb(21)    [ 21 ];\n  }\n  COMPRESSED
          lsb28 {\n    discriminator =:= '1110' [  4 ];\n    field =:= msn_lsb(28)
          \   [ 28 ];\n  }\n  COMPRESSED lsb32 {\n    discriminator =:= '11111111'
          \       [  8 ];\n    field =:= irregular(field_width)    [ field_width ];\n
          \ }\n"
        - '}

          '
        - '// Self-describing variable length encoding

          '
        - 'sdvl_lsb(field_width)

          '
        - "{\n  UNCOMPRESSED {\n    field [ field_width ];\n  }\n  COMPRESSED lsb7
          {\n    discriminator =:= '0'               [ 1 ];\n    field =:= lsb(7,
          ((2^7) / 4) - 1)   [ 7 ];\n  }\n  COMPRESSED lsb14 {\n    discriminator
          =:= '10'              [  2 ];\n    field =:= lsb(14, ((2^14) / 4) - 1) [
          14 ];\n  }\n  COMPRESSED lsb21 {\n    discriminator =:= '110'             [
          \ 3 ];\n    field =:= lsb(21, ((2^21) / 4) - 1) [ 21 ];\n  }\n  COMPRESSED
          lsb28 {\n    discriminator =:= '1110'            [  4 ];\n    field =:=
          lsb(28, ((2^28) / 4) - 1) [ 28 ];\n  }\n  COMPRESSED lsb32 {\n    discriminator
          =:= '11111111'        [  8 ];\n    field =:= irregular(field_width)    [
          field_width ];\n  }\n"
        - '}

          '
        - 'sdvl_scaled_ts_lsb(time_stride)

          '
        - "{\n   UNCOMPRESSED {\n     field [ 32 ];\n   }\n   COMPRESSED lsb7 {\n
          \    discriminator =:= '0'                     [  1 ];\n     field =:= scaled_ts_lsb(time_stride,
          7)   [  7 ];\n   }\n   COMPRESSED lsb14 {\n     discriminator =:= '10'                    [
          \ 2 ];\n     field =:= scaled_ts_lsb(time_stride, 14)  [ 14 ];\n   }\n   COMPRESSED
          lsb21 {\n     discriminator =:= '110'                   [  3 ];\n     field
          =:= scaled_ts_lsb(time_stride, 21)  [ 21 ];\n   }\n   COMPRESSED lsb28 {\n
          \    discriminator =:= '1110'                  [  4 ];\n     field =:= scaled_ts_lsb(time_stride,
          28)  [ 28 ];\n   }\n   COMPRESSED lsb32 {\n     discriminator =:= '11111111'
          \             [  8 ];\n     field =:= irregular(32)                   [
          32 ];\n   }\n"
        - '}

          '
        - 'variable_scaled_timestamp(tss_flag, tsc_flag, ts_stride, time_stride)

          '
        - "{\n  UNCOMPRESSED {\n    scaled_value [ 32 ];\n  }\n  COMPRESSED present
          {\n    ENFORCE((tss_flag == 0) && (tsc_flag == 1));\n    ENFORCE(ts_stride
          != 0);\n    scaled_value =:= sdvl_scaled_ts_lsb(time_stride) [ VARIABLE
          ];\n  }\n  COMPRESSED not_present {\n    ENFORCE(((tss_flag == 1) && (tsc_flag
          == 0)) ||\n            ((tss_flag == 0) && (tsc_flag == 0)));\n  }\n"
        - '}

          '
        - 'variable_unscaled_timestamp(tss_flag, tsc_flag)

          '
        - "{\n  UNCOMPRESSED {\n    timestamp [ 32 ];\n  }\n  COMPRESSED present {\n
          \   ENFORCE(((tss_flag == 1) && (tsc_flag == 0)) ||\n            ((tss_flag
          == 0) && (tsc_flag == 0)));\n    timestamp =:= sdvl_lsb(32);\n  }\n  COMPRESSED
          not_present {\n    ENFORCE((tss_flag == 0) && (tsc_flag == 1));\n  }\n"
        - '}

          '
        - 'profile_1_7_flags1_enc(flag, ip_version)

          '
        - "{\n  UNCOMPRESSED {\n    ip_outer_indicator  [ 1 ];\n    ttl_hopl_indicator
          \ [ 1 ];\n    tos_tc_indicator    [ 1 ];\n    df                  [ 0, 1
          ];\n    ip_id_behavior      [ 2 ];\n    reorder_ratio       [ 2 ];\n  }\n
          \ COMPRESSED not_present {\n    ENFORCE(flag == 0);\n    ENFORCE(ip_outer_indicator.CVALUE
          == 0);\n    ENFORCE(ttl_hopl_indicator.CVALUE == 0);\n    ENFORCE(tos_tc_indicator.CVALUE
          == 0);\n    df                   =:= static;\n    ip_id_behavior       =:=
          static;\n    reorder_ratio        =:= static;\n  }\n  COMPRESSED present
          {\n    ENFORCE(flag == 1);\n    ip_outer_indicator  =:= irregular(1)                [
          1 ];\n    ttl_hopl_indicator  =:= irregular(1)                [ 1 ];\n    tos_tc_indicator
          \   =:= irregular(1)                [ 1 ];\n    df                  =:=
          dont_fragment(ip_version)   [ 1 ];\n    ip_id_behavior      =:= irregular(2)
          \               [ 2 ];\n    reorder_ratio       =:= irregular(2)                [
          2 ];\n  }\n"
        - '}

          '
        - 'profile_1_flags2_enc(flag)

          '
        - "{\n  UNCOMPRESSED {\n    list_indicator        [ 1 ];\n    pt_indicator
          \         [ 1 ];\n    time_stride_indicator [ 1 ];\n    pad_bit               [
          1 ];\n    extension             [ 1 ];\n  }\n  COMPRESSED not_present{\n
          \   ENFORCE(flag == 0);\n    ENFORCE(list_indicator.UVALUE == 0);\n    ENFORCE(pt_indicator.UVALUE
          == 0);\n    ENFORCE(time_stride_indicator.UVALUE == 0);\n    pad_bit      =:=
          static;\n    extension    =:= static;\n  }\n  COMPRESSED present {\n    ENFORCE(flag
          == 1);\n    list_indicator =:= irregular(1)                  [ 1 ];\n    pt_indicator
          \  =:= irregular(1)                  [ 1 ];\n    time_stride_indicator =:=
          irregular(1)           [ 1 ];\n    pad_bit        =:= irregular(1)                  [
          1 ];\n    extension      =:= irregular(1)                  [ 1 ];\n    reserved
          \      =:= compressed_value(3, 0)        [ 3 ];\n  }\n"
        - '}

          '
        - 'profile_2_3_4_flags_enc(flag, ip_version)

          '
        - "{\n  UNCOMPRESSED {\n    ip_outer_indicator [ 1 ];\n    df                 [
          0, 1 ];\n    ip_id_behavior     [ 2 ];\n  }\n  COMPRESSED not_present {\n
          \   ENFORCE(flag == 0);\n    ENFORCE(ip_outer_indicator.CVALUE == 0);\n
          \   df                 =:= static;\n    ip_id_behavior     =:= static;\n
          \ }\n  COMPRESSED present {\n    ENFORCE(flag == 1);\n    ip_outer_indicator
          =:= irregular(1)              [ 1 ];\n    df                 =:= dont_fragment(ip_version)
          [ 1 ];\n    ip_id_behavior     =:= irregular(2)              [ 2 ];\n    reserved
          \          =:= compressed_value(4, 0)    [ 4 ];\n  }\n"
        - '}

          '
        - 'profile_8_flags_enc(flag, ip_version)

          '
        - "{\n  UNCOMPRESSED {\n    ip_outer_indicator  [ 1 ];\n    df                  [
          0, 1 ];\n    ip_id_behavior      [ 2 ];\n    coverage_behavior   [ 2 ];\n
          \ }\n  COMPRESSED not_present {\n    ENFORCE(flag == 0);\n    ENFORCE(ip_outer_indicator.CVALUE
          == 0);\n    df                  =:= static;\n    ip_id_behavior      =:=
          static;\n    coverage_behavior   =:= static;\n  }\n  COMPRESSED present
          {\n    ENFORCE(flag == 1);\n    reserved            =:= compressed_value(2,
          0)      [ 2 ];\n    ip_outer_indicator  =:= irregular(1)                [
          1 ];\n    df                  =:= dont_fragment(ip_version)   [ 1 ];\n    ip_id_behavior
          \     =:= irregular(2)                [ 2 ];\n    coverage_behavior   =:=
          irregular(2)                [ 2 ];\n  }\n"
        - '}

          '
        - 'profile_7_flags2_enc(flag)

          '
        - "{\n  UNCOMPRESSED {\n    list_indicator          [ 1 ];\n    pt_indicator
          \           [ 1 ];\n    time_stride_indicator   [ 1 ];\n    pad_bit                 [
          1 ];\n    extension               [ 1 ];\n    coverage_behavior       [
          2 ];\n  }\n  COMPRESSED not_present{\n    ENFORCE(flag == 0);\n    ENFORCE(list_indicator.CVALUE
          == 0);\n    ENFORCE(pt_indicator.CVALUE == 0);\n    ENFORCE(time_stride_indicator.CVALUE
          == 0);\n    pad_bit             =:= static;\n    extension           =:=
          static;\n    coverage_behavior   =:= static;\n  }\n  COMPRESSED present
          {\n    ENFORCE(flag == 1);\n    reserved       =:= compressed_value(1, 0)
          \     [ 1 ];\n    list_indicator =:= irregular(1)                [ 1 ];\n
          \   pt_indicator   =:= irregular(1)                [ 1 ];\n    time_stride_indicator
          =:= irregular(1)         [ 1 ];\n    pad_bit        =:= irregular(1)                [
          1 ];\n    extension      =:= irregular(1)                [ 1 ];\n    coverage_behavior
          =:= irregular(2)             [ 2 ];\n  }\n"
        - '}

          '
        - '////////////////////////////////////////////

          '
        - '// RTP profile

          '
        - '////////////////////////////////////////////

          '
        - "rtp_baseheader(profile_value, ts_stride_value, time_stride_value,\n               outer_ip_flag,
          ip_id_behavior_value,\n               reorder_ratio_value)\n"
        - "{\n  UNCOMPRESSED v4 {\n    ENFORCE(msn.UVALUE == sequence_number.UVALUE);\n
          \   outer_headers  =:= baseheader_outer_headers        [ VARIABLE ];\n    ip_version
          \    =:= uncompressed_value(4, 4)        [  4 ];\n    header_length  =:=
          uncompressed_value(4, 5)        [  4 ];\n    tos_tc                                             [
          \ 8 ];\n    length         =:= inferred_ip_v4_length           [ 16 ];\n
          \   ip_id                                              [ 16 ];\n    rf             =:=
          uncompressed_value(1, 0)        [  1 ];\n    df                                                 [
          \ 1 ];\n    mf             =:= uncompressed_value(1, 0)        [  1 ];\n
          \   frag_offset    =:= uncompressed_value(13, 0)       [ 13 ];\n    ttl_hopl
          \                                          [  8 ];\n    next_header                                        [
          \ 8 ];\n    ip_checksum =:= inferred_ip_v4_header_checksum     [ 16 ];\n
          \   src_addr                                           [ 32 ];\n    dest_addr
          \                                         [ 32 ];\n    extension_headers
          =:= baseheader_extension_headers [ VARIABLE ];\n    src_port                                           [
          16 ];\n    dst_port                                           [ 16 ];\n
          \   udp_length  =:= inferred_udp_length                [ 16 ];\n    udp_checksum
          \                                      [ 16 ];\n    rtp_version =:= uncompressed_value(2,
          2)           [  2 ];\n    pad_bit                                            [
          \ 1 ];\n    extension                                          [  1 ];\n
          \   cc                                                 [  4 ];\n    marker
          \                                            [  1 ];\n    payload_type                                       [
          \ 7 ];\n    sequence_number                                    [ 16 ];\n
          \   timestamp                                          [ 32 ];\n    ssrc
          \                                              [ 32 ];\n    csrc_list                                          [
          VARIABLE ];\n  }\n  UNCOMPRESSED v6 {\n    ENFORCE(ip_id_behavior_innermost.UVALUE
          == IP_ID_BEHAVIOR_RANDOM);\n    ENFORCE(msn.UVALUE == sequence_number.UVALUE);\n
          \   outer_headers  =:= baseheader_outer_headers        [ VARIABLE ];\n    ip_version
          \    =:= uncompressed_value(4, 6)        [   4 ];\n    tos_tc                                             [
          \  8 ];\n    flow_label                                         [  20 ];\n
          \   payload_length =:= inferred_ip_v6_length           [  16 ];\n    next_header
          \                                       [   8 ];\n    ttl_hopl                                           [
          \  8 ];\n    src_addr                                           [ 128 ];\n
          \   dest_addr                                          [ 128 ];\n    extension_headers
          =:= baseheader_extension_headers [ VARIABLE ];\n    src_port                                           [
          \ 16 ];\n    dst_port                                           [  16 ];\n
          \   udp_length     =:= inferred_udp_length             [  16 ];\n    udp_checksum
          \                                      [  16 ];\n    rtp_version    =:=
          uncompressed_value(2, 2)        [   2 ];\n    pad_bit                                            [
          \  1 ];\n    extension                                          [   1 ];\n
          \   cc                                                 [   4 ];\n    marker
          \                                            [   1 ];\n    payload_type
          \                                      [   7 ];\n    sequence_number                                    [
          \ 16 ];\n    timestamp                                          [  32 ];\n
          \   ssrc                                               [  32 ];\n    csrc_list
          \                                         [ VARIABLE ];\n    df    =:= uncompressed_value(0,0)
          \                 [   0 ];\n    ip_id =:= uncompressed_value(0,0)                  [
          \  0 ];\n  }\n  CONTROL {\n    ENFORCE(profile_value == PROFILE_RTP_0101);\n
          \   ENFORCE(profile == profile_value);\n    ENFORCE(time_stride.UVALUE ==
          time_stride_value);\n    ENFORCE(ts_stride.UVALUE == ts_stride_value);\n
          \   ENFORCE(reorder_ratio.UVALUE == reorder_ratio_value);\n    ENFORCE(ip_id_behavior_innermost.UVALUE
          == ip_id_behavior_value);\n    dummy_field =:= field_scaling(ts_stride.UVALUE,\n
          \     ts_scaled.UVALUE, timestamp.UVALUE, ts_offset.UVALUE) [ 0 ];\n  }\n
          \ INITIAL {\n    ts_stride     =:= uncompressed_value(32, TS_STRIDE_DEFAULT);\n
          \   time_stride   =:= uncompressed_value(32, TIME_STRIDE_DEFAULT);\n  }\n
          \ DEFAULT {\n    ENFORCE(outer_ip_flag == 0);\n    tos_tc          =:= static;\n
          \   dest_addr       =:= static;\n    ttl_hopl        =:= static;\n    src_addr
          \       =:= static;\n    df              =:= static;\n    flow_label      =:=
          static;\n    next_header     =:= static;\n    src_port        =:= static;\n
          \   dst_port        =:= static;\n    pad_bit         =:= static;\n    extension
          \      =:= static;\n    cc              =:= static;\n    // When marker
          not present in packets, it is assumed 0\n    marker          =:= uncompressed_value(1,
          0);\n    payload_type    =:= static;\n    sequence_number =:= static;\n
          \   timestamp       =:= static;\n    ssrc            =:= static;\n    csrc_list
          \      =:= static;\n    ts_stride       =:= static;\n    time_stride     =:=
          static;\n    ts_scaled       =:= static;\n    ts_offset       =:= static;\n
          \   reorder_ratio   =:= static;\n    ip_id_behavior_innermost =:= static;\n
          \ }\n  // Replacement for UOR-2-ext3\n  COMPRESSED co_common {\n    ENFORCE(outer_ip_flag
          == outer_ip_indicator.CVALUE);\n    discriminator        =:= '11111010'
          \                   [ 8 ];\n    marker               =:= irregular(1)                  [
          1 ];\n    header_crc   =:= crc7(THIS.UVALUE, THIS.ULENGTH)       [ 7 ];\n
          \   flags1_indicator     =:= irregular(1)                  [ 1 ];\n    flags2_indicator
          \    =:= irregular(1)                  [ 1 ];\n    tsc_indicator        =:=
          irregular(1)                  [ 1 ];\n    tss_indicator        =:= irregular(1)
          \                 [ 1 ];\n    ip_id_indicator      =:= irregular(1)                  [
          1 ];\n    control_crc3         =:= control_crc3_encoding         [ 3 ];\n
          \   outer_ip_indicator : ttl_hopl_indicator :\n      tos_tc_indicator :
          df : ip_id_behavior_innermost : reorder_ratio\n      =:= profile_1_7_flags1_enc(flags1_indicator.CVALUE,\n
          \       ip_version.UVALUE)                                 [ 0, 8 ];\n    list_indicator
          : pt_indicator : tis_indicator : pad_bit :\n      extension =:= profile_1_flags2_enc(\n
          \       flags2_indicator.CVALUE)                           [ 0, 8 ];\n    tos_tc
          =:= static_or_irreg(tos_tc_indicator.CVALUE, 8) [ 0, 8 ];\n    ttl_hopl
          =:= static_or_irreg(ttl_hopl_indicator.CVALUE,\n      ttl_hopl.ULENGTH)
          \                                   [ 0, 8 ];\n    payload_type =:= pt_irr_or_static(pt_indicator)
          \       [ 0, 8 ];\n    sequence_number =:=\n      sdvl_sn_lsb(sequence_number.ULENGTH)
          \               [ VARIABLE ];\n    ip_id =:= ip_id_sequential_variable(\n
          \     ip_id_behavior_innermost.UVALUE,\n      ip_id_indicator.CVALUE) [
          0, 8, 16 ];\n    ts_scaled =:= variable_scaled_timestamp(tss_indicator.CVALUE,\n
          \     tsc_indicator.CVALUE, ts_stride.UVALUE,\n      time_stride.UVALUE)
          \                                [ VARIABLE ];\n    timestamp =:= variable_unscaled_timestamp(tss_indicator.CVALUE,\n
          \     tsc_indicator.CVALUE)                               [ VARIABLE ];\n
          \   ts_stride =:= sdvl_or_static(tss_indicator.CVALUE)    [ VARIABLE ];\n
          \   time_stride =:= sdvl_or_static(tis_indicator.CVALUE)  [ VARIABLE ];\n
          \   csrc_list =:= csrc_list_presence(list_indicator.CVALUE,\n      cc.UVALUE)
          \                                         [ VARIABLE ];\n  }\n  // UO-0\n
          \ COMPRESSED pt_0_crc3 {\n    discriminator =:= '0'                             [
          1 ];\n    msn           =:= msn_lsb(4)                      [ 4 ];\n    header_crc
          \   =:= crc3(THIS.UVALUE, THIS.ULENGTH) [ 3 ];\n    timestamp     =:= inferred_scaled_field
          \          [ 0 ];\n    ip_id         =:= inferred_sequential_ip_id       [
          0 ];\n  }\n  // New format, Type 0 with strong CRC and more SN bits\n  COMPRESSED
          pt_0_crc7 {\n    discriminator =:= '1000'                          [ 4 ];\n
          \   msn           =:= msn_lsb(5)                      [ 5 ];\n    header_crc
          \   =:= crc7(THIS.UVALUE, THIS.ULENGTH) [ 7 ];\n    timestamp     =:= inferred_scaled_field
          \          [ 0 ];\n    ip_id         =:= inferred_sequential_ip_id       [
          0 ];\n  }\n  // UO-1 replacement\n  COMPRESSED pt_1_rnd {\n    ENFORCE(ts_stride.UVALUE
          != 0);\n    ENFORCE((ip_id_behavior_innermost.UVALUE ==\n             IP_ID_BEHAVIOR_RANDOM)
          ||\n            (ip_id_behavior_innermost.UVALUE == IP_ID_BEHAVIOR_ZERO));\n
          \   discriminator =:= '101'                                [ 3 ];\n    marker
          \       =:= irregular(1)                         [ 1 ];\n    msn           =:=
          msn_lsb(4)                           [ 4 ];\n    ts_scaled     =:= scaled_ts_lsb(time_stride.UVALUE,
          5) [ 5 ];\n    header_crc    =:= crc3(THIS.UVALUE, THIS.ULENGTH)      [
          3 ];\n  }\n  // UO-1-ID replacement\n  COMPRESSED pt_1_seq_id {\n    ENFORCE((ip_id_behavior_innermost.UVALUE
          ==\n             IP_ID_BEHAVIOR_SEQUENTIAL) ||\n            (ip_id_behavior_innermost.UVALUE
          ==\n             IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n    discriminator
          =:= '1001'                                [ 4 ];\n    ip_id =:= ip_id_lsb(ip_id_behavior_innermost.UVALUE,
          4) [ 4 ];\n    msn           =:= msn_lsb(5)                            [
          5 ];\n    header_crc    =:= crc3(THIS.UVALUE, THIS.ULENGTH)       [ 3 ];\n
          \   timestamp     =:= inferred_scaled_field                 [ 0 ];\n  }\n
          \ // UO-1-TS replacement\n  COMPRESSED pt_1_seq_ts {\n    ENFORCE(ts_stride.UVALUE
          != 0);\n    ENFORCE((ip_id_behavior_innermost.UVALUE ==\n             IP_ID_BEHAVIOR_SEQUENTIAL)
          ||\n            (ip_id_behavior_innermost.UVALUE ==\n             IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n
          \   discriminator =:= '101'                                [ 3 ];\n    marker
          \       =:= irregular(1)                         [ 1 ];\n    msn           =:=
          msn_lsb(4)                           [ 4 ];\n    ts_scaled     =:= scaled_ts_lsb(time_stride.UVALUE,
          5) [ 5 ];\n    header_crc    =:= crc3(THIS.UVALUE, THIS.ULENGTH)      [
          3 ];\n    ip_id         =:= inferred_sequential_ip_id       [ 0 ];\n  }\n
          \ // UOR-2 replacement\n  COMPRESSED pt_2_rnd {\n    ENFORCE(ts_stride.UVALUE
          != 0);\n    ENFORCE((ip_id_behavior_innermost.UVALUE ==\n             IP_ID_BEHAVIOR_RANDOM)
          ||\n            (ip_id_behavior_innermost.UVALUE == IP_ID_BEHAVIOR_ZERO));\n
          \   discriminator =:= '110'                                [ 3 ];\n    msn
          \          =:= msn_lsb(7)                           [ 7 ];\n    ts_scaled
          \    =:= scaled_ts_lsb(time_stride.UVALUE, 6) [ 6 ];\n    marker        =:=
          irregular(1)                         [ 1 ];\n    header_crc    =:= crc7(THIS.UVALUE,
          THIS.ULENGTH)      [ 7 ];\n  }\n  // UOR-2-ID replacement\n  COMPRESSED
          pt_2_seq_id {\n    ENFORCE((ip_id_behavior_innermost.UVALUE ==\n             IP_ID_BEHAVIOR_SEQUENTIAL)
          ||\n            (ip_id_behavior_innermost.UVALUE ==\n             IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n
          \   discriminator =:= '11000'                               [ 5 ];\n    msn
          \          =:= msn_lsb(7)                            [ 7 ];\n    ip_id =:=
          ip_id_lsb(ip_id_behavior_innermost.UVALUE, 5) [ 5 ];\n    header_crc    =:=
          crc7(THIS.UVALUE, THIS.ULENGTH)       [ 7 ];\n    timestamp     =:= inferred_scaled_field
          \                [ 0 ];\n  }\n  // UOR-2-ID-ext1 replacement (both TS and
          IP-ID)\n  COMPRESSED pt_2_seq_both {\n    ENFORCE(ts_stride.UVALUE != 0);\n
          \   ENFORCE((ip_id_behavior_innermost.UVALUE ==\n             IP_ID_BEHAVIOR_SEQUENTIAL)
          ||\n            (ip_id_behavior_innermost.UVALUE ==\n             IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n
          \   discriminator =:= '11001'                               [ 5 ];\n    msn
          \          =:= msn_lsb(7)                            [ 7 ];\n    ip_id =:=
          ip_id_lsb(ip_id_behavior_innermost.UVALUE, 5) [ 5 ];\n    header_crc    =:=
          crc7(THIS.UVALUE, THIS.ULENGTH)       [ 7 ];\n    ts_scaled     =:= scaled_ts_lsb(time_stride.UVALUE,
          7)  [ 7 ];\n    marker        =:= irregular(1)                          [
          1 ];\n  }\n  // UOR-2-TS replacement\n  COMPRESSED pt_2_seq_ts {\n    ENFORCE(ts_stride.UVALUE
          != 0);\n    ENFORCE((ip_id_behavior_innermost.UVALUE ==\n             IP_ID_BEHAVIOR_SEQUENTIAL)
          ||\n            (ip_id_behavior_innermost.UVALUE ==\n             IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n
          \   discriminator =:= '1101'                               [ 4 ];\n    msn
          \          =:= msn_lsb(7)                           [ 7 ];\n    ts_scaled
          \    =:= scaled_ts_lsb(time_stride.UVALUE, 5) [ 5 ];\n    marker        =:=
          irregular(1)                         [ 1 ];\n    header_crc    =:= crc7(THIS.UVALUE,
          THIS.ULENGTH)      [ 7 ];\n    ip_id         =:= inferred_sequential_ip_id
          \           [ 0 ];\n  }\n"
        - '}

          '
        - '////////////////////////////////////////////

          '
        - '// UDP profile

          '
        - '////////////////////////////////////////////

          '
        - "udp_baseheader(profile_value, outer_ip_flag, ip_id_behavior_value,\n               reorder_ratio_value)\n"
        - "{\n  UNCOMPRESSED v4 {\n    outer_headers  =:= baseheader_outer_headers
          \       [ VARIABLE ];\n    ip_version     =:= uncompressed_value(4, 4)        [
          \ 4 ];\n    header_length  =:= uncompressed_value(4, 5)        [  4 ];\n
          \   tos_tc                                             [  8 ];\n    length
          \        =:= inferred_ip_v4_length           [ 16 ];\n    ip_id                                              [
          16 ];\n    rf             =:= uncompressed_value(1, 0)        [  1 ];\n
          \   df                                                 [  1 ];\n    mf             =:=
          uncompressed_value(1, 0)        [  1 ];\n    frag_offset    =:= uncompressed_value(13,
          0)       [ 13 ];\n    ttl_hopl                                           [
          \ 8 ];\n    next_header                                        [  8 ];\n
          \   ip_checksum =:= inferred_ip_v4_header_checksum     [ 16 ];\n    src_addr
          \                                          [ 32 ];\n    dest_addr                                          [
          32 ];\n    extension_headers =:= baseheader_extension_headers [ VARIABLE
          ];\n    src_port                                           [ 16 ];\n    dst_port
          \                                          [ 16 ];\n    udp_length     =:=
          inferred_udp_length             [ 16 ];\n    udp_checksum                                       [
          16 ];\n  }\n  UNCOMPRESSED v6 {\n    ENFORCE(ip_id_behavior.UVALUE == IP_ID_BEHAVIOR_RANDOM);\n
          \   outer_headers  =:= baseheader_outer_headers        [ VARIABLE ];\n    ip_version
          \    =:= uncompressed_value(4, 6)        [  4 ];\n    tos_tc                                             [
          \ 8 ];\n    flow_label                                         [ 20 ];\n
          \   payload_length =:= inferred_ip_v6_length           [ 16 ];\n    next_header
          \                                       [  8 ];\n    ttl_hopl                                           [
          \ 8 ];\n    src_addr                                           [ 128 ];\n
          \   dest_addr                                          [ 128 ];\n    extension_headers
          =:= baseheader_extension_headers [ VARIABLE ];\n    src_port                                           [
          16 ];\n    dst_port                                           [ 16 ];\n
          \   udp_length     =:= inferred_udp_length             [ 16 ];\n    udp_checksum
          \                                      [ 16 ];\n    df    =:= uncompressed_value(0,0)
          \                 [  0 ];\n    ip_id =:= uncompressed_value(0,0)                  [
          \ 0 ];\n  }\n  CONTROL {\n    ENFORCE(profile_value == PROFILE_UDP_0102);\n
          \   ENFORCE(profile == profile_value);\n    ENFORCE(reorder_ratio.UVALUE
          == reorder_ratio_value);\n    ENFORCE(ip_id_behavior_innermost.UVALUE ==
          ip_id_behavior_value);\n  }\n  DEFAULT {\n    ENFORCE(outer_ip_flag == 0);\n
          \   tos_tc         =:= static;\n    dest_addr      =:= static;\n    ip_version
          \    =:= static;\n    ttl_hopl       =:= static;\n    src_addr       =:=
          static;\n    df             =:= static;\n    flow_label     =:= static;\n
          \   next_header    =:= static;\n    src_port       =:= static;\n    dst_port
          \      =:= static;\n    reorder_ratio  =:= static;\n    ip_id_behavior_innermost
          =:= static;\n  }\n  // Replacement for UOR-2-ext3\n  COMPRESSED co_common
          {\n    ENFORCE(outer_ip_flag == outer_ip_indicator.CVALUE);\n    discriminator
          \       =:= '11111010'                    [ 8 ];\n    ip_id_indicator      =:=
          irregular(1)                  [ 1 ];\n    header_crc   =:= crc7(THIS.UVALUE,
          THIS.ULENGTH)       [ 7 ];\n    flags_indicator      =:= irregular(1)                  [
          1 ];\n    ttl_hopl_indicator   =:= irregular(1)                  [ 1 ];\n
          \   tos_tc_indicator     =:= irregular(1)                  [ 1 ];\n    reorder_ratio
          \       =:= irregular(2)                  [ 2 ];\n    control_crc3         =:=
          control_crc3_encoding         [ 3 ];\n    outer_ip_indicator : df : ip_id_behavior_innermost
          =:=\n      profile_2_3_4_flags_enc(\n      flags_indicator.CVALUE, ip_version.UVALUE)
          \          [ 0, 8 ];\n    tos_tc =:= static_or_irreg(tos_tc_indicator.CVALUE,
          8) [ 0, 8 ];\n    ttl_hopl =:= static_or_irreg(ttl_hopl_indicator.CVALUE,\n
          \     ttl_hopl.ULENGTH)                                    [ 0, 8 ];\n    msn
          \                 =:= msn_lsb(8)                    [ 8 ];\n    ip_id =:=
          ip_id_sequential_variable(ip_id_behavior_innermost.UVALUE,\n      ip_id_indicator.CVALUE)
          \                         [ 0, 8, 16 ];\n  }\n  // UO-0\n  COMPRESSED pt_0_crc3
          {\n    discriminator =:= '0'                             [ 1 ];\n    msn
          \          =:= msn_lsb(4)                      [ 4 ];\n    header_crc    =:=
          crc3(THIS.UVALUE, THIS.ULENGTH) [ 3 ];\n    ip_id         =:= inferred_sequential_ip_id
          \      [ 0 ];\n  }\n  // New format, Type 0 with strong CRC and more SN
          bits\n  COMPRESSED pt_0_crc7 {\n    discriminator =:= '100'                           [
          3 ];\n    msn           =:= msn_lsb(6)                      [ 6 ];\n    header_crc
          \   =:= crc7(THIS.UVALUE, THIS.ULENGTH) [ 7 ];\n    ip_id         =:= inferred_sequential_ip_id
          \      [ 0 ];\n  }\n  // UO-1-ID replacement (PT-1 only used for sequential)\n
          \ COMPRESSED pt_1_seq_id {\n    ENFORCE((ip_id_behavior_innermost.UVALUE
          ==\n             IP_ID_BEHAVIOR_SEQUENTIAL) ||\n            (ip_id_behavior_innermost.UVALUE
          ==\n             IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n    discriminator
          =:= '101'                                 [ 3 ];\n    header_crc    =:=
          crc3(THIS.UVALUE, THIS.ULENGTH)       [ 3 ];\n    msn           =:= msn_lsb(6)
          \                           [ 6 ];\n    ip_id =:= ip_id_lsb(ip_id_behavior_innermost.UVALUE,
          4) [ 4 ];\n  }\n  // UOR-2-ID replacement\n  COMPRESSED pt_2_seq_id {\n
          \   ENFORCE((ip_id_behavior_innermost.UVALUE ==\n             IP_ID_BEHAVIOR_SEQUENTIAL)
          ||\n            (ip_id_behavior_innermost.UVALUE ==\n             IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n
          \   discriminator =:= '110'                                 [ 3 ];\n    ip_id
          =:= ip_id_lsb(ip_id_behavior_innermost.UVALUE, 6) [ 6 ];\n    header_crc
          \   =:= crc7(THIS.UVALUE, THIS.ULENGTH)       [ 7 ];\n    msn           =:=
          msn_lsb(8)                            [ 8 ];\n  }\n"
        - '}

          '
        - '////////////////////////////////////////////

          '
        - '// ESP profile

          '
        - '////////////////////////////////////////////

          '
        - "esp_baseheader(profile_value, outer_ip_flag, ip_id_behavior_value,\n               reorder_ratio_value)\n"
        - "{\n  UNCOMPRESSED v4 {\n    ENFORCE(msn.UVALUE == sequence_number.UVALUE
          % 65536);\n    outer_headers  =:= baseheader_outer_headers        [ VARIABLE
          ];\n    ip_version     =:= uncompressed_value(4, 4)        [  4 ];\n    header_length
          \ =:= uncompressed_value(4, 5)        [  4 ];\n    tos_tc                                             [
          \ 8 ];\n    length         =:= inferred_ip_v4_length           [ 16 ];\n
          \   ip_id                                              [ 16 ];\n    rf             =:=
          uncompressed_value(1, 0)        [  1 ];\n    df                                                 [
          \ 1 ];\n    mf             =:= uncompressed_value(1, 0)        [  1 ];\n
          \   frag_offset    =:= uncompressed_value(13, 0)       [ 13 ];\n    ttl_hopl
          \                                          [  8 ];\n    next_header                                        [
          \ 8 ];\n    ip_checksum =:= inferred_ip_v4_header_checksum     [ 16 ];\n
          \   src_addr                                           [ 32 ];\n    dest_addr
          \                                         [ 32 ];\n    extension_headers
          =:= baseheader_extension_headers [ VARIABLE ];\n    spi                                                [
          32 ];\n    sequence_number                                    [ 32 ];\n
          \ }\n  UNCOMPRESSED v6 {\n    ENFORCE(msn.UVALUE == (sequence_number.UVALUE
          % 65536));\n    ENFORCE(ip_id_behavior_innermost.UVALUE == IP_ID_BEHAVIOR_RANDOM);\n
          \   outer_headers  =:= baseheader_outer_headers        [ VARIABLE ];\n    ip_version
          \    =:= uncompressed_value(4, 6)        [   4 ];\n    tos_tc                                             [
          \  8 ];\n    flow_label                                         [  20 ];\n
          \   payload_length =:= inferred_ip_v6_length           [  16 ];\n    next_header
          \                                       [   8 ];\n    ttl_hopl                                           [
          \  8 ];\n    src_addr                                           [ 128 ];\n
          \   dest_addr                                          [ 128 ];\n    extension_headers
          =:= baseheader_extension_headers [ VARIABLE ];\n    spi                                                [
          \ 32 ];\n    sequence_number                                    [  32 ];\n
          \   df    =:= uncompressed_value(0,0)                  [   0 ];\n    ip_id
          =:= uncompressed_value(0,0)                  [   0 ];\n  }\n  CONTROL {\n
          \   ENFORCE(profile_value == PROFILE_ESP_0103);\n    ENFORCE(profile ==
          profile_value);\n    ENFORCE(ip_id_behavior_innermost.UVALUE == ip_id_behavior_value);\n
          \   ENFORCE(reorder_ratio.UVALUE == reorder_ratio_value);\n  }\n  DEFAULT
          {\n    ENFORCE(outer_ip_flag == 0);\n    tos_tc          =:= static;\n    dest_addr
          \      =:= static;\n    ttl_hopl        =:= static;\n    src_addr        =:=
          static;\n    df              =:= static;\n    flow_label      =:= static;\n
          \   next_header     =:= static;\n    spi             =:= static;\n    sequence_number
          =:= static;\n    reorder_ratio   =:= static;\n    ip_id_behavior_innermost
          =:= static;\n  }\n  // Replacement for UOR-2-ext3\n  COMPRESSED co_common
          {\n    ENFORCE(outer_ip_flag == outer_ip_indicator.CVALUE);\n    discriminator
          \       =:= '11111010'                    [ 8 ];\n    ip_id_indicator      =:=
          irregular(1)                  [ 1 ];\n    header_crc   =:= crc7(THIS.UVALUE,
          THIS.ULENGTH)       [ 7 ];\n    flags_indicator      =:= irregular(1)                  [
          1 ];\n    ttl_hopl_indicator   =:= irregular(1)                  [ 1 ];\n
          \   tos_tc_indicator     =:= irregular(1)                  [ 1 ];\n    reorder_ratio
          \       =:= irregular(2)                  [ 2 ];\n    control_crc3         =:=
          control_crc3_encoding         [ 3 ];\n    outer_ip_indicator : df : ip_id_behavior_innermost
          =:=\n      profile_2_3_4_flags_enc(\n      flags_indicator.CVALUE, ip_version.UVALUE)
          \          [ 0, 8 ];\n    tos_tc =:= static_or_irreg(tos_tc_indicator.CVALUE,
          8) [ 0, 8 ];\n    ttl_hopl =:= static_or_irreg(ttl_hopl_indicator.CVALUE,\n
          \     ttl_hopl.ULENGTH)                                    [ 0, 8 ];\n    sequence_number
          =:=\n      sdvl_sn_lsb(sequence_number.ULENGTH)             [ VARIABLE ];\n
          \   ip_id =:= ip_id_sequential_variable(ip_id_behavior_innermost.UVALUE,\n
          \     ip_id_indicator.CVALUE)                          [ 0, 8, 16 ];\n  }\n
          \ // Sequence number sent instead of MSN due to field length\n  // UO-0\n
          \ COMPRESSED pt_0_crc3 {\n    discriminator   =:= '0'                             [
          1 ];\n    sequence_number =:= msn_lsb(4)                      [ 4 ];\n    header_crc
          \     =:= crc3(THIS.UVALUE, THIS.ULENGTH) [ 3 ];\n    ip_id           =:=
          inferred_sequential_ip_id       [ 0 ];\n  }\n  // New format, Type 0 with
          strong CRC and more SN bits\n  COMPRESSED pt_0_crc7 {\n    discriminator
          \  =:= '100'                           [ 3 ];\n    sequence_number =:= msn_lsb(6)
          \                     [ 6 ];\n    header_crc      =:= crc7(THIS.UVALUE,
          THIS.ULENGTH) [ 7 ];\n    ip_id           =:= inferred_sequential_ip_id
          \      [ 0 ];\n  }\n  // UO-1-ID replacement (PT-1 only used for sequential)\n
          \ COMPRESSED pt_1_seq_id {\n    ENFORCE((ip_id_behavior_innermost.UVALUE
          ==\n             IP_ID_BEHAVIOR_SEQUENTIAL) ||\n            (ip_id_behavior_innermost.UVALUE
          ==\n             IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n    discriminator
          \  =:= '101'                               [ 3 ];\n    header_crc      =:=
          crc3(THIS.UVALUE, THIS.ULENGTH)     [ 3 ];\n    sequence_number =:= msn_lsb(6)
          \                         [ 6 ];\n    ip_id =:= ip_id_lsb(ip_id_behavior_innermost.UVALUE,
          4) [ 4 ];\n  }\n  // UOR-2-ID replacement\n  COMPRESSED pt_2_seq_id {\n
          \   ENFORCE((ip_id_behavior_innermost.UVALUE ==\n             IP_ID_BEHAVIOR_SEQUENTIAL)
          ||\n            (ip_id_behavior_innermost.UVALUE ==\n             IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n
          \   discriminator   =:= '110'                               [ 3 ];\n    ip_id
          =:= ip_id_lsb(ip_id_behavior_innermost.UVALUE, 6) [ 6 ];\n    header_crc
          \     =:= crc7(THIS.UVALUE, THIS.ULENGTH)     [ 7 ];\n    sequence_number
          =:= msn_lsb(8)                          [ 8 ];\n  }\n"
        - '}

          '
        - '////////////////////////////////////////////

          '
        - '// IP-only profile

          '
        - '////////////////////////////////////////////

          '
        - "iponly_baseheader(profile_value, outer_ip_flag, ip_id_behavior_value,\n
          \                 reorder_ratio_value)\n"
        - "{\n  UNCOMPRESSED v4 {\n    outer_headers  =:= baseheader_outer_headers
          \       [ VARIABLE ];\n    ip_version     =:= uncompressed_value(4, 4)        [
          \ 4 ];\n    header_length  =:= uncompressed_value(4, 5)        [  4 ];\n
          \   tos_tc                                             [  8 ];\n    length
          \        =:= inferred_ip_v4_length           [ 16 ];\n    ip_id                                              [
          16 ];\n    rf             =:= uncompressed_value(1, 0)        [  1 ];\n
          \   df                                                 [  1 ];\n    mf             =:=
          uncompressed_value(1, 0)        [  1 ];\n    frag_offset    =:= uncompressed_value(13,
          0)       [ 13 ];\n    ttl_hopl                                           [
          \ 8 ];\n    next_header                                        [  8 ];\n
          \   ip_checksum =:= inferred_ip_v4_header_checksum     [ 16 ];\n    src_addr
          \                                          [ 32 ];\n    dest_addr                                          [
          32 ];\n    extension_headers =:= baseheader_extension_headers [ VARIABLE
          ];\n  }\n  UNCOMPRESSED v6 {\n    ENFORCE(ip_id_behavior_innermost.UVALUE
          == IP_ID_BEHAVIOR_RANDOM);\n    outer_headers     =:= baseheader_outer_headers
          \    [ VARIABLE ];\n    ip_version        =:= uncompressed_value(4, 6)     [
          \  4 ];\n    tos_tc                                             [   8 ];\n
          \   flow_label                                         [  20 ];\n    payload_length
          \   =:= inferred_ip_v6_length        [  16 ];\n    next_header                                        [
          \  8 ];\n    ttl_hopl                                           [   8 ];\n
          \   src_addr                                           [ 128 ];\n    dest_addr
          \                                         [ 128 ];\n    extension_headers
          =:= baseheader_extension_headers [ VARIABLE ];\n    df    =:= uncompressed_value(0,0)
          \                 [   0 ];\n    ip_id =:= uncompressed_value(0,0)                  [
          \  0 ];\n  }\n  CONTROL {\n    ENFORCE(profile_value == PROFILE_IP_0104);\n
          \   ENFORCE(profile == profile_value);\n    ENFORCE(reorder_ratio.UVALUE
          == reorder_ratio_value);\n    ENFORCE(ip_id_behavior_innermost.UVALUE ==
          ip_id_behavior_value);\n  }\n  DEFAULT {\n    ENFORCE(outer_ip_flag == 0);\n
          \   tos_tc         =:= static;\n    dest_addr      =:= static;\n    ttl_hopl
          \      =:= static;\n    src_addr       =:= static;\n    df             =:=
          static;\n    flow_label     =:= static;\n    next_header    =:= static;\n
          \   reorder_ratio  =:= static;\n    ip_id_behavior_innermost =:= static;\n
          \ }\n  // Replacement for UOR-2-ext3\n  COMPRESSED co_common {\n    ENFORCE(outer_ip_flag
          == outer_ip_indicator.CVALUE);\n    discriminator        =:= '11111010'
          \                   [ 8 ];\n    ip_id_indicator      =:= irregular(1)                  [
          1 ];\n    header_crc   =:= crc7(THIS.UVALUE, THIS.ULENGTH)       [ 7 ];\n
          \   flags_indicator      =:= irregular(1)                  [ 1 ];\n    ttl_hopl_indicator
          \  =:= irregular(1)                  [ 1 ];\n    tos_tc_indicator     =:=
          irregular(1)                  [ 1 ];\n    reorder_ratio        =:= irregular(2)
          \                 [ 2 ];\n    control_crc3         =:= control_crc3_encoding
          \        [ 3 ];\n    outer_ip_indicator : df : ip_id_behavior_innermost
          =:=\n      profile_2_3_4_flags_enc(\n      flags_indicator.CVALUE, ip_version.UVALUE)
          \          [ 0, 8 ];\n    tos_tc =:= static_or_irreg(tos_tc_indicator.CVALUE,
          8) [ 0, 8 ];\n    ttl_hopl =:= static_or_irreg(ttl_hopl_indicator.CVALUE,\n
          \     ttl_hopl.ULENGTH)                                    [ 0, 8 ];\n    msn
          \                 =:= msn_lsb(8)                    [ 8 ];\n    ip_id =:=
          ip_id_sequential_variable(ip_id_behavior_innermost.UVALUE,\n      ip_id_indicator.CVALUE)
          \                         [ 0, 8, 16 ];\n  }\n  // UO-0\n  COMPRESSED pt_0_crc3
          {\n    discriminator =:= '0'                             [ 1 ];\n    msn
          \          =:= msn_lsb(4)                      [ 4 ];\n    header_crc    =:=
          crc3(THIS.UVALUE, THIS.ULENGTH) [ 3 ];\n    ip_id         =:= inferred_sequential_ip_id
          \      [ 0 ];\n  }\n  // New format, Type 0 with strong CRC and more SN
          bits\n  COMPRESSED pt_0_crc7 {\n    discriminator =:= '100'                           [
          3 ];\n    msn           =:= msn_lsb(6)                      [ 6 ];\n    header_crc
          \   =:= crc7(THIS.UVALUE, THIS.ULENGTH) [ 7 ];\n    ip_id         =:= inferred_sequential_ip_id
          \      [ 0 ];\n  }\n  // UO-1-ID replacement (PT-1 only used for sequential)\n
          \ COMPRESSED pt_1_seq_id {\n    ENFORCE((ip_id_behavior_innermost.UVALUE
          ==\n             IP_ID_BEHAVIOR_SEQUENTIAL) ||\n            (ip_id_behavior_innermost.UVALUE
          ==\n             IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n    discriminator
          =:= '101'                                 [ 3 ];\n    header_crc    =:=
          crc3(THIS.UVALUE, THIS.ULENGTH)       [ 3 ];\n    msn           =:= msn_lsb(6)
          \                           [ 6 ];\n    ip_id =:= ip_id_lsb(ip_id_behavior_innermost.UVALUE,
          4) [ 4 ];\n  }\n  // UOR-2-ID replacement\n  COMPRESSED pt_2_seq_id {\n
          \   ENFORCE((ip_id_behavior_innermost.UVALUE ==\n             IP_ID_BEHAVIOR_SEQUENTIAL)
          ||\n            (ip_id_behavior_innermost.UVALUE ==\n             IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n
          \   discriminator =:= '110'                                 [ 3 ];\n    ip_id
          =:= ip_id_lsb(ip_id_behavior_innermost.UVALUE, 6) [ 6 ];\n    header_crc
          \   =:= crc7(THIS.UVALUE, THIS.ULENGTH)       [ 7 ];\n    msn           =:=
          msn_lsb(8)                            [ 8 ];\n  }\n"
        - '}

          '
        - '////////////////////////////////////////////

          '
        - '// UDP-lite/RTP profile

          '
        - '////////////////////////////////////////////

          '
        - "udplite_rtp_baseheader(profile_value, ts_stride_value,\n                       time_stride_value,
          outer_ip_flag,\n                       ip_id_behavior_value, reorder_ratio_value,\n
          \                      coverage_behavior_value)\n"
        - "{\n  UNCOMPRESSED v4 {\n    ENFORCE(msn.UVALUE == sequence_number.UVALUE);\n
          \   outer_headers  =:= baseheader_outer_headers        [ VARIABLE ];\n    ip_version
          \    =:= uncompressed_value(4, 4)        [  4 ];\n    header_length  =:=
          uncompressed_value(4, 5)        [  4 ];\n    tos_tc                                             [
          \ 8 ];\n    length         =:= inferred_ip_v4_length           [ 16 ];\n
          \   ip_id                                              [ 16 ];\n    rf             =:=
          uncompressed_value(1, 0)        [  1 ];\n    df                                                 [
          \ 1 ];\n    mf             =:= uncompressed_value(1, 0)        [  1 ];\n
          \   frag_offset    =:= uncompressed_value(13, 0)       [ 13 ];\n    ttl_hopl
          \                                          [  8 ];\n    next_header                                        [
          \ 8 ];\n    ip_checksum =:= inferred_ip_v4_header_checksum     [ 16 ];\n
          \   src_addr                                           [ 32 ];\n    dest_addr
          \                                         [ 32 ];\n    extension_headers
          =:= baseheader_extension_headers [ VARIABLE ];\n    src_port                                           [
          16 ];\n    dst_port                                           [ 16 ];\n
          \   checksum_coverage                                  [ 16 ];\n    udp_checksum
          \                                      [ 16 ];\n    rtp_version    =:= uncompressed_value(2,
          2)        [  2 ];\n    pad_bit                                            [
          \ 1 ];\n    extension                                          [  1 ];\n
          \   cc                                                 [  4 ];\n    marker
          \                                            [  1 ];\n    payload_type                                       [
          \ 7 ];\n    sequence_number                                    [ 16 ];\n
          \   timestamp                                          [ 32 ];\n    ssrc
          \                                              [ 32 ];\n    csrc_list                                          [
          VARIABLE ];\n  }\n  UNCOMPRESSED v6 {\n    ENFORCE(ip_id_behavior_innermost.UVALUE
          == IP_ID_BEHAVIOR_RANDOM);\n    outer_headers  =:= baseheader_outer_headers
          \       [ VARIABLE ];\n    ip_version     =:= uncompressed_value(4, 6)        [
          \  4 ];\n    tos_tc                                             [   8 ];\n
          \   flow_label                                         [  20 ];\n    payload_length
          =:= inferred_ip_v6_length           [  16 ];\n    next_header                                        [
          \  8 ];\n    ttl_hopl                                           [   8 ];\n
          \   src_addr                                           [ 128 ];\n    dest_addr
          \                                         [ 128 ];\n    extension_headers
          =:= baseheader_extension_headers [ VARIABLE ];\n    src_port                                           [
          \ 16 ];\n    dst_port                                           [  16 ];\n
          \   checksum_coverage                                  [  16 ];\n    udp_checksum
          \                                      [  16 ];\n    rtp_version =:= uncompressed_value(2,
          2)           [   2 ];\n    pad_bit                                            [
          \  1 ];\n    extension                                          [   1 ];\n
          \   cc                                                 [   4 ];\n    marker
          \                                            [   1 ];\n    payload_type
          \                                      [   7 ];\n    sequence_number                                    [
          \ 16 ];\n    timestamp                                          [  32 ];\n
          \   ssrc                                               [  32 ];\n    csrc_list
          \                                         [ VARIABLE ];\n    df    =:= uncompressed_value(0,0)
          \                 [   0 ];\n    ip_id =:= uncompressed_value(0,0)                  [
          \  0 ];\n  }\n  CONTROL {\n    ENFORCE(profile_value == PROFILE_RTP_0107);\n
          \   ENFORCE(profile == profile_value);\n    ENFORCE(time_stride.UVALUE ==
          time_stride_value);\n    ENFORCE(ts_stride.UVALUE == ts_stride_value);\n
          \   ENFORCE(coverage_behavior.UVALUE == coverage_behavior_value);\n    ENFORCE(reorder_ratio.UVALUE
          == reorder_ratio_value);\n    ENFORCE(ip_id_behavior_innermost.UVALUE ==
          ip_id_behavior_value);\n    dummy_field =:= field_scaling(ts_stride.UVALUE,\n
          \     ts_scaled.UVALUE, timestamp.UVALUE, ts_offset.UVALUE) [ 0 ];\n  }\n
          \ INITIAL {\n    ts_stride     =:= uncompressed_value(32, TS_STRIDE_DEFAULT);\n
          \   time_stride   =:= uncompressed_value(32, TIME_STRIDE_DEFAULT);\n  }\n
          \ DEFAULT {\n    ENFORCE(outer_ip_flag == 0);\n    tos_tc            =:=
          static;\n    dest_addr         =:= static;\n    ttl_hopl          =:= static;\n
          \   src_addr          =:= static;\n    df                =:= static;\n    flow_label
          \       =:= static;\n    next_header       =:= static;\n    src_port          =:=
          static;\n    dst_port          =:= static;\n    pad_bit           =:= static;\n
          \   extension         =:= static;\n    cc                =:= static;\n    //
          When marker not present in packets, it is assumed 0\n    marker            =:=
          uncompressed_value(1, 0);\n    payload_type      =:= static;\n    sequence_number
          \  =:= static;\n    timestamp         =:= static;\n    ssrc              =:=
          static;\n    csrc_list         =:= static;\n    ts_stride         =:= static;\n
          \   time_stride       =:= static;\n    ts_scaled         =:= static;\n    ts_offset
          \        =:= static;\n    reorder_ratio     =:= static;\n    ip_id_behavior_innermost
          =:= static;\n  }\n  // Replacement for UOR-2-ext3\n  COMPRESSED co_common
          {\n    ENFORCE(outer_ip_flag == outer_ip_indicator.CVALUE);\n    discriminator
          \       =:= '11111010'                    [ 8 ];\n    marker               =:=
          irregular(1)                  [ 1 ];\n    header_crc   =:= crc7(THIS.UVALUE,
          THIS.ULENGTH)       [ 7 ];\n    flags1_indicator     =:= irregular(1)                  [
          1 ];\n    flags2_indicator     =:= irregular(1)                  [ 1 ];\n
          \   tsc_indicator        =:= irregular(1)                  [ 1 ];\n    tss_indicator
          \       =:= irregular(1)                  [ 1 ];\n    ip_id_indicator      =:=
          irregular(1)                  [ 1 ];\n    control_crc3         =:= control_crc3_encoding
          \        [ 3 ];\n    outer_ip_indicator : ttl_hopl_indicator :\n      tos_tc_indicator
          : df : ip_id_behavior_innermost : reorder_ratio\n      =:= profile_1_7_flags1_enc(flags1_indicator.CVALUE,\n
          \       ip_version.UVALUE)                                 [ 0, 8 ];\n    list_indicator
          : pt_indicator : tis_indicator : pad_bit :\n      extension : coverage_behavior
          =:=\n      profile_7_flags2_enc(flags2_indicator.CVALUE)        [ 0, 8 ];\n
          \   tos_tc =:= static_or_irreg(tos_tc_indicator.CVALUE, 8) [ 0, 8 ];\n    ttl_hopl
          =:=\n      static_or_irreg(ttl_hopl_indicator.CVALUE, 8)        [ 0, 8 ];\n
          \   payload_type =:= pt_irr_or_static(pt_indicator.CVALUE) [ 0, 8 ];\n    sequence_number
          =:=\n      sdvl_sn_lsb(sequence_number.ULENGTH)               [ VARIABLE
          ];\n    ip_id =:= ip_id_sequential_variable(ip_id_behavior_innermost.UVALUE,\n
          \     ip_id_indicator.CVALUE)                            [ 0, 8, 16 ];\n
          \   ts_scaled =:= variable_scaled_timestamp(tss_indicator.CVALUE,\n      tsc_indicator.CVALUE,
          ts_stride.UVALUE,\n      time_stride.UVALUE)                                [
          VARIABLE ];\n    timestamp =:= variable_unscaled_timestamp(tss_indicator.CVALUE,\n
          \     tsc_indicator.CVALUE)                              [ VARIABLE ];\n
          \   ts_stride =:= sdvl_or_static(tss_indicator.CVALUE)   [ VARIABLE ];\n
          \   time_stride =:= sdvl_or_static(tis_indicator.CVALUE) [ VARIABLE ];\n
          \   csrc_list            =:=\n        csrc_list_presence(list_indicator.CVALUE,\n
          \         cc.UVALUE)                                     [ VARIABLE ];\n
          \ }\n  // UO-0\n  COMPRESSED pt_0_crc3 {\n    discriminator =:= '0'                             [
          1 ];\n    msn           =:= msn_lsb(4)                      [ 4 ];\n    header_crc
          \   =:= crc3(THIS.UVALUE, THIS.ULENGTH) [ 3 ];\n    timestamp     =:= inferred_scaled_field
          \          [ 0 ];\n    ip_id         =:= inferred_sequential_ip_id       [
          0 ];\n  }\n  // New format, Type 0 with strong CRC and more SN bits\n  COMPRESSED
          pt_0_crc7 {\n    discriminator =:= '1000'                          [ 4 ];\n
          \   msn           =:= msn_lsb(5)                      [ 5 ];\n    header_crc
          \   =:= crc7(THIS.UVALUE, THIS.ULENGTH) [ 7 ];\n    timestamp     =:= inferred_scaled_field
          \          [ 0 ];\n    ip_id         =:= inferred_sequential_ip_id       [
          0 ];\n  }\n  // UO-1 replacement\n  COMPRESSED pt_1_rnd {\n    ENFORCE(ts_stride.UVALUE
          != 0);\n    ENFORCE((ip_id_behavior_innermost.UVALUE ==\n             IP_ID_BEHAVIOR_RANDOM)
          ||\n            (ip_id_behavior_innermost.UVALUE == IP_ID_BEHAVIOR_ZERO));\n
          \   discriminator =:= '101'                                [ 3 ];\n    marker
          \       =:= irregular(1)                         [ 1 ];\n    msn           =:=
          msn_lsb(4)                           [ 4 ];\n    ts_scaled     =:= scaled_ts_lsb(time_stride.UVALUE,
          5) [ 5 ];\n    header_crc    =:= crc3(THIS.UVALUE, THIS.ULENGTH)      [
          3 ];\n  }\n  // UO-1-ID replacement\n  COMPRESSED pt_1_seq_id {\n    ENFORCE((ip_id_behavior_innermost.UVALUE
          ==\n             IP_ID_BEHAVIOR_SEQUENTIAL) ||\n            (ip_id_behavior_innermost.UVALUE
          ==\n             IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n    discriminator
          =:= '1001'                                [ 4 ];\n    ip_id =:= ip_id_lsb(ip_id_behavior_innermost.UVALUE,
          4) [ 4 ];\n    msn           =:= msn_lsb(5)                            [
          5 ];\n    header_crc    =:= crc3(THIS.UVALUE, THIS.ULENGTH)       [ 3 ];\n
          \   timestamp     =:= inferred_scaled_field                 [ 0 ];\n  }\n
          \ // UO-1-TS replacement\n  COMPRESSED pt_1_seq_ts {\n    ENFORCE(ts_stride.UVALUE
          != 0);\n    ENFORCE((ip_id_behavior_innermost.UVALUE ==\n             IP_ID_BEHAVIOR_SEQUENTIAL)
          ||\n            (ip_id_behavior_innermost.UVALUE ==\n             IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n
          \   discriminator =:= '101'                                [ 3 ];\n    marker
          \       =:= irregular(1)                         [ 1 ];\n    msn           =:=
          msn_lsb(4)                           [ 4 ];\n    ts_scaled     =:= scaled_ts_lsb(time_stride.UVALUE,
          5) [ 5 ];\n    header_crc    =:= crc3(THIS.UVALUE, THIS.ULENGTH)      [
          3 ];\n    ip_id         =:= inferred_sequential_ip_id            [ 0 ];\n
          \ }\n  // UOR-2 replacement\n  COMPRESSED pt_2_rnd {\n    ENFORCE(ts_stride.UVALUE
          != 0);\n    ENFORCE((ip_id_behavior_innermost.UVALUE ==\n             IP_ID_BEHAVIOR_RANDOM)
          ||\n            (ip_id_behavior_innermost.UVALUE == IP_ID_BEHAVIOR_ZERO));\n
          \   discriminator =:= '110'                                [ 3 ];\n    msn
          \          =:= msn_lsb(7)                           [ 7 ];\n    ts_scaled
          \    =:= scaled_ts_lsb(time_stride.UVALUE, 6) [ 6 ];\n    marker        =:=
          irregular(1)                         [ 1 ];\n    header_crc    =:= crc7(THIS.UVALUE,
          THIS.ULENGTH)      [ 7 ];\n  }\n  // UOR-2-ID replacement\n  COMPRESSED
          pt_2_seq_id {\n    ENFORCE((ip_id_behavior_innermost.UVALUE ==\n             IP_ID_BEHAVIOR_SEQUENTIAL)
          ||\n            (ip_id_behavior_innermost.UVALUE ==\n             IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n
          \   discriminator =:= '11000'                               [ 5 ];\n    msn
          \          =:= msn_lsb(7)                            [ 7 ];\n    ip_id =:=
          ip_id_lsb(ip_id_behavior_innermost.UVALUE, 5) [ 5 ];\n    header_crc    =:=
          crc7(THIS.UVALUE, THIS.ULENGTH)       [ 7 ];\n    timestamp     =:= inferred_scaled_field
          \                [ 0 ];\n  }\n  // UOR-2-ID-ext1 replacement (both TS and
          IP-ID)\n  COMPRESSED pt_2_seq_both {\n    ENFORCE(ts_stride.UVALUE != 0);\n
          \   ENFORCE((ip_id_behavior_innermost.UVALUE ==\n             IP_ID_BEHAVIOR_SEQUENTIAL)
          ||\n            (ip_id_behavior_innermost.UVALUE ==\n             IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n
          \   discriminator =:= '11001'                               [ 5 ];\n    msn
          \          =:= msn_lsb(7)                            [ 7 ];\n    ip_id =:=
          ip_id_lsb(ip_id_behavior_innermost.UVALUE, 5) [ 5 ];\n    header_crc    =:=
          crc7(THIS.UVALUE, THIS.ULENGTH)       [ 7 ];\n    ts_scaled     =:= scaled_ts_lsb(time_stride.UVALUE,
          7)  [ 7 ];\n    marker        =:= irregular(1)                          [
          1 ];\n  }\n  // UOR-2-TS replacement\n  COMPRESSED pt_2_seq_ts {\n    ENFORCE(ts_stride.UVALUE
          != 0);\n    ENFORCE((ip_id_behavior_innermost.UVALUE ==\n             IP_ID_BEHAVIOR_SEQUENTIAL)
          ||\n            (ip_id_behavior_innermost.UVALUE ==\n             IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n
          \   discriminator =:= '1101'                               [ 4 ];\n    msn
          \          =:= msn_lsb(7)                           [ 7 ];\n    ts_scaled
          \    =:= scaled_ts_lsb(time_stride.UVALUE, 5) [ 5 ];\n    marker        =:=
          irregular(1)                         [ 1 ];\n    header_crc    =:= crc7(THIS.UVALUE,
          THIS.ULENGTH)      [ 7 ];\n    ip_id         =:= inferred_sequential_ip_id
          \           [ 0 ];\n  }\n"
        - '}

          '
        - '////////////////////////////////////////////

          '
        - '// UDP-lite profile

          '
        - '////////////////////////////////////////////

          '
        - "udplite_baseheader(profile_value, outer_ip_flag, ip_id_behavior_value,\n
          \                  reorder_ratio_value, coverage_behavior_value)\n"
        - "{\n  UNCOMPRESSED v4 {\n    outer_headers  =:= baseheader_outer_headers
          \       [ VARIABLE ];\n    ip_version     =:= uncompressed_value(4, 4)        [
          \ 4 ];\n    header_length  =:= uncompressed_value(4, 5)        [  4 ];\n
          \   tos_tc                                             [  8 ];\n    length
          \        =:= inferred_ip_v4_length           [ 16 ];\n    ip_id                                              [
          16 ];\n    rf             =:= uncompressed_value(1, 0)        [  1 ];\n
          \   df                                                 [  1 ];\n    mf             =:=
          uncompressed_value(1, 0)        [  1 ];\n    frag_offset    =:= uncompressed_value(13,
          0)       [ 13 ];\n    ttl_hopl                                           [
          \ 8 ];\n    next_header                                        [  8 ];\n
          \   ip_checksum =:= inferred_ip_v4_header_checksum     [ 16 ];\n    src_addr
          \                                          [ 32 ];\n    dest_addr                                          [
          32 ];\n    extension_headers =:= baseheader_extension_headers [ VARIABLE
          ];\n    src_port                                           [ 16 ];\n    dst_port
          \                                          [ 16 ];\n    checksum_coverage
          \                                 [ 16 ];\n    udp_checksum                                       [
          16 ];\n  }\n  UNCOMPRESSED v6 {\n    ENFORCE(ip_id_behavior_innermost.UVALUE
          == IP_ID_BEHAVIOR_RANDOM);\n    outer_headers  =:= baseheader_outer_headers
          \       [ VARIABLE ];\n    ip_version     =:= uncompressed_value(4, 6)        [
          \  4 ];\n    tos_tc                                             [   8 ];\n
          \   flow_label                                         [  20 ];\n    payload_length
          =:= inferred_ip_v6_length           [  16 ];\n    next_header                                        [
          \  8 ];\n    ttl_hopl                                           [   8 ];\n
          \   src_addr                                           [ 128 ];\n    dest_addr
          \                                         [ 128 ];\n    extension_headers
          =:= baseheader_extension_headers [ VARIABLE ];\n    src_port                                           [
          \ 16 ];\n    dst_port                                           [  16 ];\n
          \   checksum_coverage                                  [  16 ];\n    udp_checksum
          \                                      [  16 ];\n    df    =:= uncompressed_value(0,0)
          \                 [   0 ];\n    ip_id =:= uncompressed_value(0,0)                  [
          \  0 ];\n  }\n  CONTROL {\n    ENFORCE(profile_value == PROFILE_UDPLITE_0108);\n
          \   ENFORCE(profile == profile_value);\n    ENFORCE(coverage_behavior.UVALUE
          == coverage_behavior_value);\n    ENFORCE(reorder_ratio.UVALUE == reorder_ratio_value);\n
          \   ENFORCE(ip_id_behavior_innermost.UVALUE == ip_id_behavior_value);\n
          \ }\n  DEFAULT {\n    ENFORCE(outer_ip_flag == 0);\n    tos_tc            =:=
          static;\n    dest_addr         =:= static;\n    ttl_hopl          =:= static;\n
          \   src_addr          =:= static;\n    df                =:= static;\n    flow_label
          \       =:= static;\n    next_header       =:= static;\n    src_port          =:=
          static;\n    dst_port          =:= static;\n    reorder_ratio     =:= static;\n
          \   ip_id_behavior_innermost =:= static;\n  }\n  // Replacement for UOR-2-ext3\n
          \ COMPRESSED co_common {\n    ENFORCE(outer_ip_flag == outer_ip_indicator.CVALUE);\n
          \   discriminator        =:= '11111010'                    [ 8 ];\n    ip_id_indicator
          \     =:= irregular(1)                  [ 1 ];\n    header_crc   =:= crc7(THIS.UVALUE,
          THIS.ULENGTH)       [ 7 ];\n    flags_indicator      =:= irregular(1)                  [
          1 ];\n    ttl_hopl_indicator   =:= irregular(1)                  [ 1 ];\n
          \   tos_tc_indicator     =:= irregular(1)                  [ 1 ];\n    reorder_ratio
          \       =:= irregular(2)                  [ 2 ];\n    control_crc3         =:=
          control_crc3_encoding         [ 3 ];\n    outer_ip_indicator : df : ip_id_behavior_innermost
          :\n      coverage_behavior  =:=\n      profile_8_flags_enc(flags_indicator.CVALUE,\n
          \     ip_version.UVALUE)                                   [ 0, 8 ];\n    tos_tc
          =:= static_or_irreg(tos_tc_indicator.CVALUE, 8) [ 0, 8 ];\n    ttl_hopl
          =:= static_or_irreg(ttl_hopl_indicator.CVALUE,\n      ttl_hopl.ULENGTH)
          \                                   [ 0, 8 ];\n    msn                  =:=
          msn_lsb(8)                    [ 8 ];\n    ip_id =:= ip_id_sequential_variable(ip_id_behavior_innermost.UVALUE,\n
          \     ip_id_indicator.CVALUE)                          [ 0, 8, 16 ];\n  }\n
          \ // UO-0\n  COMPRESSED pt_0_crc3 {\n    discriminator =:= '0'                             [
          1 ];\n    msn           =:= msn_lsb(4)                      [ 4 ];\n    header_crc
          \   =:= crc3(THIS.UVALUE, THIS.ULENGTH) [ 3 ];\n    ip_id         =:= inferred_sequential_ip_id
          \      [ 0 ];\n  }\n  // New format, Type 0 with strong CRC and more SN
          bits\n  COMPRESSED pt_0_crc7 {\n    discriminator =:= '100'                           [
          3 ];\n    msn           =:= msn_lsb(6)                      [ 6 ];\n    header_crc
          \   =:= crc7(THIS.UVALUE, THIS.ULENGTH) [ 7 ];\n    ip_id         =:= inferred_sequential_ip_id
          \      [ 0 ];\n  }\n  // UO-1-ID replacement (PT-1 only used for sequential)\n
          \ COMPRESSED pt_1_seq_id {\n    ENFORCE((ip_id_behavior_innermost.UVALUE
          ==\n             IP_ID_BEHAVIOR_SEQUENTIAL) ||\n            (ip_id_behavior_innermost.UVALUE
          ==\n             IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n    discriminator
          =:= '101'                                 [ 3 ];\n    header_crc    =:=
          crc3(THIS.UVALUE, THIS.ULENGTH)       [ 3 ];\n    msn           =:= msn_lsb(6)
          \                           [ 6 ];\n    ip_id =:= ip_id_lsb(ip_id_behavior_innermost.UVALUE,
          4) [ 4 ];\n  }\n  // UOR-2-ID replacement\n  COMPRESSED pt_2_seq_id {\n
          \   ENFORCE((ip_id_behavior_innermost.UVALUE ==\n             IP_ID_BEHAVIOR_SEQUENTIAL)
          ||\n            (ip_id_behavior_innermost.UVALUE ==\n             IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n
          \   discriminator =:= '110'                                 [ 3 ];\n    ip_id
          =:= ip_id_lsb(ip_id_behavior_innermost.UVALUE, 6) [ 6 ];\n    header_crc
          \   =:= crc7(THIS.UVALUE, THIS.ULENGTH)       [ 7 ];\n    msn           =:=
          msn_lsb(8)                            [ 8 ];\n  }\n"
        - '}

          '
        title: 6.8.2.4.  Header Formats in ROHC-FN
      title: 6.8.2.  Compressed Header Formats (CO)
    title: 6.8.  Header Formats
  - contents:
    - '6.9.  Feedback Formats and Options

      '
    - contents:
      - "6.9.1.  Feedback Formats\n   This section describes the feedback format for
        ROHCv2 profiles, using\n   the formats described in Section 5.2.3 of [RFC4995].\n
        \  The Acknowledgment Number field of the feedback formats contains the\n
        \  least significant bits of the MSN (see Section 6.3.1) that\n   corresponds
        to the reference header that is being acknowledged.  A\n   reference header
        is a header that has been successfully CRC-8\n   validated or CRC verified.
        \ If there is no reference header\n   available, the feedback MUST carry an
        ACKNUMBER-NOT-VALID option.\n   FEEDBACK-1\n        0   1   2   3   4   5
        \  6   7\n      +---+---+---+---+---+---+---+---+\n      |     Acknowledgment
        Number     |\n      +---+---+---+---+---+---+---+---+\n      Acknowledgment
        Number: The eight least significant bits of the\n      MSN.\n   A FEEDBACK-1
        is an ACK.  In order to send a NACK or a STATIC-NACK,\n   FEEDBACK-2 must
        be used.\n   FEEDBACK-2\n        0   1   2   3   4   5   6   7\n      +---+---+---+---+---+---+---+---+\n
        \     |Acktype| Acknowledgment Number |\n      +---+---+---+---+---+---+---+---+\n
        \     |     Acknowledgment Number     |\n      +---+---+---+---+---+---+---+---+\n
        \     |              CRC              |\n      +---+---+---+---+---+---+---+---+\n
        \     /       Feedback options        /\n      +---+---+---+---+---+---+---+---+\n
        \     Acktype:\n         0 = ACK\n         1 = NACK\n         2 = STATIC-NACK\n
        \        3 is reserved (MUST NOT be used for parsability)\n      Acknowledgment
        Number: The least significant bits of the MSN.\n      CRC: 8-bit CRC computed
        over the entire feedback payload including\n      any CID fields but excluding
        the feedback type, the 'Size' field,\n      and the 'Code' octet, using the
        polynomial defined in Section\n      5.3.1.1 of [RFC4995].  If the CID is
        given with an Add-CID octet,\n      the Add-CID octet immediately precedes
        the FEEDBACK-1 or\n      FEEDBACK-2 format.  For purposes of computing the
        CRC, the CRC\n      field is zero.\n      Feedback options: A variable number
        of feedback options, see\n      Section 6.9.2.  Options may appear in any
        order.\n   A FEEDBACK-2 of type NACK or STATIC-NACK is always implicitly an\n
        \  acknowledgment for a successfully decompressed packet, which\n   corresponds
        to a packet whose LSBs match the Acknowledgment Number of\n   the feedback
        element, unless the ACKNUMBER-NOT-VALID option (see\n   Section 6.9.2.2) appears
        in the feedback element.\n   The FEEDBACK-2 format always carries a CRC and
        is thus more robust\n   than the FEEDBACK-1 format.  When receiving FEEDBACK-2,
        the\n   compressor MUST verify the information by computing the CRC and\n
        \  comparing the result with the CRC carried in the feedback format.  If\n
        \  the two are not identical, the feedback element MUST be discarded.\n"
      title: 6.9.1.  Feedback Formats
    - contents:
      - "6.9.2.  Feedback Options\n   A feedback option has variable length and the
        following general\n   format:\n        0   1   2   3   4   5   6   7\n      +---+---+---+---+---+---+---+---+\n
        \     |   Opt Type    |    Opt Len    |\n      +---+---+---+---+---+---+---+---+\n
        \     /          Option Data          /  Opt Len (octets)\n      +---+---+---+---+---+---+---+---+\n
        \     Opt Type: Unsigned integer that represents the type of the\n      feedback
        option.  Section 6.9.2.1 through Section 6.9.2.4\n      describes the ROHCv2
        feedback options.\n      Opt Len: Unsigned integer that represents the length
        of the Option\n      Data field, in octets.\n      Option Data: Feedback type
        specific data.  Present if the value of\n      the Opt Len field is set to
        a non-zero value.\n"
      - contents:
        - "6.9.2.1.  The REJECT Option\n   The REJECT option informs the compressor
          that the decompressor does\n   not have sufficient resources to handle the
          flow.\n        0   1   2   3   4   5   6   7\n      +---+---+---+---+---+---+---+---+\n
          \     |  Opt Type = 2 |  Opt Len = 0  |\n      +---+---+---+---+---+---+---+---+\n
          \  When receiving a REJECT option, the compressor MUST stop compressing\n
          \  the packet flow, and SHOULD refrain from attempting to increase the\n
          \  number of compressed packet flows for some time.  The REJECT option\n
          \  MUST NOT appear more than once in the FEEDBACK-2 format; otherwise,\n
          \  the compressor MUST discard the entire feedback element.\n"
        title: 6.9.2.1.  The REJECT Option
      - contents:
        - "6.9.2.2.  The ACKNUMBER-NOT-VALID Option\n   The ACKNUMBER-NOT-VALID option
          indicates that the Acknowledgment\n   Number field of the feedback is not
          valid.\n        0   1   2   3   4   5   6   7\n      +---+---+---+---+---+---+---+---+\n
          \     |  Opt Type = 3 |  Opt Len = 0  |\n      +---+---+---+---+---+---+---+---+\n
          \  A compressor MUST NOT use the Acknowledgment Number of the feedback\n
          \  to find the corresponding sent header when this option is present.\n
          \  When this option is used, the Acknowledgment Number field of the\n   FEEDBACK-2
          format is set to zero.  Consequently, a NACK or a STATIC-\n   NACK feedback
          type sent with the ACKNUMBER-NOT-VALID option is\n   equivalent to a STATIC-NACK
          with respect to the type of context\n   repair requested by the decompressor.\n
          \  The ACKNUMBER-NOT-VALID option MUST NOT appear more than once in the\n
          \  FEEDBACK-2 format; otherwise, the compressor MUST discard the entire\n
          \  feedback element.\n"
        title: 6.9.2.2.  The ACKNUMBER-NOT-VALID Option
      - contents:
        - "6.9.2.3.  The CONTEXT_MEMORY Option\n   The CONTEXT_MEMORY option informs
          the compressor that the\n   decompressor does not have sufficient memory
          resources to handle the\n   context of the packet flow, as the flow is currently
          compressed.\n        0   1   2   3   4   5   6   7\n      +---+---+---+---+---+---+---+---+\n
          \     |  Opt Type = 9 |  Opt Len = 0  |\n      +---+---+---+---+---+---+---+---+\n
          \  When receiving a CONTEXT_MEMORY option, the compressor SHOULD take\n
          \  actions to compress the packet flow in a way that requires less\n   decompressor
          memory resources or stop compressing the packet flow.\n   The CONTEXT_MEMORY
          option MUST NOT appear more than once in the\n   FEEDBACK-2 format; otherwise,
          the compressor MUST discard the entire\n   feedback element.\n"
        title: 6.9.2.3.  The CONTEXT_MEMORY Option
      - contents:
        - "6.9.2.4.  The CLOCK_RESOLUTION Option\n   The CLOCK_RESOLUTION option informs
          the compressor of the clock\n   resolution of the decompressor.  It also
          informs whether or not the\n   decompressor supports timer-based compression
          of the RTP TS timestamp\n   (see Section 6.6.9).  The CLOCK_RESOLUTION option
          is applicable per\n   channel, i.e., it applies to any context associated
          with a profile\n   for which the option is relevant between a compressor
          and\n   decompressor pair.\n        0   1   2   3   4   5   6   7\n      +---+---+---+---+---+---+---+---+\n
          \     | Opt Type = 10 |  Opt Len = 1  |\n      +---+---+---+---+---+---+---+---+\n
          \     |     Clock resolution (ms)     |\n      +---+---+---+---+---+---+---+---+\n
          \     Clock resolution: Unsigned integer that represents the clock\n      resolution
          of the decompressor expressed in milliseconds.\n   The smallest clock resolution
          that can be indicated is 1 millisecond.\n   The value zero has a special
          meaning: it indicates that the\n   decompressor cannot do timer-based compression
          of the RTP Timestamp.\n   The CLOCK_RESOLUTION option MUST NOT appear more
          than once in the\n   FEEDBACK-2 format; otherwise, the compressor MUST discard
          the entire\n   feedback element.\n"
        title: 6.9.2.4.  The CLOCK_RESOLUTION Option
      - contents:
        - "6.9.2.5.  Unknown Option Types\n   If an option type other than those defined
          in this document is\n   encountered, the compressor MUST discard the entire
          feedback element.\n"
        title: 6.9.2.5.  Unknown Option Types
      title: 6.9.2.  Feedback Options
    title: 6.9.  Feedback Formats and Options
  title: 6.  ROHCv2 Profiles (Normative)
- contents:
  - "7.  Security Considerations\n   Impairments such as bit errors on the received
    compressed headers,\n   missing packets, and reordering between packets could
    cause the\n   header decompressor to reconstitute erroneous packets, i.e., packets\n
    \  that do not match the original packet, but still have a valid IP, UDP\n   (or
    UDP-Lite), and RTP headers, and possibly also valid UDP (or UDP-\n   Lite) checksums.\n
    \  The header compression profiles defined herein use an internal\n   checksum
    for verification of reconstructed headers.  This reduces the\n   probability that
    a header decompressor delivers erroneous packets to\n   upper layers without the
    error being noticed.  In particular, the\n   probability that consecutive erroneous
    packets are not detected by\n   the internal checksum is close to zero.\n   This
    small but non-zero probability remains unchanged when integrity\n   protection
    is applied after compression and verified before\n   decompression, in the case
    where an attacker could discard or reorder\n   packets between the compression
    endpoints.\n   The impairments mentioned above could be caused by a malfunctioning\n
    \  or malicious header compressor.  Such corruption may be detected with\n   end-to-end
    integrity mechanisms that will not be affected by the\n   compression.  Moreover,
    the internal checksum can also be useful in\n   the case of malfunctioning compressors.\n
    \  Denial-of-service attacks are possible if an intruder can introduce\n   (for
    example) bogus IR or FEEDBACK packets onto the link and thereby\n   cause compression
    efficiency to be reduced.  However, an intruder\n   having the ability to inject
    arbitrary packets at the link layer in\n   this manner raises additional security
    issues that dwarf those\n   related to the use of header compression.\n"
  title: 7.  Security Considerations
- contents:
  - "8.  IANA Considerations\n   The following ROHC profile identifiers have been
    assigned by the IANA\n   for the profiles defined in this document:\n     Identifier
    \       Profile\n     ----------        -------\n     0x0101            ROHCv2
    RTP\n     0x0102            ROHCv2 UDP\n     0x0103            ROHCv2 ESP\n     0x0104
    \           ROHCv2 IP\n     0x0107            ROHCv2 RTP/UDP-Lite\n     0x0108
    \           ROHCv2 UDP-Lite\n"
  title: 8.  IANA Considerations
- contents:
  - "9.  Acknowledgements\n   The authors would like to thank Mark West, Robert Finking,
    Haipeng\n   Jin, and Rohit Kapoor for serving as committed document reviewers,\n
    \  and also for constructive discussions during the development of this\n   document.
    \ Thanks to Carl Knutsson for his extensive contribution to\n   this specification,
    as well as to Jani Juvan and Anders Edqvist for\n   useful comments and feedback.
    \ Thanks also to Elwyn Davies for his\n   review as the General Area Review Team
    (Gen-ART) reviewer, and to\n   Stephen Kent for his review on behalf of the IETF
    security\n   directorate, during IETF last-call.  Finally, thanks to the many\n
    \  people who have contributed to previous ROHC specifications and\n   supported
    this effort.\n"
  title: 9.  Acknowledgements
- contents:
  - '10.  References

    '
  - contents:
    - "10.1.  Normative References\n   [RFC0768]  Postel, J., \"User Datagram Protocol\",
      STD 6, RFC 768,\n              August 1980.\n   [RFC0791]  Postel, J., \"Internet
      Protocol\", STD 5, RFC 791,\n              September 1981.\n   [RFC2004]  Perkins,
      C., \"Minimal Encapsulation within IP\", RFC 2004,\n              October 1996.\n
      \  [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement
      Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC2460]  Deering, S. and R. Hinden,
      \"Internet Protocol, Version 6\n              (IPv6) Specification\", RFC 2460,
      December 1998.\n   [RFC2784]  Farinacci, D., Li, T., Hanks, S., Meyer, D., and
      P.\n              Traina, \"Generic Routing Encapsulation (GRE)\", RFC 2784,\n
      \             March 2000.\n   [RFC2890]  Dommety, G., \"Key and Sequence Number
      Extensions to GRE\",\n              RFC 2890, September 2000.\n   [RFC3550]
      \ Schulzrinne, H., Casner, S., Frederick, R., and V.\n              Jacobson,
      \"RTP: A Transport Protocol for Real-Time\n              Applications\", STD
      64, RFC 3550, July 2003.\n   [RFC3828]  Larzon, L-A., Degermark, M., Pink, S.,
      Jonsson, L-E., and\n              G. Fairhurst, \"The Lightweight User Datagram
      Protocol\n              (UDP-Lite)\", RFC 3828, July 2004.\n   [RFC4019]  Pelletier,
      G., \"RObust Header Compression (ROHC): Profiles\n              for User Datagram
      Protocol (UDP) Lite\", RFC 4019,\n              April 2005.\n   [RFC4302]  Kent,
      S., \"IP Authentication Header\", RFC 4302,\n              December 2005.\n
      \  [RFC4303]  Kent, S., \"IP Encapsulating Security Payload (ESP)\",\n              RFC
      4303, December 2005.\n   [RFC4995]  Jonsson, L-E., Pelletier, G., and K. Sandlund,
      \"The RObust\n              Header Compression (ROHC) Framework\", RFC 4995,
      July 2007.\n   [RFC4997]  Finking, R. and G. Pelletier, \"Formal Notation for
      RObust\n              Header Compression (ROHC-FN)\", RFC 4997, July 2007.\n"
    title: 10.1.  Normative References
  - contents:
    - "10.2.  Informative References\n   [RFC2675]  Borman, D., Deering, S., and R.
      Hinden, \"IPv6 Jumbograms\",\n              RFC 2675, August 1999.\n   [RFC3095]
      \ Bormann, C., Burmeister, C., Degermark, M., Fukushima, H.,\n              Hannu,
      H., Jonsson, L-E., Hakenberg, R., Koren, T., Le,\n              K., Liu, Z.,
      Martensson, A., Miyazaki, A., Svanbro, K.,\n              Wiebke, T., Yoshimura,
      T., and H. Zheng, \"RObust Header\n              Compression (ROHC): Framework
      and four profiles: RTP, UDP,\n              ESP, and uncompressed\", RFC 3095,
      July 2001.\n   [RFC3843]  Jonsson, L-E. and G. Pelletier, \"RObust Header Compression\n
      \             (ROHC): A Compression Profile for IP\", RFC 3843,\n              June
      2004.\n   [RFC4224]  Pelletier, G., Jonsson, L-E., and K. Sandlund, \"RObust\n
      \             Header Compression (ROHC): ROHC over Channels That Can\n              Reorder
      Packets\", RFC 4224, January 2006.\n"
    title: 10.2.  Informative References
  title: 10.  References
- contents:
  - "Appendix A.  Detailed Classification of Header Fields\n   Header compression
    is possible due to the fact that most header\n   fields do not vary randomly from
    packet to packet.  Many of the\n   fields exhibit static behavior or change in
    a more or less\n   predictable way.  When designing a header compression scheme,
    it is\n   of fundamental importance to understand the behavior of the fields in\n
    \  detail.\n   In this appendix, all fields in the headers compressible by these\n
    \  profiles are classified and analyzed.  The analysis is based on\n   behavior
    for the types of traffic that are expected to be the most\n   frequently compressed
    (e.g., RTP field behavior is based on voice\n   and/or video traffic behavior).\n
    \  Fields are classified as belonging to one of the following classes:\n   INFERRED
    - These fields contain values that can be inferred from\n   other values, for
    example the size of the frame carrying the packet,\n   and thus do not have to
    be included in compressed packets.\n   STATIC - These fields are expected to be
    constant throughout the\n   lifetime of the flow; in general, it is sufficient
    to design a\n   compressed format so that these fields are only updated by IR\n
    \  packets.\n   STATIC-DEF - These fields are expected to be constant throughout
    the\n   lifetime of the flow and their values can be used to define a flow.\n
    \  They are only sent in IR packets.\n   STATIC-KNOWN - These fields are expected
    to have well-known values\n   and therefore do not need to be communicated at
    all.\n   SEMISTATIC - These fields are unchanged most of the time.  However,\n
    \  occasionally the value changes but will revert to its original value.\n   For
    ROHCv2, the values of such fields do not need to be possible to\n   change with
    the smallest compressed packet formats, but should be\n   possible to change via
    slightly larger compressed packets.\n   RARELY CHANGING (RACH) - These are fields
    that change their values\n   occasionally and then keep their new values.  For
    ROHCv2, the values\n   of such fields do not need to be possible to change with
    the smallest\n   compressed packet formats, but should be possible to change via\n
    \  slightly larger compressed packets.\n   IRREGULAR - These are the fields for
    which no useful change pattern\n   can be identified and should be transmitted
    uncompressed in all\n   compressed packets.\n   PATTERN - These are fields that
    change between each packet, but\n   change in a predictable pattern.\n"
  - contents:
    - "A.1.  IPv4 Header Fields\n   +------------------------+----------------+\n
      \  | Field                  | Class          |\n   +------------------------+----------------+\n
      \  | Version                | STATIC-KNOWN   |\n   | Header Length          |
      STATIC-KNOWN   |\n   | Type Of Service        | RACH           |\n   | Packet
      Length          | INFERRED       |\n   | Identification         |                |\n
      \  |             Sequential | PATTERN        |\n   |             Seq. swap  |
      PATTERN        |\n   |             Random     | IRREGULAR      |\n   |             Zero
      \      | STATIC         |\n   | Reserved flag          | STATIC-KNOWN   |\n
      \  | Don't Fragment flag    | RACH           |\n   | More Fragments flag    |
      STATIC-KNOWN   |\n   | Fragment Offset        | STATIC-KNOWN   |\n   | Time
      To Live           | RACH           |\n   | Protocol               | STATIC-DEF
      \    |\n   | Header Checksum        | INFERRED       |\n   | Source Address
      \        | STATIC-DEF     |\n   | Destination Address    | STATIC-DEF     |\n
      \  +------------------------+----------------+\n   Version\n      The version
      field states which IP version is used and is set to\n      the value four.\n
      \  Header Length\n      As long as no options are present in the IP header,
      the header\n      length is constant with the value five.  If there are options,
      the\n      field could be RACH or STATIC-DEF, but only option-less headers\n
      \     are compressed by ROHCv2 profiles.  The field is therefore\n      classified
      as STATIC-KNOWN.\n   Type Of Service\n      For the type of flows compressed
      by the ROHCv2 profiles, the DSCP\n      (Differentiated Services Code Point)
      and ECN (Explicit Congestion\n      Notification) fields are expected to change
      relatively seldom.\n   Packet Length\n      Information about packet length
      is expected to be provided by the\n      link layer.  The field is therefore
      classified as INFERRED.\n   IPv4 Identification\n      The Identification field
      (IP-ID) is used to identify what\n      fragments constitute a datagram when
      reassembling fragmented\n      datagrams.  The IPv4 specification does not specify
      exactly how\n      this field is to be assigned values, only that each packet
      should\n      get an IP-ID that is unique for the source-destination pair and\n
      \     protocol for the time the datagram (or any of its fragments) could\n      be
      alive in the network.  This means that assignment of IP-ID\n      values can
      be done in various ways, but the expected behaviors\n      have been separated
      into four classes.\n      Sequential\n         In this behavior, the IP-ID is
      expected to increment by one for\n         most packets, but may increment by
      a value larger than one,\n         depending on the behavior of the transmitting
      IPv4 stack.\n      Sequential Swapped\n         When using this behavior, the
      IP-ID behaves as in the\n         Sequential behavior, but the two bytes of
      IP-ID are byte-\n         swapped.  Therefore, the IP-ID can be swapped before\n
      \        compression to make it behave exactly as the Sequential\n         behavior.\n
      \     Random\n         Some IP stacks assign IP-ID values using a pseudo-random
      number\n         generator.  There is thus no correlation between the ID values\n
      \        of subsequent datagrams, and therefore there is no way to\n         predict
      the IP-ID value for the next datagram.  For header\n         compression purposes,
      this means that the IP-ID field needs to\n         be sent uncompressed with
      each datagram, resulting in two extra\n         octets of header.\n      Zero\n
      \        This behavior, although not a legal implementation of IPv4, is\n         sometimes
      seen in existing IPv4 stacks.  When this behavior is\n         used, all IP
      packets have the IP-ID value set to zero.\n   Flags\n      The Reserved flag
      must be set to zero and is therefore classified\n      as STATIC-KNOWN.  The
      Don't Fragment (DF) flag changes rarely and\n      is therefore classified as
      RACH.  Finally, the More Fragments (MF)\n      flag is expected to be zero because
      IP fragments will not be\n      compressed by ROHC and is therefore classified
      as STATIC-KNOWN.\n   Fragment Offset\n      Under the assumption that no fragmentation
      occurs, the fragment\n      offset is always zero and is therefore classified
      as STATIC-KNOWN.\n   Time To Live\n      The Time To Live field is expected
      to be constant during the\n      lifetime of a flow or to alternate between
      a limited number of\n      values due to route changes.\n   Protocol\n      This
      field will have the same value in all packets of a flow and\n      is therefore
      classified as STATIC-DEF.\n   Header Checksum\n      The header checksum protects
      individual hops from processing a\n      corrupted header.  When almost all
      IP header information is\n      compressed away, there is no point in having
      this additional\n      checksum; instead, it can be regenerated at the decompressor
      side.\n      The field is therefore classified as INFERRED.\n   Source and Destination
      addresses\n      These fields are part of the definition of a flow and must
      thus be\n      constant for all packets in the flow.\n"
    title: A.1.  IPv4 Header Fields
  - contents:
    - "A.2.  IPv6 Header Fields\n   +----------------------+----------------+\n   |
      Field                | Class          |\n   +----------------------+----------------+\n
      \  | Version              | STATIC-KNOWN   |\n   | Traffic Class        | RACH
      \          |\n   | Flow Label           | STATIC-DEF     |\n   | Payload Length
      \      | INFERRED       |\n   | Next Header          | STATIC-DEF     |\n   |
      Hop Limit            | RACH           |\n   | Source Address       | STATIC-DEF
      \    |\n   | Destination Address  | STATIC-DEF     |\n   +----------------------+----------------+\n
      \  Version\n      The version field states which IP version is used and is set
      to\n      the value six.\n   Traffic Class\n      For the type of flows compressed
      by the ROHCv2 profiles, the DSCP\n      and ECN fields are expected to change
      relatively seldom.\n   Flow Label\n      This field may be used to identify
      packets belonging to a specific\n      flow.  If it is not used, the value should
      be set to zero.\n      Otherwise, all packets belonging to the same flow must
      have the\n      same value in this field.  The field is therefore classified
      as\n      STATIC-DEF.\n   Payload Length\n      Information about packet length
      (and, consequently, payload\n      length) is expected to be provided by the
      link layer.  The field\n      is therefore classified as INFERRED.\n   Next
      Header\n      This field will have the same value in all packets of a flow and\n
      \     is therefore classified as STATIC-DEF.\n   Hop Limit\n      The Hop Limit
      field is expected to be constant during the lifetime\n      of a flow or to
      alternate between a limited number of values due\n      to route changes.\n
      \  Source and Destination addresses\n      These fields are part of the definition
      of a flow and must thus be\n      constant for all packets in the flow.  The
      fields are therefore\n      classified as STATIC-DEF.\n"
    title: A.2.  IPv6 Header Fields
  - contents:
    - "A.3.  UDP Header Fields\n   +------------------+-------------+\n   | Field
      \           | Class       |\n   +------------------+-------------+\n   | Source
      Port      | STATIC-DEF  |\n   | Destination Port | STATIC-DEF  |\n   | Length
      \          | INFERRED    |\n   | Checksum         |             |\n   |         Disabled
      | STATIC      |\n   |         Enabled  | IRREGULAR   |\n   +------------------+-------------+\n
      \  Source and Destination ports\n      These fields are part of the definition
      of a flow and must thus be\n      constant for all packets in the flow.\n   Length\n
      \     Information about packet length is expected to be provided by the\n      link
      layer.  The field is therefore classified as INFERRED.\n   Checksum\n      The
      checksum can be optional.  If disabled, its value is\n      constantly zero
      and can be compressed away.  If enabled, its value\n      depends on the payload,
      which for compression purposes is\n      equivalent to it changing randomly
      with every packet.\n"
    title: A.3.  UDP Header Fields
  - contents:
    - "A.4.  UDP-Lite Header Fields\n   +--------------------+-------------+\n   |
      Field              | Class       |\n   +--------------------+-------------+\n
      \  | Source Port        | STATIC-DEF  |\n   | Destination Port   | STATIC-DEF
      \ |\n   | Checksum Coverage  |             |\n   |        Zero        | STATIC-DEF
      \ |\n   |        Constant    | INFERRED    |\n   |        Variable    | IRREGULAR
      \  |\n   | Checksum           | IRREGULAR   |\n   +--------------------+-------------+\n
      \  Source and Destination Port\n      These fields are part of the definition
      of a flow and must thus be\n      constant for all packets in the flow.\n   Checksum
      Coverage\n      The Checksum Coverage field may behave in different ways: it
      may\n      have a value of zero, it may be equal to the datagram length, or\n
      \     it may have any value between eight octets and the length of the\n      datagram.
      \ From a compression perspective, this field is expected\n      to either be
      entirely predictable (for the cases where it follows\n      the same behavior
      as the UDP Length field or where it takes on a\n      constant value) or to
      change randomly for each packet (making the\n      value unpredictable from
      a header-compression perspective).  For\n      all cases, the behavior itself
      is not expected to change for this\n      field during the lifetime of a packet
      flow, or to change\n      relatively seldom.\n   Checksum\n      The information
      used for the calculation of the UDP-Lite checksum\n      is governed by the
      value of the checksum coverage and minimally\n      includes the UDP-Lite header.
      \ The checksum is a changing field\n      that must always be sent as-is.\n"
    title: A.4.  UDP-Lite Header Fields
  - contents:
    - "A.5.  RTP Header Fields\n   +----------------+----------------+\n   | Field
      \         | Class          |\n   +----------------+----------------+\n   | Version
      \       | STATIC-KNOWN   |\n   | Padding        | RACH           |\n   | Extension
      \     | RACH           |\n   | CSRC Counter   | RACH           |\n   | Marker
      \        | SEMISTATIC     |\n   | Payload Type   | RACH           |\n   | Sequence
      Number| PATTERN        |\n   | Timestamp      | PATTERN        |\n   | SSRC
      \          | STATIC-DEF     |\n   | CSRC           | RACH           |\n   +----------------+----------------+\n
      \  Version\n      This field is expected to have the value two and the field
      is\n      therefore classified as STATIC-KNOWN.\n   Padding\n      The use of
      this field is application-dependent, but when payload\n      padding is used,
      it is likely to be present in most or all\n      packets.  The field is classified
      as RACH to allow for the case\n      where the value of this field changes.\n
      \  Extension\n      If RTP extensions are used by the application, these extensions\n
      \     are often present in all packets, although the use of extensions\n      is
      infrequent.  To allow efficient compression of a flow using\n      extensions
      in only a few packets, this field is classified as\n      RACH.\n   CSRC Count\n
      \     This field indicates the number of CSRC items present in the CSRC\n      list.
      \ This number is expected to be mostly constant on a packet-\n      to-packet
      basis and when it changes, change by small amounts.  As\n      long as no RTP
      mixer is used, the value of this field will be\n      zero.\n   Marker\n      For
      audio, the marker bit should be set only in the first packet\n      of a talkspurt,
      while for video, it should be set in the last\n      packet of every picture.
      \ This means that in both cases the RTP\n      marker is classified as SEMISTATIC.\n
      \  Payload Type\n      Applications could adapt to congestion by changing payload
      type\n      and/or frame sizes, but that is not expected to happen frequently,\n
      \     so this field is classified as RACH.\n   RTP Sequence Number\n      The
      RTP Sequence Number will be incremented by one for each packet\n      sent.\n
      \  Timestamp\n      In the audio case:\n         As long as there are no pauses
      in the audio stream, the RTP\n         Timestamp will be incremented by a constant
      value, which\n         corresponds to the number of samples in the speech frame.
      \ It\n         will thus mostly follow the RTP Sequence Number.  When there\n
      \        has been a silent period and a new talkspurt begins, the\n         timestamp
      will jump in proportion to the length of the silent\n         period.  However,
      the increment will probably be within a\n         relatively limited range.\n
      \     In the video case:\n         Between two consecutive packets, the timestamp
      will either be\n         unchanged or increase by a multiple of a fixed value\n
      \        corresponding to the picture clock frequency.  The timestamp\n         can
      also decrease by a multiple of the fixed value for certain\n         coding
      schemes.  The change in timestamp value, expressed as a\n         multiple of
      the picture clock frequency, is in most cases\n         within a limited range.\n
      \  SSRC\n      This field is part of the definition of a flow and must thus
      be\n      constant for all packets in the flow.  The field is therefore\n      classified
      as STATIC-DEF.\n   Contributing Sources (CSRC)\n      The participants in a
      session, who are identified by the CSRC\n      fields, are usually expected
      to be unchanged on a packet-to-packet\n      basis, but will infrequently change
      by a few additions and/or\n      removals.\n"
    title: A.5.  RTP Header Fields
  - contents:
    - "A.6.  ESP Header Fields\n   +------------------+-------------+\n   | Field
      \           | Class       |\n   +------------------+-------------+\n   | SPI
      \             | STATIC-DEF  |\n   | Sequence Number  | PATTERN     |\n   +------------------+-------------+\n
      \  SPI\n      This field is used to identify a distinct flow between two IPsec\n
      \     peers and it changes rarely; therefore, it is classified as\n      STATIC-DEF.\n
      \  ESP Sequence Number\n      The ESP Sequence Number will be incremented by
      one for each packet\n      sent.\n"
    title: A.6.  ESP Header Fields
  - contents:
    - "A.7.  IPv6 Extension Header Fields\n   +-----------------------+---------------+\n
      \  | Field                 | Class         |\n   +-----------------------+---------------+\n
      \  | Next Header           | STATIC-DEF    |\n   | Ext Hdr Len           |               |\n
      \  |      Routing          | STATIC-DEF    |\n   |      Hop-by-hop       | STATIC
      \       |\n   |      Destination      | STATIC        |\n   | Options               |
      \              |\n   |      Routing          | STATIC-DEF    |\n   |      Hop-by-hop
      \      | RACH          |\n   |      Destination      | RACH          |\n   +-----------------------+---------------+\n
      \  Next Header\n      This field will have the same value in all packets of
      a flow and\n      is therefore classified as STATIC-DEF.\n   Ext Hdr Len\n      For
      the Routing header, it is expected that the length will remain\n      constant
      for the duration of the flow, and that a change in the\n      length should
      be classified as a new flow by the ROHC compressor.\n      For Hop-by-hop and
      Destination options headers, the length is\n      expected to remain static,
      but can be updated by an IR packet.\n   Options\n      For the Routing header,
      it is expected that the option content\n      will remain constant for the duration
      of the flow, and that a\n      change in the routing information should be classified
      as a new\n      flow by the ROHC compressor.  For Hop-by-hop and Destination\n
      \     options headers, the options are expected to remain static, but\n      can
      be updated by an IR packet.\n"
    title: A.7.  IPv6 Extension Header Fields
  - contents:
    - "A.8.  GRE Header Fields\n   +--------------------+---------------+\n   | Field
      \             | Class         |\n   +--------------------+---------------+\n
      \  | C flag             | STATIC        |\n   | K flag             | STATIC
      \       |\n   | S flag             | STATIC        |\n   | R flag             |
      STATIC-KNOWN  |\n   | Reserved0, Version | STATIC-KNOWN  |\n   | Protocol           |
      STATIC-DEF    |\n   | Checksum           | IRREGULAR     |\n   | Reserved           |
      STATIC-KNOWN  |\n   | Sequence Number    | PATTERN       |\n   | Key                |
      STATIC-DEF    |\n   +--------------------+---------------+\n   Flags\n      The
      four flag bits are not expected to change for the duration of\n      the flow,
      and the R flag is expected to always be set to zero.\n   Reserved0, Version\n
      \     Both of these fields are expected to be set to zero for the\n      duration
      of any flow.\n   Protocol\n      This field will have the same value in all
      packets of a flow and\n      is therefore classified as STATIC-DEF.\n   Checksum\n
      \     When the checksum field is present, it is expected to behave\n      unpredictably.\n
      \  Reserved\n      When present, this field is expected to be set to zero.\n
      \  Sequence Number\n      When present, the Sequence Number increases by one
      for each\n      packet.\n   Key\n      When present, the Key field is used to
      define the flow and does\n      not change.\n"
    title: A.8.  GRE Header Fields
  - contents:
    - "A.9.  MINE Header Fields\n   +---------------------+----------------+\n   |
      Field               | Class          |\n   +---------------------+----------------+\n
      \  | Protocol            | STATIC-DEF     |\n   | S bit               | STATIC-DEF
      \    |\n   | Reserved            | STATIC-KNOWN   |\n   | Checksum            |
      INFERRED       |\n   | Source Address      | STATIC-DEF     |\n   | Destination
      Address | STATIC-DEF     |\n   +---------------------+----------------+\n   Protocol\n
      \     This field will have the same value in all packets of a flow and\n      is
      therefore classified as STATIC-DEF.\n   S bit\n      The S bit is not expected
      to change during a flow.\n   Reserved\n      The reserved field is expected
      to be set to zero.\n   Checksum\n      The header checksum protects individual
      routing hops from\n      processing a corrupted header.  Since all fields of
      this header\n      are compressed away, there is no need to include this checksum
      in\n      compressed packets and it can be regenerated at the decompressor\n
      \     side.\n   Source and Destination Addresses\n      These fields can be
      used to define the flow and are not expected\n      to change.\n"
    title: A.9.  MINE Header Fields
  - contents:
    - "A.10.  AH Header Fields\n   +---------------------+----------------+\n   |
      Field               | Class          |\n   +---------------------+----------------+\n
      \  | Next Header         | STATIC-DEF     |\n   | Payload Length      | STATIC
      \        |\n   | Reserved            | STATIC-KNOWN   |\n   | SPI                 |
      STATIC-DEF     |\n   | Sequence Number     | PATTERN        |\n   | ICV                 |
      IRREGULAR      |\n   +---------------------+----------------+\n   Next Header\n
      \     This field will have the same value in all packets of a flow and\n      is
      therefore classified as STATIC-DEF.\n   Payload Length\n      It is expected
      that the length of the header is constant for the\n      duration of the flow.\n
      \  Reserved\n      The value of this field will be set to zero.\n   SPI\n      This
      field is used to identify a specific flow and only changes\n      when the sequence
      number wraps around, and is therefore classified\n      as STATIC-DEF.\n   Sequence
      Number\n      The Sequence Number will be incremented by one for each packet\n
      \     sent.\n   ICV\n      The ICV is expected to behave unpredictably and is
      therefore\n      classified as IRREGULAR.\n"
    title: A.10.  AH Header Fields
  title: Appendix A.  Detailed Classification of Header Fields
- contents:
  - "Appendix B.  Compressor Implementation Guidelines\n   This section describes
    some guiding principles for implementing a\n   ROHCv2 compressor with focus on
    how to efficiently select appropriate\n   packet formats.  The text in this appendix
    should be considered\n   guidelines; it does not define any normative requirement
    on how\n   ROHCv2 profiles are implemented.\n"
  - contents:
    - "B.1.  Reference Management\n   The compressor usually maintains a sliding window
      of reference\n   headers, which contains as many references as needed for the\n
      \  optimistic approach.  Each reference contains a description of which\n   changes
      occurred in the flow between two consecutive headers in the\n   flow, and a
      new reference is inserted into the window each time a\n   packet is compressed
      by this context.  A reference may for example be\n   implemented as a stored
      copy of the uncompressed header being\n   represented.  When the compressor
      is confident that a specific\n   reference is no longer used by the decompressor
      (for example by using\n   the optimistic approach or feedback received), the
      reference is\n   removed from the sliding window.\n"
    title: B.1.  Reference Management
  - contents:
    - "B.2.  Window-based LSB Encoding (W-LSB)\n   Section 5.1.1 describes how the
      optimistic approach impacts the\n   packet format selection for the compressor.
      \ Exactly how the\n   compressor selects a packet format is up to the implementation
      to\n   decide, but the following is an example of how this process can be\n
      \  performed for lsb-encoded fields through the use of Window-based LSB\n   encoding
      (W-LSB).\n   With W-LSB encoding, the compressor uses a number of references
      (a\n   window) from its context.  What references to use is determined by\n
      \  its optimistic approach.  The compressor extracts the value of the\n   field
      to be W-LSB encoded from each reference in the window, and\n   finds the maximum
      and minimum values.  Once it determines these\n   values, the compressor uses
      the assumption that the decompressor has\n   a value for this field within the
      range given by these boundaries\n   (inclusively) as its reference.  The compressor
      can then select a\n   number of LSBs from the value to be compressed, so that
      the LSBs can\n   be decompressed regardless of whether the decompressor uses
      the\n   minimum value, the maximum value or any other value in the range of\n
      \  possible references.\n"
    title: B.2.  Window-based LSB Encoding (W-LSB)
  - contents:
    - "B.3.  W-LSB Encoding and Timer-based Compression\n   Section 6.6.9 defines
      decompressor behavior for timer-based RTP\n   timestamp compression.  This section
      gives guidelines on how the\n   compressor should determine the number of LSB
      bits it should send for\n   the timestamp field.  When using timer-based compression,
      this number\n   depends on the sum of the jitter before the compressor and the
      jitter\n   between the compressor and decompressor.\n   The jitter before the
      compressor can be estimated using the following\n   computation:\n       Max_Jitter_BC
      =\n            max {|(T_n - T_j) - ((a_n - a_j) / time_stride)|,\n               for
      all headers j in the sliding window}\n   where (T_n - T_j) is the difference
      in the timestamp between the\n   currently compressed header and a reference
      header and (a_n - a_j) is\n   the difference in arrival time between those same
      two headers.\n   In addition to this, the compressor needs to estimate an upper
      bound\n   for the jitter between the compressor and decompressor\n   (Max_Jitter_CD).
      \ This information may for example come from lower\n   layers.\n   A compressor
      implementation can determine whether the difference in\n   clock resolution
      between the compressor and decompressor induces an\n   error when performing
      integer arithmetics; it can then treat this\n   error as additional jitter.\n
      \  After obtaining estimates for the jitters, the number of bits needed\n   to
      transmit is obtained using the following calculation:\n       ceiling(log2(2
      * (Max_Jitter_BC + Max_Jitter_CD + 2) + 1))\n   This number is then used to
      select a packet format that contains at\n   least this many scaled timestamp
      bits.\n"
    title: B.3.  W-LSB Encoding and Timer-based Compression
  title: Appendix B.  Compressor Implementation Guidelines
- contents:
  - "Authors' Addresses\n   Ghyslain Pelletier\n   Ericsson\n   Box 920\n   Lulea
    \ SE-971 28\n   Sweden\n   Phone: +46 (0) 8 404 29 43\n   EMail: ghyslain.pelletier@ericsson.com\n
    \  Kristofer Sandlund\n   Ericsson\n   Box 920\n   Lulea  SE-971 28\n   Sweden\n
    \  Phone: +46 (0) 8 404 41 58\n   EMail: kristofer.sandlund@ericsson.com\n"
  title: Authors' Addresses
- contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2008).\n   This document
    is subject to the rights, licenses and restrictions\n   contained in BCP 78, and
    except as set forth therein, the authors\n   retain all their rights.\n   This
    document and the information contained herein are provided on an\n   \"AS IS\"
    basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE INTERNET ENGINEERING
    TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT
    LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION HEREIN WILL NOT INFRINGE
    ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the procedures with respect to
    rights in RFC documents can be\n   found in BCP 78 and BCP 79.\n   Copies of IPR
    disclosures made to the IETF Secretariat and any\n   assurances of licenses to
    be made available, or the result of an\n   attempt made to obtain a general license
    or permission for the use of\n   such proprietary rights by implementers or users
    of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at\n   ietf-ipr@ietf.org.\n"
  title: Intellectual Property
