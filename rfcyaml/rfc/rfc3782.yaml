- title: __initial_text__
  contents:
  - '       The NewReno Modification to TCP''s Fast Recovery Algorithm

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2004).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   The purpose of this document is to advance NewReno TCP's  Fast\n\
    \   Retransmit and Fast Recovery algorithms in RFC 2582 from Experimental\n  \
    \ to Standards Track status.\n   The main change in this document relative to\
    \ RFC 2582 is to specify\n   the Careful variant of NewReno's Fast Retransmit\
    \ and Fast Recovery\n   algorithms.  The base algorithm described in RFC 2582\
    \ did not attempt\n   to avoid unnecessary multiple Fast Retransmits that can\
    \ occur after a\n   timeout.  However, RFC 2582 also defined \"Careful\" and \"\
    Less Careful\"\n   variants that avoid these unnecessary Fast Retransmits, and\n\
    \   recommended the Careful variant.  This document specifies the\n   previously-named\
    \ \"Careful\" variant as the basic version of NewReno\n   TCP.\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   For the typical implementation of the TCP Fast Recovery\
    \ algorithm\n   described in [RFC2581] (first implemented in the 1990 BSD Reno\n\
    \   release, and referred to as the Reno algorithm in [FF96]), the TCP\n   data\
    \ sender only retransmits a packet after a retransmit timeout has\n   occurred,\
    \ or after three duplicate acknowledgements have arrived\n   triggering the Fast\
    \ Retransmit algorithm.  A single retransmit\n   timeout might result in the retransmission\
    \ of several data packets,\n   but each invocation of the Fast Retransmit algorithm\
    \ in RFC 2581\n   leads to the retransmission of only a single data packet.\n\
    \   Problems can arise, therefore, when multiple packets are dropped from\n  \
    \ a single window of data and the Fast Retransmit and Fast Recovery\n   algorithms\
    \ are invoked.  In this case, if the SACK option is\n   available, the TCP sender\
    \ has the information to make intelligent\n   decisions about which packets to\
    \ retransmit and which packets not to\n   retransmit during Fast Recovery.  This\
    \ document applies only for TCP\n   connections that are unable to use the TCP\
    \ Selective Acknowledgement\n   (SACK) option, either because the option is not\
    \ locally supported or\n   because the TCP peer did not indicate a willingness\
    \ to use SACK.\n   In the absence of SACK, there is little information available\
    \ to the\n   TCP sender in making retransmission decisions during Fast Recovery.\n\
    \   From the three duplicate acknowledgements, the sender infers a packet\n  \
    \ loss, and retransmits the indicated packet.  After this, the data\n   sender\
    \ could receive additional duplicate acknowledgements, as the\n   data receiver\
    \ acknowledges additional data packets that were already\n   in flight when the\
    \ sender entered Fast Retransmit.\n   In the case of multiple packets dropped\
    \ from a single window of data,\n   the first new information available to the\
    \ sender comes when the\n   sender receives an acknowledgement for the retransmitted\
    \ packet (that\n   is, the packet retransmitted when Fast Retransmit was first\
    \ entered).\n   If there is a single packet drop and no reordering, then the\n\
    \   acknowledgement for this packet will acknowledge all of the packets\n   transmitted\
    \ before Fast Retransmit was entered.  However, if there\n   are multiple packet\
    \ drops, then the acknowledgement for the\n   retransmitted packet will acknowledge\
    \ some but not all of the packets\n   transmitted before the Fast Retransmit.\
    \  We call this acknowledgement\n   a partial acknowledgment.\n   Along with several\
    \ other suggestions, [Hoe95] suggested that during\n   Fast Recovery the TCP data\
    \ sender responds to a partial\n   acknowledgment by inferring that the next in-sequence\
    \ packet has been\n   lost, and retransmitting that packet.  This document describes\
    \ a\n   modification to the Fast Recovery algorithm in RFC 2581 that\n   incorporates\
    \ a response to partial acknowledgements received during\n   Fast Recovery.  We\
    \ call this modified Fast Recovery algorithm\n   NewReno, because it is a slight\
    \ but significant variation of the\n   basic Reno algorithm in RFC 2581.  This\
    \ document does not discuss the\n   other suggestions in [Hoe95] and [Hoe96],\
    \ such as a change to the\n   ssthresh parameter during Slow-Start, or the proposal\
    \ to send a new\n   packet for every two duplicate acknowledgements during Fast\
    \ Recovery.\n   The version of NewReno in this document also draws on other\n\
    \   discussions of NewReno in the literature [LM97, Hen98].\n   We do not claim\
    \ that the NewReno version of Fast Recovery described\n   here is an optimal modification\
    \ of Fast Recovery for responding to\n   partial acknowledgements, for TCP connections\
    \ that are unable to use\n   SACK.  Based on our experiences with the NewReno\
    \ modification in the\n   NS simulator [NS] and with numerous implementations\
    \ of NewReno, we\n   believe that this modification improves the performance of\
    \ the Fast\n   Retransmit and Fast Recovery algorithms in a wide variety of\n\
    \   scenarios.\n"
- title: 2.  Terminology and Definitions
  contents:
  - "2.  Terminology and Definitions\n   In this document, the key words \"MUST\"\
    , \"MUST NOT\", \"REQUIRED\",\n   \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD\
    \ NOT\", \"RECOMMENDED\", \"MAY\",\n   and \"OPTIONAL\" are to be interpreted\
    \ as described in BCP 14, RFC 2119\n   [RFC2119].  This RFC indicates requirement\
    \ levels for compliant TCP\n   implementations implementing the NewReno Fast Retransmit\
    \ and Fast\n   Recovery algorithms described in this document.\n   This document\
    \ assumes that the reader is familiar with the terms\n   SENDER MAXIMUM SEGMENT\
    \ SIZE (SMSS), CONGESTION WINDOW (cwnd), and\n   FLIGHT SIZE (FlightSize) defined\
    \ in [RFC2581].  FLIGHT SIZE is\n   defined as in [RFC2581] as follows:\n    \
    \  FLIGHT SIZE:\n         The amount of data that has been sent but not yet acknowledged.\n"
- title: 3.  The Fast Retransmit and Fast Recovery Algorithms in NewReno
  contents:
  - "3.  The Fast Retransmit and Fast Recovery Algorithms in NewReno\n   The standard\
    \ implementation of the Fast Retransmit and Fast Recovery\n   algorithms is given\
    \ in [RFC2581].  This section specifies the basic\n   NewReno algorithm.  Sections\
    \ 4 through 6 describe some optional\n   variants, and the motivations behind\
    \ them, that an implementor may\n   want to consider when tuning performance for\
    \ certain network\n   scenarios.  Sections 7 and 8 provide some guidance to implementors\n\
    \   based on experience with NewReno implementations.\n   The NewReno modification\
    \ concerns the Fast Recovery procedure that\n   begins when three duplicate ACKs\
    \ are received and ends when either a\n   retransmission timeout occurs or an\
    \ ACK arrives that acknowledges all\n   of the data up to and including the data\
    \ that was outstanding when\n   the Fast Recovery procedure began.\n   The NewReno\
    \ algorithm specified in this document differs from the\n   implementation in\
    \ [RFC2581] in the introduction of the variable\n   \"recover\" in step 1, in\
    \ the response to a partial or new\n   acknowledgement in step 5, and in modifications\
    \ to step 1 and the\n   addition of step 6 for avoiding multiple Fast Retransmits\
    \ caused by\n   the retransmission of packets already received by the receiver.\n\
    \   The algorithm specified in this document uses a variable \"recover\",\n  \
    \ whose initial value is the initial send sequence number.\n   1)  Three duplicate\
    \ ACKs:\n       When the third duplicate ACK is received and the sender is not\n\
    \       already in the Fast Recovery procedure, check to see if the\n       Cumulative\
    \ Acknowledgement field covers more than \"recover\".  If\n       so, go to Step\
    \ 1A.  Otherwise, go to Step 1B.\n   1A) Invoking Fast Retransmit:\n       If\
    \ so, then set ssthresh to no more than the value given in\n       equation 1\
    \ below.  (This is equation 3 from [RFC2581]).\n         ssthresh = max (FlightSize\
    \ / 2, 2*SMSS)           (1)\n       In addition, record the highest sequence\
    \ number transmitted in\n       the variable \"recover\", and go to Step 2.\n\
    \   1B) Not invoking Fast Retransmit:\n       Do not enter the Fast Retransmit\
    \ and Fast Recovery procedure.  In\n       particular, do not change ssthresh,\
    \ do not go to Step 2 to\n       retransmit the \"lost\" segment, and do not execute\
    \ Step 3 upon\n       subsequent duplicate ACKs.\n   2)  Entering Fast Retransmit:\n\
    \       Retransmit the lost segment and set cwnd to ssthresh plus 3*SMSS.\n  \
    \     This artificially \"inflates\" the congestion window by the number\n   \
    \    of segments (three) that have left the network and the receiver\n       has\
    \ buffered.\n   3)  Fast Recovery:\n       For each additional duplicate ACK received\
    \ while in Fast\n       Recovery, increment cwnd by SMSS.  This artificially inflates\
    \ the\n       congestion window in order to reflect the additional segment that\n\
    \       has left the network.\n   4)  Fast Recovery, continued:\n       Transmit\
    \ a segment, if allowed by the new value of cwnd and the\n       receiver's advertised\
    \ window.\n   5)  When an ACK arrives that acknowledges new data, this ACK could\
    \ be\n       the acknowledgment elicited by the retransmission from step 2, or\n\
    \       elicited by a later retransmission.\n       Full acknowledgements:\n \
    \      If this ACK acknowledges all of the data up to and including\n       \"\
    recover\", then the ACK acknowledges all the intermediate\n       segments sent\
    \ between the original transmission of the lost\n       segment and the receipt\
    \ of the third duplicate ACK.  Set cwnd to\n       either (1) min (ssthresh, FlightSize\
    \ + SMSS) or (2) ssthresh,\n       where ssthresh is the value set in step 1;\
    \ this is termed\n       \"deflating\" the window.  (We note that \"FlightSize\"\
    \ in step 1\n       referred to the amount of data outstanding in step 1, when\
    \ Fast\n       Recovery was entered, while \"FlightSize\" in step 5 refers to\
    \ the\n       amount of data outstanding in step 5, when Fast Recovery is\n  \
    \     exited.)  If the second option is selected, the implementation is\n    \
    \   encouraged to take measures to avoid a possible burst of data, in\n      \
    \ case the amount of data outstanding in the network is much less\n       than\
    \ the new congestion window allows.  A simple mechanism is to\n       limit the\
    \ number of data packets that can be sent in response to\n       a single acknowledgement;\
    \ this is known as \"maxburst_\" in the NS\n       simulator.  Exit the Fast Recovery\
    \ procedure.\n       Partial acknowledgements:\n       If this ACK does *not*\
    \ acknowledge all of the data up to and\n       including \"recover\", then this\
    \ is a partial ACK.  In this case,\n       retransmit the first unacknowledged\
    \ segment.  Deflate the\n       congestion window by the amount of new data acknowledged\
    \ by the\n       cumulative acknowledgement field.  If the partial ACK\n     \
    \  acknowledges at least one SMSS of new data, then add back SMSS\n       bytes\
    \ to the congestion window.  As in Step 3, this artificially\n       inflates\
    \ the congestion window in order to reflect the additional\n       segment that\
    \ has left the network.  Send a new segment if\n       permitted by the new value\
    \ of cwnd.  This \"partial window\n       deflation\" attempts to ensure that,\
    \ when Fast Recovery eventually\n       ends, approximately ssthresh amount of\
    \ data will be outstanding\n       in the network.  Do not exit the Fast Recovery\
    \ procedure (i.e.,\n       if any duplicate ACKs subsequently arrive, execute\
    \ Steps 3 and 4\n       above).\n       For the first partial ACK that arrives\
    \ during Fast Recovery, also\n       reset the retransmit timer.  Timer management\
    \ is discussed in\n       more detail in Section 4.\n   6)  Retransmit timeouts:\n\
    \       After a retransmit timeout, record the highest sequence number\n     \
    \  transmitted in the variable \"recover\" and exit the Fast Recovery\n      \
    \ procedure if applicable.\n   Step 1 specifies a check that the Cumulative Acknowledgement\
    \ field\n   covers more than \"recover\".  Because the acknowledgement field\n\
    \   contains the sequence number that the sender next expects to receive,\n  \
    \ the acknowledgement \"ack_number\" covers more than \"recover\" when:\n    \
    \  ack_number - 1 > recover;\n   i.e., at least one byte more of data is acknowledged\
    \ beyond the\n   highest byte that was outstanding when Fast Retransmit was last\n\
    \   entered.\n   Note that in Step 5, the congestion window is deflated after\
    \ a\n   partial acknowledgement is received.  The congestion window was\n   likely\
    \ to have been inflated considerably when the partial\n   acknowledgement was\
    \ received.  In addition, depending on the original\n   pattern of packet losses,\
    \ the partial acknowledgement might\n   acknowledge nearly a window of data. \
    \ In this case, if the congestion\n   window was not deflated, the data sender\
    \ might be able to send nearly\n   a window of data back-to-back.\n   This document\
    \ does not specify the sender's response to duplicate\n   ACKs when the Fast Retransmit/Fast\
    \ Recovery algorithm is not invoked.\n   This is addressed in other documents,\
    \ such as those describing the\n   Limited Transmit procedure [RFC3042].  This\
    \ document also does not\n   address issues of adjusting the duplicate acknowledgement\
    \ threshold,\n   but assumes the threshold specified in the IETF standards; the\n\
    \   current standard is RFC 2581, which specifies a threshold of three\n   duplicate\
    \ acknowledgements.\n   As a final note, we would observe that in the absence\
    \ of the SACK\n   option, the data sender is working from limited information.\
    \  When\n   the issue of recovery from multiple dropped packets from a single\n\
    \   window of data is of particular importance, the best alternative\n   would\
    \ be to use the SACK option.\n"
- title: 4.  Resetting the Retransmit Timer in Response to Partial
  contents:
  - "4.  Resetting the Retransmit Timer in Response to Partial\n    Acknowledgements\n\
    \   One possible variant to the response to partial acknowledgements\n   specified\
    \ in Section 3 concerns when to reset the retransmit timer\n   after a partial\
    \ acknowledgement.  The algorithm in Section 3, Step 5,\n   resets the retransmit\
    \ timer only after the first partial ACK.  In\n   this case, if a large number\
    \ of packets were dropped from a window of\n   data, the TCP data sender's retransmit\
    \ timer will ultimately expire,\n   and the TCP data sender will invoke Slow-Start.\
    \  (This is illustrated\n   on page 12 of [F98].)  We call this the Impatient\
    \ variant of NewReno.\n   We note that the Impatient variant in Section 3 doesn't\
    \ follow the\n   recommended algorithm in RFC 2988 of restarting the retransmit\
    \ timer\n   after every packet transmission or retransmission [RFC2988, Step\n\
    \   5.1].\n   In contrast, the NewReno simulations in [FF96] illustrate the\n\
    \   algorithm described above with the modification that the retransmit\n   timer\
    \ is reset after each partial acknowledgement.  We call this the\n   Slow-but-Steady\
    \ variant of NewReno.  In this case, for a window with\n   a large number of packet\
    \ drops, the TCP data sender retransmits at\n   most one packet per roundtrip\
    \ time.  (This behavior is illustrated in\n   the New-Reno TCP simulation of Figure\
    \ 5 in [FF96], and on page 11 of\n   [F98]).\n   When N packets have been dropped\
    \ from a window of data for a large\n   value of N, the Slow-but-Steady variant\
    \ can remain in Fast Recovery\n   for N round-trip times, retransmitting one more\
    \ dropped packet each\n   round-trip time; for these scenarios, the Impatient\
    \ variant gives a\n   faster recovery and better performance.  The tests \"ns\
    \ test-suite-\n   newreno.tcl impatient1\" and \"ns test-suite-newreno.tcl slow1\"\
    \ in the\n   NS simulator illustrate such a scenario, where the Impatient variant\n\
    \   performs better than the Slow-but-Steady variant.  The Impatient\n   variant\
    \ can be particularly important for TCP connections with large\n   congestion\
    \ windows, as illustrated by the tests \"ns test-suite-\n   newreno.tcl impatient4\"\
    \ and \"ns test-suite-newreno.tcl slow4\" in the\n   NS simulator.\n   One can\
    \ also construct scenarios where the Slow-but-Steady variant\n   gives better\
    \ performance than the Impatient variant.  As an example,\n   this occurs when\
    \ only a small number of packets are dropped, the RTO\n   is sufficiently small\
    \ that the retransmit timer expires, and\n   performance would have been better\
    \ without a retransmit timeout.  The\n   tests \"ns test-suite-newreno.tcl impatient2\"\
    \ and \"ns test-suite-\n   newreno.tcl slow2\" in the NS simulator illustrate\
    \ such a scenario.\n   The Slow-but-Steady variant can also achieve higher goodput\
    \ than the\n   Impatient variant, by avoiding unnecessary retransmissions.  This\n\
    \   could be of special interest for cellular links, where every\n   transmission\
    \ costs battery power and money.  The tests \"ns test-\n   suite-newreno.tcl impatient3\"\
    \ and \"ns test-suite-newreno.tcl slow3\"\n   in the NS simulator illustrate such\
    \ a scenario.  The Slow-but-Steady\n   variant can also be more robust to delay\
    \ variation in the network,\n   where a delay spike might force the Impatient\
    \ variant into a timeout\n   and go-back-N recovery.\n   Neither of the two variants\
    \ discussed above are optimal.  Our\n   recommendation is for the Impatient variant,\
    \ as specified in Section\n   3 of this document, because of the poor performance\
    \ of the Slow-but-\n   Steady variant for TCP connections with large congestion\
    \ windows.\n   One possibility for a more optimal algorithm would be one that\n\
    \   recovered from multiple packet drops as quickly as does slow-start,\n   while\
    \ resetting the retransmit timers after each partial\n   acknowledgement, as described\
    \ in the section below.  We note,\n   however, that there is a limitation to the\
    \ potential performance in\n   this case in the absence of the SACK option.\n"
- title: 5.  Retransmissions after a Partial Acknowledgement
  contents:
  - "5.  Retransmissions after a Partial Acknowledgement\n   One possible variant\
    \ to the response to partial acknowledgements\n   specified in Section 3 would\
    \ be to retransmit more than one packet\n   after each partial acknowledgement,\
    \ and to reset the retransmit timer\n   after each retransmission.  The algorithm\
    \ specified in Section 3\n   retransmits a single packet after each partial acknowledgement.\
    \  This\n   is the most conservative alternative, in that it is the least likely\n\
    \   to result in an unnecessarily-retransmitted packet.  A variant that\n   would\
    \ recover faster from a window with many packet drops would be to\n   effectively\
    \ Slow-Start, retransmitting two packets after each partial\n   acknowledgement.\
    \  Such an approach would take less than N roundtrip\n   times to recover from\
    \ N losses [Hoe96].  However, in the absence of\n   SACK, recovering as quickly\
    \ as slow-start introduces the likelihood\n   of unnecessarily retransmitting\
    \ packets, and this could significantly\n   complicate the recovery mechanisms.\n\
    \   We note that the response to partial acknowledgements specified in\n   Section\
    \ 3 of this document and in RFC 2582 differs from the response\n   in [FF96],\
    \ even though both approaches only retransmit one packet in\n   response to a\
    \ partial acknowledgement.  Step 5 of Section 3 specifies\n   that the TCP sender\
    \ responds to a partial ACK by deflating the\n   congestion window by the amount\
    \ of new data acknowledged, adding back\n   SMSS bytes if the partial ACK acknowledges\
    \ at least SMSS bytes of new\n   data, and sending a new segment if permitted\
    \ by the new value of\n   cwnd.  Thus, only one previously-sent packet is retransmitted\
    \ in\n   response to each partial acknowledgement, but additional new packets\n\
    \   might be transmitted as well, depending on the amount of new data\n   acknowledged\
    \ by the partial acknowledgement.  In contrast, the\n   variant of NewReno illustrated\
    \ in [FF96] simply set the congestion\n   window to ssthresh when a partial acknowledgement\
    \ was received.  The\n   approach in [FF96] is more conservative, and does not\
    \ attempt to\n   accurately track the actual number of outstanding packets after\
    \ a\n   partial acknowledgement is received.  While either of these\n   approaches\
    \ gives acceptable performance, the variant specified in\n   Section 3 recovers\
    \ more smoothly when multiple packets are dropped\n   from a window of data. \
    \ (The [FF96] behavior can be seen in the NS\n   simulator by setting the variable\
    \ \"partial_window_deflation_\" for\n   \"Agent/TCP/Newreno\" to 0; the behavior\
    \ specified in Section 3 is\n   achieved by setting \"partial_window_deflation_\"\
    \ to 1.)\n"
- title: 6.  Avoiding Multiple Fast Retransmits
  contents:
  - "6.  Avoiding Multiple Fast Retransmits\n   This section describes the motivation\
    \ for the sender's state variable\n   \"recover\", and discusses possible heuristics\
    \ for distinguishing\n   between a retransmitted packet that was dropped, and\
    \ three duplicate\n   acknowledgements from the unnecessary retransmission of\
    \ three\n   packets.\n   In the absence of the SACK option or timestamps, a duplicate\n\
    \   acknowledgement carries no information to identify the data packet or\n  \
    \ packets at the TCP data receiver that triggered that duplicate\n   acknowledgement.\
    \  In this case, the TCP data sender is unable to\n   distinguish between a duplicate\
    \ acknowledgement that results from a\n   lost or delayed data packet, and a duplicate\
    \ acknowledgement that\n   results from the sender's unnecessary retransmission\
    \ of a data packet\n   that had already been received at the TCP data receiver.\
    \  Because of\n   this, with the Retransmit and Fast Recovery algorithms in Reno\
    \ TCP,\n   multiple segment losses from a single window of data can sometimes\n\
    \   result in unnecessary multiple Fast Retransmits (and multiple\n   reductions\
    \ of the congestion window) [F94].\n   With the Fast Retransmit and Fast Recovery\
    \ algorithms in Reno TCP,\n   the performance problems caused by multiple Fast\
    \ Retransmits are\n   relatively minor compared to the potential problems with\
    \ Tahoe TCP,\n   which does not implement Fast Recovery.  Nevertheless, unnecessary\n\
    \   Fast Retransmits can occur with Reno TCP unless some explicit\n   mechanism\
    \ is added to avoid this, such as the use of the \"recover\"\n   variable.  (This\
    \ modification is called \"bugfix\" in [F98], and is\n   illustrated on pages\
    \ 7 and 9 of that document.  Unnecessary Fast\n   Retransmits for Reno without\
    \ \"bugfix\" is illustrated on page 6 of\n   [F98].)\n   Section 3 of [RFC2582]\
    \ defined a default variant of NewReno TCP that\n   did not use the variable \"\
    recover\", and did not check if duplicate\n   ACKs cover the variable \"recover\"\
    \ before invoking Fast Retransmit.\n   With this default variant from RFC 2582,\
    \ the problem of multiple Fast\n   Retransmits from a single window of data can\
    \ occur after a Retransmit\n   Timeout (as in page 8 of [F98]) or in scenarios\
    \ with reordering (as\n   in the validation test \"./test-all-newreno newreno5_noBF\"\
    \ in\n   directory \"tcl/test\" of the NS simulator.  This gives performance\n\
    \   similar to that on page 8 of [F03].)  RFC 2582 also defined Careful\n   and\
    \ Less Careful variants of the NewReno algorithm, and recommended\n   the Careful\
    \ variant.\n   The algorithm specified in Section 3 of this document corresponds\
    \ to\n   the Careful variant of NewReno TCP from RFC 2582, and eliminates the\n\
    \   problem of multiple Fast Retransmits.  This algorithm uses the\n   variable\
    \ \"recover\", whose initial value is the initial send sequence\n   number.  After\
    \ each retransmit timeout, the highest sequence number\n   transmitted so far\
    \ is recorded in the variable \"recover\".\n   If, after a retransmit timeout,\
    \ the TCP data sender retransmits three\n   consecutive packets that have already\
    \ been received by the data\n   receiver, then the TCP data sender will receive\
    \ three duplicate\n   acknowledgements that do not cover more than \"recover\"\
    .  In this\n   case, the duplicate acknowledgements are not an indication of a\
    \ new\n   instance of congestion.  They are simply an indication that the\n  \
    \ sender has unnecessarily retransmitted at least three packets.\n   However,\
    \ when a retransmitted packet is itself dropped, the sender\n   can also receive\
    \ three duplicate acknowledgements that do not cover\n   more than \"recover\"\
    .  In this case, the sender would have been better\n   off if it had initiated\
    \ Fast Retransmit.  For a TCP that implements\n   the algorithm specified in Section\
    \ 3 of this document, the sender\n   does not infer a packet drop from duplicate\
    \ acknowledgements in this\n   scenario.  As always, the retransmit timer is the\
    \ backup mechanism\n   for inferring packet loss in this case.\n   There are several\
    \ heuristics, based on timestamps or on the amount of\n   advancement of the cumulative\
    \ acknowledgement field, that allow the\n   sender to distinguish, in some cases,\
    \ between three duplicate\n   acknowledgements following a retransmitted packet\
    \ that was dropped,\n   and three duplicate acknowledgements from the unnecessary\n\
    \   retransmission of three packets [Gur03, GF04].  The TCP sender MAY\n   use\
    \ such a heuristic to decide to invoke a Fast Retransmit in some\n   cases, even\
    \ when the three duplicate acknowledgements do not cover\n   more than \"recover\"\
    .\n   For example, when three duplicate acknowledgements are caused by the\n \
    \  unnecessary retransmission of three packets, this is likely to be\n   accompanied\
    \ by the cumulative acknowledgement field advancing by at\n   least four segments.\
    \  Similarly, a heuristic based on timestamps uses\n   the fact that when there\
    \ is a hole in the sequence space, the\n   timestamp echoed in the duplicate acknowledgement\
    \ is the timestamp of\n   the most recent data packet that advanced the cumulative\n\
    \   acknowledgement field [RFC1323].  If timestamps are used, and the\n   sender\
    \ stores the timestamp of the last acknowledged segment, then\n   the timestamp\
    \ echoed by duplicate acknowledgements can be used to\n   distinguish between\
    \ a retransmitted packet that was dropped and three\n   duplicate acknowledgements\
    \ from the unnecessary retransmission of\n   three packets.  The heuristics are\
    \ illustrated in the NS simulator in\n   the validation test \"./test-all-newreno\"\
    .\n"
- title: 6.1.  ACK Heuristic
  contents:
  - "6.1.  ACK Heuristic\n   If the ACK-based heuristic is used, then following the\
    \ advancement of\n   the cumulative acknowledgement field, the sender stores the\
    \ value of\n   the previous cumulative acknowledgement as prev_highest_ack, and\n\
    \   stores the latest cumulative ACK as highest_ack.  In addition, the\n   following\
    \ step is performed if Step 1 in Section 3 fails, before\n   proceeding to Step\
    \ 1B.\n   1*)  If the Cumulative Acknowledgement field didn't cover more than\n\
    \        \"recover\", check to see if the congestion window is greater than\n\
    \        SMSS bytes and the difference between highest_ack and\n        prev_highest_ack\
    \ is at most 4*SMSS bytes.  If true, duplicate\n        ACKs indicate a lost segment\
    \ (proceed to Step 1A in Section 3).\n        Otherwise, duplicate ACKs likely\
    \ result from unnecessary\n        retransmissions (proceed to Step 1B in Section\
    \ 3).\n   The congestion window check serves to protect against fast retransmit\n\
    \   immediately after a retransmit timeout, similar to the\n   \"exitFastRetrans_\"\
    \ variable in NS.  Examples of applying the ACK\n   heuristic are in validation\
    \ tests \"./test-all-newreno\n   newreno_rto_loss_ack\" and \"./test-all-newreno\
    \ newreno_rto_dup_ack\" in\n   directory \"tcl/test\" of the NS simulator.\n \
    \  If several ACKs are lost, the sender can see a jump in the cumulative\n   ACK\
    \ of more than three segments, and the heuristic can fail.  A\n   validation test\
    \ for this scenario is \"./test-all-newreno\n   newreno_rto_loss_ackf\".  RFC\
    \ 2581 recommends that a receiver should\n   send duplicate ACKs for every out-of-order\
    \ data packet, such as a\n   data packet received during Fast Recovery.  The ACK\
    \ heuristic is more\n   likely to fail if the receiver does not follow this advice,\
    \ because\n   then a smaller number of ACK losses are needed to produce a\n  \
    \ sufficient jump in the cumulative ACK.\n"
- title: 6.2.  Timestamp Heuristic
  contents:
  - "6.2.  Timestamp Heuristic\n   If this heuristic is used, the sender stores the\
    \ timestamp of the\n   last acknowledged segment.  In addition, the second paragraph\
    \ of step\n   1 in Section 3 is replaced as follows:\n   1**) If the Cumulative\
    \ Acknowledgement field didn't cover more than\n        \"recover\", check to\
    \ see if the echoed timestamp in the last\n        non-duplicate acknowledgment\
    \ equals the stored timestamp.  If\n        true, duplicate ACKs indicate a lost\
    \ segment (proceed to Step 1A\n        in Section 3).  Otherwise, duplicate ACKs\
    \ likely result from\n        unnecessary retransmissions (proceed to Step 1B\
    \ in Section 3).\n   Examples of applying the timestamp heuristic are in validation\
    \ tests\n   \"./test-all-newreno newreno_rto_loss_tsh\" and \"./test-all-newreno\n\
    \   newreno_rto_dup_tsh\".  The timestamp heuristic works correctly, both\n  \
    \ when the receiver echoes timestamps as specified by [RFC1323], and by\n   its\
    \ revision attempts.  However, if the receiver arbitrarily echoes\n   timestamps,\
    \ the heuristic can fail.  The heuristic can also fail if a\n   timeout was spurious\
    \ and returning ACKs are not from retransmitted\n   segments.  This can be prevented\
    \ by detection algorithms such as\n   [RFC3522].\n"
- title: 7.  Implementation Issues for the Data Receiver
  contents:
  - "7.  Implementation Issues for the Data Receiver\n   [RFC2581] specifies that\
    \ \"Out-of-order data segments SHOULD be\n   acknowledged immediately, in order\
    \ to accelerate loss recovery.\"\n   Neal Cardwell has noted that some data receivers\
    \ do not send an\n   immediate acknowledgement when they send a partial acknowledgment,\n\
    \   but instead wait first for their delayed acknowledgement timer to\n   expire\
    \ [C98].  As [C98] notes, this severely limits the potential\n   benefit of NewReno\
    \ by delaying the receipt of the partial\n   acknowledgement at the data sender.\
    \  Echoing RFC 2581, our\n   recommendation is that the data receiver send an\
    \ immediate\n   acknowledgement for an out-of-order segment, even when that out-of-\n\
    \   order segment fills a hole in the buffer.\n"
- title: 8.  Implementation Issues for the Data Sender
  contents:
  - "8.  Implementation Issues for the Data Sender\n   In Section 3, Step 5 above,\
    \ it is noted that implementations should\n   take measures to avoid a possible\
    \ burst of data when leaving Fast\n   Recovery, in case the amount of new data\
    \ that the sender is eligible\n   to send due to the new value of the congestion\
    \ window is large.  This\n   can arise during NewReno when ACKs are lost or treated\
    \ as pure window\n   updates, thereby causing the sender to underestimate the\
    \ number of\n   new segments that can be sent during the recovery procedure.\n\
    \   Specifically, bursts can occur when the FlightSize is much less than\n   the\
    \ new congestion window when exiting from Fast Recovery.  One\n   simple mechanism\
    \ to avoid a burst of data when leaving Fast Recovery\n   is to limit the number\
    \ of data packets that can be sent in response\n   to a single acknowledgment.\
    \  (This is known as \"maxburst_\" in the ns\n   simulator.)  Other possible mechanisms\
    \ for avoiding bursts include\n   rate-based pacing, or setting the slow-start\
    \ threshold to the\n   resultant congestion window and then resetting the congestion\
    \ window\n   to FlightSize.  A recommendation on the general mechanism to avoid\n\
    \   excessively bursty sending patterns is outside the scope of this\n   document.\n\
    \   An implementation may want to use a separate flag to record whether\n   or\
    \ not it is presently in the Fast Recovery procedure.  The use of\n   the value\
    \ of the duplicate acknowledgment counter for this purpose is\n   not reliable\
    \ because it can be reset upon window updates and out-of-\n   order acknowledgments.\n\
    \   When not in Fast Recovery, the value of the state variable \"recover\"\n \
    \  should be pulled along with the value of the state variable for\n   acknowledgments\
    \ (typically, \"snd_una\") so that, when large amounts of\n   data have been sent\
    \ and acked, the sequence space does not wrap and\n   falsely indicate that Fast\
    \ Recovery should not be entered (Section 3,\n   step 1, last paragraph).\n  \
    \ It is important for the sender to respond correctly to duplicate ACKs\n   received\
    \ when the sender is no longer in Fast Recovery (e.g., because\n   of a Retransmit\
    \ Timeout).  The Limited Transmit procedure [RFC3042]\n   describes possible responses\
    \ to the first and second duplicate\n   acknowledgements.  When three or more\
    \ duplicate acknowledgements are\n   received, the Cumulative Acknowledgement\
    \ field doesn't cover more\n   than \"recover\", and a new Fast Recovery is not\
    \ invoked, it is\n   important that the sender not execute the Fast Recovery steps\
    \ (3) and\n   (4) in Section 3.  Otherwise, the sender could end up in a chain\
    \ of\n   spurious timeouts.  We mention this only because several NewReno\n  \
    \ implementations had this bug, including the implementation in the NS\n   simulator.\
    \  (This bug in the NS simulator was fixed in July 2003,\n   with the variable\
    \ \"exitFastRetrans_\".)\n"
- title: 9.  Simulations
  contents:
  - "9.  Simulations\n   Simulations with NewReno are illustrated with the validation\
    \ test\n   \"tcl/test/test-all-newreno\" in the NS simulator.  The command\n \
    \  \"../../ns test-suite-newreno.tcl reno\" shows a simulation with Reno\n   TCP,\
    \ illustrating the data sender's lack of response to a partial\n   acknowledgement.\
    \  In contrast, the command \"../../ns test-suite-\n   newreno.tcl newreno_B\"\
    \ shows a simulation with the same scenario\n   using the NewReno algorithms described\
    \ in this paper.\n"
- title: 10.  Comparisons between Reno and NewReno TCP
  contents:
  - "10.  Comparisons between Reno and NewReno TCP\n   As we stated in the introduction,\
    \ we believe that the NewReno\n   modification described in this document improves\
    \ the performance of\n   the Fast Retransmit and Fast Recovery algorithms of Reno\
    \ TCP in a\n   wide variety of scenarios.  This has been discussed in some depth\
    \ in\n   [FF96], which illustrates Reno TCP's poor performance when multiple\n\
    \   packets are dropped from a window of data and also illustrates\n   NewReno\
    \ TCP's good performance in that scenario.\n   We do, however, know of one scenario\
    \ where Reno TCP gives better\n   performance than NewReno TCP, that we describe\
    \ here for the sake of\n   completeness.  Consider a scenario with no packet loss,\
    \ but with\n   sufficient reordering so that the TCP sender receives three duplicate\n\
    \   acknowledgements.  This will trigger the Fast Retransmit and Fast\n   Recovery\
    \ algorithms.  With Reno TCP or with Sack TCP, this will\n   result in the unnecessary\
    \ retransmission of a single packet, combined\n   with a halving of the congestion\
    \ window (shown on pages 4 and 6 of\n   [F03]).  With NewReno TCP, however, this\
    \ reordering will also result\n   in the unnecessary retransmission of an entire\
    \ window of data (shown\n   on page 5 of [F03]).\n   While Reno TCP performs better\
    \ than NewReno TCP in the presence of\n   reordering, NewReno's superior performance\
    \ in the presence of\n   multiple packet drops generally outweighs its less optimal\n\
    \   performance in the presence of reordering.  (Sack TCP is the\n   preferred\
    \ solution, with good performance in both scenarios.)  This\n   document recommends\
    \ the Fast Retransmit and Fast Recovery algorithms\n   of NewReno TCP instead\
    \ of those of Reno TCP for those TCP connections\n   that do not support SACK.\
    \  We would also note that NewReno's Fast\n   Retransmit and Fast Recovery mechanisms\
    \ are widely deployed in TCP\n   implementations in the Internet today, as documented\
    \ in [PF01].  For\n   example, tests of TCP implementations in several thousand\
    \ web servers\n   in 2001 showed that for those TCP connections where the web\
    \ browser\n   was not SACK-capable, more web servers used the Fast Retransmit\
    \ and\n   Fast Recovery algorithms of NewReno than those of Reno or Tahoe TCP\n\
    \   [PF01].\n"
- title: 11.  Changes Relative to RFC 2582
  contents:
  - "11.  Changes Relative to RFC 2582\n   The purpose of this document is to advance\
    \ the NewReno's Fast\n   Retransmit and Fast Recovery algorithms in RFC 2582 to\
    \ Standards\n   Track.\n   The main change in this document relative to RFC 2582\
    \ is to specify\n   the Careful variant of NewReno's Fast Retransmit and Fast\
    \ Recovery\n   algorithms.  The base algorithm described in RFC 2582 did not attempt\n\
    \   to avoid unnecessary multiple Fast Retransmits that can occur after a\n  \
    \ timeout (described in more detail in the section above).  However,\n   RFC 2582\
    \ also defined \"Careful\" and \"Less Careful\" variants that\n   avoid these\
    \ unnecessary Fast Retransmits, and recommended the Careful\n   variant.  This\
    \ document specifies the previously-named \"Careful\"\n   variant as the basic\
    \ version of NewReno.  As described below, this\n   algorithm uses a variable\
    \ \"recover\", whose initial value is the send\n   sequence number.\n   The algorithm\
    \ specified in Section 3 checks whether the\n   acknowledgement field of a partial\
    \ acknowledgement covers *more* than\n   \"recover\", as defined in Section 3.\
    \  Another possible variant would\n   be to simply require that the acknowledgement\
    \ field covers *more than\n   or equal to* \"recover\" before initiating another\
    \ Fast Retransmit.  We\n   called this the Less Careful variant in RFC 2582.\n\
    \   There are two separate scenarios in which the TCP sender could\n   receive\
    \ three duplicate acknowledgements acknowledging \"recover\" but\n   no more than\
    \ \"recover\".  One scenario would be that the data sender\n   transmitted four\
    \ packets with sequence numbers higher than \"recover\",\n   that the first packet\
    \ was dropped in the network, and the following\n   three packets triggered three\
    \ duplicate acknowledgements\n   acknowledging \"recover\".  The second scenario\
    \ would be that the\n   sender unnecessarily retransmitted three packets below\
    \ \"recover\", and\n   that these three packets triggered three duplicate acknowledgements\n\
    \   acknowledging \"recover\".  In the absence of SACK, the TCP sender is\n  \
    \ unable to distinguish between these two scenarios.\n   For the Careful variant\
    \ of Fast Retransmit, the data sender would\n   have to wait for a retransmit\
    \ timeout in the first scenario, but\n   would not have an unnecessary Fast Retransmit\
    \ in the second scenario.\n   For the Less Careful variant to Fast Retransmit,\
    \ the data sender\n   would Fast Retransmit as desired in the first scenario,\
    \ and would\n   unnecessarily Fast Retransmit in the second scenario.  This document\n\
    \   only specifies the Careful variant in Section 3.  Unnecessary Fast\n   Retransmits\
    \ with the Less Careful variant in scenarios with\n   reordering are illustrated\
    \ in page 8 of [F03].\n   The document also specifies two heuristics that the\
    \ TCP sender MAY\n   use to decide to invoke Fast Retransmit even when the three\
    \ duplicate\n   acknowledgements do not cover more than \"recover\".  These heuristics,\n\
    \   an ACK-based heuristic and a timestamp heuristic, are described in\n   Sections\
    \ 6.1 and 6.2 respectively.\n"
- title: 12.  Conclusions
  contents:
  - "12.  Conclusions\n   This document specifies the NewReno Fast Retransmit and\
    \ Fast Recovery\n   algorithms for TCP.  This NewReno modification to TCP can\
    \ even be\n   important for TCP implementations that support the SACK option,\n\
    \   because the SACK option can only be used for TCP connections when\n   both\
    \ TCP end-nodes support the SACK option.  NewReno performs better\n   than Reno\
    \ (RFC 2581) in a number of scenarios discussed herein.\n   A number of options\
    \ to the basic algorithm presented in Section 3 are\n   also described.  These\
    \ include the handling of the retransmission\n   timer (Section 4), the response\
    \ to partial acknowledgments (Section\n   5), and the value of the congestion\
    \ window when leaving Fast Recovery\n   (section 3, step 5).  Our belief is that\
    \ the differences between\n   these variants of NewReno are small compared to\
    \ the differences\n   between Reno and NewReno.  That is, the important thing\
    \ is to\n   implement NewReno instead of Reno, for a TCP connection without SACK;\n\
    \   it is less important exactly which of the variants of NewReno is\n   implemented.\n"
- title: 13.  Security Considerations
  contents:
  - "13.  Security Considerations\n   RFC 2581 discusses general security considerations\
    \ concerning TCP\n   congestion control.  This document describes a specific algorithm\n\
    \   that conforms with the congestion control requirements of RFC 2581,\n   and\
    \ so those considerations apply to this algorithm, too.  There are\n   no known\
    \ additional security concerns for this specific algorithm.\n"
- title: 14.  Acknowledgements
  contents:
  - "14.  Acknowledgements\n   Many thanks to Anil Agarwal, Mark Allman, Armando Caro,\
    \ Jeffrey Hsu,\n   Vern Paxson, Kacheong Poon, Keyur Shah, and Bernie Volz for\
    \ detailed\n   feedback on this document or on its precursor, RFC 2582.\n"
- title: 15.  References
  contents:
  - '15.  References

    '
- title: 15.1.  Normative References
  contents:
  - "15.1.  Normative References\n   [RFC2018] Mathis, M., Mahdavi, J., Floyd, S.\
    \ and A. Romanow, \"TCP\n             Selective Acknowledgement Options\", RFC\
    \ 2018, October 1996.\n   [RFC2119] Bradner, S., \"Key words for use in RFCs to\
    \ Indicate\n             Requirement Levels\", BCP 14, RFC 2119, March 1997.\n\
    \   [RFC2581] Allman, M., Paxson, V. and  W. Stevens, \"TCP Congestion\n     \
    \        Control\", RFC 2581, April 1999.\n   [RFC2582] Floyd, S. and T. Henderson,\
    \ \"The NewReno Modification to\n             TCP's Fast Recovery Algorithm\"\
    , RFC 2582, April 1999.\n   [RFC2988] Paxson, V. and M. Allman, \"Computing TCP's\
    \ Retransmission\n             Timer\", RFC 2988, November 2000.\n   [RFC3042]\
    \ Allman, M., Balakrishnan, H. and S. Floyd, \"Enhancing TCP's\n             Loss\
    \ Recovery Using Limited Transmit\", RFC 3042, January\n             2001.\n"
- title: 15.2.  Informative References
  contents:
  - "15.2.  Informative References\n   [C98]     Cardwell, N., \"delayed ACKs for\
    \ retransmitted packets:\n             ouch!\".  November 1998,  Email to the\
    \ tcpimpl mailing list,\n             Message-ID \"Pine.LNX.4.02A.9811021421340.26785-\n\
    \             100000@sake.cs.washington.edu\", archived at \"http://tcp-\n   \
    \          impl.lerc.nasa.gov/tcp-impl\".\n   [F98]     Floyd, S., Revisions to\
    \ RFC 2001, \"Presentation to the\n             TCPIMPL Working Group\", August\
    \ 1998.  URLs\n             \"ftp://ftp.ee.lbl.gov/talks/sf-tcpimpl-aug98.ps\"\
    \ and\n             \"ftp://ftp.ee.lbl.gov/talks/sf-tcpimpl-aug98.pdf\".\n   [F03]\
    \     Floyd, S., \"Moving NewReno from Experimental to Proposed\n            \
    \ Standard?  Presentation to the TSVWG Working Group\", March\n             2003.\
    \  URLs \"http://www.icir.org/floyd/talks/newreno-\n             Mar03.ps\" and\
    \ \"http://www.icir.org/floyd/talks/newreno-\n             Mar03.pdf\".\n   [FF96]\
    \    Fall, K. and S. Floyd, \"Simulation-based Comparisons of\n             Tahoe,\
    \ Reno and SACK TCP\", Computer Communication Review,\n             July 1996.\
    \  URL \"ftp://ftp.ee.lbl.gov/papers/sacks.ps.Z\".\n   [F94]     Floyd, S., \"\
    TCP and Successive Fast Retransmits\", Technical\n             report, October\
    \ 1994.  URL\n             \"ftp://ftp.ee.lbl.gov/papers/fastretrans.ps\".\n \
    \  [GF04]    Gurtov, A. and S. Floyd, \"Resolving Acknowledgment\n           \
    \  Ambiguity in non-SACK TCP\", Next Generation Teletraffic and\n            \
    \ Wired/Wireless Advanced Networking (NEW2AN'04), February\n             2004.\
    \  URL \"http://www.cs.helsinki.fi/u/gurtov/papers/\n             heuristics.html\"\
    .\n   [Gur03]   Gurtov, A., \"[Tsvwg] resolving the problem of unnecessary\n \
    \            fast retransmits in go-back-N\", email to the tsvwg mailing\n   \
    \          list, message ID <3F25B467.9020609@cs.helsinki.fi>, July\n        \
    \     28, 2003.  URL \"http://www1.ietf.org/mail-archive/working-\n          \
    \   groups/tsvwg/current/msg04334.html\".\n   [Hen98]   Henderson, T., Re: NewReno\
    \ and the 2001 Revision. September\n             1998.  Email to the tcpimpl mailing\
    \ list, Message ID\n             \"Pine.BSI.3.95.980923224136.26134A-\n      \
    \       100000@raptor.CS.Berkeley.EDU\", archived at \"http://tcp-\n         \
    \    impl.lerc.nasa.gov/tcp-impl\".\n   [Hoe95]   Hoe, J., \"Startup Dynamics\
    \ of TCP's Congestion Control and\n             Avoidance Schemes\", Master's\
    \ Thesis, MIT, 1995.\n   [Hoe96]   Hoe, J., \"Improving the Start-up Behavior\
    \ of a Congestion\n             Control Scheme for TCP\", ACM SIGCOMM, August\
    \ 1996.  URL\n             \"http://www.acm.org/sigcomm/sigcomm96/program.html\"\
    .\n   [LM97]    Lin, D. and R. Morris, \"Dynamics of Random Early\n          \
    \   Detection\", SIGCOMM 97, September 1997.  URL\n             \"http://www.acm.org/sigcomm/sigcomm97/program.html\"\
    .\n   [NS]      The Network Simulator (NS). URL\n             \"http://www.isi.edu/nsnam/ns/\"\
    .\n   [PF01]    Padhye, J. and S. Floyd, \"Identifying the TCP Behavior of\n \
    \            Web Servers\", June 2001, SIGCOMM 2001.\n   [RFC1323] Jacobson, V.,\
    \ Braden, R. and D. Borman, \"TCP Extensions for\n             High Performance\"\
    , RFC 1323, May 1992.\n   [RFC3517] Blanton, E., Allman, M., Fall, K. and L. Wang,\
    \ \"A\n             Conservative Selective Acknowledgment (SACK)-based Loss\n\
    \             Recovery Algorithm for TCP\", RFC 3517, April 2003.\n   [RFC3522]\
    \ Ludwig, R. and M. Meyer, \"The Eifel Detection Algorithm for\n             TCP\"\
    , RFC 3522, April 2003.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Sally Floyd\n   International Computer Science Institute\n\
    \   Phone: +1 (510) 666-2989\n   EMail: floyd@acm.org\n   URL: http://www.icir.org/floyd/\n\
    \   Tom Henderson\n   The Boeing Company\n   EMail: thomas.r.henderson@boeing.com\n\
    \   Andrei Gurtov\n   TeliaSonera\n   EMail: andrei.gurtov@teliasonera.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2004).  This\
    \ document is subject\n   to the rights, licenses and restrictions contained in\
    \ BCP 78, and\n   except as set forth therein, the authors retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE\n   REPRESENTS\
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE\n   INTERNET ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed\n   to pertain to the implementation or use of the technology\n   described\
    \ in this document or the extent to which any license\n   under such rights might\
    \ or might not be available; nor does it\n   represent that it has made any independent\
    \ effort to identify any\n   such rights.  Information on the procedures with\
    \ respect to\n   rights in RFC documents can be found in BCP 78 and BCP 79.\n\
    \   Copies of IPR disclosures made to the IETF Secretariat and any\n   assurances\
    \ of licenses to be made available, or the result of an\n   attempt made to obtain\
    \ a general license or permission for the use\n   of such proprietary rights by\
    \ implementers or users of this\n   specification can be obtained from the IETF\
    \ on-line IPR repository\n   at http://www.ietf.org/ipr.\n   The IETF invites\
    \ any interested party to bring to its attention\n   any copyrights, patents or\
    \ patent applications, or other\n   proprietary rights that may cover technology\
    \ that may be required\n   to implement this standard.  Please address the information\
    \ to the\n   IETF at ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
