As reported in RFC 1052, IAB Recommendations for the Development of Internet Network Management Standards [1], a two prong strategy for network management of TCP/IP based internets was undertaken.
In the short term, the Simple Network Management Protocol (SNMP) was to be used to manage nodes in the Internet community.
In the long term, the use of the OSI network management framework was to be examined.
Two documents were produced to define the management information: RFC 1065, which defined the Structure of Management Information (SMI) [2], and RFC 1066, which defined the Management Information Base (MIB) [3].
Both of these documents were designed so as to be compatible with both the SNMP and the OSI network management framework.
This strategy was quite successful in the short term:
Internet based network management technology was fielded, by both the research and commercial communities, within a few months.
As a result of this, portions of the Internet community became network manageable in a timely fashion.
As reported in RFC 1109, Report of the Second Ad Hoc Network Management Review Group [4], the requirements of the SNMP and the OSI network management frameworks were more different than anticipated.
As such, the requirement for compatibility between the SMI/MIB and both frameworks was suspended.
This action permitted the operational network management framework, the SNMP, to respond to new operational needs in the Internet community by producing this document.
As such, the current network management framework for TCP/IP  based internets consists of: Structure and Identification of Management Information for TCP/IP based internets, RFC 1155 [13], which describes how managed objects contained in the MIB are defined; Management Information Base for Network Management of TCP/IP based internets (version 2), this memo, which describes the managed objects contained in the MIB; and, the Simple Network Management Protocol, RFC 1157 [14], which defines the protocol used to manage these objects.
Consistent with the IAB directive to produce simple, workable systems in the short term, the list ofc objects (e.g., for BSD UNIX) were excluded.
It was agreed to avoid heavily instrumenting critical sections of code.
The general guideline was one counter per critical section per layer.
I Features of this MIB include: 1) incremental additions to reflect new operational requirements; 2) upwards compatibility with the SMI/MIB and the SNMP; 3) improved support for multi protocol entities; and, 4) textual clean up of the MIB to improve clarity and readability.
The objects defined in MIB II have the OBJECT IDENTIFIER prefix:
In order to better prepare implementors for future changes in the MIB, a new term "deprecated" may be used when describing an object.
A deprecated object in the MIB is one which must be supported, but one which will most likely be removed from the next version of the MIB (e.g., MIB III).
MIB II marks one object as being deprecated: atTable As a result of deprecating the atTable object
, the entire Address Translation group is deprecated.
Note that no functionality is lost with the deprecation of these objects: new objects providing equivalent or superior functionality are defined in MIB II.
In the past, there have been misinterpretations of the MIB as to when a string of octets should contain printable characters, meant to be displayed to a human.
A DisplayString is restricted to the NVT ASCII character set, as defined in pages 10 11 of [7].
The following objects are now defined in terms of DisplayString:
It should be noted that this change has no effect on either the syntax nor semantics of these objects.
The use of the DisplayString notation is merely an artifact of the explanatory method used in MIB II and future MIBs.
Further, it should be noted that any object defined in terms of OCTET STRING may contain arbitrary binary data, in which each octet may take any value from 0 to 255 (decimal).
The System Group Four new objects are added to this group:
sysContact sysName sysLocation sysServices These provide contact, administrative, location, and service information regarding the managed node.
The definition of the ifNumber object was incorrect, as it required all interfaces to support IP.
(For example, devices without IP, such as MAC layer bridges, could not be managed if this definition was strictly followed.)
The description of the ifNumber object is changed accordingly.
The ifTable object was mistaken marked as read write
, it has been (correctly) re designated as read only.
In addition, several new values have been added to the ifType column in the ifTable object: ppp(23)
Finally, a new column has been added to the ifTable object:
ifSpecific which provides information about information specific to the media being used to realize the interface.
In MIB I, this group contained a table which permitted mappings from network addresses (e.g., IP addresses) to physical addresses (e.g., MAC addresses).
Experience has shown that efficient implementations of this table make two assumptions: a single network protocol environment, and mappings occur only from network address to physical address.
The need to support multi protocol nodes (e.g., those with both the IP and CLNP active), and the need to support the inverse mapping (e.g., for ES IS), have invalidated both of these assumptions.
As such, the atTable object is declared deprecated.
In order to meet both the multi protocol and inverse mapping requirements, MIB II and its successors will allocate up to two address translation tables inside each network protocol group.
That is, the IP group will contain one address translation table, for going from IP addresses to physical addresses.
Similarly, when a document defining MIB objects for the CLNP is produced (e.g., [8]), it will contain two tables, for mappings in both directions, as this is required for full functionality.
It should be noted that the choice of two tables (one for each direction of mapping) provides for ease of implementation in many cases, and does not introduce undue burden on implementations which realize the address translation abstraction through a single internal table.
The access attribute of the variable ipForwarding has been changed from read only to read write.
In addition, there is a new column to the ipAddrTable object, ipAdEntReasmMaxSize which keeps track of the largest IP datagram that can be re  assembled on a particular interface.
There is also a new column in the ipRoutingTable object, ipRouteMask which is used for IP routing subsystems that support arbitrary subnet masks.
One new object is added to the IP group: ipNetToMediaTable which is the address translation table for the IP group (providing identical functionality to the now deprecated atTable in the address translation group).
There are no changes to this group.
The TCP Group Two new variables are added: tcpInErrs tcpOutRsts which keep track of the number of incoming TCP segments in error and the number of resets generated by a TCP.
The UDP Group A new table: udpTable is added.
The EGP Group Experience has indicated a need for additional objects that are useful in EGP monitoring.
In addition to making several additions to the egpNeighborTable object, a new variable is added: egpAs which gives the autonomous system associated with this EGP entity.
The Transmission Group MIB I was lacking in that it did not distinguish between different types of transmission media.
Typically, such definitions reside in the experimental portion of the MIB until they are "proven", then as a part of the Internet standardization process, the definitions are accordingly elevated and a new object identifier, under the transmission group is defined.
The application oriented working groups of the IETF have been tasked to be receptive towards defining MIB variables specific to their respective applications.
For the SNMP, it is useful to have statistical information.
A new group, the SNMP group, is allocated for this purpose:
Objects Managed objects are accessed via a virtual information store, termed the Management Information Base or MIB.
Objects in the MIB are defined using Abstract Syntax Notation One (ASN.1) [9].
The mechanisms used for describing these objects are specified the companion memo, the SMI.
In particular, each object has a name, a syntax, and an encoding.
The name is an object identifier, an administratively assigned name, which specifies an object type.
The object type together with an object instance serves to uniquely identify a specific instantiation of the object.
For human convenience, we often use a textual string, termed the OBJECT DESCRIPTOR, to also refer to the object type.
The syntax of an object type defines the abstract data structure corresponding to that object type.
The ASN.1 language is used for this purpose.
However, the companion memo purposely restricts the ASN.1 constructs which may be used.
These restrictions are explicitly made for simplicity.
The encoding of an object type is simply how that object type is represented using the object type's syntax.
Implicitly tied to the notion of an object type's syntax and encoding
is how the object type is represented when being transmitted on the network.
This memo specifies the use of the basic encoding rules (BER) of ASN.1 [10], subject to the additional requirements imposed by the SNMP [14].
Since this list of managed objects contains only the essential elements, there is no need to allow individual objects to be optional.
Rather, the objects are arranged into the following groups: System Interfaces Address Translation (deprecated) IP ICMP TCP UDP EGP Transmission SNMP
There are two reasons for defining these groups: to provide a means of assigning object identifiers; and, to provide a method for implementations of managed agents to know which objects they must implement.
This method is as follows: if the semantics of a group is applicable to an implementation, then it must implement all objects in that group.
For example, an implementation must implement the EGP group if and only if it implements the EGP.
The next section contains the specification of all object types contained in the MIB.
Following the conventions of the companion memo, the object types are defined using the following fields: OBJECT:
A textual name, termed the OBJECT DESCRIPTOR, for the object type, along with its corresponding OBJECT IDENTIFIER.
The abstract syntax for the object type, presented using ASN.1.
This must resolve to an instance of the ASN.1 type ObjectSyntax defined in the SMI.
A textual description of the semantics of the object type.
Implementations should ensure that their interpretation of the object type fulfills this definition since this MIB is intended for use in multi  vendor environments.
As such it is vital that object types have consistent meaning across all machines.
A keyword, one of read only, read write, write only, or not accessible.
Note that this designation specifies the minimum level of support required.
As a local matter, implementations may support other access types (e.g., an implementation may elect to permitting writing a variable marked herein as read only).
Further, protocol specific "views" (e.g., those implied by an SNMP community) may make further restrictions on access to a variable.
A keyword, one of mandatory, optional, obsolete, or deprecated.
Use of deprecated implies mandatory status.
IMPORTS mgmt, OBJECT TYPE, NetworkAddress, IpAddress, Counter, Gauge, TimeTicks FROM RFC1155 SMI;
The System Group Implementation of the System group is mandatory for all systems.
{ system 1 } Syntax:
A textual description of the entity.
This value should include the full name and version identification of the system's hardware type, software operating system, and networking software.
It is mandatory that this only contain printable ASCII characters.
sysObjectID { system 2 } Syntax:
The vendor's authoritative identification of the network management subsystem contained in the entity.
This value is allocated within the SMI enterprises subtree (1.3.6.1.4.1) and provides an easy and unambiguous means for determining "what kind of box" is being managed.
For example, if vendor "Flintstones,
Inc." was assigned the subtree 1.3.6.1.4.1.4242, it could assign the identifier 1.3.6.1.4.1.4242.1.1 to its "Fred Router".
sysUpTime { system 3 } Syntax: TimeTicks Definition:
The time (in hundredths of a second) since the network management portion of the system was last re initialized.
{ system 4 } Syntax:
The textual identification of the contact person for this managed node, together with information on how to contact this person.
sysName { system 5 } Syntax:
An administratively assigned name for this managed node.
By convention, this is the node's fully qualified domain name.
sysLocation { system 6 }
The physical location of this node (e.g., "telephone closet, 3rd floor").
sysServices { system 7 } Syntax: INTEGER (0
A value which indicates the set of services that this entity potentially offers.
The value is a sum.
This sum initially takes the value zero, Then, for each layer, L, in the range 1 through 7, that this node performs transactions for, 2 raised to (L 1) is added to the sum.
For example, a node which performs only routing functions would have a value of 4 (2^(3 1)).
In contrast, a node which is a host offering application services would have a value of 72 (2^(4 1)   2^(7 1)).
For systems including OSI protocols, layers 5 and 6 may also be counted.
The Interfaces Group Implementation of the Interfaces group is mandatory for all systems.
ifNumber { interfaces 1 } Syntax:
The number of network interfaces (regardless of their current state) present on this system.
The Interfaces table The Interfaces table contains information on the entity's interfaces.
Each interface is thought of as being attached to a "subnetwork".
Note that this term should not be confused with "subnet" which refers to an addressing partitioning scheme used in the Internet suite of protocols.
{ interfaces 2 } Syntax: SEQUENCE OF IfEntry Definition:
A list of interface entries.
The number of entries is given by the value of ifNumber.
, ifLastChange TimeTicks, ifInOctets Counter, ifInUcastPkts Counter, ifInNUcastPkts Counter, ifInDiscards Counter, ifInErrors Counter, ifInUnknownProtos Counter, ifOutOctets Counter, ifOutUcastPkts Counter, ifOutNUcastPkts Counter, ifOutDiscards Counter, ifOutErrors Counter,
An interface entry containing objects at the subnetwork layer and below for a particular interface.
We now consider the individual components of each interface entry: OBJECT:
ifIndex { ifEntry 1 } Syntax: INTEGER Definition:
A unique value for each interface.
Its value ranges between 1 and the value of ifNumber.
The value for each interface must remain constant at least from one re  initialization of the entity's network management system to the next re initialization.
ifDescr { ifEntry 2 } Syntax:
A textual string containing information about the interface.
This string should include the name of the manufacturer, the product name and the version of the hardware interface.
The type of interface, distinguished according to the physical/link protocol(s) immediately "below" the network layer in the protocol stack.
ifMtu { ifEntry 4 } Syntax: INTEGER Definition:
The size of the largest datagram which can be sent/received on the interface, specified in octets.
For interfaces that are used for transmitting network datagrams, this is the size of the largest network datagram that can be sent on the interface.
ifSpeed { ifEntry 5 } Syntax:
An estimate of the interface's current bandwidth in bits per second.
For interfaces which do not vary in bandwidth or for those where no accurate estimation can be made, this object should contain the nominal bandwidth.
The interface's address at the protocol layer immediately "below" the network layer in the protocol stack.
For interfaces which do not have such an address (e.g., a serial line), this object should contain an octet string of zero length.
The testing(3) state indicates that no operational packets can be passed.
The testing(3) state indicates that no operational packets can be passed.
{ ifEntry 9 } Syntax:
The value of sysUpTime at the time the interface entered its current operational state.
If the current state was entered prior to the last re initialization of the local network management subsystem, then this object contains a zero value.
ifInOctets { ifEntry 10 } Syntax:
The total number of octets received on the interface, including framing characters.
{ ifEntry 11 } Syntax:
The number of subnetwork unicast packets delivered to a higher layer protocol.
The number of non unicast (i.e., subnetwork broadcast or subnetwork multicast)
packets delivered to a higher layer protocol.
ifInDiscards { ifEntry 13 } Syntax:
The number of inbound packets which were chosen to be discarded even though no errors had been detected to prevent their being deliverable to a higher layer protocol.
One possible reason for discarding such a packet could be to free up buffer space.
ifInErrors { ifEntry 14 } Syntax:
The number of inbound packets that contained errors preventing them from being deliverable to a higher layer protocol.
The number of packets received via the interface which were discarded because of an unknown or unsupported protocol.
The total number of octets transmitted out of the interface, including framing characters.
ifOutUcastPkts { ifEntry 17 }
The total number of packets that higher level protocols requested be transmitted to a subnetwork unicast address, including those that were discarded or not sent.
ifOutNUcastPkts { ifEntry 18 }
The total number of packets that higher level protocols requested be transmitted to a non unicast (i.e., a subnetwork broadcast or subnetwork multicast) address, including those that were discarded or not sent.
The number of outbound packets which were chosen to be discarded even though no errors had been detected to prevent their being transmitted.
One possible reason for discarding such a packet could be to free up buffer space.
ifOutErrors { ifEntry 20 } Syntax:
The number of outbound packets that could not be transmitted because of errors.
{ ifEntry 21 } Syntax: Gauge Definition:
The length of the output packet queue (in packets).
ifSpecific { ifEntry 22 } Syntax:
A reference to MIB definitions specific to the particular media being used to realize the interface.
For example, if the interface is realized by an ethernet, then the value of this object refers to a document defining objects specific to ethernet.
If an agent is not configured to have a value for any of these variables, the object identifier nullSpecific
Note that "nullSpecific" is a syntatically valid object identifier, and any conformant implementation of ASN.1 and BER must be able to generate and recognize this value.
The Address Translation Group Implementation of the Address Translation group is mandatory for all systems.
Note however that this group is deprecated by MIB II.
That is, it is being included solely for compatibility with MIB I nodes, and will most likely be excluded from MIB III nodes.
From MIB II and onwards, each network protocol group contains its own address translation tables.
The Address Translation group contains one table which is the union across all interfaces of the translation tables for converting a NetworkAddress (e.g., an IP address) into a subnetwork specific address.
For lack of a better term, this document refers to such a subnetwork specific address as a "physical" address.
Examples of such translation tables are: for broadcast media where ARP is in use, the translation table is equivalent to the ARP cache; or, on an X.25 network where non algorithmic translation to X.121 addresses is required, the translation table contains the NetworkAddress to X.121 address equivalences.
atTable { at 1 } Syntax: SEQUENCE OF AtEntry Definition:
The Address Translation tables contain the NetworkAddress to "physical" address equivalences.
Some interfaces do not use translation tables for determining address equivalences (e.g., DDN X.25 has an algorithmic method); if all interfaces are of this type, then the Address Translation table is empty, i.e., has zero entries.
Each entry contains one NetworkAddress to "physical" address equivalence.
We now consider the individual components of each Address Translation table entry: OBJECT:
atIfIndex { atEntry 1 } Syntax: INTEGER Definition:
The interface on which this entry's equivalence is effective.
The interface identified by a particular value of this index is the same interface as identified by the same value of ifIndex.
{ atEntry 2 } Syntax: OCTET STRING Definition:
The media dependent "physical" address.
Setting this object to a null string (one of zero length) has the effect of invaliding the corresponding entry in the atTable object.
That is, it effectively disassociates the interface identified with said entry from the mapping identified with said entry.
It is an implementation specific matter as to whether the agent removes an invalidated entry from the table.
Accordingly, management stations must be prepared to receive tabular information from agents that corresponds to entries not currently in use.
Proper interpretation of such entries requires examination of the relevant atPhysAddress object.
atNetAddress { atEntry 3 } Syntax: NetworkAddress Definition:
The NetworkAddress (e.g., the IP address) corresponding to the media dependent "physical" address.
The IP Group Implementation of the IP group is mandatory for all systems.
ipForwarding { ip 1 } Syntax: INTEGER { forwarding(1),
i.e., acting as a gateway not forwarding(2)   i.e., NOT acting as a gateway } Definition:
The indication of whether this entity is acting as an IP gateway in respect to the forwarding of datagrams received by, but not addressed to, this entity.
IP hosts do not (except those source routed via the host).
{ ip 2 } Syntax: INTEGER Definition:
The default value inserted into the Time To Live field of the IP header of datagrams originated at this entity, whenever a TTL value is not supplied by the transport layer protocol.
ipInReceives { ip 3 } Syntax:
The total number of input datagrams received from interfaces, including those received in error.
ipInHdrErrors { ip 4 } Syntax:
The number of input datagrams discarded due to errors in their IP headers, including bad checksums, version number mismatch, other format errors, time to live exceeded, errors discovered in processing their IP options, etc.
ipInAddrErrors { ip 5 } Syntax:
The number of input datagrams discarded because the IP address in their IP header's destination field was not a valid address to be received at this entity.
This count includes invalid addresses (e.g., 0.0.0.0) and addresses of unsupported Classes (e.g., Class E).
For entities which are not IP Gateways and therefore do not forward datagrams, this counter includes datagrams discarded because the destination address was not a local address.
{ ip 6 } Syntax:
The number of input datagrams for which this entity was not their final IP destination, as a result of which an attempt was made to find a route to forward them to that final destination.
In entities which do not act as IP Gateways, this counter will include only those packets which were Source Routed via this entity, and the Source Route option processing was successful.
ipInUnknownProtos { ip 7 } Syntax:
The number of locally addressed datagrams received successfully but discarded because of an unknown or unsupported protocol.
ipInDiscards { ip 8 } Syntax:
The number of input IP datagrams for which no problems were encountered to prevent their continued processing, but which were discarded (e.g., for lack of buffer space).
Note that this counter does not include any datagrams discarded while awaiting re assembly.
ipInDelivers { ip 9 } Syntax:
The total number of input datagrams successfully delivered to IP user protocols (including ICMP).
ipOutRequests { ip 10 } Syntax:
The total number of IP datagrams which local IP user  protocols (including ICMP) supplied to IP in requests for transmission.
Note that this counter does not include any datagrams counted in ipForwDatagrams.
ipOutDiscards { ip 11 } Syntax:
The number of output IP datagrams for which no problem was encountered to prevent their transmission to their destination, but which were discarded (e.g., for lack of buffer space).
Note that this counter would include datagrams counted in ipForwDatagrams if any such packets met this (discretionary) discard criterion.
The number of IP datagrams discarded because no route could be found to transmit them to their destination.
Note that this counter includes any packets counted in ipForwDatagrams which meet this "no route" criterion.
Note that this includes any datagarms which a host cannot route because all of its default gateways are down.
{ ip 13 } Syntax: INTEGER Definition:
The maximum number of seconds which received fragments are held while they are awaiting reassembly at this entity.
{ ip 14 } Syntax:
The number of IP fragments received which needed to be reassembled at this entity.
{ ip 15 } Syntax:
The number of IP datagrams successfully re assembled.
The number of failures detected by the IP re assembly algorithm (for whatever reason: timed out, errors, etc).
Note that this is not necessarily a count of discarded IP fragments since some algorithms (notably the algorithm in RFC 815) can lose track of the number of fragments by combining them as they are received.
ipFragOKs { ip 17 } Syntax:
The number of IP datagrams that have been successfully fragmented at this entity.
{ ip 18 } Syntax:
The number of IP datagrams that have been discarded because they needed to be fragmented at this entity but could not be, e.g., because their "Don't Fragment" flag was set.
The number of IP datagram fragments that have been generated as a result of fragmentation at this entity.
The IP Address table The Ip Address table contains this entity's IP addressing information.
{ ip 20 } Syntax: SEQUENCE OF IpAddrEntry Definition:
The table of addressing information relevant to this entity's IP addresses.
INTEGER, ipAdEntNetMask IpAddress, ipAdEntBcastAddr INTEGER, ipAdEntReasmMaxSize INTEGER (0
The addressing information for one of this entity's IP addresses.
{ ipAddrEntry 1 } Syntax: IpAddress Definition:
The IP address to which this entry's addressing information pertains.
{ ipAddrEntry 2 } Syntax: INTEGER Definition:
The index value which uniquely identifies the interface to which this entry is applicable.
The interface identified by a particular value of this index is the same interface as identified by the same value of ifIndex.
{ ipAddrEntry 3 } Syntax: IpAddress Definition:
The subnet mask associated with the IP address of this entry.
The value of the mask is an IP address with all the network bits set to 1 and all the hosts bits set to 0.
{ ipAddrEntry 4 } Syntax: INTEGER Definition:
The value of the least significant bit in the IP broadcast address used for sending datagrams on the (logical) interface associated with the IP address of this entry.
For example, when the Internet standard all ones broadcast address is used, the value will be 1.
This value applies to both the subnet and network broadcasts addresses used by the entity on this (logical) interface.
{ ipAddrEntry 5 } Syntax: INTEGER (0
The size of the largest IP datagram which this entity can re assemble from incoming IP fragmented datagrams received on this interface.
The IP Routing table contains an entry for each route presently known to this entity.
ipRoutingTable { ip 21 } Syntax: SEQUENCE OF IpRouteEntry Definition: This entity's IP Routing table.
, ipRouteType INTEGER, ipRouteProto INTEGER, ipRouteAge INTEGER
, ipRouteMask IpAddress } Definition:
A route to a particular destination.
We now consider the individual components of each route in the IP Routing table:
ipRouteEntry 1 } Syntax: IpAddress Definition:
The destination IP address of this route.
An entry with a value of 0.0.0.0 is considered a default route.
Multiple routes to a single destination can appear in the table, but access to such multiple entries is dependent on the table access mechanisms defined by the network management protocol in use.
{ ipRouteEntry 2 } Syntax: INTEGER Definition:
The index value which uniquely identifies the local interface through which the next hop of this route should be reached.
The interface identified by a particular value of this index is the same interface as identified by the same value of ifIndex.
The primary routing metric for this route.
The semantics of this metric are determined by the routing protocol specified in the route's ipRouteProto value.
If this metric is not used, its value should be set to  1.
An alternate routing metric for this route.
The semantics of this metric are determined by the routing  protocol specified in the route's ipRouteProto value.
If this metric is not used, its value should be set to  1.
ipRouteMetric3 { ipRouteEntry 5 } Syntax: INTEGER Definition:
An alternate routing metric for this route.
The semantics of this metric are determined by the routing  protocol specified in the route's ipRouteProto value.
If this metric is not used, its value should be set to  1.
ipRouteMetric4 { ipRouteEntry 6 } Syntax: INTEGER Definition:
An alternate routing metric for this route.
The semantics of this metric are determined by the routing  protocol specified in the route's ipRouteProto value.
If this metric is not used, its value should be set to  1.
ipRouteEntry 7 } Syntax: IpAddress Definition:
The IP address of the next hop of this route.
(In the case of a route bound to an interface which is realized via a broadcast media, the value of this field is the agent's IP address on that interface.)
Setting this object to the value invalid(2) has the effect of invalidating the corresponding entry in the ipRoutingTable object.
That is, it effectively disassociates the destination identified with said entry from the route identified with said entry.
It is an implementation specific matter as to whether the agent removes an invalidated entry from the table.
Accordingly, management stations must be prepared to receive tabular information from agents that corresponds to entries not currently in use.
Proper interpretation of such entries requires examination of the relevant ipRouteType object.
The routing mechanism via which this route was learned.
Inclusion of values for gateway routing protocols is not intended to imply that hosts should support those protocols.
{ ipRouteEntry 10 } Syntax: INTEGER Definition:
The number of seconds since this route was last updated or otherwise determined to be correct.
Note that no semantics of "too old" can be implied except through knowledge of the routing protocol by which the route was learned.
ipRouteMask { ipRouteEntry 11 } Syntax: IpAddress Definition:
Indicate the mask to be logical ANDed with the destination address before being compared to the value in the ipRouteDest field.
If the value of the ipRouteDest is 0.0.0.0 (a default route), then the mask value is also 0.0.0.0.
It should be noted that all IP routing subsystems implicitly use this mechanism.
The IP Address Translation table
The Address Translation tables contain the IpAddress to "physical" address equivalences.
Some interfaces do not use translation tables for determining address equivalences (e.g., DDN X.25 has an algorithmic method); if all interfaces are of this type, then the Address Translation table is empty, i.e., has zero entries.
{ ip 22 } Syntax: SEQUENCE OF IpNetToMediaEntry Definition:
The IP Address Translation table used for mapping from IP addresses to physical addresses.
STRING, ipNetToMediaNetAddress IpAddress, ipNetToMediaType INTEGER } Definition: Each entry contains one IpAddress to "physical" address equivalence.
We now consider the individual components of each IP Address Translation table entry: OBJECT:   ipNetToMediaIfIndex { ipNetToMediaEntry
1 } Syntax: INTEGER Definition:
The interface on which this entry's equivalence is effective.
The interface identified by a particular value of this index is the same interface as identified by the same value of ifIndex.
2 } Syntax: OCTET STRING Definition:
The media dependent "physical" address.
ipNetToMediaNetAddress { ipNetToMediaEntry 3 } Syntax: IpAddress Definition:
The IpAddress corresponding to the media dependent "physical" address.
Setting this object to the value invalid(2) has the effect of invalidating the corresponding entry in the ipNetToMediaTable.
That is, it effectively disassociates the interface identified with said entry from the mapping identified with said entry.
It is an implementation specific matter as to whether the agent removes an invalidated entry from the table.
Accordingly, management stations must be prepared to receive tabular information from agents that corresponds to entries not currently in use.
Proper interpretation of such entries requires examination of the relevant ipNetToMediaType object.
The ICMP Group Implementation of the ICMP group is mandatory for all systems.
The ICMP group contains the ICMP input and output statistics.
icmpInMsgs { icmp 1 } Syntax:
The total number of ICMP messages which the entity received.
Note that this counter includes all those counted by icmpInErrors.
icmpInErrors { icmp 2 } Syntax:
The number of ICMP messages which the entity received but determined as having ICMP specific errors (bad ICMP checksums, bad length, etc.).
{ icmp 3 } Syntax:
The number of ICMP Destination Unreachable messages received.
icmpInTimeExcds { icmp 4 } Syntax:
The number of ICMP Time Exceeded messages received.
icmpInParmProbs { icmp 5 } Syntax:
The number of ICMP Parameter Problem messages received.
{ icmp 6 } Syntax:
The number of ICMP Source Quench messages received.
icmpInRedirects { icmp 7 }
The number of ICMP Redirect messages received.
icmpInEchos { icmp 8 } Syntax:
The number of ICMP Echo (request) messages received.
{ icmp 9 } Syntax:
The number of ICMP Echo Reply messages received.
icmpInTimestamps { icmp 10 }
The number of ICMP Timestamp (request) messages received.
icmpInTimestampReps { icmp 11 } Syntax:
The number of ICMP Timestamp Reply messages received.
{ icmp 12 } Syntax:
The number of ICMP Address Mask Request messages received.
icmpInAddrMaskReps { icmp 13 }
The number of ICMP Address Mask Reply messages received.
{ icmp 14 } Syntax:
The total number of ICMP messages which this entity attempted to send.
Note that this counter includes all those counted by icmpOutErrors.
{ icmp 15 } Syntax:
The number of ICMP messages which this entity did not send due to problems discovered within ICMP such as a lack of buffers.
This value should not include errors discovered outside the ICMP layer such as the inability of IP to route the resultant datagram.
In some implementations there may be no types of error which contribute to this counter's value.
icmpOutDestUnreachs { icmp 16 }
The number of ICMP Destination Unreachable messages sent.
{ icmp 17 } Syntax:
The number of ICMP Time Exceeded messages sent.
icmpOutParmProbs { icmp 18 } Syntax:
The number of ICMP Parameter Problem messages sent.
icmpOutSrcQuenchs { icmp 19 } Syntax:
The number of ICMP Source Quench messages sent.
{ icmp 20 } Syntax:
The number of ICMP Redirect messages sent.
For a host, this object will always be zero, since hosts do not send redirects.
{ icmp 21 } Syntax:
The number of ICMP Echo (request) messages sent.
icmpOutEchoReps { icmp 22 } Syntax:
The number of ICMP Echo Reply messages sent.
{ icmp 23 } Syntax:
The number of ICMP Timestamp (request) messages sent.
{ icmp 24 } Syntax:
The number of ICMP Timestamp Reply messages sent.
icmpOutAddrMasks { icmp 25 }
The number of ICMP Address Mask Request messages sent.
icmpOutAddrMaskReps { icmp 26 } Syntax:
The number of ICMP Address Mask Reply messages sent.
The TCP Group Implementation of the TCP group is mandatory for all systems that implement the TCP.
Note that instances of object types that represent information about a particular TCP connection are transient; they persist only as long as the connection in question.
The algorithm used to determine the timeout value used for retransmitting unacknowledged octets.
{ tcp 2 } Syntax: INTEGER Definition:
The minimum value permitted by a TCP implementation for the retransmission timeout, measured in milliseconds.
More refined semantics for objects of this type depend upon the algorithm used to determine the retransmission timeout.
In particular, when the timeout algorithm is rsre(3), an object of this type has the semantics of the LBOUND quantity described in RFC 793.
{ tcp 3 } Syntax: INTEGER Definition:
The maximum value permitted by a TCP implementation for the retransmission timeout, measured in milliseconds.
More refined semantics for objects of this type depend upon the algorithm used to determine the retransmission timeout.
In particular, when the timeout algorithm is rsre(3), an object of this type has the semantics of the UBOUND quantity described in RFC 793.
{ tcp 4 } Syntax: INTEGER Definition:
The limit on the total number of TCP connections the entity can support.
In entities where the maximum number of connections is dynamic, this object should contain the value " 1".
{ tcp 5 } Syntax:
The number of times TCP connections have made a direct transition to the SYN SENT state from the CLOSED state.
tcpPassiveOpens { tcp 6 } Syntax: Counter Definition:
The number of times TCP connections have made a direct transition to the SYN RCVD state from the LISTEN state.
{ tcp 7 } Syntax:
The number of times TCP connections have made a direct transition to the CLOSED state from either the SYN SENT state or the SYN RCVD state, plus the number of times TCP connections have made a direct transition to the LISTEN state from the SYN RCVD state.
{ tcp 8 } Syntax:
The number of times TCP connections have made a direct transition to the CLOSED state from either the ESTABLISHED state or the CLOSE WAIT state.
{ tcp 9 } Syntax: Gauge Definition:
The number of TCP connections for which the current state is either ESTABLISHED or CLOSE WAIT.
{ tcp 10 } Syntax:
The total number of segments received, including those received in error.
This count includes segments received on currently established connections.
{ tcp 11 } Syntax:
The total number of segments sent, including those on current connections but excluding those containing only retransmitted octets.
{ tcp 12 } Syntax:
The total number of segments retransmitted that is, the number of TCP segments transmitted containing one or more previously transmitted octets.
The TCP connection table contains information about this entity's existing TCP connections.
{ tcp 13 } Syntax: SEQUENCE OF TcpConnEntry Definition:
A table containing TCP connection specific information.
tcpConnEntry { tcpConnTable 1 } Syntax:
} Definition: Information about a particular current TCP connection.
An object of this type is transient, in that it ceases to exist when (or soon after)
the connection makes the transition to the CLOSED state.
tcpConnEntry 1 } Syntax: INTEGER { closed(1), listen(2), synSent(3), synReceived(4), established(5), finWait1(6), finWait2(7), closeWait(8), lastAck(9), closing(10), timeWait(11
The state of this TCP connection.
tcpConnLocalAddress { tcpConnEntry 2 } Syntax: IpAddress Definition:
The local IP address for this TCP connection.
In the case of a connection in the listen state which is willing to accept connections for any IP interface associated with the node, the value 0.0.0.0 is used.
tcpConnLocalPort { tcpConnEntry 3 } Syntax: INTEGER (0
The local port number for this TCP connection.
tcpConnEntry 4 } Syntax: IpAddress Definition:
The remote IP address for this TCP connection.
The remote port number for this TCP connection.
tcpInErrs { tcp 14 } Syntax:
The total number of segments received in error (e.g., bad TCP checksums).
{ tcp 15 } Syntax:
The number of TCP segments sent containing the RST flag.
The UDP Group Implementation of the UDP group is mandatory for all systems which implement the UDP.
udpInDatagrams { udp 1 } Syntax:
The total number of UDP datagrams delivered to UDP users.
udpNoPorts { udp 2 } Syntax:
The total number of received UDP datagrams for which there was no application at the destination port.
udpInErrors { udp 3 } Syntax:
The number of received UDP datagrams that could not be delivered for reasons other than the lack of an application at the destination port.
udpOutDatagrams { udp 4 } Syntax:
The total number of UDP datagrams sent from this entity.
The UDP listener table contains information about this entity's UDP end points on which a local application is currently accepting datagrams.
udpTable { udp 5 } Syntax: SEQUENCE OF UdpEntry Definition:
A table containing UDP listener information.
} Definition: Information about a particular current UDP listener.
{ udpEntry 1 } Syntax: IpAddress Definition:
The local IP address for this UDP listener.
In the case of a UDP listener which is willing to accept datagrams for any IP interface associated with the node, the value 0.0.0.0 is used.
udpLocalPort { udpEntry 2 } Syntax: INTEGER (0
The local port number for this UDP listener.
The EGP Group Implementation of the EGP group is mandatory for all systems which implement the EGP.
egpInMsgs { egp 1 } Syntax:
The number of EGP messages received without error.
egpInErrors { egp 2 }
The number of EGP messages received that proved to be in error.
The total number of locally generated EGP messages.
egpOutErrors { egp 4 }
The number of locally generated EGP messages not sent due to resource limitations within an EGP entity.
The Egp Neighbor table contains information about this entity's EGP neighbors.
{ egp 5 } Syntax: SEQUENCE OF EgpNeighEntry Definition:
egpNeighAs INTEGER, egpNeighInMsgs Counter, egpNeighInErrs Counter, egpNeighOutMsgs
egpNeighInErrMsgs Counter, egpNeighOutErrMsgs Counter, egpNeighStateUps Counter,
egpNeighStateDowns Counter, egpNeighIntervalHello INTEGER, egpNeighIntervalPoll INTEGER, egpNeighMode INTEGER, egpNeighEventTrigger INTEGER } Definition:
Information about this entity's relationship with a particular EGP neighbor.
We now consider the individual components of each EGP neighbor entry:
egpNeighState { egpNeighEntry 1 } Syntax: INTEGER { idle(1), acquisition(2), down(3), up(4), cease(5)
The EGP state of the local system with respect to this entry's EGP neighbor.
Each EGP state is represented by a value that is one greater than the numerical value associated with said state in RFC 904.
egpNeighAddr { egpNeighEntry 2 } Syntax: IpAddress Definition:
The IP address of this entry's EGP neighbor.
{ egpNeighEntry 3 } Syntax:
The autonomous system of this EGP peer.
Zero should be specified if the autonomous system number of the neighbor is not yet known.
The number of EGP messages received without error from this EGP peer.
{ egpNeighEntry 5 } Syntax:
The number of EGP messages received from this EGP peer that proved to be in error (e.g., bad EGP checksum).
{ egpNeighEntry 6 } Syntax:
The number of locally generated EGP messages to this EGP peer.
{ egpNeighEntry 7 } Syntax:
The number of locally generated EGP messages not sent to this EGP peer due to resource limitations within an EGP entity.
{ egpNeighEntry 8 } Syntax:
The number of EGP defined error messages received from this EGP peer.
The number of EGP defined error messages sent to this EGP peer.
The number of EGP state transitions to the UP state with this EGP peer.
egpNeighStateDowns { egpNeighEntry 11 }
The number of EGP state transitions from the UP state to any other state with this EGP peer.
egpNeighIntervalHello { egpNeighEntry 12 } Syntax: INTEGER Definition:
The interval between EGP Hello command retransmissions (in hundredths of a second).
This represents the t1 timer as defined in RFC 904.
egpNeighIntervalPoll { egpNeighEntry 13 } Syntax: INTEGER Definition:
The interval between EGP poll command retransmissions (in hundredths of a second).
This represents the t3 timer as defined in RFC 904.
{ egpNeighEntry 14 } Syntax: INTEGER { active(1), passive(2) } Definition:
The polling mode of this EGP entity, either passive or active.
} Syntax: INTEGER { start(1), stop(2)
A control variable used to trigger operator initiated Start and Stop events.
When read, this variable always returns the most recent value that egpNeightEventTrigger was set to.
If it has not been set since the last initialization of the network management subsystem on the node, it returns a value of "stop".
Access: read write Status: mandatory.
egpAs { egp 6 }
The autonomous system number of this EGP entity.
The Transmission Group Based on the transmission media underlying each interface on a system, the corresponding portion of the Transmission group is mandatory for that system.
When Internet standard definitions for managing transmission media are defined, the transmission group is used to provide a prefix for the names of those objects.
Typically, such definitions reside in the experimental portion of the MIB until they are "proven", then as a part of the Internet standardization process, the definitions are accordingly elevated and a new object identifier, under the transmission group is defined.
The SNMP Group Implementation of the SNMP group is mandatory for all systems which support an SNMP protocol entity.
Some of the objects defined below will be zero valued in those SNMP implementations that are optimized to support only those functions specific to either a management agent or a management client.
{ snmp 1 } Syntax:
The total number of PDUs delivered to the SNMP entity from the transport service.
{ snmp 2 } Syntax:
The total number of SNMP PDUs which were passed from the SNMP protocol entity to the transport service.
The total number of syntactically correct SNMP PDUs which were delivered to the SNMP protocol entity and were for an unsupported SNMP version.
snmpInBadCommunityNames { snmp 4 }
The total number of SNMP PDUs delivered to the SNMP protocol entity which used a SNMP community name not known to said entity.
snmpInBadCommunityUses { snmp 5 }
The total number of SNMP PDUs delivered to the SNMP protocol entity which represented an SNMP operation which was not allowed by the SNMP community named in the PDU.
The total number of ASN.1 parsing errors (either in encoding or syntax) encountered by the SNMP protocol entity when decoding received SNMP PDUs.
snmpInBadTypes { snmp 7 } Syntax:
The total number of SNMP PDUs delivered to the SNMP protocol entity which had an unknown PDU type.
snmpInTooBigs { snmp 8 }
The total number valid SNMP PDUs which were delivered to the SNMP protocol entity and for which the value of the "ErrorStatus" component is "tooBig.
snmpInNoSuchNames { snmp 9 }
The total number valid SNMP PDUs which were delivered to the SNMP protocol entity and for which the value of the "ErrorStatus" component is "noSuchName.
snmpInBadValues { snmp 10 } Syntax:
The total number valid SNMP PDUs which were delivered to the SNMP protocol entity and for which the value of the "ErrorStatus" component is "badValue.
snmpInReadOnlys { snmp 11 } Syntax:
The total number valid SNMP PDUs which were delivered to the SNMP protocol entity and for which the value of the "ErrorStatus" component is "readOnly.
{ snmp 12 } Syntax:
The total number valid SNMP PDUs which were delivered to the SNMP protocol entity and for which the value of the "ErrorStatus" component is "genErr.
snmpInTotalReqVars { snmp 13 }
The total number of MIB objects which have been retrieved successfully by the SNMP protocol entity as the result of receiving valid SNMP Get Request and Get Next PDUs.
snmpInTotalSetVars { snmp 14 }
The total number of MIB objects which have been altered successfully by the SNMP protocol entity as the result of receiving valid SNMP Set Request PDUs.
snmpInGetRequests { snmp 15 } Syntax:
The total number of SNMP Get Request PDUs which have been accepted and processed by the SNMP protocol entity.
snmpInGetNexts { snmp 16 } Syntax:
The total number of SNMP Get Next PDUs which have been accepted and processed by the SNMP protocol entity.
snmpInSetRequests { snmp 17 } Syntax:
The total number of SNMP Set Request PDUs which have been accepted and processed by the SNMP protocol entity.
snmpInGetResponses { snmp 18 } Syntax:
The total number of SNMP Get Response PDUs which have been accepted and processed by the SNMP protocol entity.
snmpInTraps { snmp 19 }
The total number of SNMP Trap PDUs which have been accepted and processed by the SNMP protocol entity.
snmpOutTooBigs { snmp 20 }
The total number valid SNMP PDUs which were generated by the SNMP protocol entity and for which the value of the "ErrorStatus" component is "tooBig.
snmpOutNoSuchNames { snmp 21 } Syntax:
The total number valid SNMP PDUs which were generated by the SNMP protocol entity and for which the value of the "ErrorStatus" component is "noSuchName.
snmpOutBadValues { snmp 22 }
The total number valid SNMP PDUs which were generated by the SNMP protocol entity and for which the value of the "ErrorStatus" component is "badValue.
The total number valid SNMP PDUs which were generated by the SNMP protocol entity and for which the value of the "ErrorStatus" component is "readOnly.
snmpOutGenErrs { snmp 24 } Syntax:
The total number valid SNMP PDUs which were generated by the SNMP protocol entity and for which the value of the "ErrorStatus" component is "genErr.
snmpOutGetRequests { snmp 25 }
The total number of SNMP Get Request PDUs which have been generated by the SNMP protocol entity.
The total number of SNMP Get Next PDUs which have been generated by the SNMP protocol entity.
snmpOutSetRequests { snmp 27 }
The total number of SNMP Set Request PDUs which have been generated by the SNMP protocol entity.
{ snmp 28 } Syntax:
The total number of SNMP Get Response PDUs which have been generated by the SNMP protocol entity.
{ snmp 29 } Syntax:
The total number of SNMP Trap PDUs which have been generated by the SNMP protocol entity.
snmpEnableAuthTraps { snmp 30 } Syntax: INTEGER { enabled(1), disabled(2)
} Definition: Indicates whether the SNMP agent process is configured to generate authentication failure traps.
} sysObjectID OBJECT TYPE SYNTAX
ACCESS  read only STATUS  mandatory ::
{ system 6 } sysServices OBJECT TYPE SYNTAX
the Interfaces group ifNumber OBJECT TYPE SYNTAX
SEQUENCE OF IfEntry ACCESS  read only STATUS  mandatory ::
{ interfaces 2 } ifEntry OBJECT TYPE SYNTAX
, ifLastChange TimeTicks, ifInOctets Counter, ifInUcastPkts Counter, ifInNUcastPkts Counter, ifInDiscards Counter, ifInErrors Counter, ifInUnknownProtos Counter, ifOutOctets Counter, ifOutUcastPkts Counter, ifOutNUcastPkts Counter, ifOutDiscards Counter, ifOutErrors Counter,
ifOutQLen Gauge, ifSpecific OBJECT IDENTIFIER } ifIndex OBJECT
INTEGER ACCESS  read only STATUS  mandatory ::
{ ifEntry 1 } ifDescr OBJECT TYPE SYNTAX
ACCESS  read only STATUS  mandatory ::
{ ifEntry 2 } ifType OBJECT
read only STATUS  mandatory ::
{ ifEntry 5 } ifPhysAddress OBJECT
in some test mode } ACCESS  read write STATUS
in some test mode } ACCESS  read only STATUS  mandatory ::
{ ifEntry 8 } ifLastChange OBJECT
read only STATUS  mandatory ::
{ ifEntry 9 } ifInOctets OBJECT TYPE SYNTAX
read only STATUS  mandatory ::
{ ifEntry 10 } ifInUcastPkts OBJECT TYPE SYNTAX
read only STATUS  mandatory ::
{ ifEntry 11 } ifInNUcastPkts OBJECT
read only STATUS  mandatory ::
{ ifEntry 12 } ifInDiscards OBJECT
read only STATUS  mandatory ::
{ ifEntry 13 } ifInErrors OBJECT
read only STATUS  mandatory ::
{ ifEntry 14 } ifInUnknownProtos OBJECT TYPE SYNTAX
read only STATUS  mandatory ::
{ ifEntry 16 } ifOutUcastPkts OBJECT
read only STATUS  mandatory ::
{ ifEntry 17 } ifOutNUcastPkts OBJECT TYPE SYNTAX
read only STATUS  mandatory ::
{ ifEntry 18 } ifOutDiscards OBJECT TYPE SYNTAX
read only STATUS  mandatory ::
{ ifEntry 19 } ifOutErrors OBJECT
read only STATUS  mandatory ::
atEntry 2 } atNetAddress OBJECT TYPE SYNTAX
entity does NOT   forward datagrams }
read only STATUS  mandatory ::
{ ip 3 } ipInHdrErrors OBJECT TYPE SYNTAX
read only STATUS  mandatory ::
{ ip 6 } ipInUnknownProtos OBJECT TYPE SYNTAX
read only STATUS  mandatory ::
{ ip 7 } ipInDiscards OBJECT TYPE SYNTAX
read only STATUS  mandatory ::
{ ip 10 } ipOutDiscards OBJECT
} ipReasmTimeout OBJECT TYPE SYNTAX
read only STATUS  mandatory ::
{ ip 14 } ipReasmOKs OBJECT TYPE SYNTAX
} ipFragOKs OBJECT TYPE SYNTAX
read only STATUS  mandatory ::
{ ip 17 } ipFragFails OBJECT TYPE SYNTAX
SEQUENCE OF IpAddrEntry ACCESS  read only STATUS  mandatory ::
{ ip 20 } ipAddrEntry OBJECT TYPE SYNTAX
INTEGER, ipAdEntNetMask IpAddress, ipAdEntBcastAddr INTEGER, ipAdEntReasmMaxSize INTEGER (0..65535) } ipAdEntAddr
read only STATUS  mandatory :
INTEGER ACCESS  read only STATUS  mandatory :
{ ipAddrEntry 2 } ipAdEntNetMask OBJECT TYPE SYNTAX  IpAddress ACCESS
read only STATUS  mandatory :
{ ip 21 } ipRouteEntry OBJECT
, ipRouteType INTEGER, ipRouteProto INTEGER, ipRouteAge INTEGER,
ipRouteMask IpAddress } ipRouteDest OBJECT
{ ipRouteEntry 2 } ipRouteMetric1 OBJECT TYPE SYNTAX
{ ipRouteEntry 4 } ipRouteMetric3 OBJECT TYPE
{ ipRouteEntry 5 } ipRouteMetric4 OBJECT
} ipRouteNextHop OBJECT TYPE SYNTAX
{ ipRouteEntry 7 } ipRouteType OBJECT TYPE SYNTAX
(sub )network   route to a non local remote(4)
the following are   gateway routing   protocols egp(5), ggp(6), hello(7), rip(8), is is(9), es is(10), ciscoIgrp(11), bbnSpfIgp(12), ospf(13) bgp(14)
:  SEQUENCE { ipNetToMediaIfIndex INTEGER, ipNetToMediaPhysAddress OCTET STRING, ipNetToMediaNetAddress IpAddress, ipNetoToMediaType INTEGER } ipNetToMediaIfIndex
read only STATUS  mandatory ::
{ icmp 1 } icmpInErrors OBJECT
read only STATUS  mandatory ::
{ icmp 6 } icmpInRedirects OBJECT TYPE SYNTAX
} icmpInEchoReps OBJECT TYPE SYNTAX
read only STATUS  mandatory ::
{ icmp 12 } icmpInAddrMaskReps OBJECT
read only STATUS  mandatory ::
{ icmp 15 } icmpOutDestUnreachs OBJECT
read only STATUS  mandatory ::
{ icmp 16 } icmpOutTimeExcds OBJECT TYPE SYNTAX
read only STATUS  mandatory ::
{ icmp 17 } icmpOutParmProbs OBJECT TYPE SYNTAX
read only STATUS  mandatory ::
{ icmp 18 } icmpOutSrcQuenchs OBJECT TYPE SYNTAX
read only STATUS  mandatory ::
{ icmp 23 } icmpOutTimestampReps OBJECT
the TCP group tcpRtoAlgorithm OBJECT TYPE SYNTAX
Van Jacobson's   algorithm } ACCESS  read only STATUS  mandatory ::
{ tcp 1 } tcpRtoMin OBJECT TYPE SYNTAX
SEQUENCE OF TcpConnEntry ACCESS  read only STATUS  mandatory ::
{ tcp 13 } tcpConnEntry OBJECT TYPE SYNTAX
INTEGER { closed(1), listen(2), synSent(3), synReceived(4), established(5), finWait1(6), finWait2(7), closeWait(8), lastAck(9), closing(10), timeWait(11) }
read only STATUS  mandatory ::
{ tcpConnEntry 1 } tcpConnLocalAddress OBJECT
ACCESS  read only STATUS  mandatory ::
{ tcpConnEntry 3 } tcpConnRemAddress OBJECT TYPE SYNTAX
read only STATUS  mandatory ::
{ tcpConnEntry 4 } tcpConnRemPort OBJECT TYPE SYNTAX
} tcpOutRsts OBJECT TYPE SYNTAX
the UDP group udpInDatagrams OBJECT
read only STATUS  mandatory ::
{ udp 2 } udpInErrors OBJECT
read only STATUS  mandatory ::
{ egp 1 } egpInErrors OBJECT
egpNeighAs INTEGER, egpNeighInMsgs Counter, egpNeighInErrs Counter, egpNeighOutMsgs
egpNeighInErrMsgs Counter, egpNeighOutErrMsgs Counter, egpNeighStateUps Counter,
egpNeighStateDowns Counter, egpNeighIntervalHello INTEGER, egpNeighIntervalPoll INTEGER, egpNeighMode INTEGER, egpNeighEventTrigger INTEGER }
INTEGER { idle(1), acquisition(2), down(3), up(4)
INTEGER ACCESS  read only STATUS  mandatory ::
{ egpNeighEntry 3 } egpNeighInMsgs OBJECT TYPE SYNTAX
} egpNeighOutErrs OBJECT TYPE SYNTAX
read only STATUS  mandatory ::
{ egpNeighEntry 8 } egpNeighOutErrMsgs OBJECT
read only STATUS  mandatory ::
{ egpNeighEntry 10 } egpNeighStateDowns OBJECT TYPE SYNTAX
INTEGER { start(1), stop(2) }
read only STATUS  mandatory ::
{ snmp 3 } snmpInBadCommunityNames OBJECT TYPE SYNTAX
read only STATUS  mandatory ::
{ snmp 6 } snmpInBadTypes OBJECT
{ snmp 8 } snmpInNoSuchNames OBJECT
read only STATUS  mandatory ::
{ snmp 9 } snmpInBadValues OBJECT
read only STATUS  mandatory :
{ snmp 17 } snmpInGetResponses OBJECT
read only STATUS  mandatory :
read only STATUS  mandatory ::
read only STATUS  mandatory :
{ snmp 29 } snmpEnableAuthTraps OBJECT TYPE SYNTAX
INTEGER { enabled(1), disabled(2) } ACCESS
Identification of OBJECT instances for use with the SNMP
The names for all object types in the MIB are defined explicitly either in the Internet standard MIB or in other documents which conform to the naming conventions of the SMI.
The SMI requires that conformant management protocols define mechanisms for identifying individual instances of those object types for a particular network element.
Each instance of any object type defined in the MIB is identified in SNMP operations by a unique name called its "variable name.
In general, the name of an SNMP variable is an OBJECT IDENTIFIER of the form x.y, where x is the name of a non aggregate object type defined in the MIB and y is an OBJECT IDENTIFIER fragment that, in a way specific to the named object type, identifies the desired instance.
This naming strategy admits the fullest exploitation of the semantics of the powerful SNMP get next operator, because it assigns names for related variables so as to be contiguous in the lexicographical ordering of all variable names known in the MIB.
The type specific naming of object instances is defined below for a number of classes of object types.
Instances of an object type to which none of the following naming conventions are applicable are named by OBJECT IDENTIFIERs of the form x.0, where x is the name of said object type in the MIB definition.
For example, suppose one wanted to identify an instance of the variable sysDescr.
The object class for sysDescr is: iso org dod internet mgmt mib system sysDescr
Hence, the object type, x, would be 1.3.6.1.2.1.1.1 to which is appended an instance sub identifier of 0.
That is, 1.3.6.1.2.1.1.1.0 identifies the one and only instance of sysDescr.
The name of a subnetwork interface, s, is the OBJECT IDENTIFIER value of the form
i, where i has the value of that instance of the ifIndex object type associated with s.  For each object type, t, for which the defined name, n, has a prefix of ifEntry, an instance, i, of t is named by an OBJECT IDENTIFIER of the form
n.s, where s is the name of the subnetwork interface about which i represents information.
For example, suppose one wanted to identify the instance of the variable ifType associated with interface 2.
Accordingly, ifType.2 would identify the desired instance.
The name of an address translation entry, x, is an OBJECT IDENTIFIER of the form s.1.a.b.c.d, such that s is the value of that instance of the atIfIndex object type associated with x, the subidentifer "1" signifies the translation of an IP protocol address, and a.b.c.d is the IP address value (in the familiar "dot" notation) of that instance of the atNetAddress object type associated with x.
For each object type, t, for which the defined name, n, has a prefix of atEntry, an instance, i, of t is named by an OBJECT IDENTIFIER of the form n.y, where y is the name of the address translation entry about which i represents information.
For example, suppose one wanted to find the physical address of an entry in the address translation table (ARP cache) associated with an IP address of 89.1.1.42 and interface 3.
Accordingly, atPhysAddress.3.1.89.1.1.42 would identify the desired instance.
The name of an IP addressable network element, x, is the OBJECT IDENTIFIER of the form a.b.c.d
such that a.b.c.d is the value (in the familiar "dot" notation) of that instance of the ipAdEntAddr object type associated with x.
For each object type, t, for which the defined name, n, has a prefix of ipAddrEntry, an instance, i, of t is named by an OBJECT IDENTIFIER of the form n.y, where y is the name of the IP  addressable network element about which i represents information.
For example, suppose one wanted to find the network mask of an entry in the IP interface table associated with an IP address of 89.1.1.42.
Accordingly, ipAdEntNetMask.89.1.1.42 would identify the desired instance.
At the option of the agent, multiple entries for the same IP address may be visible.
To realize this, the agent, while required to return a single entry for an IP address, x, of the form n.y, may also return information about other entries for the same IP address using the form
n.y.z, where z is a implementation dependendent small, non  negative integer.
It is strongly recommended that the value of z correspond to the value of ipAddrIfIndex for that entry.
The name of an IP route, x, is the OBJECT IDENTIFIER of the form a.b.c.d
such that a.b.c.d is the value (in the familiar "dot" notation) of that instance of the ipRouteDest object type associated with x.
For each object type, t, for which the defined name, n, has a prefix of ipRoutingEntry, an instance, i, of t is named by an OBJECT IDENTIFIER of the form n.y, where y is the name of the IP route about which i represents information.
For example, suppose one wanted to find the next hop of an entry in the IP routing table associated  with the destination of 89.1.1.42.
Accordingly, ipRouteNextHop.89.1.1.42 would identify the desired instance.
At the option of the agent, multiple routes to the same destination may be visible.
To realize this, the agent, while required to return a single entry for an IP route, x, of the form n.y, may also return information about other routes to the same destination using the form
n.y.z, where z is a implementation dependendent small, non negative integer.
The name of a cached IP address, x, is an OBJECT IDENTIFIER of the form s.a.b.c.d, such that s is the value of that instance of the ipNetToMediaIfIndex object type associated with the entry and a.b.c.d is the value (in the familiar "dot" notation) of the ipNetToMediaNetAddress object type associated with x.
For each object type, t, for which the defined name, n, has a prefix of ipNetToMediaEntry, an instance, i, of t is named by an OBJECT IDENTIFIER of the form n.y, where y is the name of the cached IP address about which i represents information.
For example, suppose one wanted to find the media address of an entry in the address translation table associated with a IP address of 192.52.180.1 and interface 3.
Accordingly, ipNetToMediaPhysAddress.3.192.52.180.1 would identify the desired instance.
The name of a TCP connection, x, is the OBJECT IDENTIFIER of the form a.b.c.d.e.f.g.h.i.j
such that a.b.c.d is the value (in the familiar "dot" notation) of that instance of the tcpConnLocalAddress object type associated with x and
such that f.g.h.i is the value (
in the familiar "dot" notation) of that instance of the tcpConnRemoteAddress object type associated with x and such that e is the value of that instance of the tcpConnLocalPort object type associated with x and such that j is the value of that instance of the tcpConnRemotePort object type associated with x.
For each object type, t, for which the defined name, n, has a prefix of  tcpConnEntry, an instance, i, of t is named by an OBJECT IDENTIFIER of the form n.y, where y is the name of the TCP connection about which i represents information.
For example, suppose one wanted to find the state of a TCP connection between the local address of 89.1.1.42 on TCP port 21 and the remote address of 10.0.0.51 on TCP port 2059.
Accordingly, tcpConnState.89.1.1.42.21.10.0.0.51.2059 would identify the desired instance.
The name of a UDP listener, x, is the OBJECT IDENTIFIER of the form a.b.c.d.e.
such that a.b.c.d is the value (in the familiar "dot" notation) of that instance of the udpLocalAddress object type associated with x and such that e is the value of that instance of the udpLocalPort object type associated with x.
For each object type, t, for which the defined name, n, has a prefix of udpEntry, an instance, i, of t is named by an OBJECT IDENTIFIER of the form n.y, where y is the name of the UDP listener about which i represents information.
For example, suppose one wanted to determine if a UDP listener was present at the local address of 89.1.1.42 on UDP port 21.
Accordingly, a successful retrieval of either udpLocalAddress.89.1.1.42.21 or udpLocalPort.89.1.1.42.21 would indicate this.
The name of an EGP neighbor, x, is the OBJECT IDENTIFIER of the form a.b.c.d
such that a.b.c.d is the value (in the familiar "dot" notation) of that instance of the egpNeighAddr object type associated with x.
For each object type, t, for which the defined name, n, has a prefix of egpNeighEntry, an instance, i, of t is named by an OBJECT IDENTIFIER of the form n.y, where y is the name of the EGP neighbor about which i represents information.
For example, suppose one wanted to find the neighbor state for the IP address of 89.1.1.42.
Accordingly, egpNeighState.89.1.1.42 would identify the desired instance.
Security Considerations Security issues are not discussed in this memo.
