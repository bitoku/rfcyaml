- title: __initial_text__
  contents:
  - ''
- title: Internet Research Task Force (IRTF)                            D. McGrew
  contents:
  - "Internet Research Task Force (IRTF)                            D. McGrew\n  \
    \               Leighton-Micali Hash-Based Signatures\n"
- title: Abstract
  contents:
  - "Abstract\n   This note describes a digital-signature system based on cryptographic\n\
    \   hash functions, following the seminal work in this area of Lamport,\n   Diffie,\
    \ Winternitz, and Merkle, as adapted by Leighton and Micali in\n   1995.  It specifies\
    \ a one-time signature scheme and a general\n   signature scheme.  These systems\
    \ provide asymmetric authentication\n   without using large integer mathematics\
    \ and can achieve a high\n   security level.  They are suitable for compact implementations,\
    \ are\n   relatively simple to implement, and are naturally resistant to side-\n\
    \   channel attacks.  Unlike many other signature systems, hash-based\n   signatures\
    \ would still be secure even if it proves feasible for an\n   attacker to build\
    \ a quantum computer.\n   This document is a product of the Crypto Forum Research\
    \ Group (CFRG)\n   in the IRTF.  This has been reviewed by many researchers, both\
    \ in the\n   research group and outside of it.  The Acknowledgements section lists\n\
    \   many of them.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Research Task Force\n   (IRTF).  The IRTF publishes the results\
    \ of Internet-related research\n   and development activities.  These results\
    \ might not be suitable for\n   deployment.  This RFC represents the consensus\
    \ of the Crypto Forum\n   Research Group of the Internet Research Task Force (IRTF).\
    \  Documents\n   approved for publication by the IRSG are not candidates for any\
    \ level\n   of Internet Standard; see Section 2 of RFC 7841.\n   Information about\
    \ the current status of this document, any errata,\n   and how to provide feedback\
    \ on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8554.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2019 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   3\n     1.1.  CFRG Note on Post-Quantum Cryptography  . . . . .\
    \ . . . .   5\n     1.2.  Intellectual Property . . . . . . . . . . . . . . .\
    \ . . .   6\n       1.2.1.  Disclaimer  . . . . . . . . . . . . . . . . . . .\
    \ . .   6\n     1.3.  Conventions Used in This Document . . . . . . . . . . .\
    \ .   6\n   2.  Interface . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \   6\n   3.  Notation  . . . . . . . . . . . . . . . . . . . . . . . . . .  \
    \ 7\n     3.1.  Data Types  . . . . . . . . . . . . . . . . . . . . . . .   7\n\
    \       3.1.1.  Operators . . . . . . . . . . . . . . . . . . . . . .   7\n  \
    \     3.1.2.  Functions . . . . . . . . . . . . . . . . . . . . . .   8\n    \
    \   3.1.3.  Strings of w-Bit Elements . . . . . . . . . . . . . .   8\n     3.2.\
    \  Typecodes . . . . . . . . . . . . . . . . . . . . . . . .   9\n     3.3.  Notation\
    \ and Formats  . . . . . . . . . . . . . . . . . .   9\n   4.  LM-OTS One-Time\
    \ Signatures  . . . . . . . . . . . . . . . . .  12\n     4.1.  Parameters  .\
    \ . . . . . . . . . . . . . . . . . . . . . .  13\n     4.2.  Private Key . .\
    \ . . . . . . . . . . . . . . . . . . . . .  14\n     4.3.  Public Key  . . .\
    \ . . . . . . . . . . . . . . . . . . . .  15\n     4.4.  Checksum  . . . . .\
    \ . . . . . . . . . . . . . . . . . . .  15\n     4.5.  Signature Generation \
    \ . . . . . . . . . . . . . . . . . .  16\n     4.6.  Signature Verification \
    \ . . . . . . . . . . . . . . . . .  17\n   5.  Leighton-Micali Signatures  .\
    \ . . . . . . . . . . . . . . . .  19\n     5.1.  Parameters  . . . . . . . .\
    \ . . . . . . . . . . . . . . .  19\n     5.2.  LMS Private Key . . . . . . .\
    \ . . . . . . . . . . . . . .  20\n     5.3.  LMS Public Key  . . . . . . . .\
    \ . . . . . . . . . . . . .  21\n     5.4.  LMS Signature . . . . . . . . . .\
    \ . . . . . . . . . . . .  22\n       5.4.1.  LMS Signature Generation  . . .\
    \ . . . . . . . . . . .  23\n       5.4.2.  LMS Signature Verification  . . .\
    \ . . . . . . . . . .  24\n   6.  Hierarchical Signatures . . . . . . . . . .\
    \ . . . . . . . . .  26\n     6.1.  Key Generation  . . . . . . . . . . . . .\
    \ . . . . . . . .  29\n     6.2.  Signature Generation  . . . . . . . . . . .\
    \ . . . . . . .  30\n     6.3.  Signature Verification  . . . . . . . . . . .\
    \ . . . . . .  32\n     6.4.  Parameter Set Recommendations . . . . . . . . .\
    \ . . . . .  32\n   7.  Rationale . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . .  34\n     7.1.  Security String . . . . . . . . . . . . . . . . . .\
    \ . . .  35\n   8.  IANA Considerations . . . . . . . . . . . . . . . . . . .\
    \ . .  36\n   9.  Security Considerations . . . . . . . . . . . . . . . . . .\
    \ .  38\n     9.1.  Hash Formats  . . . . . . . . . . . . . . . . . . . . . .\
    \  39\n     9.2.  Stateful Signature Algorithm  . . . . . . . . . . . . . .  40\n\
    \     9.3.  Security of LM-OTS Checksum . . . . . . . . . . . . . . .  41\n  \
    \ 10. Comparison with Other Work  . . . . . . . . . . . . . . . . .  42\n   11.\
    \ References  . . . . . . . . . . . . . . . . . . . . . . . . .  43\n     11.1.\
    \  Normative References . . . . . . . . . . . . . . . . . .  43\n     11.2.  Informative\
    \ References . . . . . . . . . . . . . . . . .  43\n   Appendix A.  Pseudorandom\
    \ Key Generation  . . . . . . . . . . . .  45\n   Appendix B.  LM-OTS Parameter\
    \ Options . . . . . . . . . . . . . .  45\n   Appendix C.  An Iterative Algorithm\
    \ for Computing an LMS Public\n                Key  . . . . . . . . . . . . .\
    \ . . . . . . . . . . .  47\n   Appendix D.  Method for Deriving Authentication\
    \ Path for a\n                Signature  . . . . . . . . . . . . . . . . . . .\
    \ . .  48\n   Appendix E.  Example Implementation . . . . . . . . . . . . . .\
    \ .  49\n   Appendix F.  Test Cases . . . . . . . . . . . . . . . . . . . . .\
    \  49\n   Acknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  60\n\
    \   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  61\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   One-time signature systems, and general-purpose signature\
    \ systems\n   built out of one-time signature systems, have been known since 1979\n\
    \   [Merkle79], were well studied in the 1990s [USPTO5432852], and have\n   benefited\
    \ from renewed attention in the last decade.  The\n   characteristics of these\
    \ signature systems are small private and\n   public keys and fast signature generation\
    \ and verification, but large\n   signatures and moderately slow key generation\
    \ (in comparison with RSA\n   and ECDSA (Elliptic Curve Digital Signature Algorithm)).\
    \  Private\n   keys can be made very small by appropriate key generation, for\n\
    \   example, as described in Appendix A.  In recent years, there has been\n  \
    \ interest in these systems because of their post-quantum security and\n   their\
    \ suitability for compact verifier implementations.\n   This note describes the\
    \ Leighton and Micali adaptation [USPTO5432852]\n   of the original Lamport-Diffie-Winternitz-Merkle\
    \ one-time signature\n   system [Merkle79] [C:Merkle87] [C:Merkle89a] [C:Merkle89b]\
    \ and\n   general signature system [Merkle79] with enough specificity to ensure\n\
    \   interoperability between implementations.\n   A signature system provides\
    \ asymmetric message authentication.  The\n   key-generation algorithm produces\
    \ a public/private key pair.  A\n   message is signed by a private key, producing\
    \ a signature, and a\n   message/signature pair can be verified by a public key.\
    \  A One-Time\n   Signature (OTS) system can be used to sign one message securely\
    \ but\n   will become insecure if more than one is signed with the same public/\n\
    \   private key pair.  An N-time signature system can be used to sign N\n   or\
    \ fewer messages securely.  A Merkle-tree signature scheme is an\n   N-time signature\
    \ system that uses an OTS system as a component.\n   In the Merkle scheme, a binary\
    \ tree of height h is used to hold 2^h\n   OTS key pairs.  Each interior node\
    \ of the tree holds a value that is\n   the hash of the values of its two child\
    \ nodes.  The public key of the\n   tree is the value of the root node (a recursive\
    \ hash of the OTS\n   public keys), while the private key of the tree is the collection\
    \ of\n   all the OTS private keys, together with the index of the next OTS\n \
    \  private key to sign the next message with.\n   In this note, we describe the\
    \ Leighton-Micali Signature (LMS) system\n   (a variant of the Merkle scheme)\
    \ with the Hierarchical Signature\n   System (HSS) built on top of it that allows\
    \ it to efficiently scale\n   to larger numbers of signatures.  In order to support\
    \ signing a large\n   number of messages on resource-constrained systems, the\
    \ Merkle tree\n   can be subdivided into a number of smaller trees.  Only the\n\
    \   bottommost tree is used to sign messages, while trees above that are\n   used\
    \ to sign the public keys of their children.  For example, in the\n   simplest\
    \ case with two levels with both levels consisting of height h\n   trees, the\
    \ root tree is used to sign 2^h trees with 2^h OTS key\n   pairs, and each second-level\
    \ tree has 2^h OTS key pairs, for a total\n   of 2^(2h) bottom-level key pairs,\
    \ and so can sign 2^(2h) messages.\n   The advantage of this scheme is that only\
    \ the active trees need to be\n   instantiated, which saves both time (for key\
    \ generation) and space\n   (for key storage).  On the other hand, using a multilevel\
    \ signature\n   scheme increases the size of the signature as well as the signature\n\
    \   verification time.\n   This note is structured as follows.  Notes on post-quantum\n\
    \   cryptography are discussed in Section 1.1.  Intellectual property\n   issues\
    \ are discussed in Section 1.2.  The notation used within this\n   note is defined\
    \ in Section 3, and the public formats are described in\n   Section 3.3.  The\
    \ Leighton-Micali One-Time Signature (LM-OTS) system\n   is described in Section\
    \ 4, and the LMS and HSS N-time signature\n   systems are described in Sections\
    \ 5 and 6, respectively.  Sufficient\n   detail is provided to ensure interoperability.\
    \  The rationale for the\n   design decisions is given in Section 7.  The IANA\
    \ registry for these\n   signature systems is described in Section 8.  Security\
    \ considerations\n   are presented in Section 9.  Comparison with another hash-based\n\
    \   signature algorithm (eXtended Merkle Signature Scheme (XMSS)) is in\n   Section\
    \ 10.\n   This document represents the rough consensus of the CFRG.\n"
- title: 1.1.  CFRG Note on Post-Quantum Cryptography
  contents:
  - "1.1.  CFRG Note on Post-Quantum Cryptography\n   All post-quantum algorithms\
    \ documented by the Crypto Forum Research\n   Group (CFRG) are today considered\
    \ ready for experimentation and\n   further engineering development (e.g., to\
    \ establish the impact of\n   performance and sizes on IETF protocols).  However,\
    \ at the time of\n   writing, we do not have significant deployment experience\
    \ with such\n   algorithms.\n   Many of these algorithms come with specific restrictions,\
    \ e.g.,\n   change of classical interface or less cryptanalysis of proposed\n\
    \   parameters than established schemes.  The CFRG has consensus that all\n  \
    \ documents describing post-quantum technologies include the above\n   paragraph\
    \ and a clear additional warning about any specific\n   restrictions, especially\
    \ as those might affect use or deployment of\n   the specific scheme.  That guidance\
    \ may be changed over time via\n   document updates.\n   Additionally, for LMS:\n\
    \   CFRG consensus is that we are confident in the cryptographic security\n  \
    \ of the signature schemes described in this document against quantum\n   computers,\
    \ given the current state of the research community's\n   knowledge about quantum\
    \ algorithms.  Indeed, we are confident that\n   the security of a significant\
    \ part of the Internet could be made\n   dependent on the signature schemes defined\
    \ in this document, if\n   developers take care of the following.\n   In contrast\
    \ to traditional signature schemes, the signature schemes\n   described in this\
    \ document are stateful, meaning the secret key\n   changes over time.  If a secret\
    \ key state is used twice, no\n   cryptographic security guarantees remain.  In\
    \ consequence, it becomes\n   feasible to forge a signature on a new message.\
    \  This is a new\n   property that most developers will not be familiar with and\
    \ requires\n   careful handling of secret keys.  Developers should not use the\n\
    \   schemes described here except in systems that prevent the reuse of\n   secret\
    \ key states.\n   Note that the fact that the schemes described in this document\
    \ are\n   stateful also implies that classical APIs for digital signatures\n \
    \  cannot be used without modification.  The API MUST be able to handle\n   a\
    \ dynamic secret key state; that is, the API MUST allow the\n   signature-generation\
    \ algorithm to update the secret key state.\n"
- title: 1.2.  Intellectual Property
  contents:
  - "1.2.  Intellectual Property\n   This document is based on U.S. Patent 5,432,852,\
    \ which was issued\n   over twenty years ago and is thus expired.\n"
- title: 1.2.1.  Disclaimer
  contents:
  - "1.2.1.  Disclaimer\n   This document is not intended as legal advice.  Readers\
    \ are advised\n   to consult with their own legal advisers if they would like\
    \ a legal\n   interpretation of their rights.\n   The IETF policies and processes\
    \ regarding intellectual property and\n   patents are outlined in [RFC8179] and\
    \ at\n   <https://datatracker.ietf.org/ipr/about>.\n"
- title: 1.3.  Conventions Used in This Document
  contents:
  - "1.3.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be\
    \ interpreted as described in\n   BCP 14 [RFC2119] [RFC8174] when, and only when,\
    \ they appear in all\n   capitals, as shown here.\n"
- title: 2.  Interface
  contents:
  - "2.  Interface\n   The LMS signing algorithm is stateful; it modifies and updates\
    \ the\n   private key as a side effect of generating a signature.  Once a\n  \
    \ particular value of the private key is used to sign one message, it\n   MUST\
    \ NOT be used to sign another.\n   The key-generation algorithm takes as input\
    \ an indication of the\n   parameters for the signature system.  If it is successful,\
    \ it returns\n   both a private key and a public key.  Otherwise, it returns an\n\
    \   indication of failure.\n   The signing algorithm takes as input the message\
    \ to be signed and the\n   current value of the private key.  If successful, it\
    \ returns a\n   signature and the next value of the private key, if there is such\
    \ a\n   value.  After the private key of an N-time signature system has\n   signed\
    \ N messages, the signing algorithm returns the signature and an\n   indication\
    \ that there is no next value of the private key that can be\n   used for signing.\
    \  If unsuccessful, it returns an indication of\n   failure.\n   The verification\
    \ algorithm takes as input the public key, a message,\n   and a signature; it\
    \ returns an indication of whether or not the\n   signature-and-message pair is\
    \ valid.\n   A message/signature pair is valid if the signature was returned by\n\
    \   the signing algorithm upon input of the message and the private key\n   corresponding\
    \ to the public key; otherwise, the signature and message\n   pair is not valid\
    \ with probability very close to one.\n"
- title: 3.  Notation
  contents:
  - '3.  Notation

    '
- title: 3.1.  Data Types
  contents:
  - "3.1.  Data Types\n   Bytes and byte strings are the fundamental data types. \
    \ A single byte\n   is denoted as a pair of hexadecimal digits with a leading\
    \ \"0x\".  A\n   byte string is an ordered sequence of zero or more bytes and\
    \ is\n   denoted as an ordered sequence of hexadecimal characters with a\n   leading\
    \ \"0x\".  For example, 0xe534f0 is a byte string with a length\n   of three.\
    \  An array of byte strings is an ordered set, indexed\n   starting at zero, in\
    \ which all strings have the same length.\n   Unsigned integers are converted\
    \ into byte strings by representing\n   them in network byte order.  To make the\
    \ number of bytes in the\n   representation explicit, we define the functions\
    \ u8str(X), u16str(X),\n   and u32str(X), which take a nonnegative integer X as\
    \ input and return\n   one-, two-, and four-byte strings, respectively.  We also\
    \ make use of\n   the function strTou32(S), which takes a four-byte string S as\
    \ input\n   and returns a nonnegative integer; the identity u32str(strTou32(S))\
    \ =\n   S holds for any four-byte string S.\n"
- title: 3.1.1.  Operators
  contents:
  - "3.1.1.  Operators\n   When a and b are real numbers, mathematical operators are\
    \ defined as\n   follows:\n      ^ : a ^ b denotes the result of a raised to the\
    \ power of b\n      * : a * b denotes the product of a multiplied by b\n     \
    \ / : a / b denotes the quotient of a divided by b\n      % : a % b denotes the\
    \ remainder of the integer division of a by b\n      (with a and b being restricted\
    \ to integers in this case)\n      + : a + b denotes the sum of a and b\n    \
    \  - : a - b denotes the difference of a and b\n      AND : a AND b denotes the\
    \ bitwise AND of the two nonnegative\n      integers a and b (represented in binary\
    \ notation)\n   The standard order of operations is used when evaluating arithmetic\n\
    \   expressions.\n   When B is a byte and i is an integer, then B >> i denotes\
    \ the logical\n   right-shift operation by i bit positions.  Similarly, B << i\
    \ denotes\n   the logical left-shift operation.\n   If S and T are byte strings,\
    \ then S || T denotes the concatenation of\n   S and T.  If S and T are equal-length\
    \ byte strings, then S AND T\n   denotes the bitwise logical and operation.\n\
    \   The i-th element in an array A is denoted as A[i].\n"
- title: 3.1.2.  Functions
  contents:
  - "3.1.2.  Functions\n   If r is a nonnegative real number, then we define the following\n\
    \   functions:\n      ceil(r) : returns the smallest integer greater than or equal\
    \ to r\n      floor(r) : returns the largest integer less than or equal to r\n\
    \      lg(r) : returns the base-2 logarithm of r\n"
- title: 3.1.3.  Strings of w-Bit Elements
  contents:
  - "3.1.3.  Strings of w-Bit Elements\n   If S is a byte string, then byte(S, i)\
    \ denotes its i-th byte, where\n   the index starts at 0 at the left.  Hence,\
    \ byte(S, 0) is the leftmost\n   byte of S, byte(S, 1) is the second byte from\
    \ the left, and (assuming\n   S is n bytes long) byte(S, n-1) is the rightmost\
    \ byte of S.  In\n   addition, bytes(S, i, j) denotes the range of bytes from\
    \ the i-th to\n   the j-th byte, inclusive.  For example, if S = 0x02040608, then\n\
    \   byte(S, 0) is 0x02 and bytes(S, 1, 2) is 0x0406.\n   A byte string can be\
    \ considered to be a string of w-bit unsigned\n   integers; the correspondence\
    \ is defined by the function coef(S, i, w)\n   as follows:\n   If S is a string,\
    \ i is a positive integer, and w is a member of the\n   set { 1, 2, 4, 8 }, then\
    \ coef(S, i, w) is the i-th, w-bit value, if S\n   is interpreted as a sequence\
    \ of w-bit values.  That is,\n       coef(S, i, w) = (2^w - 1) AND\n         \
    \              ( byte(S, floor(i * w / 8)) >>\n                         (8 - (w\
    \ * (i % (8 / w)) + w)) )\n   For example, if S is the string 0x1234, then coef(S,\
    \ 7, 1) is 0 and\n   coef(S, 0, 4) is 1.\n                      S (represented\
    \ as bits)\n         +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n     \
    \    | 0| 0| 0| 1| 0| 0| 1| 0| 0| 0| 1| 1| 0| 1| 0| 0|\n         +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \                                ^\n                                |\n      \
    \                    coef(S, 7, 1)\n                 S (represented as four-bit\
    \ values)\n         +-----------+-----------+-----------+-----------+\n      \
    \   |     1     |     2     |     3     |     4     |\n         +-----------+-----------+-----------+-----------+\n\
    \               ^\n               |\n         coef(S, 0, 4)\n   The return value\
    \ of coef is an unsigned integer.  If i is larger than\n   the number of w-bit\
    \ values in S, then coef(S, i, w) is undefined, and\n   an attempt to compute\
    \ that value MUST raise an error.\n"
- title: 3.2.  Typecodes
  contents:
  - "3.2.  Typecodes\n   A typecode is an unsigned integer that is associated with\
    \ a\n   particular data format.  The format of the LM-OTS, LMS, and HSS\n   signatures\
    \ and public keys all begin with a typecode that indicates\n   the precise details\
    \ used in that format.  These typecodes are\n   represented as four-byte unsigned\
    \ integers in network byte order;\n   equivalently, they are External Data Representation\
    \ (XDR)\n   enumerations (see Section 3.3).\n"
- title: 3.3.  Notation and Formats
  contents:
  - "3.3.  Notation and Formats\n   The signature and public key formats are formally\
    \ defined in XDR to\n   provide an unambiguous, machine-readable definition [RFC4506].\
    \  The\n   private key format is not included as it is not needed for\n   interoperability\
    \ and an implementation MAY use any private key\n   format.  However, for clarity,\
    \ we include an example of private key\n   data in Test Case 2 of Appendix F.\
    \  Though XDR is used, these formats\n   are simple and easy to parse without\
    \ any special tools.  An\n   illustration of the layout of data in these objects\
    \ is provided\n   below.  The definitions are as follows:\n   /* one-time signatures\
    \ */\n   enum lmots_algorithm_type {\n     lmots_reserved       = 0,\n     lmots_sha256_n32_w1\
    \  = 1,\n     lmots_sha256_n32_w2  = 2,\n     lmots_sha256_n32_w4  = 3,\n    \
    \ lmots_sha256_n32_w8  = 4\n   };\n   typedef opaque bytestring32[32];\n   struct\
    \ lmots_signature_n32_p265 {\n     bytestring32 C;\n     bytestring32 y[265];\n\
    \   };\n   struct lmots_signature_n32_p133 {\n     bytestring32 C;\n     bytestring32\
    \ y[133];\n   };\n   struct lmots_signature_n32_p67 {\n     bytestring32 C;\n\
    \     bytestring32 y[67];\n   };\n   struct lmots_signature_n32_p34 {\n     bytestring32\
    \ C;\n     bytestring32 y[34];\n   };\n   union lmots_signature switch (lmots_algorithm_type\
    \ type) {\n    case lmots_sha256_n32_w1:\n      lmots_signature_n32_p265 sig_n32_p265;\n\
    \    case lmots_sha256_n32_w2:\n      lmots_signature_n32_p133 sig_n32_p133;\n\
    \    case lmots_sha256_n32_w4:\n      lmots_signature_n32_p67  sig_n32_p67;\n\
    \    case lmots_sha256_n32_w8:\n      lmots_signature_n32_p34  sig_n32_p34;\n\
    \    default:\n      void;   /* error condition */\n   };\n   /* hash-based signatures\
    \ (hbs) */\n   enum lms_algorithm_type {\n     lms_reserved       = 0,\n     lms_sha256_n32_h5\
    \  = 5,\n     lms_sha256_n32_h10 = 6,\n     lms_sha256_n32_h15 = 7,\n     lms_sha256_n32_h20\
    \ = 8,\n     lms_sha256_n32_h25 = 9\n   };\n   /* leighton-micali signatures (lms)\
    \ */\n   union lms_path switch (lms_algorithm_type type) {\n    case lms_sha256_n32_h5:\n\
    \      bytestring32 path_n32_h5[5];\n    case lms_sha256_n32_h10:\n      bytestring32\
    \ path_n32_h10[10];\n    case lms_sha256_n32_h15:\n      bytestring32 path_n32_h15[15];\n\
    \    case lms_sha256_n32_h20:\n      bytestring32 path_n32_h20[20];\n    case\
    \ lms_sha256_n32_h25:\n      bytestring32 path_n32_h25[25];\n    default:\n  \
    \    void;     /* error condition */\n   };\n   struct lms_signature {\n     unsigned\
    \ int q;\n     lmots_signature lmots_sig;\n     lms_path nodes;\n   };\n   struct\
    \ lms_key_n32 {\n     lmots_algorithm_type ots_alg_type;\n     opaque I[16];\n\
    \     opaque K[32];\n   };\n   union lms_public_key switch (lms_algorithm_type\
    \ type) {\n    case lms_sha256_n32_h5:\n    case lms_sha256_n32_h10:\n    case\
    \ lms_sha256_n32_h15:\n    case lms_sha256_n32_h20:\n    case lms_sha256_n32_h25:\n\
    \         lms_key_n32 z_n32;\n    default:\n      void;     /* error condition\
    \ */\n   };\n   /* hierarchical signature system (hss) */\n   struct hss_public_key\
    \ {\n     unsigned int L;\n     lms_public_key pub;\n   };\n   struct signed_public_key\
    \ {\n     lms_signature sig;\n     lms_public_key pub;\n   };\n   struct hss_signature\
    \ {\n     signed_public_key signed_keys<7>;\n     lms_signature sig_of_message;\n\
    \   };\n"
- title: 4.  LM-OTS One-Time Signatures
  contents:
  - "4.  LM-OTS One-Time Signatures\n   This section defines LM-OTS signatures.  The\
    \ signature is used to\n   validate the authenticity of a message by associating\
    \ a secret\n   private key with a shared public key.  These are one-time signatures;\n\
    \   each private key MUST be used at most one time to sign any given\n   message.\n\
    \   As part of the signing process, a digest of the original message is\n   computed\
    \ using the cryptographic hash function H (see Section 4.1),\n   and the resulting\
    \ digest is signed.\n   In order to facilitate its use in an N-time signature\
    \ system, the\n   LM-OTS key generation, signing, and verification algorithms\
    \ all take\n   as input parameters I and q.  The parameter I is a 16-byte string\n\
    \   that indicates which Merkle tree this LM-OTS is used with.  The\n   parameter\
    \ q is a 32-bit integer that indicates the leaf of the Merkle\n   tree where the\
    \ OTS public key appears.  These parameters are used as\n   part of the security\
    \ string, as listed in Section 7.1.  When the\n   LM-OTS signature system is used\
    \ outside of an N-time signature\n   system, the value I MAY be used to differentiate\
    \ this one-time\n   signature from others; however, the value q MUST be set to\
    \ the all-\n   zero value.\n"
- title: 4.1.  Parameters
  contents:
  - "4.1.  Parameters\n   The signature system uses the parameters n and w, which\
    \ are both\n   positive integers.  The algorithm description also makes use of\
    \ the\n   internal parameters p and ls, which are dependent on n and w.  These\n\
    \   parameters are summarized as follows:\n      n : the number of bytes of the\
    \ output of the hash function.\n      w : the width (in bits) of the Winternitz\
    \ coefficients; that is,\n      the number of bits from the hash or checksum that\
    \ is used with a\n      single Winternitz chain.  It is a member of the set\n\
    \      { 1, 2, 4, 8 }.\n      p : the number of n-byte string elements that make\
    \ up the LM-OTS\n      signature.  This is a function of n and w; the values for\
    \ the\n      defined parameter sets are listed in Table 1; it can also be\n  \
    \    computed by the algorithm given in Appendix B.\n      ls : the number of\
    \ left-shift bits used in the checksum function\n      Cksm (defined in Section\
    \ 4.4).\n      H : a second-preimage-resistant cryptographic hash function that\n\
    \      accepts byte strings of any length and returns an n-byte string.\n   For\
    \ more background on the cryptographic security requirements for H,\n   see Section\
    \ 9.\n   The value of n is determined by the hash function selected for use as\n\
    \   part of the LM-OTS algorithm; the choice of this value has a strong\n   effect\
    \ on the security of the system.  The parameter w determines the\n   length of\
    \ the Winternitz chains computed as a part of the OTS\n   signature (which involve\
    \ 2^w - 1 invocations of the hash function);\n   it has little effect on security.\
    \  Increasing w will shorten the\n   signature, but at a cost of a larger computation\
    \ to generate and\n   verify a signature.  The values of p and ls are dependent\
    \ on the\n   choices of the parameters n and w, as described in Appendix B.\n\
    \   Table 1 illustrates various combinations of n, w, p and ls, along\n   with\
    \ the resulting signature length.\n   The value of w describes a space/time trade-off;\
    \ increasing the value\n   of w will cause the signature to shrink (by decreasing\
    \ the value of\n   p) while increasing the amount of time needed to perform operations\n\
    \   with it: generate the public key and generate and verify the\n   signature.\
    \  In general, the LM-OTS signature is 4+n*(p+1) bytes long,\n   and public key\
    \ generation will take p*(2^w - 1) + 1 hash computations\n   (and signature generation\
    \ and verification will take approximately\n   half that on average).\n      +---------------------+--------+----+---+-----+----+---------+\n\
    \      | Parameter Set Name  | H      | n  | w | p   | ls | sig_len |\n      +---------------------+--------+----+---+-----+----+---------+\n\
    \      | LMOTS_SHA256_N32_W1 | SHA256 | 32 | 1 | 265 | 7  | 8516    |\n      |\
    \                     |        |    |   |     |    |         |\n      | LMOTS_SHA256_N32_W2\
    \ | SHA256 | 32 | 2 | 133 | 6  | 4292    |\n      |                     |    \
    \    |    |   |     |    |         |\n      | LMOTS_SHA256_N32_W4 | SHA256 | 32\
    \ | 4 | 67  | 4  | 2180    |\n      |                     |        |    |   |\
    \     |    |         |\n      | LMOTS_SHA256_N32_W8 | SHA256 | 32 | 8 | 34  |\
    \ 0  | 1124    |\n      +---------------------+--------+----+---+-----+----+---------+\n\
    \                                  Table 1\n   Here SHA256 denotes the SHA-256\
    \ hash function defined in NIST\n   standard [FIPS180].\n"
- title: 4.2.  Private Key
  contents:
  - "4.2.  Private Key\n   The format of the LM-OTS private key is an internal matter\
    \ to the\n   implementation, and this document does not attempt to define it.\
    \  One\n   possibility is that the private key may consist of a typecode\n   indicating\
    \ the particular LM-OTS algorithm, an array x[] containing p\n   n-byte strings,\
    \ and the 16-byte string I and the 4-byte string q.\n   This private key MUST\
    \ be used to sign (at most) one message.  The\n   following algorithm shows pseudocode\
    \ for generating a private key.\n   Algorithm 0: Generating a Private Key\n  \
    \   1. Retrieve the values of q and I (the 16-byte identifier of the\n       \
    \ LMS public/private key pair) from the LMS tree that this LM-OTS\n        private\
    \ key will be used with\n     2. Set type to the typecode of the algorithm\n \
    \    3. Set n and p according to the typecode and Table 1\n     4. Compute the\
    \ array x as follows:\n        for ( i = 0; i < p; i = i + 1 ) {\n          set\
    \ x[i] to a uniformly random n-byte string\n        }\n     5. Return u32str(type)\
    \ || I || u32str(q) || x[0] || x[1] || ...\n                                 \
    \             || x[p-1]\n   An implementation MAY use a pseudorandom method to\
    \ compute x[i], as\n   suggested in [Merkle79], page 46.  The details of the pseudorandom\n\
    \   method do not affect interoperability, but the cryptographic strength\n  \
    \ MUST match that of the LM-OTS algorithm.  Appendix A provides an\n   example\
    \ of a pseudorandom method for computing the LM-OTS private\n   key.\n"
- title: 4.3.  Public Key
  contents:
  - "4.3.  Public Key\n   The LM-OTS public key is generated from the private key\
    \ by\n   iteratively applying the function H to each individual element of x,\n\
    \   for 2^w - 1 iterations, then hashing all of the resulting values.\n   The\
    \ public key is generated from the private key using the following\n   algorithm,\
    \ or any equivalent process.\n   Algorithm 1: Generating a One-Time Signature\
    \ Public Key From a\n   Private Key\n     1. Set type to the typecode of the algorithm\n\
    \     2. Set the integers n, p, and w according to the typecode and\n        Table\
    \ 1\n     3. Determine x, I, and q from the private key\n     4. Compute the string\
    \ K as follows:\n        for ( i = 0; i < p; i = i + 1 ) {\n          tmp = x[i]\n\
    \          for ( j = 0; j < 2^w - 1; j = j + 1 ) {\n            tmp = H(I || u32str(q)\
    \ || u16str(i) || u8str(j) || tmp)\n          }\n          y[i] = tmp\n      \
    \  }\n        K = H(I || u32str(q) || u16str(D_PBLC) || y[0] || ... || y[p-1])\n\
    \     5. Return u32str(type) || I || u32str(q) || K\n   where D_PBLC is the fixed\
    \ two-byte value 0x8080, which is used to\n   distinguish the last hash from every\
    \ other hash in this system.\n   The public key is the value returned by Algorithm\
    \ 1.\n"
- title: 4.4.  Checksum
  contents:
  - "4.4.  Checksum\n   A checksum is used to ensure that any forgery attempt that\n\
    \   manipulates the elements of an existing signature will be detected.\n   This\
    \ checksum is needed because an attacker can freely advance any of\n   the Winternitz\
    \ chains.  That is, if this checksum were not present,\n   then an attacker who\
    \ could find a hash that has every digit larger\n   than the valid hash could\
    \ replace it (and adjust the Winternitz\n   chains).  The security property that\
    \ the checksum provides is\n   detailed in Section 9.  The checksum function Cksm\
    \ is defined as\n   follows, where S denotes the n-byte string that is input to\
    \ that\n   function, and the value sum is a 16-bit unsigned integer:\n   Algorithm\
    \ 2: Checksum Calculation\n     sum = 0\n     for ( i = 0; i < (n*8/w); i = i\
    \ + 1 ) {\n       sum = sum + (2^w - 1) - coef(S, i, w)\n     }\n     return (sum\
    \ << ls)\n   ls is the parameter that shifts the significant bits of the checksum\n\
    \   into the positions that will actually be used by the coef function\n   when\
    \ encoding the digits of the checksum.  The actual ls parameter is\n   a function\
    \ of the n and w parameters; the values for the currently\n   defined parameter\
    \ sets are shown in Table 1.  It is calculated by the\n   algorithm given in Appendix\
    \ B.\n   Because of the left-shift operation, the rightmost bits of the result\n\
    \   of Cksm will often be zeros.  Due to the value of p, these bits will\n   not\
    \ be used during signature generation or verification.\n"
- title: 4.5.  Signature Generation
  contents:
  - "4.5.  Signature Generation\n   The LM-OTS signature of a message is generated\
    \ by doing the following\n   in sequence: prepending the LMS key identifier I,\
    \ the LMS leaf\n   identifier q, the value D_MESG (0x8181), and the randomizer\
    \ C to the\n   message; computing the hash; concatenating the checksum of the\
    \ hash\n   to the hash itself; considering the resulting value as a sequence of\n\
    \   w-bit values; and using each of the w-bit values to determine the\n   number\
    \ of times to apply the function H to the corresponding element\n   of the private\
    \ key.  The outputs of the function H are concatenated\n   together and returned\
    \ as the signature.  The pseudocode for this\n   procedure is shown below.\n \
    \  Algorithm 3: Generating a One-Time Signature From a Private Key and a\n   Message\n\
    \     1. Set type to the typecode of the algorithm\n     2. Set n, p, and w according\
    \ to the typecode and Table 1\n     3. Determine x, I, and q from the private\
    \ key\n     4. Set C to a uniformly random n-byte string\n     5. Compute the\
    \ array y as follows:\n        Q = H(I || u32str(q) || u16str(D_MESG) || C ||\
    \ message)\n        for ( i = 0; i < p; i = i + 1 ) {\n          a = coef(Q ||\
    \ Cksm(Q), i, w)\n          tmp = x[i]\n          for ( j = 0; j < a; j = j +\
    \ 1 ) {\n            tmp = H(I || u32str(q) || u16str(i) || u8str(j) || tmp)\n\
    \          }\n          y[i] = tmp\n        }\n      6. Return u32str(type) ||\
    \ C || y[0] || ... || y[p-1]\n   Note that this algorithm results in a signature\
    \ whose elements are\n   intermediate values of the elements computed by the public\
    \ key\n   algorithm in Section 4.3.\n   The signature is the string returned by\
    \ Algorithm 3.  Section 3.3\n   formally defines the structure of the string as\
    \ the lmots_signature\n   union.\n"
- title: 4.6.  Signature Verification
  contents:
  - "4.6.  Signature Verification\n   In order to verify a message with its signature\
    \ (an array of n-byte\n   strings, denoted as y), the receiver must \"complete\"\
    \ the chain of\n   iterations of H using the w-bit coefficients of the string\
    \ resulting\n   from the concatenation of the message hash and its checksum. \
    \ This\n   computation should result in a value that matches the provided public\n\
    \   key.\n   Algorithm 4a: Verifying a Signature and Message Using a Public Key\n\
    \     1. If the public key is not at least four bytes long,\n        return INVALID.\n\
    \     2. Parse pubtype, I, q, and K from the public key as follows:\n        a.\
    \ pubtype = strTou32(first 4 bytes of public key)\n        b. Set n according\
    \ to the pubkey and Table 1; if the public key\n           is not exactly 24 +\
    \ n bytes long, return INVALID.\n        c. I = next 16 bytes of public key\n\
    \        d. q = strTou32(next 4 bytes of public key)\n        e. K = next n bytes\
    \ of public key\n     3. Compute the public key candidate Kc from the signature,\n\
    \        message, pubtype, and the identifiers I and q obtained from the\n   \
    \     public key, using Algorithm 4b.  If Algorithm 4b returns\n        INVALID,\
    \ then return INVALID.\n     4. If Kc is equal to K, return VALID; otherwise,\
    \ return INVALID.\n   Algorithm 4b: Computing a Public Key Candidate Kc from a\
    \ Signature,\n   Message, Signature Typecode pubtype, and Identifiers I, q\n \
    \    1. If the signature is not at least four bytes long,\n        return INVALID.\n\
    \     2. Parse sigtype, C, and y from the signature as follows:\n        a. sigtype\
    \ = strTou32(first 4 bytes of signature)\n        b. If sigtype is not equal to\
    \ pubtype, return INVALID.\n        c. Set n and p according to the pubtype and\
    \ Table 1; if the\n           signature is not exactly 4 + n * (p+1) bytes long,\n\
    \           return INVALID.\n        d. C = next n bytes of signature\n      \
    \  e.   y[0] = next n bytes of signature\n             y[1] = next n bytes of\
    \ signature\n             ...\n           y[p-1] = next n bytes of signature\n\
    \     3. Compute the string Kc as follows:\n        Q = H(I || u32str(q) || u16str(D_MESG)\
    \ || C || message)\n        for ( i = 0; i < p; i = i + 1 ) {\n          a = coef(Q\
    \ || Cksm(Q), i, w)\n          tmp = y[i]\n          for ( j = a; j < 2^w - 1;\
    \ j = j + 1 ) {\n            tmp = H(I || u32str(q) || u16str(i) || u8str(j) ||\
    \ tmp)\n          }\n          z[i] = tmp\n        }\n        Kc = H(I || u32str(q)\
    \ || u16str(D_PBLC) ||\n                                      z[0] || z[1] ||\
    \ ... || z[p-1])\n     4. Return Kc.\n"
- title: 5.  Leighton-Micali Signatures
  contents:
  - "5.  Leighton-Micali Signatures\n   The Leighton-Micali Signature (LMS) method\
    \ can sign a potentially\n   large but fixed number of messages.  An LMS system\
    \ uses two\n   cryptographic components: a one-time signature method and a hash\n\
    \   function.  Each LMS public/private key pair is associated with a\n   perfect\
    \ binary tree, each node of which contains an m-byte value,\n   where m is the\
    \ output length of the hash function.  Each leaf of the\n   tree contains the\
    \ value of the public key of an LM-OTS public/private\n   key pair.  The value\
    \ contained by the root of the tree is the LMS\n   public key.  Each interior\
    \ node is computed by applying the hash\n   function to the concatenation of the\
    \ values of its children nodes.\n   Each node of the tree is associated with a\
    \ node number, an unsigned\n   integer that is denoted as node_num in the algorithms\
    \ below, which is\n   computed as follows.  The root node has node number 1; for\
    \ each node\n   with node number N < 2^h (where h is the height of the tree),\
    \ its\n   left child has node number 2*N, while its right child has node number\n\
    \   2*N + 1.  The result of this is that each node within the tree will\n   have\
    \ a unique node number, and the leaves will have node numbers 2^h,\n   (2^h)+1,\
    \ (2^h)+2, ..., (2^h)+(2^h)-1.  In general, the j-th node at\n   level i has node\
    \ number 2^i + j.  The node number can conveniently be\n   computed when it is\
    \ needed in the LMS algorithms, as described in\n   those algorithms.\n"
- title: 5.1.  Parameters
  contents:
  - "5.1.  Parameters\n   An LMS system has the following parameters:\n      h : the\
    \ height of the tree\n      m : the number of bytes associated with each node\n\
    \      H : a second-preimage-resistant cryptographic hash function that\n    \
    \  accepts byte strings of any length and returns an m-byte string.\n   There\
    \ are 2^h leaves in the tree.\n   The overall strength of LMS signatures is governed\
    \ by the weaker of\n   the hash function used within the LM-OTS and the hash function\
    \ used\n   within the LMS system.  In order to minimize the risk, these two hash\n\
    \   functions SHOULD be the same (so that an attacker could not take\n   advantage\
    \ of the weaker hash function choice).\n                 +--------------------+--------+----+----+\n\
    \                 | Name               | H      | m  | h  |\n                \
    \ +--------------------+--------+----+----+\n                 | LMS_SHA256_M32_H5\
    \  | SHA256 | 32 | 5  |\n                 |                    |        |    |\
    \    |\n                 | LMS_SHA256_M32_H10 | SHA256 | 32 | 10 |\n         \
    \        |                    |        |    |    |\n                 | LMS_SHA256_M32_H15\
    \ | SHA256 | 32 | 15 |\n                 |                    |        |    |\
    \    |\n                 | LMS_SHA256_M32_H20 | SHA256 | 32 | 20 |\n         \
    \        |                    |        |    |    |\n                 | LMS_SHA256_M32_H25\
    \ | SHA256 | 32 | 25 |\n                 +--------------------+--------+----+----+\n\
    \                                  Table 2\n"
- title: 5.2.  LMS Private Key
  contents:
  - "5.2.  LMS Private Key\n   The format of the LMS private key is an internal matter\
    \ to the\n   implementation, and this document does not attempt to define it.\
    \  One\n   possibility is that it may consist of an array OTS_PRIV[] of 2^h\n\
    \   LM-OTS private keys and the leaf number q of the next LM-OTS private\n   key\
    \ that has not yet been used.  The q-th element of OTS_PRIV[] is\n   generated\
    \ using Algorithm 0 with the identifiers I, q.  The leaf\n   number q is initialized\
    \ to zero when the LMS private key is created.\n   The process is as follows:\n\
    \   Algorithm 5: Computing an LMS Private Key.\n     1. Determine h and m from\
    \ the typecode and Table 2.\n     2. Set I to a uniformly random 16-byte string.\n\
    \     3. Compute the array OTS_PRIV[] as follows:\n        for ( q = 0; q < 2^h;\
    \ q = q + 1) {\n          OTS_PRIV[q] = LM-OTS private key with identifiers I,\
    \ q\n        }\n     4. q = 0\n   An LMS private key MAY be generated pseudorandomly\
    \ from a secret\n   value; in this case, the secret value MUST be at least m bytes\
    \ long\n   and uniformly random and MUST NOT be used for any other purpose than\n\
    \   the generation of the LMS private key.  The details of how this\n   process\
    \ is done do not affect interoperability; that is, the public\n   key verification\
    \ operation is independent of these details.\n   Appendix A provides an example\
    \ of a pseudorandom method for computing\n   an LMS private key.\n   The signature-generation\
    \ logic uses q as the next leaf to use; hence,\n   step 4 starts it off at the\
    \ leftmost leaf.  Because the signature\n   process increments q after the signature\
    \ operation, the first\n   signature will have q=0.\n"
- title: 5.3.  LMS Public Key
  contents:
  - "5.3.  LMS Public Key\n   An LMS public key is defined as follows, where we denote\
    \ the public\n   key final hash value (namely, the K value computed in Algorithm\
    \ 1)\n   associated with the i-th LM-OTS private key as OTS_PUB_HASH[i], with\n\
    \   i ranging from 0 to (2^h)-1.  Each instance of an LMS public/private\n   key\
    \ pair is associated with a balanced binary tree, and the nodes of\n   that tree\
    \ are indexed from 1 to 2^(h+1)-1.  Each node is associated\n   with an m-byte\
    \ string.  The string for the r-th node is denoted as\n   T[r] and defined as\n\
    \     if r >= 2^h:\n          H(I||u32str(r)||u16str(D_LEAF)||OTS_PUB_HASH[r-2^h])\n\
    \     else\n          H(I||u32str(r)||u16str(D_INTR)||T[2*r]||T[2*r+1])\n   where\
    \ D_LEAF is the fixed two-byte value 0x8282 and D_INTR is the\n   fixed two-byte\
    \ value 0x8383, both of which are used to distinguish\n   this hash from every\
    \ other hash in this system.\n   When we have r >= 2^h, then we are processing\
    \ a leaf node (and thus\n   hashing only a single LM-OTS public key).  When we\
    \ have r < 2^h, then\n   we are processing an internal node -- that is, a node\
    \ with two child\n   nodes that we need to combine.\n   The LMS public key can\
    \ be represented as the byte string\n     u32str(type) || u32str(otstype) || I\
    \ || T[1]\n   Section 3.3 specifies the format of the type variable.  The value\n\
    \   otstype is the parameter set for the LM-OTS public/private key pairs\n   used.\
    \  The value I is the private key identifier and is the value\n   used for all\
    \ computations for the same LMS tree.  The value T[1] can\n   be computed via\
    \ recursive application of the above equation or by any\n   equivalent method.\
    \  An iterative procedure is outlined in Appendix C.\n"
- title: 5.4.  LMS Signature
  contents:
  - "5.4.  LMS Signature\n   An LMS signature consists of\n      the number q of the\
    \ leaf associated with the LM-OTS signature, as\n      a four-byte unsigned integer\
    \ in network byte order, an LM-OTS\n      signature,\n      a typecode indicating\
    \ the particular LMS algorithm,\n      an array of h m-byte values that is associated\
    \ with the path\n      through the tree from the leaf associated with the LM-OTS\n\
    \      signature to the root.\n   Symbolically, the signature can be represented\
    \ as\n       u32str(q) || lmots_signature || u32str(type) ||\n               \
    \  path[0] || path[1] || path[2] || ... || path[h-1]\n   Section 3.3 formally\
    \ defines the format of the signature as the\n   lms_signature structure.  The\
    \ array for a tree with height h will\n   have h values and contains the values\
    \ of the siblings of (that is, is\n   adjacent to) the nodes on the path from\
    \ the leaf to the root, where\n   the sibling to node A is the other node that\
    \ shares node A's parent.\n   In the signature, 0 is counted from the bottom level\
    \ of the tree, and\n   so path[0] is the value of the node adjacent to leaf node\
    \ q; path[1]\n   is the second-level node that is adjacent to leaf node q's parent,\n\
    \   and so on up the tree until we get to path[h-1], which is the value\n   of\
    \ the next-to-the-top-level node whose branch the leaf node q does\n   not reside\
    \ in.\n   Below is a simple example of the authentication path for h=3 and q=2.\n\
    \   The leaf marked OTS is the one-time signature that is used to sign\n   the\
    \ actual message.  The nodes on the path from the OTS public key to\n   the root\
    \ are marked with a *, while the nodes that are used within\n   the path array\
    \ are marked with **.  The values in the path array are\n   those nodes that are\
    \ siblings of the nodes on the path; path[0] is\n   the leaf** node that is adjacent\
    \ to the OTS public key (which is the\n   start of the path); path[1] is the T[4]**\
    \ node that is the sibling of\n   the second node T[5]* on the path, and path[2]\
    \ is the T[3]** node\n   that is the sibling of the third node T[2]* on the path.\n\
    \                                Root\n                                 |\n  \
    \               ---------------------------------\n                 |        \
    \                       |\n               T[2]*                          T[3]**\n\
    \                 |                               |\n          ------------------\
    \            -----------------\n          |                |            |    \
    \           |\n       T[4]**           T[5]*         T[6]            T[7]\n  \
    \        |                |            |               |\n      ---------    \
    \   ----------     --------       ---------\n      |       |       |        |\
    \     |      |       |       |\n     leaf    leaf    OTS  leaf**   leaf   leaf\
    \    leaf    leaf\n   The idea behind this authentication path is that it allows\
    \ us to\n   validate the OTS hash with using h path array values and hash\n  \
    \ computations.  What the verifier does is recompute the hashes up the\n   path;\
    \ first, it hashes the given OTS and path[0] value, giving a\n   tentative T[5]'\
    \ value.  Then, it hashes its path[1] and tentative\n   T[5]' value to get a tentative\
    \ T[2]' value.  Then, it hashes that and\n   the path[2] value to get a tentative\
    \ Root' value.  If that value is\n   the known public key of the Merkle tree,\
    \ then we can assume that the\n   value T[2]' it got was the correct T[2] value\
    \ in the original tree,\n   and so the T[5]' value it got was the correct T[5]\
    \ value in the\n   original tree, and so the OTS public key is the same as in\
    \ the\n   original and, hence, is correct.\n"
- title: 5.4.1.  LMS Signature Generation
  contents:
  - "5.4.1.  LMS Signature Generation\n   To compute the LMS signature of a message\
    \ with an LMS private key,\n   the signer first computes the LM-OTS signature\
    \ of the message using\n   the leaf number of the next unused LM-OTS private key.\
    \  The leaf\n   number q in the signature is set to the leaf number of the LMS\n\
    \   private key that was used in the signature.  Before releasing the\n   signature,\
    \ the leaf number q in the LMS private key MUST be\n   incremented to prevent\
    \ the LM-OTS private key from being used again.\n   If the LMS private key is\
    \ maintained in nonvolatile memory, then the\n   implementation MUST ensure that\
    \ the incremented value has been stored\n   before releasing the signature.  The\
    \ issue this tries to prevent is a\n   scenario where a) we generate a signature\
    \ using one LM-OTS private\n   key and release it to the application, b) before\
    \ we update the\n   nonvolatile memory, we crash, and c) we reboot and generate\
    \ a second\n   signature using the same LM-OTS private key.  With two different\n\
    \   signatures using the same LM-OTS private key, an attacker could\n   potentially\
    \ generate a forged signature of a third message.\n   The array of node values\
    \ in the signature MAY be computed in any way.\n   There are many potential time/storage\
    \ trade-offs that can be applied.\n   The fastest alternative is to store all\
    \ of the nodes of the tree and\n   set the array in the signature by copying them;\
    \ pseudocode to do so\n   appears in Appendix D.  The least storage-intensive\
    \ alternative is to\n   recompute all of the nodes for each signature.  Note that\
    \ the details\n   of this procedure are not important for interoperability; it\
    \ is not\n   necessary to know any of these details in order to perform the\n\
    \   signature-verification operation.  The internal nodes of the tree\n   need\
    \ not be kept secret, and thus a node-caching scheme that stores\n   only internal\
    \ nodes can sidestep the need for strong protections.\n   Several useful time/storage\
    \ trade-offs are described in the \"Small-\n   Memory LM Schemes\" section of\
    \ [USPTO5432852].\n"
- title: 5.4.2.  LMS Signature Verification
  contents:
  - "5.4.2.  LMS Signature Verification\n   An LMS signature is verified by first\
    \ using the LM-OTS signature\n   verification algorithm (Algorithm 4b) to compute\
    \ the LM-OTS public\n   key from the LM-OTS signature and the message.  The value\
    \ of that\n   public key is then assigned to the associated leaf of the LMS tree,\n\
    \   and then the root of the tree is computed from the leaf value and the\n  \
    \ array path[] as described in Algorithm 6 below.  If the root value\n   matches\
    \ the public key, then the signature is valid; otherwise, the\n   signature verification\
    \ fails.\n   Algorithm 6: LMS Signature Verification\n     1. If the public key\
    \ is not at least eight bytes long, return\n        INVALID.\n     2. Parse pubtype,\
    \ I, and T[1] from the public key as follows:\n        a. pubtype = strTou32(first\
    \ 4 bytes of public key)\n        b. ots_typecode = strTou32(next 4 bytes of public\
    \ key)\n        c. Set m according to pubtype, based on Table 2.\n        d. If\
    \ the public key is not exactly 24 + m bytes\n           long, return INVALID.\n\
    \        e. I = next 16 bytes of the public key\n        f. T[1] = next m bytes\
    \ of the public key\n     3. Compute the LMS Public Key Candidate Tc from the\
    \ signature,\n        message, identifier, pubtype, and ots_typecode, using\n\
    \        Algorithm 6a.\n     4. If Tc is equal to T[1], return VALID; otherwise,\
    \ return INVALID.\n   Algorithm 6a: Computing an LMS Public Key Candidate from\
    \ a Signature,\n   Message, Identifier, and Algorithm Typecodes\n     1. If the\
    \ signature is not at least eight bytes long,\n        return INVALID.\n     2.\
    \ Parse sigtype, q, lmots_signature, and path from the signature\n        as follows:\n\
    \        a. q = strTou32(first 4 bytes of signature)\n        b. otssigtype =\
    \ strTou32(next 4 bytes of signature)\n        c. If otssigtype is not the OTS\
    \ typecode from the public key,\n           return INVALID.\n        d. Set n,\
    \ p according to otssigtype and Table 1; if the\n           signature is not at\
    \ least 12 + n * (p + 1) bytes long,\n           return INVALID.\n        e. lmots_signature\
    \ = bytes 4 through 7 + n * (p + 1)\n           of signature\n        f. sigtype\
    \ = strTou32(bytes 8 + n * (p + 1)) through\n           11 + n * (p + 1) of signature)\n\
    \        g. If sigtype is not the LM typecode from the public key,\n         \
    \  return INVALID.\n        h. Set m, h according to sigtype and Table 2.\n  \
    \      i. If q >= 2^h or the signature is not exactly\n           12 + n * (p\
    \ + 1) + m * h bytes long,\n           return INVALID.\n        j. Set path as\
    \ follows:\n             path[0] = next m bytes of signature\n             path[1]\
    \ = next m bytes of signature\n                ...\n           path[h-1] = next\
    \ m bytes of signature\n     3. Kc = candidate public key computed by applying\
    \ Algorithm 4b\n        to the signature lmots_signature, the message, and the\n\
    \        identifiers I, q\n     4. Compute the candidate LMS root value Tc as\
    \ follows:\n        node_num = 2^h + q\n        tmp = H(I || u32str(node_num)\
    \ || u16str(D_LEAF) || Kc)\n        i = 0\n        while (node_num > 1) {\n  \
    \        if (node_num is odd):\n            tmp = H(I||u32str(node_num/2)||u16str(D_INTR)||path[i]||tmp)\n\
    \          else:\n            tmp = H(I||u32str(node_num/2)||u16str(D_INTR)||tmp||path[i])\n\
    \          node_num = node_num/2\n          i = i + 1\n        }\n        Tc =\
    \ tmp\n     5. Return Tc.\n"
- title: 6.  Hierarchical Signatures
  contents:
  - "6.  Hierarchical Signatures\n   In scenarios where it is necessary to minimize\
    \ the time taken by the\n   public key generation process, the Hierarchical Signature\
    \ System\n   (HSS) can be used.  This hierarchical scheme, which we describe in\n\
    \   this section, uses the LMS scheme as a component.  In HSS, we have a\n   sequence\
    \ of L LMS trees, where the public key for the first LMS tree\n   is included\
    \ in the public key of the HSS system, each LMS private key\n   signs the next\
    \ LMS public key, and the last LMS private key signs the\n   actual message. \
    \ For example, if we have a three-level hierarchy\n   (L=3), then to sign a message,\
    \ we would have:\n      The first LMS private key (level 0) signs a level 1 LMS\
    \ public\n      key.\n      The second LMS private key (level 1) signs a level\
    \ 2 LMS public\n      key.\n      The third LMS private key (level 2) signs the\
    \ message.\n   The root of the level 0 LMS tree is contained in the HSS public\
    \ key.\n   To verify the LMS signature, we would verify all the signatures:\n\
    \      We would verify that the level 1 LMS public key is correctly\n      signed\
    \ by the level 0 signature.\n      We would verify that the level 2 LMS public\
    \ key is correctly\n      signed by the level 1 signature.\n      We would verify\
    \ that the message is correctly signed by the level\n      2 signature.\n   We\
    \ would accept the HSS signature only if all the signatures\n   validated.\n \
    \  During the signature-generation process, we sign messages with the\n   lowest\
    \ (level L-1) LMS tree.  Once we have used all the leafs in that\n   tree to sign\
    \ messages, we would discard it, generate a fresh LMS\n   tree, and sign it with\
    \ the next (level L-2) LMS tree (and when that\n   is used up, recursively generate\
    \ and sign a fresh level L-2 LMS\n   tree).\n   HSS, in essence, utilizes a tree\
    \ of LMS trees.  There is a single LMS\n   tree at level 0 (the root).  Each LMS\
    \ tree (actually, the private key\n   corresponding to the LMS tree) at level\
    \ i is used to sign 2^h objects\n   (where h is the height of trees at level i).\
    \  If i < L-1, then each\n   object will be another LMS tree (actually, the public\
    \ key) at level\n   i+1; if i = L-1, we've reached the bottom of the HSS tree,\
    \ and so\n   each object will be a message from the application.  The HSS public\n\
    \   key contains the public key of the LMS tree at the root, and an HSS\n   signature\
    \ is associated with a path from the root of the HSS tree to\n   the leaf.\n \
    \  Compared to LMS, HSS has a much reduced public key generation time,\n   as\
    \ only the root tree needs to be generated prior to the distribution\n   of the\
    \ HSS public key.  For example, an L=3 tree (with h=10 at each\n   level) would\
    \ have one level 0 LMS tree, 2^10 level 1 LMS trees (with\n   each such level\
    \ 1 public key signed by one of the 1024 level 0 OTS\n   public keys), and 2^20\
    \ level 2 LMS trees.  Only 1024 OTS public keys\n   need to be computed to generate\
    \ the HSS public key (as you need to\n   compute only the level 0 LMS tree to\
    \ compute that value; you can, of\n   course, decide to compute the initial level\
    \ 1 and level 2 LMS trees).\n   In addition, the 2^20 level 2 LMS trees can jointly\
    \ sign a total of\n   over a billion messages.  In contrast, a single LMS tree\
    \ that could\n   sign a billion messages would require a billion OTS public keys\
    \ to be\n   computed first (if h=30 were allowed in a supported parameter set).\n\
    \   Each LMS tree within the hierarchy is associated with a distinct LMS\n   public\
    \ key, private key, signature, and identifier.  The number of\n   levels is denoted\
    \ as L and is between one and eight, inclusive.  The\n   following notation is\
    \ used, where i is an integer between 0 and L-1\n   inclusive, and the root of\
    \ the hierarchy is level 0:\n      prv[i] is the current LMS private key of the\
    \ i-th level.\n      pub[i] is the current LMS public key of the i-th level, as\n\
    \      described in Section 5.3.\n      sig[i] is the LMS signature of public\
    \ key pub[i+1] generated using\n      the private key prv[i].\n   It is expected\
    \ that the above arrays are maintained for the course of\n   the HSS key.  The\
    \ contents of the prv[] array MUST be kept private;\n   the pub[] and sig[] array\
    \ may be revealed should the implementation\n   find that convenient.\n   In this\
    \ section, we say that an N-time private key is exhausted when\n   it has generated\
    \ N signatures; thus, it can no longer be used for\n   signing.\n   For i > 0,\
    \ the values prv[i], pub[i], and (for all values of i)\n   sig[i] will be updated\
    \ over time as private keys are exhausted and\n   replaced by newer keys.\n  \
    \ When these key pairs are updated (or initially generated before the\n   first\
    \ message is signed), then the LMS key generation processes\n   outlined in Sections\
    \ 5.2 and 5.3 are performed.  If the generated key\n   pairs are for level i of\
    \ the HSS hierarchy, then we store the public\n   key in pub[i] and the private\
    \ key in prv[i].  In addition, if i > 0,\n   then we sign the generated public\
    \ key with the LMS private key at\n   level i-1, placing the signature into sig[i-1].\
    \  When the LMS key\n   pair is generated, the key pair and the corresponding\
    \ identifier MUST\n   be generated independently of all other key pairs.\n   HSS\
    \ allows L=1, in which case the HSS public key and signature\n   formats are essentially\
    \ the LMS public key and signature formats,\n   prepended by a fixed field.  Since\
    \ HSS with L=1 has very little\n   overhead compared to LMS, all implementations\
    \ MUST support HSS in\n   order to maximize interoperability.\n   We specifically\
    \ allow different LMS levels to use different parameter\n   sets.  For example,\
    \ the 0-th LMS public key (the root) may use the\n   LMS_SHA256_M32_H15 parameter\
    \ set, while the 1-th public key may use\n   LMS_SHA256_M32_H10.  There are practical\
    \ reasons to allow this; for\n   one, the signer may decide to store parts of\
    \ the 0-th LMS tree (that\n   it needs to construct while computing the public\
    \ key) to accelerate\n   later operations.  As the 0-th tree is never updated,\
    \ these internal\n   nodes will never need to be recomputed.  In addition, during\
    \ the\n   signature-generation operation, almost all the operations involved\n\
    \   with updating the authentication path occur with the bottom (L-1th)\n   LMS\
    \ public key; hence, it may be useful to select the parameter set\n   for that\
    \ public key to have a shorter LMS tree.\n   A close reading of the HSS verification\
    \ pseudocode shows that it\n   would allow the parameters of the nontop LMS public\
    \ keys to change\n   over time; for example, the signer might initially have the\
    \ 1-th LMS\n   public key use the LMS_SHA256_M32_H10 parameter set, but when that\n\
    \   tree is exhausted, the signer might replace it with an LMS public key\n  \
    \ that uses the LMS_SHA256_M32_H15 parameter set.  While this would\n   work with\
    \ the example verification pseudocode, the signer MUST NOT\n   change the parameter\
    \ sets for a specific level.  This prohibition is\n   to support verifiers that\
    \ may keep state over the course of several\n   signature verifications.\n"
- title: 6.1.  Key Generation
  contents:
  - "6.1.  Key Generation\n   The public key of the HSS scheme consists of the number\
    \ of levels L,\n   followed by pub[0], the public key of the top level.\n   The\
    \ HSS private key consists of prv[0], ... , prv[L-1], along with\n   the associated\
    \ pub[0], ... pub[L-1] and sig[0], ..., sig[L-2] values.\n   As stated earlier,\
    \ the values of the pub[] and sig[] arrays need not\n   be kept secret and may\
    \ be revealed.  The value of pub[0] does not\n   change (and, except for the index\
    \ q, the value of prv[0] need not\n   change); however, the values of pub[i] and\
    \ prv[i] are dynamic for i >\n   0 and are changed by the signature-generation\
    \ algorithm.\n   During the key generation, the public and private keys are\n\
    \   initialized.  Here is some pseudocode that explains the key-\n   generation\
    \ logic:\n   Algorithm 7: Generating an HSS Key Pair\n     1. Generate an LMS\
    \ key pair, as specified in Sections 5.2 and 5.3,\n        placing the private\
    \ key into priv[0], and the public key into\n        pub[0]\n     2. For i = 1\
    \ to L-1 do {\n          generate an LMS key pair, placing the private key into\
    \ priv[i]\n          and the public key into pub[i]\n          sig[i-1] = lms_signature(\
    \ pub[i], priv[i-1] )\n        }\n     3. Return u32str(L) || pub[0] as the public\
    \ key and the priv[],\n        pub[], and sig[] arrays as the private key\n  \
    \ In the above algorithm, each LMS public/private key pair generated\n   MUST\
    \ be generated independently.\n   Note that the value of the public key does not\
    \ depend on the\n   execution of step 2.  As a result, an implementation may decide\
    \ to\n   delay step 2 until later -- for example, during the initial\n   signature-generation\
    \ operation.\n"
- title: 6.2.  Signature Generation
  contents:
  - "6.2.  Signature Generation\n   To sign a message using an HSS key pair, the following\
    \ steps are\n   performed:\n      If prv[L-1] is exhausted, then determine the\
    \ smallest integer d\n      such that all of the private keys prv[d], prv[d+1],\
    \ ... , prv[L-1]\n      are exhausted.  If d is equal to zero, then the HSS key\
    \ pair is\n      exhausted, and it MUST NOT generate any more signatures.\n  \
    \    Otherwise, the key pairs for levels d through L-1 must be\n      regenerated\
    \ during the signature-generation process, as follows.\n      For i from d to\
    \ L-1, a new LMS public and private key pair with a\n      new identifier is generated,\
    \ pub[i] and prv[i] are set to those\n      values, then the public key pub[i]\
    \ is signed with prv[i-1], and\n      sig[i-1] is set to the resulting value.\n\
    \      The message is signed with prv[L-1], and the value sig[L-1] is set\n  \
    \    to that result.\n      The value of the HSS signature is set as follows.\
    \  We let\n      signed_pub_key denote an array of octet strings, where\n    \
    \  signed_pub_key[i] = sig[i] || pub[i+1], for i between 0 and\n      Nspk-1,\
    \ inclusive, where Nspk = L-1 denotes the number of signed\n      public keys.\
    \  Then the HSS signature is u32str(Nspk) ||\n      signed_pub_key[0] || ... ||\
    \ signed_pub_key[Nspk-1] || sig[Nspk].\n      Note that the number of signed_pub_key\
    \ elements in the signature\n      is indicated by the value Nspk that appears\
    \ in the initial four\n      bytes of the signature.\n   Here is some pseudocode\
    \ of the above logic:\n   Algorithm 8: Generating an HSS signature\n     1. If\
    \ the message-signing key prv[L-1] is exhausted, regenerate\n        that key\
    \ pair, together with any parent key pairs that might\n        be necessary.\n\
    \        If the root key pair is exhausted, then the HSS key pair is\n       \
    \ exhausted and MUST NOT generate any more signatures.\n        d = L\n      \
    \  while (prv[d-1].q == 2^(prv[d-1].h)) {\n          d = d - 1\n          if (d\
    \ == 0)\n            return FAILURE\n        }\n        while (d < L) {\n    \
    \      create lms key pair pub[d], prv[d]\n          sig[d-1] = lms_signature(\
    \ pub[d], prv[d-1] )\n          d = d + 1\n        }\n     2. Sign the message.\n\
    \        sig[L-1] = lms_signature( msg, prv[L-1] )\n     3. Create the list of\
    \ signed public keys.\n        i = 0;\n        while (i < L-1) {\n          signed_pub_key[i]\
    \ = sig[i] || pub[i+1]\n          i = i + 1\n        }\n     4. Return u32str(L-1)\
    \ || signed_pub_key[0] || ...\n                                 || signed_pub_key[L-2]\
    \ || sig[L-1]\n   In the specific case of L=1, the format of an HSS signature\
    \ is\n     u32str(0) || sig[0]\n   In the general case, the format of an HSS signature\
    \ is\n     u32str(Nspk) || signed_pub_key[0] || ...\n                        \
    \      || signed_pub_key[Nspk-1] || sig[Nspk]\n   which is equivalent to\n   \
    \  u32str(Nspk) || sig[0] || pub[1] || ...\n                              || sig[Nspk-1]\
    \ || pub[Nspk] || sig[Nspk]\n"
- title: 6.3.  Signature Verification
  contents:
  - "6.3.  Signature Verification\n   To verify a signature S and message using the\
    \ public key pub, perform\n   the following steps:\n     The signature S is parsed\
    \ into its components as follows:\n     Nspk = strTou32(first four bytes of S)\n\
    \     if Nspk+1 is not equal to the number of levels L in pub:\n       return\
    \ INVALID\n     for (i = 0; i < Nspk; i = i + 1) {\n       siglist[i] = next LMS\
    \ signature parsed from S\n       publist[i] = next LMS public key parsed from\
    \ S\n     }\n     siglist[Nspk] = next LMS signature parsed from S\n     key =\
    \ pub\n     for (i = 0; i < Nspk; i = i + 1) {\n       sig = siglist[i]\n    \
    \   msg = publist[i]\n       if (lms_verify(msg, key, sig) != VALID):\n      \
    \   return INVALID\n       key = msg\n     }\n     return lms_verify(message,\
    \ key, siglist[Nspk])\n   Since the length of an LMS signature cannot be known\
    \ without parsing\n   it, the HSS signature verification algorithm makes use of\
    \ an LMS\n   signature parsing routine that takes as input a string consisting\
    \ of\n   an LMS signature with an arbitrary string appended to it and returns\n\
    \   both the LMS signature and the appended string.  The latter is passed\n  \
    \ on for further processing.\n"
- title: 6.4.  Parameter Set Recommendations
  contents:
  - "6.4.  Parameter Set Recommendations\n   As for guidance as to the number of LMS\
    \ levels and the size of each,\n   any discussion of performance is implementation\
    \ specific.  In\n   general, the sole drawback for a single LMS tree is the time\
    \ it takes\n   to generate the public key; as every LM-OTS public key needs to\
    \ be\n   generated, the time this takes can be substantial.  For a two-level\n\
    \   tree, only the top-level LMS tree and the initial bottom-level LMS\n   tree\
    \ need to be generated initially (before the first signature is\n   generated);\
    \ this will in general be significantly quicker.\n   To give a general idea of\
    \ the trade-offs available, we include some\n   measurements taken with the LMS\
    \ implementation available at\n   <https://github.com/cisco/hash-sigs>, taken\
    \ on a 3.3 GHz Xeon\n   processor with threading enabled.  We tried various parameter\
    \ sets,\n   all with W=8 (which minimizes signature size, while increasing time).\n\
    \   These are here to give a guideline as to what's possible; for the\n   computational\
    \ time, your mileage may vary, depending on the computing\n   resources you have.\
    \  The machine these tests were performed on does\n   not have the SHA-256 extensions;\
    \ you could possibly do significantly\n   better.\n             +---------+------------+---------+-------------+\n\
    \             | ParmSet | KeyGenTime | SigSize | KeyLifetime |\n             +---------+------------+---------+-------------+\n\
    \             | 15      | 6 sec      | 1616    | 30 seconds  |\n             |\
    \         |            |         |             |\n             | 20      | 3 min\
    \      | 1776    | 16 minutes  |\n             |         |            |      \
    \   |             |\n             | 25      | 1.5 hour   | 1936    | 9 hours \
    \    |\n             |         |            |         |             |\n      \
    \       | 15/10   | 6 sec      | 3172    | 9 hours     |\n             |     \
    \    |            |         |             |\n             | 15/15   | 6 sec  \
    \    | 3332    | 12 days     |\n             |         |            |        \
    \ |             |\n             | 20/10   | 3 min      | 3332    | 12 days   \
    \  |\n             |         |            |         |             |\n        \
    \     | 20/15   | 3 min      | 3492    | 1 year      |\n             |       \
    \  |            |         |             |\n             | 25/10   | 1.5 hour \
    \  | 3492    | 1 year      |\n             |         |            |         |\
    \             |\n             | 25/15   | 1.5 hour   | 3652    | 34 years    |\n\
    \             +---------+------------+---------+-------------+\n             \
    \                     Table 3\n   ParmSet:  this is the height of the Merkle tree(s);\
    \ parameter sets\n      listed as a single integer have L=1 and consist of a single\
    \ Merkle\n      tree of that height; parameter sets with L=2 are listed as x/y,\n\
    \      with x being the height of the top-level Merkle tree and y being\n    \
    \  the bottom level.\n   KeyGenTime:  the measured key-generation time; that is,\
    \ the time\n      needed to generate the public/private key pair.\n   SigSize:\
    \  the size of a signature (in bytes)\n   KeyLifetime:  the lifetime of a key,\
    \ assuming we generated 1000\n      signatures per second.  In practice, we're\
    \ not likely to get\n      anywhere close to 1000 signatures per second sustained;\
    \ if you\n      have a more appropriate figure for your scenario, this column\
    \ is\n      easy to recompute.\n   As for signature generation or verification\
    \ times, those are\n   moderately insensitive to the above parameter settings\
    \ (except for\n   the Winternitz setting and the number of Merkle trees for\n\
    \   verification).  Tests on the same machine (without multithreading)\n   gave\
    \ approximately 4 msec to sign a short message, 2.6 msec to\n   verify; these\
    \ tests used a two-level ParmSet; a single level would\n   approximately halve\
    \ the verification time.  All times can be\n   significantly improved (by perhaps\
    \ a factor of 8) by using a\n   parameter set with W=4; however, that also about\
    \ doubles the\n   signature size.\n"
- title: 7.  Rationale
  contents:
  - "7.  Rationale\n   The goal of this note is to describe the LM-OTS, LMS, and HSS\n\
    \   algorithms following the original references and present the modern\n   security\
    \ analysis of those algorithms.  Other signature methods are\n   out of scope\
    \ and may be interesting follow-on work.\n   We adopt the techniques described\
    \ by Leighton and Micali to mitigate\n   attacks that amortize their work over\
    \ multiple invocations of the\n   hash function.\n   The values taken by the identifier\
    \ I across different LMS public/\n   private key pairs are chosen randomly in\
    \ order to improve security.\n   The analysis of this method in [Fluhrer17] shows\
    \ that we do not need\n   uniqueness to ensure security; we do need to ensure\
    \ that we don't\n   have a large number of private keys that use the same I value.\
    \  By\n   randomly selecting 16-byte I values, the chance that, out of 2^64\n\
    \   private keys, 4 or more of them will use the same I value is\n   negligible\
    \ (that is, has probability less than 2^-128).\n   The reason 16-byte I values\
    \ were selected was to optimize the\n   Winternitz hash-chain operation.  With\
    \ the current settings, the\n   value being hashed is exactly 55 bytes long (for\
    \ a 32-byte hash\n   function), which SHA-256 can hash in a single hash-compression\n\
    \   operation.  Other hash functions may be used in future\n   specifications;\
    \ all the ones that we will be likely to support\n   (SHA-512/256 and the various\
    \ SHA-3 hashes) would work well with a\n   16-byte I value.\n   The signature\
    \ and public key formats are designed so that they are\n   relatively easy to\
    \ parse.  Each format starts with a 32-bit\n   enumeration value that indicates\
    \ the details of the signature\n   algorithm and provides all of the information\
    \ that is needed in order\n   to parse the format.\n   The Checksum (Section 4.4)\
    \ is calculated using a nonnegative integer\n   \"sum\" whose width was chosen\
    \ to be an integer number of w-bit fields\n   such that it is capable of holding\
    \ the difference of the total\n   possible number of applications of the function\
    \ H (as defined in the\n   signing algorithm of Section 4.5) and the total actual\
    \ number.  In\n   the case that the number of times H is applied is 0, the sum\
    \ is (2^w\n   - 1) * (8*n/w).  Thus, for the purposes of this document, which\n\
    \   describes signature methods based on H = SHA256 (n = 32 bytes) and w\n   =\
    \ { 1, 2, 4, 8 }, the sum variable is a 16-bit nonnegative integer\n   for all\
    \ combinations of n and w.  The calculation uses the parameter\n   ls defined\
    \ in Section 4.1 and calculated in Appendix B, which\n   indicates the number\
    \ of bits used in the left-shift operation.\n"
- title: 7.1.  Security String
  contents:
  - "7.1.  Security String\n   To improve security against attacks that amortize their\
    \ effort\n   against multiple invocations of the hash function, Leighton and\n\
    \   Micali introduced a \"security string\" that is distinct for each\n   invocation\
    \ of that function.  Whenever this process computes a hash,\n   the string being\
    \ hashed will start with a string formed from the\n   fields below.  These fields\
    \ will appear in fixed locations in the\n   value we compute the hash of, and\
    \ so we list where in the hash these\n   fields would be present.  The fields\
    \ that make up this string are as\n   follows:\n   I     A 16-byte identifier\
    \ for the LMS public/private key pair.  It\n         MUST be chosen uniformly\
    \ at random, or via a pseudorandom\n         process, at the time that a key pair\
    \ is generated, in order to\n         minimize the probability that any specific\
    \ value of I be used\n         for a large number of different LMS private keys.\
    \  This is\n         always bytes 0-15 of the value being hashed.\n   r     In\
    \ the LMS N-time signature scheme, the node number r\n         associated with\
    \ a particular node of a hash tree is used as an\n         input to the hash used\
    \ to compute that node.  This value is\n         represented as a 32-bit (four\
    \ byte) unsigned integer in network\n         byte order.  Either r or q (depending\
    \ on the domain-separation\n         parameter) will be bytes 16-19 of the value\
    \ being hashed.\n   q     In the LMS N-time signature scheme, each LM-OTS signature\
    \ is\n         associated with the leaf of a hash tree, and q is set to the\n\
    \         leaf number.  This ensures that a distinct value of q is used\n    \
    \     for each distinct LM-OTS public/private key pair.  This value\n        \
    \ is represented as a 32-bit (four byte) unsigned integer in\n         network\
    \ byte order.  Either r or q (depending on the domain-\n         separation parameter)\
    \ will be bytes 16-19 of the value being\n         hashed.\n   D     A domain-separation\
    \ parameter, which is a two-byte identifier\n         that takes on different\
    \ values in the different contexts in\n         which the hash function is invoked.\
    \  D occurs in bytes 20 and\n         21 of the value being hashed and takes on\
    \ the following values:\n            D_PBLC = 0x8080 when computing the hash of\
    \ all of the\n            iterates in the LM-OTS algorithm\n            D_MESG\
    \ = 0x8181 when computing the hash of the message in\n            the LM-OTS algorithms\n\
    \            D_LEAF = 0x8282 when computing the hash of the leaf of an\n     \
    \       LMS tree\n            D_INTR = 0x8383 when computing the hash of an interior\
    \ node\n            of an LMS tree\n   i     A value between 0 and 264; this is\
    \ used in the LM-OTS scheme\n         when either computing the iterations of\
    \ the Winternitz chain or\n         using the suggested LM-OTS private key generation\
    \ process.  It\n         is represented as a 16-bit (two-byte) unsigned integer\
    \ in\n         network byte order.  If present, it occurs at bytes 20 and 21\n\
    \         of the value being hashed.\n   j     In the LM-OTS scheme, j is the\
    \ iteration number used when the\n         private key element is being iteratively\
    \ hashed.  It is\n         represented as an 8-bit (one byte) unsigned integer\
    \ and is\n         present if i is a value between 0 and 264.  If present, it\n\
    \         occurs at bytes 22 to 21+n of the value being hashed.\n   C     An n-byte\
    \ randomizer that is included with the message whenever\n         it is being\
    \ hashed to improve security.  C MUST be chosen\n         uniformly at random\
    \ or via another unpredictable process.  It\n         is present if D=D_MESG,\
    \ and it occurs at bytes 22 to 21+n of\n         the value being hashed.\n"
- title: 8.  IANA Considerations
  contents:
  - "8.  IANA Considerations\n   IANA has created two registries: \"LM-OTS Signatures\"\
    , which includes\n   all of the LM-OTS signatures as defined in Section 4, and\
    \ \"Leighton-\n   Micali Signatures (LMS)\" for LMS as defined in Section 5.\n\
    \   Additions to these registries require that a specification be\n   documented\
    \ in an RFC or another permanent and readily available\n   reference in sufficient\
    \ detail that interoperability between\n   independent implementations is possible\
    \ [RFC8126].  IANA MUST verify\n   that all applications for additions to these\
    \ registries have first\n   been reviewed by the IRTF Crypto Forum Research Group\
    \ (CFRG).\n   Each entry in either of the registries contains the following\n\
    \   elements:\n      a short name (Name), such as \"LMS_SHA256_M32_H10\",\n  \
    \    a positive number (Numeric Identifier), and\n      a Reference to a specification\
    \ that completely defines the\n      signature-method test cases that can be used\
    \ to verify the\n      correctness of an implementation.\n   The numbers between\
    \ 0xDDDDDDDD (decimal 3,722,304,989) and 0xFFFFFFFF\n   (decimal 4,294,967,295),\
    \ inclusive, will not be assigned by IANA and\n   are reserved for private use;\
    \ no attempt will be made to prevent\n   multiple sites from using the same value\
    \ in different (and\n   incompatible) ways [RFC8126].\n   The initial contents\
    \ of the \"LM-OTS Signatures\" registry are as\n   follows.\n    +--------------------------+-----------+--------------------------+\n\
    \    | Name                     | Reference |    Numeric Identifier    |\n   \
    \ +--------------------------+-----------+--------------------------+\n    | Reserved\
    \                 |           |        0x00000000        |\n    |            \
    \              |           |                          |\n    | LMOTS_SHA256_N32_W1\
    \      | Section 4 |        0x00000001        |\n    |                       \
    \   |           |                          |\n    | LMOTS_SHA256_N32_W2      |\
    \ Section 4 |        0x00000002        |\n    |                          |   \
    \        |                          |\n    | LMOTS_SHA256_N32_W4      | Section\
    \ 4 |        0x00000003        |\n    |                          |           |\
    \                          |\n    | LMOTS_SHA256_N32_W8      | Section 4 |   \
    \     0x00000004        |\n    |                          |           |      \
    \                    |\n    | Unassigned               |           | 0x00000005\
    \ - 0xDDDDDDDC  |\n    |                          |           |              \
    \            |\n    | Reserved for Private Use |           | 0xDDDDDDDD - 0xFFFFFFFF\
    \  |\n    +--------------------------+-----------+--------------------------+\n\
    \                                  Table 4\n   The initial contents of the \"\
    Leighton Micali Signatures (LMS)\"\n   registry are as follows.\n    +--------------------------+-----------+--------------------------+\n\
    \    | Name                     | Reference |    Numeric Identifier    |\n   \
    \ +--------------------------+-----------+--------------------------+\n    | Reserved\
    \                 |           |        0x0 - 0x4         |\n    |            \
    \              |           |                          |\n    | LMS_SHA256_M32_H5\
    \        | Section 5 |        0x00000005        |\n    |                     \
    \     |           |                          |\n    | LMS_SHA256_M32_H10     \
    \  | Section 5 |        0x00000006        |\n    |                          |\
    \           |                          |\n    | LMS_SHA256_M32_H15       | Section\
    \ 5 |        0x00000007        |\n    |                          |           |\
    \                          |\n    | LMS_SHA256_M32_H20       | Section 5 |   \
    \     0x00000008        |\n    |                          |           |      \
    \                    |\n    | LMS_SHA256_M32_H25       | Section 5 |        0x00000009\
    \        |\n    |                          |           |                     \
    \     |\n    | Unassigned               |           | 0x0000000A - 0xDDDDDDDC\
    \  |\n    |                          |           |                          |\n\
    \    | Reserved for Private Use |           | 0xDDDDDDDD - 0xFFFFFFFF  |\n   \
    \ +--------------------------+-----------+--------------------------+\n      \
    \                            Table 5\n   An IANA registration of a signature system\
    \ does not constitute an\n   endorsement of that system or its security.\n   Currently,\
    \ the two registries assign a disjoint set of values to the\n   defined parameter\
    \ sets.  This coincidence is a historical accident;\n   the correctness of the\
    \ system does not depend on this.  IANA is not\n   required to maintain this situation.\n"
- title: 9.  Security Considerations
  contents:
  - "9.  Security Considerations\n   The hash function H MUST have second preimage\
    \ resistance: it must be\n   computationally infeasible for an attacker that is\
    \ given one message\n   M to be able to find a second message M' such that H(M)\
    \ = H(M').\n   The security goal of a signature system is to prevent forgeries.\
    \  A\n   successful forgery occurs when an attacker who does not know the\n  \
    \ private key associated with a public key can find a message (distinct\n   from\
    \ all previously signed ones) and signature that is valid with\n   that public\
    \ key (that is, the Signature Verification algorithm\n   applied to that signature\
    \ and message and public key will return\n   VALID).  Such an attacker, in the\
    \ strongest case, may have the\n   ability to forge valid signatures for an arbitrary\
    \ number of other\n   messages.\n   LMS is provably secure in the random oracle\
    \ model, as shown by\n   [Katz16].  In addition, further analysis is done by [Fluhrer17],\n\
    \   where the hash compression function (rather than the entire hash\n   function)\
    \ is considered to be a random oracle.  Corollary 1 of the\n   latter paper states:\n\
    \      If we have no more than 2^64 randomly chosen LMS private keys,\n      allow\
    \ the attacker access to a signing oracle and a SHA-256 hash\n      compression\
    \ oracle, and allow a maximum of 2^120 hash compression\n      computations, then\
    \ the probability of an attacker being able to\n      generate a single forgery\
    \ against any of those LMS keys is less\n      than 2^-129.\n   Many of the objects\
    \ within the public key and the signature start\n   with a typecode.  A verifier\
    \ MUST check each of these typecodes, and\n   a verification operation on a signature\
    \ with an unknown type, or a\n   type that does not correspond to the type within\
    \ the public key, MUST\n   return INVALID.  The expected length of a variable-length\
    \ object can\n   be determined from its typecode; if an object has a different\
    \ length,\n   then any signature computed from the object is INVALID.\n"
- title: 9.1.  Hash Formats
  contents:
  - "9.1.  Hash Formats\n   The format of the inputs to the hash function H has the\
    \ property that\n   each invocation of that function has an input that is repeated\
    \ by a\n   small bounded number of other inputs (due to potential repeats of the\n\
    \   I value).  In particular, it will vary somewhere in the first 23\n   bytes\
    \ of the value being hashed.  This property is important for a\n   proof of security\
    \ in the random oracle model.\n   The formats used during key generation and signing\
    \ (including the\n   recommended pseudorandom key-generation procedure in Appendix\
    \ A) are\n   as follows:\n      I || u32str(q) || u16str(i) || u8str(j) || tmp\n\
    \      I || u32str(q) || u16str(D_PBLC) || y[0] || ... || y[p-1]\n      I || u32str(q)\
    \ || u16str(D_MESG) || C || message\n      I || u32str(r) || u16str(D_LEAF) ||\
    \ OTS_PUB_HASH[r-2^h]\n      I || u32str(r) || u16str(D_INTR) || T[2*r] || T[2*r+1]\n\
    \      I || u32str(q) || u16str(i) || u8str(0xff) || SEED\n   Each hash type listed\
    \ is distinct; at locations 20 and 21 of the\n   value being hashed, there exists\
    \ either a fixed value D_PBLC, D_MESG,\n   D_LEAF, D_INTR, or a 16-bit value i.\
    \  These fixed values are distinct\n   from each other and are large (over 32768),\
    \ while the 16-bit values\n   of i are small (currently no more than 265; possibly\
    \ being slightly\n   larger if larger hash functions are supported); hence, the\
    \ range of\n   possible values of i will not collide any of the D_PBLC, D_MESG,\n\
    \   D_LEAF, D_INTR identifiers.  The only other collision possibility is\n   the\
    \ Winternitz chain hash colliding with the recommended pseudorandom\n   key-generation\
    \ process; here, at location 22 of the value being\n   hashed, the Winternitz\
    \ chain function has the value u8str(j), where j\n   is a value between 0 and\
    \ 254, while location 22 of the recommended\n   pseudorandom key-generation process\
    \ has value 255.\n   For the Winternitz chaining function, D_PBLC, and D_MESG,\
    \ the value\n   of I || u32str(q) is distinct for each LMS leaf (or equivalently,\
    \ for\n   each q value).  For the Winternitz chaining function, the value of\n\
    \   u16str(i) || u8str(j) is distinct for each invocation of H for a\n   given\
    \ leaf.  For D_PBLC and D_MESG, the input format is used only\n   once for each\
    \ value of q and, thus, distinctness is assured.  The\n   formats for D_INTR and\
    \ D_LEAF are used exactly once for each value of\n   r, which ensures their distinctness.\
    \  For the recommended\n   pseudorandom key-generation process, for a given value\
    \ of I, q and j\n   are distinct for each invocation of H.\n   The value of I\
    \ is chosen uniformly at random from the set of all\n   128-bit strings.  If 2^64\
    \ public keys are generated (and, hence, 2^64\n   random I values), there is a\
    \ nontrivial probability of a duplicate\n   (which would imply duplicate prefixes).\
    \  However, there will be an\n   extremely high probability there will not be\
    \ a four-way collision\n   (that is, any I value used for four distinct LMS keys;\
    \ probability <\n   2^-132), and, hence, the number of repeats for any specific\
    \ prefix\n   will be limited to at most three.  This is shown (in [Fluhrer17])\
    \ to\n   have only a limited effect on the security of the system.\n"
- title: 9.2.  Stateful Signature Algorithm
  contents:
  - "9.2.  Stateful Signature Algorithm\n   The LMS signature system, like all N-time\
    \ signature systems, requires\n   that the signer maintain state across different\
    \ invocations of the\n   signing algorithm to ensure that none of the component\
    \ one-time\n   signature systems are used more than once.  This section calls\
    \ out\n   some important practical considerations around this statefulness.\n\
    \   These issues are discussed in greater detail in [STMGMT].\n   In a typical\
    \ computing environment, a private key will be stored in\n   nonvolatile media\
    \ such as on a hard drive.  Before it is used to sign\n   a message, it will be\
    \ read into an application's Random-Access Memory\n   (RAM).  After a signature\
    \ is generated, the value of the private key\n   will need to be updated by writing\
    \ the new value of the private key\n   into nonvolatile storage.  It is essential\
    \ for security that the\n   application ensures that this value is actually written\
    \ into that\n   storage, yet there may be one or more memory caches between it\
    \ and\n   the application.  Memory caching is commonly done in the file system\n\
    \   and in a physical memory unit on the hard disk that is dedicated to\n   that\
    \ purpose.  To ensure that the updated value is written to\n   physical media,\
    \ the application may need to take several special\n   steps.  In a POSIX environment,\
    \ for instance, the O_SYNC flag (for\n   the open() system call) will cause invocations\
    \ of the write() system\n   call to block the calling process until the data has\
    \ been written to\n   the underlying hardware.  However, if that hardware has\
    \ its own\n   memory cache, it must be separately dealt with using an operating\n\
    \   system or device-specific tool such as hdparm to flush the on-drive\n   cache\
    \ or turn off write caching for that drive.  Because these\n   details vary across\
    \ different operating systems and devices, this\n   note does not attempt to provide\
    \ complete guidance; instead, we call\n   the implementer's attention to these\
    \ issues.\n   When hierarchical signatures are used, an easy way to minimize the\n\
    \   private key synchronization issues is to have the private key for the\n  \
    \ second-level resident in RAM only and never write that value into\n   nonvolatile\
    \ memory.  A new second-level public/private key pair will\n   be generated whenever\
    \ the application (re)starts; thus, failures such\n   as a power outage or application\
    \ crash are automatically\n   accommodated.  Implementations SHOULD use this approach\
    \ wherever\n   possible.\n"
- title: 9.3.  Security of LM-OTS Checksum
  contents:
  - "9.3.  Security of LM-OTS Checksum\n   To show the security of LM-OTS checksum,\
    \ we consider the signature y\n   of a message with a private key x and let h\
    \ = H(message) and\n   c = Cksm(H(message)) (see Section 4.5).  To attempt a forgery,\
    \ an\n   attacker may try to change the values of h and c.  Let h' and c'\n  \
    \ denote the values used in the forgery attempt.  If for some integer j\n   in\
    \ the range 0 to u, where u = ceil(8*n/w) is the size of the range\n   that the\
    \ checksum value can cover, inclusive,\n      a' = coef(h', j, w),\n      a =\
    \ coef(h, j, w), and\n      a' > a\n   then the attacker can compute F^a'(x[j])\
    \ from F^a(x[j]) = y[j] by\n   iteratively applying function F to the j-th term\
    \ of the signature an\n   additional (a' - a) times.  However, as a result of\
    \ the increased\n   number of hashing iterations, the checksum value c' will decrease\n\
    \   from its original value of c.  Thus, a valid signature's checksum\n   will\
    \ have, for some number k in the range u to (p-1), inclusive,\n      b' = coef(c',\
    \ k, w),\n      b = coef(c, k, w), and\n      b' < b\n   Due to the one-way property\
    \ of F, the attacker cannot easily compute\n   F^b'(x[k]) from F^b(x[k]) = y[k].\n"
- title: 10.  Comparison with Other Work
  contents:
  - "10.  Comparison with Other Work\n   The eXtended Merkle Signature Scheme (XMSS)\
    \ is similar to HSS in\n   several ways [XMSS][RFC8391].  Both are stateful hash-based\
    \ signature\n   schemes, and both use a hierarchical approach, with a Merkle tree\
    \ at\n   each level of the hierarchy.  XMSS signatures are slightly shorter\n\
    \   than HSS signatures, for equivalent security and an equal number of\n   signatures.\n\
    \   HSS has several advantages over XMSS.  HSS operations are roughly\n   four\
    \ times faster than the comparable XMSS ones, when SHA256 is used\n   as the underlying\
    \ hash.  This occurs because the hash operation done\n   as a part of the Winternitz\
    \ iterations dominates performance, and\n   XMSS performs four compression-function\
    \ invocations (two for the PRF,\n   two for the F function) where HSS only needs\
    \ to perform one.\n   Additionally, HSS is somewhat simpler (as each hash invocation\
    \ is\n   just a prefix followed by the data being hashed).\n"
- title: 11.  References
  contents:
  - '11.  References

    '
- title: 11.1.  Normative References
  contents:
  - "11.1.  Normative References\n   [FIPS180]  National Institute of Standards and\
    \ Technology, \"Secure\n              Hash Standard (SHS)\", FIPS PUB 180-4,\n\
    \              DOI 10.6028/NIST.FIPS.180-4, March 2012.\n   [RFC2119]  Bradner,\
    \ S., \"Key words for use in RFCs to Indicate\n              Requirement Levels\"\
    , BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n       \
    \       <https://www.rfc-editor.org/info/rfc2119>.\n   [RFC4506]  Eisler, M.,\
    \ Ed., \"XDR: External Data Representation\n              Standard\", STD 67,\
    \ RFC 4506, DOI 10.17487/RFC4506, May\n              2006, <https://www.rfc-editor.org/info/rfc4506>.\n\
    \   [RFC8126]  Cotton, M., Leiba, B., and T. Narten, \"Guidelines for\n      \
    \        Writing an IANA Considerations Section in RFCs\", BCP 26,\n         \
    \     RFC 8126, DOI 10.17487/RFC8126, June 2017,\n              <https://www.rfc-editor.org/info/rfc8126>.\n\
    \   [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n     \
    \         2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n        \
    \      May 2017, <https://www.rfc-editor.org/info/rfc8174>.\n   [RFC8179]  Bradner,\
    \ S. and J. Contreras, \"Intellectual Property\n              Rights in IETF Technology\"\
    , BCP 79, RFC 8179,\n              DOI 10.17487/RFC8179, May 2017,\n         \
    \     <https://www.rfc-editor.org/info/rfc8179>.\n   [USPTO5432852]\n        \
    \      Leighton, T. and S. Micali, \"Large provably fast and\n              secure\
    \ digital signature schemes based on secure hash\n              functions\", U.S.\
    \ Patent 5,432,852, July 1995.\n"
- title: 11.2.  Informative References
  contents:
  - "11.2.  Informative References\n   [C:Merkle87]\n              Merkle, R., \"\
    A Digital Signature Based on a Conventional\n              Encryption Function\"\
    , in Advances in Cryptology -- CRYPTO\n              '87 Proceedings, Lecture\
    \ Notes in Computer Science Vol.\n              293, DOI 10.1007/3-540-48184-2_32,\
    \ 1988.\n   [C:Merkle89a]\n              Merkle, R., \"A Certified Digital Signature\"\
    , in Advances\n              in Cryptology -- CRYPTO '89 Proceedings, Lecture\
    \ Notes in\n              Computer Science Vol. 435, DOI 10.1007/0-387-34805-0_21,\n\
    \              1990.\n   [C:Merkle89b]\n              Merkle, R., \"One Way Hash\
    \ Functions and DES\", in Advances\n              in Cryptology -- CRYPTO '89\
    \ Proceedings, Lecture Notes in\n              Computer Science Vol. 435, DOI\
    \ 10.1007/0-387-34805-0_40,\n              1990.\n   [Fluhrer17]\n           \
    \   Fluhrer, S., \"Further Analysis of a Proposed Hash-Based\n              Signature\
    \ Standard\", Cryptology ePrint Archive Report\n              2017/553, 2017,\
    \ <https://eprint.iacr.org/2017/553>.\n   [Katz16]   Katz, J., \"Analysis of a\
    \ Proposed Hash-Based Signature\n              Standard\", in SSR 2016: Security\
    \ Standardisation Research\n              (SSR) pp. 261-273, Lecture Notes in\
    \ Computer Science Vol.\n              10074, DOI 10.1007/978-3-319-49100-4_12,\
    \ 2016.\n   [Merkle79]\n              Merkle, R., \"Secrecy, Authentication, and\
    \ Public Key\n              Systems\", Technical Report No. 1979-1, Information\
    \ Systems\n              Laboratory, Stanford University, 1979,\n            \
    \  <http://www.merkle.com/papers/Thesis1979.pdf>.\n   [RFC8391]  Huelsing, A.,\
    \ Butin, D., Gazdag, S., Rijneveld, J., and A.\n              Mohaisen, \"XMSS:\
    \ eXtended Merkle Signature Scheme\",\n              RFC 8391, DOI 10.17487/RFC8391,\
    \ May 2018,\n              <https://www.rfc-editor.org/info/rfc8391>.\n   [STMGMT]\
    \   McGrew, D., Kampanakis, P., Fluhrer, S., Gazdag, S.,\n              Butin,\
    \ D., and J. Buchmann, \"State Management for Hash-\n              Based Signatures.\"\
    , in SSR 2016: Security Standardisation\n              Research (SSR) pp. 244-260,\
    \ Lecture Notes in Computer\n              Science Vol. 10074, DOI 10.1007/978-3-319-49100-4_11,\n\
    \              2016.\n   [XMSS]     Buchmann, J., Dahmen, E., and , \"XMSS --\
    \ A Practical\n              Forward Secure Signature Scheme Based on Minimal\
    \ Security\n              Assumptions.\", in PQCrypto 2011: Post-Quantum Cryptography\n\
    \              pp. 117-129, Lecture Notes in Computer Science Vol. 7071,\n   \
    \           DOI 10.1007/978-3-642-25405-5_8, 2011.\n"
- title: Appendix A.  Pseudorandom Key Generation
  contents:
  - "Appendix A.  Pseudorandom Key Generation\n   An implementation MAY use the following\
    \ pseudorandom process for\n   generating an LMS private key.\n      SEED is an\
    \ m-byte value that is generated uniformly at random at\n      the start of the\
    \ process,\n      I is the LMS key pair identifier,\n      q denotes the LMS leaf\
    \ number of an LM-OTS private key,\n      x_q denotes the x array of private elements\
    \ in the LM-OTS private\n      key with leaf number q,\n      i is the index of\
    \ the private key element, and\n      H is the hash function used in LM-OTS.\n\
    \   The elements of the LM-OTS private keys are computed as:\n   x_q[i] = H(I\
    \ || u32str(q) || u16str(i) || u8str(0xff) || SEED).\n   This process stretches\
    \ the m-byte random value SEED into a (much\n   larger) set of pseudorandom values,\
    \ using a unique counter in each\n   invocation of H.  The format of the inputs\
    \ to H are chosen so that\n   they are distinct from all other uses of H in LMS\
    \ and LM-OTS.  A\n   careful reader will note that this is similar to the hash\
    \ we perform\n   when iterating through the Winternitz chain; however, in that\
    \ chain,\n   the iteration index will vary between 0 and 254 maximum (for W=8),\n\
    \   while the corresponding value in this formula is 255.  This algorithm\n  \
    \ is included in the proof of security in [Fluhrer17] and hence this\n   method\
    \ is safe when used within the LMS system; however, any other\n   cryptographically\
    \ secure method of generating private keys would also\n   be safe.\n"
- title: Appendix B.  LM-OTS Parameter Options
  contents:
  - "Appendix B.  LM-OTS Parameter Options\n   The LM-OTS one-time signature method\
    \ uses several internal\n   parameters, which are a function of the selected parameter\
    \ set.\n   These internal parameters include the following:\n   p     This is\
    \ the number of independent Winternitz chains used in the\n         signature;\
    \ it will be the number of w-bit digits needed to hold\n         the n-bit hash\
    \ (u in the below equations), along with the\n         number of digits needed\
    \ to hold the checksum (v in the below\n         equations)\n   ls    This is\
    \ the size of the shift needed to move the checksum so\n         that it appears\
    \ in the checksum digits\n   ls is needed because, while we express the checksum\
    \ internally as a\n   16-bit value, we don't always express all 16 bits in the\
    \ signature;\n   for example, if w=4, we might use only the top 12 bits.  Because\
    \ we\n   read the checksum in network order, this means that, without the\n  \
    \ shift, we'll use the higher-order bits (which may be always 0) and\n   omit\
    \ the lower-order bits (where the checksum value actually\n   resides).  This\
    \ shift is here to ensure that the parts of the\n   checksum we need to express\
    \ (for security) actually contribute to the\n   signature; when multiple such\
    \ shifts are possible, we take the\n   minimal value.\n   The parameters ls and\
    \ p are computed as follows:\n     u = ceil(8*n/w)\n     v = ceil((floor(lg((2^w\
    \ - 1) * u)) + 1) / w)\n     ls = 16 - (v * w)\n     p = u + v\n   Here, u and\
    \ v represent the number of w-bit fields required to\n   contain the hash of the\
    \ message and the checksum byte strings,\n   respectively.  And as the value of\
    \ p is the number of w-bit elements\n   of ( H(message) || Cksm(H(message)) ),\
    \ it is also equivalently the\n   number of byte strings that form the private\
    \ key and the number of\n   byte strings in the signature.  The value 16 in the\
    \ ls computation of\n   ls corresponds to the 16-bit value used for the sum variable\
    \ in\n   Algorithm 2 in Section 4.4\n   A table illustrating various combinations\
    \ of n and w with the\n   associated values of u, v, ls, and p is provided in\
    \ Table 6.\n   +---------+------------+-----------+-----------+-------+------------+\n\
    \   |   Hash  | Winternitz |   w-bit   |   w-bit   |  Left |   Total    |\n  \
    \ |  Length | Parameter  |  Elements |  Elements | Shift | Number of  |\n   |\
    \    in   |    (w)     |  in Hash  |     in    |  (ls) |   w-bit    |\n   |  Bytes\
    \  |            |    (u)    |  Checksum |       |  Elements  |\n   |   (n)   |\
    \            |           |    (v)    |       |    (p)     |\n   +---------+------------+-----------+-----------+-------+------------+\n\
    \   |    32   |     1      |    256    |     9     |   7   |    265     |\n  \
    \ |         |            |           |           |       |            |\n   |\
    \    32   |     2      |    128    |     5     |   6   |    133     |\n   |  \
    \       |            |           |           |       |            |\n   |    32\
    \   |     4      |     64    |     3     |   4   |     67     |\n   |        \
    \ |            |           |           |       |            |\n   |    32   |\
    \     8      |     32    |     2     |   0   |     34     |\n   +---------+------------+-----------+-----------+-------+------------+\n\
    \                                  Table 6\n"
- title: Appendix C.  An Iterative Algorithm for Computing an LMS Public Key
  contents:
  - "Appendix C.  An Iterative Algorithm for Computing an LMS Public Key\n   The LMS\
    \ public key can be computed using the following algorithm or\n   any equivalent\
    \ method.  The algorithm uses a stack of hashes for\n   data.  It also makes use\
    \ of a hash function with the typical\n   init/update/final interface to hash\
    \ functions; the result of the\n   invocations hash_init(), hash_update(N[1]),\
    \ hash_update(N[2]), ... ,\n   hash_update(N[n]), v = hash_final(), in that order,\
    \ is identical to\n   that of the invocation of H(N[1] || N[2] || ... || N[n]).\n\
    \   Generating an LMS Public Key from an LMS Private Key\n     for ( i = 0; i\
    \ < 2^h; i = i + 1 ) {\n       r = i + num_lmots_keys;\n       temp = H(I || u32str(r)\
    \ || u16str(D_LEAF) || OTS_PUB_HASH[i])\n       j = i;\n       while (j % 2 ==\
    \ 1) {\n         r = (r - 1)/2;\n         j = (j-1) / 2;\n         left_side =\
    \ pop(data stack);\n         temp = H(I || u32str(r) || u16str(D_INTR) || left_side\
    \ || temp)\n       }\n       push temp onto the data stack\n    }\n    public_key\
    \ = pop(data stack)\n   Note that this pseudocode expects that all 2^h leaves\
    \ of the tree\n   have equal depth -- that is, it expects num_lmots_keys to be\
    \ a power\n   of 2.  The maximum depth of the stack will be h-1 elements -- that\n\
    \   is, a total of (h-1)*n bytes; for the currently defined parameter\n   sets,\
    \ this will never be more than 768 bytes of data.\n"
- title: Appendix D.  Method for Deriving Authentication Path for a Signature
  contents:
  - "Appendix D.  Method for Deriving Authentication Path for a Signature\n   The\
    \ LMS signature consists of u32str(q) || lmots_signature ||\n   u32str(type) ||\
    \ path[0] || path[1] || ... || path[h-1].  This\n   appendix shows one method\
    \ of constructing this signature, assuming\n   that the implementation has stored\
    \ the T[] array that was used to\n   construct the public key.  Note that this\
    \ is not the only possible\n   method; other methods exist that don't assume that\
    \ you have the\n   entire T[] array in memory.  To construct a signature, you\
    \ perform\n   the following algorithm:\n   Generating an LMS Signature\n     1.\
    \ Set type to the typecode of the LMS algorithm.\n     2. Extract h from the typecode,\
    \ according to Table 2.\n     3. Create the LM-OTS signature for the message:\n\
    \        ots_signature = lmots_sign(message, LMS_PRIV[q])\n     4. Compute the\
    \ array path as follows:\n        i = 0\n        r = 2^h + q\n        while (i\
    \ < h) {\n          temp = (r / 2^i) xor 1\n          path[i] = T[temp]\n    \
    \      i = i + 1\n        }\n     5. S = u32str(q) || ots_signature || u32str(type)\
    \ ||\n                             path[0] || path[1] || ... || path[h-1]\n  \
    \   6. q = q + 1\n     7. Return S.\n   Here \"xor\" is the bitwise exclusive-or\
    \ operation, and / is integer\n   division (that is, rounded down to an integer\
    \ value).\n"
- title: Appendix E.  Example Implementation
  contents:
  - "Appendix E.  Example Implementation\n   An example implementation can be found\
    \ online at\n   <https://github.com/cisco/hash-sigs>.\n"
- title: Appendix F.  Test Cases
  contents:
  - "Appendix F.  Test Cases\n   This section provides test cases that can be used\
    \ to verify or debug\n   an implementation.  This data is formatted with the name\
    \ of the\n   elements on the left and the hexadecimal value of the elements on\
    \ the\n   right.  The concatenation of all of the values within a public key or\n\
    \   signature produces that public key or signature, and values that do\n   not\
    \ fit within a single line are listed across successive lines.\n   Test Case 1\
    \ Public Key\n   --------------------------------------------\n   HSS public key\n\
    \   levels      00000002\n   --------------------------------------------\n  \
    \ LMS type    00000005                         # LM_SHA256_M32_H5\n   LMOTS type\
    \  00000004                         # LMOTS_SHA256_N32_W8\n   I           61a5d57d37f5e46bfb7520806b07a1b8\n\
    \   K           50650e3b31fe4a773ea29a07f09cf2ea\n               30e579f0df58ef8e298da0434cb2b878\n\
    \   --------------------------------------------\n   --------------------------------------------\n\
    \   Test Case 1 Message\n   --------------------------------------------\n   Message\
    \     54686520706f77657273206e6f742064  |The powers not d|\n               656c65676174656420746f2074686520\
    \  |elegated to the |\n               556e6974656420537461746573206279  |United\
    \ States by|\n               2074686520436f6e737469747574696f  | the Constitutio|\n\
    \               6e2c206e6f722070726f686962697465  |n, nor prohibite|\n       \
    \        6420627920697420746f207468652053  |d by it to the S|\n              \
    \ 74617465732c20617265207265736572  |tates, are reser|\n               76656420746f20746865205374617465\
    \  |ved to the State|\n               7320726573706563746976656c792c20  |s respectively,\
    \ |\n               6f7220746f207468652070656f706c65  |or to the people|\n   \
    \            2e0a                              |..|\n   --------------------------------------------\n\
    \   Test Case 1 Signature\n   --------------------------------------------\n \
    \  HSS signature\n   Nspk        00000001\n   sig[0]:\n   --------------------------------------------\n\
    \   LMS signature\n   q           00000005\n   --------------------------------------------\n\
    \   LMOTS signature\n   LMOTS type  00000004                         # LMOTS_SHA256_N32_W8\n\
    \   C           d32b56671d7eb98833c49b433c272586\n               bc4a1c8a8970528ffa04b966f9426eb9\n\
    \   y[0]        965a25bfd37f196b9073f3d4a232feb6\n               9128ec45146f86292f9dff9610a7bf95\n\
    \   y[1]        a64c7f60f6261a62043f86c70324b770\n               7f5b4a8a6e19c114c7be866d488778a0\n\
    \   y[2]        e05fd5c6509a6e61d559cf1a77a970de\n               927d60c70d3de31a7fa0100994e162a2\n\
    \   y[3]        582e8ff1b10cd99d4e8e413ef469559f\n               7d7ed12c838342f9b9c96b83a4943d16\n\
    \   y[4]        81d84b15357ff48ca579f19f5e71f184\n               66f2bbef4bf660c2518eb20de2f66e3b\n\
    \   y[5]        14784269d7d876f5d35d3fbfc7039a46\n               2c716bb9f6891a7f41ad133e9e1f6d95\n\
    \   y[6]        60b960e7777c52f060492f2d7c660e14\n               71e07e72655562035abc9a701b473ecb\n\
    \   y[7]        c3943c6b9c4f2405a3cb8bf8a691ca51\n               d3f6ad2f428bab6f3a30f55dd9625563\n\
    \   y[8]        f0a75ee390e385e3ae0b906961ecf41a\n               e073a0590c2eb6204f44831c26dd768c\n\
    \   y[9]        35b167b28ce8dc988a3748255230cef9\n               9ebf14e730632f27414489808afab1d1\n\
    \   y[10]       e783ed04516de012498682212b078105\n               79b250365941bcc98142da13609e9768\n\
    \   y[11]       aaf65de7620dabec29eb82a17fde35af\n               15ad238c73f81bdb8dec2fc0e7f93270\n\
    \   y[12]       1099762b37f43c4a3c20010a3d72e2f6\n               06be108d310e639f09ce7286800d9ef8\n\
    \   y[13]       a1a40281cc5a7ea98d2adc7c7400c2fe\n               5a101552df4e3cccfd0cbf2ddf5dc677\n\
    \   y[14]       9cbbc68fee0c3efe4ec22b83a2caa3e4\n               8e0809a0a750b73ccdcf3c79e6580c15\n\
    \   y[15]       4f8a58f7f24335eec5c5eb5e0cf01dcf\n               4439424095fceb077f66ded5bec73b27\n\
    \   y[16]       c5b9f64a2a9af2f07c05e99e5cf80f00\n               252e39db32f6c19674f190c9fbc506d8\n\
    \   y[17]       26857713afd2ca6bb85cd8c107347552\n               f30575a5417816ab4db3f603f2df56fb\n\
    \   y[18]       c413e7d0acd8bdd81352b2471fc1bc4f\n               1ef296fea1220403466b1afe78b94f7e\n\
    \   y[19]       cf7cc62fb92be14f18c2192384ebceaf\n               8801afdf947f698ce9c6ceb696ed70e9\n\
    \   y[20]       e87b0144417e8d7baf25eb5f70f09f01\n               6fc925b4db048ab8d8cb2a661ce3b57a\n\
    \   y[21]       da67571f5dd546fc22cb1f97e0ebd1a6\n               5926b1234fd04f171cf469c76b884cf3\n\
    \   y[22]       115cce6f792cc84e36da58960c5f1d76\n               0f32c12faef477e94c92eb75625b6a37\n\
    \   y[23]       1efc72d60ca5e908b3a7dd69fef02491\n               50e3eebdfed39cbdc3ce9704882a2072\n\
    \   y[24]       c75e13527b7a581a556168783dc1e975\n               45e31865ddc46b3c957835da252bb732\n\
    \   y[25]       8d3ee2062445dfb85ef8c35f8e1f3371\n               af34023cef626e0af1e0bc017351aae2\n\
    \   y[26]       ab8f5c612ead0b729a1d059d02bfe18e\n               fa971b7300e882360a93b025ff97e9e0\n\
    \   y[27]       eec0f3f3f13039a17f88b0cf808f4884\n               31606cb13f9241f40f44e537d302c64a\n\
    \   y[28]       4f1f4ab949b9feefadcb71ab50ef27d6\n               d6ca8510f150c85fb525bf25703df720\n\
    \   y[29]       9b6066f09c37280d59128d2f0f637c7d\n               7d7fad4ed1c1ea04e628d221e3d8db77\n\
    \   y[30]       b7c878c9411cafc5071a34a00f4cf077\n               38912753dfce48f07576f0d4f94f42c6\n\
    \   y[31]       d76f7ce973e9367095ba7e9a3649b7f4\n               61d9f9ac1332a4d1044c96aefee67676\n\
    \   y[32]       401b64457c54d65fef6500c59cdfb69a\n               f7b6dddfcb0f086278dd8ad0686078df\n\
    \   y[33]       b0f3f79cd893d314168648499898fbc0\n               ced5f95b74e8ff14d735cdea968bee74\n\
    \   --------------------------------------------\n   LMS type    00000005    \
    \                     # LM_SHA256_M32_H5\n   path[0]     d8b8112f9200a5e50c4a262165bd342c\n\
    \               d800b8496810bc716277435ac376728d\n   path[1]     129ac6eda839a6f357b5a04387c5ce97\n\
    \               382a78f2a4372917eefcbf93f63bb591\n   path[2]     12f5dbe400bd49e4501e859f885bf073\n\
    \               6e90a509b30a26bfac8c17b5991c157e\n   path[3]     b5971115aa39efd8d564a6b90282c316\n\
    \               8af2d30ef89d51bf14654510a12b8a14\n   path[4]     4cca1848cf7da59cc2b3d9d0692dd2a2\n\
    \               0ba3863480e25b1b85ee860c62bf5136\n   --------------------------------------------\n\
    \   LMS public key\n   LMS type    00000005                         # LM_SHA256_M32_H5\n\
    \   LMOTS type  00000004                         # LMOTS_SHA256_N32_W8\n   I \
    \          d2f14ff6346af964569f7d6cb880a1b6\n   K           6c5004917da6eafe4d9ef6c6407b3db0\n\
    \               e5485b122d9ebe15cda93cfec582d7ab\n   --------------------------------------------\n\
    \   final_signature:\n   --------------------------------------------\n   LMS\
    \ signature\n   q           0000000a\n   --------------------------------------------\n\
    \   LMOTS signature\n   LMOTS type  00000004                         # LMOTS_SHA256_N32_W8\n\
    \   C           0703c491e7558b35011ece3592eaa5da\n               4d918786771233e8353bc4f62323185c\n\
    \   y[0]        95cae05b899e35dffd71705470620998\n               8ebfdf6e37960bb5c38d7657e8bffeef\n\
    \   y[1]        9bc042da4b4525650485c66d0ce19b31\n               7587c6ba4bffcc428e25d08931e72dfb\n\
    \   y[2]        6a120c5612344258b85efdb7db1db9e1\n               865a73caf96557eb39ed3e3f426933ac\n\
    \   y[3]        9eeddb03a1d2374af7bf771855774562\n               37f9de2d60113c23f846df26fa942008\n\
    \   y[4]        a698994c0827d90e86d43e0df7f4bfcd\n               b09b86a373b98288b7094ad81a0185ac\n\
    \   y[5]        100e4f2c5fc38c003c1ab6fea479eb2f\n               5ebe48f584d7159b8ada03586e65ad9c\n\
    \   y[6]        969f6aecbfe44cf356888a7b15a3ff07\n               4f771760b26f9c04884ee1faa329fbf4\n\
    \   y[7]        e61af23aee7fa5d4d9a5dfcf43c4c26c\n               e8aea2ce8a2990d7ba7b57108b47dabf\n\
    \   y[8]        beadb2b25b3cacc1ac0cef346cbb90fb\n               044beee4fac2603a442bdf7e507243b7\n\
    \   y[9]        319c9944b1586e899d431c7f91bcccc8\n               690dbf59b28386b2315f3d36ef2eaa3c\n\
    \   y[10]       f30b2b51f48b71b003dfb08249484201\n               043f65f5a3ef6bbd61ddfee81aca9ce6\n\
    \   y[11]       0081262a00000480dcbc9a3da6fbef5c\n               1c0a55e48a0e729f9184fcb1407c3152\n\
    \   y[12]       9db268f6fe50032a363c9801306837fa\n               fabdf957fd97eafc80dbd165e435d0e2\n\
    \   y[13]       dfd836a28b354023924b6fb7e48bc0b3\n               ed95eea64c2d402f4d734c8dc26f3ac5\n\
    \   y[14]       91825daef01eae3c38e3328d00a77dc6\n               57034f287ccb0f0e1c9a7cbdc828f627\n\
    \   y[15]       205e4737b84b58376551d44c12c3c215\n               c812a0970789c83de51d6ad787271963\n\
    \   y[16]       327f0a5fbb6b5907dec02c9a90934af5\n               a1c63b72c82653605d1dcce51596b3c2\n\
    \   y[17]       b45696689f2eb382007497557692caac\n               4d57b5de9f5569bc2ad0137fd47fb47e\n\
    \   y[18]       664fcb6db4971f5b3e07aceda9ac130e\n               9f38182de994cff192ec0e82fd6d4cb7\n\
    \   y[19]       f3fe00812589b7a7ce51544045643301\n               6b84a59bec6619a1c6c0b37dd1450ed4\n\
    \   y[20]       f2d8b584410ceda8025f5d2d8dd0d217\n               6fc1cf2cc06fa8c82bed4d944e71339e\n\
    \   y[21]       ce780fd025bd41ec34ebff9d4270a322\n               4e019fcb444474d482fd2dbe75efb203\n\
    \   y[22]       89cc10cd600abb54c47ede93e08c114e\n               db04117d714dc1d525e11bed8756192f\n\
    \   y[23]       929d15462b939ff3f52f2252da2ed64d\n               8fae88818b1efa2c7b08c8794fb1b214\n\
    \   y[24]       aa233db3162833141ea4383f1a6f120b\n               e1db82ce3630b3429114463157a64e91\n\
    \   y[25]       234d475e2f79cbf05e4db6a9407d72c6\n               bff7d1198b5c4d6aad2831db61274993\n\
    \   y[26]       715a0182c7dc8089e32c8531deed4f74\n               31c07c02195eba2ef91efb5613c37af7\n\
    \   y[27]       ae0c066babc69369700e1dd26eddc0d2\n               16c781d56e4ce47e3303fa73007ff7b9\n\
    \   y[28]       49ef23be2aa4dbf25206fe45c20dd888\n               395b2526391a724996a44156beac8082\n\
    \   y[29]       12858792bf8e74cba49dee5e8812e019\n               da87454bff9e847ed83db07af3137430\n\
    \   y[30]       82f880a278f682c2bd0ad6887cb59f65\n               2e155987d61bbf6a88d36ee93b6072e6\n\
    \   y[31]       656d9ccbaae3d655852e38deb3a2dcf8\n               058dc9fb6f2ab3d3b3539eb77b248a66\n\
    \   y[32]       1091d05eb6e2f297774fe6053598457c\n               c61908318de4b826f0fc86d4bb117d33\n\
    \   y[33]       e865aa805009cc2918d9c2f840c4da43\n               a703ad9f5b5806163d7161696b5a0adc\n\
    \   --------------------------------------------\n   LMS type    00000005    \
    \                     # LM_SHA256_M32_H5\n   path[0]     d5c0d1bebb06048ed6fe2ef2c6cef305\n\
    \               b3ed633941ebc8b3bec9738754cddd60\n   path[1]     e1920ada52f43d055b5031cee6192520\n\
    \               d6a5115514851ce7fd448d4a39fae2ab\n   path[2]     2335b525f484e9b40d6a4a969394843b\n\
    \               dcf6d14c48e8015e08ab92662c05c6e9\n   path[3]     f90b65a7a6201689999f32bfd368e5e3\n\
    \               ec9cb70ac7b8399003f175c40885081a\n   path[4]     09ab3034911fe125631051df0408b394\n\
    \               6b0bde790911e8978ba07dd56c73e7ee\n   Test Case 2 Private Key\n\
    \   --------------------------------------------\n   (note: procedure in Appendix\
    \ A is used)\n   Top level LMS tree\n   SEED        558b8966c48ae9cb898b423c83443aae\n\
    \               014a72f1b1ab5cc85cf1d892903b5439\n   I           d08fabd4a2091ff0a8cb4ed834e74534\n\
    \   Second level LMS tree\n   SEED        a1c4696e2608035a886100d05cd99945\n \
    \              eb3370731884a8235e2fb3d4d71f2547\n   I           215f83b7ccb9acbcd08db97b0d04dc2b\n\
    \   --------------------------------------------\n   --------------------------------------------\n\
    \   Test Case 2 Public Key\n   --------------------------------------------\n\
    \   HSS public key\n   levels      00000002\n   --------------------------------------------\n\
    \   LMS type    00000006                         # LM_SHA256_M32_H10\n   LMOTS\
    \ type  00000003                         # LMOTS_SHA256_N32_W4\n   I         \
    \  d08fabd4a2091ff0a8cb4ed834e74534\n   K           32a58885cd9ba0431235466bff9651c6\n\
    \               c92124404d45fa53cf161c28f1ad5a8e\n   --------------------------------------------\n\
    \   --------------------------------------------\n   Test Case 2 Message\n   --------------------------------------------\n\
    \   Message     54686520656e756d65726174696f6e20  |The enumeration |\n       \
    \        696e2074686520436f6e737469747574  |in the Constitut|\n              \
    \ 696f6e2c206f66206365727461696e20  |ion, of certain |\n               7269676874732c207368616c6c206e6f\
    \  |rights, shall no|\n               7420626520636f6e7374727565642074  |t be\
    \ construed t|\n               6f2064656e79206f7220646973706172  |o deny or dispar|\n\
    \               616765206f7468657273207265746169  |age others retai|\n       \
    \        6e6564206279207468652070656f706c  |ned by the peopl|\n              \
    \ 652e0a                            |e..|\n   --------------------------------------------\n\
    \   Test Case 2 Signature\n   --------------------------------------------\n \
    \  HSS signature\n   Nspk        00000001\n   sig[0]:\n   --------------------------------------------\n\
    \   LMS signature\n   q           00000003\n   --------------------------------------------\n\
    \   LMOTS signature\n   LMOTS type  00000003                         # LMOTS_SHA256_N32_W4\n\
    \   C           3d46bee8660f8f215d3f96408a7a64cf\n               1c4da02b63a55f62c666ef5707a914ce\n\
    \   y[0]        0674e8cb7a55f0c48d484f31f3aa4af9\n               719a74f22cf823b94431d01c926e2a76\n\
    \   y[1]        bb71226d279700ec81c9e95fb11a0d10\n               d065279a5796e265ae17737c44eb8c59\n\
    \   y[2]        4508e126a9a7870bf4360820bdeb9a01\n               d9693779e416828e75bddd7d8c70d50a\n\
    \   y[3]        0ac8ba39810909d445f44cb5bb58de73\n               7e60cb4345302786ef2c6b14af212ca1\n\
    \   y[4]        9edeaa3bfcfe8baa6621ce88480df237\n               1dd37add732c9de4ea2ce0dffa53c926\n\
    \   y[5]        49a18d39a50788f4652987f226a1d481\n               68205df6ae7c58e049a25d4907edc1aa\n\
    \   y[6]        90da8aa5e5f7671773e941d805536021\n               5c6b60dd35463cf2240a9c06d694e9cb\n\
    \   y[7]        54e7b1e1bf494d0d1a28c0d31acc7516\n               1f4f485dfd3cb9578e836ec2dc722f37\n\
    \   y[8]        ed30872e07f2b8bd0374eb57d22c614e\n               09150f6c0d8774a39a6e168211035dc5\n\
    \   y[9]        2988ab46eaca9ec597fb18b4936e66ef\n               2f0df26e8d1e34da28cbb3af75231372\n\
    \   y[10]       0c7b345434f72d65314328bbb030d0f0\n               f6d5e47b28ea91008fb11b05017705a8\n\
    \   y[11]       be3b2adb83c60a54f9d1d1b2f476f9e3\n               93eb5695203d2ba6ad815e6a111ea293\n\
    \   y[12]       dcc21033f9453d49c8e5a6387f588b1e\n               a4f706217c151e05f55a6eb7997be09d\n\
    \   y[13]       56a326a32f9cba1fbe1c07bb49fa04ce\n               cf9df1a1b815483c75d7a27cc88ad1b1\n\
    \   y[14]       238e5ea986b53e087045723ce16187ed\n               a22e33b2c70709e53251025abde89396\n\
    \   y[15]       45fc8c0693e97763928f00b2e3c75af3\n               942d8ddaee81b59a6f1f67efda0ef81d\n\
    \   y[16]       11873b59137f67800b35e81b01563d18\n               7c4a1575a1acb92d087b517a8833383f\n\
    \   y[17]       05d357ef4678de0c57ff9f1b2da61dfd\n               e5d88318bcdde4d9061cc75c2de3cd47\n\
    \   y[18]       40dd7739ca3ef66f1930026f47d9ebaa\n               713b07176f76f953e1c2e7f8f271a6ca\n\
    \   y[19]       375dbfb83d719b1635a7d8a138919579\n               44b1c29bb101913e166e11bd5f34186f\n\
    \   y[20]       a6c0a555c9026b256a6860f4866bd6d0\n               b5bf90627086c6149133f8282ce6c9b3\n\
    \   y[21]       622442443d5eca959d6c14ca8389d12c\n               4068b503e4e3c39b635bea245d9d05a2\n\
    \   y[22]       558f249c9661c0427d2e489ca5b5dde2\n               20a90333f4862aec793223c781997da9\n\
    \   y[23]       8266c12c50ea28b2c438e7a379eb106e\n               ca0c7fd6006e9bf612f3ea0a454ba3bd\n\
    \   y[24]       b76e8027992e60de01e9094fddeb3349\n               883914fb17a9621ab929d970d101e45f\n\
    \   y[25]       8278c14b032bcab02bd15692d21b6c5c\n               204abbf077d465553bd6eda645e6c306\n\
    \   y[26]       5d33b10d518a61e15ed0f092c3222628\n               1a29c8a0f50cde0a8c66236e29c2f310\n\
    \   y[27]       a375cebda1dc6bb9a1a01dae6c7aba8e\n               bedc6371a7d52aacb955f83bd6e4f84d\n\
    \   y[28]       2949dcc198fb77c7e5cdf6040b0f84fa\n               f82808bf985577f0a2acf2ec7ed7c0b0\n\
    \   y[29]       ae8a270e951743ff23e0b2dd12e9c3c8\n               28fb5598a22461af94d568f29240ba28\n\
    \   y[30]       20c4591f71c088f96e095dd98beae456\n               579ebbba36f6d9ca2613d1c26eee4d8c\n\
    \   y[31]       73217ac5962b5f3147b492e8831597fd\n               89b64aa7fde82e1974d2f6779504dc21\n\
    \   y[32]       435eb3109350756b9fdabe1c6f368081\n               bd40b27ebcb9819a75d7df8bb07bb05d\n\
    \   y[33]       b1bab705a4b7e37125186339464ad8fa\n               aa4f052cc1272919fde3e025bb64aa8e\n\
    \   y[34]       0eb1fcbfcc25acb5f718ce4f7c2182fb\n               393a1814b0e942490e52d3bca817b2b2\n\
    \   y[35]       6e90d4c9b0cc38608a6cef5eb153af08\n               58acc867c9922aed43bb67d7b33acc51\n\
    \   y[36]       9313d28d41a5c6fe6cf3595dd5ee63f0\n               a4c4065a083590b275788bee7ad875a7\n\
    \   y[37]       f88dd73720708c6c6c0ecf1f43bbaada\n               e6f208557fdc07bd4ed91f88ce4c0de8\n\
    \   y[38]       42761c70c186bfdafafc444834bd3418\n               be4253a71eaf41d718753ad07754ca3e\n\
    \   y[39]       ffd5960b0336981795721426803599ed\n               5b2b7516920efcbe32ada4bcf6c73bd2\n\
    \   y[40]       9e3fa152d9adeca36020fdeeee1b7395\n               21d3ea8c0da497003df1513897b0f547\n\
    \   y[41]       94a873670b8d93bcca2ae47e64424b74\n               23e1f078d9554bb5232cc6de8aae9b83\n\
    \   y[42]       fa5b9510beb39ccf4b4e1d9c0f19d5e1\n               7f58e5b8705d9a6837a7d9bf99cd1338\n\
    \   y[43]       7af256a8491671f1f2f22af253bcff54\n               b673199bdb7d05d81064ef05f80f0153\n\
    \   y[44]       d0be7919684b23da8d42ff3effdb7ca0\n               985033f389181f47659138003d712b5e\n\
    \   y[45]       c0a614d31cc7487f52de8664916af79c\n               98456b2c94a8038083db55391e347586\n\
    \   y[46]       2250274a1de2584fec975fb09536792c\n               fbfcf6192856cc76eb5b13dc4709e2f7\n\
    \   y[47]       301ddff26ec1b23de2d188c999166c74\n               e1e14bbc15f457cf4e471ae13dcbdd9c\n\
    \   y[48]       50f4d646fc6278e8fe7eb6cb5c94100f\n               a870187380b777ed19d7868fd8ca7ceb\n\
    \   y[49]       7fa7d5cc861c5bdac98e7495eb0a2cee\n               c1924ae979f44c5390ebedddc65d6ec1\n\
    \   y[50]       1287d978b8df064219bc5679f7d7b264\n               a76ff272b2ac9f2f7cfc9fdcfb6a5142\n\
    \   y[51]       8240027afd9d52a79b647c90c2709e06\n               0ed70f87299dd798d68f4fadd3da6c51\n\
    \   y[52]       d839f851f98f67840b964ebe73f8cec4\n               1572538ec6bc131034ca2894eb736b3b\n\
    \   y[53]       da93d9f5f6fa6f6c0f03ce43362b8414\n               940355fb54d3dfdd03633ae108f3de3e\n\
    \   y[54]       bc85a3ff51efeea3bc2cf27e1658f178\n               9ee612c83d0f5fd56f7cd071930e2946\n\
    \   y[55]       beeecaa04dccea9f97786001475e0294\n               bc2852f62eb5d39bb9fbeef75916efe4\n\
    \   y[56]       4a662ecae37ede27e9d6eadfdeb8f8b2\n               b2dbccbf96fa6dbaf7321fb0e701f4d4\n\
    \   y[57]       29c2f4dcd153a2742574126e5eaccc77\n               686acf6e3ee48f423766e0fc466810a9\n\
    \   y[58]       05ff5453ec99897b56bc55dd49b99114\n               2f65043f2d744eeb935ba7f4ef23cf80\n\
    \   y[59]       cc5a8a335d3619d781e7454826df720e\n               ec82e06034c44699b5f0c44a8787752e\n\
    \   y[60]       057fa3419b5bb0e25d30981e41cb1361\n               322dba8f69931cf42fad3f3bce6ded5b\n\
    \   y[61]       8bfc3d20a2148861b2afc14562ddd27f\n               12897abf0685288dcc5c4982f8260268\n\
    \   y[62]       46a24bf77e383c7aacab1ab692b29ed8\n               c018a65f3dc2b87ff619a633c41b4fad\n\
    \   y[63]       b1c78725c1f8f922f6009787b1964247\n               df0136b1bc614ab575c59a16d089917b\n\
    \   y[64]       d4a8b6f04d95c581279a139be09fcf6e\n               98a470a0bceca191fce476f9370021cb\n\
    \   y[65]       c05518a7efd35d89d8577c990a5e1996\n               1ba16203c959c91829ba7497cffcbb4b\n\
    \   y[66]       294546454fa5388a23a22e805a5ca35f\n               956598848bda678615fec28afd5da61a\n\
    \   --------------------------------------------\n   LMS type    00000006    \
    \                     # LM_SHA256_M32_H10\n   path[0]     b326493313053ced3876db9d23714818\n\
    \               1b7173bc7d042cefb4dbe94d2e58cd21\n   path[1]     a769db4657a103279ba8ef3a629ca84e\n\
    \               e836172a9c50e51f45581741cf808315\n   path[2]     0b491cb4ecbbabec128e7c81a46e62a6\n\
    \               7b57640a0a78be1cbf7dd9d419a10cd8\n   path[3]     686d16621a80816bfdb5bdc56211d72c\n\
    \               a70b81f1117d129529a7570cf79cf52a\n   path[4]     7028a48538ecdd3b38d3d5d62d262465\n\
    \               95c4fb73a525a5ed2c30524ebb1d8cc8\n   path[5]     2e0c19bc4977c6898ff95fd3d310b0ba\n\
    \               e71696cef93c6a552456bf96e9d075e3\n   path[6]     83bb7543c675842bafbfc7cdb88483b3\n\
    \               276c29d4f0a341c2d406e40d4653b7e4\n   path[7]     d045851acf6a0a0ea9c710b805cced46\n\
    \               35ee8c107362f0fc8d80c14d0ac49c51\n   path[8]     6703d26d14752f34c1c0d2c4247581c1\n\
    \               8c2cf4de48e9ce949be7c888e9caebe4\n   path[9]     a415e291fd107d21dc1f084b11582082\n\
    \               49f28f4f7c7e931ba7b3bd0d824a4570\n   --------------------------------------------\n\
    \   LMS public key\n   LMS type    00000005                         # LM_SHA256_M32_H5\n\
    \   LMOTS type  00000004                         # LMOTS_SHA256_N32_W8\n   I \
    \          215f83b7ccb9acbcd08db97b0d04dc2b\n   K           a1cd035833e0e90059603f26e07ad2aa\n\
    \               d152338e7a5e5984bcd5f7bb4eba40b7\n   --------------------------------------------\n\
    \   final_signature:\n   --------------------------------------------\n   LMS\
    \ signature\n   q           00000004\n   --------------------------------------------\n\
    \   LMOTS signature\n   LMOTS type  00000004                         # LMOTS_SHA256_N32_W8\n\
    \   C           0eb1ed54a2460d512388cad533138d24\n               0534e97b1e82d33bd927d201dfc24ebb\n\
    \   y[0]        11b3649023696f85150b189e50c00e98\n               850ac343a77b3638319c347d7310269d\n\
    \   y[1]        3b7714fa406b8c35b021d54d4fdada7b\n               9ce5d4ba5b06719e72aaf58c5aae7aca\n\
    \   y[2]        057aa0e2e74e7dcfd17a0823429db629\n               65b7d563c57b4cec942cc865e29c1dad\n\
    \   y[3]        83cac8b4d61aacc457f336e6a10b6632\n               3f5887bf3523dfcadee158503bfaa89d\n\
    \   y[4]        c6bf59daa82afd2b5ebb2a9ca6572a60\n               67cee7c327e9039b3b6ea6a1edc7fdc3\n\
    \   y[5]        df927aade10c1c9f2d5ff446450d2a39\n               98d0f9f6202b5e07c3f97d2458c69d3c\n\
    \   y[6]        8190643978d7a7f4d64e97e3f1c4a08a\n               7c5bc03fd55682c017e2907eab07e5bb\n\
    \   y[7]        2f190143475a6043d5e6d5263471f4ee\n               cf6e2575fbc6ff37edfa249d6cda1a09\n\
    \   y[8]        f797fd5a3cd53a066700f45863f04b6c\n               8a58cfd341241e002d0d2c0217472bf1\n\
    \   y[9]        8b636ae547c1771368d9f317835c9b0e\n               f430b3df4034f6af00d0da44f4af7800\n\
    \   y[10]       bc7a5cf8a5abdb12dc718b559b74cab9\n               090e33cc58a955300981c420c4da8ffd\n\
    \   y[11]       67df540890a062fe40dba8b2c1c548ce\n               d22473219c534911d48ccaabfb71bc71\n\
    \   y[12]       862f4a24ebd376d288fd4e6fb06ed870\n               5787c5fedc813cd2697e5b1aac1ced45\n\
    \   y[13]       767b14ce88409eaebb601a93559aae89\n               3e143d1c395bc326da821d79a9ed41dc\n\
    \   y[14]       fbe549147f71c092f4f3ac522b5cc572\n               90706650487bae9bb5671ecc9ccc2ce5\n\
    \   y[15]       1ead87ac01985268521222fb9057df7e\n               d41810b5ef0d4f7cc67368c90f573b1a\n\
    \   y[16]       c2ce956c365ed38e893ce7b2fae15d36\n               85a3df2fa3d4cc098fa57dd60d2c9754\n\
    \   y[17]       a8ade980ad0f93f6787075c3f680a2ba\n               1936a8c61d1af52ab7e21f416be09d2a\n\
    \   y[18]       8d64c3d3d8582968c2839902229f85ae\n               e297e717c094c8df4a23bb5db658dd37\n\
    \   y[19]       7bf0f4ff3ffd8fba5e383a48574802ed\n               545bbe7a6b4753533353d73706067640\n\
    \   y[20]       135a7ce517279cd683039747d218647c\n               86e097b0daa2872d54b8f3e508598762\n\
    \   y[21]       9547b830d8118161b65079fe7bc59a99\n               e9c3c7380e3e70b7138fe5d9be255150\n\
    \   y[22]       2b698d09ae193972f27d40f38dea264a\n               0126e637d74ae4c92a6249fa103436d3\n\
    \   y[23]       eb0d4029ac712bfc7a5eacbdd7518d6d\n               4fe903a5ae65527cd65bb0d4e9925ca2\n\
    \   y[24]       4fd7214dc617c150544e423f450c99ce\n               51ac8005d33acd74f1bed3b17b7266a4\n\
    \   y[25]       a3bb86da7eba80b101e15cb79de9a207\n               852cf91249ef480619ff2af8cabca831\n\
    \   y[26]       25d1faa94cbb0a03a906f683b3f47a97\n               c871fd513e510a7a25f283b196075778\n\
    \   y[27]       496152a91c2bf9da76ebe089f4654877\n               f2d586ae7149c406e663eadeb2b5c7e8\n\
    \   y[28]       2429b9e8cb4834c83464f079995332e4\n               b3c8f5a72bb4b8c6f74b0d45dc6c1f79\n\
    \   y[29]       952c0b7420df525e37c15377b5f09843\n               19c3993921e5ccd97e097592064530d3\n\
    \   y[30]       3de3afad5733cbe7703c5296263f7734\n               2efbf5a04755b0b3c997c4328463e84c\n\
    \   y[31]       aa2de3ffdcd297baaaacd7ae646e44b5\n               c0f16044df38fabd296a47b3a838a913\n\
    \   y[32]       982fb2e370c078edb042c84db34ce36b\n               46ccb76460a690cc86c302457dd1cde1\n\
    \   y[33]       97ec8075e82b393d542075134e2a17ee\n               70a5e187075d03ae3c853cff60729ba4\n\
    \   --------------------------------------------\n   LMS type    00000005    \
    \                     # LM_SHA256_M32_H5\n   path[0]     4de1f6965bdabc676c5a4dc7c35f97f8\n\
    \               2cb0e31c68d04f1dad96314ff09e6b3d\n   path[1]     e96aeee300d1f68bf1bca9fc58e40323\n\
    \               36cd819aaf578744e50d1357a0e42867\n   path[2]     04d341aa0a337b19fe4bc43c2e79964d\n\
    \               4f351089f2e0e41c7c43ae0d49e7f404\n   path[3]     b0f75be80ea3af098c9752420a8ac0ea\n\
    \               2bbb1f4eeba05238aef0d8ce63f0c6e5\n   path[4]     e4041d95398a6f7f3e0ee97cc1591849\n\
    \               d4ed236338b147abde9f51ef9fd4e1c1\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   Thanks are due to Chirag Shroff, Andreas Huelsing, Burt\
    \ Kaliski, Eric\n   Osterweil, Ahmed Kosba, Russ Housley, Philip Lafrance, Alexander\n\
    \   Truskovsky, Mark Peruzel, and Jim Schaad for constructive suggestions\n  \
    \ and valuable detailed review.  We especially acknowledge Jerry\n   Solinas,\
    \ Laurie Law, and Kevin Igoe, who pointed out the security\n   benefits of the\
    \ approach of Leighton and Micali [USPTO5432852],\n   Jonathan Katz, who gave\
    \ us security guidance, and Bruno Couillard and\n   Jim Goodman for an especially\
    \ thorough review.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   David McGrew\n   Cisco Systems\n   13600 Dulles Technology\
    \ Drive\n   Herndon, VA  20171\n   United States of America\n   Email: mcgrew@cisco.com\n\
    \   Michael Curcio\n   Cisco Systems\n   7025-2 Kit Creek Road\n   Research Triangle\
    \ Park, NC  27709-4987\n   United States of America\n   Email: micurcio@cisco.com\n\
    \   Scott Fluhrer\n   Cisco Systems\n   170 West Tasman Drive\n   San Jose, CA\n\
    \   United States of America\n   Email: sfluhrer@cisco.com\n"
