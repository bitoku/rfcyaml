- contents:
  - ''
  title: __initial_text__
- contents:
  - "Framework for Establishing a Secure Real-time Transport Protocol (SRTP)\n    Security
    Context Using Datagram Transport Layer Security (DTLS)\n"
  title: Framework for Establishing a Secure Real-time Transport Protocol (SRTP)
- contents:
  - "Abstract\n   This document specifies how to use the Session Initiation Protocol\n
    \  (SIP) to establish a Secure Real-time Transport Protocol (SRTP)\n   security
    context using the Datagram Transport Layer Security (DTLS)\n   protocol.  It describes
    a mechanism of transporting a fingerprint\n   attribute in the Session Description
    Protocol (SDP) that identifies\n   the key that will be presented during the DTLS
    handshake.  The key\n   exchange travels along the media path as opposed to the
    signaling\n   path.  The SIP Identity mechanism can be used to protect the\n   integrity
    of the fingerprint attribute from modification by\n   intermediate proxies.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc5763.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2010 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n   This document may contain
    material from IETF Documents or IETF\n   Contributions published or made publicly
    available before November\n   10, 2008.  The person(s) controlling the copyright
    in some of this\n   material may not have granted the IETF Trust the right to
    allow\n   modifications of such material outside the IETF Standards Process.\n
    \  Without obtaining an adequate license from the person(s) controlling\n   the
    copyright in such materials, this document may not be modified\n   outside the
    IETF Standards Process, and derivative works of it may\n   not be created outside
    the IETF Standards Process, except to format\n   it for publication as an RFC
    or to translate it into languages other\n   than English.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n
    \  2. Overview ........................................................5\n   3.
    Motivation ......................................................7\n   4. Terminology
    .....................................................8\n   5. Establishing a Secure
    Channel ...................................8\n   6. Miscellaneous Considerations
    ...................................10\n      6.1. Anonymous Calls ...........................................10\n
    \     6.2. Early Media ...............................................11\n      6.3.
    Forking ...................................................11\n      6.4. Delayed
    Offer Calls .......................................11\n      6.5. Multiple Associations
    .....................................11\n      6.6. Session Modification ......................................12\n
    \     6.7. Middlebox Interaction .....................................12\n           6.7.1.
    ICE Interaction ....................................12\n           6.7.2. Latching
    Control without ICE .......................13\n      6.8. Rekeying ..................................................13\n
    \     6.9. Conference Servers and Shared Encryptions Contexts ........13\n      6.10.
    Media over SRTP ..........................................14\n      6.11. Best
    Effort Encryption ...................................14\n   7. Example Message
    Flow ...........................................14\n      7.1. Basic Message Flow
    with Early Media and SIP Identity ......14\n      7.2. Basic Message Flow with
    Connected Identity (RFC 4916) .....19\n      7.3. Basic Message Flow with STUN
    Check for NAT Case ...........23\n   8. Security Considerations ........................................25\n
    \     8.1. Responder Identity ........................................25\n      8.2.
    SIPS ......................................................26\n      8.3. S/MIME
    ....................................................26\n      8.4. Continuity
    of Authentication ..............................26\n      8.5. Short Authentication
    String ...............................27\n      8.6. Limits of Identity Assertions
    .............................27\n      8.7. Third-Party Certificates ..................................29\n
    \     8.8. Perfect Forward Secrecy ...................................29\n   9.
    Acknowledgments ................................................29\n   10. References
    ....................................................30\n      10.1. Normative
    References .....................................30\n      10.2. Informative References
    ...................................31\n   Appendix A.  Requirements Analysis ................................33\n
    \     A.1.  Forking and Retargeting (R-FORK-RETARGET,\n            R-BEST-SECURE,
    R-DISTINCT) ...............................33\n      A.2.  Distinct Cryptographic
    Contexts (R-DISTINCT) .............33\n      A.3.  Reusage of a Security Context
    (R-REUSE) ..................33\n      A.4.  Clipping (R-AVOID-CLIPPING) ..............................33\n
    \     A.5.  Passive Attacks on the Media Path (R-PASS-MEDIA) .........33\n      A.6.
    \ Passive Attacks on the Signaling Path (R-PASS-SIG) .......34\n      A.7.  (R-SIG-MEDIA,
    R-ACT-ACT) .................................34\n      A.8.  Binding to Identifiers
    (R-ID-BINDING) ....................34\n      A.9.  Perfect Forward Secrecy (R-PFS)
    ..........................34\n      A.10. Algorithm Negotiation (R-COMPUTE) ........................35\n
    \     A.11. RTP Validity Check (R-RTP-VALID) .........................35\n      A.12.
    Third-Party Certificates (R-CERTS, R-EXISTING) ...........35\n      A.13. FIPS
    140-2 (R-FIPS) ......................................35\n      A.14. Linkage between
    Keying Exchange and SIP Signaling\n            (R-ASSOC) ................................................35\n
    \     A.15. Denial-of-Service Vulnerability (R-DOS) ..................35\n      A.16.
    Crypto-Agility (R-AGILITY) ...............................35\n      A.17. Downgrading
    Protection (R-DOWNGRADE) .....................36\n      A.18. Media Security Negotiation
    (R-NEGOTIATE) .................36\n      A.19. Signaling Protocol Independence
    (R-OTHER-SIGNALING) ......36\n      A.20. Media Recording (R-RECORDING) ............................36\n
    \     A.21. Interworking with Intermediaries (R-TRANSCODER) ..........36\n      A.22.
    PSTN Gateway Termination (R-PSTN) ........................36\n      A.23. R-ALLOW-RTP
    ..............................................36\n      A.24. R-HERFP ..................................................37\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The Session Initiation Protocol (SIP) [RFC3261] and the
    Session\n   Description Protocol (SDP) [RFC4566] are used to set up multimedia\n
    \  sessions or calls.  SDP is also used to set up TCP [RFC4145] and\n   additionally
    TCP/TLS connections for usage with media sessions\n   [RFC4572].  The Real-time
    Transport Protocol (RTP) [RFC3550] is used\n   to transmit real-time media on
    top of UDP and TCP [RFC4571].\n   Datagram TLS [RFC4347] was introduced to allow
    TLS functionality to\n   be applied to datagram transport protocols, such as UDP
    and DCCP.\n   This document provides guidelines on how to establish SRTP [RFC3711]\n
    \  security over UDP using an extension to DTLS (see [RFC5764]).\n   The goal
    of this work is to provide a key negotiation technique that\n   allows encrypted
    communication between devices with no prior\n   relationships.  It also does not
    require the devices to trust every\n   call signaling element that was involved
    in routing or session setup.\n   This approach does not require any extra effort
    by end users and does\n   not require deployment of certificates that are signed
    by a well-\n   known certificate authority to all devices.\n   The media is transported
    over a mutually authenticated DTLS session\n   where both sides have certificates.
    \ It is very important to note\n   that certificates are being used purely as
    a carrier for the public\n   keys of the peers.  This is required because DTLS
    does not have a\n   mode for carrying bare keys, but it is purely an issue of
    formatting.\n   The certificates can be self-signed and completely self-generated.\n
    \  All major TLS stacks have the capability to generate such\n   certificates
    on demand.  However, third-party certificates MAY also\n   be used if the peers
    have them (thus reducing the need to trust\n   intermediaries).  The certificate
    fingerprints are sent in SDP over\n   SIP as part of the offer/answer exchange.\n
    \  The fingerprint mechanism allows one side of the connection to verify\n   that
    the certificate presented in the DTLS handshake matches the\n   certificate used
    by the party in the signaling.  However, this\n   requires some form of integrity
    protection on the signaling.  S/MIME\n   signatures, as described in RFC 3261,
    or SIP Identity, as described\n   in [RFC4474], provide the highest level of security
    because they are\n   not susceptible to modification by malicious intermediaries.\n
    \  However, even hop-by-hop security, such as provided by SIPS, offers\n   some
    protection against modification by attackers who are not in\n   control of on-path
    signaling elements.  Because DTLS-SRTP only\n   requires message integrity and
    not confidentiality for the signaling,\n   the number of elements that must have
    credentials and be trusted is\n   significantly reduced.  In particular, if RFC
    4474 is used, only the\n   Authentication Service need have a certificate and
    be trusted.\n   Intermediate elements cannot undetectably modify the message and\n
    \  therefore cannot mount a man-in-the-middle (MITM) attack.  By\n   comparison,
    because SDESCRIPTIONS [RFC4568] requires confidentiality\n   for the signaling,
    all intermediate elements must be trusted.\n   This approach differs from previous
    attempts to secure media traffic\n   where the authentication and key exchange
    protocol (e.g., Multimedia\n   Internet KEYing (MIKEY) [RFC3830]) is piggybacked
    in the signaling\n   message exchange.  With DTLS-SRTP, establishing the protection
    of the\n   media traffic between the endpoints is done by the media endpoints\n
    \  with only a cryptographic binding of the media keying to the SIP/SDP\n   communication.
    \ It allows RTP and SIP to be used in the usual manner\n   when there is no encrypted
    media.\n   In SIP, typically the caller sends an offer and the callee may\n   subsequently
    send one-way media back to the caller before a SIP\n   answer is received by the
    caller.  The approach in this\n   specification, where the media key negotiation
    is decoupled from the\n   SIP signaling, allows the early media to be set up before
    the SIP\n   answer is received while preserving the important security property\n
    \  of allowing the media sender to choose some of the keying material\n   for
    the media.  This also allows the media sessions to be changed,\n   rekeyed, and
    otherwise modified after the initial SIP signaling\n   without any additional
    SIP signaling.\n   Design decisions that influence the applicability of this\n
    \  specification are discussed in Section 3.\n"
  title: 1.  Introduction
- contents:
  - "2.  Overview\n   Endpoints wishing to set up an RTP media session do so by exchanging\n
    \  offers and answers in SDP messages over SIP.  In a typical use case,\n   two
    endpoints would negotiate to transmit audio data over RTP using\n   the UDP protocol.\n
    \  Figure 1 shows a typical message exchange in the SIP trapezoid.\n                 +-----------+
    \           +-----------+\n                 |SIP        |   SIP/SDP  |SIP        |\n
    \        +------>|Proxy      |----------->|Proxy      |-------+\n         |       |Server
    X   | (+finger-  |Server Y   |       |\n         |       +-----------+   print,
    \  +-----------+       |\n         |                      +auth.id.)                    |\n
    \        | SIP/SDP                              SIP/SDP       |\n         | (+fingerprint)
    \                      (+fingerprint,|\n         |                                       +auth.id.)
    \  |\n         |                                                    |\n         |
    \                                                   v\n     +-----------+          Datagram
    TLS               +-----------+\n     |SIP        | <-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+->
    |SIP        |\n     |User Agent |               Media                 |User Agent
    |\n     |Alice@X    | <=================================> |Bob@Y      |\n     +-----------+
    \                                    +-----------+\n     Legend:\n     ------>:
    Signaling Traffic\n     <-+-+->: Key Management Traffic\n     <=====>: Data Traffic\n
    \                Figure 1: DTLS Usage in the SIP Trapezoid\n   Consider Alice
    wanting to set up an encrypted audio session with\n   Bob.  Both Bob and Alice
    could use public-key-based authentication in\n   order to establish a confidentiality
    protected channel using DTLS.\n   Since providing mutual authentication between
    two arbitrary endpoints\n   on the Internet using public-key-based cryptography
    tends to be\n   problematic, we consider more deployment-friendly alternatives.
    \ This\n   document uses one approach and several others are discussed in\n   Section
    8.\n   Alice sends an SDP offer to Bob over SIP.  If Alice uses only self-\n   signed
    certificates for the communication with Bob, a fingerprint is\n   included in
    the SDP offer/answer exchange.  This fingerprint binds\n   the DTLS key exchange
    in the media plane to the signaling plane.\n   The fingerprint alone protects
    against active attacks on the media\n   but not active attacks on the signaling.
    \ In order to prevent active\n   attacks on the signaling, \"Enhancements for
    Authenticated Identity\n   Management in the Session Initiation Protocol (SIP)\"
    [RFC4474] may be\n   used.  When Bob receives the offer, the peers establish some
    number\n   of DTLS connections (depending on the number of media sessions) with\n
    \  mutual DTLS authentication (i.e., both sides provide certificates).\n   At
    this point, Bob can verify that Alice's credentials offered in TLS\n   match the
    fingerprint in the SDP offer, and Bob can begin sending\n   media to Alice.  Once
    Bob accepts Alice's offer and sends an SDP\n   answer to Alice, Alice can begin
    sending confidential media to Bob\n   over the appropriate streams.  Alice and
    Bob will verify that the\n   fingerprints from the certificates received over
    the DTLS handshakes\n   match with the fingerprints received in the SDP of the
    SIP signaling.\n   This provides the security property that Alice knows that the
    media\n   traffic is going to Bob and vice versa without necessarily requiring\n
    \  global Public Key Infrastructure (PKI) certificates for Alice and\n   Bob.
    \ (See Section 8 for detailed security analysis.)\n"
  title: 2.  Overview
- contents:
  - "3.  Motivation\n   Although there is already prior work in this area (e.g., Security\n
    \  Descriptions for SDP [RFC4568], Key Management Extensions [RFC4567]\n   combined
    with MIKEY [RFC3830] for authentication and key exchange),\n   this specification
    is motivated as follows:\n   o  TLS will be used to offer security for connection-oriented
    media.\n      The design of TLS is well-known and implementations are widely\n
    \     available.\n   o  This approach deals with forking and early media without
    requiring\n      support for Provisional Response ACKnowledgement (PRACK) [RFC3262]\n
    \     while preserving the important security property of allowing the\n      offerer
    to choose keying material for encrypting the media.\n   o  The establishment of
    security protection for the media path is\n      also provided along the media
    path and not over the signaling\n      path.  In many deployment scenarios, the
    signaling and media\n      traffic travel along a different path through the network.\n
    \  o  When RFC 4474 is used, this solution works even when the SIP\n      proxies
    downstream of the authentication service are not trusted.\n      There is no need
    to reveal keys in the SIP signaling or in the SDP\n      message exchange, as
    is done in SDESCRIPTIONS [RFC4568].\n      Retargeting of a dialog-forming request
    (changing the value of the\n      Request-URI), the User Agent (UA) that receives
    it (the User Agent\n      Server, UAS) can have a different identity from that
    in the To\n      header field.  When RFC 4916 is used, then it is possible to\n
    \     supply its identity to the peer UA by means of a request in the\n      reverse
    direction, and for that identity to be signed by an\n      Authentication Service.\n
    \  o  In this method, synchronization source (SSRC) collisions do not\n      result
    in any extra SIP signaling.\n   o  Many SIP endpoints already implement TLS.  The
    changes to existing\n      SIP and RTP usage are minimal even when DTLS-SRTP [RFC5764]
    is\n      used.\n"
  title: 3.  Motivation
- contents:
  - "4.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
    \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\"
    in this\n   document are to be interpreted as described in [RFC2119].\n   DTLS/TLS
    uses the term \"session\" to refer to a long-lived set of\n   keying material
    that spans associations.  In this document,\n   consistent with SIP/SDP usage,
    we use it to refer to a multimedia\n   session and use the term \"TLS session\"
    to refer to the TLS construct.\n   We use the term \"association\" to refer to
    a particular DTLS cipher\n   suite and keying material set that is associated
    with a single host/\n   port quartet.  The same DTLS/TLS session can be used to
    establish the\n   keying material for multiple associations.  For consistency
    with\n   other SIP/SDP usage, we use the term \"connection\" when what's being\n
    \  referred to is a multimedia stream that is not specifically DTLS/TLS.\n   In
    this document, the term \"Mutual DTLS\" indicates that both the DTLS\n   client
    and server present certificates even if one or both\n   certificates are self-signed.\n"
  title: 4.  Terminology
- contents:
  - "5.  Establishing a Secure Channel\n   The two endpoints in the exchange present
    their identities as part of\n   the DTLS handshake procedure using certificates.
    \ This document uses\n   certificates in the same style as described in \"Connection-Oriented\n
    \  Media Transport over the Transport Layer Security (TLS) Protocol in\n   the
    Session Description Protocol (SDP)\" [RFC4572].\n   If self-signed certificates
    are used, the content of the\n   subjectAltName attribute inside the certificate
    MAY use the uniform\n   resource identifier (URI) of the user.  This is useful
    for debugging\n   purposes only and is not required to bind the certificate to
    one of\n   the communication endpoints.  The integrity of the certificate is\n
    \  ensured through the fingerprint attribute in the SDP.  The\n   subjectAltName
    is not an important component of the certificate\n   verification.\n   The generation
    of public/private key pairs is relatively expensive.\n   Endpoints are not required
    to generate certificates for each session.\n   The offer/answer model, defined
    in [RFC3264], is used by protocols\n   like the Session Initiation Protocol (SIP)
    [RFC3261] to set up\n   multimedia sessions.  In addition to the usual contents
    of an SDP\n   [RFC4566] message, each media description (\"m=\" line and associated\n
    \  parameters) will also contain several attributes as specified in\n   [RFC5764],
    [RFC4145], and [RFC4572].\n   When an endpoint wishes to set up a secure media
    session with another\n   endpoint, it sends an offer in a SIP message to the other
    endpoint.\n   This offer includes, as part of the SDP payload, the fingerprint
    of\n   the certificate that the endpoint wants to use.  The endpoint SHOULD\n
    \  send the SIP message containing the offer to the offerer's SIP proxy\n   over
    an integrity protected channel.  The proxy SHOULD add an\n   Identity header field
    according to the procedures outlined in\n   [RFC4474].  The SIP message containing
    the offer SHOULD be sent to\n   the offerer's SIP proxy over an integrity protected
    channel.  When\n   the far endpoint receives the SIP message, it can verify the
    identity\n   of the sender using the Identity header field.  Since the Identity\n
    \  header field is a digital signature across several SIP header fields,\n   in
    addition to the body of the SIP message, the receiver can also be\n   certain
    that the message has not been tampered with after the digital\n   signature was
    applied and added to the SIP message.\n   The far endpoint (answerer) may now
    establish a DTLS association with\n   the offerer.  Alternately, it can indicate
    in its answer that the\n   offerer is to initiate the TLS association.  In either
    case, mutual\n   DTLS certificate-based authentication will be used.  After completing\n
    \  the DTLS handshake, information about the authenticated identities,\n   including
    the certificates, are made available to the endpoint\n   application.  The answerer
    is then able to verify that the offerer's\n   certificate used for authentication
    in the DTLS handshake can be\n   associated to the certificate fingerprint contained
    in the offer in\n   the SDP.  At this point, the answerer may indicate to the
    end user\n   that the media is secured.  The offerer may only tentatively accept\n
    \  the answerer's certificate since it may not yet have the answerer's\n   certificate
    fingerprint.\n   When the answerer accepts the offer, it provides an answer back
    to\n   the offerer containing the answerer's certificate fingerprint.  At\n   this
    point, the offerer can accept or reject the peer's certificate\n   and the offerer
    can indicate to the end user that the media is\n   secured.\n   Note that the
    entire authentication and key exchange for securing the\n   media traffic is handled
    in the media path through DTLS.  The\n   signaling path is only used to verify
    the peers' certificate\n   fingerprints.\n   The offer and answer MUST conform
    to the following requirements.\n   o  The endpoint MUST use the setup attribute
    defined in [RFC4145].\n      The endpoint that is the offerer MUST use the setup
    attribute\n      value of setup:actpass and be prepared to receive a client_hello\n
    \     before it receives the answer.  The answerer MUST use either a\n      setup
    attribute value of setup:active or setup:passive.  Note that\n      if the answerer
    uses setup:passive, then the DTLS handshake will\n      not begin until the answerer
    is received, which adds additional\n      latency. setup:active allows the answer
    and the DTLS handshake to\n      occur in parallel.  Thus, setup:active is RECOMMENDED.
    \ Whichever\n      party is active MUST initiate a DTLS handshake by sending a\n
    \     ClientHello over each flow (host/port quartet).\n   o  The endpoint MUST
    NOT use the connection attribute defined in\n      [RFC4145].\n   o  The endpoint
    MUST use the certificate fingerprint attribute as\n      specified in [RFC4572].\n
    \  o  The certificate presented during the DTLS handshake MUST match the\n      fingerprint
    exchanged via the signaling path in the SDP.  The\n      security properties of
    this mechanism are described in Section 8.\n   o  If the fingerprint does not
    match the hashed certificate, then the\n      endpoint MUST tear down the media
    session immediately.  Note that\n      it is permissible to wait until the other
    side's fingerprint has\n      been received before establishing the connection;
    however, this\n      may have undesirable latency effects.\n"
  title: 5.  Establishing a Secure Channel
- contents:
  - '6.  Miscellaneous Considerations

    '
  - contents:
    - "6.1.  Anonymous Calls\n   The use of DTLS-SRTP does not provide anonymous calling;
      however, it\n   also does not prevent it.  However, if care is not taken when\n
      \  anonymous calling features, such as those described in [RFC3325] or\n   [RFC5767]
      are used, DTLS-SRTP may allow deanonymizing an otherwise\n   anonymous call.
      \ When anonymous calls are being made, the following\n   procedures SHOULD be
      used to prevent deanonymization.\n   When making anonymous calls, a new self-signed
      certificate SHOULD be\n   used for each call so that the calls cannot be correlated
      as to being\n   from the same caller.  In situations where some degree of correlation\n
      \  is acceptable, the same certificate SHOULD be used for a number of\n   calls
      in order to enable continuity of authentication; see\n   Section 8.4.\n   Additionally,
      note that in networks that deploy [RFC3325], RFC 3325\n   requires that the
      Privacy header field value defined in [RFC3323]\n   needs to be set to 'id'.
      \ This is used in conjunction with the SIP\n   identity mechanism to ensure
      that the identity of the user is not\n   asserted when enabling anonymous calls.
      \ Furthermore, the content of\n   the subjectAltName attribute inside the certificate
      MUST NOT contain\n   information that either allows correlation or identification
      of the\n   user that wishes to place an anonymous call.  Note that following\n
      \  this recommendation is not sufficient to provide anonymization.\n"
    title: 6.1.  Anonymous Calls
  - contents:
    - "6.2.  Early Media\n   If an offer is received by an endpoint that wishes to
      provide early\n   media, it MUST take the setup:active role and can immediately\n
      \  establish a DTLS association with the other endpoint and begin\n   sending
      media.  The setup:passive endpoint may not yet have validated\n   the fingerprint
      of the active endpoint's certificate.  The security\n   aspects of media handling
      in this situation are discussed in\n   Section 8.\n"
    title: 6.2.  Early Media
  - contents:
    - "6.3.  Forking\n   In SIP, it is possible for a request to fork to multiple
      endpoints.\n   Each forked request can result in a different answer.  Assuming
      that\n   the requester provided an offer, each of the answerers will provide
      a\n   unique answer.  Each answerer will form a DTLS association with the\n
      \  offerer.  The offerer can then securely correlate the SDP answer\n   received
      in the SIP message by comparing the fingerprint in the\n   answer to the hashed
      certificate for each DTLS association.\n"
    title: 6.3.  Forking
  - contents:
    - "6.4.  Delayed Offer Calls\n   An endpoint may send a SIP INVITE request with
      no offer in it.  When\n   this occurs, the receiver(s) of the INVITE will provide
      the offer in\n   the response and the originator will provide the answer in
      the\n   subsequent ACK request or in the PRACK request [RFC3262], if both\n
      \  endpoints support reliable provisional responses.  In any event, the\n   active
      endpoint still establishes the DTLS association with the\n   passive endpoint
      as negotiated in the offer/answer exchange.\n"
    title: 6.4.  Delayed Offer Calls
  - contents:
    - "6.5.  Multiple Associations\n   When there are multiple flows (e.g., multiple
      media streams, non-\n   multiplexed RTP and RTCP, etc.) the active side MAY
      perform the DTLS\n   handshakes in any order.  Appendix B of [RFC5764] provides
      some\n   guidance on the performance of parallel DTLS handshakes.  Note that\n
      \  if the answerer ends up being active, it may only initiate handshakes\n   on
      some subset of the potential streams (e.g., if audio and video are\n   offered
      but it only wishes to do audio).  If the offerer ends up\n   being active, the
      complete answer will be received before the offerer\n   begins initiating handshakes.\n"
    title: 6.5.  Multiple Associations
  - contents:
    - "6.6.  Session Modification\n   Once an answer is provided to the offerer, either
      endpoint MAY\n   request a session modification that MAY include an updated
      offer.\n   This session modification can be carried in either an INVITE or\n
      \  UPDATE request.  The peers can reuse the existing associations if\n   they
      are compatible (i.e., they have the same key fingerprints and\n   transport
      parameters), or establish a new one following the same\n   rules are for initial
      exchanges, tearing down the existing\n   association as soon as the offer/answer
      exchange is completed.  Note\n   that if the active/passive status of the endpoints
      changes, a new\n   connection MUST be established.\n"
    title: 6.6.  Session Modification
  - contents:
    - "6.7.  Middlebox Interaction\n   There are a number of potentially bad interactions
      between DTLS-SRTP\n   and middleboxes, as documented in [MMUSIC-MEDIA], which
      also provides\n   recommendations for avoiding such problems.\n"
    - contents:
      - "6.7.1.  ICE Interaction\n   Interactive Connectivity Establishment (ICE),
        as specified in\n   [RFC5245], provides a methodology of allowing participants
        in\n   multimedia sessions to verify mutual connectivity.  When ICE is being\n
        \  used, the ICE connectivity checks are performed before the DTLS\n   handshake
        begins.  Note that if aggressive nomination mode is used,\n   multiple candidate
        pairs may be marked valid before ICE finally\n   converges on a single candidate
        pair.  Implementations MUST treat all\n   ICE candidate pairs associated with
        a single component as part of the\n   same DTLS association.  Thus, there
        will be only one DTLS handshake\n   even if there are multiple valid candidate
        pairs.  Note that this may\n   mean adjusting the endpoint IP addresses if
        the selected candidate\n   pair shifts, just as if the DTLS packets were an
        ordinary media\n   stream.\n   Note that Simple Traversal of the UDP Protocol
        through NAT (STUN)\n   packets are sent directly over UDP, not over DTLS.
        \ [RFC5764]\n   describes how to demultiplex STUN packets from DTLS packets
        and SRTP\n   packets.\n"
      title: 6.7.1.  ICE Interaction
    - contents:
      - "6.7.2.  Latching Control without ICE\n   If ICE is not being used, then there
        is potential for a bad\n   interaction with Session Border Controllers (SBCs)
        via \"latching\", as\n   described in [MMUSIC-MEDIA].  In order to avoid this
        issue, if ICE is\n   not being used and the DTLS handshake has not completed
        upon\n   receiving the other side's SDP, then the passive side MUST do a\n
        \  single unauthenticated STUN [RFC5389] connectivity check in order to\n
        \  open up the appropriate pinhole.  All implementations MUST be\n   prepared
        to answer this request during the handshake period even if\n   they do not
        otherwise do ICE.  However, the active side MUST proceed\n   with the DTLS
        handshake as appropriate even if no such STUN check is\n   received and the
        passive MUST NOT wait for a STUN answer before\n   sending its ServerHello.\n"
      title: 6.7.2.  Latching Control without ICE
    title: 6.7.  Middlebox Interaction
  - contents:
    - "6.8.  Rekeying\n   As with TLS, DTLS endpoints can rekey at any time by redoing
      the DTLS\n   handshake.  While the rekey is under way, the endpoints continue
      to\n   use the previously established keying material for usage with DTLS.\n
      \  Once the new session keys are established, the session can switch to\n   using
      these and abandon the old keys.  This ensures that latency is\n   not introduced
      during the rekeying process.\n   Further considerations regarding rekeying in
      case the SRTP security\n   context is established with DTLS can be found in
      Section 3.7 of\n   [RFC5764].\n"
    title: 6.8.  Rekeying
  - contents:
    - "6.9.  Conference Servers and Shared Encryptions Contexts\n   It has been proposed
      that conference servers might use the same\n   encryption context for all of
      the participants in a conference.  The\n   advantage of this approach is that
      the conference server only needs\n   to encrypt the output for all speakers
      instead of once per\n   participant.\n   This shared encryption context approach
      is not possible under this\n   specification because each DTLS handshake establishes
      fresh keys that\n   are not completely under the control of either side.  However,
      it is\n   argued that the effort to encrypt each RTP packet is small compared\n
      \  to the other tasks performed by the conference server such as the\n   codec
      processing.\n   Future extensions, such as [SRTP-EKT] or [KEY-TRANSPORT], could
      be\n   used to provide this functionality in concert with the mechanisms\n   described
      in this specification.\n"
    title: 6.9.  Conference Servers and Shared Encryptions Contexts
  - contents:
    - "6.10.  Media over SRTP\n   Because DTLS's data transfer protocol is generic,
      it is less highly\n   optimized for use with RTP than is SRTP [RFC3711], which
      has been\n   specifically tuned for that purpose.  DTLS-SRTP [RFC5764] has been\n
      \  defined to provide for the negotiation of SRTP transport using a DTLS\n   connection,
      thus allowing the performance benefits of SRTP with the\n   easy key management
      of DTLS.  The ability to reuse existing SRTP\n   software and hardware implementations
      may in some environments\n   provide another important motivation for using
      DTLS-SRTP instead of\n   RTP over DTLS.  Implementations of this specification
      MUST support\n   DTLS-SRTP [RFC5764].\n"
    title: 6.10.  Media over SRTP
  - contents:
    - "6.11.  Best Effort Encryption\n   [RFC5479] describes a requirement for best-effort
      encryption where\n   SRTP is used and where both endpoints support it and key
      negotiation\n   succeeds, otherwise RTP is used.\n   [MMUSIC-SDP] describes
      a mechanism that can signal both RTP and SRTP\n   as an alternative.  This allows
      an offerer to express a preference\n   for SRTP, but RTP is the default and
      will be understood by endpoints\n   that do not understand SRTP or this key
      exchange mechanism.\n   Implementations of this document MUST support [MMUSIC-SDP].\n"
    title: 6.11.  Best Effort Encryption
  title: 6.  Miscellaneous Considerations
- contents:
  - "7.  Example Message Flow\n   Prior to establishing the session, both Alice and
    Bob generate self-\n   signed certificates that are used for a single session
    or, more\n   likely, reused for multiple sessions.  In this example, Alice calls\n
    \  Bob.  In this example, we assume that Alice and Bob share the same\n   proxy.\n"
  - contents:
    - "7.1.  Basic Message Flow with Early Media and SIP Identity\n   This example
      shows the SIP message flows where Alice acts as the\n   passive endpoint and
      Bob acts as the active endpoint; meaning that as\n   soon as Bob receives the
      INVITE from Alice, with DTLS specified in\n   the \"m=\" line of the offer,
      Bob will begin to negotiate a DTLS\n   association with Alice for both RTP and
      RTCP streams.  Early media\n   (RTP and RTCP) starts to flow from Bob to Alice
      as soon as Bob sends\n   the DTLS finished message to Alice.  Bi-directional
      media (RTP and\n   RTCP) can flow after Alice receives the SIP 200 response
      and once\n   Alice has sent the DTLS finished message.\n   The SIP signaling
      from Alice to her proxy is transported over TLS to\n   ensure an integrity protected
      channel between Alice and her identity\n   service.  Transport between proxies
      should also be protected somehow,\n   especially if SIP Identity is not in use.\n
      \  Alice            Proxies             Bob\n     |(1) INVITE       |                  |\n
      \    |---------------->|                  |\n     |                 |(2) INVITE
      \       |\n     |                 |----------------->|\n     |                 |(3)
      hello         |\n     |<-----------------------------------|\n     |(4) hello
      \       |                  |\n     |----------------------------------->|\n
      \    |                 |(5) finished      |\n     |<-----------------------------------|\n
      \    |                 |(6) media         |\n     |<-----------------------------------|\n
      \    |(7) finished     |                  |\n     |----------------------------------->|\n
      \    |                 |(8)  200 OK       |\n     |                 <------------------|\n
      \    |(9)  200 OK      |                  |\n     |<----------------|                  |\n
      \    |                 |(10) media        |\n     |<---------------------------------->|\n
      \    |(11) ACK         |                  |\n     |----------------------------------->|\n
      \  Message (1):  INVITE Alice -> Proxy\n      This shows the initial INVITE
      from Alice to Bob carried over the\n      TLS transport protocol to ensure an
      integrity protected channel\n      between Alice and her proxy that acts as
      Alice's identity service.\n      Alice has requested to be either the active
      or passive endpoint by\n      specifying a=setup:actpass in the SDP.  Bob chooses
      to act as the\n      DTLS client and will initiate the session.  Also note that
      there\n      is a fingerprint attribute in the SDP.  This is computed from\n
      \     Alice's self-signed certificate.\n      This offer includes a default
      \"m=\" line offering RTP in case the\n      answerer does not support SRTP.
      \ However, the potential\n      configuration utilizing a transport of SRTP
      is preferred.  See\n      [MMUSIC-SDP] for more details on the details of SDP
      capability\n      negotiation.\n   INVITE sip:bob@example.com SIP/2.0\n   To:
      <sip:bob@example.com>\n   From: \"Alice\"<sip:alice@example.com>;tag=843c7b0b\n
      \  Via: SIP/2.0/TLS ua1.example.com;branch=z9hG4bK-0e53sadfkasldkfj\n   Contact:
      <sip:alice@ua1.example.com>\n   Call-ID: 6076913b1c39c212@REVMTEpG\n   CSeq:
      1 INVITE\n   Allow: INVITE, ACK, CANCEL, OPTIONS, BYE, UPDATE\n   Max-Forwards:
      70\n   Content-Type: application/sdp\n   Content-Length: xxxx\n   Supported:
      from-change\n   v=0\n   o=- 1181923068 1181923196 IN IP4 ua1.example.com\n   s=example1\n
      \  c=IN IP4 ua1.example.com\n   a=setup:actpass\n   a=fingerprint: SHA-1 \\\n
      \    4A:AD:B9:B1:3F:82:18:3B:54:02:12:DF:3E:5D:49:6B:19:E5:7C:AB\n   t=0 0\n
      \  m=audio 6056 RTP/AVP 0\n   a=sendrecv\n   a=tcap:1 UDP/TLS/RTP/SAVP RTP/AVP\n
      \  a=pcfg:1 t=1\n   Message (2):  INVITE Proxy -> Bob\n      This shows the
      INVITE being relayed to Bob from Alice (and Bob's)\n      proxy.  Note that
      Alice's proxy has inserted an Identity and\n      Identity-Info header.  This
      example only shows one element for\n      both proxies for the purposes of simplification.
      \ Bob verifies the\n      identity provided with the INVITE.\n   INVITE sip:bob@ua2.example.com
      SIP/2.0\n   To: <sip:bob@example.com>\n   From: \"Alice\"<sip:alice@example.com>;tag=843c7b0b\n
      \  Via: SIP/2.0/TLS proxy.example.com;branch=z9hG4bK-0e53sadfkasldk\n   Via:
      SIP/2.0/TLS ua1.example.com;branch=z9hG4bK-0e53sadfkasldkfj\n   Record-Route:
      <sip:proxy.example.com;lr>\n   Contact: <sip:alice@ua1.example.com>\n   Call-ID:
      6076913b1c39c212@REVMTEpG\n   CSeq: 1 INVITE\n   Allow: INVITE, ACK, CANCEL,
      OPTIONS, BYE, UPDATE\n   Max-Forwards: 69\n   Identity: CyI4+nAkHrH3ntmaxgr01TMxTmtjP7MASwliNRdupRI1vpkXRvZXx1ja9k\n
      \            3W+v1PDsy32MaqZi0M5WfEkXxbgTnPYW0jIoK8HMyY1VT7egt0kk4XrKFC\n             HYWGCl0nB2sNsM9CG4hq+YJZTMaSROoMUBhikVIjnQ8ykeD6UXNOyfI=\n
      \  Identity-Info: https://example.com/cert\n   Content-Type: application/sdp\n
      \  Content-Length: xxxx\n   Supported: from-change\n   v=0\n   o=- 1181923068
      1181923196 IN IP4 ua1.example.com\n   s=example1\n   c=IN IP4 ua1.example.com\n
      \  a=setup:actpass\n   a=fingerprint: SHA-1 \\\n     4A:AD:B9:B1:3F:82:18:3B:54:02:12:DF:3E:5D:49:6B:19:E5:7C:AB\n
      \  t=0 0\n   m=audio 6056 RTP/AVP 0\n   a=sendrecv\n   a=tcap:1 UDP/TLS/RTP/SAVP
      RTP/AVP\n   a=pcfg:1 t=1\n   Message (3):  ClientHello Bob -> Alice\n      Assuming
      that Alice's identity is valid, Line 3 shows Bob sending\n      a DTLS ClientHello(s)
      directly to Alice.  In this case, two DTLS\n      ClientHello messages would
      be sent to Alice: one to\n      ua1.example.com:6056 for RTP and another to
      port 6057 for RTCP,\n      but only one arrow is drawn for compactness of the
      figure.\n   Message (4):  ServerHello+Certificate Alice -> Bob\n      Alice
      sends back a ServerHello, Certificate, and ServerHelloDone\n      for both RTP
      and RTCP associations.  Note that the same\n      certificate is used for both
      the RTP and RTCP associations.  If\n      RTP/RTCP multiplexing [RFC5761] were
      being used only a single\n      association would be required.\n   Message (5):
      \ Certificate Bob -> Alice\n      Bob sends a Certificate, ClientKeyExchange,
      CertificateVerify,\n      change_cipher_spec, and Finished for both RTP and
      RTCP\n      associations.  Again note that Bob uses the same server\n      certificate
      for both associations.\n   Message (6):  Early Media Bob -> Alice\n      At
      this point, Bob can begin sending early media (RTP and RTCP) to\n      Alice.
      \ Note that Alice can't yet trust the media since the\n      fingerprint has
      not yet been received.  This lack of trusted,\n      secure media is indicated
      to Alice via the UA user interface.\n   Message (7):  Finished Alice -> Bob\n
      \     After Message 7 is received by Bob, Alice sends change_cipher_spec\n      and
      Finished.\n   Message (8):  200 OK Bob -> Alice\n      When Bob answers the
      call, Bob sends a 200 OK SIP message that\n      contains the fingerprint for
      Bob's certificate.  Bob signals the\n      actual transport protocol configuration
      of SRTP over DTLS in the\n      acfg parameter.\n   SIP/2.0 200 OK\n   To: <sip:bob@example.com>;tag=6418913922105372816\n
      \  From: \"Alice\" <sip:alice@example.com>;tag=843c7b0b\n   Via: SIP/2.0/TLS
      proxy.example.com:5061;branch=z9hG4bK-0e53sadfkasldk\n   Via: SIP/2.0/TLS ua1.example.com;branch=z9hG4bK-0e53sadfkasldkfj\n
      \  Record-Route: <sip:proxy.example.com;lr>\n   Call-ID: 6076913b1c39c212@REVMTEpG\n
      \  CSeq: 1 INVITE\n   Contact: <sip:bob@ua2.example.com>\n   Content-Type: application/sdp\n
      \  Content-Length: xxxx\n   Supported: from-change\n   v=0\n   o=- 6418913922105372816
      2105372818 IN IP4 ua2.example.com\n   s=example2\n   c=IN IP4 ua2.example.com\n
      \  a=setup:active\n   a=fingerprint: SHA-1 \\\n     FF:FF:FF:B1:3F:82:18:3B:54:02:12:DF:3E:5D:49:6B:19:E5:7C:AB\n
      \  t=0 0\n   m=audio 12000 UDP/TLS/RTP/SAVP 0\n   a=acfg:1 t=1\n   Message (9):
      \ 200 OK Proxy -> Alice\n      Alice receives the message from her proxy and
      validates the\n      certificate presented in Message 7.  The endpoint now shows
      Alice\n      that the call as secured.\n   Message (10):  RTP+RTCP Alice ->
      Bob\n      At this point, Alice can also start sending RTP and RTCP to Bob.\n
      \  Message (11):  ACK Alice -> Bob\n      Finally, Alice sends the SIP ACK to
      Bob.\n"
    title: 7.1.  Basic Message Flow with Early Media and SIP Identity
  - contents:
    - "7.2.  Basic Message Flow with Connected Identity (RFC 4916)\n   The previous
      example did not show the use of RFC 4916 for connected\n   identity.  The following
      example does:\n   Alice            Proxies             Bob\n     |(1) INVITE
      \      |                  |\n     |---------------->|                  |\n     |
      \                |(2) INVITE        |\n     |                 |----------------->|\n
      \    |                 |(3) hello         |\n     |<-----------------------------------|\n
      \    |(4) hello        |                  |\n     |----------------------------------->|\n
      \    |                 |(5) finished      |\n     |<-----------------------------------|\n
      \    |                 |(6) media         |\n     |<-----------------------------------|\n
      \    |(7) finished     |                  |\n     |----------------------------------->|\n
      \    |                 |(8)  200 OK       |\n     |<-----------------------------------|\n
      \    |(9) ACK          |                  |\n     |----------------------------------->|\n
      \    |                 |(10)  UPDATE      |\n     |                 |<-----------------|\n
      \    |(11) UPDATE      |                  |\n     |<----------------|                  |\n
      \    |(12) 200 OK      |                  |\n     |---------------->|                  |\n
      \    |                 |(13) 200 OK       |\n     |                 |----------------->|\n
      \    |                 |(14) media        |\n     |<---------------------------------->|\n
      \  The first 9 messages of this example are the same as before.\n   However,
      Messages 10-13, performing the RFC 4916 UPDATE, are new.\n   Message (10):  UPDATE
      Bob -> Proxy\n      Bob sends an RFC 4916 UPDATE towards Alice.  This update
      contains\n      his fingerprint.  Bob's UPDATE contains the same session\n      information
      that he provided in his 200 OK (Message 8).  Note that\n      in principle an
      UPDATE here can be used to modify session\n      parameters.  However, in this
      case it's being used solely to\n      confirm the fingerprint.\n   UPDATE sip:alice@ua1.example.com
      SIP/2.0\n   Via: SIP/2.0/TLS ua2.example.com;branch=z9hG4bK-0e53sadfkasldkfj\n
      \  To: \"Alice\" <sip:alice@example.com>;tag=843c7b0b\n   From <sip:bob@example.com>;tag=6418913922105372816\n
      \  Route: <sip:proxy.example.com;lr>\n   Call-ID: 6076913b1c39c212@REVMTEpG\n
      \  CSeq: 2 UPDATE\n   Contact: <sip:ua2.example.com>\n   Content-Type: application/sdp\n
      \  Content-Length: xxxx\n   Supported: from-change\n   Max-Forwards: 70\n   v=0\n
      \  o=- 6418913922105372816 2105372818 IN IP4 ua2.example.com\n   s=example2\n
      \  c=IN IP4 ua2.example.com\n   a=setup:active\n   a=fingerprint: SHA-1 \\\n
      \    FF:FF:FF:B1:3F:82:18:3B:54:02:12:DF:3E:5D:49:6B:19:E5:7C:AB\n   t=0 0\n
      \  m=audio 12000 UDP/TLS/RTP/SAVP 0\n   a=acfg:1 t=1\n   Message (11):  UPDATE
      Proxy -> Alice\n      This shows the UPDATE being relayed to Alice from Bob
      (and Alice's\n      proxy).  Note that Bob's proxy has inserted an Identity
      and\n      Identity-Info header.  As above, we only show one element for both\n
      \     proxies for purposes of simplification.  Alice verifies the\n      identity
      provided.  (Note: the actual identity signatures here are\n      incorrect and
      provided merely as examples.)\n   UPDATE sip:alice@ua1.example.com SIP/2.0\n
      \  Via: SIP/2.0/TLS proxy.example.com;branch=z9hG4bK-0e53sadfkasldkfj\n   Via:
      SIP/2.0/TLS ua2.example.com;branch=z9hG4bK-0e53sadfkasldkfj\n   To: \"Alice\"
      <sip:alice@example.com>;tag=843c7b0b\n   From <sip:bob@example.com>;tag=6418913922105372816\n
      \  Call-ID: 6076913b1c39c212@REVMTEpG\n   CSeq: 2 UPDATE\n   Contact: <sip:bob@ua2.example.com>\n
      \  Content-Type: application/sdp\n   Content-Length: xxxx\n   Supported: from-change\n
      \  Max-Forwards: 69\n   Identity: CyI4+nAkHrH3ntmaxgr01TMxTmtjP7MASwliNRdupRI1vpkXRvZXx1ja9k\n
      \            3W+v1PDsy32MaqZi0M5WfEkXxbgTnPYW0jIoK8HMyY1VT7egt0kk4XrKFC\n             HYWGCl0nB2sNsM9CG4hq+YJZTMaSROoMUBhikVIjnQ8ykeD6UXNOyfI=\n
      \  Identity-Info: https://example.com/cert\n   v=0\n   o=- 6418913922105372816
      2105372818 IN IP4 ua2.example.com\n   s=example2\n   c=IN IP4 ua2.example.com\n
      \  a=setup:active\n   a=fingerprint: SHA-1 \\\n     FF:FF:FF:B1:3F:82:18:3B:54:02:12:DF:3E:5D:49:6B:19:E5:7C:AB\n
      \  t=0 0\n   m=audio 12000 UDP/TLS/RTP/SAVP 0\n   a=acfg:1 t=1\n   Message (12):
      \ 200 OK Alice -> Bob\n      This shows Alice's 200 OK response to Bob's UPDATE.
      \ Because Bob\n      has merely sent the same session parameters he sent in
      his 200 OK,\n      Alice can simply replay her view of the session parameters
      as\n      well.\n   SIP/2.0 200 OK\n   To: \"Alice\" <sip:alice@example.com>;tag=843c7b0b\n
      \  From <sip:bob@example.com>;tag=6418913922105372816\n   Via: SIP/2.0/TLS proxy.example.com;branch=z9hG4bK-0e53sadfkasldkfj\n
      \  Via: SIP/2.0/TLS ua2.example.com;branch=z9hG4bK-0e53sadfkasldkfj\n   Call-ID:
      6076913b1c39c212@REVMTEpG\n   CSeq: 2 UPDATE\n   Contact: <sip:bob@ua2.example.com>\n
      \  Content-Type: application/sdp\n   Content-Length: xxxx\n   Supported: from-change\n
      \  v=0\n   o=- 1181923068 1181923196 IN IP4 ua2.example.com\n   s=example1\n
      \  c=IN IP4 ua2.example.com\n   a=setup:actpass\n   a=fingerprint: SHA-1 \\\n
      \    4A:AD:B9:B1:3F:82:18:3B:54:02:12:DF:3E:5D:49:6B:19:E5:7C:AB\n   t=0 0\n
      \  m=audio 6056 RTP/AVP 0\n   a=sendrecv\n   a=tcap:1 UDP/TLS/RTP/SAVP RTP/AVP\n
      \  a=pcfg:1 t=1\n"
    title: 7.2.  Basic Message Flow with Connected Identity (RFC 4916)
  - contents:
    - "7.3.  Basic Message Flow with STUN Check for NAT Case\n   In the previous examples,
      the DTLS handshake has already completed by\n   the time Alice receives Bob's
      200 OK (8).  Therefore, no STUN check\n   is sent.  However, if Alice had a
      NAT, then Bob's ClientHello might\n   get blocked by that NAT, in which case
      Alice would send the STUN\n   check described in Section 6.7.1 upon receiving
      the 200 OK, as shown\n   below:\n   Alice            Proxies             Bob\n
      \    |(1) INVITE       |                  |\n     |---------------->|                  |\n
      \    |                 |(2) INVITE        |\n     |                 |----------------->|\n
      \    |                 |(3) hello         |\n     |                 X<-----------------|\n
      \    |                 |(4)  200 OK       |\n     |<-----------------------------------|\n
      \    | (5) conn-check  |                  |\n     |----------------------------------->|\n
      \    |                 |(6) conn-response |\n     |<-----------------------------------|\n
      \    |                 |(7) hello (rtx)   |\n     |<-----------------------------------|\n
      \    |(8) hello        |                  |\n     |----------------------------------->|\n
      \    |                 |(9) finished      |\n     |<-----------------------------------|\n
      \    |                 |(10) media        |\n     |<-----------------------------------|\n
      \    |(11) finished    |                  |\n     |----------------------------------->|\n
      \    |                 |(11) media        |\n     |----------------------------------->|\n
      \    |(12) ACK         |                  |\n     |----------------------------------->|\n
      \  The messages here are the same as in the first example (for\n   simplicity
      this example omits an UPDATE), with the following three\n   new messages:\n
      \  Message (5):  STUN connectivity-check Alice -> Bob\n      Section 6.7.1 describes
      an approach to avoid an SBC interaction\n      issue where the endpoints do
      not support ICE.  Alice (the passive\n      endpoint) sends a STUN connectivity
      check to Bob.  This opens a\n      pinhole in Alice's NAT/firewall.\n   Message
      (6):  STUN connectivity-check response Bob -> Alice\n      Bob (the active endpoint)
      sends a response to the STUN\n      connectivity check (Message 3) to Alice.
      \ This tells Alice that\n      her connectivity check has succeeded and she
      can stop the\n      retransmit state machine.\n   Message (7):  Hello (retransmit)
      Bob -> Alice\n      Bob retransmits his DTLS ClientHello, which now passes through
      the\n      pinhole created in Alice's firewall.  At this point, the DTLS\n      handshake
      proceeds as before.\n"
    title: 7.3.  Basic Message Flow with STUN Check for NAT Case
  title: 7.  Example Message Flow
- contents:
  - "8.  Security Considerations\n   DTLS or TLS media signaled with SIP requires
    a way to ensure that the\n   communicating peers' certificates are correct.\n
    \  The standard TLS/DTLS strategy for authenticating the communicating\n   parties
    is to give the server (and optionally the client) a PKIX\n   [RFC5280] certificate.
    \ The client then verifies the certificate and\n   checks that the name in the
    certificate matches the server's domain\n   name.  This works because there are
    a relatively small number of\n   servers with well-defined names; a situation
    that does not usually\n   occur in the VoIP context.\n   The design described
    in this document is intended to leverage the\n   authenticity of the signaling
    channel (while not requiring\n   confidentiality).  As long as each side of the
    connection can verify\n   the integrity of the SDP received from the other side,
    then the DTLS\n   handshake cannot be hijacked via a man-in-the-middle attack.
    \ This\n   integrity protection is easily provided by the caller to the callee\n
    \  (see Alice to Bob in Section 7) via the SIP Identity [RFC4474]\n   mechanism.
    \ Other mechanisms, such as the S/MIME mechanism described\n   in RFC 3261, or
    perhaps future mechanisms yet to be defined could\n   also serve this purpose.\n
    \  While this mechanism can still be used without such integrity\n   mechanisms,
    the security provided is limited to defense against\n   passive attack by intermediaries.
    \ An active attack on the signaling\n   plus an active attack on the media plane
    can allow an attacker to\n   attack the connection (R-SIG-MEDIA in the notation
    of [RFC5479]).\n"
  - contents:
    - "8.1.  Responder Identity\n   SIP Identity does not support signatures in responses.
      \ Ideally,\n   Alice would want to know that Bob's SDP had not been tampered
      with\n   and who it was from so that Alice's User Agent could indicate to\n
      \  Alice that there was a secure phone call to Bob.  [RFC4916] defines\n   an
      approach for a UA to supply its identity to its peer UA, and for\n   this identity
      to be signed by an authentication service.  For\n   example, using this approach,
      Bob sends an answer, then immediately\n   follows up with an UPDATE that includes
      the fingerprint and uses the\n   SIP Identity mechanism to assert that the message
      is from\n   Bob@example.com.  The downside of this approach is that it requires\n
      \  the extra round trip of the UPDATE.  However, it is simple and secure\n   even
      when not all of the proxies are trusted.  In this example, Bob\n   only needs
      to trust his proxy.  Offerers SHOULD support this\n   mechanism and answerers
      SHOULD use it.\n   In some cases, answerers will not send an UPDATE and in many
      calls,\n   some media will be sent before the UPDATE is received.  In these\n
      \  cases, no integrity is provided for the fingerprint from Bob to\n   Alice.
      \ In this approach, an attacker that was on the signaling path\n   could tamper
      with the fingerprint and insert themselves as a man-in-\n   the-middle on the
      media.  Alice would know that she had a secure call\n   with someone, but would
      not know if it was with Bob or a man-in-the-\n   middle.  Bob would know that
      an attack was happening.  The fact that\n   one side can detect this attack
      means that in most cases where Alice\n   and Bob both wish for the communications
      to be encrypted, there is\n   not a problem.  Keep in mind that in any of the
      possible approaches,\n   Bob could always reveal the media that was received
      to anyone.  We\n   are making the assumption that Bob also wants secure communications.\n
      \  In this do nothing case, Bob knows the media has not been tampered\n   with
      or intercepted by a third party and that it is from\n   Alice@example.com.  Alice
      knows that she is talking to someone and\n   that whoever that is has probably
      checked that the media is not being\n   intercepted or tampered with.  This
      approach is certainly less than\n   ideal but very usable for many situations.\n"
    title: 8.1.  Responder Identity
  - contents:
    - "8.2.  SIPS\n   If SIP Identity is not used, but the signaling is protected
      by SIPS,\n   the security guarantees are weaker.  Some security is still provided\n
      \  as long as all proxies are trusted.  This provides integrity for the\n   fingerprint
      in a chain-of-trust security model.  Note, however, that\n   if the proxies
      are not trusted, then the level of security provided\n   is limited.\n"
    title: 8.2.  SIPS
  - contents:
    - "8.3.  S/MIME\n   RFC 3261 [RFC3261] defines an S/MIME security mechanism for
      SIP that\n   could be used to sign that the fingerprint was from Bob.  This
      would\n   be secure.\n"
    title: 8.3.  S/MIME
  - contents:
    - "8.4.  Continuity of Authentication\n   One desirable property of a secure media
      system is to provide\n   continuity of authentication: being able to ensure
      cryptographically\n   that you are talking to the same person as before.  With
      DTLS,\n   continuity of authentication is achieved by having each side use the\n
      \  same public key/self-signed certificate for each connection (at least\n   with
      a given peer entity).  It then becomes possible to cache the\n   credential
      (or its hash) and verify that it is unchanged.  Thus, once\n   a single secure
      connection has been established, an implementation\n   can establish a future
      secure channel even in the face of future\n   insecure signaling.\n   In order
      to enable continuity of authentication, implementations\n   SHOULD attempt to
      keep a constant long-term key.  Verifying\n   implementations SHOULD maintain
      a cache of the key used for each peer\n   identity and alert the user if that
      key changes.\n"
    title: 8.4.  Continuity of Authentication
  - contents:
    - "8.5.  Short Authentication String\n   An alternative available to Alice and
      Bob is to use human speech to\n   verify each other's identity and then to verify
      each other's\n   fingerprints also using human speech.  Assuming that it is
      difficult\n   to impersonate another's speech and seamlessly modify the audio\n
      \  contents of a call, this approach is relatively safe.  It would not\n   be
      effective if other forms of communication were being used such as\n   video
      or instant messaging.  DTLS supports this mode of operation.\n   The minimal
      secure fingerprint length is around 64 bits.\n   ZRTP [AVT-ZRTP] includes Short
      Authentication String (SAS) mode in\n   which a unique per-connection bitstring
      is generated as part of the\n   cryptographic handshake.  The SAS can be as
      short as 25 bits and so\n   is somewhat easier to read.  DTLS does not natively
      support this\n   mode.  Based on the level of deployment interest, a TLS extension\n
      \  [RFC5246] could provide support for it.  Note that SAS schemes only\n   work
      well when the endpoints recognize each other's voices, which is\n   not true
      in many settings (e.g., call centers).\n"
    title: 8.5.  Short Authentication String
  - contents:
    - "8.6.  Limits of Identity Assertions\n   When RFC 4474 is used to bind the media
      keying material to the SIP\n   signaling, the assurances about the provenance
      and security of the\n   media are only as good as those for the signaling.  There
      are two\n   important cases to note here:\n   o  RFC 4474 assumes that the proxy
      with the certificate \"example.com\"\n      controls the namespace \"example.com\".
      \ Therefore, the RFC 4474\n      authentication service that is authoritative
      for a given namespace\n      can control which user is assigned each name.  Thus,
      the\n      authentication service can take an address formerly assigned to\n
      \     Alice and transfer it to Bob.  This is an intentional design\n      feature
      of RFC 4474 and a direct consequence of the SIP namespace\n      architecture.\n
      \  o  When phone number URIs (e.g.,\n      'sip:+17005551008@chicago.example.com'
      or\n      'sip:+17005551008@chicago.example.com;user=phone') are used, there\n
      \     is no structural reason to trust that the domain name is\n      authoritative
      for a given phone number, although individual\n      proxies and UAs may have
      private arrangements that allow them to\n      trust other domains.  This is
      a structural issue in that Public\n      Switched Telephone Network (PSTN) elements
      are trusted to assert\n      their phone number correctly and that there is
      no real concept of\n      a given entity being authoritative for some number
      space.\n   In both of these cases, the assurances that DTLS-SRTP provides in\n
      \  terms of data origin integrity and confidentiality are necessarily no\n   better
      than SIP provides for signaling integrity when RFC 4474 is\n   used.  Implementors
      should therefore take care not to indicate\n   misleading peer identity information
      in the user interface.  That is,\n   if the peer's identity is sip:+17005551008@chicago.example.com,
      it is\n   not sufficient to display that the identity of the peer as\n   +17005551008,
      unless there is some policy that states that the domain\n   \"chicago.example.com\"
      is trusted to assert the E.164 numbers it is\n   asserting.  In cases where
      the UA can determine that the peer\n   identity is clearly an E.164 number,
      it may be less confusing to\n   simply identify the call as encrypted but to
      an unknown peer.\n   In addition, some middleboxes (back-to-back user agents
      (B2BUAs) and\n   Session Border Controllers) are known to modify portions of
      the SIP\n   message that are included in the RFC 4474 signature computation,
      thus\n   breaking the signature.  This sort of man-in-the-middle operation is\n
      \  precisely the sort of message modification that RFC 4474 is intended\n   to
      detect.  In cases where the middlebox is itself permitted to\n   generate valid
      RFC 4474 signatures (e.g., it is within the same\n   administrative domain as
      the RFC 4474 authentication service), then\n   it may generate a new signature
      on the modified message.\n   Alternately, the middlebox may be able to sign
      with some other\n   identity that it is permitted to assert.  Otherwise, the
      recipient\n   cannot rely on the RFC 4474 Identity assertion and the UA MUST
      NOT\n   indicate to the user that a secure call has been established to the\n
      \  claimed identity.  Implementations that are configured to only\n   establish
      secure calls SHOULD terminate the call in this case.\n   If SIP Identity or
      an equivalent mechanism is not used, then only\n   protection against attackers
      who cannot actively change the signaling\n   is provided.  While this is still
      superior to previous mechanisms,\n   the security provided is inferior to that
      provided if integrity is\n   provided for the signaling.\n"
    title: 8.6.  Limits of Identity Assertions
  - contents:
    - "8.7.  Third-Party Certificates\n   This specification does not depend on the
      certificates being held by\n   endpoints being independently verifiable (e.g.,
      being issued by a\n   trusted third party).  However, there is no limitation
      on such\n   certificates being used.  Aside from the difficulty of obtaining
      such\n   certificates, it is not clear what identities those certificates\n
      \  would contain -- RFC 3261 specifies a convention for S/MIME\n   certificates
      that could also be used here, but that has seen only\n   minimal deployment.
      \ However, in closed or semi-closed contexts where\n   such a convention can
      be established, third-party certificates can\n   reduce the reliance on trusting
      even proxies in the endpoint's\n   domains.\n"
    title: 8.7.  Third-Party Certificates
  - contents:
    - "8.8.  Perfect Forward Secrecy\n   One concern about the use of a long-term
      key is that compromise of\n   that key may lead to compromise of past communications.
      \ In order to\n   prevent this attack, DTLS supports modes with Perfect Forward
      Secrecy\n   using Diffie-Hellman and Elliptic-Curve Diffie-Hellman cipher suites.\n
      \  When these modes are in use, the system is secure against such\n   attacks.
      \ Note that compromise of a long-term key may still lead to\n   future active
      attacks.  If this is a concern, a backup authentication\n   channel, such as
      manual fingerprint establishment or a short\n   authentication string, should
      be used.\n"
    title: 8.8.  Perfect Forward Secrecy
  title: 8.  Security Considerations
- contents:
  - "9.  Acknowledgments\n   Cullen Jennings contributed substantial text and comments
    to this\n   document.  This document benefited from discussions with Francois\n
    \  Audet, Nagendra Modadugu, and Dan Wing.  Thanks also for useful\n   comments
    by Flemming Andreasen, Jonathan Rosenberg, Rohan Mahy, David\n   McGrew, Miguel
    Garcia, Steffen Fries, Brian Stucker, Robert Gilman,\n   David Oran, and Peter
    Schneider.\n   We would like to thank Thomas Belling, Guenther Horn, Steffen Fries,\n
    \  Brian Stucker, Francois Audet, Dan Wing, Jari Arkko, and Vesa\n   Lehtovirta
    for their input regarding traversal of SBCs.\n"
  title: 9.  Acknowledgments
- contents:
  - '10.  References

    '
  - contents:
    - "10.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March
      1997.\n   [RFC3261]  Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston,\n
      \             A., Peterson, J., Sparks, R., Handley, M., and E.\n              Schooler,
      \"SIP: Session Initiation Protocol\", RFC 3261,\n              June 2002.\n
      \  [RFC3264]  Rosenberg, J. and H. Schulzrinne, \"An Offer/Answer Model\n              with
      Session Description Protocol (SDP)\", RFC 3264,\n              June 2002.\n
      \  [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,\n              Housley,
      R., and W. Polk, \"Internet X.509 Public Key\n              Infrastructure Certificate
      and Certificate Revocation List\n              (CRL) Profile\", RFC 5280, May
      2008.\n   [RFC3323]  Peterson, J., \"A Privacy Mechanism for the Session\n              Initiation
      Protocol (SIP)\", RFC 3323, November 2002.\n   [RFC3550]  Schulzrinne, H., Casner,
      S., Frederick, R., and V.\n              Jacobson, \"RTP: A Transport Protocol
      for Real-Time\n              Applications\", STD 64, RFC 3550, July 2003.\n
      \  [RFC4145]  Yon, D. and G. Camarillo, \"TCP-Based Media Transport in\n              the
      Session Description Protocol (SDP)\", RFC 4145,\n              September 2005.\n
      \  [RFC4347]  Rescorla, E. and N. Modadugu, \"Datagram Transport Layer\n              Security\",
      RFC 4347, April 2006.\n   [RFC4474]  Peterson, J. and C. Jennings, \"Enhancements
      for\n              Authenticated Identity Management in the Session\n              Initiation
      Protocol (SIP)\", RFC 4474, August 2006.\n   [RFC4566]  Handley, M., Jacobson,
      V., and C. Perkins, \"SDP: Session\n              Description Protocol\", RFC
      4566, July 2006.\n   [RFC4572]  Lennox, J., \"Connection-Oriented Media Transport
      over the\n              Transport Layer Security (TLS) Protocol in the Session\n
      \             Description Protocol (SDP)\", RFC 4572, July 2006.\n   [RFC5389]
      \ Rosenberg, J., Mahy, R., Matthews, P., and D. Wing,\n              \"Session
      Traversal Utilities for NAT (STUN)\", RFC 5389,\n              October 2008.\n"
    title: 10.1.  Normative References
  - contents:
    - "10.2.  Informative References\n   [RFC4571]  Lazzaro, J., \"Framing Real-time
      Transport Protocol (RTP)\n              and RTP Control Protocol (RTCP) Packets
      over\n              Connection-Oriented Transport\", RFC 4571, July 2006.\n
      \  [RFC3325]  Jennings, C., Peterson, J., and M. Watson, \"Private\n              Extensions
      to the Session Initiation Protocol (SIP) for\n              Asserted Identity
      within Trusted Networks\", RFC 3325,\n              November 2002.\n   [RFC5245]
      \ Rosenberg, J., \"Interactive Connectivity Establishment\n              (ICE):
      A Protocol for Network Address Translator (NAT)\n              Traversal for
      Offer/Answer Protocols\", RFC 5245, April\n              2010.\n   [RFC4567]
      \ Arkko, J., Lindholm, F., Naslund, M., Norrman, K., and E.\n              Carrara,
      \"Key Management Extensions for Session\n              Description Protocol
      (SDP) and Real Time Streaming\n              Protocol (RTSP)\", RFC 4567, July
      2006.\n   [RFC4568]  Andreasen, F., Baugher, M., and D. Wing, \"Session\n              Description
      Protocol (SDP) Security Descriptions for Media\n              Streams\", RFC
      4568, July 2006.\n   [AVT-ZRTP] Zimmermann, P., Johnston, A., and J. Callas,
      \"ZRTP: Media\n              Path Key Agreement for Secure RTP\", Work in Progress,\n
      \             March 2009.\n   [SRTP-EKT] McGrew, D., Andreasen, F., and L. Dondeti,
      \"Encrypted Key\n              Transport for Secure RTP\", Work in Progress,
      March 2009.\n   [RFC5764]  McGrew, D. and E. Rescorla, \"Datagram Transport
      Layer\n              Security (DTLS) Extension to Establish Keys for Secure\n
      \             Real-time Transport Protocol (SRTP)\", RFC 5764, May 2010.\n   [RFC5479]
      \ Wing, D., Fries, S., Tschofenig, H., and F. Audet,\n              \"Requirements
      and Analysis of Media Security Management\n              Protocols\", RFC 5479,
      March 2009.\n   [MMUSIC-SDP]\n              Andreasen, F., \"SDP Capability
      Negotiation\", Work\n              in Progress, February 2010.\n   [RFC5761]
      \ Perkins, C. and M. Westerlund, \"Multiplexing RTP Data and\n              Control
      Packets on a Single Port\", RFC 5761, April 2010.\n   [RFC3262]  Rosenberg,
      J. and H. Schulzrinne, \"Reliability of\n              Provisional Responses
      in Session Initiation Protocol\n              (SIP)\", RFC 3262, June 2002.\n
      \  [RFC5246]  Dierks, T. and E. Rescorla, \"The Transport Layer Security\n              (TLS)
      Protocol Version 1.2\", RFC 5246, August 2008.\n   [RFC4916]  Elwell, J., \"Connected
      Identity in the Session Initiation\n              Protocol (SIP)\", RFC 4916,
      June 2007.\n   [RFC3711]  Baugher, M., McGrew, D., Naslund, M., Carrara, E.,
      and K.\n              Norrman, \"The Secure Real-time Transport Protocol (SRTP)\",\n
      \             RFC 3711, March 2004.\n   [RFC3830]  Arkko, J., Carrara, E., Lindholm,
      F., Naslund, M., and K.\n              Norrman, \"MIKEY: Multimedia Internet
      KEYing\", RFC 3830,\n              August 2004.\n   [SIPPING-SRTP]\n              Wing,
      D., Audet, F., Fries, S., Tschofenig, H., and A.\n              Johnston, \"Secure
      Media Recording and Transcoding with the\n              Session Initiation Protocol\",
      Work in Progress,\n              October 2008.\n   [KEY-TRANSPORT]\n              Wing,
      D., \"DTLS-SRTP Key Transport (KTR)\", Work\n              in Progress, March
      2009.\n   [MMUSIC-MEDIA]\n              Stucker, B. and H. Tschofenig, \"Analysis
      of Middlebox\n              Interactions for Signaling Protocol Communication
      along\n              the Media Path\", Work in Progress, March 2009.\n   [RFC5767]
      \ Munakata, M., Schubert, S., and T. Ohba, \"User-Agent-\n              Driven
      Privacy Mechanism for SIP\", RFC 5767, April 2010.\n"
    title: 10.2.  Informative References
  title: 10.  References
- contents:
  - "Appendix A.  Requirements Analysis\n   [RFC5479] describes security requirements
    for media keying.  This\n   section evaluates this proposal with respect to each
    requirement.\n"
  - contents:
    - "A.1.  Forking and Retargeting (R-FORK-RETARGET, R-BEST-SECURE,\n      R-DISTINCT)\n
      \  In this document, the SDP offer (in the INVITE) is simply an\n   advertisement
      of the capability to do security.  This advertisement\n   does not depend on
      the identity of the communicating peer, so forking\n   and retargeting work
      when all the endpoints will do SRTP.  When a mix\n   of SRTP and non-SRTP endpoints
      are present, we use the SDP\n   capabilities mechanism currently being defined
      [MMUSIC-SDP] to\n   transparently negotiate security where possible.  Because
      DTLS\n   establishes a new key for each session, only the entity with which\n
      \  the call is finally established gets the media encryption keys (R3).\n"
    title: A.1.  Forking and Retargeting (R-FORK-RETARGET, R-BEST-SECURE,
  - contents:
    - "A.2.  Distinct Cryptographic Contexts (R-DISTINCT)\n   DTLS performs a new
      DTLS handshake with each endpoint, which\n   establishes distinct keys and cryptographic
      contexts for each\n   endpoint.\n"
    title: A.2.  Distinct Cryptographic Contexts (R-DISTINCT)
  - contents:
    - "A.3.  Reusage of a Security Context (R-REUSE)\n   DTLS allows sessions to be
      resumed with the 'TLS session resumption'\n   functionality.  This feature can
      be used to lower the amount of\n   cryptographic computation that needs to be
      done when two peers\n   re-initiate the communication.  See [RFC5764] for more
      on session\n   resumption in this context.\n"
    title: A.3.  Reusage of a Security Context (R-REUSE)
  - contents:
    - "A.4.  Clipping (R-AVOID-CLIPPING)\n   Because the key establishment occurs
      in the media plane, media need\n   not be clipped before the receipt of the
      SDP answer.  Note, however,\n   that only confidentiality is provided until
      the offerer receives the\n   answer: the answerer knows that they are not sending
      data to an\n   attacker but the offerer cannot know that they are receiving
      data\n   from the answerer.\n"
    title: A.4.  Clipping (R-AVOID-CLIPPING)
  - contents:
    - "A.5.  Passive Attacks on the Media Path (R-PASS-MEDIA)\n   The public key algorithms
      used by DTLS cipher suites, such as RSA,\n   Diffie-Hellman, and Elliptic Curve
      Diffie-Hellman, are secure against\n   passive attacks.\n"
    title: A.5.  Passive Attacks on the Media Path (R-PASS-MEDIA)
  - contents:
    - "A.6.  Passive Attacks on the Signaling Path (R-PASS-SIG)\n   DTLS provides
      protection against passive attacks by adversaries on\n   the signaling path
      since only a fingerprint is exchanged using SIP\n   signaling.\n"
    title: A.6.  Passive Attacks on the Signaling Path (R-PASS-SIG)
  - contents:
    - "A.7.  (R-SIG-MEDIA, R-ACT-ACT)\n   An attacker who controls the media channel
      but not the signaling\n   channel can perform a MITM attack on the DTLS handshake
      but this will\n   change the certificates that will cause the fingerprint check
      to\n   fail.  Thus, any successful attack requires that the attacker modify\n
      \  the signaling messages to replace the fingerprints.\n   If RFC 4474 Identity
      or an equivalent mechanism is used, an attacker\n   who controls the signaling
      channel at any point between the proxies\n   performing the Identity signatures
      cannot modify the fingerprints\n   without invalidating the signature.  Thus,
      even an attacker who\n   controls both signaling and media paths cannot successfully
      attack\n   the media traffic.  Note that the channel between the UA and the\n
      \  authentication service MUST be secured and the authentication service\n   MUST
      verify the UA's identity in order for this mechanism to be\n   secure.\n   Note
      that an attacker who controls the authentication service can\n   impersonate
      the UA using that authentication service.  This is an\n   intended feature of
      SIP Identity -- the authentication service owns\n   the namespace and therefore
      defines which user has which identity.\n"
    title: A.7.  (R-SIG-MEDIA, R-ACT-ACT)
  - contents:
    - "A.8.  Binding to Identifiers (R-ID-BINDING)\n   When an end-to-end mechanism
      such as SIP-Identity [RFC4474] and SIP-\n   Connected-Identity [RFC4916] or
      S/MIME are used, they bind the\n   endpoint's certificate fingerprints to the
      From: address in the\n   signaling.  The fingerprint is covered by the Identity
      signature.\n   When other mechanisms (e.g., SIPS) are used, then the binding
      is\n   correspondingly weaker.\n"
    title: A.8.  Binding to Identifiers (R-ID-BINDING)
  - contents:
    - "A.9.  Perfect Forward Secrecy (R-PFS)\n   DTLS supports Diffie-Hellman and
      Elliptic Curve Diffie-Hellman cipher\n   suites that provide PFS.\n"
    title: A.9.  Perfect Forward Secrecy (R-PFS)
  - contents:
    - "A.10.  Algorithm Negotiation (R-COMPUTE)\n   DTLS negotiates cipher suites
      before performing significant\n   cryptographic computation and therefore supports
      algorithm\n   negotiation and multiple cipher suites without additional\n   computational
      expense.\n"
    title: A.10.  Algorithm Negotiation (R-COMPUTE)
  - contents:
    - "A.11.  RTP Validity Check (R-RTP-VALID)\n   DTLS packets do not pass the RTP
      validity check.  The first byte of a\n   DTLS packet is the content type and
      all current DTLS content types\n   have the first two bits set to zero, resulting
      in a version of zero;\n   thus, failing the first validity check.  DTLS packets
      can also be\n   distinguished from STUN packets.  See [RFC5764] for details
      on\n   demultiplexing.\n"
    title: A.11.  RTP Validity Check (R-RTP-VALID)
  - contents:
    - "A.12.  Third-Party Certificates (R-CERTS, R-EXISTING)\n   Third-party certificates
      are not required because signaling (e.g.,\n   [RFC4474]) is used to authenticate
      the certificates used by DTLS.\n   However, if the parties share an authentication
      infrastructure that\n   is compatible with TLS (third-party certificates or
      shared keys) it\n   can be used.\n"
    title: A.12.  Third-Party Certificates (R-CERTS, R-EXISTING)
  - contents:
    - "A.13.  FIPS 140-2 (R-FIPS)\n   TLS implementations already may be FIPS 140-2
      approved and the\n   algorithms used here are consistent with the approval of
      DTLS and\n   DTLS-SRTP.\n"
    title: A.13.  FIPS 140-2 (R-FIPS)
  - contents:
    - "A.14.  Linkage between Keying Exchange and SIP Signaling (R-ASSOC)\n   The
      signaling exchange is linked to the key management exchange using\n   the fingerprints
      carried in SIP and the certificates are exchanged in\n   DTLS.\n"
    title: A.14.  Linkage between Keying Exchange and SIP Signaling (R-ASSOC)
  - contents:
    - "A.15.  Denial-of-Service Vulnerability (R-DOS)\n   DTLS offers some degree
      of Denial-of-Service (DoS) protection as a\n   built-in feature (see Section
      4.2.1 of [RFC4347]).\n"
    title: A.15.  Denial-of-Service Vulnerability (R-DOS)
  - contents:
    - "A.16.  Crypto-Agility (R-AGILITY)\n   DTLS allows cipher suites to be negotiated
      and hence new algorithms\n   can be incrementally deployed.  Work on replacing
      the fixed MD5/SHA-1\n   key derivation function is ongoing.\n"
    title: A.16.  Crypto-Agility (R-AGILITY)
  - contents:
    - "A.17.  Downgrading Protection (R-DOWNGRADE)\n   DTLS provides protection against
      downgrading attacks since the\n   selection of the offered cipher suites is
      confirmed in a later stage\n   of the handshake.  This protection is efficient
      unless an adversary\n   is able to break a cipher suite in real-time.  RFC 4474
      is able to\n   prevent an active attacker on the signaling path from downgrading
      the\n   call from SRTP to RTP.\n"
    title: A.17.  Downgrading Protection (R-DOWNGRADE)
  - contents:
    - "A.18.  Media Security Negotiation (R-NEGOTIATE)\n   DTLS allows a User Agent
      to negotiate media security parameters for\n   each individual session.\n"
    title: A.18.  Media Security Negotiation (R-NEGOTIATE)
  - contents:
    - "A.19.  Signaling Protocol Independence (R-OTHER-SIGNALING)\n   The DTLS-SRTP
      framework does not rely on SIP; every protocol that is\n   capable of exchanging
      a fingerprint and the media description can be\n   secured.\n"
    title: A.19.  Signaling Protocol Independence (R-OTHER-SIGNALING)
  - contents:
    - "A.20.  Media Recording (R-RECORDING)\n   An extension, see [SIPPING-SRTP],
      has been specified to support media\n   recording that does not require intermediaries
      to act as an MITM.\n   When media recording is done by intermediaries, then
      they need to act\n   as an MITM.\n"
    title: A.20.  Media Recording (R-RECORDING)
  - contents:
    - "A.21.  Interworking with Intermediaries (R-TRANSCODER)\n   In order to interface
      with any intermediary that transcodes the\n   media, the transcoder must have
      access to the keying material and be\n   treated as an endpoint for the purposes
      of this document.\n"
    title: A.21.  Interworking with Intermediaries (R-TRANSCODER)
  - contents:
    - "A.22.  PSTN Gateway Termination (R-PSTN)\n   The DTLS-SRTP framework allows
      the media security to terminate at a\n   PSTN gateway.  This does not provide
      end-to-end security, but is\n   consistent with the security goals of this framework
      because the\n   gateway is authorized to speak for the PSTN namespace.\n"
    title: A.22.  PSTN Gateway Termination (R-PSTN)
  - contents:
    - "A.23.  R-ALLOW-RTP\n   DTLS-SRTP allows RTP media to be received by the calling
      party until\n   SRTP has been negotiated with the answerer, after which SRTP
      is\n   preferred over RTP.\n"
    title: A.23.  R-ALLOW-RTP
  - contents:
    - "A.24.  R-HERFP\n   The Heterogeneous Error Response Forking Problem (HERFP)
      is not\n   applicable to DTLS-SRTP since the key exchange protocol will be\n
      \  executed along the media path and hence error messages are\n   communicated
      along this path and proxies do not need to progress\n   them.\n"
    title: A.24.  R-HERFP
  title: Appendix A.  Requirements Analysis
- contents:
  - "Authors' Addresses\n   Jason Fischl\n   Skype, Inc.\n   2145 Hamilton Ave.\n
    \  San Jose, CA  95135\n   USA\n   Phone: +1-415-692-1760\n   EMail: jason.fischl@skype.net\n
    \  Hannes Tschofenig\n   Nokia Siemens Networks\n   Linnoitustie 6\n   Espoo,
    \  02600\n   Finland\n   Phone: +358 (50) 4871445\n   EMail: Hannes.Tschofenig@gmx.net\n
    \  URI:   http://www.tschofenig.priv.at\n   Eric Rescorla\n   RTFM, Inc.\n   2064
    Edgewood Drive\n   Palo Alto, CA  94303\n   USA\n   EMail: ekr@rtfm.com\n"
  title: Authors' Addresses
