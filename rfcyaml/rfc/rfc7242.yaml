- title: __initial_text__
  contents:
  - ''
- title: Internet Research Task Force (IRTF)                            M. Demmer
  contents:
  - "Internet Research Task Force (IRTF)                            M. Demmer\n  \
    \      Delay-Tolerant Networking TCP Convergence-Layer Protocol\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes the protocol for the TCP-based convergence\n\
    \   layer for Delay-Tolerant Networking (DTN).  It is the product of the\n   IRTF's\
    \ DTN Research Group (DTNRG).\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for examination, experimental implementation, and\n   evaluation.\n\
    \   This document defines an Experimental Protocol for the Internet\n   community.\
    \  This document is a product of the Internet Research Task\n   Force (IRTF).\
    \  The IRTF publishes the results of Internet-related\n   research and development\
    \ activities.  These results might not be\n   suitable for deployment.  This RFC\
    \ represents the consensus of the\n   Delay-Tolerant Networking Research Group\
    \ of the Internet Research\n   Task Force (IRTF).  Documents approved for publication\
    \ by the IRSG\n   are not a candidate for any level of Internet Standard; see\
    \ Section 2\n   of RFC 5741.\n   Information about the current status of this\
    \ document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc7242.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2014 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................2\n\
    \   2. Definitions .....................................................4\n  \
    \    2.1. Definitions Specific to the TCPCL Protocol .................4\n   3.\
    \ General Protocol Description ....................................5\n      3.1.\
    \ Bidirectional Use of TCP Connection ........................6\n      3.2. Example\
    \ Message Exchange ...................................6\n   4. Connection Establishment\
    \ ........................................7\n      4.1. Contact Header .............................................8\n\
    \      4.2. Validation and Parameter Negotiation ......................10\n  \
    \ 5. Established Connection Operation ...............................11\n    \
    \  5.1. Message Type Codes ........................................11\n      5.2.\
    \ Bundle Data Transmission (DATA_SEGMENT) ...................12\n      5.3. Bundle\
    \ Acknowledgments (ACK_SEGMENT) ......................13\n      5.4. Bundle Refusal\
    \ (REFUSE_BUNDLE) ............................14\n      5.5. Bundle Length (LENGTH)\
    \ ....................................15\n      5.6. KEEPALIVE Feature (KEEPALIVE)\
    \ .............................16\n   6. Connection Termination .........................................17\n\
    \      6.1. Shutdown Message (SHUTDOWN) ...............................17\n  \
    \    6.2. Idle Connection Shutdown ..................................18\n   7.\
    \ Security Considerations ........................................19\n   8. IANA\
    \ Considerations ............................................20\n      8.1. Port\
    \ Number ...............................................20\n      8.2. Protocol\
    \ Versions .........................................20\n      8.3. Message Types\
    \ .............................................20\n      8.4. REFUSE_BUNDLE Reason\
    \ Codes ................................21\n      8.5. SHUTDOWN Reason Codes .....................................21\n\
    \   9. Acknowledgments ................................................21\n  \
    \ 10. References ....................................................21\n    \
    \  10.1. Normative References .....................................21\n      10.2.\
    \ Informative References ...................................21\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document describes the TCP-based convergence-layer\
    \ protocol for\n   Delay-Tolerant Networking.  Delay-Tolerant Networking is an\
    \ end-to-\n   end architecture providing communications in and/or through highly\n\
    \   stressed environments, including those with intermittent\n   connectivity,\
    \ long and/or variable delays, and high bit error rates.\n   More detailed descriptions\
    \ of the rationale and capabilities of these\n   networks can be found in \"Delay-Tolerant\
    \ Network Architecture\"\n   [RFC4838].\n   An important goal of the DTN architecture\
    \ is to accommodate a wide\n   range of networking technologies and environments.\
    \  The protocol used\n   for DTN communications is the Bundle Protocol (BP) [RFC5050],\
    \ an\n   application-layer protocol that is used to construct a store-and-\n \
    \  forward overlay network.  As described in the Bundle Protocol\n   specification\
    \ [RFC5050], it requires the services of a \"convergence-\n   layer adapter\"\
    \ (CLA) to send and receive bundles using the service of\n   some \"native\" link,\
    \ network, or Internet protocol.  This document\n   describes one such convergence-layer\
    \ adapter that uses the well-known\n   Transmission Control Protocol (TCP).  This\
    \ convergence layer is\n   referred to as TCPCL.\n   The locations of the TCPCL\
    \ and the BP in the Internet model protocol\n   stack are shown in Figure 1. \
    \ In particular, when BP is using TCP as\n   its bearer with TCPCL as its convergence\
    \ layer, both BP and TCPCL\n   reside at the application layer of the Internet\
    \ model.\n      +-------------------------+\n      |     DTN Application     |\
    \ -\\\n      +-------------------------|   |\n      |  Bundle Protocol (BP)  \
    \ |   -> Application Layer\n      +-------------------------+   |\n      | TCP\
    \ Conv. Layer (TCPCL) | -/\n      +-------------------------+\n      |       \
    \   TCP            | ---> Transport Layer\n      +-------------------------+\n\
    \      |           IP            | ---> Network Layer\n      +-------------------------+\n\
    \      |   Link-Layer Protocol   | ---> Link Layer\n      +-------------------------+\n\
    \      |    Physical Medium      | ---> Physical Layer\n      +-------------------------+\n\
    \        Figure 1: The Locations of the Bundle Protocol and the TCP\n        \
    \ Convergence-Layer Protocol in the Internet Protocol Stack\n   This document\
    \ describes the format of the protocol data units passed\n   between entities\
    \ participating in TCPCL communications.  This\n   document does not address:\n\
    \   o  The format of protocol data units of the Bundle Protocol, as those\n  \
    \    are defined elsewhere [RFC5050].\n   o  Mechanisms for locating or identifying\
    \ other bundle nodes within\n      an internet.\n   Note that this document describes\
    \ version 3 of the protocol.\n   Versions 0, 1, and 2 were never specified in\
    \ an Internet-Draft, RFC,\n   or any other public document.  These prior versions\
    \ of the protocol\n   were, however, implemented in the DTN reference implementation\n\
    \   [DTNIMPL] in prior releases; hence, the current version number\n   reflects\
    \ the existence of those prior versions.\n   This is an experimental protocol\
    \ produced within the IRTF's Delay-\n   Tolerant Networking Research Group (DTNRG).\
    \  It represents the\n   consensus of all active contributors to this group. \
    \ If this protocol\n   is used on the Internet, IETF standard protocols for security\
    \ and\n   congestion control should be used.\n"
- title: 2.  Definitions
  contents:
  - "2.  Definitions\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in [RFC2119].\n\
    \   The terms defined in Section 3.1 of [RFC5050] are used extensively in\n  \
    \ this document.\n"
- title: 2.1.  Definitions Specific to the TCPCL Protocol
  contents:
  - "2.1.  Definitions Specific to the TCPCL Protocol\n   This section contains definitions\
    \ that are interpreted to be specific\n   to the operation of the TCPCL protocol,\
    \ as described below.\n   TCP Connection --  A TCP connection refers to a transport\
    \ connection\n        using TCP as the transport protocol.\n   TCPCL Connection\
    \ --  A TCPCL connection (as opposed to a TCP\n        connection) is a TCPCL\
    \ communication relationship between two\n        bundle nodes.  The lifetime\
    \ of a TCPCL connection is bound to\n        the lifetime of an underlying TCP\
    \ connection.  Therefore, a\n        TCPCL connection is initiated when a bundle\
    \ node initiates a TCP\n        connection to be established for the purposes\
    \ of bundle\n        communication.  A TCPCL connection is terminated when the\
    \ TCP\n        connection ends, due either to one or both nodes actively\n   \
    \     terminating the TCP connection or due to network errors causing\n      \
    \  a failure of the TCP connection.  For the remainder of this\n        document,\
    \ the term \"connection\" without the prefix \"TCPCL\" shall\n        refer to\
    \ a TCPCL connection.\n   Connection parameters --  The connection parameters\
    \ are a set of\n        values used to affect the operation of the TCPCL for a\
    \ given\n        connection.  The manner in which these parameters are conveyed\n\
    \        to the bundle node and thereby to the TCPCL is implementation\n     \
    \   dependent.  However, the mechanism by which two bundle nodes\n        exchange\
    \ and negotiate the values to be used for a given session\n        is described\
    \ in Section 4.2.\n   Transmission --  Transmission refers to the procedures and\
    \ mechanisms\n        (described below) for conveyance of a bundle from one node\
    \ to\n        another.\n"
- title: 3.  General Protocol Description
  contents:
  - "3.  General Protocol Description\n   The service of this protocol is the transmission\
    \ of DTN bundles over\n   TCP.  This document specifies the encapsulation of bundles,\n\
    \   procedures for TCP setup and teardown, and a set of messages and node\n  \
    \ requirements.  The general operation of the protocol is as follows.\n   First,\
    \ one node establishes a TCPCL connection to the other by\n   initiating a TCP\
    \ connection.  After setup of the TCP connection is\n   complete, an initial contact\
    \ header is exchanged in both directions\n   to set parameters of the TCPCL connection\
    \ and exchange a singleton\n   endpoint identifier for each node (not the singleton\
    \ Endpoint\n   Identifier (EID) of any application running on the node) to denote\n\
    \   the bundle-layer identity of each DTN node.  This is used to assist\n   in\
    \ routing and forwarding messages, e.g., to prevent loops.\n   Once the TCPCL\
    \ connection is established and configured in this way,\n   bundles can be transmitted\
    \ in either direction.  Each bundle is\n   transmitted in one or more logical\
    \ segments of formatted bundle data.\n   Each logical data segment consists of\
    \ a DATA_SEGMENT message header,\n   a Self-Delimiting Numeric Value (SDNV) as\
    \ defined in [RFC5050] (see\n   also [RFC6256]) containing the length of the segment,\
    \ and finally the\n   byte range of the bundle data.  The choice of the length\
    \ to use for\n   segments is an implementation matter.  The first segment for\
    \ a bundle\n   must set the 'start' flag, and the last one must set the 'end'\
    \ flag\n   in the DATA_SEGMENT message header.\n   If multiple bundles are transmitted\
    \ on a single TCPCL connection,\n   they MUST be transmitted consecutively.  Interleaving\
    \ data segments\n   from different bundles is not allowed.  Bundle interleaving\
    \ can be\n   accomplished by fragmentation at the BP layer.\n   An optional feature\
    \ of the protocol is for the receiving node to send\n   acknowledgments as bundle\
    \ data segments arrive (ACK_SEGMENT).  The\n   rationale behind these acknowledgments\
    \ is to enable the sender node\n   to determine how much of the bundle has been\
    \ received, so that in\n   case the connection is interrupted, it can perform\
    \ reactive\n   fragmentation to avoid re-sending the already transmitted part\
    \ of the\n   bundle.\n   When acknowledgments are enabled, then for each data\
    \ segment that is\n   received, the receiving node sends an ACK_SEGMENT code followed\
    \ by an\n   SDNV containing the cumulative length of the bundle that has been\n\
    \   received.  The sending node may transmit multiple DATA_SEGMENT\n   messages\
    \ without necessarily waiting for the corresponding\n   ACK_SEGMENT responses.\
    \  This enables pipelining of messages on a\n   channel.  In addition, there is\
    \ no explicit flow control on the TCPCL\n   layer.\n   Another optional feature\
    \ is that a receiver may interrupt the\n   transmission of a bundle at any point\
    \ in time by replying with a\n   REFUSE_BUNDLE message, which causes the sender\
    \ to stop transmission\n   of the current bundle, after completing transmission\
    \ of a partially\n   sent data segment.  Note: This enables a cross-layer optimization\
    \ in\n   that it allows a receiver that detects that it already has received a\n\
    \   certain bundle to interrupt transmission as early as possible and\n   thus\
    \ save transmission capacity for other bundles.\n   For connections that are idle,\
    \ a KEEPALIVE message may optionally be\n   sent at a negotiated interval.  This\
    \ is used to convey liveness\n   information.\n   Finally, before connections\
    \ close, a SHUTDOWN message is sent on the\n   channel.  After sending a SHUTDOWN\
    \ message, the sender of this\n   message may send further acknowledgments (ACK_SEGMENT\
    \ or\n   REFUSE_BUNDLE) but no further data messages (DATA_SEGMENT).  A\n   SHUTDOWN\
    \ message may also be used to refuse a connection setup by a\n   peer.\n"
- title: 3.1.  Bidirectional Use of TCP Connection
  contents:
  - "3.1.  Bidirectional Use of TCP Connection\n   There are specific messages for\
    \ sending and receiving operations (in\n   addition to connection setup/teardown).\
    \  TCPCL is symmetric, i.e.,\n   both sides can start sending data segments in\
    \ a connection, and one\n   side's bundle transfer does not have to complete before\
    \ the other\n   side can start sending data segments on its own.  Hence, the protocol\n\
    \   allows for a bi-directional mode of communication.\n   Note that in the case\
    \ of concurrent bidirectional transmission,\n   acknowledgment segments may be\
    \ interleaved with data segments.\n"
- title: 3.2.  Example Message Exchange
  contents:
  - "3.2.  Example Message Exchange\n   The following figure visually depicts the\
    \ protocol exchange for a\n   simple session, showing the connection establishment\
    \ and the\n   transmission of a single bundle split into three data segments (of\n\
    \   lengths L1, L2, and L3) from Node A to Node B.\n   Note that the sending node\
    \ may transmit multiple DATA_SEGMENT\n   messages without necessarily waiting\
    \ for the corresponding\n   ACK_SEGMENT responses.  This enables pipelining of\
    \ messages on a\n   channel.  Although this example only demonstrates a single\
    \ bundle\n   transmission, it is also possible to pipeline multiple DATA_SEGMENT\n\
    \   messages for different bundles without necessarily waiting for\n   ACK_SEGMENT\
    \ messages to be returned for each one.  However,\n   interleaving data segments\
    \ from different bundles is not allowed.\n   No errors or rejections are shown\
    \ in this example.\n                  Node A                              Node\
    \ B\n                  ======                              ======\n        +-------------------------+\
    \         +-------------------------+\n        |     Contact Header      | ->\
    \   <- |     Contact Header      |\n        +-------------------------+      \
    \   +-------------------------+\n        +-------------------------+\n       \
    \ |   DATA_SEGMENT (start)  | ->\n        |    SDNV length [L1]     | ->\n   \
    \     |  Bundle Data 0..(L1-1)  | ->\n        +-------------------------+\n  \
    \      +-------------------------+         +-------------------------+\n     \
    \   |     DATA_SEGMENT        | ->   <- |       ACK_SEGMENT       |\n        |\
    \    SDNV length [L2]     | ->   <- |     SDNV length [L1]    |\n        |Bundle\
    \ Data L1..(L1+L2-1)| ->      +-------------------------+\n        +-------------------------+\n\
    \        +-------------------------+         +-------------------------+\n   \
    \     |    DATA_SEGMENT (end)   | ->   <- |       ACK_SEGMENT       |\n      \
    \  |     SDNV length [L3]    | ->   <- |   SDNV length [L1+L2]   |\n        |Bundle\
    \ Data              | ->      +-------------------------+\n        |    (L1+L2)..(L1+L2+L3-1)|\n\
    \        +-------------------------+\n                                       \
    \     +-------------------------+\n                                         <-\
    \ |       ACK_SEGMENT       |\n                                         <- | \
    \ SDNV length [L1+L2+L3] |\n                                            +-------------------------+\n\
    \        +-------------------------+         +-------------------------+\n   \
    \     |       SHUTDOWN          | ->   <- |         SHUTDOWN        |\n      \
    \  +-------------------------+         +-------------------------+\n   Figure\
    \ 2: A Simple Visual Example of the Flow of Protocol Messages on\n           \
    \  a Single TCP Session between Two Nodes (A and B)\n"
- title: 4.  Connection Establishment
  contents:
  - "4.  Connection Establishment\n   For bundle transmissions to occur using the\
    \ TCPCL, a TCPCL connection\n   must first be established between communicating\
    \ nodes.  It is up to\n   the implementation to decide how and when connection\
    \ setup is\n   triggered.  For example, some connections may be opened proactively\n\
    \   and maintained for as long as is possible given the network\n   conditions,\
    \ while other connections may be opened only when there is\n   a bundle that is\
    \ queued for transmission and the routing algorithm\n   selects a certain next-hop\
    \ node.\n   To establish a TCPCL connection, a node must first establish a TCP\n\
    \   connection with the intended peer node, typically by using the\n   services\
    \ provided by the operating system.  Port number 4556 has been\n   assigned by\
    \ IANA as the well-known port number for the TCP\n   convergence layer.  Other\
    \ port numbers MAY be used per local\n   configuration.  Determining a peer's\
    \ port number (if different from\n   the well-known TCPCL port) is up to the implementation.\n\
    \   If the node is unable to establish a TCP connection for any reason,\n   then\
    \ it is an implementation matter to determine how to handle the\n   connection\
    \ failure.  A node MAY decide to re-attempt to establish the\n   connection. \
    \ If it does so, it MUST NOT overwhelm its target with\n   repeated connection\
    \ attempts.  Therefore, the node MUST retry the\n   connection setup only after\
    \ some delay (a 1-second minimum is\n   RECOMMENDED), and it SHOULD use a (binary)\
    \ exponential backoff\n   mechanism to increase this delay in case of repeated\
    \ failures.  In\n   case a SHUTDOWN message specifying a reconnection delay is\
    \ received,\n   that delay is used as the initial delay.  The default initial\
    \ delay\n   SHOULD be at least 1 second but SHOULD be configurable since it will\n\
    \   be application and network type dependent.\n   The node MAY declare failure\
    \ after one or more connection attempts\n   and MAY attempt to find an alternate\
    \ route for bundle data.  Such\n   decisions are up to the higher layer (i.e.,\
    \ the BP).\n   Once a TCP connection is established, each node MUST immediately\n\
    \   transmit a contact header over the TCP connection.  The format of the\n  \
    \ contact header is described in Section 4.1.\n   Upon receipt of the contact\
    \ header, both nodes perform the validation\n   and negotiation procedures defined\
    \ in Section 4.2\n   After receiving the contact header from the other node, either\
    \ node\n   MAY also refuse the connection by sending a SHUTDOWN message.  If\n\
    \   connection setup is refused, a reason MUST be included in the\n   SHUTDOWN\
    \ message.\n"
- title: 4.1.  Contact Header
  contents:
  - "4.1.  Contact Header\n   Once a TCP connection is established, both parties exchange\
    \ a contact\n   header.  This section describes the format of the contact header\
    \ and\n   the meaning of its fields.\n   The format for the Contact Header is\
    \ as follows:\n                        1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2\
    \ 3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n \
    \  +---------------+---------------+---------------+---------------+\n   |   \
    \                       magic='dtn!'                         |\n   +---------------+---------------+---------------+---------------+\n\
    \   |     version   |     flags     |      keepalive_interval       |\n   +---------------+---------------+---------------+---------------+\n\
    \   |                     local EID length (SDNV)                   |\n   +---------------+---------------+---------------+---------------+\n\
    \   |                                                               |\n   +  \
    \                    local EID (variable)                     +\n   |        \
    \                                                       |\n   +---------------+---------------+---------------+---------------+\n\
    \                      Figure 3: Contact Header Format\n   The fields of the contact\
    \ header are:\n   magic:  A four-byte field that always contains the byte sequence\
    \ 0x64\n        0x74 0x6e 0x21, i.e., the text string \"dtn!\" in US-ASCII.\n\
    \   version:  A one-byte field value containing the value 3 (current\n       \
    \ version of the protocol).\n   flags:  A one-byte field containing optional connection\
    \ flags.  The\n        first four bits are unused and MUST be set to zero upon\n\
    \        transmission and MUST be ignored upon reception.  The last four\n   \
    \     bits are interpreted as shown in Table 1 below.\n   keepalive_interval:\
    \  A two-byte integer field containing the number\n        of seconds between\
    \ exchanges of KEEPALIVE messages on the\n        connection (see Section 5.6).\
    \  This value is in network byte\n        order, as are all other multi-byte fields\
    \ described in this\n        protocol.\n   local EID length:  A variable-length\
    \ SDNV field containing the length\n        of the endpoint identifier (EID) for\
    \ some singleton endpoint in\n        which the sending node is a member.  A four-byte\
    \ SDNV is\n        depicted for clarity of the figure.\n   local EID:  A byte\
    \ string containing the EID of some singleton\n        endpoint in which the sending\
    \ node is a member, in the canonical\n        format of <scheme name>:<scheme-specific\
    \ part>.  An eight-byte\n        EID is shown for clarity of the figure.\n   +----------+--------------------------------------------------------+\n\
    \   |  Value   | Meaning                                                |\n  \
    \ +----------+--------------------------------------------------------+\n   |\
    \ 00000001 | Request acknowledgment of bundle segments.             |\n   | 00000010\
    \ | Request enabling of reactive fragmentation.            |\n   | 00000100 |\
    \ Indicate support for bundle refusal.  This flag MUST   |\n   |          | NOT\
    \ be set to '1' unless support for acknowledgments   |\n   |          | is also\
    \ indicated.                                     |\n   | 00001000 | Request sending\
    \ of LENGTH messages.                    |\n   +----------+--------------------------------------------------------+\n\
    \                       Table 1: Contact Header Flags\n   The manner in which\
    \ values are configured and chosen for the various\n   flags and parameters in\
    \ the contact header is implementation\n   dependent.\n"
- title: 4.2.  Validation and Parameter Negotiation
  contents:
  - "4.2.  Validation and Parameter Negotiation\n   Upon reception of the contact\
    \ header, each node follows the following\n   procedures to ensure the validity\
    \ of the TCPCL connection and to\n   negotiate values for the connection parameters.\n\
    \   If the magic string is not present or is not valid, the connection\n   MUST\
    \ be terminated.  The intent of the magic string is to provide\n   some protection\
    \ against an inadvertent TCP connection by a different\n   protocol than the one\
    \ described in this document.  To prevent a flood\n   of repeated connections\
    \ from a misconfigured application, a node MAY\n   elect to hold an invalid connection\
    \ open and idle for some time\n   before closing it.\n   If a node receives a\
    \ contact header containing a version that is\n   greater than the current version\
    \ of the protocol that the node\n   implements, then the node SHOULD interpret\
    \ all fields and messages as\n   it would normally.  If a node receives a contact\
    \ header with a\n   version that is lower than the version of the protocol that\
    \ the node\n   implements, the node may either terminate the connection due to\
    \ the\n   version mismatch or may adapt its operation to conform to the older\n\
    \   version of the protocol.  This decision is an implementation matter.\n   A\
    \ node calculates the parameters for a TCPCL connection by\n   negotiating the\
    \ values from its own preferences (conveyed by the\n   contact header it sent)\
    \ with the preferences of the peer node\n   (expressed in the contact header that\
    \ it received).  This negotiation\n   MUST proceed in the following manner:\n\
    \   o  The parameter for requesting acknowledgment of bundle segments is\n   \
    \   set to true iff the corresponding flag is set in both contact\n      headers.\n\
    \   o  The parameter for enabling reactive fragmentation is set to true\n    \
    \  iff the corresponding flag is set in both contact headers.\n   o  The bundle\
    \ refusal capability is set to true if the corresponding\n      flag is set in\
    \ both contact headers and if segment acknowledgment\n      has been enabled.\n\
    \   o  The keepalive_interval parameter is set to the minimum value from\n   \
    \   both contact headers.  If one or both contact headers contains the\n     \
    \ value zero, then the keepalive feature (described in Section 5.6)\n      is\
    \ disabled.\n   o  The flag requesting sending of LENGTH messages is handled as\n\
    \      described in Section 5.5.\n   Once this process of parameter negotiation\
    \ is completed, the protocol\n   defines no additional mechanism to change the\
    \ parameters of an\n   established connection; to effect such a change, the connection\
    \ MUST\n   be terminated and a new connection established.\n"
- title: 5.  Established Connection Operation
  contents:
  - "5.  Established Connection Operation\n   This section describes the protocol\
    \ operation for the duration of an\n   established connection, including the mechanisms\
    \ for transmitting\n   bundles over the connection.\n"
- title: 5.1.  Message Type Codes
  contents:
  - "5.1.  Message Type Codes\n   After the initial exchange of a contact header,\
    \ all messages\n   transmitted over the connection are identified by a one-byte\
    \ header\n   with the following structure:\n                             0 1 2\
    \ 3 4 5 6 7\n                            +-+-+-+-+-+-+-+-+\n                 \
    \           | type  | flags |\n                            +-+-+-+-+-+-+-+-+\n\
    \              Figure 4: Format of the One-Byte Message Header\n   type:  Indicates\
    \ the type of the message as per Table 2 below\n   flags:  Optional flags defined\
    \ based on message type.\n   The types and values for the message type code are\
    \ as follows.\n   +----------------+---------+----------------------------------------+\n\
    \   |      Type      | Code    | Description                            |\n  \
    \ +----------------+---------+----------------------------------------+\n   |\
    \                | 0x0     | Reserved.                              |\n   |  \
    \              |         |                                        |\n   |  DATA_SEGMENT\
    \  | 0x1     | Indicates the transmission of a        |\n   |                |\
    \         | segment of bundle data, as described   |\n   |                |  \
    \       | in Section 5.2.                        |\n   |                |    \
    \     |                                        |\n   |  ACK_SEGMENT   | 0x2  \
    \   | Acknowledges reception of a data       |\n   |                |        \
    \ | segment, as described in Section 5.3   |\n   |                |         |\
    \                                        |\n   | REFUSE_BUNDLE  | 0x3     | Indicates\
    \ that the transmission of the |\n   |                |         | current bundle\
    \ shall be stopped, as    |\n   |                |         | described in Section\
    \ 5.4.              |\n   |                |         |                       \
    \                 |\n   |   KEEPALIVE    | 0x4     | KEEPALIVE message for the\
    \ connection,  |\n   |                |         | as described in Section 5.6.\
    \           |\n   |                |         |                               \
    \         |\n   |    SHUTDOWN    | 0x5     | Indicates that one of the nodes \
    \       |\n   |                |         | participating in the connection wishes\
    \ |\n   |                |         | to cleanly terminate the connection,   |\n\
    \   |                |         | as described in Section 6.             |\n  \
    \ |                |         |                                        |\n   |\
    \     LENGTH     | 0x6     | Contains the length (in bytes) of the  |\n   |  \
    \              |         | next bundle, as described in Section   |\n   |    \
    \            |         | 5.5.                                   |\n   |      \
    \          |         |                                        |\n   |        \
    \        | 0x7-0xf | Unassigned.                            |\n   |          \
    \      |         |                                        |\n   +----------------+---------+----------------------------------------+\n\
    \                       Table 2: TCPCL Message Types\n"
- title: 5.2.  Bundle Data Transmission (DATA_SEGMENT)
  contents:
  - "5.2.  Bundle Data Transmission (DATA_SEGMENT)\n   Each bundle is transmitted\
    \ in one or more data segments.  The format\n   of a DATA_SEGMENT message follows:\n\
    \                           1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n    \
    \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |  0x1  |0|0|S|E|   length ...    |  contents....               |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \           Figure 5: Format of DATA_SEGMENT Messages\n   The type portion of\
    \ the message header contains the value 0x1.\n   The flags portion of the message\
    \ header byte contains two optional\n   values in the two low-order bits, denoted\
    \ 'S' and 'E' above.  The 'S'\n   bit MUST be set to one if it precedes the transmission\
    \ of the first\n   segment of a new bundle.  The 'E' bit MUST be set to one when\n\
    \   transmitting the last segment of a bundle.\n   Following the message header,\
    \ the length field is an SDNV containing\n   the number of bytes of bundle data\
    \ that are transmitted in this\n   segment.  Following this length is the actual\
    \ data contents.\n   Determining the size of the segment is an implementation\
    \ matter.  In\n   particular, a node may, based on local policy or configuration,\
    \ only\n   ever transmit bundle data in a single segment, in which case both the\n\
    \   'S' and 'E' bits MUST be set to one.\n   In the Bundle Protocol specification\
    \ [RFC5050], a single bundle\n   comprises a primary bundle block, a payload block,\
    \ and zero or more\n   additional bundle blocks.  The relationship between the\
    \ protocol\n   blocks and the convergence-layer segments is an implementation-\n\
    \   specific decision.  In particular, a segment MAY contain more than\n   one\
    \ protocol block; alternatively, a single protocol block (such as\n   the payload)\
    \ MAY be split into multiple segments.\n   However, a single segment MUST NOT\
    \ contain data of more than a single\n   bundle.\n   Once a transmission of a\
    \ bundle has commenced, the node MUST only\n   send segments containing sequential\
    \ portions of that bundle until it\n   sends a segment with the 'E' bit set.\n"
- title: 5.3.  Bundle Acknowledgments (ACK_SEGMENT)
  contents:
  - "5.3.  Bundle Acknowledgments (ACK_SEGMENT)\n   Although the TCP transport provides\
    \ reliable transfer of data between\n   transport peers, the typical BSD sockets\
    \ interface provides no means\n   to inform a sending application of when the\
    \ receiving application has\n   processed some amount of transmitted data.  Thus,\
    \ after transmitting\n   some data, a Bundle Protocol agent needs an additional\
    \ mechanism to\n   determine whether the receiving agent has successfully received\
    \ the\n   segment.\n   To this end, the TCPCL protocol offers an optional feature\
    \ whereby a\n   receiving node transmits acknowledgments of reception of data\n\
    \   segments.  This feature is enabled if, and only if, during the\n   exchange\
    \ of contact headers, both parties set the flag to indicate\n   that segment acknowledgments\
    \ are enabled (see Section 4.1).  If so,\n   then the receiver MUST transmit a\
    \ bundle acknowledgment message when\n   it successfully receives each data segment.\n\
    \   The format of a bundle acknowledgment is as follows:\n                   \
    \        1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n       0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |  0x2  |0|0|0|0|   acknowledged length ...                     |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \           Figure 6: Format of ACK_SEGMENT Messages\n   To transmit an acknowledgment,\
    \ a node first transmits a message\n   header with the ACK_SEGMENT type code and\
    \ all flags set to zero, then\n   transmits an SDNV containing the cumulative\
    \ length in bytes of the\n   received segment(s) of the current bundle.  The length\
    \ MUST fall on a\n   segment boundary.  That is, only full segments can be acknowledged.\n\
    \   For example, suppose the sending node transmits four segments of\n   bundle\
    \ data with lengths 100, 200, 500, and 1000, respectively.\n   After receiving\
    \ the first segment, the node sends an acknowledgment\n   of length 100.  After\
    \ the second segment is received, the node sends\n   an acknowledgment of length\
    \ 300.  The third and fourth\n   acknowledgments are of length 800 and 1800, respectively.\n"
- title: 5.4.  Bundle Refusal (REFUSE_BUNDLE)
  contents:
  - "5.4.  Bundle Refusal (REFUSE_BUNDLE)\n   As bundles may be large, the TCPCL supports\
    \ an optional mechanisms by\n   which a receiving node may indicate to the sender\
    \ that it does not\n   want to receive the corresponding bundle.\n   To do so,\
    \ upon receiving a DATA_SEGMENT message, the node MAY\n   transmit a REFUSE_BUNDLE\
    \ message.  As data segments and\n   acknowledgments may cross on the wire, the\
    \ bundle that is being\n   refused is implicitly identified by the sequence in\
    \ which\n   acknowledgements and refusals are received.\n   The format of the\
    \ REFUSE_BUNDLE message is as follows:\n                               0 1 2 3\
    \ 4 5 6 7\n                              +-+-+-+-+-+-+-+-+\n                 \
    \             |  0x3  | RCode |\n                              +-+-+-+-+-+-+-+-+\n\
    \                Figure 7: Format of REFUSE_BUNDLE Messages\n   The RCode field,\
    \ which stands for \"reason code\", contains a value\n   indicating why the bundle\
    \ was refused.  The following table contains\n   semantics for some values.  Other\
    \ values may be registered with IANA,\n   as defined in Section 8.\n   +---------+---------------------------------------------------------+\n\
    \   |  RCode  | Semantics                                               |\n  \
    \ +---------+---------------------------------------------------------+\n   |\
    \   0x0   | Reason for refusal is unknown or not specified.         |\n   |  \
    \ 0x1   | The receiver now has the complete bundle.  The sender   |\n   |    \
    \     | may now consider the bundle as completely received.     |\n   |   0x2\
    \   | The receiver's resources are exhausted.  The sender     |\n   |        \
    \ | SHOULD apply reactive bundle fragmentation before       |\n   |         |\
    \ retrying.                                               |\n   |   0x3   | The\
    \ receiver has encountered a problem that requires    |\n   |         | the bundle\
    \ to be retransmitted in its entirety.         |\n   | 0x4-0x7 | Unassigned. \
    \                                            |\n   | 0x8-0xf | Reserved for future\
    \ usage.                              |\n   +---------+---------------------------------------------------------+\n\
    \                    Table 3: REFUSE_BUNDLE Reason Codes\n   The receiver MUST,\
    \ for each bundle preceding the one to be refused,\n   have either acknowledged\
    \ all DATA_SEGMENTs or refused the bundle.\n   This allows the sender to identify\
    \ the bundles accepted and refused\n   by means of a simple FIFO list of segments\
    \ and acknowledgments.\n   The bundle refusal MAY be sent before the entire data\
    \ segment is\n   received.  If a sender receives a REFUSE_BUNDLE message, the\
    \ sender\n   MUST complete the transmission of any partially sent DATA_SEGMENT\n\
    \   message (so that the receiver stays in sync).  The sender MUST NOT\n   commence\
    \ transmission of any further segments of the rejected bundle\n   subsequently.\
    \  Note, however, that this requirement does not ensure\n   that a node will not\
    \ receive another DATA_SEGMENT for the same bundle\n   after transmitting a REFUSE_BUNDLE\
    \ message since messages may cross\n   on the wire; if this happens, subsequent\
    \ segments of the bundle\n   SHOULD also be refused with a REFUSE_BUNDLE message.\n\
    \   Note: If a bundle transmission is aborted in this way, the receiver\n   may\
    \ not receive a segment with the 'E' flag set to '1' for the\n   aborted bundle.\
    \  The beginning of the next bundle is identified by\n   the 'S' bit set to '1',\
    \ indicating the start of a new bundle.\n"
- title: 5.5.  Bundle Length (LENGTH)
  contents:
  - "5.5.  Bundle Length (LENGTH)\n   The LENGTH message contains the total length,\
    \ in bytes, of the next\n   bundle, formatted as an SDNV.  Its purpose is to allow\
    \ nodes to\n   preemptively refuse bundles that would exceed their resources.\
    \  It is\n   an optimization.\n   The format of the LENGTH message is as follows:\n\
    \                           1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n    \
    \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |  0x6  |0|0|0|0|     total bundle length ...                   |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \              Figure 8: Format of LENGTH Messages\n   LENGTH messages MUST NOT\
    \ be sent unless the corresponding flag bit is\n   set in the contact header.\
    \  If the flag bit is set, LENGTH messages\n   MAY be sent at the sender's discretion.\
    \  LENGTH messages MUST NOT be\n   sent unless the next DATA_SEGMENT message has\
    \ the 'S' bit set to \"1\"\n   (i.e., just before the start of a new bundle).\n\
    \   A receiver MAY send a BUNDLE_REFUSE message as soon as it receives a\n   LENGTH\
    \ message without waiting for the next DATA_SEGMENT message.\n   The sender MUST\
    \ be prepared for this and MUST associate the refusal\n   with the right bundle.\n"
- title: 5.6.  KEEPALIVE Feature (KEEPALIVE)
  contents:
  - "5.6.  KEEPALIVE Feature (KEEPALIVE)\n   The protocol includes a provision for\
    \ transmission of KEEPALIVE\n   messages over the TCP connection to help determine\
    \ if the connection\n   has been disrupted.\n   As described in Section 4.1, one\
    \ of the parameters in the contact\n   header is the keepalive_interval.  Both\
    \ sides populate this field\n   with their requested intervals (in seconds) between\
    \ KEEPALIVE\n   messages.\n   The format of a KEEPALIVE message is a one-byte\
    \ message type code of\n   KEEPALIVE (as described in Table 2) with no additional\
    \ data.  Both\n   sides SHOULD send a KEEPALIVE message whenever the negotiated\n\
    \   interval has elapsed with no transmission of any message (KEEPALIVE\n   or\
    \ other).\n   If no message (KEEPALIVE or other) has been received for at least\n\
    \   twice the keepalive_interval, then either party MAY terminate the\n   session\
    \ by transmitting a one-byte SHUTDOWN message (as described in\n   Table 2) and\
    \ by closing the TCP connection.\n   Note: The keepalive_interval should not be\
    \ chosen too short as TCP\n   retransmissions may occur in case of packet loss.\
    \  Those will have to\n   be triggered by a timeout (TCP retransmission timeout\
    \ (RTO)), which\n   is dependent on the measured RTT for the TCP connection so\
    \ that\n   KEEPALIVE messages may experience noticeable latency.\n"
- title: 6.  Connection Termination
  contents:
  - "6.  Connection Termination\n   This section describes the procedures for ending\
    \ a TCPCL connection.\n"
- title: 6.1.  Shutdown Message (SHUTDOWN)
  contents:
  - "6.1.  Shutdown Message (SHUTDOWN)\n   To cleanly shut down a connection, a SHUTDOWN\
    \ message MUST be\n   transmitted by either node at any point following complete\n\
    \   transmission of any other message.  In case acknowledgments have been\n  \
    \ negotiated, a node SHOULD acknowledge all received data segments\n   first and\
    \ then shut down the connection.\n   The format of the SHUTDOWN message is as\
    \ follows:\n                           1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2\
    \ 3 3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   \
    \   |  0x5  |0|0|R|D| reason (opt)  | reconnection delay (opt)      |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \               Figure 9: Format of Bundle SHUTDOWN Messages\n   It is possible\
    \ for a node to convey additional information regarding\n   the reason for connection\
    \ termination.  To do so, the node MUST set\n   the 'R' bit in the message header\
    \ flags and transmit a one-byte\n   reason code immediately following the message\
    \ header.  The specified\n   values of the reason code are:\n   +-----------+------------------+------------------------------------+\n\
    \   |    Code   | Meaning          | Description                        |\n  \
    \ +-----------+------------------+------------------------------------+\n   |\
    \    0x00   | Idle timeout     | The connection is being closed due |\n   |  \
    \         |                  | to idleness.                       |\n   |    \
    \       |                  |                                    |\n   |    0x01\
    \   | Version mismatch | The node cannot conform to the     |\n   |          \
    \ |                  | specified TCPCL protocol version.  |\n   |           |\
    \                  |                                    |\n   |    0x02   | Busy\
    \             | The node is too busy to handle the |\n   |           |       \
    \           | current connection.                |\n   |           |         \
    \         |                                    |\n   | 0x03-0xff |           \
    \       | Unassigned.                        |\n   +-----------+------------------+------------------------------------+\n\
    \                      Table 4: SHUTDOWN Reason Codes\n   It is also possible\
    \ to convey a requested reconnection delay to\n   indicate how long the other\
    \ node must wait before attempting\n   connection re-establishment.  To do so,\
    \ the node sets the 'D' bit in\n   the message header flags and then transmits\
    \ an SDNV specifying the\n   requested delay, in seconds, following the message\
    \ header (and\n   optionally, the SHUTDOWN reason code).  The value 0 SHALL be\n\
    \   interpreted as an infinite delay, i.e., that the connecting node MUST\n  \
    \ NOT re-establish the connection.  In contrast, if the node does not\n   wish\
    \ to request a delay, it SHOULD omit the reconnection delay field\n   (and set\
    \ the 'D' bit to zero).  Note that in the figure above, the\n   reconnection delay\
    \ SDNV is represented as a two-byte field for\n   convenience.\n   A connection\
    \ shutdown MAY occur immediately after TCP connection\n   establishment or reception\
    \ of a contact header (and prior to any\n   further data exchange).  This may,\
    \ for example, be used to notify\n   that the node is currently not able or willing\
    \ to communicate.\n   However, a node MUST always send the contact header to its\
    \ peer\n   before sending a SHUTDOWN message.\n   If either node terminates a\
    \ connection prematurely in this manner, it\n   SHOULD send a SHUTDOWN message\
    \ and MUST indicate a reason code unless\n   the incoming connection did not include\
    \ the magic string.  If a node\n   does not want its peer to reopen the connection\
    \ immediately, it\n   SHOULD set the 'D' bit in the flags and include a reconnection\
    \ delay\n   to indicate when the peer is allowed to attempt another connection\n\
    \   setup.\n   If a connection is to be terminated before another protocol message\n\
    \   has completed, then the node MUST NOT transmit the SHUTDOWN message\n   but\
    \ still SHOULD close the TCP connection.  In particular, if the\n   connection\
    \ is to be closed (for whatever reason) while a node is in\n   the process of\
    \ transmitting a bundle data segment, the receiving node\n   is still expecting\
    \ segment data and might erroneously interpret the\n   SHUTDOWN message to be\
    \ part of the data segment.\n"
- title: 6.2.  Idle Connection Shutdown
  contents:
  - "6.2.  Idle Connection Shutdown\n   The protocol includes a provision for clean\
    \ shutdown of idle TCP\n   connections.  Determining the length of time to wait\
    \ before closing\n   idle connections, if they are to be closed at all, is an\n\
    \   implementation and configuration matter.\n   If there is a configured time\
    \ to close idle links and if no bundle\n   data (other than KEEPALIVE messages)\
    \ has been received for at least\n   that amount of time, then either node MAY\
    \ terminate the connection by\n   transmitting a SHUTDOWN message indicating the\
    \ reason code of 'Idle\n   timeout' (as described in Table 4).  After receiving\
    \ a SHUTDOWN\n   message in response, both sides may close the TCP connection.\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   One security consideration for this protocol\
    \ relates to the fact that\n   nodes present their endpoint identifier as part\
    \ of the connection\n   header exchange.  It would be possible for a node to fake\
    \ this value\n   and present the identity of a singleton endpoint in which the\
    \ node is\n   not a member, essentially masquerading as another DTN node.  If\
    \ this\n   identifier is used without further verification as a means to\n   determine\
    \ which bundles are transmitted over the connection, then the\n   node that has\
    \ falsified its identity may be able to obtain bundles\n   that it should not\
    \ have.  Therefore, a node SHALL NOT use the\n   endpoint identifier conveyed\
    \ in the TCPCL connection message to\n   derive a peer node's identity unless\
    \ it can ascertain it via other\n   means.\n   These concerns may be mitigated\
    \ through the use of the Bundle\n   Security Protocol [RFC6257].  In particular,\
    \ the Bundle\n   Authentication Block defines mechanism for secure exchange of\
    \ bundles\n   between DTN nodes.  Thus, an implementation could delay trusting\
    \ the\n   presented endpoint identifier until the node can securely validate\n\
    \   that its peer is in fact the only member of the given singleton\n   endpoint.\n\
    \   In general, TCPCL does not provide any security services.  The\n   mechanisms\
    \ defined in [RFC6257] are to be used instead.\n   Nothing in TCPCL prevents the\
    \ use of the Transport Layer Security\n   (TLS) protocol [RFC5246] to secure a\
    \ connection.\n   Another consideration for this protocol relates to denial-of-service\n\
    \   attacks.  A node may send a large amount of data over a TCP\n   connection,\
    \ requiring the receiving node to handle the data, attempt\n   to stop the flood\
    \ of data by sending a REFUSE_BUNDLE message, or\n   forcibly terminate the connection.\
    \  This burden could cause denial of\n   service on other, well-behaving connections.\
    \  There is also nothing\n   to prevent a malicious node from continually establishing\
    \ connections\n   and repeatedly trying to send copious amounts of bundle data.\
    \  A\n   listening node MAY take countermeasures such as ignoring TCP SYN\n  \
    \ messages, closing TCP connections as soon as they are established,\n   waiting\
    \ before sending the contact header, sending a SHUTDOWN message\n   quickly or\
    \ with a delay, etc.\n"
- title: 8.  IANA Considerations
  contents:
  - "8.  IANA Considerations\n   In this section, registration procedures are as defined\
    \ in [RFC5226].\n"
- title: 8.1.  Port Number
  contents:
  - "8.1.  Port Number\n   Port number 4556 has been assigned as the default port\
    \ for the TCP\n   convergence layer.\n   Service Name:  dtn-bundle\n   Transport\
    \ Protocol(s):  TCP\n   Assignee:  Simon Perreault <simon@per.reau.lt>\n   Contact:\
    \  Simon Perreault <simon@per.reau.lt>\n   Description:  DTN Bundle TCP CL Protocol\n\
    \   Reference:  [RFC7242]\n   Port Number:  4556\n"
- title: 8.2.  Protocol Versions
  contents:
  - "8.2.  Protocol Versions\n   IANA has created, under the \"Bundle Protocol\" registry,\
    \ a sub-\n   registry titled \"Bundle Protocol TCP Convergence-Layer Version\n\
    \   Numbers\" and initialized it with the following:\n                    +-------+-------------+-----------+\n\
    \                    | Value | Description | Reference |\n                   \
    \ +-------+-------------+-----------+\n                    |   0   | Reserved\
    \    | [RFC7242] |\n                    |   1   | Reserved    | [RFC7242] |\n\
    \                    |   2   | Reserved    | [RFC7242] |\n                   \
    \ |   3   | TCPCL       | [RFC7242] |\n                    | 4-255 | Unassigned\
    \  | [RFC7242] |\n                    +-------+-------------+-----------+\n  \
    \ The registration procedure is RFC Required.\n"
- title: 8.3.  Message Types
  contents:
  - "8.3.  Message Types\n   IANA has created, under the \"Bundle Protocol\" registry,\
    \ a sub-\n   registry titled \"Bundle Protocol TCP Convergence-Layer Message Types\"\
    \n   and initialized it with the contents of Table 2.  The registration\n   procedure\
    \ is RFC Required.\n"
- title: 8.4.  REFUSE_BUNDLE Reason Codes
  contents:
  - "8.4.  REFUSE_BUNDLE Reason Codes\n   IANA has created, under the \"Bundle Protocol\"\
    \ registry, a sub-\n   registry titled \"Bundle Protocol TCP Convergence-Layer\
    \ REFUSE_BUNDLE\n   Reason Codes\" and initialized it with the contents of Table\
    \ 3.  The\n   registration procedure is RFC Required.\n"
- title: 8.5.  SHUTDOWN Reason Codes
  contents:
  - "8.5.  SHUTDOWN Reason Codes\n   IANA has created, under the \"Bundle Protocol\"\
    \ registry, a sub-\n   registry titled \"Bundle Protocol TCP Convergence-Layer\
    \ SHUTDOWN\n   Reason Codes\" and initialized it with the contents of Table 4.\
    \  The\n   registration procedure is RFC Required.\n"
- title: 9.  Acknowledgments
  contents:
  - "9.  Acknowledgments\n   The authors would like to thank the following individuals\
    \ who have\n   participated in the drafting, review, and discussion of this memo:\n\
    \   Alex McMahon, Brenton Walker, Darren Long, Dirk Kutscher, Elwyn\n   Davies,\
    \ Jean-Philippe Dionne, Joseph Ishac, Keith Scott, Kevin Fall,\n   Lloyd Wood,\
    \ Marc Blanchet, Peter Lovell, Scott Burleigh, Stephen\n   Farrell, Vint Cerf,\
    \ and William Ivancic.\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March\
    \ 1997.\n   [RFC5050]  Scott, K. and S. Burleigh, \"Bundle Protocol\n        \
    \      Specification\", RFC 5050, November 2007.\n   [RFC5226]  Narten, T. and\
    \ H. Alvestrand, \"Guidelines for Writing an\n              IANA Considerations\
    \ Section in RFCs\", BCP 26, RFC 5226,\n              May 2008.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [DTNIMPL]  DTNRG, \"Delay-Tolerant Networking\
    \ Reference\n              Implementation\", <https://sites.google.com/site/\n\
    \              dtnresgroup/home/code>.\n   [RFC4838]  Cerf, V., Burleigh, S.,\
    \ Hooke, A., Torgerson, L., Durst,\n              R., Scott, K., Fall, K., and\
    \ H. Weiss, \"Delay-Tolerant\n              Networking Architecture\", RFC 4838,\
    \ April 2007.\n   [RFC5246]  Dierks, T. and E. Rescorla, \"The Transport Layer\
    \ Security\n              (TLS) Protocol Version 1.2\", RFC 5246, August 2008.\n\
    \   [RFC6256]  Eddy, W. and E. Davies, \"Using Self-Delimiting Numeric\n     \
    \         Values in Protocols\", RFC 6256, May 2011.\n   [RFC6257]  Symington,\
    \ S., Farrell, S., Weiss, H., and P. Lovell,\n              \"Bundle Security\
    \ Protocol Specification\", RFC 6257, May\n              2011.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Michael J. Demmer\n   University of California, Berkeley\n\
    \   Computer Science Division\n   445 Soda Hall\n   Berkeley, CA  94720-1776\n\
    \   US\n   EMail: demmer@cs.berkeley.edu\n   Joerg Ott\n   Aalto University\n\
    \   Department of Communications and Networking\n   PO Box 13000\n   AALTO  02015\n\
    \   Finland\n   EMail: jo@netlab.tkk.fi\n   Simon Perreault\n   Quebec, QC\n \
    \  Canada\n   EMail: simon@per.reau.lt\n"
