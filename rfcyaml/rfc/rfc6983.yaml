- title: __initial_text__
  contents:
  - ''
- title: Independent Submission                                R. van Brandenburg
  contents:
  - "Independent Submission                                R. van Brandenburg\n  \
    \              Models for HTTP-Adaptive-Streaming-Aware\n          Content Distribution\
    \ Network Interconnection (CDNI)\n"
- title: Abstract
  contents:
  - "Abstract\n   This document presents thoughts on the potential impact of supporting\n\
    \   HTTP Adaptive Streaming (HAS) technologies in Content Distribution\n   Network\
    \ Interconnection (CDNI) scenarios.  The intent is to present\n   the authors'\
    \ analysis of the CDNI-HAS problem space and discuss\n   different options put\
    \ forward by the authors (and by others during\n   informal discussions) on how\
    \ to deal with HAS in the context of CDNI.\n   This document has been used as\
    \ input information during the CDNI\n   working group process for making a decision\
    \ regarding support for\n   HAS.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This is a contribution to\
    \ the RFC Series, independently of any other\n   RFC stream.  The RFC Editor has\
    \ chosen to publish this document at\n   its discretion and makes no statement\
    \ about its value for\n   implementation or deployment.  Documents approved for\
    \ publication by\n   the RFC Editor are not a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc6983.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2013 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n\
    \      1.1. Terminology ................................................5\n  \
    \ 2. HTTP Adaptive Streaming Aspects Relevant to CDNI ................6\n    \
    \  2.1. Segmentation versus Fragmentation ..........................6\n      2.2.\
    \ Addressing Chunks ..........................................7\n           2.2.1.\
    \ Relative URLs .......................................8\n           2.2.2. Absolute\
    \ URLs with Redirection ......................9\n           2.2.3. Absolute URLs\
    \ without Redirection ..................10\n      2.3. Live Content versus VoD\
    \ Content ...........................11\n      2.4. Stream Splicing ...........................................12\n\
    \   3. Possible HAS Optimizations .....................................12\n  \
    \    3.1. File Management and Content Collections ...................13\n    \
    \       3.1.1. General Remarks ....................................13\n      \
    \     3.1.2. Candidate Approaches ...............................13\n        \
    \          3.1.2.1. Option 1.1: Do Nothing ....................13\n          \
    \        3.1.2.2. Option 1.2: Allow Single-File\n                           Storage\
    \ of Fragmented Content .............14\n                  3.1.2.3. Option 1.3:\
    \ Access Correlation Hint .......14\n           3.1.3. Recommendations ....................................15\n\
    \      3.2. Content Acquisition of Content Collections ................15\n  \
    \         3.2.1. General Remarks ....................................15\n    \
    \       3.2.2. Candidate Approaches ...............................16\n      \
    \            3.2.2.1. Option 2.1: No HAS Awareness ..............16\n        \
    \          3.2.2.2. Option 2.2: Allow Single-File\n                          \
    \ Acquisition of Fragmented Content .........17\n           3.2.3. Recommendations\
    \ ....................................17\n      3.3. Request Routing of HAS Content\
    \ ............................17\n           3.3.1. General Remarks ....................................17\n\
    \           3.3.2. Candidate Approaches ...............................18\n  \
    \                3.3.2.1. Option 3.1: No HAS Awareness ..............18\n    \
    \              3.3.2.2. Option 3.2: Manifest File Rewriting\n                \
    \           by uCDN ...................................20\n                  3.3.2.3.\
    \ Option 3.3: Two-Step Manifest File\n                           Rewriting .................................21\n\
    \           3.3.3. Recommendations ....................................22\n  \
    \    3.4. Logging ...................................................23\n    \
    \       3.4.1. General Remarks ....................................23\n      \
    \     3.4.2. Candidate Approaches ...............................24\n        \
    \          3.4.2.1. Option 4.1: Do Nothing ....................24\n          \
    \        3.4.2.2. Option 4.2: CDNI Metadata Content\n                        \
    \   Collection ID .............................26\n                  3.4.2.3.\
    \ Option 4.3: CDNI Logging Interface\n                           Compression ...............................28\n\
    \                  3.4.2.4. Option 4.4: Full HAS\n                           Awareness/Per-Session\
    \ Logs ................29\n           3.4.3. Recommendations ....................................30\n\
    \      3.5. URL Signing ...............................................32\n  \
    \         3.5.1. HAS Implications ...................................32\n    \
    \       3.5.2. CDNI Considerations ................................33\n      \
    \     3.5.3. Option 5.1: Do Nothing .............................34\n        \
    \   3.5.4. Option 5.2: Flexible URL Signing by CSP ............34\n          \
    \ 3.5.5. Option 5.3: Flexible URL Signing by uCDN ...........37\n           3.5.6.\
    \ Option 5.4: Authorization Group ID and HTTP\n                  Cookie .............................................37\n\
    \           3.5.7. Option 5.5: HAS Awareness with HTTP Cookie in CDN ..38\n  \
    \         3.5.8. Option 5.6: HAS Awareness with Manifest\n                  File\
    \ in CDN ........................................40\n           3.5.9. Recommendations\
    \ ....................................41\n      3.6. Content Purge .............................................41\n\
    \           3.6.1. Option 6.1: No HAS Awareness .......................42\n  \
    \         3.6.2. Option 6.2: Purge Identifiers ......................42\n    \
    \       3.6.3. Recommendations ....................................43\n      3.7.\
    \ Other Issues ..............................................43\n   4. Security\
    \ Considerations ........................................43\n   5. Acknowledgements\
    \ ...............................................44\n   6. References .....................................................44\n\
    \      6.1. Normative References ......................................44\n  \
    \    6.2. Informative References ....................................44\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   [RFC6707] defines the problem space for Content Distribution\
    \ Network\n   Interconnection (CDNI) and the associated CDNI interfaces.  This\n\
    \   includes support, through interconnected Content Delivery Networks\n   (CDNs),\
    \ of content delivery to End Users using HTTP progressive\n   download and HTTP\
    \ Adaptive Streaming (HAS).\n   HTTP Adaptive Streaming is an umbrella term for\
    \ various HTTP-based\n   streaming technologies that allow a client to adaptively\
    \ switch\n   between multiple bitrates, depending on current network conditions.\n\
    \   A defining aspect of HAS is that, since it is based on HTTP, it is a\n   pull-based\
    \ mechanism, with a client actively requesting content\n   segments instead of\
    \ the content being pushed to the client by a\n   server.  Due to this pull-based\
    \ nature, media servers delivering\n   content using HAS often show different\
    \ characteristics when compared\n   with media servers delivering content using\
    \ traditional streaming\n   methods such as the Real-time Transport Protocol /\
    \ Real Time\n   Streaming Protocol (RTP/RTSP), the Real Time Messaging Protocol\n\
    \   (RTMP), and the Multimedia Messaging Service (MMS).\n   This document presents\
    \ a discussion of the impact of the HAS\n   operation on the CDNI interfaces,\
    \ and what HAS-specific optimizations\n   may be required or may be desirable.\
    \  The scope of this document is\n   to present the authors' analysis of the CDNI-HAS\
    \ problem space and\n   discuss different options put forward by the authors (and\
    \ by others\n   during informal discussions) on how to deal with HAS in the context\n\
    \   of CDNI.  The document concludes by presenting the authors'\n   recommendations\
    \ on how the CDNI WG should deal with HAS in its\n   initial charter, with a focus\
    \ on 'making it work' instead of\n   including 'nice-to-have' optimizations that\
    \ might delay the\n   development of the CDNI WG deliverables identified in its\
    \ initial\n   charter.\n   It should be noted that the document is not a WG document\
    \ but has\n   been used as input during the WG process for making its decision\n\
    \   regarding support for HAS.  We expect the analysis presented in the\n   document\
    \ to be useful in the future if and when the WG recharters and\n   wants to reassess\
    \ the level of HAS optimizations to be supported in\n   CDNI scenarios.\n"
- title: 1.1.  Terminology
  contents:
  - "1.1.  Terminology\n   This document uses the terminology defined in [RFC6707]\
    \ and\n   [CDNI-FRAMEWORK].\n   For convenience, the definitions of HAS-related\
    \ terms are restated\n   here:\n   Content Item:  A uniquely addressable content\
    \ element in a CDN.  A\n      content item is defined by the fact that it has\
    \ its own Content\n      Metadata associated with it.  An example of a content\
    \ item is a\n      video file/stream, an audio file/stream, or an image file.\n\
    \   Chunk:  A fixed-length element that is the result of a segmentation\n    \
    \  or fragmentation operation and that is independently addressable.\n   Fragment:\
    \  A specific form of chunk (see Section 2.1).  A fragment is\n      stored as\
    \ part of a larger file that includes all chunks that are\n      part of the chunk\
    \ collection.\n   Segment:  A specific form of chunk (see Section 2.1).  A segment\
    \ is\n      stored as a single file from a file-system perspective.\n   Original\
    \ Content:  Non-chunked content that is the basis for a\n      segmentation or\
    \ fragmentation operation.  Based on Original\n      Content, multiple alternative\
    \ representations (using different\n      encoding methods, supporting different\
    \ resolutions, and/or\n      targeting different bitrates) may be derived, each\
    \ of which may be\n      fragmented or segmented.\n   Chunk Collection:  The set\
    \ of all chunks that are the result of a\n      single segmentation or fragmentation\
    \ operation being performed on\n      a single representation of the Original\
    \ Content.  A chunk\n      collection is described in a Manifest File.\n   Content\
    \ Collection:  The set of all chunk collections that are\n      derived from the\
    \ same Original Content.  A content collection may\n      consist of multiple\
    \ chunk collections, each corresponding to a\n      single representation of the\
    \ Original Content.  A content\n      collection may be described by one or more\
    \ Manifest Files.\n   Manifest File:  A Manifest File, also referred to as a Media\n\
    \      Presentation Description (MPD) file, is a file that lists the way\n   \
    \   the content has been chunked (possibly for multiple encodings), as\n     \
    \ well as where the various chunks are located (in the case of\n      segments)\
    \ or how they can be addressed (in the case of fragments).\n"
- title: 2.  HTTP Adaptive Streaming Aspects Relevant to CDNI
  contents:
  - "2.  HTTP Adaptive Streaming Aspects Relevant to CDNI\n   In the last couple of\
    \ years, a wide variety of HAS-like protocols\n   have emerged.  Among them are\
    \ proprietary solutions such as Apple's\n   HTTP Live Streaming (HLS), Microsoft's\
    \ HTTP Smooth Streaming (HSS),\n   and Adobe's HTTP Dynamic Streaming (HDS), as\
    \ well as various\n   standardized solutions such as 3GPP Adaptive HTTP Streaming\
    \ (AHS) and\n   MPEG Dynamic Adaptive Streaming over HTTP (DASH).  While all of\
    \ these\n   technologies share a common set of features, each has its own\n  \
    \ defining elements.  This section looks at some of the common\n   characteristics\
    \ and some of the differences between these\n   technologies and how those might\
    \ be relevant to CDNI.  In particular,\n   Section 2.1 describes the various methods\
    \ to store HAS content, and\n   Section 2.2 lists three methods that are used\
    \ to address HAS content\n   in a CDN.  After these generic HAS aspects are discussed,\
    \ two special\n   situations that need to be taken into account when discussing\
    \ HAS are\n   addressed: Section 2.3 discusses the differences between live content\n\
    \   and Video on Demand (VoD) content, while Section 2.4 discusses the\n   scenario\
    \ where multiple streams are combined in a single Manifest\n   File (e.g., for\
    \ ad insertion purposes).\n"
- title: 2.1.  Segmentation versus Fragmentation
  contents:
  - "2.1.  Segmentation versus Fragmentation\n   All HAS implementations are based\
    \ on a concept referred to as\n   \"chunking\": the concept of having a server\
    \ split content up in\n   numerous fixed-duration chunks that are independently\
    \ decodable.  By\n   sequentially requesting and receiving chunks, a client can\
    \ recreate\n   and play out the content.  An advantage of this mechanism is that\
    \ it\n   allows a client to seamlessly switch between different encodings of\n\
    \   the same Original Content at chunk boundaries.  Before requesting a\n   particular\
    \ chunk, a client can choose between multiple alternative\n   encodings of the\
    \ same chunk, irrespective of the encoding of the\n   chunks it has requested\
    \ earlier.\n   While every HAS implementation uses some form of chunking, not\
    \ all\n   implementations store the resulting chunks in the same way.  In\n  \
    \ general, there are two distinct methods of performing chunking and\n   storing\
    \ the results: segmentation and fragmentation.\n   -  With segmentation -- which\
    \ is, for example, mandatory in all\n      versions of Apple's HLS prior to version\
    \ 7 -- the chunks, in this\n      case also referred to as segments, are stored\
    \ completely\n      independently from each other, with each segment being stored\
    \ as a\n      separate file from a file-system perspective.  This means that\n\
    \      each segment has its own unique URL with which it can be\n      retrieved.\n\
    \   -  With fragmentation (or virtual segmentation) -- which is, for\n      example,\
    \ used in Microsoft's HTTP Smooth Streaming -- all chunks,\n      or fragments,\
    \ belonging to the same chunk collection are stored\n      together as part of\
    \ a single file.  While there are a number of\n      container formats that allow\
    \ for storing this type of chunked\n      content, fragmented MP4 is most commonly\
    \ used.  With\n      fragmentation, a specific chunk is addressable by suffixing,\
    \ to\n      the common file URL, an identifier uniquely identifying the chunk\n\
    \      that one is interested in, either by timestamp, by byte range, or\n   \
    \   in some other way.\n   While one can argue about the merits of each of these\
    \ two different\n   methods of handling chunks, both have their advantages and\
    \ drawbacks\n   in a CDN environment.  For example, fragmentation is often regarded\n\
    \   as a method that introduces less overhead, from both a storage and\n   processing\
    \ perspective.  Segmentation, on the other hand, is regarded\n   as being more\
    \ flexible and easier to cache.  In practice, current HAS\n   implementations\
    \ increasingly support both methods.\n"
- title: 2.2.  Addressing Chunks
  contents:
  - "2.2.  Addressing Chunks\n   In order for a client to request chunks, in the form\
    \ of either\n   segments or fragments, it needs to know how the content has been\n\
    \   chunked and where to find the chunks.  For this purpose, most HAS\n   protocols\
    \ use a concept that is often referred to as a Manifest File\n   (also known as\
    \ a Media Presentation Description, or MPD), i.e., a\n   file that lists the way\
    \ the content has been chunked and where the\n   various chunks are located (in\
    \ the case of segments) or how they can\n   be addressed (in the case of fragments).\
    \  A Manifest File or set of\n   Manifest Files may also identify the different\
    \ representations, and\n   thus chunk collections, available for the content.\n\
    \   In general, a HAS client will first request and receive a Manifest\n   File,\
    \ and then, after parsing the information in the Manifest File,\n   proceed with\
    \ sequentially requesting the chunks listed in the\n   Manifest File.  Each HAS\
    \ implementation has its own Manifest File\n   format, and even within a particular\
    \ format there are different\n   methods available to specify the location of\
    \ a chunk.\n   Of course, managing the location of files is a core aspect of every\n\
    \   CDN, and each CDN will have its own method of doing so.  Some CDNs\n   may\
    \ be purely cache-based, with no higher-level knowledge of where\n   each file\
    \ resides at each instant in time.  Other CDNs may have\n   dedicated management\
    \ nodes that, at each instant in time, do know at\n   which servers each file\
    \ resides.  The CDNI interfaces designed by the\n   CDNI WG will probably need\
    \ to be agnostic to these kinds of CDN-\n   internal architecture decisions. \
    \ In the case of HAS, there is a\n   strict relationship between the location\
    \ of the content in the CDN\n   (in this case chunks) and the content itself (the\
    \ locations specified\n   in the Manifest File).  It is therefore useful to have\
    \ an\n   understanding of the different methods in use in CDNs today for\n   specifying\
    \ chunk locations in Manifest Files.  The different methods\n   for doing so are\
    \ described in Sections 2.2.1 to 2.2.3.\n   Although these sections are especially\
    \ relevant for segmented content\n   due to its inherent distributed nature, the\
    \ discussed methods are\n   also applicable to fragmented content.  Furthermore,\
    \ it should be\n   noted that the methods detailed below for specifying locations\
    \ of\n   content items in Manifest Files do not relate only to temporally\n  \
    \ segmented content (e.g., segments and fragments) but are also\n   relevant in\
    \ situations where content is made available in multiple\n   representations (e.g.,\
    \ in different qualities, encoding methods,\n   resolutions, and/or bitrates).\
    \  In this case, the content consists of\n   multiple chunk collections, which\
    \ may be described by either a single\n   Manifest File or multiple interrelated\
    \ Manifest Files.  In the latter\n   case, there may be a high-level Manifest\
    \ File describing the various\n   available bitrates, with URLs pointing to separate\
    \ Manifest Files\n   describing the details of each specific bitrate.  For specifying\
    \ the\n   locations of the other Manifest Files, the same methods that are used\n\
    \   for specifying chunk locations also apply.\n   One final note relates to the\
    \ delivery of the Manifest Files\n   themselves.  While in most situations the\
    \ delivery of both the\n   Manifest File and the chunks is handled by the CDN,\
    \ there are\n   scenarios imaginable in which the Manifest File is delivered by,\
    \ for\n   example, the Content Service Provider (CSP), and the Manifest File is\n\
    \   therefore not visible to the CDN.\n"
- title: 2.2.1.  Relative URLs
  contents:
  - "2.2.1.  Relative URLs\n   One method for specifying chunk locations in a Manifest\
    \ File is\n   through the use of relative URLs.  A relative URL is a URL that\
    \ does\n   not include the HOST part of a URL but only includes (part of) the\n\
    \   PATH part of a URL.  In practice, a relative URL is used by the\n   client\
    \ as being relative to the location from which the Manifest File\n   has been\
    \ acquired.  In these cases, a relative URL will take the form\n   of a string\
    \ that has to be appended to the location of the Manifest\n   File to get the\
    \ location of a specific chunk.  This means that in the\n   case where a Manifest\
    \ File with relative URLs is used, all chunks\n   will be delivered by the same\
    \ Surrogate that delivered the Manifest\n   File.  A relative URL will therefore\
    \ not include a hostname.\n   For example, in the case where a Manifest File has\
    \ been requested\n   (and received) from:\n      http://surrogate.server.cdn.example.com/content_1/manifest.xml\n\
    \   a relative URL pointing to a specific segment referenced in the\n   Manifest\
    \ File might be:\n      segments/segment1_1.ts\n   which means that the client\
    \ should take the location of the Manifest\n   File and append the relative URL.\
    \  In this case, the segment would\n   then be requested from http://surrogate.server.cdn.example.com/\n\
    \   content_1/segments/segment1_1.ts.\n   One drawback of using relative URLs\
    \ is that it forces a CDN relying\n   on HTTP-based request routing to deliver\
    \ all segments belonging to a\n   given content item with the same Surrogate that\
    \ delivered the\n   Manifest File for that content item, which results in limited\n\
    \   flexibility.  Another drawback is that relative URLs do not allow for\n  \
    \ fallback URLs; should the Surrogate that delivered the Manifest File\n   break\
    \ down, the client is no longer able to request chunks.  The\n   advantage of\
    \ relative URLs is that it is very easy to transfer\n   content between different\
    \ Surrogates and even CDNs.\n"
- title: 2.2.2.  Absolute URLs with Redirection
  contents:
  - "2.2.2.  Absolute URLs with Redirection\n   Another method for specifying locations\
    \ of chunks (or other Manifest\n   Files) in a Manifest File is through the use\
    \ of an absolute URL.  An\n   absolute URL contains a fully formed URL (i.e.,\
    \ the client does not\n   have to calculate the URL as in the case of the relative\
    \ URL but can\n   use the URL from the Manifest File directly).\n   In the context\
    \ of Manifest Files, there are two types of absolute\n   URLs imaginable: absolute\
    \ URLs with redirection and absolute URLs\n   without redirection.  The two methods\
    \ differ in whether the URL\n   points to a request routing node that will redirect\
    \ the client to a\n   Surrogate (absolute URLs with redirection) or point directly\
    \ to a\n   Surrogate hosting the requested content (absolute URLs without\n  \
    \ redirection).\n   In the case of absolute URLs with redirection, a request for\
    \ a chunk\n   is handled by the Request Routing system of a CDN just as if it\
    \ were\n   a standalone (non-HAS) content request, which might include looking\n\
    \   up the Surrogate (and/or CDN) best suited for delivering the\n   requested\
    \ chunk to the particular user and sending an HTTP redirect\n   to the user with\
    \ the URL pointing to the requested chunk on the\n   specified Surrogate (and/or\
    \ CDN), or a DNS response pointing to the\n   specific Surrogate.\n   An example\
    \ of an absolute URL with redirection might look as follows:\n      http://requestrouting.cdn.example.com/\n\
    \      content_request?content=content_1&segment=segment1_1.ts\n   As can be seen\
    \ from this example URL, the URL includes a pointer to a\n   general CDN Request\
    \ Routing function and some arguments identifying\n   the requested segment.\n\
    \   The advantage of using absolute URLs with redirection is that they\n   allow\
    \ for maximum flexibility (since chunks can be distributed across\n   Surrogates\
    \ and CDNs in any imaginable way) without having to modify\n   the Manifest File\
    \ every time one or more chunks are moved (as is the\n   case when absolute URLs\
    \ without redirection are used).  The downside\n   of this method is that it can\
    \ add significant load to a CDN Request\n   Routing system, since it has to perform\
    \ a redirect every time a\n   client requests a new chunk.\n"
- title: 2.2.3.  Absolute URLs without Redirection
  contents:
  - "2.2.3.  Absolute URLs without Redirection\n   In the case of absolute URLs without\
    \ redirection, the URL points\n   directly to the specific chunk on the actual\
    \ Surrogate that will\n   deliver the requested chunk to the client.  In other\
    \ words, there\n   will be no HTTP redirection operation taking place between\
    \ the client\n   requesting the chunk and the chunk being delivered to the client\
    \ by\n   the Surrogate.\n   An example of an absolute URL without redirection\
    \ is the following:\n      http://surrogate1.cdn.example.com/content_1/segments/segment1_1.ts\n\
    \   As can be seen from this example URL, the URL includes both the\n   identifier\
    \ of the requested segment (in this case segment1_1.ts) and\n   the server that\
    \ is expected to deliver the segment (in this case\n   surrogate1.cdn.example.com).\
    \  With this, the client has enough\n   information to directly request the specific\
    \ segment from the\n   specified Surrogate.\n   The advantage of using absolute\
    \ URLs without redirection is that it\n   allows more flexibility compared to\
    \ using relative URLs (since\n   segments do not necessarily have to be delivered\
    \ by the same server)\n   while not requiring per-segment redirection (which would\
    \ add\n   significant load to the node doing the redirection).  The drawback of\n\
    \   this method is that it requires a modification of the Manifest File\n   every\
    \ time content is moved to a different location (either within a\n   CDN or across\
    \ CDNs).\n"
- title: 2.3.  Live Content versus VoD Content
  contents:
  - "2.3.  Live Content versus VoD Content\n   Though the formats and addresses of\
    \ Manifest Files and chunk files do\n   not typically differ significantly between\
    \ live and Video-on-Demand\n   (VoD) content, the time at which the Manifest Files\
    \ and chunk files\n   become available does differ significantly.  For live content,\
    \ chunk\n   files and their corresponding Manifest Files are created and\n   delivered\
    \ in real time.  This poses a number of potential issues for\n   HAS optimization:\n\
    \   -  With live content, chunk files are made available in real time.\n     \
    \ This limits the applicability of bundling for content acquisition\n      purposes.\
    \  Pre-positioning may still be employed; however, any\n      significant latency\
    \ in the pre-positioning may diminish the value\n      of pre-positioning if a\
    \ client requests the chunk prior to\n      pre-positioning or if the pre-positioning\
    \ request is serviced\n      after the chunk playout time has passed.\n   -  In\
    \ the case of live content, Manifest Files must be updated for\n      each chunk\
    \ and therefore must be retrieved by the client prior to\n      each chunk request.\
    \  Any optimization schemes based on Manifest\n      Files must therefore be prepared\
    \ to optimize on a per-segment\n      request basis.  Manifest Files may also\
    \ be polled multiple times\n      prior to the actual availability of the next\
    \ chunk.\n   -  Since live Manifest Files are updated as new chunks become\n \
    \     available, the cacheability of Manifest Files is limited.  Though\n    \
    \  timestamping and reasonable Time-to-Live (TTL) settings can\n      improve\
    \ delivery performance, timely replication and delivery of\n      updated Manifest\
    \ Files are critical to ensuring uninterrupted\n      playback.\n   -  Manifest\
    \ Files are typically updated after the corresponding chunk\n      is available\
    \ for delivery, to prevent premature requests for\n      chunks that are not yet\
    \ available.  HAS optimization approaches\n      that employ dynamic Manifest\
    \ File generation must be synchronized\n      with chunk creation to prevent playback\
    \ errors.\n"
- title: 2.4.  Stream Splicing
  contents:
  - "2.4.  Stream Splicing\n   Stream splicing is used to create media mashups, combining\
    \ content\n   from multiple sources.  A common example in which content resides\n\
    \   outside the CDNs is with advertisement insertion, for both VoD and\n   live\
    \ streams.  Manifest Files that contain absolute URLs with\n   redirection may\
    \ contain chunk or nested Manifest File URLs that point\n   to content not delivered\
    \ via any of the interconnected CDNs.\n   Furthermore, client and downstream proxy\
    \ devices may depend on\n   non-URL information provided in the Manifest File\
    \ (e.g., comments or\n   custom tags) for performing stream splicing.  This often\
    \ occurs\n   outside the scope of the interconnected CDNs.  HAS optimization\n\
    \   schemes that employ dynamic Manifest File generation or rewriting\n   must\
    \ be cognizant of chunk URLs, nested Manifest File URLs, and other\n   metadata\
    \ that should not be modified or removed.  Improper\n   modification of these\
    \ URLs or other metadata may cause playback\n   interruptions and in the case\
    \ of unplayed advertisements may result\n   in loss of revenue for CSPs.\n"
- title: 3.  Possible HAS Optimizations
  contents:
  - "3.  Possible HAS Optimizations\n   In the previous section, some of the unique\
    \ properties of HAS were\n   discussed.  Furthermore, some of the CDN-specific\
    \ design decisions\n   with regards to addressing chunks have been detailed. \
    \ In this\n   section, the impact of supporting HAS in CDNI scenarios is discussed.\n\
    \   There are a number of topics, or problem areas, that are of\n   particular\
    \ interest when considering the combination of HAS and CDNI.\n   For each of these\
    \ problem areas, it holds that there are a number of\n   different ways in which\
    \ the CDNI interfaces can deal with them.  In\n   general, it can be said that\
    \ each problem area can either be solved\n   in a way that minimizes the amount\
    \ of HAS-specific changes to the\n   CDNI interfaces or maximizes the flexibility\
    \ and efficiency with\n   which the CDNI interfaces can deliver HAS content. \
    \ The goal for the\n   CDNI WG should probably be to try to find the middle ground\
    \ between\n   these two extremes and try to come up with solutions that optimize\n\
    \   the balance between efficiency and additional complexity.\n   In order to\
    \ allow the WG to make this decision, this section briefly\n   describes each\
    \ of the following problem areas, together with a number\n   of different options\
    \ for dealing with them.  Section 3.1 discusses\n   the problem of how to deal\
    \ with file management of groups of files,\n   or content collections.  Section\
    \ 3.2 deals with a related topic: how\n   to do content acquisition of content\
    \ collections between the Upstream\n   CDN (uCDN) and Downstream CDN (dCDN). \
    \ After that, Section 3.3\n   describes the various options for the request routing\
    \ of HAS content,\n   particularly related to Manifest Files.  Section 3.4 talks\
    \ about a\n   number of possible optimizations for the logging of HAS content,\n\
    \   while Section 3.5 discusses the options regarding URL signing.\n   Finally,\
    \ Section 3.6 describes different scenarios for dealing with\n   the removal of\
    \ HAS content from CDNs.\n"
- title: 3.1.  File Management and Content Collections
  contents:
  - '3.1.  File Management and Content Collections

    '
- title: 3.1.1.  General Remarks
  contents:
  - "3.1.1.  General Remarks\n   One of the unique properties of HAS content is that\
    \ it does not\n   consist of a single file or stream but of multiple interrelated\
    \ files\n   (segments, fragments, and/or Manifest Files).  In this document, this\n\
    \   group of files is also referred to as a content collection.  Another\n   important\
    \ aspect is the difference between segments and fragments\n   (see Section 2.1).\n\
    \   Irrespective of whether segments or fragments are used, different\n   CDNs\
    \ might handle content collections differently from a file\n   management perspective.\
    \  For example, some CDNs might handle all\n   files belonging to a content collection\
    \ as individual files that are\n   stored independently from each other.  An advantage\
    \ of this approach\n   is that it makes it easy to cache individual chunks.  Other\
    \ CDNs\n   might store all fragments belonging to a content collection in a\n\
    \   bundle, as if they were a single file (e.g., by using a fragmented\n   MP4\
    \ container).  The advantage of this approach is that it reduces\n   file management\
    \ overhead.\n   The following subsections look at the various ways with which\
    \ the\n   CDNI interfaces might deal with these differences in handling content\n\
    \   collections from a file management perspective.  The different\n   options\
    \ can be distinguished based on the level of HAS awareness they\n   require on\
    \ the part of the different CDNs and the CDNI interfaces.\n"
- title: 3.1.2.  Candidate Approaches
  contents:
  - '3.1.2.  Candidate Approaches

    '
- title: '3.1.2.1.  Option 1.1: Do Nothing'
  contents:
  - "3.1.2.1.  Option 1.1: Do Nothing\n   This option assumes no HAS awareness in\
    \ both the involved CDNs and\n   the CDNI interfaces.  This means that the uCDN\
    \ uses individual files,\n   and the dCDN is not explicitly made aware of the\
    \ relationship between\n   chunks and doesn't know which files are part of the\
    \ same content\n   collection.  In practice, this scenario would mean that the\
    \ file\n   management method used by the uCDN is simply imposed on the dCDN as\n\
    \   well.\n   This scenario also means that it is not possible for the dCDN to\
    \ use\n   any form of file bundling, such as the single-file mechanism, which\n\
    \   can be used to store fragmented content as a single file (see\n   Section\
    \ 2.1).  The one exception to this rule is the situation where\n   the content\
    \ is fragmented and the Manifest Files on the uCDN contain\n   byte range requests,\
    \ in which case the dCDN might be able to acquire\n   fragmented content as a\
    \ single file (see Section 3.2.2.2).\n   Effect on CDNI interfaces:\n   o  None\n\
    \   Advantages/Drawbacks:\n   +  No HAS awareness necessary in CDNs; no changes\
    \ to CDNI interfaces\n      necessary\n   -  The dCDN is forced to store chunks\
    \ as individual files\n"
- title: '3.1.2.2.  Option 1.2: Allow Single-File Storage of Fragmented Content'
  contents:
  - "3.1.2.2.  Option 1.2: Allow Single-File Storage of Fragmented Content\n   In\
    \ some cases, the dCDN might prefer to store fragmented content as a\n   single\
    \ file on its Surrogates to reduce file management overhead.  In\n   order to\
    \ do so, it needs to be able to either acquire the content as\n   a single file\
    \ (see Section 3.2.2.2) or to merge the different chunks\n   together and place\
    \ them in the same container (e.g., fragmented MP4).\n   The downside of this\
    \ method is that in order to do so, the dCDN needs\n   to be fully HAS aware.\n\
    \   Effect on CDNI interfaces:\n   o  CDNI Metadata interface: Add fields for\
    \ indicating the particular\n      type of HAS (e.g., MPEG DASH or HLS) that is\
    \ used and whether\n      segments or fragments are used\n   o  CDNI Metadata\
    \ interface: Add field for indicating the name and\n      type of the Manifest\
    \ File(s)\n   Advantages/Drawbacks:\n   +  Allows the dCDN to store fragmented\
    \ content as a single file,\n      reducing file management overhead\n   -  Complex\
    \ operation, requiring the dCDN to be fully HAS aware\n"
- title: '3.1.2.3.  Option 1.3: Access Correlation Hint'
  contents:
  - "3.1.2.3.  Option 1.3: Access Correlation Hint\n   An intermediary approach between\
    \ the two extremes detailed in the\n   previous two sections is one that uses\
    \ an 'Access Correlation Hint'.\n   This hint, which is added to the CDNI Metadata\
    \ of all chunks of a\n   particular content collection, indicates that those files\
    \ are likely\n   to be requested in a short time window from each other.  This\n\
    \   information can help a dCDN to implement local file storage\n   optimizations\
    \ for VoD items (e.g., by bundling all files with the\n   same Access Correlation\
    \ Hint value in a single bundle/file), thereby\n   reducing the number of files\
    \ it has to manage while not requiring any\n   HAS awareness.\n   Effect on CDNI\
    \ interfaces:\n   o  CDNI Metadata interface: Add field for indicating Access\n\
    \      Correlation Hint\n   Advantages/Drawbacks:\n   +  Allows the dCDN to perform\
    \ file management optimization\n   +  Does not require any HAS awareness\n   +\
    \  Very small impact on CDNI interfaces\n   -  Expected benefit compared with\
    \ Option 1.1 is small\n"
- title: 3.1.3.  Recommendations
  contents:
  - "3.1.3.  Recommendations\n   Based on the listed pros and cons, the authors recommend\
    \ that the WG\n   go for Option 1.1 (do nothing).  The likely benefits of going\
    \ for\n   Option 1.3 are not believed to be significant enough to warrant\n  \
    \ changing the CDNI Metadata interface.  Although Option 1.2 would\n   bring definite\
    \ benefits for HAS-aware dCDNs, going for this option\n   would require significant\
    \ CDNI extensions that would impact the WG's\n   milestones.  The authors therefore\
    \ don't recommend including it in\n   the current work but mark it as a possible\
    \ candidate for rechartering\n   once the initial CDNI solution is completed.\n"
- title: 3.2.  Content Acquisition of Content Collections
  contents:
  - '3.2.  Content Acquisition of Content Collections

    '
- title: 3.2.1.  General Remarks
  contents:
  - "3.2.1.  General Remarks\n   In the previous section, the relationship between\
    \ file management and\n   HAS in a CDNI scenario was discussed.  This section\
    \ discusses a\n   related topic: content acquisition between two CDNs.\n   With\
    \ regards to content acquisition, it is important to note the\n   difference between\
    \ CDNs that do dynamic acquisition of content and\n   CDNs that perform content\
    \ pre-positioning.  In the case of dynamic\n   acquisition, a CDN only requests\
    \ a particular content item when a\n   cache miss occurs.  In the case of pre-positioning,\
    \ a CDN proactively\n   places content items on the nodes on which it expects\
    \ traffic for\n   that particular content item.  For each of these types of CDNs,\
    \ there\n   might be a benefit in being HAS aware.  For example, in the case of\n\
    \   dynamic acquisition, being HAS aware means that after a cache miss\n   for\
    \ a given chunk occurs, that node might not only acquire the\n   requested chunk\
    \ but might also acquire some related chunks that are\n   expected to be requested\
    \ in the near future.  In the case of\n   pre-positioning, similar benefits can\
    \ be had.\n"
- title: 3.2.2.  Candidate Approaches
  contents:
  - '3.2.2.  Candidate Approaches

    '
- title: '3.2.2.1.  Option 2.1: No HAS Awareness'
  contents:
  - "3.2.2.1.  Option 2.1: No HAS Awareness\n   This option assumes no HAS awareness\
    \ in both the involved CDNs and\n   the CDNI interfaces.  Just as with Option\
    \ 1.1, discussed earlier with\n   regards to file management, having no HAS awareness\
    \ means that the\n   dCDN is not aware of the relationship between chunks.  In\
    \ the case of\n   content acquisition, this means that each and every file belonging\
    \ to\n   a content collection will have to be individually acquired from the\n\
    \   uCDN by the dCDN.  The exception to the rule is cases with fragmented\n  \
    \ content where the uCDN uses Manifest Files that contain byte range\n   requests.\
    \  In this case, the dCDN can simply omit the byte range\n   identifier and acquire\
    \ the complete file.\n   The advantage of this approach is that it is highly flexible.\
    \  If a\n   client only requests a small portion of the chunks belonging to a\n\
    \   particular content collection, the dCDN only has to acquire those\n   chunks\
    \ from the uCDN, saving both bandwidth and storage capacity.\n   The downside\
    \ of acquiring content on a per-chunk basis is that it\n   creates more transaction\
    \ overhead between the dCDN and uCDN, compared\n   to a method in which entire\
    \ content collections can be acquired as\n   part of one transaction.\n   Effect\
    \ on CDNI interfaces:\n   o  None\n   Advantages/Drawbacks:\n   +  Per-chunk content\
    \ acquisition allows for a high level of\n      flexibility between the dCDN and\
    \ uCDN\n   -  Per-chunk content acquisition creates more transaction overhead\n\
    \      between the dCDN and uCDN\n"
- title: '3.2.2.2.  Option 2.2: Allow Single-File Acquisition of Fragmented'
  contents:
  - "3.2.2.2.  Option 2.2: Allow Single-File Acquisition of Fragmented\n         \
    \ Content\n   As discussed in Section 3.2.2.1, there is one (fairly rare) case\n\
    \   where fragmented content can be acquired as a single file without any\n  \
    \ HAS awareness, and that is when fragmented content is used and where\n   the\
    \ Manifest File specifies byte range requests.  This section\n   discusses how\
    \ to perform single-file acquisition in the other (very\n   common) cases.  To\
    \ do so, the dCDN would have to have full HAS\n   awareness (at least to the extent\
    \ of being able to map between a\n   single file and individual chunks to serve).\n\
    \   Effect on CDNI interfaces:\n   o  CDNI Metadata interface: Add fields for\
    \ indicating the particular\n      type of HAS (e.g., MPEG DASH or HLS) that is\
    \ used and whether\n      segments or fragments are used\n   o  CDNI Metadata\
    \ interface: Add field for indicating the name and\n      type of the Manifest\
    \ File(s)\n   Advantages/Drawbacks:\n   +  Allows for more efficient content acquisition\
    \ in all HAS-specific\n      supported forms\n   -  Requires full HAS awareness\
    \ on the part of the dCDN\n   -  Requires significant CDNI Metadata interface\
    \ extensions\n"
- title: 3.2.3.  Recommendations
  contents:
  - "3.2.3.  Recommendations\n   Based on the listed pros and cons, the authors recommend\
    \ that the WG\n   go for Option 2.1, since it is sufficient to 'make HAS work'.\
    \  While\n   Option 2.2 would bring benefits to the acquisition of large content\n\
    \   collections, it would require significant CDNI extensions that would\n   impact\
    \ the WG's milestones.  Option 2.2 might be a candidate to\n   include in possible\
    \ rechartering once the initial CDNI solution is\n   completed.\n"
- title: 3.3.  Request Routing of HAS Content
  contents:
  - '3.3.  Request Routing of HAS Content

    '
- title: 3.3.1.  General Remarks
  contents:
  - "3.3.1.  General Remarks\n   In this section, the effect HAS content has on request\
    \ routing is\n   identified.  Of particular interest in this case are the different\n\
    \   types of Manifest Files that might be used.  In Section 2.2, three\n   different\
    \ methods for identifying and addressing chunks from within a\n   Manifest File\
    \ were described: relative URLs, absolute URLs with\n   redirection, and absolute\
    \ URLs without redirection.  Of course, not\n   every current CDN will use and/or\
    \ support all three methods.  Some\n   CDNs may only use one of the three methods,\
    \ while others may support\n   two or all three.\n   An important factor in deciding\
    \ which chunk-addressing method is used\n   is the CSP.  Some CSPs may have a\
    \ strong preference for a particular\n   method and deliver the Manifest Files\
    \ to the CDN in a particular way.\n   Depending on the CDN and the agreement it\
    \ has with the CSP, a CDN may\n   either host the Manifest Files as they were\
    \ created by the CSP or\n   modify the Manifest File to adapt it to its particular\
    \ architecture\n   (e.g., by changing relative URLs to absolute URLs that point\
    \ to the\n   CDN Request Routing function).\n"
- title: 3.3.2.  Candidate Approaches
  contents:
  - '3.3.2.  Candidate Approaches

    '
- title: '3.3.2.1.  Option 3.1: No HAS Awareness'
  contents:
  - "3.3.2.1.  Option 3.1: No HAS Awareness\n   This option assumes no HAS awareness\
    \ in both the involved CDNs and\n   the CDNI interfaces.  This scenario also assumes\
    \ that neither the\n   dCDN nor the uCDN has the ability to actively manipulate\
    \ Manifest\n   Files.  As was also discussed with regards to file management and\n\
    \   content acquisition, having no HAS awareness means that each file\n   constituting\
    \ a content collection is handled on an individual basis,\n   with the dCDN unaware\
    \ of any relationship between files.\n   The only chunk-addressing method that\
    \ works without question in this\n   case is absolute URLs with redirection. \
    \ In other words, the CSP that\n   ingested the content into the uCDN created\
    \ a Manifest File with each\n   chunk location pointing to the Request Routing\
    \ function of the uCDN.\n   Alternatively, the CSP may have ingested the Manifest\
    \ File containing\n   relative URLs, and the uCDN ingestion function has translated\
    \ these\n   to absolute URLs pointing to the Request Routing function.\n   In\
    \ this \"absolute URL with redirection\" case, the uCDN can simply\n   have the\
    \ Manifest File be delivered by the dCDN as if it were a\n   regular file.  Once\
    \ the client parses the Manifest File, it will\n   request any subsequent chunks\
    \ from the uCDN Request Routing function.\n   That function can then decide to\
    \ outsource the delivery of those\n   chunks to the dCDN.  Depending on whether\
    \ HTTP-based (recursive or\n   iterative) or DNS-based request routing is used,\
    \ the uCDN Request\n   Routing function will then either directly or indirectly\
    \ redirect the\n   client to the Request Routing function of the dCDN (assuming\
    \ that it\n   does not have the necessary information to redirect the client\n\
    \   directly to a Surrogate in the dCDN).\n   The drawback of this method is that\
    \ it creates a large amount of\n   request routing overhead for both the uCDN\
    \ and dCDN.  For each chunk,\n   the full inter-CDN Request Routing process is\
    \ invoked (which can\n   result in two HTTP redirections in the case of iterative\
    \ redirection,\n   or one HTTP redirection plus one CDNI Request Routing Redirection\n\
    \   interface request/response).  Even in the case where DNS-based\n   redirection\
    \ is used, there might be significant overhead involved,\n   since both the dCDN\
    \ and uCDN Request Routing functions might have to\n   perform database lookups\
    \ and query each other.  While with DNS this\n   overhead might be reduced by\
    \ using DNS's inherent caching mechanism,\n   this will have significant impact\
    \ on the accuracy of the redirect.\n   With no HAS awareness, relative URLs might\
    \ or might not work,\n   depending on the type of relative URL that is used. \
    \ When a uCDN\n   delegates the delivery of a Manifest File containing relative\
    \ URLs to\n   a dCDN, the client goes directly to the dCDN Surrogate from which\
    \ it\n   has received the Manifest File for every subsequent chunk.  As long\n\
    \   as the relative URL is not path-absolute (see [RFC3986]), this\n   approach\
    \ will work fine.\n   Since using absolute URLs without redirection inherently\
    \ requires a\n   HAS-aware CDN, absolute URLs without redirection cannot be used\
    \ in\n   this case because the URLs in the Manifest File will point directly\n\
    \   to a Surrogate in the uCDN.  Since this scenario assumes no HAS\n   awareness\
    \ on the part of the dCDN or uCDN, it is impossible for\n   either of these CDNs\
    \ to rewrite the Manifest File and thus allow the\n   client to either go to a\
    \ Surrogate in the dCDN or to a Request\n   Routing function.\n   Effect on CDNI\
    \ interfaces:\n   o  None\n   Advantages/Drawbacks:\n   +  Supports absolute URLs\
    \ with redirection\n   +  Supports relative URLs\n   +  Does not require HAS awareness\
    \ and/or changes to the CDNI\n      interfaces\n   -  Not possible to use absolute\
    \ URLs without redirection\n   -  Creates significant signaling overhead in cases\
    \ where absolute\n      URLs with redirection are used (inter-CDN request redirection\
    \ for\n      each chunk)\n"
- title: '3.3.2.2.  Option 3.2: Manifest File Rewriting by uCDN'
  contents:
  - "3.3.2.2.  Option 3.2: Manifest File Rewriting by uCDN\n   While Option 3.1 does\
    \ allow absolute URLs with redirection to be\n   used, it does so in a way that\
    \ creates a high level of request\n   routing overhead for both the dCDN and the\
    \ uCDN.  This option\n   presents a solution to significantly reduce this overhead.\n\
    \   In this scenario, the uCDN is able to rewrite the Manifest File (or\n   generate\
    \ a new one) to be able to remove itself from the request\n   routing chain for\
    \ chunks being referenced in the Manifest File.  As\n   described in Section 3.3.2.1,\
    \ in the case of no HAS awareness, the\n   client will go to the uCDN Request\
    \ Routing function for each chunk\n   request.  This Request Routing function\
    \ can then redirect the client\n   to the dCDN Request Routing function.  By rewriting\
    \ the Manifest File\n   (or generating a new one), the uCDN is able to remove\
    \ this first step\n   and have the Manifest File point directly to the dCDN Request\
    \ Routing\n   function.\n   A key advantage of this solution is that it does not\
    \ directly have an\n   impact on the CDNI interfaces and is therefore transparent\
    \ to these\n   interfaces.  It is a CDN-internal function that a uCDN can perform\n\
    \   autonomously by using information configured for regular CDNI\n   operation\
    \ or received from the dCDN as part of the regular\n   communication using the\
    \ CDNI Request Routing Redirection interface.\n   More specifically, in order\
    \ for the uCDN to rewrite the Manifest\n   File, the minimum information needed\
    \ is the location of the dCDN\n   Request Routing function (or, alternatively,\
    \ the location of the dCDN\n   delivering Surrogate).  This information can be\
    \ available from\n   configuration or can be derived from the regular CDNI Request\
    \ Routing\n   Redirection interface.  For example, the uCDN may ask the dCDN for\n\
    \   the location of its request routing node (through the CDNI Request\n   Routing\
    \ Redirection interface) every time a request for a Manifest\n   File is received\
    \ and processed by the uCDN Request Routing function.\n   The uCDN would then\
    \ modify the Manifest File and deliver the Manifest\n   File to the client.  One\
    \ advantage of this method is that it\n   maximizes efficiency and flexibility\
    \ by allowing the dCDN to\n   optionally respond with the locations of its Surrogates\
    \ instead of\n   the location of its Request Routing function (and effectively\
    \ turning\n   the URLs into absolute URLs without redirection).  There are many\n\
    \   variations on this approach, such as where the modification of the\n   Manifest\
    \ File is only performed once (or once per period of time) by\n   the uCDN Request\
    \ Routing function, when the first client for that\n   particular content collection\
    \ (and redirected to that particular\n   dCDN) sends a Manifest File request.\
    \  The advantage of such a\n   variation is that the uCDN only has to modify the\
    \ Manifest File once\n   (or once per time period).  The drawback of this variation\
    \ is that\n   the dCDN is no longer in a position to influence the request routing\n\
    \   decision across individual content requests.\n   It should be noted that there\
    \ are a number of things to take into\n   account when changing a Manifest File\
    \ (see, for example, Sections 2.3\n   and 2.4 on live HAS content and ad insertion).\
    \  Furthermore, some\n   CSPs might have issues with a CDN changing Manifest Files.\
    \  However,\n   in this option the Manifest File manipulation is only being performed\n\
    \   by the uCDN, which can be expected to be aware of these limitations\n   if\
    \ it wants to perform Manifest File manipulation, since it is in its\n   own best\
    \ interest that its customer's content gets delivered in the\n   proper way and\
    \ since there is a direct commercial and technical\n   relationship between the\
    \ uCDN (the Authoritative CDN in this\n   scenario) and its customer (the CSP).\
    \  Should the CSP want to limit\n   Manifest File manipulation, it can simply\
    \ arrange this with the uCDN\n   bilaterally.\n   Effect on CDNI interfaces:\n\
    \   o  None\n   Advantages/Drawbacks:\n   +  Possible to significantly decrease\
    \ signaling overhead when using\n      absolute URLs\n   +  (Optional) Possible\
    \ to have the uCDN rewrite the Manifest File\n      with locations of Surrogates\
    \ in the dCDN (turning absolute URLs\n      with redirection into absolute URLs\
    \ without redirection)\n   +  No changes to CDNI interfaces\n   +  Does not require\
    \ HAS awareness in the dCDN\n   -  Requires a high level of HAS awareness in the\
    \ uCDN (for modifying\n      Manifest Files)\n"
- title: '3.3.2.3.  Option 3.3: Two-Step Manifest File Rewriting'
  contents:
  - "3.3.2.3.  Option 3.3: Two-Step Manifest File Rewriting\n   One of the possibilities\
    \ with Option 3.2 is allowing the dCDN to\n   provide the locations of a specific\
    \ Surrogate to the uCDN, so that\n   the uCDN can fit the Manifest File with absolute\
    \ URLs without\n   redirection and the client can request chunks directly from\
    \ a dCDN\n   Surrogate.  However, some dCDNs might not be willing to provide this\n\
    \   information to the uCDN.  In that case, they can only provide the\n   uCDN\
    \ with the location of their Request Routing function, thereby\n   preventing\
    \ the use of absolute URLs without redirection.\n   One method for solving this\
    \ limitation is allowing two-step Manifest\n   File manipulation.  In the first\
    \ step, the uCDN would perform its own\n   modification and place the locations\
    \ of the dCDN Request Routing\n   function in the Manifest File.  Then, once a\
    \ request for the Manifest\n   File comes in at the dCDN Request Routing function,\
    \ it would perform\n   a second modification in which it replaces the URLs in\
    \ the Manifest\n   Files with the URLs of its Surrogates.  This way, the dCDN\
    \ can still\n   profit from having limited request routing traffic while not having\n\
    \   to share sensitive Surrogate information with the uCDN.\n   The downside of\
    \ this approach is that it not only assumes HAS\n   awareness in the dCDN but\
    \ also requires some HAS-specific additions\n   to the CDNI Metadata interface.\
    \  In order for the dCDN to be able to\n   change the Manifest File, it has to\
    \ have some information about the\n   structure of the content.  Specifically,\
    \ it needs to have information\n   about which chunks make up the content collection.\n\
    \   Effect on CDNI interfaces (apart from those already listed under\n   Option\
    \ 3.2):\n   o  CDNI Metadata interface: Add necessary fields for conveying HAS-\n\
    \      specific information (e.g., the files that make up the content\n      collection)\
    \ to the dCDN\n   o  CDNI Metadata interface: Allow dCDN to modify Manifest File\n\
    \   Advantages/Drawbacks (apart from those already listed under\n   Option 3.2):\n\
    \   +  Allows the dCDN to use absolute URLs without redirection, without\n   \
    \   having to convey sensitive information to the uCDN\n   -  Requires a high\
    \ level of HAS awareness in the dCDN (for modifying\n      Manifest Files)\n \
    \  -  Requires adding HAS-specific and Manifest File manipulation-\n      specific\
    \ information to the CDNI Metadata interface\n"
- title: 3.3.3.  Recommendations
  contents:
  - "3.3.3.  Recommendations\n   Based on the listed pros and cons, the authors recommend\
    \ going for\n   Option 3.1, with Option 3.2 as an optional feature that may be\n\
    \   supported as a CDN-internal behavior by a uCDN.  While Option 3.1\n   allows\
    \ for HAS content to be delivered using the CDNI interfaces, it\n   does so with\
    \ some limitations regarding supported Manifest Files and,\n   in some cases,\
    \ with a large amount of signaling overhead.  Option 3.2\n   can solve most of\
    \ these limitations and presents a significant\n   reduction in request routing\
    \ overhead.  Since Option 3.2 does not\n   require any changes to the CDNI interfaces\
    \ but only changes the way\n   the uCDN uses the existing interfaces, supporting\
    \ it is not expected\n   to result in a significant delay of the WG's milestones.\
    \  The authors\n   recommend that the WG not include Option 3.3, since it raises\
    \ some\n   questions of potential brittleness and including it would result in\
    \ a\n   significant delay of the WG's milestones.\n"
- title: 3.4.  Logging
  contents:
  - '3.4.  Logging

    '
- title: 3.4.1.  General Remarks
  contents:
  - "3.4.1.  General Remarks\n   As stated in [RFC6707], the CDNI Logging interface\
    \ enables details of\n   logs or events to be exchanged between interconnected\
    \ CDNs.\n   As discussed in [CDNI-LOGGING], the CDNI logging information can be\n\
    \   used for multiple purposes, including maintenance/debugging by a\n   uCDN,\
    \ accounting (e.g., for billing or settlement purposes),\n   reporting and management\
    \ of end-user experience (e.g., to the CSP),\n   analytics (e.g., by the CSP),\
    \ and control of content distribution\n   policy enforcement (e.g., by the CSP).\n\
    \   The key consideration for HAS with respect to logging is the\n   potential\
    \ increase of the number of log records by two to three\n   orders of magnitude,\
    \ as compared to regular HTTP delivery of a video,\n   since by default log records\
    \ would typically be generated on a\n   per-chunk-delivery basis instead of a\
    \ per-content-item-delivery\n   basis.  This impacts the scale of every processing\
    \ step in the\n   logging process (see [CDNI-LOGGING]), including:\n   a.  Logging\
    \ information generation and storing on CDN elements\n       (Surrogate, Request\
    \ Routers, ...)\n   b.  Logging information aggregation within a CDN\n   c.  Logging\
    \ information manipulation (including information\n       protection, filtering,\
    \ update, and rectification)\n   d.  (Where needed) CDNI reformatting of logging\
    \ information (e.g.,\n       reformatting from a CDN-specific format to the CDNI\
    \ Logging\n       interface format for export by the dCDN to the uCDN)\n   e.\
    \  Logging exchange via the CDNI Logging interface\n   f.  (Where needed) Logging\
    \ re-reformatting (e.g., reformatting from\n       the CDNI Logging interface\
    \ format into a log-consuming\n       application)\n   g.  Logging consumption/processing\
    \ (e.g., feed logs into uCDN\n       accounting application, feed logs into uCDN\
    \ reporting system to\n       provide per-CSP views, feed logs into debugging\
    \ tools)\n   Note that there may be multiple instances of steps [f] and [g]\n\
    \   running in parallel.\n   While the CDNI Logging interface is only used to\
    \ perform step [e], we\n   note that its format directly affects steps [d] and\
    \ [f] and that its\n   format also indirectly affects the other steps (for example,\
    \ if the\n   CDNI Logging interface requires per-chunk log records, steps [a],\n\
    \   [b], and [d] cannot operate on a per-HAS-session basis, and they also\n  \
    \ need to operate on a per-chunk basis).\n   This section discusses the main candidate\
    \ approaches identified for\n   CDNI in terms of dealing with HAS with respect\
    \ to logging.\n"
- title: 3.4.2.  Candidate Approaches
  contents:
  - '3.4.2.  Candidate Approaches

    '
- title: '3.4.2.1.  Option 4.1: Do Nothing'
  contents:
  - "3.4.2.1.  Option 4.1: Do Nothing\n   In this approach, nothing is done specifically\
    \ for HAS, so each\n   HAS-chunk delivery is considered, for CDNI logging, as\
    \ a standalone\n   content delivery.  In particular, a separate log record for\
    \ each\n   HAS-chunk delivery is included in the CDNI Logging interface in\n \
    \  step [e] (as defined in Section 3.4.1).  This approach requires that\n   steps\
    \ [a], [b], [c], [d], and [f] also be performed on a per-chunk\n   basis.  This\
    \ approach allows step [g] to be performed either on a\n   per-chunk basis (assuming\
    \ that step [f] maintains per-chunk records)\n   or in a more \"summarized\" manner,\
    \ such as on a per-HAS-session basis\n   (assuming that step [f] summarizes per-chunk\
    \ records into per-HAS-\n   session records).\n   Effect on CDNI interfaces:\n\
    \   o  None\n   Advantages/Drawbacks:\n   +  No information loss (i.e., all details\
    \ of each individual chunk\n      delivery are preserved).  While this full level\
    \ of detail may not\n      be needed for some log-consuming applications (e.g.,\
    \ billing),\n      this full level of detail is likely valuable (and possibly\n\
    \      required) for some log-consuming applications (e.g., debugging)\n   + \
    \ Easier integration (at least in the short term) into existing\n      logging\
    \ tools, since those tools are all capable of handling\n      per-chunk records\n\
    \   +  No extension needed on CDNI interfaces\n   -  High volume of logging information\
    \ to be handled (storing and\n      processing) at every step of the logging process,\
    \ from steps [a]\n      to [g] (while summarization in step [f] is conceivable,\
    \ it may be\n      difficult to achieve in practice without any hints for correlation\n\
    \      in the log records)\n   An interesting question is whether a dCDN could\
    \ use the CDNI Logging\n   interface specified for the \"do nothing\" approach\
    \ to report\n   summarized \"per-session\" log information in the case where the\
    \ dCDN\n   performs such summarization.  The high-level idea would be that when\n\
    \   a dCDN performs HAS log summarization, for its own purposes anyway,\n   this\
    \ dCDN could include in the CDNI Logging interface one or more log\n   entries\
    \ for a HAS session (instead of one entry per HAS chunk) that\n   summarize the\
    \ deliveries of many/all HAS chunks for a session.\n   However, the authors feel\
    \ that when considering the details of this\n   idea, it is not achievable without\
    \ explicit agreement between the\n   uCDN and dCDN about how to perform/interpret\
    \ such summarization.  For\n   example, when a HAS session switches between representations,\
    \ the\n   uCDN and dCDN would have to agree on things such as:\n   o  whether\
    \ the session will be represented by a single log entry\n      (which therefore\
    \ cannot convey the distribution across\n      representations), or multiple log\
    \ entries, such as one entry per\n      contiguous period at a given representation\
    \ (which therefore would\n      be generally very difficult to correlate back\
    \ into a single\n      session)\n   o  what the single URI included in the log\
    \ entry would correspond to\n      (for example, the Manifest File, top-level\
    \ playlist, or next-level\n      playlist, ...)\n   The authors feel that since\
    \ explicit agreement is needed between the\n   uCDN and dCDN on how to perform/interpret\
    \ the summarization, this\n   method can only work if it is specified as part\
    \ of the CDNI Logging\n   interface, in which case it would effectively boil down\
    \ to Option 4.4\n   (full HAS awareness / per-session logs) as defined below.\n\
    \   We note that support by CDNI of a mechanism (independent of HAS)\n   allowing\
    \ the customization of the fields to be reported in log\n   entries by the dCDN\
    \ to the uCDN would mitigate concerns related to\n   the scaling of HAS logging,\
    \ because it ensures that only the\n   necessary subset of fields is actually\
    \ stored, reported, and\n   processed.\n"
- title: '3.4.2.2.  Option 4.2: CDNI Metadata Content Collection ID'
  contents:
  - "3.4.2.2.  Option 4.2: CDNI Metadata Content Collection ID\n   In this approach,\
    \ a \"Content Collection IDentifier (CCID)\" field is\n   distributed through\
    \ the CDNI Metadata interface, and the same CCID\n   value is associated through\
    \ the CDNI Metadata interface with every\n   chunk of the same content collection.\
    \  The CCID value needs to be\n   such that it allows, in combination with the\
    \ content URI, unique\n   identification of a content collection.  When the CCID\
    \ is\n   distributed, and CCID logging is requested from the dCDN, the dCDN\n\
    \   Surrogates are to store the CCID value in the corresponding log\n   entries.\
    \  The objective of this field is to facilitate optional\n   summarization of\
    \ per-chunk records at step [f] into something along\n   the lines of per-HAS-session\
    \ logs, at least for the log-consuming\n   applications that do not require per-chunk\
    \ detailed information (for\n   example, billing).\n   We note that if the dCDN\
    \ happens to have sufficient HAS awareness to\n   be able to generate a \"Session\
    \ IDentifier (Session-ID)\", optionally\n   including such a Session-ID (in addition\
    \ to the CCID) in the\n   per-chunk log record would further facilitate optional\
    \ summarization\n   at step [f].  The Session-ID value to be included in a log\
    \ record by\n   the delivering CDN is such that\n   o  different per-chunk log\
    \ records with the same Session-ID value\n      must correspond to the same user\
    \ session (i.e., delivery of the\n      same content to the same End User at a\
    \ given point in time).\n   o  log records for different chunks of the same user\
    \ session (i.e.,\n      delivery of the same content to the same End User at a\
    \ given point\n      in time) should be provided with the same Session-ID value.\
    \  While\n      undesirable, there may be situations where the delivering CDN\
    \ uses\n      more than one Session-ID value for different per-chunk log records\n\
    \      of a given session -- for example, in scenarios of fail-over or\n     \
    \ load balancing across multiple Surrogates and where the delivering\n      CDN\
    \ does not implement mechanisms to synchronize Session-IDs\n      across Surrogates.\n\
    \   Effect on CDNI interfaces:\n   o  CDNI Metadata interface: One additional\
    \ metadata field (CCID) in\n      the CDNI Metadata interface.  We note that a\
    \ similar content\n      collection ID is discussed for the handling of other\
    \ aspects of\n      HAS and observe that further thought is needed to determine\n\
    \      whether such a CCID should be shared for multiple purposes or\n      should\
    \ be independent.\n   o  CDNI Logging interface: Two additional fields (CCID and\n\
    \      Session-ID) in CDNI logging records.\n   Advantages/Drawbacks:\n   +  No\
    \ information loss (i.e., all details of each individual chunk\n      delivery\
    \ are preserved).  While this full level of detail may not\n      be needed for\
    \ some log-consuming applications (e.g., billing),\n      this full level of detail\
    \ is likely valuable (and possibly\n      required) for some log-consuming applications\
    \ (e.g., debugging)\n   +  Easier integration (at least in the short term) into\
    \ existing\n      logging tools, since those tools are all capable of handling\n\
    \      per-chunk records\n   +  Very minor extension to CDNI interfaces needed\n\
    \   +  Facilitated summarization of records related to a HAS session in\n    \
    \  step [f] and therefore ability to operate on a lower volume of\n      logging\
    \ information in step [g] by log-consuming applications that\n      do not need\
    \ per-chunk record details (e.g., billing) or that need\n      per-session information\
    \ (e.g., analytics)\n   -  High volume of logging information to be handled (storing\
    \ and\n      processing) at every step of the logging process, from steps [a]\n\
    \      to [f]\n"
- title: '3.4.2.3.  Option 4.3: CDNI Logging Interface Compression'
  contents:
  - "3.4.2.3.  Option 4.3: CDNI Logging Interface Compression\n   In this approach,\
    \ a lossless compression technique is applied to the\n   sets of logging records\
    \ (e.g., logging files) for transfer on the\n   CDNI Logging interface.  The objective\
    \ of this approach is to reduce\n   the volume of information to be stored and\
    \ transferred in step [e].\n   Effect on CDNI interfaces:\n   o  One compression\
    \ mechanism to be included in the CDNI Logging\n      interface\n   Advantages/Drawbacks:\n\
    \   +  No information loss (i.e., all details of each individual chunk\n     \
    \ delivery are preserved).  While this full level of detail may not\n      be\
    \ needed for some log-consuming applications (e.g., billing),\n      this full\
    \ level of detail is likely valuable (and possibly\n      required) for some log-consuming\
    \ applications (e.g., debugging)\n   +  Easier integration (at least in the short\
    \ term) into existing\n      logging tools, since those tools are all capable\
    \ of handling\n      per-chunk records\n   +  Small extension to CDNI interfaces\
    \ needed\n   +  Reduced volume of logging information in step [e]\n   +  Compression\
    \ likely to also be applicable to logs for non-HAS\n      content\n   -  High\
    \ volume of logging information to be handled (storing and\n      processing)\
    \ at every step of the logging process, from steps [a]\n      to [g], except step\
    \ [e].\n"
- title: '3.4.2.4.  Option 4.4: Full HAS Awareness/Per-Session Logs'
  contents:
  - "3.4.2.4.  Option 4.4: Full HAS Awareness/Per-Session Logs\n   In this approach,\
    \ HAS awareness is assumed across the CDNs\n   interconnected via CDNI, and the\
    \ necessary information to describe\n   the HAS relationship across all chunks\
    \ of the same content collection\n   is distributed through the CDNI Metadata\
    \ interface.  In this\n   approach, the dCDN leverages the HAS information distributed\
    \ through\n   the CDNI Metadata and their HAS awareness, to do one of the\n  \
    \ following:\n   o  directly generate summarized logging information at logging\n\
    \      information generation time (which has the benefit of operating on\n  \
    \    a lower volume of logging information as early as possible in the\n     \
    \ successive steps of the logging process), or\n   o  (if per-chunk logs are generated)\
    \ accurately correlate and\n      summarize per-chunk logs into per-session logs\
    \ for exchange over\n      the CDNI Logging interface\n   Effect on CDNI interfaces:\n\
    \   o  CDNI Metadata interface: Significant extension to convey HAS\n      relationship\
    \ across chunks of a content collection.  Note that\n      this extension requires\
    \ specific support for every HAS protocol to\n      be supported over the CDNI\
    \ mesh\n   o  CDNI Logging interface: Extension to specify summarized per-\n \
    \     session logs\n   Advantages/Drawbacks:\n   +  Lower volume of logging information\
    \ to be handled (storing and\n      processing) at every step of the logging process,\
    \ from steps [a]\n      to [g]\n   +  Accurate generation of summarized logs because\
    \ of HAS awareness in\n      the dCDN (for example, where the Surrogate is also\
    \ serving the\n      Manifest File(s) for a content collection, the Surrogate\
    \ may be\n      able to extract definitive information about the relationship\n\
    \      between all chunks)\n   -  Very significant extensions to CDNI interfaces\
    \ needed, including\n      specific support for available HAS protocols\n   -\
    \  Very significant additional requirement for HAS awareness on the\n      dCDN\
    \ and for this HAS awareness to be consistent with the defined\n      CDNI logging\
    \ summarization\n   -  Some information loss (i.e., all details of each individual\
    \ chunk\n      delivery are not preserved).  The actual information loss depends\n\
    \      on the summarization approach selected (typically, the lower the\n    \
    \  information loss, the lower the summarization gain), so the right\n      \"\
    sweet spot\" would have to be selected.  While a full level of\n      detail may\
    \ not be needed for some log-consuming applications\n      (e.g., billing), such\
    \ a full level of detail is likely valuable\n      (and possibly required) for\
    \ some log-consuming applications (e.g.,\n      debugging)\n   -  Less easy integration\
    \ (at least in the short term) into existing\n      logging tools, since those\
    \ tools are all capable of handling\n      per-chunk records but may not be capable\
    \ of handling CDNI\n      summarized records\n   -  Challenges in defining behavior\
    \ (and achieving summarization gain)\n      in the presence of load balancing\
    \ of a given HAS session across\n      multiple Surrogates (in the same dCDN or\
    \ a different dCDN)\n"
- title: 3.4.3.  Recommendations
  contents:
  - "3.4.3.  Recommendations\n   Because of its benefits (in particular simplicity,\
    \ universal support\n   by CDNs, and support by all log-consuming applications),\
    \ the authors\n   recommend that per-chunk logging as described in Section 3.4.2.1\n\
    \   (Option 4.1) be supported by the CDNI Logging interface as a \"High\n   Priority\"\
    \ (as defined in [CDNI-REQUIREMENTS]) and be a mandatory\n   capability of CDNs\
    \ implementing CDNI.\n   Because of its very low complexity and its benefits in\
    \ facilitating\n   some useful scenarios (e.g., per-session analytics), we recommend\n\
    \   that the CCID mechanisms and Session-ID mechanism as described in\n   Section\
    \ 3.4.2.2 (Option 4.2) be supported by the CDNI Metadata\n   interface and the\
    \ CDNI Logging interface as a \"Medium Priority\" (as\n   defined in [CDNI-REQUIREMENTS])\
    \ and be an optional capability of CDNs\n   implementing CDNI.\n   The authors\
    \ also recommend that\n   (i)   the ability of the uCDN to request inclusion of\
    \ the CCID and\n         Session-ID fields (in log entries provided by the dCDN)\
    \ be\n         supported by the relevant CDNI interfaces\n   (ii)  the ability\
    \ of the dCDN to include the CCID and Session-ID\n         fields in CDNI log\
    \ entries (when the dCDN is capable of doing\n         so) be indicated in the\
    \ CDNI Logging interface (in line with\n         the \"customizable\" log format\
    \ expected to be defined\n         independently of HAS)\n   (iii) items (i) and\
    \ (ii) be supported as a \"Medium Priority\" (as\n         defined in [CDNI-REQUIREMENTS])\
    \ and be an optional capability\n         of CDNs implementing CDNI\n   When performing\
    \ dCDN selection, a uCDN may want to take into account\n   whether a given dCDN\
    \ is capable of reporting the CCID and Session-ID.\n   Thus, the authors recommend\
    \ that the ability of a dCDN to advertise\n   its support of the optional CCID\
    \ and Session-ID capability be\n   supported by the CDNI Footprint & Capabilities\
    \ Advertisement\n   interface as a \"Medium Priority\" (as defined in [CDNI-REQUIREMENTS]).\n\
    \   The authors also recommend that a generic mechanism (independent of\n   HAS)\
    \ be supported that allows the customization of the fields to be\n   reported\
    \ in logs by CDNs over the CDNI Logging interface -- because\n   of the reduction\
    \ of the logging information volume exchanged across\n   CDNs that it allows by\
    \ removing information that is not of interest\n   to the other CDN.\n   Because\
    \ the following can be achieved with very little complexity and\n   can provide\
    \ some clear storage/communication compression benefits,\n   the authors recommend\
    \ that, in line with the concept of Option 4.3,\n   some existing very common\
    \ compression techniques (e.g., gzip) be\n   supported by the CDNI Logging interface\
    \ as a \"Medium Priority\" (as\n   defined in [CDNI-REQUIREMENTS]) and be an optional\
    \ capability of CDNs\n   implementing CDNI.\n   Because of its complexity, the\
    \ time it would take to understand the\n   trade-offs of candidate summarization\
    \ approaches, and the time it\n   would take to specify the corresponding support\
    \ in the CDNI Logging\n   interface, the authors recommend that the log summarization\
    \ discussed\n   in Section 3.4.2.4 (Option 4.4) not be supported by the CDNI Logging\n\
    \   interface at this stage but that it be kept as a candidate topic of\n   great\
    \ interest for a rechartering of the CDNI WG once the first set\n   of deliverables\
    \ is produced.  At that time, we suggest investigating\n   the notion of complementing\
    \ a \"push style\" CDNI Logging interface\n   that would support summarization\
    \ via an on-demand \"pull type\"\n   interface that would in turn allow a uCDN\
    \ to request the subset of\n   the detailed logging information that it may need\
    \ but that is lost in\n   the summarized pushed information.\n   The authors note\
    \ that while a CDN only needs to adhere to the CDNI\n   Logging interface on its\
    \ external interfaces and can perform logging\n   in a different format within\
    \ the CDN, any possible CDNI logging\n   approach effectively places some constraints\
    \ on the dCDN logging\n   format.  For example, to support the \"do nothing\"\
    \ approach, a CDN\n   needs to perform and retain per-chunk logs.  As another\
    \ example, to\n   support the \"full HAS awareness/per-session logs\" approach,\
    \ the dCDN\n   cannot use a logging format that summarizes data in a way that\
    \ is\n   incompatible with the summarization specified for CDNI logging (e.g.,\n\
    \   summarizes data into a smaller set of information than what is\n   specified\
    \ for CDNI logging).  However, the authors feel that such\n   constraints are\
    \ (i) inevitable, (ii) outweighed by the benefits of a\n   standardized logging\
    \ interface, and (iii) acceptable because, in the\n   case of incompatible summarization,\
    \ most or all CDNs are capable of\n   reverting to per-chunk logging as per the\
    \ \"do nothing\" approach that\n   we recommend as the base mandatory approach.\n"
- title: 3.5.  URL Signing
  contents:
  - "3.5.  URL Signing\n   URL signing is an authorization method for content delivery.\
    \  This is\n   based on embedding the HTTP URL with information that can be\n\
    \   validated to ensure that the request has legitimate access to the\n   content.\
    \  There are two parts: 1) parameters that convey\n   authorization restrictions\
    \ (e.g., source IP address and time period)\n   and/or a protected URL portion,\
    \ and 2) a message digest that confirms\n   the integrity of the URL and authenticates\
    \ the entity that creates\n   the URL.  The authorization parameters can be anything\
    \ agreed upon\n   between the entity that creates the URL and the entity that\
    \ validates\n   the URL.  A key is used to generate the message digest (i.e.,\
    \ sign\n   the URL) and validate the message digest.  The two functions may or\n\
    \   may not use the same key.\n   There are two types of keys used for URL signing:\
    \ asymmetric keys and\n   symmetric keys.  Asymmetric keys always have a key pair\
    \ made up of a\n   public key and private key.  The private key and public key\
    \ are used\n   for signing and validating the URL, respectively.  A symmetric\
    \ key is\n   the same key that is used for both functions.  Regardless of the\
    \ type\n   of key, the entity that validates the URL has to obtain the key.\n\
    \   Distribution of the symmetric key requires security to prevent others\n  \
    \ from taking it.  A public key can be distributed freely, while a\n   private\
    \ key is kept by the URL signer.  The method for key\n   distribution is out of\
    \ scope for this document.\n   URL signing operates in the following way.  A signed\
    \ URL is provided\n   by the content owner (i.e., URL signer) to the user during\
    \ website\n   navigation.  When the user selects the URL, the HTTP request is\
    \ sent\n   to the CDN, which validates that URL before delivering the content.\n"
- title: 3.5.1.  HAS Implications
  contents:
  - "3.5.1.  HAS Implications\n   The authorization lifetime for URL signing is affected\
    \ by HAS.  The\n   expiration time in the authorization parameters of URL signing\
    \ limits\n   the period that the content referenced by the URL can be accessed.\n\
    \   This works for URLs that directly access the media content, but for\n   HAS\
    \ content the Manifest File contains another layer of URLs that\n   reference\
    \ the chunks.  The chunk URL that is embedded in the content\n   may be requested\
    \ some undetermined amount of time later.  The time\n   period between access\
    \ to the Manifest File and chunk retrieval may\n   vary significantly.  The type\
    \ of content (i.e., live or VoD) impacts\n   this time variance as well.  This\
    \ property of HAS content needs to be\n   addressed for URL signing.\n"
- title: 3.5.2.  CDNI Considerations
  contents:
  - "3.5.2.  CDNI Considerations\n   For CDNI, the two types of request routing are\
    \ DNS-based and HTTP-\n   based.  The use of symmetric vs. asymmetric keys for\
    \ URL signing has\n   implications for the trust model between the CSP and CDNs\
    \ and for the\n   key distribution method that can be used.\n   DNS-based request\
    \ routing does not change the URL.  In the case of a\n   symmetric key, the CSP\
    \ and the Authoritative CDN have a business\n   relationship that allows them\
    \ to share a key (or multiple keys) for\n   URL signing.  When the user requests\
    \ content from the Authoritative\n   CDN, the URL is signed by the CSP.  The Authoritative\
    \ CDN (as a uCDN)\n   redirects the request to a dCDN via DNS.  There may be more\
    \ than one\n   level of redirection to reach the delivering CDN.  The user would\n\
    \   obtain the IP address from DNS and send the HTTP request to the\n   delivering\
    \ CDN, which needs to validate the URL.  This requires that\n   the key be distributed\
    \ from the Authoritative CDN to the delivering\n   CDN.  This may be problematic\
    \ when the key is exposed to a delivering\n   CDN that does not have a relationship\
    \ with the CSP.  The combination\n   of DNS-based request routing and symmetric\
    \ key function is a generic\n   issue for URL signing and not specific to HAS\
    \ content.  In the case\n   of asymmetric keys, the CSP signs the URL with its\
    \ private key.  The\n   delivering CDN validates the URL with the associated public\
    \ key.\n   HTTP-based request routing changes the URL during the redirection\n\
    \   procedure.  In the case of a symmetric key, the CSP signs the\n   original\
    \ URL with the same key used by the Authoritative CDN to\n   validate the URL.\
    \  The Authoritative CDN (as a uCDN) redirects the\n   request to the dCDN.  The\
    \ new URL is signed by the uCDN with the same\n   key used by the dCDN to validate\
    \ that URL.  The key used by the uCDN\n   to validate the original URL is expected\
    \ to be different than the key\n   used to sign the new URL.  In the case of asymmetric\
    \ keys, the CSP\n   signs the original URL with its private key.  The Authoritative\
    \ CDN\n   validates that URL with the CSP's public key.  The Authoritative CDN\n\
    \   redirects the request to the dCDN.  The new URL is signed by the uCDN\n  \
    \ with its private key.  The dCDN validates that URL with the uCDN's\n   public\
    \ key.  There may be more than one level of redirection to reach\n   the delivering\
    \ CDN.  The URL signing operation described previously\n   applies at each level\
    \ between the uCDN and dCDN for both symmetric\n   keys and asymmetric keys.\n\
    \   URL signing requires support in most of the CDNI interfaces.  The\n   CDNI\
    \ Metadata interface should specify the content that is subject to\n   URL signing\
    \ and provide information to perform the function.  The\n   dCDN should inform\
    \ the uCDN that it supports URL signing in the\n   asynchronous capabilities information\
    \ advertisement as part of the\n   Request Routing interface.  This allows the\
    \ CDN selection function in\n   request routing to choose the dCDN with URL signing\
    \ capability when\n   the CDNI Metadata of the content requires this authorization\
    \ method.\n   The logging interface provides information on the authorization\n\
    \   method (e.g., URL signing) and related authorization parameters used\n   for\
    \ content delivery.  Having the information in the URL is not\n   sufficient to\
    \ know that the Surrogate enforced the authorization.\n   URL signing has no impact\
    \ on the control interface.\n"
- title: '3.5.3.  Option 5.1: Do Nothing'
  contents:
  - "3.5.3.  Option 5.1: Do Nothing\n   This approach means that the CSP can only\
    \ perform URL signing for the\n   top-level Manifest File.  The top-level Manifest\
    \ File contains chunk\n   URLs or lower-level Manifest File URLs, which are not\
    \ modified (i.e.,\n   no URL signing for the embedded URLs).  In essence, the\
    \ lower-level\n   Manifest Files and chunks are delivered without content access\n\
    \   authorization.\n   Effect on CDNI interfaces:\n   o  None\n   Advantages/Drawbacks:\n\
    \   +  Top-level Manifest File access is protected\n   +  The uCDN and dCDN do\
    \ not need to be aware of HAS content\n   -  Lower-level Manifest Files and chunks\
    \ are not protected, making\n      this approach unqualified for content access\
    \ authorization\n"
- title: '3.5.4.  Option 5.2: Flexible URL Signing by CSP'
  contents:
  - "3.5.4.  Option 5.2: Flexible URL Signing by CSP\n   In addition to URL signing\
    \ for the top-level Manifest File, the CSP\n   performs flexible URL signing for\
    \ the lower-level Manifest Files and\n   chunks.  For each HAS session, the top-level\
    \ Manifest File contains\n   signed chunk URLs or signed lower-level Manifest\
    \ File URLs for the\n   specific session.  The lower-level Manifest File contains\
    \ session-\n   based signed chunk URLs.  The CSP generates the Manifest Files\n\
    \   dynamically for the session.  The chunk (segment/fragment) is\n   delivered\
    \ with content access authorization using flexible URL\n   signing, which protects\
    \ the invariant portion of the URL.  A\n   \"segment\" URL (e.g., HLS) is individually\
    \ signed for the invariant\n   URL portion (relative URL) or the entire URL (absolute\
    \ URL without\n   redirection) in the Manifest File.  A \"fragment\" URL (e.g.,\
    \ HTTP\n   Smooth Streaming) is signed for the invariant portion of the template\n\
    \   URL in the Manifest File.  More details are provided later in this\n   section.\
    \  The URL signing expiration time for the chunk needs to be\n   long enough to\
    \ play the video.  There are implications related to\n   signing the URLs in the\
    \ Manifest File.  For live content, the\n   Manifest Files are requested at a\
    \ high frequency.  For VoD content,\n   the Manifest File may be quite large.\
    \  URL signing can add more\n   computational load and delivery latency in high-volume\
    \ cases.\n   For HAS content, the Manifest File contains the relative URL,\n \
    \  absolute URL without redirection, or absolute URL with redirection\n   for\
    \ specifying the chunk location.  Signing the chunk URL requires\n   that the\
    \ CSP know the portion of the URL that remains when the\n   content is requested\
    \ from the delivering CDN Surrogate.\n   For absolute URLs without redirection,\
    \ the CSP knows that the chunk\n   URL is explicitly linked with the delivering\
    \ CDN Surrogate and can\n   sign the URL based on that information.  Since the\
    \ entire URL is set\n   and does not change, the Surrogate can validate the URL.\
    \  The CSP and\n   the delivering CDN are expected to have a business relationship\
    \ in\n   this case, and so either symmetric keys or asymmetric keys can be\n \
    \  used for URL signing.\n   For relative URLs, the URL of the Manifest File provides\
    \ the root\n   location.  The method of request routing affects the URL used to\n\
    \   ultimately request the chunk from the delivering CDN Surrogate.  For\n   DNS,\
    \ the original URL does not change.  This allows the CSP to sign\n   the chunk\
    \ URL based on the Manifest File URL and the relative URL.\n   For HTTP, the URL\
    \ changes during redirection.  In this case, the CSP\n   does not know the redirected\
    \ URL that will be used to request the\n   Manifest File.  This uncertainty makes\
    \ it impossible to accurately\n   sign the chunk URLs in the Manifest File.  Basically,\
    \ URL signing\n   using this reference method \"as is\" for protection of the\
    \ entire URL\n   is not supported.  However, instead of signing the entire URL,\
    \ the\n   CSP signs the relative URL (i.e., the invariant portion of the URL)\n\
    \   and conveys the protected portion in the authorization parameters\n   embedded\
    \ in the chunk URL.  This approach works in the same way as\n   absolute URLs\
    \ without redirection, except that the HOST part and\n   (part of) the PATH part\
    \ of the URL are not signed and validated.  The\n   security level should remain\
    \ the same, as content access\n   authorization ensures that the user that requested\
    \ the content has\n   the proper credentials.  This scheme does not seem to compromise\
    \ the\n   authorization model, since the resource is still protected by the\n\
    \   authorization parameters and message digest.  Further evaluation of\n   security\
    \ might be helpful.\n   For absolute URLs with redirection, the method of request\
    \ routing\n   affects the URL used to ultimately request the chunk from the\n\
    \   delivering CDN Surrogate.  This case has the same conditions as those\n  \
    \ indicated above for the relative URL.  The difference is that the URL\n   is\
    \ for the chunk instead of the Manifest File.  For DNS, the chunk\n   URL does\
    \ not change and can be signed by the CSP.  For HTTP, the URL\n   used to deliver\
    \ the chunk is unknown to the CSP.  In this case, the\n   CSP cannot sign the\
    \ URL, and this method of reference for the chunk\n   is not supported.\n   Effect\
    \ on CDNI interfaces:\n   o  Requires the ability to exclude the variant portion\
    \ of the URL in\n      the signing process.  (NOTE: Is this issue specific to\
    \ URL signing\n      support for HAS content and not CDNI?)\n   Advantages/Drawbacks:\n\
    \   +  The Manifest File and chunks are protected\n   +  The uCDN and dCDN do\
    \ not need to be aware of HAS content\n   +  DNS-based request routing with asymmetric\
    \ keys and HTTP-based\n      request routing for relative URLs and absolute URLs\
    \ without\n      redirection work\n   -  The CSP has to generate Manifest Files\
    \ with session-based signed\n      URLs and becomes involved in content access\
    \ authorization for\n      every HAS session\n   -  Manifest Files are not cacheable\n\
    \   -  DNS-based request routing with symmetric keys may be problematic\n    \
    \  due to the need for transitive trust between the CSP and\n      delivering\
    \ CDN\n   -  HTTP-based request routing for absolute URLs with redirection does\n\
    \      not work, because the URL used by the delivering CDN Surrogate is\n   \
    \   unknown to the CSP\n"
- title: '3.5.5.  Option 5.3: Flexible URL Signing by uCDN'
  contents:
  - "3.5.5.  Option 5.3: Flexible URL Signing by uCDN\n   This is similar to the previous\
    \ section, with the exception that the\n   uCDN performs flexible URL signing\
    \ for the lower-level Manifest Files\n   and chunks.  URL signing for the top-level\
    \ Manifest File is still\n   provided by the CSP.\n   Effect on CDNI interfaces:\n\
    \   o  Requires the ability to exclude the variant portion of the URL in\n   \
    \   the signing process.  (NOTE: Is this issue specific to URL signing\n     \
    \ support for HAS content and not CDNI?)\n   Advantages/Drawbacks:\n   +  The\
    \ Manifest File and chunks are protected\n   +  The CSP does not need to be involved\
    \ in content access\n      authorization for every HAS session\n   +  The dCDN\
    \ does not need to be aware of HAS content\n   +  DNS-based request routing with\
    \ asymmetric keys and HTTP-based\n      request routing for relative URLs and\
    \ absolute URLs without\n      redirection work\n   -  The uCDN has to generate\
    \ Manifest Files with session-based signed\n      URLs and becomes involved in\
    \ content access authorization for\n      every HAS session\n   -  Manifest Files\
    \ are not cacheable\n   -  The Manifest File needs to be distributed through the\
    \ uCDN\n   -  DNS-based request routing with symmetric keys may be problematic\n\
    \      due to the need for transitive trust between the uCDN and\n      non-adjacent\
    \ delivering CDN\n   -  HTTP-based request routing for absolute URLs with redirection\
    \ does\n      not work, because the URL used by the delivering CDN Surrogate is\n\
    \      unknown to the uCDN\n"
- title: '3.5.6.  Option 5.4: Authorization Group ID and HTTP Cookie'
  contents:
  - "3.5.6.  Option 5.4: Authorization Group ID and HTTP Cookie\n   Based on the Authorization\
    \ Group ID metadata, the CDN validates the\n   URL signing or validates the HTTP\
    \ cookie for request of content in\n   the group.  The CSP performs URL signing\
    \ for the top-level Manifest\n   File.  The top-level Manifest File contains lower-level\
    \ Manifest File\n   URLs or chunk URLs.  The lower-level Manifest Files and chunks\
    \ are\n   delivered with content access authorization using an HTTP cookie that\n\
    \   contains session state associated with authorization of the top-level\n  \
    \ Manifest File.  The Group ID metadata is used to associate the\n   related content\
    \ (i.e., Manifest Files and chunks).  It also specifies\n   content (e.g., regexp\
    \ method) that needs to be validated by either\n   URL signing or an HTTP cookie.\
    \  Note that the creator of the metadata\n   is HAS aware.  The duration of the\
    \ chunk access may be included in\n   the URL signing of the top-level Manifest\
    \ File and set in the cookie.\n   Alternatively, the access control duration could\
    \ be provided by the\n   CDNI Metadata interface.\n   Effect on CDNI interfaces:\n\
    \   o  CDNI Metadata interface: Authorization Group ID metadata\n      identifies\
    \ the content that is subject to validation of URL\n      signing or validation\
    \ of an HTTP cookie associated with the URL\n      signing\n   o  CDNI Logging\
    \ interface: Report the authorization method used to\n      validate the request\
    \ for content delivery\n   Advantages/Drawbacks:\n   +  The Manifest File and\
    \ chunks are protected\n   +  The CDN does not need to be aware of HAS content\n\
    \   +  The CSP does not need to change the Manifest Files\n   -  Authorization\
    \ Group ID metadata is required (i.e., CDNI Metadata\n      interface enhancement)\n\
    \   -  Requires the use of an HTTP cookie, which may not be acceptable in\n  \
    \    some environments (e.g., where some targeted User Agents do not\n      support\
    \ HTTP cookies)\n   -  The Manifest File has to be delivered by the Surrogate\n"
- title: '3.5.7.  Option 5.5: HAS Awareness with HTTP Cookie in CDN'
  contents:
  - "3.5.7.  Option 5.5: HAS Awareness with HTTP Cookie in CDN\n   The CDN is aware\
    \ of HAS content and uses URL signing and HTTP cookies\n   for content access\
    \ authorization.  URL signing is fundamentally about\n   authorizing access to\
    \ a content item or its specific content\n   collections (representations) for\
    \ a specific user during a time\n   period, possibly also using some other criteria.\
    \  A chunk is an\n   instance of the sets of chunks referenced by the Manifest\
    \ File for\n   the content item or its specific content collections.  This\n \
    \  relationship means that once the dCDN has authorized the Manifest\n   File,\
    \ it can assume that the associated chunks are implicitly\n   authorized.  The\
    \ new function for the CDN is to link the Manifest\n   File with the chunks for\
    \ the HTTP session.  This can be accomplished\n   by using an HTTP cookie for\
    \ the HAS session.\n   After validating the URL and detecting that the requested\
    \ content is\n   a top-level Manifest File, the delivering CDN Surrogate sets\
    \ an HTTP\n   cookie with a signed session token for the HTTP session.  When a\n\
    \   request for a lower-level Manifest File or chunk arrives, the\n   Surrogate\
    \ confirms that the HTTP cookie value contains the correct\n   session token.\
    \  If so, the lower-level Manifest File or chunk is\n   delivered in accordance\
    \ with the transitive authorization mechanism.\n   The duration of the chunk access\
    \ may be included in the URL signing\n   of the top-level Manifest File and set\
    \ in the cookie.  The details of\n   the operation are left to be determined later.\n\
    \   Effect on CDNI interfaces:\n   o  CDNI Metadata interface: New metadata identifies\
    \ the content that\n      is subject to validation of URL signing and information\
    \ in the\n      cookie for the type of HAS content\n   o  Request Routing interface:\
    \ The dCDN should inform the uCDN that it\n      supports URL signing for known\
    \ HAS content types in the\n      asynchronous capabilities information advertisement.\
    \  This allows\n      the CDN selection function in request routing to choose\
    \ the\n      appropriate dCDN when the CDNI Metadata identifies the content\n\
    \   o  CDNI Logging interface: Report the authorization method used to\n     \
    \ validate the request for content delivery\n   Advantages/Drawbacks:\n   +  The\
    \ Manifest File and chunks are protected\n   +  The CSP does not need to change\
    \ the Manifest Files\n   -  Requires full HAS awareness on the part of the uCDN\
    \ and dCDN\n   -  Requires extensions to CDNI interfaces\n   -  Requires the use\
    \ of an HTTP cookie, which may not be acceptable in\n      some environments (e.g.,\
    \ where some targeted User Agents do not\n      support HTTP cookies)\n   -  The\
    \ Manifest File has to be delivered by the Surrogate\n"
- title: '3.5.8.  Option 5.6: HAS Awareness with Manifest File in CDN'
  contents:
  - "3.5.8.  Option 5.6: HAS Awareness with Manifest File in CDN\n   The CDN is aware\
    \ of HAS content and uses URL signing for content\n   access authorization of\
    \ Manifest Files and chunks.  The CDN generates\n   or rewrites the Manifest Files\
    \ and learns about the chunks based on\n   the Manifest File.  The embedded URLs\
    \ in the Manifest File are signed\n   by the CDN.  The duration of the chunk access\
    \ may be included in the\n   URL signing.  The details of the operation are left\
    \ to be determined\n   later.  Since this approach is based on signing the URLs\
    \ in the\n   Manifest File, the implications for live and VoD content mentioned\
    \ in\n   Section 3.5.4 apply.\n   Effect on CDNI interfaces:\n   o  CDNI Metadata\
    \ interface: New metadata identifies the content that\n      is subject to validation\
    \ of URL signing and information in the\n      cookie for the type of HAS content\n\
    \   o  Request Routing interface: The dCDN should inform the uCDN that it\n  \
    \    supports URL signing for known HAS content types in the\n      asynchronous\
    \ capabilities information advertisement.  This allows\n      the CDN selection\
    \ function in request routing to choose the\n      appropriate dCDN when the CDNI\
    \ Metadata identifies the content\n   o  CDNI Logging interface: Report the authorization\
    \ method used to\n      validate the request for content delivery\n   Advantages/Drawbacks:\n\
    \   +  The Manifest File and chunks are protected\n   +  The CSP does not need\
    \ to change the Manifest Files\n   -  Requires full HAS awareness on the part\
    \ of the uCDN and dCDN\n   -  Requires extensions to CDNI interfaces\n   -  Requires\
    \ the CDN to generate or rewrite the Manifest File\n   -  The Manifest File has\
    \ to be delivered by the Surrogate\n"
- title: 3.5.9.  Recommendations
  contents:
  - "3.5.9.  Recommendations\n   The authors consider Option 5.1 (do nothing) unsuitable\
    \ for access\n   control of HAS content.\n   Where the HTTP cookie mechanism is\
    \ supported by the targeted User\n   Agents and the security requirements can\
    \ be addressed through the\n   proper use of HTTP cookies, the authors recommend\
    \ using Option 5.4\n   (Authorization Group ID and HTTP cookie) and therefore\
    \ that\n   Option 5.4 be supported by the CDNI solution.  This method does not\n\
    \   require Manifest File manipulation, as Manifest File manipulation may\n  \
    \ be a significant obstacle to deployment.  Otherwise, the authors\n   recommend\
    \ that Option 5.2 (flexible URL signing by the CSP) or\n   Option 5.3 (flexible\
    \ URL signing by the uCDN) be used and therefore\n   that flexible URL signing\
    \ be supported by the CDNI solution.\n   Options 5.2 and 5.3 protect all the content,\
    \ do not require that the\n   dCDN be aware of HAS, do not impact CDNI interfaces,\
    \ support all\n   different types of devices, and support the common cases of\
    \ request\n   routing for HAS content (i.e., DNS-based request routing with\n\
    \   asymmetric keys and HTTP-based request routing for relative URLs).\n   Options\
    \ 5.5 and 5.6 (HAS awareness in CDNs using HTTP cookies or\n   Manifest Files)\
    \ have some advantages that should be considered for\n   future support (e.g.,\
    \ a CDN that is aware of HAS content can manage\n   the content more efficiently\
    \ in a broader context).  Content\n   distribution, storage, delivery, deletion,\
    \ access authorization, etc.\n   can all benefit.  Including HAS awareness as\
    \ part of the current CDNI\n   charter, however, would almost certainly delay\
    \ the CDNI WG's\n   milestones, and the authors therefore do not recommend it\
    \ right now.\n"
- title: 3.6.  Content Purge
  contents:
  - "3.6.  Content Purge\n   At some point in time, a uCDN might want to remove content\
    \ from a\n   dCDN.  With regular content, this process can be relatively\n   straightforward;\
    \ a uCDN will typically send the request for content\n   removal to the dCDN,\
    \ including a reference to the content that it\n   wants to remove (e.g., in the\
    \ form of a URL).  However, due to the\n   fact that HAS content consists of large\
    \ groups of files, things might\n   be more complex.  Section 3.1 described a\
    \ number of different\n   scenarios for doing file management on these groups\
    \ of files, while\n   Section 3.2 listed the options for performing content acquisition\
    \ on\n   these content collections.  This section presents the options for\n \
    \  requesting a content purge for the removal of a content collection\n   from\
    \ a dCDN.\n"
- title: '3.6.1.  Option 6.1: No HAS Awareness'
  contents:
  - "3.6.1.  Option 6.1: No HAS Awareness\n   The most straightforward way to signal\
    \ content purge requests is to\n   just send a single purge request for every\
    \ file that makes up the\n   content collection.  While this method is very simple\
    \ and does not\n   require HAS awareness, it obviously creates signaling overhead\n\
    \   between the uCDN and dCDN, since a reference is to be provided for\n   each\
    \ content chunk to be purged.\n   Effect on CDNI interfaces:\n   o  None\n   Advantages/Drawbacks\
    \ (apart from those already listed under\n   Option 3.3):\n   +  Does not require\
    \ changes to the CDNI interfaces or HAS awareness\n   -  Requires individual purge\
    \ request for every file making up a\n      content collection (or, alternatively,\
    \ requires the ability to\n      convey references to all the chunks making up\
    \ a content collection\n      inside a purge request), which creates signaling\
    \ overhead\n"
- title: '3.6.2.  Option 6.2: Purge Identifiers'
  contents:
  - "3.6.2.  Option 6.2: Purge Identifiers\n   There exists a potentially more efficient\
    \ method for performing\n   content removal of large numbers of files simultaneously.\
    \  By\n   including a \"Purge IDentifier (Purge-ID)\" in the metadata of a\n \
    \  particular file, it is possible to virtually group together different\n   files\
    \ making up a content collection.  A Purge-ID can take the form\n   of an arbitrary\
    \ number or string that is communicated as part of the\n   CDNI Metadata interface,\
    \ and that is the same for all files making up\n   a particular content item but\
    \ different across different content\n   items.  If a uCDN wants to request that\
    \ the dCDN remove a content\n   collection, it can send a purge request containing\
    \ this Purge-ID.\n   The dCDN can then remove all files that share the corresponding\n\
    \   Purge-ID.\n   The advantage of this method is that it is relatively simple\
    \ to use\n   by both the dCDN and uCDN and requires only limited additions to\
    \ the\n   CDNI Metadata interface and CDNI Control interface.\n   The Purge-ID\
    \ is similar to the CCID discussed in Section 3.4.2.2 for\n   handling HAS logging,\
    \ and we note that further thought is needed to\n   determine whether the CCID\
    \ and Purge-ID should be collapsed into a\n   single element or remain separate\
    \ elements.\n   Effect on CDNI interfaces:\n   o  CDNI Metadata interface: Add\
    \ metadata field for indicating\n      Purge-ID\n   o  CDNI Control interface:\
    \ Add functionality to convey a Purge-ID in\n      purge requests\n   Advantages/Drawbacks:\n\
    \   +  Allows for efficient purging of content from a dCDN\n   +  Does not require\
    \ HAS awareness on the part of a dCDN\n"
- title: 3.6.3.  Recommendations
  contents:
  - "3.6.3.  Recommendations\n   Based on the listed pros and cons, the authors recommend\
    \ that the WG\n   have mandatory support for Option 1.1 (do nothing).  In addition,\n\
    \   because of its very low complexity and its benefit in facilitating\n   low-overhead\
    \ purge of large numbers of content items simultaneously,\n   the authors recommend\
    \ that Purge-IDs (Option 6.2; see Section 3.6.2)\n   be supported as an optional\
    \ feature by the CDNI Metadata interface\n   and the CDNI Control interface.\n"
- title: 3.7.  Other Issues
  contents:
  - "3.7.  Other Issues\n   This section includes some HAS-specific issues that came\
    \ up during\n   the discussion of this document and that do not fall under any\
    \ of the\n   categories discussed in the previous sections.\n   -  As described\
    \ in Section 2.2, a Manifest File might be delivered by\n      either a CDN or\
    \ the CSP and thereby be invisible to the CDN\n      delivering the chunks.  Obviously,\
    \ the decision of whether the CDN\n      or CSP delivers the Manifest File is\
    \ made between the uCDN and\n      CSP, and the dCDN has no choice in the matter.\
    \  However, some\n      dCDNs might only want to offer their services in the cases\
    \ where\n      they have access to the Manifest File (e.g., because their\n  \
    \    internal architecture is based on the knowledge inside the\n      Manifest\
    \ File).  For these cases, it might be useful to include a\n      field in the\
    \ CDNI Capability Advertisement to allow dCDNs to\n      advertise the fact that\
    \ they require access to the Manifest File.\n"
- title: 4.  Security Considerations
  contents:
  - "4.  Security Considerations\n   This document does not discuss security issues\
    \ related to HTTP or HAS\n   delivery, as these topics are expected to be discussed\
    \ in the CDNI WG\n   documents, including [CDNI-FRAMEWORK].\n"
- title: 5.  Acknowledgements
  contents:
  - "5.  Acknowledgements\n   The authors would like to thank Kevin Ma, Stef van der\
    \ Ziel, Bhaskar\n   Bhupalam, Mahesh Viveganandhan, Larry Peterson, Ben Niven-Jenkins,\n\
    \   and Matt Caulfield for their valuable contributions to this document.\n"
- title: 6.  References
  contents:
  - '6.  References

    '
- title: 6.1.  Normative References
  contents:
  - "6.1.  Normative References\n   [RFC6707]  Niven-Jenkins, B., Le Faucheur, F.,\
    \ and N. Bitar, \"Content\n              Distribution Network Interconnection\
    \ (CDNI) Problem\n              Statement\", RFC 6707, September 2012.\n"
- title: 6.2.  Informative References
  contents:
  - "6.2.  Informative References\n   [CDNI-FRAMEWORK]\n              Peterson, L.,\
    \ Ed., and B. Davie, \"Framework for CDN\n              Interconnection\", Work\
    \ in Progress, February 2013.\n   [CDNI-LOGGING]\n              Bertrand, G.,\
    \ Ed., Stephan, E., Peterkofsky, R., Le\n              Faucheur, F., and P. Grochocki,\
    \ \"CDNI Logging Interface\",\n              Work in Progress, October 2012.\n\
    \   [CDNI-REQUIREMENTS]\n              Leung, K., Ed., and Y. Lee, Ed., \"Content\
    \ Distribution\n              Network Interconnection (CDNI) Requirements\", Work\
    \ in\n              Progress, July 2013.\n   [RFC3986]  Berners-Lee, T., Fielding,\
    \ R., and L. Masinter, \"Uniform\n              Resource Identifier (URI): Generic\
    \ Syntax\", STD 66,\n              RFC 3986, January 2005.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Ray van Brandenburg\n   TNO\n   Brassersplein 2\n   Delft\
    \  2612CT\n   the Netherlands\n   Phone: +31-88-866-7000\n   EMail: ray.vanbrandenburg@tno.nl\n\
    \   Oskar van Deventer\n   TNO\n   Brassersplein 2\n   Delft  2612CT\n   the Netherlands\n\
    \   Phone: +31-88-866-7000\n   EMail: oskar.vandeventer@tno.nl\n   Francois Le\
    \ Faucheur\n   Cisco Systems\n   E.Space Park - Batiment D\n   6254 Allee des\
    \ Ormes - BP 1200\n   06254 Mougins cedex\n   France\n   Phone: +33 4 97 23 26\
    \ 19\n   EMail: flefauch@cisco.com\n   Kent Leung\n   Cisco Systems\n   170 West\
    \ Tasman Drive\n   San Jose, CA  95134\n   USA\n   Phone: +1 408-526-5030\n  \
    \ EMail: kleung@cisco.com\n"
