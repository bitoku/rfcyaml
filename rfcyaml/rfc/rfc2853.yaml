- title: __initial_text__
  contents:
  - '         Generic Security Service API Version 2 : Java Bindings

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2000).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   The Generic Security Services Application Program Interface (GSS-API)\n\
    \   offers application programmers uniform access to security services\n   atop\
    \ a variety of underlying cryptographic mechanisms. This document\n   specifies\
    \ the Java bindings for GSS-API which is described at a\n   language independent\
    \ conceptual level in RFC 2743 [GSSAPIv2-UPDATE].\n   The GSS-API allows a caller\
    \ application to authenticate a principal\n   identity, to delegate rights to\
    \ a peer, and to apply security\n   services such as confidentiality and integrity\
    \ on a per-message\n   basis. Examples of security mechanisms defined for GSS-API\
    \ are The\n   Simple Public-Key GSS-API Mechanism [SPKM] and The Kerberos Version\
    \ 5\n   GSS-API Mechanism [KERBV5].\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . .   5\n   2.  GSS-API Operational Paradigm . . . . . . . . . . . . . .\
    \ .   6\n   3.  Additional Controls  . . . . . . . . . . . . . . . . . . .   8\n\
    \   3.1.  Delegation . . . . . . . . . . . . . . . . . . . . . . .   9\n   3.2.\
    \  Mutual Authentication  . . . . . . . . . . . . . . . . .  10\n   3.3.  Replay\
    \ and Out-of-Sequence Detection . . . . . . . . . .  10\n   3.4.  Anonymous Authentication\
    \ . . . . . . . . . . . . . . . .  11\n   3.5.  Confidentiality  . . . . . . .\
    \ . . . . . . . . . . . . .  12\n   3.6.  Inter-process Context Transfer . . .\
    \ . . . . . . . . . .  12\n   3.7.  The Use of Incomplete Contexts . . . . . .\
    \ . . . . . . .  13\n   4.  Calling Conventions  . . . . . . . . . . . . . . .\
    \ . . . .  13\n   4.1.  Package Name . . . . . . . . . . . . . . . . . . . . .\
    \ .  13\n   4.2.  Provider Framework . . . . . . . . . . . . . . . . . . .  13\n\
    \   4.3.  Integer types  . . . . . . . . . . . . . . . . . . . . .  14\n   4.4.\
    \  Opaque Data types  . . . . . . . . . . . . . . . . . . .  14\n   4.5.  Strings\
    \  . . . . . . . . . . . . . . . . . . . . . . . .  15\n   4.6.  Object Identifiers\
    \ . . . . . . . . . . . . . . . . . . .  15\n   4.7.  Object Identifier Sets .\
    \ . . . . . . . . . . . . . . . .  15\n   4.8.  Credentials  . . . . . . . . .\
    \ . . . . . . . . . . . . .  16\n   4.9.  Contexts . . . . . . . . . . . . . .\
    \ . . . . . . . . . .  18\n   4.10.  Authentication tokens . . . . . . . . . .\
    \ . . . . . . .  18\n   4.11.  Interprocess tokens . . . . . . . . . . . . . .\
    \ . . . .  18\n   4.12.  Error Reporting . . . . . . . . . . . . . . . . . . .\
    \ .  19\n   4.12.1.  GSS status codes  . . . . . . . . . . . . . . . . . .  19\n\
    \   4.12.2.  Mechanism-specific status codes . . . . . . . . . . .  21\n   4.12.3.\
    \  Supplementary status codes  . . . . . . . . . . . . .  21\n   4.13.  Names\
    \ . . . . . . . . . . . . . . . . . . . . . . . . .  22\n   4.14.  Channel Bindings\
    \  . . . . . . . . . . . . . . . . . . .  25\n   4.15.  Stream Objects  . . .\
    \ . . . . . . . . . . . . . . . . .  26\n   4.16.  Optional Parameters . . . .\
    \ . . . . . . . . . . . . . .  26\n   5.  Introduction to GSS-API Classes and\
    \ Interfaces . . . . . .  26\n   5.1.  GSSManager class . . . . . . . . . . .\
    \ . . . . . . . . .  26\n   5.2.  GSSName interface  . . . . . . . . . . . . .\
    \ . . . . . .  27\n   5.3.  GSSCredential interface  . . . . . . . . . . . . .\
    \ . . .  28\n   5.4.  GSSContext interface . . . . . . . . . . . . . . . . . .\
    \  28\n   5.5.  MessageProp class  . . . . . . . . . . . . . . . . . . .  30\n\
    \   5.6.  GSSException class . . . . . . . . . . . . . . . . . . .  30\n   5.7.\
    \  Oid class  . . . . . . . . . . . . . . . . . . . . . . .  30\n   5.8.  ChannelBinding\
    \ class . . . . . . . . . . . . . . . . . .  31\n   6.  Detailed GSS-API Class\
    \ Description . . . . . . . . . . . .  31\n   6.1.  public abstract class GSSManager\
    \ . . . . . . . . . . . .  31\n   6.1.1.  Example Code . . . . . . . . . . . .\
    \ . . . . . . . . .  32\n   6.1.2.  getInstance  . . . . . . . . . . . . . . .\
    \ . . . . . .  33\n   6.1.3.  getMechs . . . . . . . . . . . . . . . . . . . .\
    \ . . .  33\n   6.1.4.  getNamesForMech  . . . . . . . . . . . . . . . . . . .\
    \  33\n   6.1.5.  getMechsForName  . . . . . . . . . . . . . . . . . . .  33\n\
    \   6.1.6.  createName . . . . . . . . . . . . . . . . . . . . . .  33\n   6.1.7.\
    \  createName . . . . . . . . . . . . . . . . . . . . . .  34\n   6.1.8.  createName\
    \ . . . . . . . . . . . . . . . . . . . . . .  35\n   6.1.9.  createName . . .\
    \ . . . . . . . . . . . . . . . . . . .  35\n   6.1.10.  createCredential  . .\
    \ . . . . . . . . . . . . . . . .  36\n   6.1.11.  createCredential  . . . . .\
    \ . . . . . . . . . . . . .  36\n   6.1.12.  createCredential  . . . . . . . .\
    \ . . . . . . . . . .  37\n   6.1.13.  createContext . . . . . . . . . . . . .\
    \ . . . . . . .  37\n   6.1.14.  createContext . . . . . . . . . . . . . . . .\
    \ . . . .  38\n   6.1.15.  createContext . . . . . . . . . . . . . . . . . . .\
    \ .  38\n   6.1.16.  addProviderAtFront  . . . . . . . . . . . . . . . . .  38\n\
    \   6.1.16.1.  Example Code  . . . . . . . . . . . . . . . . . . .  39\n   6.1.17.\
    \  addProviderAtEnd  . . . . . . . . . . . . . . . . . .  40\n   6.1.17.1.  Example\
    \ Code  . . . . . . . . . . . . . . . . . . .  41\n   6.2.  public interface GSSName\
    \ . . . . . . . . . . . . . . . .  42\n   6.2.1.  Example Code . . . . . . . .\
    \ . . . . . . . . . . . . .  42\n   6.2.2.  Static Constants . . . . . . . . .\
    \ . . . . . . . . . .  43\n   6.2.3.  equals . . . . . . . . . . . . . . . . .\
    \ . . . . . . .  44\n   6.2.4.  equals . . . . . . . . . . . . . . . . . . . .\
    \ . . . .  44\n   6.2.5.  canonicalize . . . . . . . . . . . . . . . . . . . .\
    \ .  44\n   6.2.6.  export . . . . . . . . . . . . . . . . . . . . . . . .  45\n\
    \   6.2.7.  toString . . . . . . . . . . . . . . . . . . . . . . .  45\n   6.2.8.\
    \  getStringNameType  . . . . . . . . . . . . . . . . . .  45\n   6.2.9.  isAnonymous\
    \  . . . . . . . . . . . . . . . . . . . . .  45\n   6.2.10.  isMN  . . . . .\
    \ . . . . . . . . . . . . . . . . . . .  45\n   6.3.  public interface GSSCredential\
    \ implements Cloneable  . .  45\n   6.3.1.  Example Code . . . . . . . . . . .\
    \ . . . . . . . . . .  46\n   6.3.2.  Static Constants . . . . . . . . . . . .\
    \ . . . . . . .  47\n   6.3.3.  dispose  . . . . . . . . . . . . . . . . . . .\
    \ . . . .  48\n   6.3.4.  getName  . . . . . . . . . . . . . . . . . . . . . .\
    \ .  48\n   6.3.5.  getName  . . . . . . . . . . . . . . . . . . . . . . .  48\n\
    \   6.3.6.  getRemainingLifetime . . . . . . . . . . . . . . . . .  48\n   6.3.7.\
    \  getRemainingInitLifetime . . . . . . . . . . . . . . .  49\n   6.3.8.  getRemainingAcceptLifetime\
    \ . . . . . . . . . . . . . .  49\n   6.3.9.  getUsage . . . . . . . . . . . .\
    \ . . . . . . . . . . .  49\n   6.3.10.  getUsage  . . . . . . . . . . . . . .\
    \ . . . . . . . .  49\n   6.3.11.  getMechs  . . . . . . . . . . . . . . . . .\
    \ . . . . .  50\n   6.3.12.  add . . . . . . . . . . . . . . . . . . . . . . .\
    \ . .  50\n   6.3.13.  equals  . . . . . . . . . . . . . . . . . . . . . . . \
    \ 51\n   6.4.  public interface GSSContext  . . . . . . . . . . . . . .  51\n\
    \   6.4.1.  Example Code . . . . . . . . . . . . . . . . . . . . .  52\n   6.4.2.\
    \  Static Constants . . . . . . . . . . . . . . . . . . .  54\n   6.4.3.  initSecContext\
    \ . . . . . . . . . . . . . . . . . . . .  54\n   6.4.3.1.  Example Code . . .\
    \ . . . . . . . . . . . . . . . . .  55\n   6.4.4.  initSecContext . . . . . .\
    \ . . . . . . . . . . . . . .  56\n   6.4.4.1.  Example Code . . . . . . . . .\
    \ . . . . . . . . . . .  56\n   6.4.5.  acceptSecContext . . . . . . . . . . .\
    \ . . . . . . . .  57\n   6.4.5.1.  Example Code . . . . . . . . . . . . . . .\
    \ . . . . .  58\n   6.4.6.  acceptSecContext . . . . . . . . . . . . . . . . .\
    \ . .  59\n   6.4.6.1.  Example Code . . . . . . . . . . . . . . . . . . . . \
    \ 59\n   6.4.7.  isEstablished  . . . . . . . . . . . . . . . . . . . .  60\n\
    \   6.4.8.  dispose  . . . . . . . . . . . . . . . . . . . . . . .  60\n   6.4.9.\
    \  getWrapSizeLimit . . . . . . . . . . . . . . . . . . .  61\n   6.4.10.  wrap\
    \  . . . . . . . . . . . . . . . . . . . . . . . .  61\n   6.4.11.  wrap  . .\
    \ . . . . . . . . . . . . . . . . . . . . . .  62\n   6.4.12.  unwrap  . . . .\
    \ . . . . . . . . . . . . . . . . . . .  63\n   6.4.13.  unwrap  . . . . . . .\
    \ . . . . . . . . . . . . . . . .  64\n   6.4.14.  getMIC  . . . . . . . . . .\
    \ . . . . . . . . . . . . .  65\n   6.4.15.  getMIC  . . . . . . . . . . . . .\
    \ . . . . . . . . . .  65\n   6.4.16.  verifyMIC . . . . . . . . . . . . . . .\
    \ . . . . . . .  66\n   6.4.17.  verifyMIC . . . . . . . . . . . . . . . . . .\
    \ . . . .  67\n   6.4.18.  export  . . . . . . . . . . . . . . . . . . . . . .\
    \ .  68\n   6.4.19.  requestMutualAuth . . . . . . . . . . . . . . . . . .  68\n\
    \   6.4.20.  requestReplayDet  . . . . . . . . . . . . . . . . . .  69\n   6.4.21.\
    \  requestSequenceDet  . . . . . . . . . . . . . . . . .  69\n   6.4.22.  requestCredDeleg\
    \  . . . . . . . . . . . . . . . . . .  69\n   6.4.23.  requestAnonymity  . .\
    \ . . . . . . . . . . . . . . . .  69\n   6.4.24.  requestConf . . . . . . . .\
    \ . . . . . . . . . . . . .  70\n   6.4.25.  requestInteg  . . . . . . . . . .\
    \ . . . . . . . . . .  70\n   6.4.26.  requestLifetime . . . . . . . . . . . .\
    \ . . . . . . .  70\n   6.4.27.  setChannelBinding . . . . . . . . . . . . . .\
    \ . . . .  71\n   6.4.28.  getCredDelegState . . . . . . . . . . . . . . . . .\
    \ .  71\n   6.4.29.  getMutualAuthState  . . . . . . . . . . . . . . . . .  71\n\
    \   6.4.30.  getReplayDetState . . . . . . . . . . . . . . . . . .  71\n   6.4.31.\
    \  getSequenceDetState . . . . . . . . . . . . . . . . .  71\n   6.4.32.  getAnonymityState\
    \ . . . . . . . . . . . . . . . . . .  72\n   6.4.33.  isTransferable  . . . .\
    \ . . . . . . . . . . . . . . .  72\n   6.4.34.  isProtReady . . . . . . . . .\
    \ . . . . . . . . . . . .  72\n   6.4.35.  getConfState  . . . . . . . . . . .\
    \ . . . . . . . . .  72\n   6.4.36.  getIntegState . . . . . . . . . . . . . .\
    \ . . . . . .  72\n   6.4.37.  getLifetime . . . . . . . . . . . . . . . . . .\
    \ . . .  73\n   6.4.38.  getSrcName  . . . . . . . . . . . . . . . . . . . . .\
    \  73\n   6.4.39.  getTargName . . . . . . . . . . . . . . . . . . . . .  73\n\
    \   6.4.40.  getMech . . . . . . . . . . . . . . . . . . . . . . .  73\n   6.4.41.\
    \  getDelegCred  . . . . . . . . . . . . . . . . . . . .  73\n   6.4.42.  isInitiator\
    \ . . . . . . . . . . . . . . . . . . . . .  73\n   6.5.  public class MessageProp\
    \ . . . . . . . . . . . . . . . .  74\n   6.5.1.  Constructors . . . . . . . .\
    \ . . . . . . . . . . . . .  74\n   6.5.2.  getQOP . . . . . . . . . . . . . .\
    \ . . . . . . . . . .  75\n   6.5.3.  getPrivacy . . . . . . . . . . . . . . .\
    \ . . . . . . .  75\n   6.5.4.  getMinorStatus . . . . . . . . . . . . . . . .\
    \ . . . .  75\n   6.5.5.  getMinorString . . . . . . . . . . . . . . . . . . .\
    \ .  75\n   6.5.6.  setQOP . . . . . . . . . . . . . . . . . . . . . . . .  75\n\
    \   6.5.7.  setPrivacy . . . . . . . . . . . . . . . . . . . . . .  75\n   6.5.8.\
    \  isDuplicateToken . . . . . . . . . . . . . . . . . . .  76\n   6.5.9.  isOldToken\
    \ . . . . . . . . . . . . . . . . . . . . . .  76\n   6.5.10.  isUnseqToken  .\
    \ . . . . . . . . . . . . . . . . . . .  76\n   6.5.11.  isGapToken  . . . . .\
    \ . . . . . . . . . . . . . . . .  76\n   6.5.12.  setSupplementaryStates  . .\
    \ . . . . . . . . . . . . .  76\n   6.6.  public class ChannelBinding  . . . .\
    \ . . . . . . . . . .  77\n   6.6.1.  Constructors . . . . . . . . . . . . . .\
    \ . . . . . . .  77\n   6.6.2.  getInitiatorAddress  . . . . . . . . . . . . .\
    \ . . . .  78\n   6.6.3.  getAcceptorAddress . . . . . . . . . . . . . . . . .\
    \ .  78\n   6.6.4.  getApplicationData . . . . . . . . . . . . . . . . . .  78\n\
    \   6.6.5.  equals . . . . . . . . . . . . . . . . . . . . . . . .  78\n   6.7.\
    \  public class Oid . . . . . . . . . . . . . . . . . . . .  79\n   6.7.1.  Constructors\
    \ . . . . . . . . . . . . . . . . . . . . .  79\n   6.7.2.  toString . . . . .\
    \ . . . . . . . . . . . . . . . . . .  80\n   6.7.3.  equals . . . . . . . . .\
    \ . . . . . . . . . . . . . . .  80\n   6.7.4.  getDER . . . . . . . . . . . .\
    \ . . . . . . . . . . . .  80\n   6.7.5.  containedIn  . . . . . . . . . . . .\
    \ . . . . . . . . .  80\n   6.8.  public class GSSException extends Exception\
    \  . . . . . .  80\n   6.8.1.  Static Constants . . . . . . . . . . . . . . .\
    \ . . . .  81\n   6.8.2.  Constructors . . . . . . . . . . . . . . . . . . . .\
    \ .  83\n   6.8.3.  getMajor . . . . . . . . . . . . . . . . . . . . . . .  84\n\
    \   6.8.4.  getMinor . . . . . . . . . . . . . . . . . . . . . . .  84\n   6.8.5.\
    \  getMajorString . . . . . . . . . . . . . . . . . . . .  84\n   6.8.6.  getMinorString\
    \ . . . . . . . . . . . . . . . . . . . .  84\n   6.8.7.  setMinor . . . . . .\
    \ . . . . . . . . . . . . . . . . .  84\n   6.8.8.  toString . . . . . . . . .\
    \ . . . . . . . . . . . . . .  85\n   6.8.9.  getMessage . . . . . . . . . . .\
    \ . . . . . . . . . . .  85\n   7.  Sample Applications  . . . . . . . . . . .\
    \ . . . . . . . .  85\n   7.1.  Simple GSS Context Initiator . . . . . . . . .\
    \ . . . . .  85\n   7.2.  Simple GSS Context Acceptor  . . . . . . . . . . . .\
    \ . .  89\n   8.  Security Considerations  . . . . . . . . . . . . . . . . . \
    \ 93\n   9.  Acknowledgments  . . . . . . . . . . . . . . . . . . . . .  94\n\
    \   10.  Bibliography  . . . . . . . . . . . . . . . . . . . . . .  94\n   11.\
    \  Authors' Addresses  . . . . . . . . . . . . . . . . . . .  95\n   12.  Full\
    \ Copyright Statement. . . . . . . . . . . . . . . . .  96\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document specifies Java language bindings for the Generic\n\
    \   Security Services Application Programming Interface Version 2 (GSS-\n   API).\
    \  GSS-API Version 2 is described in a language independent\n   format in RFC\
    \ 2743 [GSSAPIv2-UPDATE]. The GSS-API allows a caller\n   application to authenticate\
    \ a principal identity, to delegate rights\n   to a peer, and to apply security\
    \ services such as confidentiality and\n   integrity on a per-message basis.\n\
    \   This document leverages the work performed by the WG in the area of\n   RFC\
    \ 2743 [GSSAPIv2-UPDATE] and the C-bindings RFC 2744 [GSSAPI-C].\n   Whenever\
    \ appropriate, text has been used from the C-bindings RFC 2744\n   to explain\
    \ generic concepts and provide direction to the\n   implementors.\n   The design\
    \ goals of this API have been to satisfy all the\n   functionality defined in\
    \ RFC 2743 and to provide these services in an\n   object oriented method.  The\
    \ specification also aims to satisfy the\n   needs of both types of Java application\
    \ developers, those who would\n   like access to a \"system-wide\" GSS-API implementation,\
    \ as well as\n   those who would want to provide their own \"custom\" implementation.\n\
    \   A \"system-wide\" implementation is one that is available to all\n   applications\
    \ in the form of a library package.  It may be a standard\n   package in the Java\
    \ runtime environment (JRE) being used or it may be\n   additionally installed\
    \ and accessible to any application via the\n   CLASSPATH.\n   A \"custom\" implementation\
    \ of the GSS-API, on the other hand, is one\n   that would, in most cases, be\
    \ bundled with the application during\n   distribution.  It is expected that such\
    \ an implementation would be\n   meant to provide for some particular need of\
    \ the application, such as\n   support for some specific mechanism.\n   The design\
    \ of this API also aims to provide a flexible framework to\n   add and manage\
    \ GSS-API mechanisms. GSS-API leverages the Java\n   Cryptography Architecture\
    \ (JCA) provider model to support the\n   plugability of mechanisms.  Mechanisms\
    \ can be added on a \"system-\n   wide\" basis, where all users of the framework\
    \ will have them\n   available. The specification also allows for the addition\
    \ of\n   mechanisms per-instance of the GSS-API.\n   Lastly, this specification\
    \ presents an API that will naturally fit\n   within the operation environment\
    \ of the Java platform.  Readers are\n   assumed to be familiar with both the\
    \ GSS-API and the Java platform.\n"
- title: 2.  GSS-API Operational Paradigm
  contents:
  - "2.  GSS-API Operational Paradigm\n   The Generic Security Service Application\
    \ Programming Interface\n   Version 2 [GSSAPIv2-UPDATE] defines a generic security\
    \ API to calling\n   applications.  It allows a communicating application to authenticate\n\
    \   the user associated with another application, to delegate rights to\n   another\
    \ application, and to apply security services such as\n   confidentiality and\
    \ integrity on a per-message basis.\n      There are four stages to using GSS-API:\n\
    \      1) The application acquires a set of credentials with which it may\n  \
    \       prove its identity to other processes.  The application's\n         credentials\
    \ vouch for its global identity, which may or may not\n         be related to\
    \ any local username under which it may be running.\n      2) A pair of communicating\
    \ applications establish a joint security\n         context using their credentials.\
    \  The security context\n         encapsulates shared state information, which\
    \ is required in\n         order that per-message security services may be provided.\n\
    \         Examples of state information that might be shared between\n       \
    \  applications as part of a security context are cryptographic\n         keys,\
    \ and message sequence numbers.  As part of the\n         establishment of  a\
    \ security context, the context initiator is\n         authenticated to the responder,\
    \ and may require that the\n         responder is authenticated back to the initiator.\
    \  The\n         initiator may optionally give the responder the right to\n  \
    \       initiate further security contexts, acting as an agent or\n         delegate\
    \ of the initiator.  This transfer of rights is termed\n         \"delegation\"\
    , and is achieved by creating a set of credentials,\n         similar to those\
    \ used by the initiating application, but which\n         may be used by the responder.\n\
    \         A GSSContext object is used to establish and maintain the\n        \
    \ shared information that makes up the security context.  Certain\n         GSSContext\
    \ methods will generate a token, which applications\n         treat as cryptographically\
    \ protected, opaque data.  The caller\n         of such GSSContext method is responsible\
    \ for transferring the\n         token to the peer application, encapsulated if\
    \ necessary in an\n         application-to-application protocol.  On receipt of\
    \ such a\n         token, the peer application should pass it to a corresponding\n\
    \         GSSContext method which will decode the token and extract the\n    \
    \     information, updating the security context state information\n         accordingly.\n\
    \      3) Per-message services are invoked on a GSSContext object to\n       \
    \  apply either:\n         integrity and data origin authentication, or\n    \
    \     confidentiality, integrity and data origin authentication\n         to application\
    \ data, which are treated by GSS-API as arbitrary\n         octet-strings.  An\
    \ application transmitting a message that it\n         wishes to protect will\
    \ call the appropriate GSSContext method\n         (getMIC or wrap) to apply protection,\
    \ and send the resulting\n         token to the receiving application.  The receiver\
    \ will pass the\n         received token (and, in the case of data protected by\
    \ getMIC,\n         the accompanying message-data) to the corresponding decoding\n\
    \         method of the GSSContext interface (verifyMIC or unwrap) to\n      \
    \   remove the protection and validate the data.\n      4) At the completion of\
    \ a communications session (which may extend\n         across several transport\
    \ connections), each application uses a\n         GSSContext method to invalidate\
    \ the security context and\n         release any system or cryptographic resources\
    \ held.  Multiple\n         contexts may also be used (either successively or\n\
    \         simultaneously) within a single communications association, at\n   \
    \      the discretion of the applications.\n"
- title: 3.  Additional Controls
  contents:
  - "3.  Additional Controls\n   This section discusses the optional services that\
    \ a context initiator\n   may request of the GSS-API before the context establishment.\
    \  Each of\n   these services is requested by calling the appropriate mutator\
    \ method\n   in the GSSContext object before the first call to init is performed.\n\
    \   Only the context initiator can request context flags.\n   The optional services\
    \ defined are:\n   Delegation\n         The (usually temporary) transfer of rights\
    \ from initiator to\n         acceptor, enabling the acceptor to authenticate\
    \ itself as an\n         agent of the initiator.\n   Mutual Authentication\n \
    \        In addition to the initiator authenticating its identity to the\n   \
    \      context acceptor, the context acceptor should also authenticate\n     \
    \    itself to the initiator.\n   Replay Detection\n         In addition to providing\
    \ message integrity services, GSSContext\n         per-message operations of getMIC\
    \ and wrap should include\n         message numbering information  to enable verifyMIC\
    \ and unwrap\n         to detect if a message has been duplicated.\n   Out-of-Sequence\
    \ Detection\n         In addition to providing message integrity services, GSSContext\n\
    \         per-message operations  (getMIC and wrap) should include\n         message\
    \ sequencing information to enable verifyMIC and unwrap\n         to detect if\
    \ a message has been received out of sequence.\n   Anonymous Authentication\n\
    \         The establishment of the security context should not reveal the\n  \
    \       initiator's identity to the context acceptor.\n   Some mechanisms may\
    \ not support all optional services, and some\n   mechanisms may only support\
    \ some services in conjunction with others.\n   The GSSContext interface offers\
    \ query methods to allow the\n   verification by the calling application of which\
    \ services will be\n   available from the context when the establishment phase\
    \ is complete.\n   In general, if the security mechanism is capable of providing\
    \ a\n   requested service, it should do so even if additional services must\n\
    \   be enabled in order to provide the requested service.  If the\n   mechanism\
    \ is incapable of providing a requested service, it should\n   proceed without\
    \ the service leaving the application to abort the\n   context establishment process\
    \ if it considers the requested service\n   to be mandatory.\n   Some mechanisms\
    \ may specify that support for some services is\n   optional, and that implementors\
    \ of the mechanism need not provide it.\n   This is most commonly true of the\
    \ confidentiality service, often\n   because of legal restrictions on the use\
    \ of data-encryption, but may\n   apply to any of the services.  Such mechanisms\
    \ are required to send\n   at least one token from acceptor to initiator during\
    \ context\n   establishment when the initiator indicates a desire to use such\
    \ a\n   service, so that the initiating GSS-API can correctly indicate\n   whether\
    \ the service is supported by the acceptor's GSS-API.\n"
- title: 3.1.  Delegation
  contents:
  - "3.1.  Delegation\n   The GSS-API allows delegation to be controlled by the initiating\n\
    \   application via the requestCredDeleg method before the first call to\n   init\
    \ has been issued.  Some mechanisms do not support delegation, and\n   for such\
    \ mechanisms attempts by an application to enable delegation\n   are ignored.\n\
    \   The acceptor of a security context, for which the initiator enabled\n   delegation,\
    \ can check if delegation was enabled by using the\n   getCredDelegState method\
    \ of the GSSContext interface.  In cases when\n   it is, the delegated credential\
    \ object can be obtained by calling the\n   getDelegCred method.  The obtained\
    \ GSSCredential object may then be\n   used to initiate subsequent GSS-API security\
    \ contexts as an agent or\n   delegate of the initiator.  If the original initiator's\
    \ identity is\n   \"A\" and the delegate's identity is \"B\", then, depending\
    \ on the\n   underlying mechanism, the identity embodied by the delegated\n  \
    \ credential may be either \"A\" or \"B acting for A\".\n   For many mechanisms\
    \ that support delegation, a simple boolean does\n   not provide enough control.\
    \  Examples of additional aspects of\n   delegation control that a mechanism might\
    \ provide to an application\n   are duration of delegation, network addresses\
    \ from which delegation\n   is valid, and constraints on the tasks that may be\
    \ performed by a\n   delegate.  Such controls are presently outside the scope\
    \ of the GSS-\n   API.  GSS-API implementations supporting mechanisms offering\n\
    \   additional controls should provide extension routines that allow\n   these\
    \ controls to be exercised (perhaps by modifying the initiator's\n   GSS-API credential\
    \ object prior to its use in establishing a\n   context).  However, the simple\
    \ delegation control provided by GSS-API\n   should always be able to over-ride\
    \ other mechanism-specific\n   delegation controls.  If the application instructs\
    \ the GSSContext\n   object that delegation is not desired, then the implementation\
    \ must\n   not permit delegation to occur.  This is an exception to the general\n\
    \   rule that a mechanism may enable services even if they are not\n   requested\
    \ - delegation may only be provided at the explicit request\n   of the application.\n"
- title: 3.2.  Mutual Authentication
  contents:
  - "3.2.  Mutual Authentication\n   Usually, a context acceptor will require that\
    \ a context initiator\n   authenticate itself so that the acceptor may make an\
    \ access-control\n   decision prior to performing a service for the initiator.\
    \  In some\n   cases, the initiator may also request that the acceptor authenticate\n\
    \   itself.  GSS-API allows the initiating application to request this\n   mutual\
    \ authentication service by calling the requestMutualAuth method\n   of the GSSContext\
    \ interface with a \"true\" parameter before making the\n   first call to init.\
    \  The initiating application is informed as to\n   whether or not the context\
    \ acceptor has authenticated itself.  Note\n   that some mechanisms may not support\
    \ mutual authentication, and other\n   mechanisms may always perform mutual authentication,\
    \ whether or not\n   the initiating application requests it.  In particular, mutual\n\
    \   authentication may be required by some mechanisms in order to support\n  \
    \ replay or out-of-sequence message detection, and for such mechanisms\n   a request\
    \ for either of these services will automatically enable\n   mutual authentication.\n"
- title: 3.3.  Replay and Out-of-Sequence Detection
  contents:
  - "3.3.  Replay and Out-of-Sequence Detection\n   The GSS-API may provide detection\
    \ of mis-ordered messages once a\n   security context has been established.  Protection\
    \ may be applied to\n   messages by either application, by calling either getMIC\
    \ or wrap\n   methods of the GSSContext interface, and verified by the peer\n\
    \   application by calling verifyMIC or unwrap for the peer's GSSContext\n   object.\n\
    \   The getMIC method calculates a cryptographic checksum of an\n   application\
    \ message, and returns that checksum in a token.  The\n   application should pass\
    \ both the token and the message to the peer\n   application, which presents them\
    \ to the verifyMIC method of the\n   peer's GSSContext object.\n   The wrap method\
    \ calculates a cryptographic checksum of an application\n   message, and places\
    \ both the checksum and the message inside a single\n   token.  The application\
    \ should pass the token to the peer\n   application, which presents it to the\
    \ unwrap method of the peer's\n   GSSContext object to extract the message and\
    \ verify the checksum.\n   Either pair of routines may be capable of detecting\
    \ out-of-sequence\n   message delivery, or duplication of messages.  Details of\
    \ such mis-\n   ordered messages are indicated through supplementary query methods\
    \ of\n   the MessageProp object that is filled in by each of these routines.\n\
    \   A mechanism need not maintain a list of all tokens that have been\n   processed\
    \ in order to support these status codes.  A typical\n   mechanism might retain\
    \ information about only the most recent \"N\"\n   tokens processed, allowing\
    \ it to distinguish duplicates and missing\n   tokens within the most recent \"\
    N\" messages; the receipt of a token\n   older than the most recent \"N\" would\
    \ result in the isOldToken method\n   of the instance of MessageProp to return\
    \ \"true\".\n"
- title: 3.4.  Anonymous Authentication
  contents:
  - "3.4.  Anonymous Authentication\n   In certain situations, an application may\
    \ wish to initiate the\n   authentication process to authenticate a peer, without\
    \ revealing its\n   own identity.  As an example, consider an application providing\n\
    \   access to a database containing medical information, and offering\n   unrestricted\
    \ access to the service.  A client of such a service might\n   wish to authenticate\
    \ the service (in order to establish trust in any\n   information retrieved from\
    \ it), but might not wish the service to be\n   able to obtain the client's identity\
    \ (perhaps due to privacy concerns\n   about the specific inquiries, or perhaps\
    \ simply to avoid being placed\n   on mailing-lists).\n   In normal use of the\
    \ GSS-API, the initiator's identity is made\n   available to the acceptor as a\
    \ result of the context establishment\n   process.  However, context initiators\
    \ may request that their identity\n   not be revealed to the context acceptor.\
    \  Many mechanisms do not\n   support anonymous authentication, and for such mechanisms\
    \ the request\n   will not be honored.  An authentication token will still be\n\
    \   generated, but the application is always informed if a requested\n   service\
    \ is unavailable, and has the option to abort context\n   establishment if anonymity\
    \ is valued above the other security\n   services that would require a context\
    \ to be established.\n   In addition to informing the application that a context\
    \ is\n   established anonymously (via the isAnonymous method of the GSSContext\n\
    \   class), the getSrcName method of the acceptor's GSSContext object\n   will,\
    \ for such contexts, return a reserved internal-form name,\n   defined by the\
    \ implementation.\n   The toString method for a GSSName object representing an\
    \ anonymous\n   entity will return a printable name.  The returned value will\
    \ be\n   syntactically distinguishable from any valid principal name supported\n\
    \   by the implementation.  The associated name-type object identifier\n   will\
    \ be an oid representing the value of NT_ANONYMOUS.  This name-\n   type oid will\
    \ be defined as a public, static Oid object of the\n   GSSName class.  The printable\
    \ form of an anonymous name should be\n   chosen such that it implies anonymity,\
    \ since this name may appear in,\n   for example, audit logs.  For example, the\
    \ string \"<anonymous>\" might\n   be a good choice, if no valid printable names\
    \ supported by the\n   implementation can begin with \"<\" and end with \">\"\
    .\n   When using the equal method of the GSSName interface, and one of the\n \
    \  operands is a GSSName instance representing an anonymous entity, the\n   method\
    \ must return \"false\".\n"
- title: 3.5.  Confidentiality
  contents:
  - "3.5.  Confidentiality\n   If a GSSContext supports the confidentiality service,\
    \ wrap method may\n   be used to encrypt application messages.  Messages are selectively\n\
    \   encrypted, under the control of the setPrivacy method of the\n   MessageProp\
    \ object used in the wrap method.\n"
- title: 3.6.  Inter-process Context Transfer
  contents:
  - "3.6.  Inter-process Context Transfer\n   GSS-API V2 provides functionality which\
    \ allows a security context to\n   be transferred between processes on a single\
    \ machine.  These are\n   implemented using the export method of GSSContext and\
    \ a byte array\n   constructor of the same class.  The most common use for such\
    \ a\n   feature is a client-server design where the server is implemented as\n\
    \   a single process that accepts incoming security contexts, which then\n   launches\
    \ child processes to deal with the data on these contexts.  In\n   such a design,\
    \ the child processes must have access to the security\n   context object created\
    \ within the parent so that they can use per-\n   message protection services\
    \ and delete the security context when the\n   communication session ends.\n \
    \  Since the security context data structure is expected to contain\n   sequencing\
    \ information, it is impractical in general to share a\n   context between processes.\
    \  Thus GSSContext interface provides an\n   export method that the process, which\
    \ currently owns the context, can\n   call to declare that it has no intention\
    \ to use the context\n   subsequently, and to create an inter-process token containing\n\
    \   information needed by the adopting process to successfully re-create\n   the\
    \ context.  After successful completion of export, the original\n   security context\
    \ is made inaccessible to the calling process by GSS-\n   API and any further\
    \ usage of this object will result in failures.\n   The originating process transfers\
    \ the inter-process token to the\n   adopting process, which creates a new GSSContext\
    \ object using the\n   byte array constructor.  The properties of the context\
    \ are equivalent\n   to that of the original context.\n   The inter-process token\
    \ may contain sensitive data from the original\n   security context (including\
    \ cryptographic keys).  Applications using\n   inter-process tokens to transfer\
    \ security contexts must take\n   appropriate steps to protect these tokens in\
    \ transit.\n   Implementations are not required to support the inter-process\n\
    \   transfer of security contexts.  Calling the isTransferable method of\n   the\
    \ GSSContext interface will indicate if the context object is\n   transferable.\n"
- title: 3.7.  The Use of Incomplete Contexts
  contents:
  - "3.7.  The Use of Incomplete Contexts\n   Some mechanisms may allow the per-message\
    \ services to be used before\n   the context establishment process is complete.\
    \  For example, a\n   mechanism may include sufficient information in its initial\
    \ context-\n   level tokens for the context acceptor to immediately decode messages\n\
    \   protected with wrap or getMIC.  For such a mechanism, the initiating\n   application\
    \ need not wait until subsequent context-level tokens have\n   been sent and received\
    \ before invoking the per-message protection\n   services.\n   An application\
    \ can invoke the isProtReady method of the GSSContext\n   class to determine if\
    \ the per-message services are available in\n   advance of complete context establishment.\
    \  Applications wishing to\n   use per-message protection services on partially-established\
    \ contexts\n   should query this method before attempting to invoke wrap or getMIC.\n"
- title: 4.  Calling Conventions
  contents:
  - "4.  Calling Conventions\n   Java provides the implementors with not just a syntax\
    \ for the\n   language, but also an operational environment.  For example, memory\n\
    \   is automatically managed and does not require application\n   intervention.\
    \  These language features have allowed for a simpler API\n   and have led to\
    \ the elimination of certain GSS-API functions.\n   Moreover, the JCA defines\
    \ a provider model which allows for\n   implementation independent access to security\
    \ services. Using this\n   model, applications can seamlessly switch between different\n\
    \   implementations and dynamically add new services. The GSS-API\n   specification\
    \ leverages these concepts by the usage of providers for\n   the mechanism implementations.\n"
- title: 4.1.  Package Name
  contents:
  - "4.1.  Package Name\n   The classes and interfaces defined in this document reside\
    \ in the\n   package called \"org.ietf.jgss\".  Applications that wish to make\
    \ use\n   of this API should import this package name as shown in section 7.\n"
- title: 4.2.  Provider Framework
  contents:
  - "4.2.  Provider Framework\n   The Java security API's use a provider architecture\
    \ that allows\n   applications to be implementation independent and security API\n\
    \   implementations to be modular and extensible.  The\n   java.security.Provider\
    \ class is an abstract class that a vendor\n   extends.  This class maps various\
    \ properties that represent different\n   security services that are available\
    \ to the names of the actual\n   vendor classes that implement those services.\
    \  When requesting a\n   service, an application simply specifies the desired\
    \ provider and the\n   API delegates the request to service classes available\
    \ from that\n   provider.\n   Using the Java security provider model insulates\
    \ applications from\n   implementation details of the services they wish to use.\n\
    \   Applications can switch between providers easily and new providers\n   can\
    \ be added as needed, even at runtime.\n   The GSS-API may use providers to find\
    \ components for specific\n   underlying security mechanisms.  For instance, a\
    \ particular provider\n   might contain components that will allow the GSS-API\
    \ to support the\n   Kerberos v5 mechanism and another might contain components\
    \ to support\n   the SPKM mechanism.  By delegating mechanism specific functionality\n\
    \   to the components obtained from providers the GSS-API can be extended\n  \
    \ to support an arbitrary list of mechanism.\n   How the GSS-API locates and queries\
    \ these providers is beyond the\n   scope of this document and is being deferred\
    \ to a Service Provider\n   Interface (SPI) specification.  The availability of\
    \ such a SPI\n   specification is not mandatory for the adoption of this API\n\
    \   specification nor is it mandatory to use providers in the\n   implementation\
    \ of a GSS-API framework. However, by using the provider\n   framework together\
    \ with an SPI specification one can create an\n   extensible and implementation\
    \ independent GSS-API framework.\n"
- title: 4.3.  Integer types
  contents:
  - "4.3.  Integer types\n   All numeric values are declared as \"int\" primitive\
    \ Java type.  The\n   Java specification guarantees that this will be a 32 bit\
    \ two's\n   complement signed number.\n   Throughout this API, the \"boolean\"\
    \ primitive Java type is used\n   wherever a boolean value is required or returned.\n"
- title: 4.4.  Opaque Data types
  contents:
  - "4.4.  Opaque Data types\n   Java byte arrays are used to represent opaque data\
    \ types which are\n   consumed and produced by the GSS-API in the forms of tokens.\
    \  Java\n   arrays contain a length field which enables the users to easily\n\
    \   determine their size.  The language has automatic garbage collection\n   which\
    \ alleviates the need by developers to release memory and\n   simplifies buffer\
    \ ownership issues.\n"
- title: 4.5.  Strings
  contents:
  - "4.5.  Strings\n   The String object will be used to represent all textual data.\
    \  The\n   Java String object, transparently treats all characters as two-byte\n\
    \   Unicode characters which allows support for many locals.  All\n   routines\
    \ returning or accepting textual data will use the String\n   object.\n"
- title: 4.6.  Object Identifiers
  contents:
  - "4.6.  Object Identifiers\n   An Oid object will be used to represent Universal\
    \ Object Identifiers\n   (Oids).  Oids are ISO-defined, hierarchically globally-interpretable\n\
    \   identifiers used within the GSS-API framework to identify security\n   mechanisms\
    \ and name formats.  The Oid object can be created from a\n   string representation\
    \ of its dot notation (e.g. \"1.3.6.1.5.6.2\") as\n   well as from its ASN.1 DER\
    \ encoding.  Methods are also provided to\n   test equality and provide the DER\
    \ representation for the object.\n   An important feature of the Oid class is\
    \ that its instances are\n   immutable - i.e.  there are no methods defined that\
    \ allow one to\n   change the contents of an Oid.  This property allows one to\
    \ treat\n   these objects as \"statics\" without the need to perform copies.\n\
    \   Certain routines allow the usage of a default oid.  A \"null\" value\n   can\
    \ be used in those cases.\n"
- title: 4.7.  Object Identifier Sets
  contents:
  - "4.7.  Object Identifier Sets\n   The Java bindings represents object identifiers\
    \ sets as arrays of Oid\n   objects.  All Java arrays contain a length field which\
    \ allows for\n   easy manipulation and reference.\n   In order to support the\
    \ full functionality of RFC 2743, the Oid class\n   includes a method which checks\
    \ for existence of an Oid object within\n   a specified array.  This is equivalent\
    \ in functionality to\n   gss_test_oid_set_member.  The use of Java arrays and\
    \ Java's automatic\n   garbage collection has eliminated the need for the following\n\
    \   routines: gss_create_empty_oid_set, gss_release_oid_set, and\n   gss_add_oid_set_member.\
    \  Java GSS-API implementations will not\n   contain them.  Java's automatic garbage\
    \ collection and the immutable\n   property of the Oid object eliminates the complicated\
    \ memory\n   management issues of the C counterpart.\n   When ever a default value\
    \ for an Object Identifier Set is required, a\n   \"null\" value can be used.\
    \  Please consult the detailed method\n   description for details.\n"
- title: 4.8.  Credentials
  contents:
  - "4.8.  Credentials\n   GSS-API credentials are represented by the GSSCredential\
    \ interface.\n   The interface contains several constructs to allow for the creation\n\
    \   of most common credential objects for the initiator and the acceptor.\n  \
    \ Comparisons are performed using the interface's \"equals\" method.  The\n  \
    \ following general description of GSS-API credentials is included from\n   the\
    \ C-bindings specification:\n   GSS-API credentials can contain mechanism-specific\
    \ principal\n   authentication data for multiple mechanisms.  A GSS-API credential\
    \ is\n   composed of a set of credential-elements, each of which is applicable\n\
    \   to a single mechanism.  A credential may contain at most one\n   credential-element\
    \ for each supported mechanism.  A credential-\n   element identifies the data\
    \ needed by a single mechanism to\n   authenticate a single principal, and conceptually\
    \ contains two\n   credential-references that describe the actual mechanism-specific\n\
    \   authentication data, one to be used by GSS-API for initiating\n   contexts,\
    \ and one to be used for accepting contexts.  For mechanisms\n   that do not distinguish\
    \ between acceptor and initiator credentials,\n   both references would point\
    \ to the same underlying mechanism-specific\n   authentication data.\n   Credentials\
    \ describe a set of mechanism-specific principals, and give\n   their holder the\
    \ ability to act as any of those principals.  All\n   principal identities asserted\
    \ by a single GSS-API credential should\n   belong to the same entity, although\
    \ enforcement of this property is\n   an implementation-specific matter.  A single\
    \ GSSCredential object\n   represents all the credential elements that have been\
    \ acquired.\n   The creation's of an GSSContext object allows the value of \"\
    null\" to\n   be specified as the GSSCredential input parameter.  This will\n\
    \   indicate a desire by the application to act as a default principal.\n   While\
    \ individual GSS-API implementations are free to determine such\n   default behavior\
    \ as appropriate to the mechanism, the following\n   default behavior by these\
    \ routines is recommended for portability:\n      For the initiator side of the\
    \ context:\n      1) If there is only a single principal capable of initiating\n\
    \         security contexts for the chosen mechanism that the application\n  \
    \       is authorized to act on behalf of, then that principal shall be\n    \
    \     used, otherwise\n      2) If the platform maintains a concept of a default\
    \ network-\n         identity for the chosen mechanism, and if the application\
    \ is\n         authorized to act on behalf of that identity for the purpose of\n\
    \         initiating security contexts, then the principal corresponding\n   \
    \      to that identity shall be used, otherwise\n      3) If the platform maintains\
    \ a concept of a default local\n         identity, and provides a means to map\
    \ local identities into\n         network-identities for the chosen mechanism,\
    \ and if the\n         application is authorized to act on behalf of the network-\n\
    \         identity image of the default local identity for the purpose of\n  \
    \       initiating security contexts using the chosen mechanism, then\n      \
    \   the principal corresponding to that identity shall be used,\n         otherwise\n\
    \      4) A user-configurable default identity should be used.\n      and for\
    \ the acceptor side of the context\n      1) If there is only a single authorized\
    \ principal identity capable\n         of accepting security contexts for the\
    \ chosen mechanism, then\n         that principal shall be used, otherwise\n \
    \     2) If the mechanism can determine the identity of the target\n         principal\
    \ by examining the context-establishment token\n         processed during the\
    \ accept method, and if the accepting\n         application is authorized to act\
    \ as that principal for the\n         purpose of accepting security contexts using\
    \ the chosen\n         mechanism, then that principal identity shall be used,\n\
    \         otherwise\n      3) If the mechanism supports context acceptance by\
    \ any principal,\n         and if mutual authentication was not requested, any\
    \ principal\n         that the application is authorized to accept security contexts\n\
    \         under using the chosen mechanism may be used, otherwise\n      4) A\
    \ user-configurable default identity shall be used.\n   The purpose of the above\
    \ rules is to allow security contexts to be\n   established by both initiator\
    \ and acceptor using the default behavior\n   whenever possible.  Applications\
    \ requesting default behavior are\n   likely to be more portable across mechanisms\
    \ and implementations than\n   ones that instantiate an GSSCredential object representing\
    \ a specific\n   identity.\n"
- title: 4.9.  Contexts
  contents:
  - "4.9.  Contexts\n   The GSSContext interface is used to represent one end of a\
    \ GSS-API\n   security context, storing state information appropriate to that\
    \ end\n   of the peer communication, including cryptographic state information.\n\
    \   The instantiation of the context object is done differently by the\n   initiator\
    \ and the acceptor.  After the context has been instantiated,\n   the initiator\
    \ may choose to set various context options which will\n   determine the characteristics\
    \ of the desired security context.  When\n   all the application desired characteristics\
    \ have been set, the\n   initiator will call the initSecContext method which will\
    \ produce a\n   token for consumption by the peer's acceptSecContext method. \
    \ It is\n   the responsibility of the application to deliver the authentication\n\
    \   token(s) between the peer applications for processing.  Upon\n   completion\
    \ of the context establishment phase, context attributes can\n   be retrieved,\
    \ by both the initiator and acceptor, using the accessor\n   methods.  These will\
    \ reflect the actual attributes of the established\n   context.  At this point\
    \ the context can be used by the application to\n   apply cryptographic services\
    \ to its data.\n"
- title: 4.10.  Authentication tokens
  contents:
  - "4.10.  Authentication tokens\n   A token is a caller-opaque type that GSS-API\
    \ uses to maintain\n   synchronization between each end of the GSS-API security\
    \ context.\n   The token is a cryptographically protected octet-string, generated\
    \ by\n   the underlying mechanism at one end of a GSS-API security context for\n\
    \   use by the peer mechanism at the other end.  Encapsulation (if\n   required)\
    \ within the application protocol and transfer of the token\n   are the responsibility\
    \ of the peer applications.\n   Java GSS-API uses byte arrays to represent authentication\
    \ tokens.\n   Overloaded methods exist which allow the caller to supply input\
    \ and\n   output streams which will be used for the reading and writing of the\n\
    \   token data.\n"
- title: 4.11.  Interprocess tokens
  contents:
  - "4.11.  Interprocess tokens\n   Certain GSS-API routines are intended to transfer\
    \ data between\n   processes in multi-process programs.  These routines use a\
    \ caller-\n   opaque octet-string, generated by the GSS-API in one process for\
    \ use\n   by the GSS-API in another process.  The calling application is\n   responsible\
    \ for transferring such tokens between processes.  Note\n   that, while GSS-API\
    \ implementors are encouraged to avoid placing\n   sensitive information within\
    \ interprocess tokens, or to\n   cryptographically protect them, many implementations\
    \ will be unable\n   to avoid placing key material or other sensitive data within\
    \ them.\n   It is the application's responsibility to ensure that interprocess\n\
    \   tokens are protected in transit, and transferred only to processes\n   that\
    \ are trustworthy.  An interprocess token is represented using a\n   byte array\
    \ emitted from the export method of the GSSContext\n   interface.  The receiver\
    \ of the interprocess token would initialize\n   an GSSContext object with this\
    \ token to create a new context.  Once a\n   context has been exported, the GSSContext\
    \ object is invalidated and\n   is no longer available.\n"
- title: 4.12.  Error Reporting
  contents:
  - "4.12.  Error Reporting\n   RFC 2743 defined the usage of major and minor status\
    \ values for\n   signaling of GSS-API errors.  The major code, also called GSS\
    \ status\n   code, is used to signal errors at the GSS-API level independent of\n\
    \   the underlying mechanism(s).  The minor status value or Mechanism\n   status\
    \ code, is a mechanism defined error value indicating a\n   mechanism specific\
    \ error code.\n   Java GSS-API uses exceptions implemented by the GSSException\
    \ class to\n   signal both minor and major error values.  Both mechanism specific\n\
    \   errors and GSS-API level errors are signaled through instances of\n   this\
    \ class.  The usage of exceptions replaces the need for major and\n   minor codes\
    \ to be used within the API calls.  GSSException class also\n   contains methods\
    \ to obtain textual representations for both the major\n   and minor values, which\
    \ is equivalent to the functionality of\n   gss_display_status.\n"
- title: 4.12.1.  GSS status codes
  contents:
  - "4.12.1.  GSS status codes\n   GSS status codes indicate errors that are independent\
    \ of the\n   underlying mechanism(s) used to provide the security service.  The\n\
    \   errors that can be indicated via a GSS status code are generic API\n   routine\
    \ errors (errors that are defined in the GSS-API\n   specification).  These bindings\
    \ take advantage of the Java exceptions\n   mechanism, thus eliminating the need\
    \ for calling errors.\n   A GSS status code indicates a single fatal generic API\
    \ error from the\n   routine that has thrown the GSSException.  Using exceptions\
    \ announces\n   that a fatal error has occurred during the execution of the method.\n\
    \   The GSS-API operational model also allows for the signaling of\n   supplementary\
    \ status information from the per-message calls.  These\n   need to be handled\
    \ as return values since using exceptions is not\n   appropriate for informatory\
    \ or warning-like information.  The methods\n   that are capable of producing\
    \ supplementary information are the two\n   per-message methods GSSContext.verifyMIC()\
    \ and GSSContext.unwrap().\n   These methods fill the supplementary status codes\
    \ in the MessageProp\n   object that was passed in.\n   GSSException object, along\
    \ with providing the functionality for\n   setting of the various error codes\
    \ and translating them into textual\n   representation, also contains the definitions\
    \ of all the numeric\n   error values.  The following table lists the definitions\
    \ of error\n   codes:\n      Table: GSS Status Codes\n      Name             \
    \      Value   Meaning\n      BAD_MECH                 1     An unsupported mechanism\n\
    \                                     was requested.\n      BAD_NAME         \
    \        2     An invalid name was supplied.\n      BAD_NAMETYPE             3\
    \     A supplied name was of an\n                                     unsupported\
    \ type.\n      BAD_BINDINGS             4     Incorrect channel bindings were\n\
    \                                     supplied.\n      BAD_STATUS            \
    \   5     An invalid status code was\n                                     supplied.\n\
    \      BAD_MIC                  6     A token had an invalid MIC.\n      NO_CRED\
    \                  7     No credentials were supplied, or\n                  \
    \                   the credentials were unavailable\n                       \
    \              or inaccessible.\n      NO_CONTEXT               8     Invalid\
    \ context has been\n                                     supplied.\n      DEFECTIVE_TOKEN\
    \          9     A supplied token was invalid.\n      DEFECTIVE_CREDENTIAL   \
    \ 10     A supplied credential was\n                                     invalid.\n\
    \      CREDENTIALS_EXPIRED     11     The referenced credentials\n           \
    \                          have expired.\n      CONTEXT_EXPIRED         12   \
    \  The context has expired.\n      FAILURE                 13     Miscellaneous\
    \ failure,\n                                     unspecified at the GSS-API level.\n\
    \      BAD_QOP                 14     The quality-of-protection\n            \
    \                         requested could not be provided.\n      UNAUTHORIZED\
    \            15     The operation is forbidden by\n                          \
    \           local security policy.\n      UNAVAILABLE             16     The operation\
    \ or option is\n                                     unavailable.\n      DUPLICATE_ELEMENT\
    \       17     The requested credential\n                                    \
    \ element already exists.\n      NAME_NOT_MN             18     The provided name\
    \ was not a\n                                     mechanism name.\n      OLD_TOKEN\
    \               19     The token's validity period has\n                     \
    \                expired.\n      DUPLICATE_TOKEN         20     The token was\
    \ a duplicate of an\n                                     earlier version.\n \
    \  The GSS major status code of FAILURE is used to indicate that the\n   underlying\
    \ mechanism detected an error for which no specific GSS\n   status code is defined.\
    \  The mechanism-specific status code can\n   provide more details about the error.\n\
    \   The different major status codes that can be contained in the\n   GSSException\
    \ object thrown by the methods in this specification are\n   the same as the major\
    \ status codes returned by the corresponding\n   calls in RFC 2743 [GSSAPIv2-UPDATE].\n"
- title: 4.12.2.  Mechanism-specific status codes
  contents:
  - "4.12.2.  Mechanism-specific status codes\n   Mechanism-specific status codes\
    \ are communicated in two ways, they\n   are part of any GSSException thrown from\
    \ the mechanism specific layer\n   to signal a fatal error, or they are part of\
    \ the MessageProp object\n   that the per-message calls use to signal non-fatal\
    \ errors.\n   A default value of 0 in either the GSSException object or the\n\
    \   MessageProp object will be used to represent the absence of any\n   mechanism\
    \ specific status code.\n"
- title: 4.12.3.  Supplementary status codes
  contents:
  - "4.12.3.  Supplementary status codes\n   Supplementary status codes are confined\
    \ to the per-message methods of\n   the GSSContext interface.  Because of the\
    \ informative nature of these\n   errors it is not appropriate to use exceptions\
    \ to signal them.\n   Instead, the per-message operations of the GSSContext interface\n\
    \   return these values in a MessageProp object.\n   The MessageProp class defines\
    \ query methods which return boolean\n   values indicating the following supplementary\
    \ states:\n      Table: Supplementary Status Methods\n      Method Name      \
    \ Meaning when \"true\" is returned\n      isDuplicateToken   The token was a\
    \ duplicate of an\n                         earlier token.\n      isOldToken \
    \        The token's validity period has\n                         expired.\n\
    \      isUnseqToken       A later token has already been\n                   \
    \      processed.\n      isGapToken         An expected per-message token was\n\
    \                         not received.\n   \"true\" return value for any of the\
    \ above methods indicates that the\n   token exhibited the specified property.\
    \  The application must\n   determine the appropriate course of action for these\
    \ supplementary\n   values.  They are not treated as errors by the GSS-API.\n"
- title: 4.13.  Names
  contents:
  - "4.13.  Names\n   A name is used to identify a person or entity.  GSS-API authenticates\n\
    \   the relationship between a name and the entity claiming the name.\n   Since\
    \ different authentication mechanisms may employ different\n   namespaces for\
    \ identifying their principals, GSS-API's naming support\n   is necessarily complex\
    \ in multi-mechanism environments (or even in\n   some single-mechanism environments\
    \ where the underlying mechanism\n   supports multiple namespaces).\n   Two distinct\
    \ conceptual representations are defined for names:\n   1) A GSS-API form represented\
    \ by implementations of the GSSName\n      interface: A single GSSName object\
    \ may contain multiple names from\n      different namespaces, but all names should\
    \ refer to the same\n      entity.  An example of such an internal name would\
    \ be the name\n      returned from a call to the getName method of the GSSCredential\n\
    \      interface, when applied to a credential containing credential\n      elements\
    \ for multiple authentication mechanisms employing\n      different namespaces.\
    \  This GSSName object will contain a distinct\n      name for the entity for\
    \ each authentication mechanism.\n      For GSS-API implementations supporting\
    \ multiple namespaces,\n      GSSName implementations must contain sufficient\
    \ information to\n      determine the namespace to which each primitive name belongs.\n\
    \   2) Mechanism-specific contiguous byte array and string forms:\n      Different\
    \ GSSName initialization methods are provided to handle\n      both byte array\
    \ and string formats and to accommodate various\n      calling applications and\
    \ name types.  These formats are capable of\n      containing only a single name\
    \ (from a single namespace).\n      Contiguous string names are always accompanied\
    \ by an object\n      identifier specifying the namespace to which the name belongs,\
    \ and\n      their format is dependent on the authentication mechanism that\n\
    \      employs that name.  The string name forms are assumed to be\n      printable,\
    \ and may therefore be used by GSS-API applications for\n      communication with\
    \ their users.  The byte array name formats are\n      assumed to be in non-printable\
    \ formats (e.g.  the byte array\n      returned from the export method of the\
    \ GSSName interface).\n   A GSSName object can be converted to a contiguous representation\
    \ by\n   using the toString method.  This will guarantee that the name will be\n\
    \   converted to a printable format.  Different initialization methods in\n  \
    \ the GSSName interface are defined allowing support for multiple\n   syntaxes\
    \ for each supported namespace, and allowing users the freedom\n   to choose a\
    \ preferred name representation.  The toString method\n   should use an implementation-chosen\
    \ printable syntax for each\n   supported name-type.  To obtain the printable\
    \ name type,\n   getStringNameType method can be used.\n   There is no guarantee\
    \ that calling the toString method on the GSSName\n   interface will produce the\
    \ same string form as the original imported\n   string name.  Furthermore, it\
    \ is possible that the name was not even\n   constructed from a string representation.\
    \  The same applies to name-\n   space identifiers which may not necessarily survive\
    \ unchanged after a\n   journey through the internal name-form.  An example of\
    \ this might be\n   a mechanism that authenticates X.500 names, but provides an\n\
    \   algorithmic mapping of Internet DNS names into X.500.  That\n   mechanism's\
    \ implementation of GSSName might, when presented with a\n   DNS name, generate\
    \ an internal name that contained both the original\n   DNS name and the equivalent\
    \ X.500 name.  Alternatively, it might only\n   store the X.500 name.  In the\
    \ latter case, the toString method of\n   GSSName would most likely generate a\
    \ printable X.500 name, rather\n   than the original DNS name.\n   The context\
    \ acceptor can obtain a GSSName object representing the\n   entity performing\
    \ the context initiation (through the usage of\n   getSrcName method).  Since\
    \ this name has been authenticated by a\n   single mechanism, it contains only\
    \ a single name (even if the\n   internal name presented by the context initiator\
    \ to the GSSContext\n   object had multiple components).  Such names are termed\
    \ internal\n   mechanism names, or \"MN\"s and the names emitted by GSSContext\n\
    \   interface in the getSrcName and getTargName are always of this type.\n   Since\
    \ some applications may require MNs without wanting to incur the\n   overhead\
    \ of an authentication operation, creation methods are\n   provided that take\
    \ not only the name buffer and name type, but also\n   the mechanism oid for which\
    \ this name should be created.  When\n   dealing with an existing GSSName object,\
    \ the canonicalize method may\n   be invoked to convert a general internal name\
    \ into an MN.\n   GSSName objects can be compared using their equal method, which\n\
    \   returns \"true\" if the two names being compared refer to the same\n   entity.\
    \  This is the preferred way to perform name comparisons\n   instead of using\
    \ the printable names that a given GSS-API\n   implementation may support.  Since\
    \ GSS-API assumes that all primitive\n   names contained within a given internal\
    \ name refer to the same\n   entity, equal can return \"true\" if the two names\
    \ have at least one\n   primitive name in common.  If the implementation embodies\
    \ knowledge\n   of equivalence relationships between names taken from different\n\
    \   namespaces, this knowledge may also allow successful comparisons of\n   internal\
    \ names containing no overlapping primitive elements.\n   When used in large access\
    \ control lists, the overhead of creating an\n   GSSName object on each name and\
    \ invoking the equal method on each\n   name from the ACL may be prohibitive.\
    \  As an alternative way of\n   supporting this case, GSS-API defines a special\
    \ form of the\n   contiguous byte array name which may be compared directly (byte\
    \ by\n   byte).  Contiguous names suitable for comparison are generated by the\n\
    \   export method.  Exported names may be re-imported by using the byte\n   array\
    \ constructor and specifying the NT_EXPORT_NAME as the name type\n   object identifier.\
    \  The resulting GSSName name will also be a MN.\n   The GSSName interface defines\
    \ public static Oid objects representing\n   the standard name types.  Structurally,\
    \ an exported name object\n   consists of a header containing an OID identifying\
    \ the mechanism that\n   authenticated the name, and a trailer containing the\
    \ name itself,\n   where the syntax of the trailer is defined by the individual\n\
    \   mechanism specification.  Detailed description of the format is\n   specified\
    \ in the language-independent GSS-API specification\n   [GSSAPIv2-UPDATE].\n \
    \  Note that the results obtained by using the equals method will in\n   general\
    \ be different from those obtained by invoking canonicalize and\n   export, and\
    \ then comparing the byte array output.  The first series\n   of operation determines\
    \ whether two (unauthenticated) names identify\n   the same principal; the second\
    \ whether a particular mechanism would\n   authenticate them as the same principal.\
    \  These two operations will\n   in general give the same results only for MNs.\n\
    \   It is important to note that the above are guidelines as how GSSName\n   implementations\
    \ should behave, and are not intended to be specific\n   requirements of how names\
    \ objects must be implemented.  The mechanism\n   designers are free to decide\
    \ on the details of their implementations\n   of the GSSName interface as long\
    \ as the behavior satisfies the above\n   guidelines.\n"
- title: 4.14.  Channel Bindings
  contents:
  - "4.14.  Channel Bindings\n   GSS-API supports the use of user-specified tags to\
    \ identify a given\n   context to the peer application.  These tags are intended\
    \ to be used\n   to identify the particular communications channel that carries\
    \ the\n   context.  Channel bindings are communicated to the GSS-API using the\n\
    \   ChannelBinding object.  The application may use byte arrays to\n   specify\
    \ the application data to be used in the channel binding as\n   well as using\
    \ instances of the InetAddress.  The InetAddress for the\n   initiator and/or\
    \ acceptor can be used within an instance of a\n   ChannelBinding.  ChannelBinding\
    \ can be set for the GSSContext object\n   using the setChannelBinding method\
    \ before the first call to init or\n   accept has been performed.  Unless the\
    \ setChannelBinding method has\n   been used to set the ChannelBinding for a GSSContext\
    \ object, \"null\"\n   ChannelBinding will be assumed.  InetAddress is currently\
    \ the only\n   address type defined within the Java platform and as such, it is\
    \ the\n   only one supported within the ChannelBinding class.  Applications\n\
    \   that use other types of addresses can include them as part of the\n   application\
    \ specific data.\n   Conceptually, the GSS-API concatenates the initiator and\
    \ acceptor\n   address information, and the application supplied byte array to\
    \ form\n   an octet string.  The mechanism calculates a MIC over this octet\n\
    \   string and binds the MIC to the context establishment token emitted\n   by\
    \ init method of the GSSContext interface.  The same bindings are\n   set by the\
    \ context acceptor for its GSSContext object and during\n   processing of the\
    \ accept method a MIC is calculated in the same way.\n   The calculated MIC is\
    \ compared with that found in the token, and if\n   the MICs differ, accept will\
    \ throw a GSSException with the  major\n   code set to BAD_BINDINGS, and the context\
    \ will not be established.\n   Some mechanisms may include the actual channel\
    \ binding data in the\n   token (rather than just a MIC); applications should\
    \ therefore not use\n   confidential data as channel-binding components.\n   Individual\
    \ mechanisms may impose additional constraints on addresses\n   that may appear\
    \ in channel bindings.  For example, a mechanism may\n   verify that the initiator\
    \ address field of the channel binding\n   contains the correct network address\
    \ of the host system.  Portable\n   applications should therefore ensure that\
    \ they either provide correct\n   information for the address fields, or omit\
    \ setting of the addressing\n   information.\n"
- title: 4.15.  Stream Objects
  contents:
  - "4.15.  Stream Objects\n   The context object provides overloaded methods which\
    \ use input and\n   output streams as the means to convey authentication and per-message\n\
    \   GSS-API tokens.  It is important to note that the streams are\n   expected\
    \ to contain the usual GSS-API tokens which would otherwise be\n   handled through\
    \ the usage of byte arrays.  The tokens are expected to\n   have a definite start\
    \ and an end.  The callers are responsible for\n   ensuring that the supplied\
    \ streams will not block, or expect to block\n   until a full token is processed\
    \ by the GSS-API method.  Only a single\n   GSS-API token will be processed per\
    \ invocation of the stream based\n   method.\n   The usage of streams allows the\
    \ callers to have control and\n   management of the supplied buffers.  Because\
    \ streams are non-\n   primitive objects, the callers can make the streams as\
    \ complicated or\n   as simple as desired simply by using the streams defined\
    \ in the\n   java.io package or creating their own through the use of inheritance.\n\
    \   This will allow for the application's greatest flexibility.\n"
- title: 4.16.  Optional Parameters
  contents:
  - "4.16.  Optional Parameters\n   Whenever the application wishes to omit an optional\
    \ parameter the\n   \"null\" value shall be used.  The detailed method descriptions\n\
    \   indicate which parameters are optional.  Methods overloading has also\n  \
    \ been used as a technique to indicate default parameters.\n"
- title: 5.  Introduction to GSS-API Classes and Interfaces
  contents:
  - "5.  Introduction to GSS-API Classes and Interfaces\n   This section presents\
    \ a brief description of the classes and\n   interfaces that constitute the GSS-API.\
    \  The implementations of these\n   are obtained from the CLASSPATH defined by\
    \ the application.  If Java\n   GSS becomes part of the standard Java API's then\
    \ these classes will\n   be available by default on all systems as part of the\
    \ JRE's system\n   classes.\n   This section also shows the corresponding RFC\
    \ 2743 functionality\n   implemented by each of the classes.  Detailed description\
    \ of these\n   classes and their methods is presented in section 6.\n"
- title: 5.1.  GSSManager class
  contents:
  - "5.1.  GSSManager class\n   This abstract class serves as a factory to instantiate\n\
    \   implementations of the GSS-API interfaces and also provides methods\n   to\
    \ make queries about underlying security mechanisms.\n   A default implementation\
    \ can be obtained using the static method\n   getInstance(). Applications that\
    \ desire to provide their own\n   implementation of the GSSManager class can simply\
    \ extend the abstract\n   class themselves.\n   This class contains equivalents\
    \ of the following RFC 2743 routines:\n   gss_import_name              Create\
    \ an internal name from   6.1.9-\n                                the supplied\
    \ information.      6.1.12\n   gss_acquire_cred             Acquire credential\
    \             6.1.13-\n                                for use.              \
    \         6.1.15\n   gss_import_sec_context       Create a previously exported\
    \   6.1.18\n                                context.\n   gss_indicate_mechs  \
    \         List the mechanisms            6.1.6\n                             \
    \   supported by this GSS-API\n                                implementation.\n\
    \   gss_inquire_mechs_for_name   List the mechanisms            6.1.8\n      \
    \                          supporting the\n                                specified\
    \ name type.\n   gss_inquire_names_for_mech   List the name types            6.1.7\n\
    \                                supported by the\n                          \
    \      specified mechanism.\n"
- title: 5.2.  GSSName interface
  contents:
  - "5.2.  GSSName interface\n   GSS-API names are represented in the Java bindings\
    \ through the\n   GSSName interface.  Different name formats and their definitions\
    \ are\n   identified with universal Object Identifiers (oids).  The format of\n\
    \   the names can be derived based on the unique oid of each name type.\n   The\
    \ following GSS-API routines are provided by the GSSName interface:\n   RFC 2743\
    \ Routine                 Function               Section(s)\n   gss_display_name\
    \        Covert internal name             6.2.7\n                           representation\
    \ to text format.\n   gss_compare_name        Compare two internal names.    \
    \  6.2.3, 6.2.4\n   gss_release_name        Release resources associated     N/A\n\
    \                           with the internal name.\n   gss_canonicalize_name\
    \   Convert an internal name to a    6.1.11,\n                           mechanism\
    \ name.\n   gss_export_name         Convert a mechanism name to      6.2.6\n \
    \                          export format.\n   gss_duplicate_name      Create a\
    \ copy of the internal    N/A\n                           name.\n   The gss_release_name\
    \ call is not provided as Java does its own\n   garbage collection. The gss_duplicate_name\
    \ call is also redundant;\n   the GSSName interface has no mutator methods that\
    \ can change the\n   state of the object so it is safe for sharing.\n"
- title: 5.3.  GSSCredential interface
  contents:
  - "5.3.  GSSCredential interface\n   The GSSCredential interface is responsible\
    \ for the encapsulation of\n   GSS-API credentials.  Credentials identify a single\
    \ entity and\n   provide the necessary cryptographic information to enable the\n\
    \   creation of a context on behalf of that entity.  A single credential\n   may\
    \ contain multiple mechanism specific credentials, each referred to\n   as a credential\
    \ element.  The GSSCredential interface provides the\n   functionality of the\
    \ following GSS-API routines:\n   RFC 2743 Routine               Function    \
    \            Section(s)\n   gss_add_cred               Constructs credentials\
    \        6.3.12\n                              incrementally.\n   gss_inquire_cred\
    \           Obtain information about   6.3.4,6.3.5\n                         \
    \     credential.\n   gss_inquire_cred_by_mech   Obtain per-mechanism       6.3.5-6.3.10\n\
    \                              information about\n                           \
    \   a credential.\n   gss_release_cred           Disposes of credentials     \
    \  6.3.3\n                              after use.\n"
- title: 5.4.  GSSContext interface
  contents:
  - "5.4.  GSSContext interface\n   This interface encapsulates the functionality\
    \ of context-level calls\n   required for security context establishment and management\
    \ between\n   peers as well as the per-message services offered to applications.\
    \  A\n   context is established between a pair of peers and allows the usage\n\
    \   of security services on a per-message basis on application data.  It\n   is\
    \ created over a single security mechanism.  The GSSContext\n   interface provides\
    \ the functionality of the following GSS-API\n   routines:\n   RFC 2743 Routine\
    \                 Function                Section(s)\n   gss_init_sec_context\
    \     Initiate the creation of a       6.4.3,\n                            security\
    \ context with a peer.    6.4.4\n   gss_accept_sec_context   Accept a security\
    \ context        6.4.5,\n                            initiated by a peer.    \
    \         6.4.6\n   gss_delete_sec_context   Destroy a security context.     \
    \ 6.4.8\n   gss_context_time         Obtain remaining context         6.4.37\n\
    \                            time.\n   gss_inquire_context      Obtain context\
    \                   6.4.29 to\n                            characteristics.  \
    \               6.3.42\n   gss_wrap_size_limit      Determine token-size limit\
    \       6.4.9\n                            for gss_wrap.\n   gss_export_sec_context\
    \   Transfer security context        6.4.18\n                            to another\
    \ process.\n   gss_get_mic              Calculate a cryptographic        6.4.14,\n\
    \                            Message Integrity Code (MIC)     6.4.15\n       \
    \                     for a message.\n   gss_verify_mic           Verify integrity\
    \ on a received   6.4.16,\n                            message.              \
    \           6.4.17\n   gss_wrap                 Attach a MIC to a message and\
    \    6.4.10,\n                            optionally encrypt the message   6.4.11\n\
    \                            content.\n   gss_unwrap               Obtain a previously\
    \ wrapped      6.4.12,\n                            application message verifying\
    \    6.4.13\n                            its integrity and optionally\n      \
    \                      decrypting it.\n   The functionality offered by the gss_process_context_token\
    \ routine\n   has not been included in the Java bindings specification.  The\n\
    \   corresponding functionality of gss_delete_sec_context has also been\n   modified\
    \ to not return any peer tokens.  This has been proposed in\n   accordance to\
    \ the recommendations stated in RFC 2743.  GSSContext\n   does offer the functionality\
    \ of destroying the locally-stored context\n   information.\n"
- title: 5.5.  MessageProp class
  contents:
  - "5.5.  MessageProp class\n   This helper class is used in the per-message operations\
    \ on the\n   context.  An instance of this class is created by the application\
    \ and\n   then passed into the per-message calls.  In some cases, the\n   application\
    \ conveys information to the GSS-API implementation through\n   this object and\
    \ in other cases the GSS-API returns information to the\n   application by setting\
    \ it in this object.  See the description of the\n   per-message operations wrap,\
    \ unwrap, getMIC, and verifyMIC in the\n   GSSContext interfaces for details.\n"
- title: 5.6.  GSSException class
  contents:
  - "5.6.  GSSException class\n   Exceptions are used in the Java bindings to signal\
    \ fatal errors to\n   the calling applications.  This replaces the major and minor\
    \ codes\n   used in the C-bindings specification as a method of signaling\n  \
    \ failures.  The GSSException class handles both minor and major codes,\n   as\
    \ well as their translation into textual representation.  All GSS-\n   API methods\
    \ are declared as throwing this exception.\n   RFC 2743 Routine           Function\
    \              Section\n   gss_display_status   Retrieve textual          6.8.5,\
    \ 6.8.6,\n                        representation of error   6.8.8, 6.8.9\n   \
    \                     codes.\n"
- title: 5.7.  Oid class
  contents:
  - "5.7.  Oid class\n   This utility class is used to represent Universal Object\
    \ Identifiers\n   and their associated operations.  GSS-API uses object identifiers\
    \ to\n   distinguish between security mechanisms and name types.  This class,\n\
    \   aside from being used whenever an object identifier is needed,\n   implements\
    \ the following GSS-API functionality:\n   RFC 2743 Routine                  Function\
    \              Section\n   gss_test_oid_set_member   Determine if the specified\
    \ oid   6.7.5\n                             is part of a set of oids.\n"
- title: 5.8.  ChannelBinding class
  contents:
  - "5.8.  ChannelBinding class\n   An instance of this class is used to specify channel\
    \ binding\n   information to the GSSContext object before the start of a security\n\
    \   context establishment.  The application may use a byte array to\n   specify\
    \ application data to be used in the channel binding as well as\n   use instances\
    \ of the InetAddress.  InetAddress is currently the only\n   address type defined\
    \ within the Java platform and as such, it is the\n   only one supported within\
    \ the ChannelBinding class. Applications that\n   use other types of addresses\
    \ can include them as part of the\n   application data.\n"
- title: 6.  Detailed GSS-API Class Description
  contents:
  - "6.  Detailed GSS-API Class Description\n   This section lists a detailed description\
    \ of all the public methods\n   that each of the GSS-API classes and interfaces\
    \ must provide.\n"
- title: 6.1.  public abstract class GSSManager
  contents:
  - "6.1.  public abstract class GSSManager\n   The GSSManager class is an abstract\
    \ class that serves as a factory\n   for three GSS interfaces: GSSName, GSSCredential,\
    \ and GSSContext. It\n   also provides methods for applications to determine what\
    \ mechanisms\n   are available from the GSS implementation and what nametypes\
    \ these\n   mechanisms support. An instance of the default GSSManager subclass\n\
    \   may be obtained through the static method getInstance(), but\n   applications\
    \ are free to instantiate other subclasses of GSSManager.\n   All but one method\
    \ in this class are declared abstract. This means\n   that subclasses have to\
    \ provide the complete implementation for those\n   methods. The only exception\
    \ to this is the static method\n   getInstance() which will have platform specific\
    \ code to return an\n   instance of the default subclass.\n   Platform providers\
    \ of GSS are required not to add any constructors to\n   this class, private,\
    \ public, or protected. This will ensure that all\n   subclasses invoke only the\
    \ default constructor provided to the base\n   class by the compiler.\n   A subclass\
    \ extending the GSSManager abstract class may be implemented\n   as a modular\
    \ provider based layer that utilizes some well known\n   service provider specification.\
    \ The GSSManager API provides the\n   application with methods to set provider\
    \ preferences on such an\n   implementation. These methods also allow the implementation\
    \ to throw\n   a well-defined exception in case provider based configuration is\
    \ not\n   supported. Applications that expect to be portable should be aware of\n\
    \   this and recover cleanly by catching the exception.\n   It is envisioned that\
    \ there will be three most common ways in which\n   providers will be used:\n\
    \      1) The application does not care about what provider is used (the\n   \
    \      default case).\n      2) The application wants a particular provider to\
    \ be used\n         preferentially, either for a particular mechanism or all the\n\
    \         time, irrespective of mechanism.\n      3) The application wants to\
    \ use the locally configured providers\n         as far as possible but if support\
    \ is missing for one or more\n         mechanisms then it wants to fall back on\
    \ its own provider.\n   The GSSManager class has two methods that enable these\
    \ modes of\n   usage:  addProviderAtFront() and addProviderAtEnd(). These methods\n\
    \   have the effect of creating an ordered list of <provider, oid> pairs\n   where\
    \ each pair indicates a preference of provider for a given oid.\n   The use of\
    \ these methods does not require any knowledge of whatever\n   service provider\
    \ specification the GSSManager subclass follows. It is\n   hoped that these methods\
    \ will serve the needs of most applications.\n   Additional methods may be added\
    \ to an extended GSSManager that could\n   be part of a service provider specification\
    \ that is standardized\n   later.\n"
- title: 6.1.1.  Example Code
  contents:
  - "6.1.1.  Example Code\n   GSSManager mgr = GSSManager.getInstance();\n   // What\
    \ mechs are available to us?\n   Oid[] supportedMechs = mgr.getMechs();\n   //\
    \ Set a preference for the provider to be used when support is needed\n   // for\
    \ the mechanisms \"1.2.840.113554.1.2.2\" and \"1.3.6.1.5.5.1.1\".\n   Oid krb\
    \ = new Oid(\"1.2.840.113554.1.2.2\");\n   Oid spkm1 = new Oid(\"1.3.6.1.5.5.1.1\"\
    );\n   Provider p = (Provider) (new com.foo.security.Provider());\n   mgr.addProviderAtFront(p,\
    \ krb);\n   mgr.addProviderAtFront(p, spkm1);\n   // What name types does this\
    \ spkm implementation support?\n   Oid[] nameTypes = mgr.getNamesForMech(spkm1);\n"
- title: 6.1.2.  getInstance
  contents:
  - "6.1.2.  getInstance\n   public static GSSManager getInstance()\n   Returns the\
    \ default GSSManager implementation.\n"
- title: 6.1.3.  getMechs
  contents:
  - "6.1.3.  getMechs\n   public abstract Oid[] getMechs()\n   Returns an array of\
    \ Oid objects indicating mechanisms available to\n   GSS-API callers.  A \"null\"\
    \ value is returned when no mechanism are\n   available (an example of this would\
    \ be when mechanism are dynamically\n   configured, and currently no mechanisms\
    \ are installed).\n"
- title: 6.1.4.  getNamesForMech
  contents:
  - "6.1.4.  getNamesForMech\n   public abstract  Oid[] getNamesForMech(Oid mech)\n\
    \                          throws GSSException\n   Returns name type Oid's supported\
    \ by the specified mechanism.\n   Parameters:\n      mech      The Oid object\
    \ for the mechanism to query.\n"
- title: 6.1.5.  getMechsForName
  contents:
  - "6.1.5.  getMechsForName\n   public abstract  Oid[] getMechsForName(Oid nameType)\n\
    \   Returns an array of Oid objects corresponding to the mechanisms that\n   support\
    \ the specific name type.  \"null\" is returned when no\n   mechanisms are found\
    \ to support the specified name type.\n   Parameters:\n      nameType  The Oid\
    \ object for the name type.\n"
- title: 6.1.6.  createName
  contents:
  - "6.1.6.  createName\n   public abstract GSSName createName(String nameStr, Oid\
    \ nameType)\n                   throws GSSException\n   Factory method to convert\
    \ a contiguous string name from the specified\n   namespace to a GSSName object.\
    \  In general, the GSSName object\n   created will not be an MN; two examples\
    \ that are exceptions to this\n   are when the namespace type parameter indicates\
    \ NT_EXPORT_NAME or\n   when the GSS-API implementation is not multi-mechanism.\n\
    \   Parameters:\n      nameStr   The string representing a printable form of the\
    \ name\n                to create.\n      nameType  The Oid specifying the namespace\
    \ of the printable name\n                supplied. Note that nameType serves to\
    \ describe and\n                qualify the interpretation of the input nameStr,\
    \ it\n                does not necessarily imply a type for the output\n     \
    \           GSSName implementation. \"null\" value can be used to\n          \
    \      specify that a mechanism specific default printable\n                syntax\
    \ should be assumed by each mechanism that\n                examines nameStr.\n"
- title: 6.1.7.  createName
  contents:
  - "6.1.7.  createName\n   public abstract GSSName createName(byte name[], Oid nameType)\n\
    \                   throws GSSException\n   Factory method to convert a contiguous\
    \ byte array containing a name\n   from the specified namespace to a GSSName object.\
    \  In general, the\n   GSSName object created will not be an MN; two examples\
    \ that are\n   exceptions to this are when the namespace type parameter indicates\n\
    \   NT_EXPORT_NAME or when the GSS-API implementation is not multi-\n   mechanism.\n\
    \   Parameters:\n      name      The byte array containing the name to create.\n\
    \      nameType  The Oid specifying the namespace of the name supplied\n     \
    \           in the byte array.  Note that nameType serves to\n               \
    \ describe and qualify the interpretation of the input\n                name byte\
    \ array, it does not necessarily imply a type\n                for the output\
    \ GSSName implementation. \"null\" value\n                can be used to specify\
    \ that a mechanism specific\n                default syntax should be assumed\
    \ by each mechanism\n                that examines the byte array.\n"
- title: 6.1.8.  createName
  contents:
  - "6.1.8.  createName\n   public abstract GSSName createName(String nameStr, Oid\
    \ nameType,\n                   Oid mech) throws GSSException\n   Factory method\
    \ to convert a contiguous string name from the specified\n   namespace to an GSSName\
    \ object that is a mechanism name (MN).  In\n   other words, this method is a\
    \ utility that does the equivalent of two\n   steps: the createName described\
    \ in 6.1.7 and then also the\n   GSSName.canonicalize() described in 6.2.5.\n\
    \   Parameters:\n      nameStr   The string representing a printable form of the\
    \ name\n                to create.\n      nameType  The Oid specifying the namespace\
    \ of the printable name\n                supplied.  Note that nameType serves\
    \ to describe and\n                qualify the interpretation of the input nameStr,\
    \ it\n                does not necessarily imply a type for the output\n     \
    \           GSSName implementation. \"null\" value can be used to\n          \
    \      specify that a mechanism specific default printable\n                syntax\
    \ should be assumed when the mechanism examines\n                nameStr.\n  \
    \    mech      Oid specifying the mechanism for which this name\n            \
    \    should be created.\n"
- title: 6.1.9.  createName
  contents:
  - "6.1.9.  createName\n   public abstract createName(byte name[], Oid nameType,\
    \ Oid mech)\n                   throws GSSException\n   Factory method to convert\
    \ a contiguous byte array containing a name\n   from the specified namespace to\
    \ a GSSName object that is an MN.  In\n   other words, this method is a utility\
    \ that does the equivalent of two\n   steps: the createName described in 6.1.8\
    \ and then also the\n   GSSName.canonicalize() described in 6.2.5.\n   Parameters:\n\
    \      name      The byte array representing the name to create.\n      nameType\
    \  The Oid specifying the namespace of the name supplied\n                in the\
    \ byte array.  Note that nameType serves to\n                describe and qualify\
    \ the interpretation of the input\n                name byte array, it does not\
    \ necessarily imply a type\n                for the output GSSName implementation.\
    \ \"null\" value\n                can be used to specify that a mechanism specific\n\
    \                default syntax should be assumed by each mechanism\n        \
    \        that examines the byte array.\n      mech      Oid specifying the mechanism\
    \ for which this name\n                should be created.\n"
- title: 6.1.10.  createCredential
  contents:
  - "6.1.10.  createCredential\n   public abstract GSSCredential createCredential\
    \ (int usage)\n                   throws GSSException\n   Factory method for acquiring\
    \ default credentials.  This will cause\n   the GSS-API to use system specific\
    \ defaults for the set of\n   mechanisms, name, and a DEFAULT lifetime.\n   Parameters:\n\
    \      usage     The intended usage for this credential object.  The\n       \
    \         value of this parameter must be one of:\n                GSSCredential.ACCEPT_AND_INITIATE,\n\
    \                GSSCredential.ACCEPT_ONLY, GSSCredential.INITIATE_ONLY\n"
- title: 6.1.11.  createCredential
  contents:
  - "6.1.11.  createCredential\n   public abstract GSSCredential createCredential\
    \ (GSSName aName,\n                   int lifetime, Oid mech, int usage)\n   \
    \                throws GSSException\n   Factory method for acquiring a single\
    \ mechanism credential.\n   Parameters:\n      aName     Name of the principal\
    \ for whom this credential is to\n                be acquired.  Use \"null\" to\
    \ specify the default\n                principal.\n      lifetime  The number\
    \ of seconds that credentials should remain\n                valid.  Use GSSCredential.INDEFINITE_LIFETIME\
    \ to\n                request that the credentials have the maximum\n        \
    \        permitted lifetime.  Use\n                GSSCredential.DEFAULT_LIFETIME\
    \ to request default\n                credential lifetime.\n      mech      The\
    \ oid of the desired mechanism.  Use \"(Oid) null\" to\n                request\
    \ the default mechanism(s).\n      usage     The intended usage for this credential\
    \ object.  The\n                value of this parameter must be one of:\n    \
    \            GSSCredential.ACCEPT_AND_INITIATE,\n                GSSCredential.ACCEPT_ONLY,\
    \ GSSCredential.INITIATE_ONLY\n"
- title: 6.1.12.  createCredential
  contents:
  - "6.1.12.  createCredential\n   public abstract GSSCredential createCredential(GSSName\
    \ aName,\n                   int lifetime, Oid mechs[], int usage)\n         \
    \          throws GSSException\n   Factory method for acquiring credentials over\
    \ a set of mechanisms.\n   Acquires credentials for each of the mechanisms specified\
    \ in the\n   array called mechs.  To determine the list of mechanisms' for which\n\
    \   the acquisition of credentials succeeded, the caller should use the\n   GSSCredential.getMechs()\
    \ method.\n   Parameters:\n      aName     Name of the principal for whom this\
    \ credential is to\n                be acquired.  Use \"null\" to specify the\
    \ default\n                principal.\n      lifetime  The number of seconds that\
    \ credentials should remain\n                valid.  Use GSSCredential.INDEFINITE_LIFETIME\
    \ to\n                request that the credentials have the maximum\n        \
    \        permitted lifetime.  Use\n                GSSCredential.DEFAULT_LIFETIME\
    \ to request default\n                credential lifetime.\n      mechs     The\
    \ array of mechanisms over which the credential is\n                to be acquired.\
    \  Use \"(Oid[]) null\" for requesting a\n                system specific default\
    \ set of mechanisms.\n      usage     The intended usage for this credential object.\
    \  The\n                value of this parameter must be one of:\n            \
    \    GSSCredential.ACCEPT_AND_INITIATE,\n                GSSCredential.ACCEPT_ONLY,\
    \ GSSCredential.INITIATE_ONLY\n"
- title: 6.1.13.  createContext
  contents:
  - "6.1.13.  createContext\n   public abstract GSSContext createContext(GSSName peer,\
    \ Oid mech,\n                   GSSCredential myCred, int lifetime)\n        \
    \           throws GSSException\n   Factory method for creating a context on the\
    \ initiator's side.\n   Context flags may be modified through the mutator methods\
    \ prior to\n   calling GSSContext.initSecContext().\n   Parameters:\n      peer\
    \      Name of the target peer.\n      mech      Oid of the desired mechanism.\
    \  Use \"(Oid) null\" to\n                request default mechanism.\n      myCred\
    \    Credentials of the initiator.  Use \"null\" to act as a\n               \
    \ default initiator principal.\n      lifetime  The request lifetime, in seconds,\
    \ for the context.\n                Use GSSContext.INDEFINITE_LIFETIME and\n \
    \               GSSContext.DEFAULT_LIFETIME to request indefinite or\n       \
    \         default context lifetime.\n"
- title: 6.1.14.  createContext
  contents:
  - "6.1.14.  createContext\n   public abstract GSSContext createContext(GSSCredential\
    \ myCred)\n                   throws GSSException\n   Factory method for creating\
    \ a context on the acceptor' side.  The\n   context's properties will be determined\
    \ from the input token supplied\n   to the accept method.\n   Parameters:\n  \
    \    myCred    Credentials for the acceptor.  Use \"null\" to act as a\n     \
    \           default acceptor principal.\n"
- title: 6.1.15.  createContext
  contents:
  - "6.1.15.  createContext\n   public abstract GSSContext createContext(byte [] interProcessToken)\n\
    \                   throws GSSException\n   Factory method for creating a previously\
    \ exported context.  The\n   context properties will be determined from the input\
    \ token and can't\n   be modified through the set methods.\n   Parameters:\n \
    \     interProcessToken\n                The token previously emitted from the\
    \ export method.\n"
- title: 6.1.16.  addProviderAtFront
  contents:
  - "6.1.16.  addProviderAtFront\n   public abstract void addProviderAtFront(Provider\
    \ p, Oid mech)\n                throws GSSException\n   This method is used to\
    \ indicate to the GSSManager that the\n   application would like a particular\
    \ provider to be used ahead of all\n   others when support is desired for the\
    \ given mechanism. When a value\n   of null is used instead of an Oid for the\
    \ mechanism, the GSSManager\n   must use the indicated provider ahead of all others\
    \ no matter what\n   the mechanism is. Only when the indicated provider does not\
    \ support\n   the needed mechanism should the GSSManager move on to a different\n\
    \   provider.\n   Calling this method repeatedly preserves the older settings\
    \ but\n   lowers them in preference thus forming an ordered list of provider\n\
    \   and Oid pairs that grows at the top.\n   Calling addProviderAtFront with a\
    \ null Oid will remove all previous\n   preferences that were set for this provider\
    \ in the GSSManager\n   instance. Calling addProviderAtFront with a non-null Oid\
    \ will remove\n   any previous preference that was set using this mechanism and\
    \ this\n   provider together.\n   If the GSSManager implementation does not support\
    \ an SPI with a\n   pluggable provider architecture it should throw a GSSException\
    \ with\n   the status code GSSException.UNAVAILABLE to indicate that the\n   operation\
    \ is unavailable.\n   Parameters:\n      p         The provider instance that\
    \ should be used whenever\n                support is needed for mech.\n     \
    \ mech      The mechanism for which the provider is being set\n"
- title: 6.1.16.1.  Example Code
  contents:
  - "6.1.16.1.  Example Code\n   Suppose an application desired that the provider\
    \ A always be checked\n   first when any mechanism is needed, it would call:\n\
    \           GSSManager mgr = GSSManager.getInstance();\n           // mgr may\
    \ at this point have its own pre-configured list\n           // of provider preferences.\
    \ The following will prepend to\n           // any such list:\n           mgr.addProviderAtFront(A,\
    \ null);\n   Now if it also desired that the mechanism of Oid m1 always be\n \
    \  obtained from the provider B before the previously set A was checked,\n   it\
    \ would call:\n           mgr.addProviderAtFront(B, m1);\n   The GSSManager would\
    \ then first check with B if m1 was needed. In\n   case B did not provide support\
    \ for m1, the GSSManager would continue\n   on to check with A.  If any mechanism\
    \ m2 is needed where m2 is\n   different from m1 then the GSSManager would skip\
    \ B and check with A\n   directly.\n   Suppose at a later time the following call\
    \ is made to the same\n   GSSManager instance:\n           mgr.addProviderAtFront(B,\
    \ null)\n   then the previous setting with the pair (B, m1) is subsumed by this\n\
    \   and should be removed. Effectively the list of preferences now\n   becomes\
    \ {(B, null), (A, null),\n           ... //followed by the pre-configured list.\n\
    \   Please note, however, that the following call:\n           mgr.addProviderAtFront(A,\
    \ m3)\n   does not subsume the previous setting of (A, null) and the list will\n\
    \   effectively become {(A, m3), (B, null), (A, null), ...}\n"
- title: 6.1.17.  addProviderAtEnd
  contents:
  - "6.1.17.  addProviderAtEnd\n   public abstract addProviderAtEnd(Provider p, Oid\
    \ mech)\n                   throws GSSException\n   This method is used to indicate\
    \ to the GSSManager that the\n   application would like a particular provider\
    \ to be used if no other\n   provider can be found that supports the given mechanism.\
    \ When a value\n   of null is used instead of an Oid for the mechanism, the GSSManager\n\
    \   must use the indicated provider for any mechanism.\n   Calling this method\
    \ repeatedly preserves the older settings but\n   raises them above newer ones\
    \ in preference thus forming an ordered\n   list of providers and Oid pairs that\
    \ grows at the bottom. Thus the\n   older provider settings will be utilized first\
    \ before this one is.\n   If there are any previously existing preferences that\
    \ conflict with\n   the preference being set here, then the GSSManager should\
    \ ignore this\n   request.\n   If the GSSManager implementation does not support\
    \ an SPI with a\n   pluggable provider architecture it should throw a GSSException\
    \ with\n   the status code GSSException.UNAVAILABLE to indicate that the\n   operation\
    \ is unavailable.\n   Parameters:\n      p         The provider instance that\
    \ should be used whenever\n                support is needed for mech.\n     \
    \ mech      The mechanism for which the provider is being set\n"
- title: 6.1.17.1.  Example Code
  contents:
  - "6.1.17.1.  Example Code\n   Suppose an application desired that when a mechanism\
    \ of Oid m1 is\n   needed the system default providers always be checked first,\
    \ and only\n   when they do not support m1 should a provider A be checked. It\
    \ would\n   then make the call:\n           GSSManager mgr = GSSManager.getInstance();\n\
    \           mgr.addProviderAtEnd(A, m1);\n   Now, if it also desired that for\
    \ all mechanisms the provider B be\n   checked after all configured providers\
    \ have been checked, it would\n   then call:\n           mgr.addProviderAtEnd(B,\
    \ null);\n   Effectively the list of preferences now becomes {..., (A, m1), (B,\n\
    \   null)}.\n   Suppose at a later time the following call is made to the same\n\
    \   GSSManager instance:\n           mgr.addProviderAtEnd(B, m2)\n   then the\
    \ previous setting with the pair (B, null) subsumes this and\n   therefore this\
    \ request should be ignored. The same would happen if a\n   request is made for\
    \ the already existing pairs of (A, m1) or (B,\n   null).\n   Please note, however,\
    \ that the following call:\n           mgr.addProviderAtEnd(A, null)\n   is not\
    \ subsumed by the previous setting of (A, m1) and the list will\n   effectively\
    \ become {..., (A, m1), (B, null), (A, null)}\n"
- title: 6.2.  public interface GSSName
  contents:
  - "6.2.  public interface GSSName\n   This interface encapsulates a single GSS-API\
    \ principal entity.\n   Different name formats and their definitions are identified\
    \ with\n   universal Object Identifiers (Oids).  The format of the names can be\n\
    \   derived based on the unique oid of its namespace type.\n"
- title: 6.2.1.  Example Code
  contents:
  - "6.2.1.  Example Code\n   Included below are code examples utilizing the GSSName\
    \ interface.\n   The code below creates a GSSName, converts it to a mechanism\
    \ name\n   (MN), performs a comparison, obtains a printable representation of\n\
    \   the name, exports it and then re-imports to obtain a new GSSName.\n   GSSManager\
    \ mgr = GSSManager.getInstance();\n   // create a host based service name\n  \
    \ GSSName name = mgr.createName(\"service@host\",\n                   GSSName.NT_HOSTBASED_SERVICE);\n\
    \   Oid krb5 = new Oid(\"1.2.840.113554.1.2.2\");\n   GSSName mechName = name.canonicalize(krb5);\n\
    \   // the above two steps are equivalent to the following\n   GSSName mechName\
    \ = mgr.createName(\"service@host\",\n                   GSSName.NT_HOSTBASED_SERVICE,\
    \ krb5);\n   // perform name comparison\n   if (name.equals(mechName))\n     \
    \      print(\"Names are equals.\");\n   // obtain textual representation of name\
    \ and its printable\n   // name type\n   print(mechName.toString() +\n       \
    \            mechName.getStringNameType().toString());\n   // export and re-import\
    \ the name\n   byte [] exportName = mechName.export();\n   // create a new name\
    \ object from the exported buffer\n   GSSName newName = mgr.createName(exportName,\n\
    \                   GSSName.NT_EXPORT_NAME);\n"
- title: 6.2.2.  Static Constants
  contents:
  - "6.2.2.  Static Constants\n   public static final Oid NT_HOSTBASED_SERVICE\n \
    \  Oid indicating a host-based service name form.  It is used to\n   represent\
    \ services associated with host computers.  This name form is\n   constructed\
    \ using two elements, \"service\" and \"hostname\", as follows:\n        service@hostname\n\
    \   Values for the \"service\" element are registered with the IANA. It\n   represents\
    \ the following value: { 1(iso), 3(org), 6(dod),\n   1(internet), 5(security),\
    \ 6(nametypes), 2(gss-host-based-services) }\n   public static final Oid NT_USER_NAME\n\
    \   Name type to indicate a named user on a local system.  It represents\n   the\
    \ following value: { iso(1) member-body(2) United States(840)\n   mit(113554)\
    \ infosys(1) gssapi(2) generic(1) user_name(1) }\n   public static final Oid NT_MACHINE_UID_NAME\n\
    \   Name type to indicate a numeric user identifier corresponding to a\n   user\
    \ on a local system. (e.g. Uid).  It represents the following\n   value: { iso(1)\
    \ member-body(2) United States(840) mit(113554)\n   infosys(1) gssapi(2) generic(1)\
    \ machine_uid_name(2) }\n   public static final Oid NT_STRING_UID_NAME\n   Name\
    \ type to indicate a string of digits representing the numeric\n   user identifier\
    \ of a user on a local system. It represents the\n   following value:  { iso(1)\
    \ member-body(2) United States(840)\n   mit(113554) infosys(1) gssapi(2) generic(1)\
    \ string_uid_name(3) }\n   public static final Oid NT_ANONYMOUS\n   Name type\
    \ for representing an anonymous entity. It represents the\n   following value:\
    \ { 1(iso), 3(org), 6(dod), 1(internet), 5(security),\n   6(nametypes), 3(gss-anonymous-name)\
    \ }\n   public static final Oid NT_EXPORT_NAME\n   Name type used to indicate\
    \ an exported name produced by the export\n   method. It represents the following\
    \ value: { 1(iso), 3(org), 6(dod),\n   1(internet), 5(security), 6(nametypes),\
    \ 4(gss-api-exported-name) }\n"
- title: 6.2.3.  equals
  contents:
  - "6.2.3.  equals\n   public boolean equals(GSSName another) throws GSSException\n\
    \   Compares two GSSName objects to determine whether they refer to the\n   same\
    \ entity.  This method may throw a GSSException when the names\n   cannot be compared.\
    \  If either of the names represents an anonymous\n   entity, the method will\
    \ return \"false\".\n   Parameters:\n      another   GSSName object to compare\
    \ with.\n"
- title: 6.2.4.  equals
  contents:
  - "6.2.4.  equals\n   public boolean equals(Object another)\n   A variation of the\
    \ equals method described in 6.2.3 that is provided\n   to override the Object.equals()\
    \ method that the implementing class\n   will inherit.  The behavior is exactly\
    \ the same as that in 6.2.3\n   except that no GSSException is thrown; instead,\
    \ false will be\n   returned in the situation where an error occurs.  (Note that\
    \ the Java\n   language specification requires that two objects that are equal\n\
    \   according to the equals(Object) method must return the same integer\n   result\
    \ when the hashCode() method is called on them.)\n   Parameters:\n      another\
    \   GSSName object to compare with.\n"
- title: 6.2.5.  canonicalize
  contents:
  - "6.2.5.  canonicalize\n   public GSSName canonicalize(Oid mech) throws GSSException\n\
    \   Creates a mechanism name (MN) from an arbitrary internal name.  This\n   is\
    \ equivalent to using the factory methods described in 6.1.9 or\n   6.1.10 that\
    \ take the mechanism name as one of their parameters.\n   Parameters:\n      mech\
    \      The oid for the mechanism for which the canonical form\n              \
    \  of the name is requested.\n"
- title: 6.2.6.  export
  contents:
  - "6.2.6.  export\n   public byte[] export() throws GSSException\n   Returns a canonical\
    \ contiguous byte representation of a mechanism\n   name (MN), suitable for direct,\
    \ byte by byte comparison by\n   authorization functions.  If the name is not\
    \ an MN, implementations\n   may throw a GSSException with the NAME_NOT_MN status\
    \ code.  If an\n   implementation chooses not to throw an exception, it should\
    \ use some\n   system specific default mechanism to canonicalize the name and\
    \ then\n   export it.  The format of the header of the output buffer is\n   specified\
    \ in RFC 2743.\n"
- title: 6.2.7.  toString
  contents:
  - "6.2.7.  toString\n   public String toString()\n   Returns a textual representation\
    \ of the GSSName object.  To retrieve\n   the printed name format, which determines\
    \ the syntax of the returned\n   string, the getStringNameType method can be used.\n"
- title: 6.2.8.  getStringNameType
  contents:
  - "6.2.8.  getStringNameType\n   public Oid getStringNameType() throws GSSException\n\
    \   Returns the oid representing the type of name returned through the\n   toString\
    \ method.  Using this oid, the syntax of the printable name\n   can be determined.\n"
- title: 6.2.9.  isAnonymous
  contents:
  - "6.2.9.  isAnonymous\n   public boolean isAnonymous()\n   Tests if this name object\
    \ represents an anonymous entity.  Returns\n   \"true\" if this is an anonymous\
    \ name.\n"
- title: 6.2.10.  isMN
  contents:
  - "6.2.10.  isMN\n   public boolean isMN()\n   Tests if this name object contains\
    \ only one mechanism element and is\n   thus a mechanism name as defined by RFC\
    \ 2743.\n"
- title: 6.3.  public interface GSSCredential implements Cloneable
  contents:
  - "6.3.  public interface GSSCredential implements Cloneable\n   This interface\
    \ encapsulates the GSS-API credentials for an entity.  A\n   credential contains\
    \ all the necessary cryptographic information to\n   enable the creation of a\
    \ context on behalf of the entity that it\n   represents.  It may contain multiple,\
    \ distinct, mechanism specific\n   credential elements, each containing information\
    \ for a specific\n   security mechanism, but all referring to the same entity.\n\
    \   A credential may be used to perform context initiation, acceptance,\n   or\
    \ both.\n   GSS-API implementations must impose a local access-control policy\
    \ on\n   callers to prevent unauthorized callers from acquiring credentials to\n\
    \   which they are not entitled.  GSS-API credential creation is not\n   intended\
    \ to provide a \"login to the network\" function, as such a\n   function would\
    \ involve the creation of new credentials rather than\n   merely acquiring a handle\
    \ to existing credentials.  Such functions,\n   if required, should be defined\
    \ in implementation-specific extensions\n   to the API.\n   If credential acquisition\
    \ is time-consuming for a mechanism, the\n   mechanism may choose to delay the\
    \ actual acquisition until the\n   credential is required (e.g.  by GSSContext).\
    \  Such mechanism-\n   specific implementation decisions should be invisible to\
    \ the calling\n   application; thus the query methods immediately following the\n\
    \   creation of a credential object must return valid credential data,\n   and\
    \ may therefore incur the overhead of a deferred credential\n   acquisition.\n\
    \   Applications will create a credential object passing the desired\n   parameters.\
    \  The application can then use the query methods to obtain\n   specific information\
    \ about the instantiated credential object\n   (equivalent to the gss_inquire\
    \ routines).  When the credential is no\n   longer needed, the application should\
    \ call the dispose (equivalent to\n   gss_release_cred) method to release any\
    \ resources held by the\n   credential object and to destroy any cryptographically\
    \ sensitive\n   information.\n   Classes implementing this interface also implement\
    \ the Cloneable\n   interface. This indicates the the class will support the clone()\n\
    \   method that will allow the creation of duplicate credentials.  This\n   is\
    \ useful when called just before the add() call to retain a copy of\n   the original\
    \ credential.\n"
- title: 6.3.1.  Example Code
  contents:
  - "6.3.1.  Example Code\n   This example code demonstrates the creation of a GSSCredential\n\
    \   implementation for a specific entity, querying of its fields, and its\n  \
    \ release when it is no longer needed.\n   GSSManager mgr = GSSManager.getInstance();\n\
    \   // start by creating a name object for the entity\n   GSSName name = mgr.createName(\"\
    userName\", GSSName.NT_USER_NAME);\n   // now acquire credentials for the entity\n\
    \   GSSCredential cred = mgr.createCredential(name,\n                   GSSCredential.ACCEPT_ONLY);\n\
    \   // display credential information - name, remaining lifetime,\n   // and the\
    \ mechanisms it has been acquired over\n   print(cred.getName().toString());\n\
    \   print(cred.getRemainingLifetime());\n   Oid [] mechs = cred.getMechs();\n\
    \   if (mechs != null) {\n           for (int i = 0; i < mechs.length; i++)\n\
    \                   print(mechs[i].toString());\n   }\n   // release system resources\
    \ held by the credential\n   cred.dispose();\n"
- title: 6.3.2.  Static Constants
  contents:
  - "6.3.2.  Static Constants\n   public static final int INITIATE_AND_ACCEPT\n  \
    \ Credential usage flag requesting that it be able to be used for both\n   context\
    \ initiation and acceptance.\n   public static final int INITIATE_ONLY\n   Credential\
    \ usage flag requesting that it be able to be used for\n   context initiation\
    \ only.\n   public static final int ACCEPT_ONLY\n   Credential usage flag requesting\
    \ that it be able to be used for\n   context acceptance only.\n   public static\
    \ final int DEFAULT_LIFETIME\n   A lifetime constant representing the default\
    \ credential lifetime.\n   This value must be set to 0.\n   public static final\
    \ int INDEFINITE_LIFETIME\n   A lifetime constant representing indefinite credential\
    \ lifetime.\n   This value must be set to the maximum integer value in Java -\n\
    \   Integer.MAX_VALUE.\n"
- title: 6.3.3.  dispose
  contents:
  - "6.3.3.  dispose\n   public void dispose() throws GSSException\n   Releases any\
    \ sensitive information that the GSSCredential object may\n   be containing. \
    \ Applications should call this method as soon as the\n   credential is no longer\
    \ needed to minimize the time any sensitive\n   information is maintained.\n"
- title: 6.3.4.  getName
  contents:
  - "6.3.4.  getName\n   public GSSName getName() throws GSSException\n   Retrieves\
    \ the name of the entity that the credential asserts.\n"
- title: 6.3.5.  getName
  contents:
  - "6.3.5.  getName\n   public GSSName getName(Oid mechOID) throws GSSException\n\
    \   Retrieves a mechanism name of the entity that the credential asserts.\n  \
    \ Equivalent to calling canonicalize() on the name returned by 7.3.3.\n   Parameters:\n\
    \      mechOID   The mechanism for which information should be\n             \
    \   returned.\n"
- title: 6.3.6.  getRemainingLifetime
  contents:
  - "6.3.6.  getRemainingLifetime\n   public int getRemainingLifetime() throws GSSException\n\
    \   Returns the remaining lifetime in seconds for a credential.  The\n   remaining\
    \ lifetime is the minimum lifetime for any of the underlying\n   credential mechanisms.\
    \  A return value of\n   GSSCredential.INDEFINITE_LIFETIME indicates that the\
    \ credential does\n   not expire.  A return value of 0 indicates that the credential\
    \ is\n   already expired.\n"
- title: 6.3.7.  getRemainingInitLifetime
  contents:
  - "6.3.7.  getRemainingInitLifetime\n   public int getRemainingInitLifetime(Oid\
    \ mech) throws GSSException\n   Returns the remaining lifetime is seconds for\
    \ the credential to\n   remain capable of initiating security contexts under the\
    \ specified\n   mechanism.  A return value of GSSCredential.INDEFINITE_LIFETIME\n\
    \   indicates that the credential does not expire for context initiation.\n  \
    \ A return value of 0 indicates that the credential is already expired.\n   Parameters:\n\
    \      mechOID   The mechanism for which information should be\n             \
    \   returned.\n"
- title: 6.3.8.  getRemainingAcceptLifetime
  contents:
  - "6.3.8.  getRemainingAcceptLifetime\n   public int getRemainingAcceptLifetime(Oid\
    \ mech) throws GSSException\n   Returns the remaining lifetime is seconds for\
    \ the credential to\n   remain capable of accepting security contexts under the\
    \ specified\n   mechanism.  A return value of GSSCredential.INDEFINITE_LIFETIME\n\
    \   indicates that the credential does not expire for context acceptance.\n  \
    \ A return value of 0 indicates that the credential is already expired.\n   Parameters:\n\
    \      mechOID   The mechanism for which information should be\n             \
    \   returned.\n"
- title: 6.3.9.  getUsage
  contents:
  - "6.3.9.  getUsage\n   public int getUsage() throws GSSException\n   Returns the\
    \ credential usage flag.  The return value will be one of\n   GSSCredential.INITIATE_ONLY,\
    \ GSSCredential.ACCEPT_ONLY, or\n   GSSCredential.INITIATE_AND_ACCEPT.\n"
- title: 6.3.10.  getUsage
  contents:
  - "6.3.10.  getUsage\n   public int getUsage(Oid mechOID) throws GSSException\n\
    \   Returns the credential usage flag for the specified credential\n   mechanism.\
    \  The return value will be one of\n   GSSCredential.INITIATE_ONLY, GSSCredential.ACCEPT_ONLY,\
    \ or\n   GSSCredential.INITIATE_AND_ACCEPT.\n   Parameters:\n      mechOID   The\
    \ mechanism for which information should be\n                returned.\n"
- title: 6.3.11.  getMechs
  contents:
  - "6.3.11.  getMechs\n   public Oid[] getMechs() throws GSSException\n   Returns\
    \ an array of mechanisms supported by this credential.\n"
- title: 6.3.12.  add
  contents:
  - "6.3.12.  add\n   public void add(GSSName aName, int initLifetime, int acceptLifetime,\n\
    \                   Oid mech, int usage) throws GSSException\n   Adds a mechanism\
    \ specific credential-element to an existing\n   credential.  This method allows\
    \ the construction of credentials one\n   mechanism at a time.\n   This routine\
    \ is envisioned to be used mainly by context acceptors\n   during the creation\
    \ of acceptance credentials which are to be used\n   with a variety of clients\
    \ using different security mechanisms.\n   This routine adds the new credential\
    \ element \"in-place\".  To add the\n   element in a new credential, first call\
    \ clone() to obtain a copy of\n   this credential, then call its add() method.\n\
    \   Parameters:\n      aName     Name of the principal for whom this credential\
    \ is to\n                be acquired. Use \"null\" to specify the default\n  \
    \              principal.\n      initLifetime\n                The number of seconds\
    \ that credentials should remain\n                valid for initiating of security\
    \ contexts.  Use\n                GSSCredential.INDEFINITE_LIFETIME to request\
    \ that the\n                credentials have the maximum permitted lifetime. Use\n\
    \                GSSCredential.DEFAULT_LIFETIME to request default\n         \
    \       credential lifetime.\n      acceptLifetime\n                The number\
    \ of seconds that credentials should remain\n                valid for accepting\
    \ of security contexts.  Use\n                GSSCredential.INDEFINITE_LIFETIME\
    \ to request that the\n                credentials have the maximum permitted\
    \ lifetime.  Use\n                GSSCredential.DEFAULT_LIFETIME to request default\n\
    \                credential lifetime.\n      mech      The mechanisms over which\
    \ the credential is to be\n                acquired.\n      usage     The intended\
    \ usage for this credential object. The\n                value of this parameter\
    \ must be one of:\n                GSSCredential.ACCEPT_AND_INITIATE,\n      \
    \          GSSCredential.ACCEPT_ONLY, GSSCredential.INITIATE_ONLY\n"
- title: 6.3.13.  equals
  contents:
  - "6.3.13.  equals\n   public boolean equals(Object another)\n   Tests if this GSSCredential\
    \ refers to the same entity as the supplied\n   object.  The two credentials must\
    \ be acquired over the same\n   mechanisms and must refer to the same principal.\
    \  Returns \"true\" if\n   the two GSSCredentials refer to the same entity; \"\
    false\" otherwise.\n   (Note that the Java language specification requires that\
    \ two objects\n   that are equal according to the equals(Object) method must return\
    \ the\n   same integer result when the hashCode() method is called on them.)\n\
    \   Parameters:\n      another   Another GSSCredential object for comparison.\n"
- title: 6.4.  public interface GSSContext
  contents:
  - "6.4.  public interface GSSContext\n   This interface encapsulates the GSS-API\
    \ security context and provides\n   the security services (wrap, unwrap, getMIC,\
    \ verifyMIC) that are\n   available over the context.  Security contexts are established\n\
    \   between peers using locally acquired credentials.  Multiple contexts\n   may\
    \ exist simultaneously between a pair of peers, using the same or\n   different\
    \ set of credentials.  GSS-API functions in a manner\n   independent of the underlying\
    \ transport protocol and depends on its\n   calling application to transport its\
    \ tokens between peers.\n   Before the context establishment phase is initiated,\
    \ the context\n   initiator may request specific characteristics desired of the\n\
    \   established context.  These can be set using the set methods.  After\n   the\
    \ context is established, the caller can check the actual\n   characteristic and\
    \ services offered by the context using the query\n   methods.\n   The context\
    \ establishment phase begins with the first call to the\n   init method by the\
    \ context initiator.  During this phase the\n   initSecContext and acceptSecContext\
    \ methods will produce GSS-API\n   authentication tokens which the calling application\
    \ needs to send to\n   its peer.  If an error occurs at any point, an exception\
    \ will get\n   thrown and the code will start executing in a catch block.  If\
    \ not,\n   the normal flow of code continues and the application can make a call\n\
    \   to the isEstablished() method.  If this method returns false it\n   indicates\
    \ that a token is needed from its peer in order to continue\n   the context establishment\
    \ phase.  A return value of true signals that\n   the local end of the context\
    \ is established.  This may still require\n   that a token be sent to the peer,\
    \ if one is produced by GSS-API.\n   During the context establishment phase, the\
    \ isProtReady() method may\n   be called to determine if the context can be used\
    \ for the per-message\n   operations.  This allows applications to use per-message\
    \ operations\n   on contexts which aren't fully established.\n   After the context\
    \ has been established or the isProtReady() method\n   returns \"true\", the query\
    \ routines can be invoked to determine the\n   actual characteristics and services\
    \ of the established context.  The\n   application can also start using the per-message\
    \ methods of wrap and\n   getMIC to obtain cryptographic operations on application\
    \ supplied\n   data.\n   When the context is no longer needed, the application\
    \ should call\n   dispose to release any system resources the context may be using.\n"
- title: 6.4.1.  Example Code
  contents:
  - "6.4.1.  Example Code\n   The example code presented below demonstrates the usage\
    \ of the\n   GSSContext interface for the initiating peer.  Different operations\n\
    \   on the GSSContext object are presented, including: object\n   instantiation,\
    \ setting of desired flags, context establishment, query\n   of actual context\
    \ flags, per-message operations on application data,\n   and finally context deletion.\n\
    \   GSSManager mgr = GSSManager.getInstance();\n   // start by creating the name\
    \ for a service entity\n   GSSName targetName = mgr.createName(\"service@host\"\
    ,\n                   GSSName.NT_HOSTBASED_SERVICE);\n   // create a context using\
    \ default credentials for the above entity\n   // and the implementation specific\
    \ default mechanism\n   GSSContext context = mgr.createContext(targetName,\n \
    \                  null,   /* default mechanism */\n                   null, \
    \  /* default credentials */\n                   GSSContext.INDEFINITE_LIFETIME);\n\
    \   // set desired context options - all others are false by default\n   context.requestConf(true);\n\
    \   context.requestMutualAuth(true);\n   context.requestReplayDet(true);\n   context.requestSequenceDet(true);\n\
    \   // establish a context between peers - using byte arrays\n   byte []inTok\
    \ = new byte[0];\n   try {\n           do {\n                   byte[] outTok\
    \ = context.initSecContext(inTok, 0,\n                                       \
    \              inTok.length);\n                   // send the token if present\n\
    \                   if (outTok != null)\n                           sendToken(outTok);\n\
    \                   // check if we should expect more tokens\n               \
    \    if (context.isEstablished())\n                           break;\n       \
    \            // another token expected from peer\n                   inTok = readToken();\n\
    \           } while (true);\n   } catch (GSSException e) {\n           print(\"\
    GSSAPI error: \" + e.getMessage());\n   }\n   // display context information\n\
    \   print(\"Remaining lifetime in seconds = \" + context.getLifetime());\n   print(\"\
    Context mechanism = \" + context.getMech().toString());\n   print(\"Initiator\
    \ = \" + context.getSrcName().toString());\n   print(\"Acceptor = \" + context.getTargName().toString());\n\
    \   if (context.getConfState())\n           print(\"Confidentiality security service\
    \ available\");\n   if (context.getIntegState())\n           print(\"Integrity\
    \ security service available\");\n   // perform wrap on an application supplied\
    \ message, appMsg,\n   // using QOP = 0, and requesting privacy service\n   byte\
    \ [] appMsg ...\n   MessageProp mProp = new MessageProp(0, true);\n   byte []tok\
    \ = context.wrap(appMsg, 0, appMsg.length, mProp);\n   if (mProp.getPrivacy())\n\
    \           print(\"Message protected with privacy.\");\n   sendToken(tok);\n\
    \   // release the local-end of the context\n   context.dispose();\n"
- title: 6.4.2.  Static Constants
  contents:
  - "6.4.2.  Static Constants\n   public static final int DEFAULT_LIFETIME\n   A lifetime\
    \ constant representing the default context lifetime.  This\n   value must be\
    \ set to 0.\n   public static final int INDEFINITE_LIFETIME\n   A lifetime constant\
    \ representing indefinite context lifetime.  This\n   value must be set to the\
    \ maximum integer value in Java -\n   Integer.MAX_VALUE.\n"
- title: 6.4.3.  initSecContext
  contents:
  - "6.4.3.  initSecContext\n   public byte[] initSecContext(byte inputBuf[], int\
    \ offset, int len)\n                   throws GSSException\n   Called by the context\
    \ initiator to start the context creation\n   process.  This is equivalent to\
    \ the stream based method except that\n   the token buffers are handled as byte\
    \ arrays instead of using stream\n   objects.  This method may return an output\
    \ token which the\n   application will need to send to the peer for processing\
    \ by the\n   accept call.  Typically, the application would do so by calling the\n\
    \   flush() method on an OutputStream that encapsulates the connection\n   between\
    \ the two peers.  The application can call isEstablished() to\n   determine if\
    \ the context establishment phase is complete for this\n   peer.  A return value\
    \ of \"false\" from isEstablished() indicates that\n   more tokens are expected\
    \ to be supplied to the initSecContext()\n   method.  Note that it is possible\
    \ that the initSecContext() method\n   return a token for the peer, and isEstablished()\
    \ return \"true\" also.\n   This indicates that the token needs to be sent to\
    \ the peer, but the\n   local end of the context is now fully established.\n \
    \  Upon completion of the context establishment, the available context\n   options\
    \ may be queried through the get methods.\n   Parameters:\n      inputBuf  Token\
    \ generated by the peer. This parameter is ignored\n                on the first\
    \ call.\n      offset    The offset within the inputBuf where the token begins.\n\
    \      len       The length of the token within the inputBuf (starting\n     \
    \           at the offset).\n"
- title: 6.4.3.1.  Example Code
  contents:
  - "6.4.3.1.  Example Code\n   // Create a new GSSContext implementation object.\n\
    \   // GSSContext wrapper implements interface GSSContext.\n   GSSContext context\
    \ = mgr.createContext(...);\n   byte []inTok = new byte[0];\n   try {\n      \
    \     do {\n                   byte[] outTok = context.initSecContext(inTok, 0,\n\
    \                                           inTok.length);\n                 \
    \  // send the token if present\n                   if (outTok != null)\n    \
    \                       sendToken(outTok);\n                   // check if we\
    \ should expect more tokens\n                   if (context.isEstablished())\n\
    \                           break;\n                   // another token expected\
    \ from peer\n                   inTok = readToken();\n           } while (true);\n\
    \   } catch (GSSException e) {\n           print(\"GSSAPI error: \" + e.getMessage());\n\
    \   }\n"
- title: 6.4.4.  initSecContext
  contents:
  - "6.4.4.  initSecContext\n   public int initSecContext(InputStream inStream,\n\
    \                   OutputStream outStream) throws GSSException\n   Called by\
    \ the context initiator to start the context creation\n   process.  This is equivalent\
    \ to the byte array based method.  This\n   method may write an output token to\
    \ the outStream, which the\n   application will need to send to the peer for processing\
    \ by the\n   accept call. Typically, the application would do so by calling the\n\
    \   flush() method on an OutputStream that encapsulates the connection\n   between\
    \ the two peers.  The application can call isEstablished() to\n   determine if\
    \ the context establishment phase is complete for this\n   peer.  A return value\
    \ of \"false\" from isEstablished indicates that\n   more tokens are expected\
    \ to be supplied to the initSecContext method.\n   Note that it is possible that\
    \ the initSecContext() method return a\n   token for the peer, and isEstablished()\
    \ return \"true\" also.  This\n   indicates that the token needs to be sent to\
    \ the peer, but the local\n   end of the context is now fully established.\n \
    \  The GSS-API authentication tokens contain a definitive start and end.\n   This\
    \ method will attempt to read one of these tokens per invocation,\n   and may\
    \ block on the stream if only part of the token is available.\n   Upon completion\
    \ of the context establishment, the available context\n   options may be queried\
    \ through the get methods.\n   Parameters:\n      inStream  Contains the token\
    \ generated by the peer. This\n                parameter is ignored on the first\
    \ call.\n      outStream Output stream where the output token will be written.\n\
    \                During the final stage of context establishment, there\n    \
    \            may be no bytes written.\n"
- title: 6.4.4.1.  Example Code
  contents:
  - "6.4.4.1.  Example Code\n   This sample code merely demonstrates the token exchange\
    \ during the\n   context establishment phase. It is expected that most Java\n\
    \   applications will use custom implementations of the Input and Output\n   streams\
    \ that encapsulate the communication routines.  For instance, a\n   simple read\
    \ on the application InputStream, when called by the\n   Context, might cause\
    \ a token to be read from the peer, and a simple\n   flush() on the application\
    \ OutputStream might cause a previously\n   written token to be transmitted to\
    \ the peer.\n   // Create a new GSSContext implementation object.\n   // GSSContext\
    \ wrapper implements interface GSSContext.\n   GSSContext context = mgr.createContext(...);\n\
    \   // use standard java.io stream objects\n   ByteArrayOutputStream os = new\
    \ ByteArrayOutputStream();\n   ByteArrayInputStream is = null;\n   try {\n   \
    \        do {\n                   context.initSecContext(is, os);\n          \
    \         // send token if present\n                   if (os.size() > 0)\n  \
    \                         sendToken(os);\n                   // check if we should\
    \ expect more tokens\n                   if (context.isEstablished())\n      \
    \                     break;\n                   // another token expected from\
    \ peer\n                   is = recvToken();\n           } while (true);\n   }\
    \ catch (GSSException e) {\n           print(\"GSSAPI error: \" + e.getMessage());\n\
    \   }\n"
- title: 6.4.5.  acceptSecContext
  contents:
  - "6.4.5.  acceptSecContext\n   public byte[] acceptSecContext(byte inTok[], int\
    \ offset, int len)\n                   throws GSSException\n   Called by the context\
    \ acceptor upon receiving a token from the peer.\n   This call is equivalent to\
    \ the stream based method except that the\n   token buffers are handled as byte\
    \ arrays instead of using stream\n   objects.\n   This method may return an output\
    \ token which the application will\n   need to send to the peer for further processing\
    \ by the init call.\n   \"null\" return value indicates that no token needs to\
    \ be sent to the\n   peer.  The application can call isEstablished() to determine\
    \ if the\n   context establishment phase is complete for this peer.  A return\n\
    \   value of \"false\" from isEstablished() indicates that more tokens are\n \
    \  expected to be supplied to this method.\n   Note that it is possible that acceptSecContext()\
    \ return a token for\n   the peer, and isEstablished() return \"true\" also. \
    \ This indicates\n   that the token needs to be sent to the peer, but the local\
    \ end of the\n   context is now fully established.\n   Upon completion of the\
    \ context establishment, the available context\n   options may be queried through\
    \ the get methods.\n   Parameters:\n      inTok     Token generated by the peer.\n\
    \      offset    The offset within the inTok where the token begins.\n      len\
    \       The length of the token within the inTok (starting at\n              \
    \  the offset).\n"
- title: 6.4.5.1.  Example Code
  contents:
  - "6.4.5.1.  Example Code\n   // acquire server credentials\n   GSSCredential server\
    \ = mgr.createCredential(...);\n   // create acceptor GSS-API context from the\
    \ default provider\n   GSSContext context = mgr.createContext(server, null);\n\
    \   try {\n           do {\n                   byte [] inTok = readToken();\n\
    \                   byte []outTok = context.acceptSecContext(inTok, 0,\n     \
    \                                      inTok.length);\n                   // possibly\
    \ send token to peer\n                   if (outTok != null)\n               \
    \            sendToken(outTok);\n                   // check if local context\
    \ establishment is complete\n                   if (context.isEstablished())\n\
    \                           break;\n           } while (true);\n   } catch (GSSException\
    \ e) {\n           print(\"GSS-API error: \" + e.getMessage());\n   }\n"
- title: 6.4.6.  acceptSecContext
  contents:
  - "6.4.6.  acceptSecContext\n   public void acceptSecContext(InputStream inStream,\n\
    \                   OutputStream outStream) throws GSSException\n   Called by\
    \ the context acceptor upon receiving a token from the peer.\n   This call is\
    \ equivalent to the byte array method.  It may write an\n   output token to the\
    \ outStream, which the application will need to\n   send to the peer for processing\
    \ by its initSecContext method.\n   Typically, the application would do so by\
    \ calling the flush() method\n   on an OutputStream that encapsulates the connection\
    \ between the two\n   peers. The application can call isEstablished() to determine\
    \ if the\n   context establishment phase is complete for this peer.  A return\n\
    \   value of \"false\" from isEstablished() indicates that more tokens are\n \
    \  expected to be supplied to this method.\n   Note that it is possible that acceptSecContext()\
    \ return a token for\n   the peer, and isEstablished() return \"true\" also. \
    \ This indicates\n   that the token needs to be sent to the peer, but the local\
    \ end of the\n   context is now fully established.\n   The GSS-API authentication\
    \ tokens contain a definitive start and end.\n   This method will attempt to read\
    \ one of these tokens per invocation,\n   and may block on the stream if only\
    \ part of the token is available.\n   Upon completion of the context establishment,\
    \ the available context\n   options may be queried through the get methods.\n\
    \   Parameters:\n      inStream  Contains the token generated by the peer.\n \
    \     outStream Output stream where the output token will be written.\n      \
    \          During the final stage of context establishment, there\n          \
    \      may be no bytes written.\n"
- title: 6.4.6.1.  Example Code
  contents:
  - "6.4.6.1.  Example Code\n   This sample code merely demonstrates the token exchange\
    \ during the\n   context establishment phase. It is expected that most Java\n\
    \   applications will use custom implementations of the Input and Output\n   streams\
    \ that encapsulate the communication routines.  For instance, a\n   simple read\
    \ on the application InputStream, when called by the\n   Context, might cause\
    \ a token to be read from the peer, and a simple\n   flush() on the application\
    \ OutputStream might cause a previously\n   written token to be transmitted to\
    \ the peer.\n   // acquire server credentials\n   GSSCredential server = mgr.createCredential(...);\n\
    \   // create acceptor GSS-API context from the default provider\n   GSSContext\
    \ context = mgr.createContext(server, null);\n   // use standard java.io stream\
    \ objects\n   ByteArrayOutputStream os = new ByteArrayOutputStream();\n   ByteArrayInputStream\
    \ is = null;\n   try {\n           do {\n                   is = recvToken();\n\
    \                   context.acceptSecContext(is, os);\n                   // possibly\
    \ send token to peer\n                   if (os.size() > 0)\n                \
    \           sendToken(os);\n                   // check if local context establishment\
    \ is complete\n                   if (context.isEstablished())\n             \
    \              break;\n           } while (true);\n   } catch (GSSException e)\
    \ {\n           print(\"GSS-API error: \" + e.getMessage());\n   }\n"
- title: 6.4.7.  isEstablished
  contents:
  - "6.4.7.  isEstablished\n   public boolean isEstablished()\n   Used during context\
    \ establishment to determine the state of the\n   context.  Returns \"true\" if\
    \ this is a fully established context on\n   the caller's side and no more tokens\
    \ are needed from the peer.\n   Should be called after a call to initSecContext()\
    \ or\n   acceptSecContext() when no GSSException is thrown.\n"
- title: 6.4.8.  dispose
  contents:
  - "6.4.8.  dispose\n   public void dispose() throws GSSException\n   Releases any\
    \ system resources and cryptographic information stored in\n   the context object.\
    \  This will invalidate the context.\n"
- title: 6.4.9.  getWrapSizeLimit
  contents:
  - "6.4.9.  getWrapSizeLimit\n   public int getWrapSizeLimit(int qop, boolean confReq,\n\
    \                   int maxTokenSize) throws GSSException\n   Returns the maximum\
    \ message size that, if presented to the wrap\n   method with the same confReq\
    \ and qop parameters, will result in an\n   output token containing no more than\
    \ the maxTokenSize bytes.\n   This call is intended for use by applications that\
    \ communicate over\n   protocols that impose a maximum message size.  It enables\
    \ the\n   application to fragment messages prior to applying protection.\n   GSS-API\
    \ implementations are recommended but not required to detect\n   invalid QOP values\
    \ when getWrapSizeLimit is called.  This routine\n   guarantees only a maximum\
    \ message size, not the availability of\n   specific QOP values for message protection.\n\
    \   Successful completion of this call does not guarantee that wrap will\n   be\
    \ able to protect a message of the computed length, since this\n   ability may\
    \ depend on the availability of system resources at the\n   time that wrap is\
    \ called.  However, if the implementation itself\n   imposes an upper limit on\
    \ the length of messages that may be\n   processed by wrap, the implementation\
    \ should not return a value that\n   is greater than this length.\n   Parameters:\n\
    \      qop       Indicates the level of protection wrap will be asked\n      \
    \          to provide.\n      confReq   Indicates if wrap will be asked to provide\
    \ privacy\n                service.\n      maxTokenSize\n                The desired\
    \ maximum size of the token emitted by wrap.\n"
- title: 6.4.10.  wrap
  contents:
  - "6.4.10.  wrap\n   public byte[] wrap(byte inBuf[], int offset, int len,\n   \
    \                MessageProp msgProp) throws GSSException\n   Applies per-message\
    \ security services over the established security\n   context.  The method will\
    \ return a token with a cryptographic MIC and\n   may optionally encrypt the specified\
    \ inBuf.  This method is\n   equivalent in functionality to its stream counterpart.\
    \  The returned\n   byte array will contain both the MIC and the message.\n  \
    \ The MessageProp object is instantiated by the application and used to\n   specify\
    \ a QOP value which selects cryptographic algorithms, and a\n   privacy service\
    \ to optionally encrypt the message.  The underlying\n   mechanism that is used\
    \ in the call may not be able to provide the\n   privacy service.  It sets the\
    \ actual privacy service that it does\n   provide in this MessageProp object which\
    \ the caller should then query\n   upon return.  If the mechanism is not able\
    \ to provide the requested\n   QOP, it throws a GSSException with the BAD_QOP\
    \ code.\n   Since some application-level protocols may wish to use tokens emitted\n\
    \   by wrap to provide \"secure framing\", implementations should support\n  \
    \ the wrapping of zero-length messages.\n   The application will be responsible\
    \ for sending the token to the\n   peer.\n   Parameters:\n      inBuf     Application\
    \ data to be protected.\n      offset    The offset within the inBuf where the\
    \ data begins.\n      len       The length of the data within the inBuf (starting\
    \ at\n                the offset).\n      msgProp   Instance of MessageProp that\
    \ is used by the\n                application to set the desired QOP and privacy\
    \ state.\n                Set the desired QOP to 0 to request the default QOP.\n\
    \                Upon return from this method, this object will contain\n    \
    \            the the actual privacy state that was applied to the\n          \
    \      message by the underlying mechanism.\n"
- title: 6.4.11.  wrap
  contents:
  - "6.4.11.  wrap\n   public void wrap(InputStream inStream, OutputStream outStream,\n\
    \                   MessageProp msgProp) throws GSSException\n   Allows to apply\
    \ per-message security services over the established\n   security context.  The\
    \ method will produce a token with a\n   cryptographic MIC and may optionally\
    \ encrypt the message in inStream.\n   The outStream will contain both the MIC\
    \ and the message.\n   The MessageProp object is instantiated by the application\
    \ and used to\n   specify a QOP value which selects cryptographic algorithms,\
    \ and a\n   privacy service to optionally encrypt the message.  The underlying\n\
    \   mechanism that is used in the call may not be able to provide the\n   privacy\
    \ service.  It sets the actual privacy service that it does\n   provide in this\
    \ MessageProp object which the caller should then query\n   upon return.  If the\
    \ mechanism is not able to provide the requested\n   QOP, it throws a GSSException\
    \ with the BAD_QOP code.\n   Since some application-level protocols may wish to\
    \ use tokens emitted\n   by wrap to provide \"secure framing\", implementations\
    \ should support\n   the wrapping of zero-length messages.\n   The application\
    \ will be responsible for sending the token to the\n   peer.\n   Parameters:\n\
    \      inStream  Input stream containing the application data to be\n        \
    \        protected.\n      outStream The output stream to write the protected\
    \ message to.\n                The application is responsible for sending this\
    \ to the\n                other peer for processing in its unwrap method.\n  \
    \    msgProp   Instance of MessageProp that is used by the\n                application\
    \ to set the desired QOP and privacy state.\n                Set the desired QOP\
    \ to 0 to request the default QOP.\n                Upon return from this method,\
    \ this object will contain\n                the the actual privacy state that\
    \ was applied to the\n                message by the underlying mechanism.\n"
- title: 6.4.12.  unwrap
  contents:
  - "6.4.12.  unwrap\n   public byte [] unwrap(byte[] inBuf, int offset, int len,\n\
    \                   MessageProp msgProp) throws GSSException\n   Used by the peer\
    \ application to process tokens generated with the\n   wrap call.  This call is\
    \ equal in functionality to its stream\n   counterpart.  The method will return\
    \ the message supplied in the peer\n   application to the wrap call, verifying\
    \ the embedded MIC.\n   The MessageProp object is instantiated by the application\
    \ and is used\n   by the underlying mechanism to return information to the caller\
    \ such\n   as the QOP, whether confidentiality was applied to the message, and\n\
    \   other supplementary message state information.\n   Since some application-level\
    \ protocols may wish to use tokens emitted\n   by wrap to provide \"secure framing\"\
    , implementations should support\n   the wrapping and unwrapping of zero-length\
    \ messages.\n   Parameters:\n      inBuf     GSS-API wrap token received from\
    \ peer.\n      offset    The offset within the inBuf where the token begins.\n\
    \      len       The length of the token within the inBuf (starting at\n     \
    \           the offset).\n      msgProp   Upon return from the method, this object\
    \ will contain\n                the applied QOP, the privacy state of the message,\
    \ and\n                supplementary information described in 4.12.3 stating\n\
    \                whether the token was a duplicate, old, out of\n            \
    \    sequence or arriving after a gap.\n"
- title: 6.4.13.  unwrap
  contents:
  - "6.4.13.  unwrap\n   public void unwrap(InputStream inStream, OutputStream outStream,\n\
    \                   MessageProp msgProp) throws GSSException\n   Used by the peer\
    \ application to process tokens generated with the\n   wrap call.  This call is\
    \ equal in functionality to its byte array\n   counterpart.  It will produce the\
    \ message supplied in the peer\n   application to the wrap call, verifying the\
    \ embedded MIC.\n   The MessageProp object is instantiated by the application\
    \ and is used\n   by the underlying mechanism to return information to the caller\
    \ such\n   as the QOP, whether confidentiality was applied to the message, and\n\
    \   other supplementary message state information.\n   Since some application-level\
    \ protocols may wish to use tokens emitted\n   by wrap to provide \"secure framing\"\
    , implementations should support\n   the wrapping and unwrapping of zero-length\
    \ messages.\n   Parameters:\n      inStream  Input stream containing the GSS-API\
    \ wrap token\n                received from the peer.\n      outStream The output\
    \ stream to write the application message to.\n      msgProp   Upon return from\
    \ the method, this object will contain\n                the applied QOP, the privacy\
    \ state of the message, and\n                supplementary information described\
    \ in 4.12.3 stating\n                whether the token was a duplicate, old, out\
    \ of\n                sequence or arriving after a gap.\n"
- title: 6.4.14.  getMIC
  contents:
  - "6.4.14.  getMIC\n   public byte[] getMIC(byte []inMsg, int offset, int len,\n\
    \                   MessageProp msgProp) throws GSSException\n   Returns a token\
    \ containing a cryptographic MIC for the supplied\n   message,  for transfer to\
    \ the peer application.  Unlike wrap, which\n   encapsulates the user message\
    \ in the returned token, only the message\n   MIC is returned in the output token.\
    \  This method is identical in\n   functionality to its stream counterpart.\n\
    \   Note that privacy can only be applied through the wrap call.\n   Since some\
    \ application-level protocols may wish to use tokens emitted\n   by getMIC to\
    \ provide \"secure framing\", implementations should support\n   derivation of\
    \ MICs from zero-length messages.\n   Parameters:\n      inMsg     Message to\
    \ generate MIC over.\n      offset    The offset within the inMsg where the token\
    \ begins.\n      len       The length of the token within the inMsg (starting\
    \ at\n                the offset).\n      msgProp   Instance of MessageProp that\
    \ is used by the\n                application to set the desired QOP.  Set the\
    \ desired\n                QOP to 0 in msgProp to request the default QOP.\n \
    \               Alternatively pass in \"null\" for msgProp to request\n      \
    \          default QOP.\n"
- title: 6.4.15.  getMIC
  contents:
  - "6.4.15.  getMIC\n   public void getMIC(InputStream inStream, OutputStream outStream,\n\
    \                   MessageProp msgProp) throws GSSException\n   Produces a token\
    \ containing a cryptographic MIC for the supplied\n   message, for transfer to\
    \ the peer application.  Unlike wrap, which\n   encapsulates the user message\
    \ in the returned token, only the message\n   MIC is produced in the output token.\
    \  This method is identical in\n   functionality to its byte array counterpart.\n\
    \   Note that privacy can only be applied through the wrap call.\n   Since some\
    \ application-level protocols may wish to use tokens emitted\n   by getMIC to\
    \ provide \"secure framing\", implementations should support\n   derivation of\
    \ MICs from zero-length messages.\n   Parameters:\n      inStream  inStream  Input\
    \ stream containing the message to\n                generate MIC over.\n     \
    \ outStream outStream Output stream to write the GSS-API output\n            \
    \    token to.\n      msgProp   Instance of MessageProp that is used by the\n\
    \                application to set the desired QOP.  Set the desired\n      \
    \          QOP to 0 in msgProp to request the default QOP.\n                Alternatively\
    \ pass in \"null\" for msgProp to request\n                default QOP.\n"
- title: 6.4.16.  verifyMIC
  contents:
  - "6.4.16.  verifyMIC\n   public void verifyMIC(byte []inTok, int tokOffset, int\
    \ tokLen,\n                   byte[] inMsg, int msgOffset, int msgLen,\n     \
    \              MessageProp msgProp) throws GSSException\n   Verifies the cryptographic\
    \ MIC, contained in the token parameter,\n   over the supplied message.  This\
    \ method is equivalent in\n   functionality to its stream counterpart.\n   The\
    \ MessageProp object is instantiated by the application and is used\n   by the\
    \ underlying mechanism to return information to the caller such\n   as the QOP\
    \ indicating the strength of protection that was applied to\n   the message and\
    \ other supplementary message state information.\n   Since some application-level\
    \ protocols may wish to use tokens emitted\n   by getMIC to provide \"secure framing\"\
    , implementations should support\n   the calculation and verification of MICs\
    \ over zero-length messages.\n   Parameters:\n      inTok     Token generated\
    \ by peer's getMIC method.\n      tokOffset The offset within the inTok where\
    \ the token begins.\n      tokLen    The length of the token within the inTok\
    \ (starting at\n                the offset).\n      inMsg     Application message\
    \ to verify the cryptographic MIC\n                over.\n      msgOffset The\
    \ offset within the inMsg where the message begins.\n      msgLen    The length\
    \ of the message within the inMsg (starting\n                at the offset).\n\
    \      msgProp   Upon return from the method, this object will contain\n     \
    \           the applied QOP and supplementary information\n                described\
    \ in 4.12.3 stating whether the token was a\n                duplicate, old, out\
    \ of sequence or arriving after a\n                gap.  The confidentiality state\
    \ will be set to\n                \"false\".\n"
- title: 6.4.17.  verifyMIC
  contents:
  - "6.4.17.  verifyMIC\n   public void verifyMIC(InputStream tokStream, InputStream\
    \ msgStream,\n                   MessageProp msgProp) throws GSSException\n  \
    \ Verifies the cryptographic MIC, contained in the token parameter,\n   over the\
    \ supplied message.  This method is equivalent in\n   functionality to its byte\
    \ array counterpart.\n   The MessageProp object is instantiated by the application\
    \ and is used\n   by the underlying mechanism to return information to the caller\
    \ such\n   as the QOP indicating the strength of protection that was applied to\n\
    \   the message and other supplementary message state information.\n   Since some\
    \ application-level protocols may wish to use tokens emitted\n   by getMIC to\
    \ provide \"secure framing\", implementations should support\n   the calculation\
    \ and verification of MICs over zero-length messages.\n   Parameters:\n      tokStream\
    \ Input stream containing the token generated by peer's\n                getMIC\
    \ method.\n      msgStream Input stream containing the application message to\n\
    \                verify the cryptographic MIC over.\n      msgProp   Upon return\
    \ from the method, this object will contain\n                the applied QOP and\
    \ supplementary information\n                described in 4.12.3 stating whether\
    \ the token was a\n                duplicate, old, out of sequence or arriving\
    \ after a\n                gap.  The confidentiality state will be set to\n  \
    \              \"false\".\n"
- title: 6.4.18.  export
  contents:
  - "6.4.18.  export\n   public byte [] export() throws GSSException\n   Provided\
    \ to support the sharing of work between multiple processes.\n   This routine\
    \ will typically be used by the context-acceptor, in an\n   application where\
    \ a single process receives incoming connection\n   requests and accepts security\
    \ contexts over them, then passes the\n   established context to one or more other\
    \ processes for message\n   exchange.\n   This method deactivates the security\
    \ context and creates an\n   interprocess token which, when passed to the byte\
    \ array constructor\n   of the GSSContext interface in another process, will re-activate\
    \ the\n   context in the second process.  Only a single instantiation of a\n \
    \  given context may be active at any one time; a subsequent attempt by\n   a\
    \ context exporter to access the exported security context will fail.\n   The\
    \ implementation may constrain the set of processes by which the\n   interprocess\
    \ token may be imported, either as a function of local\n   security policy, or\
    \ as a result of implementation decisions.  For\n   example, some implementations\
    \ may constrain contexts to be passed\n   only between processes that run under\
    \ the same account, or which are\n   part of the same process group.\n   The interprocess\
    \ token may contain security-sensitive information\n   (for example cryptographic\
    \ keys).  While mechanisms are encouraged to\n   either avoid placing such sensitive\
    \ information within interprocess\n   tokens, or to encrypt the token before returning\
    \ it to the\n   application, in a typical GSS-API implementation this may not\
    \ be\n   possible.  Thus the application must take care to protect the\n   interprocess\
    \ token, and ensure that any process to which the token is\n   transferred is\
    \ trustworthy.\n"
- title: 6.4.19.  requestMutualAuth
  contents:
  - "6.4.19.  requestMutualAuth\n   public void requestMutualAuth(boolean state) throws\
    \ GSSException\n   Sets the request state of the mutual authentication flag for\
    \ the\n   context.  This method is only valid before the context creation\n  \
    \ process begins and only for the initiator.\n   Parameters:\n      state    \
    \ Boolean representing if mutual authentication should\n                be requested\
    \ during context establishment.\n"
- title: 6.4.20.  requestReplayDet
  contents:
  - "6.4.20.  requestReplayDet\n   public void requestReplayDet(boolean state) throws\
    \ GSSException\n   Sets the request state of the replay detection service for\
    \ the\n   context.  This method is only valid before the context creation\n  \
    \ process begins and only for the initiator.\n   Parameters:\n      state    \
    \ Boolean representing if replay detection is desired\n                over the\
    \ established context.\n"
- title: 6.4.21.  requestSequenceDet
  contents:
  - "6.4.21.  requestSequenceDet\n   public void requestSequenceDet(boolean state)\
    \ throws GSSException\n   Sets the request state for the sequence checking service\
    \ of the\n   context.  This method is only valid before the context creation\n\
    \   process begins and only for the initiator.\n   Parameters:\n      state  \
    \   Boolean representing if sequence detection is desired\n                over\
    \ the established context.\n"
- title: 6.4.22.  requestCredDeleg
  contents:
  - "6.4.22.  requestCredDeleg\n   public void requestCredDeleg(boolean state) throws\
    \ GSSException\n   Sets the request state for the credential delegation flag for\
    \ the\n   context.  This method is only valid before the context creation\n  \
    \ process begins and only for the initiator.\n   Parameters:\n      state    \
    \ Boolean representing if credential delegation is\n                desired.\n"
- title: 6.4.23.  requestAnonymity
  contents:
  - "6.4.23.  requestAnonymity\n   public void requestAnonymity(boolean state) throws\
    \ GSSException\n   Requests anonymous support over the context.  This method is\
    \ only\n   valid before the context creation process begins and only for the\n\
    \   initiator.\n   Parameters:\n      state     Boolean representing if anonymity\
    \ support is\n                requested.\n"
- title: 6.4.24.  requestConf
  contents:
  - "6.4.24.  requestConf\n   public void requestConf(boolean state) throws GSSException\n\
    \   Requests that confidentiality service be available over the context.\n   This\
    \ method is only valid before the context creation process begins\n   and only\
    \ for the initiator.\n   Parameters:\n      state     Boolean indicating if confidentiality\
    \ services are to\n                be requested for the context.\n"
- title: 6.4.25.  requestInteg
  contents:
  - "6.4.25.  requestInteg\n   public void requestInteg(boolean state) throws GSSException\n\
    \   Requests that integrity services be available over the context.  This\n  \
    \ method is only valid before the context creation process begins and\n   only\
    \ for the initiator.\n   Parameters:\n      state     Boolean indicating if integrity\
    \ services are to be\n                requested for the context.\n"
- title: 6.4.26.  requestLifetime
  contents:
  - "6.4.26.  requestLifetime\n   public void requestLifetime(int lifetime) throws\
    \ GSSException\n   Sets the desired lifetime for the context in seconds.  This\
    \ method is\n   only valid before the context creation process begins and only\
    \ for\n   the initiator. Use GSSContext.INDEFINITE_LIFETIME and\n   GSSContext.DEFAULT_LIFETIME\
    \ to request indefinite or default context\n   lifetime.\n   Parameters:\n   \
    \   lifetime  The desired context lifetime in seconds.\n"
- title: 6.4.27.  setChannelBinding
  contents:
  - "6.4.27.  setChannelBinding\n   public void setChannelBinding(ChannelBinding cb)\
    \ throws GSSException\n   Sets the channel bindings to be used during context\
    \ establishment.\n   This method is only valid before the context creation process\
    \ begins.\n   Parameters:\n      cb        Channel bindings to be used.\n"
- title: 6.4.28.  getCredDelegState
  contents:
  - "6.4.28.  getCredDelegState\n   public boolean getCredDelegState()\n   Returns\
    \ the state of the delegated credentials for the context.  When\n   issued before\
    \ context establishment is completed or when the\n   isProtReady method returns\
    \ \"false\", it returns the desired state,\n   otherwise it will indicate the\
    \ actual state over the established\n   context.\n"
- title: 6.4.29.  getMutualAuthState
  contents:
  - "6.4.29.  getMutualAuthState\n   public boolean getMutualAuthState()\n   Returns\
    \ the state of the mutual authentication option for the\n   context.  When issued\
    \ before context establishment completes or when\n   the isProtReady method returns\
    \ \"false\", it returns the desired state,\n   otherwise it will indicate the\
    \ actual state over the established\n   context.\n"
- title: 6.4.30.  getReplayDetState
  contents:
  - "6.4.30.  getReplayDetState\n   public boolean getReplayDetState()\n   Returns\
    \ the state of the replay detection option for the context.\n   When issued before\
    \ context establishment completes or when the\n   isProtReady method returns \"\
    false\", it returns the desired state,\n   otherwise it will indicate the actual\
    \ state over the established\n   context.\n"
- title: 6.4.31.  getSequenceDetState
  contents:
  - "6.4.31.  getSequenceDetState\n   public boolean getSequenceDetState()\n   Returns\
    \ the state of the sequence detection option for the context.\n   When issued\
    \ before context establishment completes or when the\n   isProtReady method returns\
    \ \"false\", it returns the desired state,\n   otherwise it will indicate the\
    \ actual state over the established\n   context.\n"
- title: 6.4.32.  getAnonymityState
  contents:
  - "6.4.32.  getAnonymityState\n   public boolean getAnonymityState()\n   Returns\
    \ \"true\" if this is an anonymous context.  When issued before\n   context establishment\
    \ completes or when the isProtReady method\n   returns \"false\", it returns the\
    \ desired state, otherwise it will\n   indicate the actual state over the established\
    \ context.\n"
- title: 6.4.33.  isTransferable
  contents:
  - "6.4.33.  isTransferable\n   public boolean isTransferable() throws GSSException\n\
    \   Returns \"true\" if the context is transferable to other processes\n   through\
    \ the use of the export method.  This call is only valid on\n   fully established\
    \ contexts.\n"
- title: 6.4.34.  isProtReady
  contents:
  - "6.4.34.  isProtReady\n   public boolean isProtReady()\n   Returns \"true\" if\
    \ the per message operations can be applied over the\n   context.  Some mechanisms\
    \ may allow the usage of per-message\n   operations before the context is fully\
    \ established.  This will also\n   indicate that the get methods will return actual\
    \ context state\n   characteristics instead of the desired ones.\n"
- title: 6.4.35.  getConfState
  contents:
  - "6.4.35.  getConfState\n   public boolean getConfState()\n   Returns the confidentiality\
    \ service state over the context.  When\n   issued before context establishment\
    \ completes or when the isProtReady\n   method returns \"false\", it returns the\
    \ desired state, otherwise it\n   will indicate the actual state over the established\
    \ context.\n"
- title: 6.4.36.  getIntegState
  contents:
  - "6.4.36.  getIntegState\n   public boolean getIntegState()\n   Returns the integrity\
    \ service state over the context.  When issued\n   before context establishment\
    \ completes or when the isProtReady method\n   returns \"false\", it returns the\
    \ desired state, otherwise it will\n   indicate the actual state over the established\
    \ context.\n"
- title: 6.4.37.  getLifetime
  contents:
  - "6.4.37.  getLifetime\n   public int getLifetime()\n   Returns the context lifetime\
    \ in seconds.  When issued before context\n   establishment completes or when\
    \ the isProtReady method returns\n   \"false\", it returns the desired lifetime,\
    \ otherwise it will indicate\n   the remaining lifetime for the context.\n"
- title: 6.4.38.  getSrcName
  contents:
  - "6.4.38.  getSrcName\n   public GSSName getSrcName() throws GSSException\n   Returns\
    \ the name of the context initiator.  This call is valid only\n   after the context\
    \ is fully established or the isProtReady method\n   returns \"true\".  It is\
    \ guaranteed to return an MN.\n"
- title: 6.4.39.  getTargName
  contents:
  - "6.4.39.  getTargName\n   public GSSName getTargName() throws GSSException\n \
    \  Returns the name of the context target (acceptor).  This call is\n   valid\
    \ only after the context is fully established or the isProtReady\n   method returns\
    \ \"true\".  It is guaranteed to return an MN.\n"
- title: 6.4.40.  getMech
  contents:
  - "6.4.40.  getMech\n   public Oid getMech() throws GSSException\n   Returns the\
    \ mechanism oid for this context. This method may be called\n   before the context\
    \ is fully established, but the mechanism returned\n   may change on successive\
    \ calls in negotiated mechanism case.\n"
- title: 6.4.41.  getDelegCred
  contents:
  - "6.4.41.  getDelegCred\n   public GSSCredential getDelegCred() throws GSSException\n\
    \   Returns the delegated credential object on the acceptor's side.  To\n   check\
    \ for availability of delegated credentials call\n   getDelegCredState.  This\
    \ call is only valid on fully established\n   contexts.\n"
- title: 6.4.42.  isInitiator
  contents:
  - "6.4.42.  isInitiator\n   public boolean isInitiator() throws GSSException\n \
    \  Returns \"true\" if this is the initiator of the context.  This call is\n \
    \  only valid after the context creation process has started.\n"
- title: 6.5.  public class MessageProp
  contents:
  - "6.5.  public class MessageProp\n   This is a utility class used within the per-message\
    \ GSSContext\n   methods to convey per-message properties.\n   When used with\
    \ the GSSContext interface's wrap and getMIC methods, an\n   instance of this\
    \ class is used to indicate the desired QOP and to\n   request if confidentiality\
    \ services are to be applied to caller\n   supplied data (wrap only).  To request\
    \ default QOP, the value of 0\n   should be used for QOP.\n   When used with the\
    \ unwrap and verifyMIC methods of the GSSContext\n   interface, an instance of\
    \ this class will be used to indicate the\n   applied QOP and confidentiality\
    \ services over the supplied message.\n   In the case of verifyMIC, the confidentiality\
    \ state will always be\n   \"false\".  Upon return from these methods, this object\
    \ will also\n   contain any supplementary status values applicable to the processed\n\
    \   token.  The supplementary status values can indicate old tokens, out\n   of\
    \ sequence tokens, gap tokens or duplicate tokens.\n"
- title: 6.5.1.  Constructors
  contents:
  - "6.5.1.  Constructors\n   public MessageProp(boolean privState)\n   Constructor\
    \ which sets QOP to 0 indicating that the default QOP is\n   requested.\n   Parameters:\n\
    \      privState The desired privacy state. \"true\" for privacy and\n       \
    \         \"false\" for integrity only.\n   public MessageProp(int qop, boolean\
    \ privState)\n   Constructor which sets the values for the qop and privacy state.\n\
    \   Parameters:\n      qop       The desired QOP.  Use 0 to request a default\
    \ QOP.\n      privState The desired privacy state. \"true\" for privacy and\n\
    \                \"false\" for integrity only.\n"
- title: 6.5.2.  getQOP
  contents:
  - "6.5.2.  getQOP\n   public int getQOP()\n   Retrieves the QOP value.\n"
- title: 6.5.3.  getPrivacy
  contents:
  - "6.5.3.  getPrivacy\n   public boolean getPrivacy()\n   Retrieves the privacy\
    \ state.\n"
- title: 6.5.4.  getMinorStatus
  contents:
  - "6.5.4.  getMinorStatus\n   public int getMinorStatus()\n   Retrieves the minor\
    \ status that the underlying mechanism might have\n   set.\n"
- title: 6.5.5.  getMinorString
  contents:
  - "6.5.5.  getMinorString\n   public String getMinorString()\n   Returns a string\
    \ explaining the mechanism specific error code. null\n   will be returned when\
    \ no mechanism error code has been set.\n"
- title: 6.5.6.  setQOP
  contents:
  - "6.5.6.  setQOP\n   public void setQOP(int qopVal)\n   Sets the QOP value.\n \
    \  Parameters:\n      qopVal    The QOP value to be set.  Use 0 to request a default\n\
    \                QOP value.\n"
- title: 6.5.7.  setPrivacy
  contents:
  - "6.5.7.  setPrivacy\n   public void setPrivacy(boolean privState)\n   Sets the\
    \ privacy state.\n   Parameters:\n      privState The privacy state to set.\n"
- title: 6.5.8.  isDuplicateToken
  contents:
  - "6.5.8.  isDuplicateToken\n   public boolean isDuplicateToken()\n   Returns \"\
    true\" if this is a duplicate of an earlier token.\n"
- title: 6.5.9.  isOldToken
  contents:
  - "6.5.9.  isOldToken\n   public boolean isOldToken()\n   Returns \"true\" if the\
    \ token's validity period has expired.\n"
- title: 6.5.10.  isUnseqToken
  contents:
  - "6.5.10.  isUnseqToken\n   public boolean isUnseqToken()\n   Returns \"true\"\
    \ if a later token has already been processed.\n"
- title: 6.5.11.  isGapToken
  contents:
  - "6.5.11.  isGapToken\n   public boolean isGapToken()\n   Returns \"true\" if an\
    \ expected per-message token was not received.\n"
- title: 6.5.12.  setSupplementaryStates
  contents:
  - "6.5.12.  setSupplementaryStates\n   public void setSupplementaryStates(boolean\
    \ duplicate,\n                   boolean old, boolean unseq, boolean gap,\n  \
    \                 int minorStatus, String minorString)\n   This method sets the\
    \ state for the supplementary information flags\n   and the minor status in MessageProp.\
    \  It is not used by the\n   application but by the GSS implementation to return\
    \ this information\n   to the caller of a per-message context method.\n   Parameters:\n\
    \      duplicate true if the token was a duplicate of an earlier token,\n    \
    \            false otherwise\n      old       true if the token's validity period\
    \ has expired, false\n                otherwise\n      unseq     true if a later\
    \ token has already been processed,\n                false otherwise\n      gap\
    \       true if one or more predecessor tokens have not yet\n                been\
    \ successfully processed, false otherwise\n      minorStatus   the integer minor\
    \ status code that the underlying\n                    mechanism wants to set\n\
    \      minorString   the textual representation of the minorStatus\n         \
    \           value\n"
- title: 6.6.  public class ChannelBinding
  contents:
  - "6.6.  public class ChannelBinding\n   The GSS-API accommodates the concept of\
    \ caller-provided channel\n   binding information.  Channel bindings are used\
    \ to strengthen the\n   quality with which peer entity authentication is provided\
    \ during\n   context establishment.  They enable the GSS-API callers to bind the\n\
    \   establishment of the security context to relevant characteristics\n   like\
    \ addresses or to application specific data.\n   The caller initiating the security\
    \ context must determine the\n   appropriate channel binding values to set in\
    \ the GSSContext object.\n   The acceptor must provide an identical binding in\
    \ order to validate\n   that received tokens possess correct channel-related characteristics.\n\
    \   Use of channel bindings is optional in GSS-API.  Since channel-\n   binding\
    \ information may be transmitted in context establishment\n   tokens, applications\
    \ should therefore not use confidential data as\n   channel-binding components.\n"
- title: 6.6.1.  Constructors
  contents:
  - "6.6.1.  Constructors\n   public ChannelBinding(InetAddress initAddr, InetAddress\
    \ acceptAddr,\n                   byte[] appData)\n   Create a ChannelBinding\
    \ object with user supplied address information\n   and data.  \"null\" values\
    \ can be used for any fields which the\n   application does not want to specify.\n\
    \   Parameters:\n      initAddr  The address of the context initiator.  \"null\"\
    \ value\n                can be supplied to indicate that the application does\n\
    \                not want to set this value.\n      acceptAddrThe address of the\
    \ context acceptor.  \"null\" value can\n                be supplied to indicate\
    \ that the application does not\n                want to set this value.\n   \
    \   appData   Application supplied data to be used as part of the\n          \
    \      channel bindings.  \"null\" value can be supplied to\n                indicate\
    \ that the application does not want to set\n                this value.\n   public\
    \ ChannelBinding(byte[] appData)\n   Creates a ChannelBinding object without any\
    \ addressing information.\n   Parameters:\n      appData   Application supplied\
    \ data to be used as part of the\n                channel bindings.\n"
- title: 6.6.2.  getInitiatorAddress
  contents:
  - "6.6.2.  getInitiatorAddress\n   public InetAddress getInitiatorAddress()\n  \
    \ Returns the initiator's address for this channel binding. \"null\" is\n   returned\
    \ if the address has not been set.\n"
- title: 6.6.3.  getAcceptorAddress
  contents:
  - "6.6.3.  getAcceptorAddress\n   public InetAddress getAcceptorAddress()\n   Returns\
    \ the acceptor's address for this channel binding. \"null\" is\n   returned if\
    \ the address has not been set.\n"
- title: 6.6.4.  getApplicationData
  contents:
  - "6.6.4.  getApplicationData\n   public byte[] getApplicationData()\n   Returns\
    \ application data being used as part of the ChannelBinding.\n   \"null\" is returned\
    \ if no application data has been specified for the\n   channel binding.\n"
- title: 6.6.5.  equals
  contents:
  - "6.6.5.  equals\n   public boolean equals(Object obj)\n   Returns \"true\" if\
    \ two channel bindings match. (Note that the Java\n   language specification requires\
    \ that two objects that are equal\n   according to the equals(Object) method must\
    \ return the same integer\n   result when the hashCode() method is called on them.)\n\
    \   Parameters:\n      obj       Another channel binding to compare with.\n"
- title: 6.7.  public class Oid
  contents:
  - "6.7.  public class Oid\n   This class represents Universal Object Identifiers\
    \ (Oids) and their\n   associated operations.\n   Oids are hierarchically globally-interpretable\
    \ identifiers used\n   within the GSS-API framework to identify mechanisms and\
    \ name formats.\n   The structure and encoding of Oids is defined in ISOIEC-8824\
    \ and\n   ISOIEC-8825.  For example the Oid representation of Kerberos V5\n  \
    \ mechanism is \"1.2.840.113554.1.2.2\"\n   The GSSName name class contains public\
    \ static Oid objects\n   representing the standard name types defined in GSS-API.\n"
- title: 6.7.1.  Constructors
  contents:
  - "6.7.1.  Constructors\n   public Oid(String strOid) throws GSSException\n   Creates\
    \ an Oid object from a string representation of its integer\n   components (e.g.\
    \ \"1.2.840.113554.1.2.2\").\n   Parameters:\n      strOid    The string representation\
    \ for the oid.\n   public Oid(InputStream derOid) throws GSSException\n   Creates\
    \ an Oid object from its DER encoding.  This refers to the full\n   encoding including\
    \ tag and length.  The structure and encoding of\n   Oids is defined in ISOIEC-8824\
    \ and ISOIEC-8825.  This method is\n   identical in functionality to its byte\
    \ array counterpart.\n   Parameters:\n      derOid    Stream containing the DER\
    \ encoded oid.\n   public Oid(byte[] DEROid) throws GSSException\n   Creates an\
    \ Oid object from its DER encoding.  This refers to the full\n   encoding including\
    \ tag and length.  The structure and encoding of\n   Oids is defined in ISOIEC-8824\
    \ and ISOIEC-8825.  This method is\n   identical in functionality to its byte\
    \ array counterpart.\n   Parameters:\n      derOid    Byte array storing a DER\
    \ encoded oid.\n"
- title: 6.7.2.  toString
  contents:
  - "6.7.2.  toString\n   public String toString()\n   Returns a string representation\
    \ of the oid's integer components in\n   dot separated notation (e.g. \"1.2.840.113554.1.2.2\"\
    ).\n"
- title: 6.7.3.  equals
  contents:
  - "6.7.3.  equals\n   public boolean equals(Object Obj)\n   Returns \"true\" if\
    \ the two Oid objects represent the same oid value.\n   (Note that the Java language\
    \ specification requires that two objects\n   that are equal according to the\
    \ equals(Object) method must return the\n   same integer result when the hashCode()\
    \ method is called on them.)\n   Parameters:\n      obj       Another Oid object\
    \ to compare with.\n"
- title: 6.7.4.  getDER
  contents:
  - "6.7.4.  getDER\n   public byte[] getDER()\n   Returns the full ASN.1 DER encoding\
    \ for this oid object, which\n   includes the tag and length.\n"
- title: 6.7.5.  containedIn
  contents:
  - "6.7.5.  containedIn\n   public boolean containedIn(Oid[] oids)\n   A utility\
    \ method to test if an Oid object is contained within the\n   supplied Oid object\
    \ array.\n   Parameters:\n      oids      An array of oids to search.\n"
- title: 6.8.  public class GSSException extends Exception
  contents:
  - "6.8.  public class GSSException extends Exception\n   This exception is thrown\
    \ whenever a fatal GSS-API error occurs\n   including mechanism specific errors.\
    \  It may contain both, the major\n   and minor, GSS-API status codes.  The mechanism\
    \ implementers are\n   responsible for setting appropriate minor status codes\
    \ when throwing\n   this exception.  Aside from delivering the numeric error code(s)\
    \ to\n   the caller, this class performs the mapping from their numeric values\n\
    \   to textual representations.  All Java GSS-API methods are declared\n   throwing\
    \ this exception.\n   All implementations are encouraged to use the Java\n   internationalization\
    \ techniques to provide local translations of the\n   message strings.\n"
- title: 6.8.1.  Static Constants
  contents:
  - "6.8.1.  Static Constants\n   All valid major GSS-API error code values are declared\
    \ as constants\n   in this class.\n   public static final int BAD_BINDINGS\n \
    \  Channel bindings mismatch error.\n   public static final int BAD_MECH\n   Unsupported\
    \ mechanism requested error.\n   public static final int BAD_NAME\n   Invalid\
    \ name provided error.\n   public static final int BAD_NAMETYPE\n   Name of unsupported\
    \ type provided error.\n   public static final int BAD_STATUS\n   Invalid status\
    \ code error - this is the default status value.\n   public static final int BAD_MIC\n\
    \   Token had invalid integrity check error.\n   public static final int CONTEXT_EXPIRED\n\
    \   Specified security context expired error.\n   public static final int CREDENTIALS_EXPIRED\n\
    \   Expired credentials detected error.\n   public static final int DEFECTIVE_CREDENTIAL\n\
    \   Defective credential error.\n   public static final int DEFECTIVE_TOKEN\n\
    \   Defective token error.\n   public static final int FAILURE\n   General failure,\
    \ unspecified at GSS-API level.\n   public static final int NO_CONTEXT\n   Invalid\
    \ security context error.\n   public static final int NO_CRED\n   Invalid credentials\
    \ error.\n   public static final int BAD_QOP\n   Unsupported QOP value error.\n\
    \   public static final int UNAUTHORIZED\n   Operation unauthorized error.\n \
    \  public static final int UNAVAILABLE\n   Operation unavailable error.\n   public\
    \ static final int DUPLICATE_ELEMENT\n   Duplicate credential element requested\
    \ error.\n   public static final int NAME_NOT_MN\n   Name contains multi-mechanism\
    \ elements error.\n   public static final int DUPLICATE_TOKEN\n   The token was\
    \ a duplicate of an earlier token.  This is a fatal error\n   code that may occur\
    \ during context establishment.  It is not used to\n   indicate supplementary\
    \ status values.  The MessageProp object is used\n   for that purpose.\n   public\
    \ static final int OLD_TOKEN\n   The token's validity period has expired.  This\
    \ is a fatal error code\n   that may occur during context establishment.  It is\
    \ not used to\n   indicate supplementary status values.  The MessageProp object\
    \ is used\n   for that purpose.\n   public static final int UNSEQ_TOKEN\n   A\
    \ later token has already been processed.  This is a fatal error code\n   that\
    \ may occur during context establishment.  It is not used to\n   indicate supplementary\
    \ status values.  The MessageProp object is used\n   for that purpose.\n   public\
    \ static final int GAP_TOKEN\n   An expected per-message token was not received.\
    \  This is a fatal\n   error code that may occur during context establishment.\
    \  It is not\n   used to indicate supplementary status values.  The MessageProp\
    \ object\n   is used for that purpose.\n"
- title: 6.8.2.  Constructors
  contents:
  - "6.8.2.  Constructors\n   public GSSException(int majorCode)\n   Creates a GSSException\
    \ object with a specified major code.\n   Parameters:\n      majorCode The GSS\
    \ error code causing this exception to be\n                thrown.\n   public\
    \ GSSException(int majorCode, int minorCode, String minorString)\n   Creates a\
    \ GSSException object with the specified major code, minor\n   code, and minor\
    \ code textual explanation.  This constructor is to be\n   used when the exception\
    \ is originating from the security mechanism.\n   It allows to specify the GSS\
    \ code and the mechanism code.\n   Parameters:\n      majorCode      The GSS error\
    \ code causing this exception to be\n                     thrown.\n      minorCode\
    \      The mechanism error code causing this exception\n                     to\
    \ be thrown.\n      minorString    The textual explanation of the mechanism error\n\
    \                     code.\n"
- title: 6.8.3.  getMajor
  contents:
  - "6.8.3.  getMajor\n   public int getMajor()\n   Returns the major code representing\
    \ the GSS error code that caused\n   this exception to be thrown.\n"
- title: 6.8.4.  getMinor
  contents:
  - "6.8.4.  getMinor\n   public int getMinor()\n   Returns the mechanism error code\
    \ that caused this exception.  The\n   minor code is set by the underlying mechanism.\
    \  Value of 0 indicates\n   that mechanism error code is not set.\n"
- title: 6.8.5.  getMajorString
  contents:
  - "6.8.5.  getMajorString\n   public String getMajorString()\n   Returns a string\
    \ explaining the GSS major error code causing this\n   exception to be thrown.\n"
- title: 6.8.6.  getMinorString
  contents:
  - "6.8.6.  getMinorString\n   public String getMinorString()\n   Returns a string\
    \ explaining the mechanism specific error code.  null\n   will be returned when\
    \ no mechanism error code has been set.\n"
- title: 6.8.7.  setMinor
  contents:
  - "6.8.7.  setMinor\n   public void setMinor(int minorCode, String message)\n  \
    \ Used internally by the GSS-API implementation and the underlying\n   mechanisms\
    \ to set the minor code and its textual representation.\n   Parameters:\n    \
    \  minorCode The mechanism specific error code.\n      message   A textual explanation\
    \ of the mechanism error code.\n"
- title: 6.8.8.  toString
  contents:
  - "6.8.8.  toString\n   public String toString()\n   Returns a textual representation\
    \ of both the major and minor status\n   codes.\n"
- title: 6.8.9.  getMessage
  contents:
  - "6.8.9.  getMessage\n   public String getMessage()\n   Returns a detailed message\
    \ of this exception.  Overrides\n   Throwable.getMessage.  It is customary in\
    \ Java to use this method to\n   obtain exception information.\n"
- title: 7.  Sample Applications
  contents:
  - '7.  Sample Applications

    '
- title: 7.1.  Simple GSS Context Initiator
  contents:
  - "7.1.  Simple GSS Context Initiator\n   import org.ietf.jgss.*;\n   /**\n    *\
    \ This is a partial sketch for a simple client program that acts\n    * as a GSS\
    \ context initiator.  It illustrates how to use the Java\n    * bindings for the\
    \ GSS-API specified in\n    * Generic Security Service API Version 2 : Java bindings\n\
    \    *\n    *\n    * This code sketch assumes the existence of a GSS-API\n   \
    \ * implementation that supports the mechanism that it will need and\n    * is\
    \ present as a library package (org.ietf.jgss) either as part of\n    * the standard\
    \ JRE or in the CLASSPATH the application specifies.\n    */\n   public class\
    \ SimpleClient {\n       private String serviceName; // name of peer (ie. server)\n\
    \       private GSSCredential clientCred = null;\n       private GSSContext context\
    \ = null;\n       private Oid mech; // underlying mechanism to use\n       private\
    \ GSSManager mgr = GSSManager.getInstance();\n       ...\n       ...\n       private\
    \ void clientActions() {\n           initializeGSS();\n           establishContext();\n\
    \           doCommunication();\n       }\n       /**\n        * Acquire credentials\
    \ for the client.\n        */\n       private void initializeGSS() {\n       \
    \    try {\n               clientCred = mgr.createCredential(null /*default princ*/,\n\
    \                   GSSCredential.INDEFINITE_LIFETIME /* max lifetime */,\n  \
    \                 mech /* mechanism  to use */,\n                   GSSCredential.INITIATE_ONLY\
    \ /* init context */);\n               print(\"GSSCredential created for \" +\n\
    \                     cred.getName().toString());\n               print(\"Credential\
    \ lifetime (sec)=\" +\n                     cred.getRemainingLifetime());\n  \
    \         } catch (GSSException e) {\n                   print(\"GSS-API error\
    \ in credential acquisition: \"\n                         + e.getMessage());\n\
    \                   ...\n                   ...\n           }\n           ...\n\
    \           ...\n       }\n       /**\n        * Does the security context establishment\
    \ with the\n        * server.\n        */\n       private void establishContext()\
    \ {\n           byte[] inToken = new byte[0];\n           byte[] outToken = null;\n\
    \           try {\n               GSSName peer = mgr.createName(serviceName,\n\
    \                                  GSSName.NT_HOSTBASED_SERVICE);\n          \
    \     context = mgr.createContext(peer, mech, gssCred,\n                     \
    \   GSSContext.INDEFINITE_LIFETIME/*lifetime*/);\n               // Will need\
    \ to support confidentiality\n               context.requestConf(true);\n    \
    \           while (!context.isEstablished()) {\n                   outToken =\
    \ context.initSecContext(inToken, 0,\n                                       \
    \              inToken.length);\n                   if (outToken != null)\n  \
    \                     writeGSSToken(outToken);\n                   if (!context.isEstablished())\n\
    \                       inToken = readGSSToken();\n               }\n        \
    \       GSSName peer = context.getSrcName();\n               print(\"Security\
    \ context established with \" + peer +\n                     \" using underlying\
    \ mechanism \" + mech.toString());\n           } catch (GSSException e) {\n  \
    \                 print(\"GSS-API error during context establishment: \"\n   \
    \                      + e.getMessage());\n               ...\n              \
    \ ...\n           }\n           ...\n           ...\n       }\n       /**\n  \
    \      * Sends some data to the server and reads back the\n        * response.\n\
    \        */\n       private void doCommunication()  {\n               byte[] inToken\
    \ = null;\n               byte[] outToken = null;\n               byte[] buffer;\n\
    \               // Container for multiple input-output arguments to and\n    \
    \           // from the per-message routines (e.g., wrap/unwrap).\n          \
    \     MessageProp messgInfo = new MessageProp();\n               try {\n     \
    \              /*\n                    * Now send some bytes to the server to\
    \ be\n                    * processed. They will be integrity protected but\n\
    \                    * not encrypted for privacy.\n                    */\n  \
    \                 buffer = readFromFile();\n                   // Set privacy\
    \ to false and use the default QOP\n                   messgInfo.setPrivacy(false);\n\
    \                   outToken = context.wrap(buffer, 0, buffer.length,\n      \
    \                                     messgInfo);\n                   writeGSSToken(outToken);\n\
    \                   /*\n                    * Now read the response from the server.\n\
    \                    */\n                   inToken = readGSSToken();\n      \
    \             buffer = context.unwrap(inToken, 0, inToken.length,\n          \
    \                                 messgInfo);\n                   // All ok if\
    \ no exception was thrown!\n                   GSSName peer = context.getSrcName();\n\
    \                   print(\"Message from \"       + peer.toString()\n        \
    \                 + \" arrived.\");\n                   print(\"Was it encrypted?\
    \ \"  +\n                         messgInfo.getPrivacy());\n                 \
    \  print(\"Duplicate Token? \"   +\n                         messgInfo.isDuplicateToken());\n\
    \                   print(\"Old Token? \"         +\n                        \
    \ messgInfo.isOldToken());\n                   print(\"Unsequenced Token? \" +\n\
    \                         messgInfo.isUnseqToken());\n                   print(\"\
    Gap Token? \"         +\n                         messgInfo.isGapToken());\n \
    \                  ...\n                   ...\n               } catch (GSSException\
    \ e) {\n                   print(\"GSS-API error in per-message calls: \"\n  \
    \                       + e.getMessage());\n                   ...\n         \
    \          ...\n               }\n               ...\n               ...\n   \
    \    } // end of doCommunication method\n       ...\n       ...\n   } // end of\
    \ class SimpleClient\n"
- title: 7.2.  Simple GSS Context Acceptor
  contents:
  - "7.2.  Simple GSS Context Acceptor\n   import org.ietf.jgss.*;\n   /**\n    *\
    \ This is a partial sketch for a simple server program that acts\n    * as a GSS\
    \ context acceptor. It illustrates how to use the Java\n    * bindings for the\
    \ GSS-API specified in\n    * Generic Security Service API Version 2 : Java bindings\n\
    \    *\n    * This code sketch assumes the existence of a GSS-API\n    * implementation\
    \ that supports the mechanisms that it will need and\n    * is present as a library\
    \ package (org.ietf.jgss) either as part of\n    * the standard JRE or in the\
    \ CLASSPATH the application specifies.\n    */\n   import org.ietf.jgss.*;\n \
    \  public class SimpleServer {\n       private String serviceName;\n       private\
    \ GSSName name;\n       private GSSCredential cred;\n       private GSSManager\
    \ mgr;\n       ...\n       ...\n       /**\n        * Wait for client connections,\
    \ establish security contexts and\n        * provide service.\n        */\n  \
    \     private void loop() {\n       ...\n       ...\n           mgr = GSSManager.getInstance();\n\
    \           name = mgr.createName(serviceName,\n                      GSSName.NT_HOSTBASED_SERVICE);\n\
    \           cred = mgr.createCredential(name,\n                      GSSCredential.INDEFINITE_LIFETIME,\n\
    \                      null,\n                      GSSCredential.ACCEPT_ONLY);\n\
    \           // Loop infinitely\n           while (true) {\n               Socket\
    \ s = serverSock.accept();\n               // Start a new thread to serve this\
    \ connection\n               Thread serverThread = new ServerThread(s);\n    \
    \           serverThread.start();\n           }\n       }\n       /**\n      \
    \  * Inner class ServerThread whose run() method provides the\n        * secure\
    \ service to a connection.\n        */\n       private class ServerThread extends\
    \ Thread {\n       ...\n       ...\n           /**\n            * Deals with the\
    \ connection from one client. It also\n            * handles all GSSException's\
    \ thrown while talking to\n            * this client.\n            */\n      \
    \     public void run() {\n               byte[] inToken = null;\n           \
    \    byte[] outToken = null;\n               byte[] buffer;\n               GSSName\
    \ peer;\n               // Container for multiple input-output arguments to and\n\
    \               // from the per-message routines (ie. wrap/unwrap).\n        \
    \       MessageProp supplInfo = new MessageProp();\n               GSSContext\
    \ secContext = null;\n               try {\n                   // Now do the context\
    \ establishment loop\n                   GSSContext context = mgr.createContext(cred);\n\
    \                   while (!context.isEstablished()) {\n                     \
    \  inToken = readGSSToken();\n                       outToken = context.acceptSecContext(inToken,\
    \ 0,\n                                                   inToken.length);\n  \
    \                     if (outToken != null)\n                           writeGSSToken(outToken);\n\
    \                   }\n                   // SimpleServer wants confidentiality\
    \ to be\n                   // available. Check for it.\n                   if\
    \ (!context.getConfState()){\n                       ...\n                   \
    \    ...\n                   }\n                   GSSName peer = context.getSrcName();\n\
    \                   Oid mech = context.getMech();\n                   print(\"\
    Security context established with \" +\n                         peer.toString()\
    \ +\n                         \" using underlying mechanism \" +\n           \
    \              mech.toString() +\n                         \" from Provider \"\
    \ +\n                         context.getProvider().getName());\n            \
    \       // Now read the bytes sent by the client to be\n                   //\
    \ processed.\n                   inToken = readGSSToken();\n                 \
    \  // Unwrap the message\n                   buffer = context.unwrap(inToken,\
    \ 0, inToken.length,\n                                             supplInfo);\n\
    \                   // All ok if no exception was thrown!\n                  \
    \ // Print other supplementary per-message status\n                   // information\n\
    \                   print(\"Message from \" +\n                           peer.toString()\
    \ + \" arrived.\");\n                   print(\"Was it encrypted? \" +\n     \
    \                      supplInfo.getPrivacy());\n                   print(\"Duplicate\
    \ Token? \" +\n                           supplInfo.isDuplicateToken());\n   \
    \                print(\"Old Token? \"  + supplInfo.isOldToken());\n         \
    \          print(\"Unsequenced Token? \" +\n                           supplInfo.isUnseqToken());\n\
    \                   print(\"Gap Token? \"  + supplInfo.isGapToken());\n      \
    \             /*\n                    * Now process the bytes and send back an\
    \ encrypted\n                    * response.\n                    */\n       \
    \            buffer = serverProcess(buffer);\n                   // Encipher it\
    \ and send it across\n                   supplInfo.setPrivacy(true); // privacy\
    \ requested\n                   supplInfo.setQOP(0); // default QOP\n        \
    \           outToken = context.wrap(buffer, 0, buffer.length,\n              \
    \                                supplInfo);\n                   writeGSSToken(outToken);\n\
    \               } catch (GSSException e) {\n                   print(\"GSS-API\
    \ Error: \" + e.getMessage());\n                   // Alternatively, could call\
    \ e.getMajorMessage()\n                   // and e.getMinorMessage()\n       \
    \            print(\"Abandoning security context.\");\n                   ...\n\
    \                   ...\n               }\n               ...\n              \
    \ ...\n           } // end of run method in ServerThread\n       } // end of inner\
    \ class ServerThread\n       ...\n       ...\n   } // end of class SimpleServer\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   The Java language security model allows platform\
    \ providers to have\n   policy based fine-grained access control over any resource\
    \ that an\n   application wants. When using a Java security manager (such as,\
    \ but\n   not limited to, the case of applets running in browsers) the\n   application\
    \ code is in a sandbox by default.\n   Administrators of the platform JRE determine\
    \ what permissions, if\n   any, are to be given to source from different codebases.\
    \ Thus the\n   administrator has to be aware of any special requirements that\
    \ the\n   GSS provider might have for system resources. For instance, a\n   Kerberos\
    \ provider might wish to make a network connection to the KDC\n   to obtain initial\
    \ credentials. This would not be allowed under the\n   sandbox unless the administrator\
    \ had granted permissions for this.\n   Also note that this granting and checking\
    \ of permissions happens\n   transparently to the application and is outside the\
    \ scope of this\n   document.\n   The Java language allows administrators to pre-configure\
    \ a list of\n   security service providers in the <JRE>/lib/security/java.security\n\
    \   file. At runtime, the system approaches these providers in order of\n   preference\
    \ when looking for security related services. Applications\n   have a means to\
    \ modify this list through methods in the \"Security\"\n   class in the \"java.security\"\
    \ package. However, since these\n   modifications would be visible in the entire\
    \ JVM and thus affect all\n   code executing in it, this operation is not available\
    \ in the sandbox\n   and requires special permissions to perform. Thus when a\
    \ GSS\n   application has special needs that are met by a particular security\n\
    \   provider, it has two choices:\n      1) To install the provider on a JVM wide\
    \ basis using the\n         java.security.Security class and then depend on the\
    \ system to\n         find the right provider automatically when the need arises.\n\
    \         (This would require the application to be granted a\n         \"insertProvider\
    \ SecurityPermission\".)\n      2) To pass an instance of the provider to the\
    \ local instance of\n         GSSManager so that only factory calls going through\
    \ that\n         GSSManager use the desired provider. (This would not require\n\
    \         any permissions.)\n"
- title: 9.  Acknowledgments
  contents:
  - "9.  Acknowledgments\n   This proposed API leverages earlier work performed by\
    \ the IETF's CAT\n   WG as outlined in both RFC 2743 and RFC 2744.  Many conceptual\n\
    \   definitions, implementation directions, and explanations have been\n   included\
    \ from these documents.\n   We would like to thank Mike Eisler, Lin Ling, Ram\
    \ Marti, Michael\n   Saltz and other members of Sun's development team for their\
    \ helpful\n   input, comments and suggestions.\n   We would also like to thank\
    \ Joe Salowey, and Michael Smith for many\n   insightful ideas and suggestions\
    \ that have contributed to this\n   document.\n"
- title: 10.  Bibliography
  contents:
  - "10.  Bibliography\n   [GSSAPIv2]        Linn, J., \"Generic Security Service\
    \ Application\n                     Program Interface, Version 2\", RFC 2078,\
    \ January\n                     1997.\n   [GSSAPIv2-UPDATE] Linn, J., \"Generic\
    \ Security Service Application\n                     Program Interface, Version\
    \ 2, Update 1\", RFC 2743,\n                     January 2000.\n   [GSSAPI-Cbind]\
    \    Wray, J., \"Generic Security Service API Version 2 :\n                  \
    \   C-bindings\", RFC 2744, January 2000.\n   [KERBV5]          Linn, J., \"The\
    \ Kerberos Version 5 GSS-API\n                     Mechanism\", RFC 1964, June\
    \ 1996.\n   [SPKM]            Adams, C., \"The Simple Public-Key GSS-API\n   \
    \                  Mechanism\", RFC 2025, October 1996.\n"
- title: 11.  Authors' Addresses
  contents:
  - "11.  Authors' Addresses\n   Address comments related to this memorandum to:\n\
    \        <cat-ietf@mit.edu>\n   Jack Kabat\n   ValiCert, Inc.\n   339 N. Bernardo\
    \ Avenue\n   Mountain View, CA\n   94043, USA\n   Phone: +1-650-567-5496\n   EMail:\
    \ jackk@valicert.com\n   Mayank Upadhyay\n   Sun Microsystems, Inc.\n   901 San\
    \ Antonio Road, MS CUP02-102\n   Palo Alto, CA 94303\n   Phone: +1-408-517-5956\n\
    \   EMail: mdu@eng.sun.com\n"
- title: 12.  Full Copyright Statement
  contents:
  - "12.  Full Copyright Statement\n   Copyright (C) The Internet Society (2000).\
    \  All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
