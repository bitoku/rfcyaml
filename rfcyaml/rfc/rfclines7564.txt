Abstract Application protocols using Unicode characters in protocol strings need to properly handle such strings in order to enforce internationalization rules for strings placed in various protocol slots (such as addresses and identifiers) and to perform valid comparison operations (e.g., for purposes of authentication or authorization).
This document defines a framework enabling application protocols to perform the preparation, enforcement, and comparison of internationalized strings ("PRECIS") in a way that depends on the properties of Unicode characters and thus is agile with respect to versions of Unicode.
As a result, this framework provides a more sustainable approach to the handling of internationalized strings than the previous framework, known as Stringprep (RFC 3454).
This document obsoletes RFC 3454.
1.  Introduction Application protocols using Unicode characters [Unicode] in protocol strings need to properly handle such strings in order to enforce internationalization rules for strings placed in various protocol slots (such as addresses and identifiers) and to perform valid comparison operations (e.g., for purposes of authentication or authorization).
This document defines a framework enabling application protocols to perform the preparation, enforcement, and comparison of internationalized strings ("PRECIS") in a way that depends on the properties of Unicode characters and thus is agile with respect to versions of Unicode.
As described in the PRECIS problem statement [RFC6885], many IETF protocols have used the Stringprep framework [RFC3454] as the basis for preparing, enforcing, and comparing protocol strings that contain Unicode characters, especially characters outside the ASCII range [RFC20].
The Stringprep framework was developed during work on the original technology for internationalized domain names (IDNs), here called "IDNA2003" [RFC3490], and Nameprep [RFC3491] was the Stringprep profile for IDNs.
At the time, Stringprep was designed as a general framework so that other application protocols could define their own Stringprep profiles.
Indeed, a number of application protocols defined such profiles.
After the publication of [RFC3454] in 2002, several significant issues arose with the use of Stringprep in the IDN case, as documented in the IAB's recommendations regarding IDNs [RFC4690]
(most significantly, Stringprep was tied to Unicode version 3.2).
Therefore, the newer IDNA specifications, here called "IDNA2008" ([RFC5890], [RFC5891], [RFC5892], [RFC5893], [RFC5894]), no longer use Stringprep and Nameprep.
This migration away from Stringprep for IDNs prompted other "customers" of Stringprep to consider new approaches to the preparation, enforcement, and comparison of internationalized strings, as described in [RFC6885].
This document defines a framework for a post Stringprep approach to the preparation, enforcement, and comparison of internationalized strings in application protocols, based on several principles: 1.
Define a small set of string classes that specify the Unicode characters (i.e., specific "code points") appropriate for common application protocol constructs.
Define each PRECIS string class in terms of Unicode code points and their properties so that an algorithm can be used to determine whether each code point or character category is (a) valid, (b) allowed in certain contexts, (c) disallowed, or (d) unassigned.
Use an "inclusion model" such that a string class consists only of code points that are explicitly allowed, with the result that any code point not explicitly allowed is forbidden.
Enable application protocols to define profiles of the PRECIS string classes if necessary (addressing matters such as width mapping, case mapping, Unicode normalization, and directionality) but strongly discourage the multiplication of profiles beyond necessity in order to avoid violations of the "Principle of Least Astonishment".
It is expected that this framework will yield the following benefits:  Application protocols will be agile with regard to Unicode versions.
Implementers will be able to share code point tables and software code across application protocols, most likely by means of software libraries.
End users will be able to acquire more accurate expectations about the characters that are acceptable in various contexts.
Given this more uniform set of string classes, it is also expected that copy/paste operations between software implementing different application protocols will be more predictable and coherent.
Whereas the string classes define the "baseline" code points for a range of applications, profiling enables application protocols to apply the string classes in ways that are appropriate for common constructs such as usernames [PRECIS Users Pwds], opaque strings such as passwords [PRECIS Users Pwds], and nicknames [PRECIS Nickname].
Profiles are responsible for defining the handling of right to left characters as well as various mapping operations of the kind also discussed for IDNs in [RFC5895], such as case preservation or lowercasing, Unicode normalization, mapping of certain characters to other characters or to nothing, and mapping of fullwidth and halfwidth characters.
When an application applies a profile of a PRECIS string class, it transforms an input string (which might or might not be conforming) into an output string that definitively conforms to the profile.
In particular, this document focuses on the resulting ability to achieve the following objectives: a.  Enforcing all the rules of a profile for a single output string (e.g., to determine if a string can be included in a protocol slot, communicated to another entity within a protocol, stored in a retrieval system, etc.).
Comparing two output strings to determine if they are equivalent, typically through octet for octet matching to test for "bit string identity" (e.g., to make an access decision for purposes of authentication or authorization as further described in [RFC6943]).
The opportunity to define profiles naturally introduces the possibility of a proliferation of profiles, thus potentially mitigating the benefits of common code and violating user expectations.
See Section 5 for a discussion of this important topic.
In addition, it is extremely important for protocol designers and application developers to understand that the transformation of an input string to an output string is rarely reversible.
As one relatively simple example, case mapping would transform an input string of "StPeter" to "stpeter", and information about the capitalization of the first and third characters would be lost.
Similar considerations apply to other forms of mapping and normalization.
Although this framework is similar to IDNA2008 and includes by reference some of the character categories defined in [RFC5892], it defines additional character categories to meet the needs of common application protocols other than DNS.
The character categories and calculation rules defined under Sections 8 and 9 are normative and apply to all Unicode code points.
The code point table that results from applying the character categories and calculation rules to the latest version of Unicode can be found in an IANA registry.
Terminology Many important terms used in this document are defined in [RFC5890],
The terms "left to right" (LTR) and "right to left" (RTL) are defined in Unicode Standard Annex
As of the date of writing, the version of Unicode published by the Unicode Consortium is 7.0 [Unicode7.0]; however, PRECIS is not tied to a specific version of Unicode.
The latest version of Unicode is always available [Unicode].
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC2119].
This document distinguishes between three different actions that an entity can take with regard to a string:
Enforcement entails applying all of the rules specified for a particular string class or profile thereof to an individual string, for the purpose of determining if the string can be used in a given protocol slot.
Comparison entails applying all of the rules specified for a particular string class or profile thereof to two separate strings, for the purpose of determining if the two strings are equivalent.
Preparation entails only ensuring that the characters in an individual string are allowed by the underlying PRECIS string class.
In most cases, authoritative entities such as servers are responsible for enforcement, whereas subsidiary entities such as clients are responsible only for preparation.
The rationale for this distinction is that clients might not have the facilities (in terms of device memory and processing power) to enforce all the rules regarding internationalized strings (such as width mapping and Unicode normalization), although they can more easily limit the repertoire of characters they offer to an end user.
By contrast, it is assumed that a server would have more capacity to enforce the rules, and in any case acts as an authority regarding allowable strings in protocol slots such as addresses and endpoint identifiers.
In addition, a client cannot necessarily be trusted to properly generate such strings, especially for security sensitive contexts such as authentication and authorization.
various "customers" of Stringprep began to discuss the need to define a post Stringprep approach to the preparation and comparison of internationalized strings other than IDNs.
This community analyzed the existing Stringprep profiles and also weighed the costs and benefits of defining a relatively small set of Unicode characters that would minimize the potential for user confusion caused by visually similar characters (and thus be relatively "safe") vs. defining a much larger set of Unicode characters that would maximize the potential for user creativity (and thus be relatively "expressive").
As a result, the community concluded that most existing uses could be addressed by two string classes:
IdentifierClass:  a sequence of letters, numbers, and some symbols that is used to identify or address a network entity such as a user account, a venue (e.g., a chatroom), an information source (e.g., a data feed), or a collection of data (e.g., a file); the intent is that this class will minimize user confusion in a wide variety of application protocols, with the result that safety has been prioritized over expressiveness for this class.
FreeformClass:  a sequence of letters, numbers, symbols, spaces, and other characters that is used for free form strings, including passwords as well as display elements such as human friendly nicknames for devices or for participants in a chatroom; the intent is that this class will allow nearly any Unicode character, with the result that expressiveness has been prioritized over safety for this class.
well that protocol designers, application developers, service providers, and end users might not understand or be able to enter all of the characters that can be included in the FreeformClass
see Section 12.3 for details.
Future specifications might define additional PRECIS string classes, such as a class that falls somewhere between the IdentifierClass and the FreeformClass.
At this time, it is not clear how useful such a class would be.
In any case, because application developers are able to define profiles of PRECIS string classes, a protocol needing a construct between the IdentifierClass and the FreeformClass could define a restricted profile of the FreeformClass if needed.
The following subsections discuss the IdentifierClass and FreeformClass in more detail, with reference to the dimensions described in Section 5 of [RFC6885].
Each string class is defined by the following behavioral rules:
Valid:  Defines which code points are treated as valid for the string.
Contextual Rule Required:  Defines which code points are treated as allowed only if the requirements of a contextual rule are met (i.e., either CONTEXTJ or CONTEXTO).
Disallowed:  Defines which code points need to be excluded from the string.
Unassigned:  Defines application behavior in the presence of code points that are unknown (i.e., not yet designated) for the version of Unicode used by the application.
This document defines the valid, contextual rule required, disallowed, and unassigned rules for the IdentifierClass and FreeformClass.
As described under Section 5, profiles of these string classes are responsible for defining the width mapping, additional mappings, case mapping, normalization, and directionality rules.
IdentifierClass Most application technologies need strings that can be used to refer to, include, or communicate protocol strings like usernames, filenames, data feed identifiers, and chatroom names.
We group such strings into a class called "IdentifierClass" having the following features.
Valid  Code points traditionally used as letters and numbers in writing systems, i.e., the LetterDigits ("A") category first defined in [RFC5892] and listed here under Section 9.1.
Code points in the range
U 0021 through U 007E
, i.e., the (printable) ASCII7 ("K") category defined under Section 9.11.
These code points are "grandfathered" into PRECIS and thus are valid even if they would otherwise be disallowed according to the property based rules specified in the next section.
Note: Although the PRECIS IdentifierClass reuses the LetterDigits category from IDNA2008, the range of characters allowed in the IdentifierClass is wider than the range of characters allowed in IDNA2008.
The main reason is that IDNA2008 applies the Unstable category before the LetterDigits category, thus disallowing uppercase characters, whereas the IdentifierClass does not apply the Unstable category.
Contextual Rule Required  A number of characters from the Exceptions ("F") category defined under Section 9.6 (see Section 9.6 for a full list).
Joining characters, i.e., the JoinControl ("H") category defined under Section 9.8.
Old Hangul Jamo characters, i.e., the OldHangulJamo ("I") category defined under Section 9.9.
Control characters, i.e., the Controls ("L") category defined under Section 9.12.
, i.e., the PrecisIgnorableProperties ("M") category defined under Section 9.13.
Space characters, i.e., the Spaces ("N") category defined under Section 9.14.
Symbol characters, i.e., the Symbols ("O") category defined under Section 9.15.
Punctuation characters, i.e., the Punctuation ("P") category defined under Section 9.16.
Any character that has a compatibility equivalent, i.e., the HasCompat ("Q") category defined under Section 9.17.
These code points are disallowed even if they would otherwise be valid according to the property based rules specified in the previous section.
Letters and digits other than the "traditional" letters and digits allowed in IDNs, i.e.,
the OtherLetterDigits ("R") category defined under Section 9.18.
Unassigned Any code points that are not yet designated in the Unicode character set are considered unassigned for purposes of the IdentifierClass, and such code points are to be treated as disallowed.
As described in the Introduction to this document, the string classes do not handle all issues related to string preparation and comparison (such as case mapping); instead, such issues are handled at the level of profiles.
Examples for profiles of the IdentifierClass can be found in [PRECIS Users Pwds] (the UsernameCaseMapped and UsernameCasePreserved profiles).
Some application technologies need strings that can be used in a free form way, e.g., as a password in an authentication exchange (see [PRECIS Users Pwds]) or a nickname in a chatroom (see [PRECIS Nickname]).
We group such things into a class called "FreeformClass" having the following features.
Security Warning: As mentioned, the FreeformClass prioritizes expressiveness over safety; Section 12.3 describes some of the security hazards involved with using or profiling the FreeformClass.
Consult Section 12.6 for relevant security considerations when strings conforming to the FreeformClass, or a profile thereof, are used as passwords.
Valid  Traditional letters and numbers, i.e., the LetterDigits (
"A") category first defined in [RFC5892] and listed here under Section 9.1.
Letters and digits other than the "traditional" letters and digits allowed in IDNs, i.e.,
the OtherLetterDigits ("R") category defined under Section 9.18.
Code points in the range
U 0021 through U 007E
, i.e., the (printable) ASCII7 ("K") category defined under Section 9.11.
Any character that has a compatibility equivalent, i.e., the HasCompat ("Q") category defined under Section 9.17.
Space characters, i.e., the Spaces ("N") category defined under Section 9.14.
Symbol characters, i.e., the Symbols ("O") category defined under Section 9.15.
Punctuation characters, i.e., the Punctuation ("P") category defined under Section 9.16.
Contextual Rule Required  A number of characters from the Exceptions ("F") category defined under Section 9.6 (see Section 9.6 for a full list).
Joining characters, i.e., the JoinControl ("H") category defined under Section 9.8.
Old Hangul Jamo characters, i.e., the OldHangulJamo ("I") category defined under Section 9.9.
Control characters, i.e., the Controls ("L") category defined under Section 9.12.
, i.e., the PrecisIgnorableProperties ("M") category defined under Section 9.13.
Unassigned Any code points that are not yet designated in the Unicode character set are considered unassigned for purposes of the FreeformClass, and such code points are to be treated as disallowed.
As described in the Introduction to this document, the string classes do not handle all issues related to string preparation and comparison (such as case mapping); instead, such issues are handled at the level of profiles.
Examples for profiles of the FreeformClass can be found in [PRECIS Users Pwds] (the OpaqueString profile) and [PRECIS Nickname] (the Nickname profile).
This framework document defines the valid, contextual rule required, disallowed, and unassigned rules for the IdentifierClass and the FreeformClass.
A profile of a PRECIS string class MUST define the width mapping, additional mappings (if any), case mapping, normalization, and directionality rules.
A profile MAY also restrict the allowable characters above and beyond the definition of the relevant PRECIS string class (but MUST NOT add as valid any code points that are disallowed by the relevant PRECIS string class).
These matters are discussed in the following subsections.
Profiles of the PRECIS string classes are registered with the IANA as described under Section 11.3.
Profile names use the following convention: they are of the form "Profilename of BaseClass", where the "Profilename" string is a differentiator and "BaseClass" is the name of the PRECIS string class being profiled; for example, the profile of the FreeformClass used for opaque strings such as passwords is the OpaqueString profile [PRECIS Users Pwds].
Profiles Must Not Be Multiplied beyond Necessity
The risk of profile proliferation is significant because having too many profiles will result in different behavior across various applications, thus violating what is known in user interface design as the "Principle of Least Astonishment".
Indeed, we already have too many profiles.
Ideally we would have at most two or three profiles.
Unfortunately, numerous application protocols exist with their own quirks regarding protocol strings.
Domain names, email addresses, instant messaging addresses, chatroom nicknames, filenames, authentication identifiers, passwords, and other strings are already out there in the wild and need to be supported in existing application protocols such as DNS, SMTP, the Extensible Messaging and Presence Protocol (XMPP), Internet Relay Chat (IRC), NFS, the Internet Small Computer System Interface (iSCSI), the Extensible Authentication Protocol (EAP), and the Simple Authentication and Security Layer (SASL), among others.
Nevertheless, profiles must not be multiplied beyond necessity.
To help prevent profile proliferation, this document recommends sensible defaults for the various options offered to profile creators (such as width mapping and Unicode normalization).
In addition, the guidelines for designated experts provided under Section 10 are meant to encourage a high level of due diligence regarding new profiles.
The width mapping rule of a profile specifies whether width mapping is performed on the characters of a string, and how the mapping is done.
Typically, such mapping consists of mapping fullwidth and halfwidth characters, i.e., code points with a Decomposition Type of Wide or Narrow, to their decomposition mappings; as an example, FULLWIDTH DIGIT ZERO (U FF10) would be mapped to DIGIT ZERO (U 0030).
The normalization form specified by a profile (see below) has an impact on the need for width mapping.
Because width mapping is performed as a part of compatibility decomposition, a profile employing either normalization form
KD (NFKD) or normalization form
KC (NFKC) does not need to specify width mapping.
However, if Unicode normalization form C (NFC) is used (as is recommended) then the profile needs to specify whether to apply width mapping; in this case, width mapping is in general RECOMMENDED because allowing fullwidth and halfwidth characters to remain unmapped to their compatibility variants would violate the "Principle of Least Astonishment".
For more information about the concept of width in East Asian scripts within Unicode, see Unicode Standard Annex #11 [UAX11].
Mapping of special characters (e.g., non ASCII space characters to ASCII space or control characters to nothing).
The PRECIS mappings document [PRECIS Mappings] describes such mappings in more detail.
The case mapping rule of a profile specifies whether case mapping (instead of case preservation) is performed on the characters of a string, and how the mapping is applied (e.g., mapping uppercase and titlecase characters to their lowercase equivalents).
If case mapping is desired (instead of case preservation), it is RECOMMENDED to use Unicode Default Case Folding as defined in the Unicode Standard [Unicode]
(at the time of this writing, the algorithm is specified in Chapter 3 of [Unicode7.0]).
Unicode Default Case Folding is not designed to handle various localization issues (such as so called "dotless i" in several Turkic languages).
The PRECIS mappings document [PRECIS Mappings] describes these issues in greater detail and defines a "local case mapping" method that handles some locale  dependent and context dependent mappings.
In order to maximize entropy and minimize the potential for false positives, it is NOT RECOMMENDED for application protocols to map uppercase and titlecase code points to their lowercase equivalents when strings conforming to the FreeformClass, or a profile thereof, are used in passwords; instead, it is RECOMMENDED to preserve the case of all code points contained in such strings and then perform case sensitive comparison.
See also the related discussion in Section 12.6 and in [PRECIS Users Pwds].
The normalization rule of a profile specifies which Unicode normalization form (D, KD, C, or KC) is to be applied (see Unicode Standard Annex #15 [UAX15] for background information).
In accordance with [RFC5198], normalization form
The directionality rule of a profile specifies how to treat strings containing what are often called "right to left" (RTL) characters (see Unicode Standard Annex #9 [UAX9]).
RTL characters come from scripts that are normally written from right to left and are considered by Unicode to, themselves, have right to left directionality.
Some strings containing RTL characters also contain "left to right" (LTR) characters, such as numerals, as well as characters without directional properties.
Consequently, such strings are known as "bidirectional strings".
Presenting bidirectional strings in different layout systems (e.g., a user interface that is configured to handle primarily an RTL script vs. an interface that is configured to handle primarily an LTR script) can yield display results that, while predictable to those who understand the display rules, are counter intuitive to casual users.
In particular, the same bidirectional string (in PRECIS terms) might not be presented in the same way to users of those different layout systems, even though the presentation is consistent within any particular layout system.
In some applications, these presentation differences might be considered problematic and thus the application designers might wish to restrict the use of bidirectional strings by specifying a directionality rule.
In other applications, these presentation differences might not be considered problematic (this especially tends to be true of more "free form" strings) and thus no directionality rule is needed.
The PRECIS framework does not directly address how to deal with bidirectional strings across all string classes and profiles, and does not define any new directionality rules, since at present there is no widely accepted and implemented solution for the safe display of arbitrary bidirectional strings beyond the Unicode bidirectional algorithm [UAX9].
Although rules for management and display of bidirectional strings have been defined for domain name labels and similar identifiers through the "Bidi Rule" specified in the IDNA2008 specification on right to left scripts [RFC5893], those rules are quite restrictive and are not necessarily applicable to all bidirectional strings.
The authors of a PRECIS profile might believe that they need to define a new directionality rule of their own.
Because of the complexity of the issues involved, such a belief is almost always misguided, even if the authors have done a great deal of careful research into the challenges of displaying bidirectional strings.
This document strongly suggests that profile authors who are thinking about defining a new directionality rule think again, and instead consider using the "Bidi Rule" [RFC5893] (for profiles based on the IdentifierClass) or following the Unicode bidirectional algorithm [UAX9] (for profiles based on the FreeformClass or in situations where the IdentifierClass is not appropriate).
A Note about Spaces With regard to the IdentifierClass, the consensus of the PRECIS Working Group was that spaces are problematic for many reasons, including the following:  Many Unicode characters are confusable with ASCII space.
Even if non ASCII space characters are mapped to ASCII space (U 0020), space characters are often not rendered in user interfaces, leading to the possibility that a human user might consider a string containing spaces to be equivalent to the same string without spaces.
In some locales, some devices are known to generate a character other than ASCII space (such as ZERO WIDTH JOINER, U 200D) when a user performs an action like hitting the space bar on a keyboard.
One consequence of disallowing space characters in the IdentifierClass might be to effectively discourage their use within identifiers created in newer application protocols; given the challenges involved with properly handling space characters (especially non ASCII space characters) in identifiers and other protocol strings, the PRECIS Working Group considered this to be a feature, not a bug.
However, the FreeformClass does allow spaces, which enables application protocols to define profiles of the FreeformClass that are more flexible than any profiles of the IdentifierClass.
In addition, as explained in Section 6.3, application protocols can also define application layer constructs containing spaces.
How to Use PRECIS in Applications
Although PRECIS has been designed with applications in mind, internationalization is not suddenly made easy through the use of PRECIS.
Application developers still need to give some thought to how they will use the PRECIS string classes, or profiles thereof, in their applications.
This section provides some guidelines to application developers (and to expert reviewers of application protocol specifications).
Don't define your own profile unless absolutely necessary (see Section 5.1).
Existing profiles have been designed for wide reuse.
It is highly likely that an existing profile will meet your needs, especially given the ability to specify further excluded characters (Section 6.2) and to build application layer constructs (see Section 6.3).
Exactly which entities are responsible for preparation, enforcement, and comparison of internationalized strings (e.g., servers or clients).
Exactly when those entities need to complete their tasks (e.g., a server might need to enforce the rules of a profile before allowing a client to gain network access).
Exactly which protocol slots need to be checked against which profiles (e.g., checking the address of a message's intended recipient against the UsernameCaseMapped profile [PRECIS Users Pwds] of the IdentifierClass, or checking the password of a user against the OpaqueString profile [PRECIS Users Pwds] of the FreeformClass).
See [PRECIS Users Pwds] and [XMPP Addr Format] for definitions of these matters for several applications.
An application protocol that uses a profile MAY specify particular code points that are not allowed in relevant slots within that application protocol, above and beyond those excluded by the string class or profile.
That is, an application protocol MAY do either of the following: 1.
Exclude specific code points that are allowed by the relevant string class.
Exclude characters matching certain Unicode properties (e.g., math symbols) that are included in the relevant PRECIS string class.
As a result of such exclusions, code points that are defined as valid for the PRECIS string class or profile will be defined as disallowed for the relevant protocol slot.
Typically, such exclusions are defined for the purpose of backward compatibility with legacy formats within an application protocol.
These are defined for application protocols, not profiles, in order to prevent multiplication of profiles beyond necessity (see Section 5.1).
Sometimes, an application layer construct does not map in a straightforward manner to one of the base string classes or a profile thereof.
Consider, for example, the "simple user name" construct in the Simple Authentication and Security Layer (SASL)
Depending on the deployment, a simple user name might take the form of a user's full name (e.g., the user's personal name followed by a space and then the user's family name).
Such a simple user name cannot be defined as an instance of the IdentifierClass or a profile thereof,
Order of Operations To ensure proper comparison, the rules specified for a particular string class or profile MUST be applied in the following order: 1.
Behavioral rules for determining whether a code point is valid, allowed under a contextual rule, disallowed, or unassigned As already described, the width mapping, additional mapping, case mapping, normalization, and directionality rules are specified for each profile, whereas the behavioral rules are specified for each string class.
Some of the logic behind this order is provided under Section 5.2.1 (see also the PRECIS mappings document [PRECIS Mappings]).
In order to implement the string classes described above, this document does the following: 1.
Reviews and classifies the collections of code points in the Unicode character set by examining various code point properties.
Defines an algorithm for determining a derived property value, which can vary depending on the string class being used by the relevant application protocol.
This document is not intended to specify precisely how derived property values are to be applied in protocol strings.
That information is the responsibility of the protocol specification that uses or profiles a PRECIS string class from this document.
The value of the property is to be interpreted as follows.
Those code points that are allowed to be used in any PRECIS string class (currently, IdentifierClass and FreeformClass).
The abbreviated term "PVALID" is used to refer to this value in the remainder of this document.
Those code points that are allowed to be used in specific string classes.
In practice, the derived property ID PVAL is not used in this specification, since every ID PVAL code point is PVALID.
Some characteristics of the character, such as its being invisible in certain contexts or problematic in others, require that it not be used in labels unless specific other characters or properties are present.
As in IDNA2008, there are two subdivisions of CONTEXTUAL RULE REQUIRED   the first for Join controls (called "CONTEXTJ") and the second for other characters (called "CONTEXTO").
A character with the derived property value CONTEXTJ or CONTEXTO MUST NOT be used unless an appropriate rule has been established and the context of the character is consistent with that rule.
The most notable of the CONTEXTUAL RULE REQUIRED characters are the Join Control characters U 200D ZERO WIDTH JOINER and
WIDTH NON JOINER, which have a derived property value of CONTEXTJ.
See Appendix A of [RFC5892] for more information.
Those code points that are not permitted in any PRECIS string class.
Those code points that are not to be included in one of the string classes but that might be permitted in others.
In practice, the derived property FREE DIS is not used in this specification, since every FREE DIS code point is DISALLOWED.
Those code points that are not designated (i.e., are unassigned) in the Unicode Standard.
The algorithm to calculate the value of the derived property is as follows (implementations MUST NOT modify the order of operations within this algorithm, since doing so would cause inconsistent results across implementations):
Then ID DIS or FREE PVAL;
Then ID DIS or FREE PVAL;
Spaces Then ID DIS or FREE PVAL; Else
Symbols Then ID DIS or FREE PVAL;
Then ID DIS or FREE PVAL
; Else DISALLOWED; The value of the derived property calculated can depend on the string class; for example, if an identifier used in an application protocol is defined as profiling the PRECIS IdentifierClass then a space character such as U 0020 would be assigned to ID DIS, whereas if an identifier is defined as profiling the PRECIS FreeformClass then the character would be assigned to FREE PVAL.
For the sake of brevity, the designation "FREE PVAL" is used herein, instead of the longer designation "ID DIS or FREE PVAL".
In practice, the derived properties ID PVAL and FREE DIS are not used in this specification, since every ID PVAL code point is PVALID and every FREE DIS code point is DISALLOWED.
Use of the name of a rule (such as "Exceptions") implies the set of code points that the rule defines, whereas the same name as a function call (such as "Exceptions(cp)") implies the value that the code point has in the Exceptions table.
The mechanisms described here allow determination of the value of the property for future versions of Unicode (including characters added after Unicode 5.2 or 7.0 depending on the category, since some categories mentioned in this document are simply pointers to IDNA2008 and therefore were defined at the time of Unicode 5.2).
Changes in Unicode properties that do not affect the outcome of this process therefore do not affect this framework.
For example, a character can have its Unicode General Category value (at the time of this writing, see Chapter 4 of [Unicode7.0]) change from So to Sm, or from Lo to Ll, without affecting the algorithm results.
Moreover, even if such changes were to result, the BackwardCompatible list (Section 9.7) can be adjusted to ensure the stability of the results.
Category Definitions Used to Calculate Derived Property
The derived property obtains its value based on a two step procedure: 1.
Characters are placed in one or more character categories either (1) based on core properties defined by the Unicode Standard or (2) by treating the code point as an exception and addressing the code point based on its code point value.
These categories are not mutually exclusive.
Set operations are used with these categories to determine the values for a property specific to a given string class.
These operations are specified under Section 8.
Note: Unicode property names and property value names might have short abbreviations, such as "gc" for the General Category property and "Ll" for the Lowercase Letter property value of the gc property.
In the following specification of character categories, the operation that returns the value of a particular Unicode character property for a code point is designated by using the formal name of that property (from the Unicode PropertyAliases.txt file [PropertyAliases] followed by "(cp)" for "code point".
For example, the value of the General Category property for a code point is indicated by General Category(cp).
The first ten categories (A J) shown below were previously defined for IDNA2008 and are referenced from [RFC5892] to ease the understanding of how PRECIS handles various characters.
Some of these categories are reused in PRECIS, and some of them are not; however, the lettering of categories is retained to prevent overlap and to ease implementation of both IDNA2008 and PRECIS in a single software application.
The next eight categories (K R) are specific to PRECIS.
This category is defined in Section 2.1 of [RFC5892] and is included by reference for use in PRECIS.
This category is defined in Section 2.2 of [RFC5892].
However, it is not used in PRECIS.
This category is defined in Section 2.3 of [RFC5892].
However, it is not used in PRECIS.
See the PrecisIgnorableProperties ("M") category below for a more inclusive category used in PRECIS identifiers.
This category is defined in Section 2.4 of [RFC5892].
However, it is not used in PRECIS.
This category is defined in Section 2.5 of [RFC5892].
However, it is not used in PRECIS.
See the ASCII7 ("K") category below for a more inclusive category used in PRECIS identifiers.
This category is defined in Section 2.6 of [RFC5892] and is included by reference for use in PRECIS.
This category is defined in Section 2.7 of [RFC5892] and is included by reference for use in PRECIS.
Management of this category is handled via the processes specified in [RFC5892].
At the time of this writing (and also at the time that RFC 5892 was published), this category consisted of the empty set; however, that is subject to change as described in RFC 5892.
This category is defined in Section 2.8 of [RFC5892] and is included by reference for use in PRECIS.
This category is defined in Section 2.9 of [RFC5892] and is included by reference for use in PRECIS.
This category is defined in Section 2.10 of [RFC5892] and is included by reference for use in PRECIS.
This PRECIS specific category consists of all printable, non space characters from the 7 bit ASCII range.
By applying this category, the algorithm specified under Section 8 exempts these characters from other rules that might be applied during PRECIS processing, on the assumption that these code points are in such wide use that disallowing them would be counter productive.
This PRECIS specific category consists of all control characters.
This PRECIS specific category is used to group code points that are discouraged from use in PRECIS string classes.
M: Default Ignorable Code Point(cp)
True or Noncharacter Code Point(cp)
The definition for Default Ignorable Code Point can be found in the DerivedCoreProperties.txt file [DerivedCoreProperties].
This PRECIS specific category is used to group code points that are space characters.
N: General Category(cp) is in {Zs} 9.15.
This PRECIS specific category is used to group code points that are symbols.
O: General Category(cp) is in {Sm, Sc, Sk, So} 9.16.
This PRECIS specific category is used to group code points that are punctuation characters.
P: General Category(cp) is in {Pc, Pd, Ps, Pe, Pi, Pf, Po} 9.17.
This PRECIS specific category is used to group code points that have compatibility equivalents as explained in the Unicode Standard (at the time of this writing, see Chapters 2 and 3 of [Unicode7.0]).
The toNFKC() operation returns the code point in normalization form KC.
For more information, see Section 5 of Unicode Standard Annex #15 [UAX15].
This PRECIS specific category is used to group code points that are letters and digits other than the "traditional" letters and digits grouped under the LetterDigits (A) class (see Section 9.1).
R: General Category(cp) is in {Lt, Nl, No, Me} 10.
Guidelines for Designated Experts Experience with internationalization in application protocols has shown that protocol designers and application developers usually do not understand the subtleties and tradeoffs involved with internationalization and that they need considerable guidance in making reasonable decisions with regard to the options before them.
Therefore:  Protocol designers are strongly encouraged to question the assumption that they need to define new profiles, since existing profiles are designed for wide reuse (see Section 5 for further discussion).
Those who persist in defining new profiles are strongly encouraged to clearly explain a strong justification for doing so, and to publish a stable specification that provides all of the information described under Section 11.3.
The designated experts for profile registration requests ought to seek answers to all of the questions provided under Section 11.3 and to encourage applicants to provide a stable specification documenting the profile (even though the registration policy for PRECIS profiles is Expert Review and a stable specification is not strictly required).
Developers of applications that use PRECIS are strongly encouraged to apply the guidelines provided under Section 6 and to seek out the advice of the designated experts or other knowledgeable individuals in doing so.
All parties are strongly encouraged to help prevent the multiplication of profiles beyond necessity, as described under Section 5.1, and to use PRECIS in ways that will minimize user confusion and insecure application behavior.
Internationalization can be difficult and contentious; designated experts, profile registrants, and application developers are strongly encouraged to work together in a spirit of good faith and mutual understanding to achieve rough consensus on profile registration requests and the use of PRECIS in particular applications.
They are also encouraged to bring additional expertise into the discussion if that would be helpful in adding perspective or otherwise resolving issues.
PRECIS Derived Property Value Registry IANA has created and now maintains the "PRECIS Derived Property Value" registry that records the derived properties for the versions of Unicode that are released after (and including) version 7.0.
The derived property value is to be calculated in cooperation with a designated expert [RFC5226] according to the rules specified under Sections 8 and 9.
The IESG is to be notified if backward incompatible changes to the table of derived properties are discovered or if other problems arise during the process of creating the table of derived property values or during expert review.
Changes to the rules defined under Sections 8 and 9 require IETF Review.
PRECIS Base Classes Registry IANA has created the "PRECIS Base Classes" registry.
In accordance with [RFC5226], the registration policy is "RFC Required".
The registration template is as follows:
Base Class:  [the name of the PRECIS string class] Description:  [a brief description of the PRECIS string class and its intended use, e.g., "A sequence of letters, numbers, and symbols that is used to identify or address a network entity."]
The initial registrations are as follows:
A sequence of letters, numbers, symbols, spaces, and other code points that is used for free form strings.
Section 4.3 of RFC 7564.
A sequence of letters, numbers, and symbols that is used to identify or address a network entity.
Section 4.2 of RFC 7564.
PRECIS Profiles Registry IANA has created the "PRECIS Profiles" registry to identify profiles that use the PRECIS string classes.
In accordance with [RFC5226], the registration policy is "Expert Review".
This policy was chosen in order to ease the burden of registration while ensuring that "customers" of PRECIS receive appropriate guidance regarding the sometimes complex and subtle internationalization issues related to profiles of PRECIS string classes.
The registration template is as follows:
Name:  [the name of the profile]
which PRECIS string class is being profiled] Applicability:  [the specific protocol elements to which this profile applies, e.g., "Localparts in XMPP addresses."]
Replaces:  [the Stringprep profile that this PRECIS profile replaces, if any]
[the behavioral rule for handling of width, e.g., "Map fullwidth and halfwidth characters to their compatibility variants."]
Additional Mapping Rule:  [any additional mappings that are required or recommended, e.g., "Map non ASCII space characters to ASCII space."]
[the behavioral rule for handling of case, e.g., "Unicode Default Case Folding"]
Normalization Rule:  [which Unicode normalization form is applied, e.g., "NFC"] Directionality Rule:  [the behavioral rule for handling of right to  left code points, e.g., "The 'Bidi Rule' defined in RFC 5893 applies."]
Enforcement:  [which entities enforce the rules, and when that enforcement occurs during protocol operations
] Specification:  [a pointer to relevant documentation, such as an RFC or Internet Draft]
In order to request a review, the registrant shall send a completed template to the precis@ietf.org list or its designated successor.
Factors to focus on while defining profiles and reviewing profile registrations include the following:  Would an existing PRECIS string class or profile solve the problem?
(See Section 5.1 for related considerations.)
Is the problem being addressed by this profile well defined?
Does the specification define what kinds of applications are involved and the protocol elements to which this profile applies?
Is the profile clearly defined?
Is the profile based on an appropriate dividing line between user interface (culture, context, intent, locale, device limitations, etc.)
and the use of conformant strings in protocol elements?
Are the width mapping, case mapping, additional mappings, normalization, and directionality rules appropriate for the intended use?
Does the profile explain which entities enforce the rules, and when such enforcement occurs during protocol operations?
Does the profile reduce the degree to which human users could be surprised or confused by application behavior (the "Principle of Least Astonishment")?
Does the profile introduce any new security concerns such as those described under Section 12 of this document (e.g., false positives for authentication or authorization)?
If input strings that appear "the same" to users are programmatically considered to be distinct in different systems, or if input strings that appear distinct to users are programmatically considered to be "the same" in different systems, then users can be confused.
Such confusion can have security implications, such as the false positives and false negatives discussed in [RFC6943].
One starting goal of work on the PRECIS framework was to limit the number of times that users are confused (consistent with the "Principle of Least Astonishment").
Unfortunately, this goal has been difficult to achieve given the large number of application protocols already in existence.
Despite these difficulties, profiles should not be multiplied beyond necessity (see Section 5.1).
In particular, application protocol designers should think long and hard before defining a new profile instead of using one that has already been defined, and if they decide to define a new profile then they should clearly explain their reasons for doing so.
The security of applications that use this framework can depend in part on the proper preparation, enforcement, and comparison of internationalized strings.
For example, such strings can be used to make authentication and authorization decisions, and the security of an application could be compromised if an entity providing a given string is connected to the wrong account or online resource based on different interpretations of the string (again, see [RFC6943]).
Specifications of application protocols that use this framework are strongly encouraged to describe how internationalized strings are used in the protocol, including the security implications of any false positives and false negatives that might result from various enforcement and comparison operations.
For some helpful guidelines, refer to [RFC6943], [RFC5890], [UTR36], and [UTS39].
Use of the IdentifierClass Strings that conform to the IdentifierClass and any profile thereof are intended to be relatively safe for use in a broad range of applications, primarily because they include only letters, digits, and "grandfathered" non space characters from the ASCII range; thus, they exclude spaces, characters with compatibility equivalents, and almost all symbols and punctuation marks.
However, because such strings can still include so called confusable characters (see Section 12.5), protocol designers and implementers are encouraged to pay close attention to the security considerations described elsewhere in this document.
Use of the FreeformClass Strings that conform to the FreeformClass and many profiles thereof can include virtually any Unicode character.
This makes the FreeformClass quite expressive, but also problematic from the perspective of possible user confusion.
Protocol designers are hereby warned that the FreeformClass contains code points they might not understand, and are encouraged to profile the IdentifierClass wherever feasible; however, if an application protocol requires more code points than are allowed by the IdentifierClass, protocol designers are encouraged to define a profile of the FreeformClass that restricts the allowable code points as tightly as possible.
(The PRECIS Working Group considered the option of allowing "superclasses" as well as profiles of PRECIS string classes, but decided against allowing superclasses to reduce the likelihood of security and interoperability problems.)
When systems use local character sets other than ASCII and Unicode, this specification leaves the problem of converting between the local character set and Unicode up to the application or local system.
If different applications (or different versions of one application) implement different rules for conversions among coded character sets, they could interpret the same name differently and contact different application servers or other network entities.
This problem is not solved by security protocols, such as Transport Layer Security (TLS) [RFC5246] and the Simple Authentication and Security Layer (SASL)
[RFC4422], that do not take local character sets into account.
Some characters are visually similar and thus can cause confusion among humans.
Such characters are often called "confusable characters" or "confusables".
The problem of confusable characters is not necessarily caused by the use of Unicode code points outside the ASCII range.
For example, in some presentations and to some individuals the string "ju1iet" (spelled with DIGIT ONE, U 0031, as the third character) might appear to be the same as "juliet" (spelled with LATIN SMALL LETTER L, U 006C), especially on casual visual inspection.
This phenomenon is sometimes called "typejacking".
However, the problem is made more serious by introducing the full range of Unicode code points into protocol strings.
For example, the characters U 13DA U 13A2 U 13B5 U 13AC U 13A2 U 13AC U 13D2 from the Cherokee block look similar to the ASCII characters "STPETER" as they might appear when presented using a "creative" font family.
In some examples of confusable characters, it is unlikely that the average human could tell the difference between the real string and the fake string.
(Indeed, there is no programmatic way to distinguish with full certainty which is the fake string and which is the real string; in some contexts, the string formed of Cherokee characters might be the real string and the string formed of ASCII characters might be the fake string.)
Because PRECIS compliant strings can contain almost any properly encoded Unicode code point, it can be relatively easy to fake or mimic some strings in systems that use the PRECIS framework.
The fact that some strings are easily confused introduces security vulnerabilities of the kind that have also plagued the World Wide Web, specifically the phenomenon known as phishing.
Despite the fact that some specific suggestions about identification and handling of confusable characters appear in the Unicode Security Considerations [UTR36] and the Unicode Security Mechanisms [UTS39], it is also true (as noted in [RFC5890])
that "there are no comprehensive technical solutions to the problems of confusable characters.
Because it is impossible to map visually similar characters without a great deal of context (such as knowing the font families used), the PRECIS framework does nothing to map similar  looking characters together, nor does it prohibit some characters because they look like others.
Nevertheless, specifications for application protocols that use this framework are strongly encouraged to describe how confusable characters can be abused to compromise the security of systems that use the protocol in question, along with any protocol specific suggestions for overcoming those threats.
In particular, software implementations and service deployments that use PRECIS based technologies are strongly encouraged to define and implement consistent policies regarding the registration, storage, and presentation of visually similar characters.
The following recommendations are appropriate: 1.
An application service SHOULD define a policy that specifies the scripts or blocks of characters that the service will allow to be registered (e.g., in an account name) or stored (e.g., in a filename).
Such a policy SHOULD be informed by the languages and scripts that are used to write registered account names; in particular, to reduce confusion, the service SHOULD forbid registration or storage of strings that contain characters from more than one script and SHOULD restrict registrations to characters drawn from a very small number of scripts (e.g., scripts that are well understood by the administrators of the service, to improve manageability).
User oriented application software SHOULD define a policy that specifies how internationalized strings will be presented to a human user.
Because every human user of such software has a preferred language or a small set of preferred languages, the software SHOULD gather that information either explicitly from the user or implicitly via the operating system of the user's device.
Furthermore, because most languages are typically represented by a single script or a small set of scripts, and because most scripts are typically contained in one or more blocks of characters, the software SHOULD warn the user when presenting a string that mixes characters from more than one script or block, or that uses characters outside the normal range of the user's preferred language(s).
(Such a recommendation is not intended to discourage communication across different communities of language users; instead, it recognizes the existence of such communities and encourages due caution when presenting unfamiliar scripts or characters to human users.)
The challenges inherent in supporting the full range of Unicode code points have in the past led some to hope for a way to programmatically negotiate more restrictive ranges based on locale, script, or other relevant factors; to tag the locale associated with a particular string; etc.
As a general purpose internationalization technology, the PRECIS framework does not include such mechanisms.
Security of Passwords Two goals of passwords are to maximize the amount of entropy and to minimize the potential for false positives.
These goals can be achieved in part by allowing a wide range of code points and by ensuring that passwords are handled in such a way that code points are not compared aggressively.
Therefore, it is NOT RECOMMENDED for application protocols to profile the FreeformClass for use in passwords in a way that removes entire categories (e.g., by disallowing symbols or punctuation).
Furthermore, it is NOT RECOMMENDED for application protocols to map uppercase and titlecase code points to their lowercase equivalents in such strings; instead, it is RECOMMENDED to preserve the case of all code points contained in such strings and to compare them in a case sensitive manner.
That said, software implementers need to be aware that there exist tradeoffs between entropy and usability.
For example, allowing a user to establish a password containing "uncommon" code points might make it difficult for the user to access a service when using an unfamiliar or constrained input device.
Some application protocols use passwords directly, whereas others reuse technologies that themselves process passwords (one example of such a technology is the Simple Authentication and Security Layer [RFC4422]).
Moreover, passwords are often carried by a sequence of protocols with backend authentication systems or data storage systems such as RADIUS [RFC2865] and the Lightweight Directory Access Protocol (LDAP)
Developers of application protocols are encouraged to look into reusing these profiles instead of defining new ones, so that end user expectations about passwords are consistent no matter which application protocol is used.
In protocols that provide passwords as input to a cryptographic algorithm such as a hash function, the client will need to perform proper preparation of the password before applying the algorithm, since the password is not available to the server in plaintext form.
Further discussion of password handling can be found in [PRECIS Users Pwds].
Although strings that are consumed in PRECIS based application protocols are often encoded using UTF 8 [RFC3629], the exact encoding is a matter for the application protocol that uses PRECIS, not for the PRECIS framework.
It is known that some existing systems are unable to support the full Unicode character set, or even any characters outside the ASCII range.
If two (or more) applications need to interoperate when exchanging data (e.g., for the purpose of authenticating a username or password), they will naturally need to have in common at least one coded character set (as defined by [RFC6365]).
Establishing such a baseline is a matter for the application protocol that uses PRECIS, not for the PRECIS framework.
Unicode Versions Changes to the properties of Unicode code points can occur as the Unicode Standard is modified from time to time.
For example, three code points underwent changes in their GeneralCategory between Unicode 5.2
(current at the time IDNA2008 was originally published) and Unicode 6.0, as described in [RFC6452].
Implementers might need to be aware that the treatment of these characters differs depending on which version of Unicode is available on the system that is using IDNA2008 or PRECIS.
Other such differences might arise between the version of Unicode current at the time of this writing (7.0) and future versions.
Potential Changes to Handling of Certain Unicode Code Points
As part of the review of Unicode 7.0 for IDNA, a question was raised about a newly added code point that led to a re analysis of the normalization rules used by IDNA and inherited by this document (Section 5.2.4).
Some of the general issues are described in [IAB Statement] and pursued in more detail in [IDNA Unicode].
At the time of writing, these issues have yet to be settled.
However, implementers need to be aware that this specification is likely to be updated in the future to address these issues.
The potential changes include the following:
The range of characters in the LetterDigits category (Sections 4.2.1 and 9.1) might be narrowed.
Some characters with special properties that are now allowed might be excluded.
More "Additional Mapping Rules" (Section 5.2.2) might be defined.
Alternative normalization methods might be added.
Nevertheless, implementations and deployments that are sensitive to the advice given in this specification are unlikely to encounter significant problems as a consequence of these issues or potential changes   specifically, the advice to use the more restrictive IdentifierClass whenever possible or, if using the FreeformClass, to allow only a restricted set of characters, particularly avoiding characters whose implications they do not actually understand.
