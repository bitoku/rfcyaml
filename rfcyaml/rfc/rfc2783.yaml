- title: __initial_text__
  contents:
  - '   Pulse-Per-Second API for UNIX-like Operating Systems, Version 1.0

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2000).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   RFC 1589 describes a UNIX kernel implementation model for high-\n\
    \   precision time-keeping.  This model is meant for use in conjunction\n   with\
    \ the Network Time Protocol (NTP, RFC 1305), or similar time\n   synchronization\
    \ protocols.  One aspect of this model is an accurate\n   interface to the high-accuracy,\
    \ one pulse-per-second (PPS) output\n   typically available from precise time\
    \ sources (such as a GPS or GOES\n   receiver).  RFC 1589 did not define an API\
    \ for managing the PPS\n   facility, leaving implementors without a portable means\
    \ for using PPS\n   sources.  This document specifies such an API.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1 Introduction...................................................\
    \  2\n   2 Data types for representing timestamps.........................  4\n\
    \   2.1 Resolution...................................................  4\n   2.2\
    \ Time scale...................................................  5\n   3 API............................................................\
    \  5\n   3.1 PPS abstraction..............................................  6\n\
    \   3.2 New data structures..........................................  7\n   3.3\
    \ Mode bit definitions......................................... 10\n   3.4 New\
    \ functions................................................ 12\n   3.4.1 New functions:\
    \ obtaining PPS sources....................... 13\n   3.4.2 New functions: setting\
    \ PPS parameters...................... 14\n   3.4.3 New functions: access to PPS\
    \ timestamps.................... 16\n   3.4.4 New functions: disciplining the\
    \ kernel timebase............ 18\n   3.5 Compliance rules.............................................\
    \ 20\n   3.5.1 Functions.................................................. 20\n\
    \   3.5.2 Mode bits.................................................. 20\n   3.6\
    \ Examples..................................................... 21\n   4 Security\
    \ Considerations........................................ 24\n   5 Acknowledgements...............................................\
    \ 24\n   6 References..................................................... 25\n\
    \   7 Authors' Addresses............................................. 26\n   A.\
    \ Extensions and related APIs................................... 27\n   A.1 Extension:\
    \ Parameters for the \"echo\" mechanism............... 27\n   A.2 Extension: Obtaining\
    \ information about external clocks....... 27\n   A.3 Extension: Finding a PPS\
    \ source.............................. 28\n   B. Example implementation: PPSDISC\
    \ Line discipline............... 29\n   B.1 Example......................................................\
    \ 29\n   C. Available implementations..................................... 30\n\
    \   Full Copyright Statement......................................... 31\n"
- title: 1 Introduction
  contents:
  - "1 Introduction\n   RFC 1589 [4] describes a model and programming interface for\
    \ generic\n   operating system software that manages the system clock and timer\n\
    \   functions. The model provides improved accuracy and stability for\n   most\
    \ workstations and servers using the Network Time Protocol (NTP)\n   [3] or similar\
    \ time synchronization protocol.  The model supports the\n   use of external timing\
    \ sources, such as the precision pulse-per-\n   second (PPS) signals typically\
    \ available from precise time sources\n   (such as a GPS or GOES receiver).\n\
    \   However, RFC 1589 did not define an application programming interface\n  \
    \ (API) for the PPS facility.  This document specifies such an\n   interface,\
    \ for use with UNIX (or UNIX-like) operating systems.  Such\n   systems often\
    \ conform to the \"Single UNIX Specification\" [5],\n   sometimes known as POSIX.\n\
    \   One convenient means to provide a PPS signal to a computer system is\n   to\
    \ connect that signal to a modem-control pin on a serial-line\n   interface to\
    \ the computer.  The Data Carrier Detect (DCD) pin is\n   frequently used for\
    \ this purpose.  Typically, the time-code output of\n   the time source is transmitted\
    \ to the computer over the same serial\n   line.  The computer detects a signal\
    \ transition on the DCD pin,\n   usually by receiving an interrupt, and records\
    \ a timestamp as soon as\n   possible.\n   Although existing practice has focussed\
    \ on the use of serial lines\n   and DCD transitions, PPS signals might also be\
    \ delivered by other\n   kinds of devices.  The API specified in this document\
    \ does not\n   require the use of a serial line, although it may be somewhat biased\n\
    \   in that direction.\n   The typical use of this facility is for the operating\
    \ system to\n   record (\"capture\") a high-resolution timestamp as soon as possible\n\
    \   after it detects a PPS signal transition (usually indicated by an\n   interrupt).\
    \  This timestamp can then be made available, with less\n   stringent delay constraints,\
    \ to time-related software.  The software\n   can compare the captured timestamp\
    \ to the received time-code to\n   accurately discover the offset between the\
    \ system clock and the\n   precise time source.\n   The operating system may also\
    \ deliver the PPS event to a kernel\n   procedure, called the \"in-kernel PPS\
    \ consumer.\"  One example would be\n   the \"hardpps()\" procedure, described\
    \ in RFC 1589, which is used to\n   discipline the kernel's internal timebase.\n\
    \   The API specified in this document allows for one or more signal\n   sources\
    \ attached to a computer system to provide PPS inputs, at the\n   option of user-level\
    \ software.  User-level software may obtain\n   signal-transition timestamps for\
    \ any of these PPS sources.  User-\n   level software may optionally specify at\
    \ most one of these PPS\n   sources to be used to discipline the system's internal\
    \ timebase.\n   Although the primary purpose of this API is for capturing true\n\
    \   pulse-per-second events, the API may also be used for accurately\n   timestamping\
    \ events of other periods, or even aperiodic events, when\n   these can be expressed\
    \ as signal transitions.\n   This document does not define internal details of\
    \ how the API must be\n   implemented, and does not specify constraints on the\
    \ accuracy,\n   resolution, or latency of the PPS feature.  However, the utility\
    \ of\n   this feature is inversely proportional to the delay (and variance of\n\
    \   delay), and implementors are encouraged to take this seriously.\n   In principle,\
    \ the rate of events to be captured, or the frequency of\n   the signals, can\
    \ range from once per day (or less often) to several\n   thousand per second.\
    \  However, since in most implementations the\n   timestamping function will be\
    \ implemented as a processor interrupt at\n   a relatively high priority, it is\
    \ prudent to limit the rate of such\n   events.  This may be done either by mechanisms\
    \ in the hardware that\n   generates the signals, or by the operating system.\n"
- title: 2 Data types for representing timestamps
  contents:
  - "2 Data types for representing timestamps\n   Computer systems use various representations\
    \ of time.  Because this\n   API is concerned with the provision of high-accuracy,\
    \ high-resolution\n   time information, the choice of representation is significant.\
    \  (Here\n   we consider only binary representations, not human-format\n   representations.)\n\
    \   The two interesting questions are:\n      1. what is the resolution of the\
    \ representation?\n      2. what time scale is represented?\n   These questions\
    \ often lead to contentious arguments.  Since this API\n   is intended for use\
    \ with NTP and POSIX-compliant systems, however, we\n   can limit the choices\
    \ to representations compatible with existing NTP\n   and POSIX practice, even\
    \ if that practice is considered \"wrong\" in\n   some quarters.\n"
- title: 2.1 Resolution
  contents:
  - "2.1 Resolution\n   In the NTP protocol, \"timestamps are represented as a 64-bit\
    \ unsigned\n   fixed-point number, in seconds relative to 0h on 1 January 1900.\
    \ The\n   integer part is in the first 32 bits and the fraction part in the\n\
    \   last 32 bits [...] The precision of this representation is about 200\n   picoseconds\"\
    \ [3].\n   However, most computer systems cannot measure time to this resolution\n\
    \   (this represents a clock rate of 5 GHz).  The POSIX gettimeofday()\n   function\
    \ returns a \"struct timeval\" value, with a resolution of 1\n   microsecond.\
    \  The POSIX clock_gettime() function returns a \"struct\n   timespec\" value,\
    \ with a resolution of 1 nanosecond.\n   This API uses an extensible representation,\
    \ but defaults to the\n   \"struct timespec\" representation.\n"
- title: 2.2 Time scale
  contents:
  - "2.2 Time scale\n   Several different time scales have been proposed for use in\
    \ computer\n   systems.  UTC and TAI are the two obvious candidates.\n   Some\
    \ people would prefer the use of TAI, which is identical to UTC\n   except that\
    \ it does not correct for leap seconds.  Their preference\n   for TAI stems from\
    \ the difficulty of computing precise time\n   differences when leap seconds are\
    \ involved, especially when using\n   times in the future (for which the exact\
    \ number of leap seconds is,\n   in general, unknowable).\n   However, POSIX and\
    \ NTP both use UTC, albeit with different base\n   dates.  Given that support\
    \ for TAI would, in general, require other\n   changes to the POSIX specification,\
    \ this API uses the POSIX base date\n   of 00:00 January 1, 1970 UTC, and conforms\
    \ to the POSIX use of the\n   UTC time scale.\n"
- title: 3 API
  contents:
  - "3 API\n   A PPS facility can be used in two different ways:\n      1. An application\
    \ can obtain a timestamp, using the system's\n         internal timebase, for\
    \ the most recent PPS event.\n      2. The kernel may directly utilize PPS events\
    \ to discipline its\n         internal timebase, thereby providing highly accurate\
    \ time to\n         all applications.\n   This API supports both uses, individually\
    \ or in combination.  The\n   timestamping feature may be used on any number of\
    \ PPS sources\n   simultaneously; the timebase-disciplining feature may be used\
    \ with at\n   most one PPS source.\n   Although the proper implementation of this\
    \ API requires support from\n   the kernel of a UNIX system, this document defines\
    \ the API in terms\n   of a set of library routines.  This gives the implementor\
    \ some\n   freedom to divide the effort between kernel code and library code\n\
    \   (different divisions might be appropriate on microkernels and\n   monolithic\
    \ kernels, for example).\n"
- title: 3.1 PPS abstraction
  contents:
  - "3.1 PPS abstraction\n   A PPS signal consists of a series of pulses, each with\
    \ an \"asserted\"\n   (logical true) phase, and a \"clear\" (logical false) phase.\
    \  The two\n   phases may be of different lengths.  The API may capture an \"\
    assert\n   timestamp\" at the moment of the transition into the asserted phase,\n\
    \   and a \"clear timestamp\" at the moment of the transition into the\n   clear\
    \ phase.\n   The specific assignment of the logical values \"true\" and \"false\"\
    \ with\n   specific voltages of a PPS signal, if applicable, is outside the\n\
    \   scope of this specification.  However, these assignments SHOULD be\n   consistent\
    \ with applicable standards.  Implementors of PPS sources\n   SHOULD document\
    \ these assignments.\n      Reminder to implementors of DCD-based PPS support:\
    \  TTL and RS-\n      232C (V.24/V.28) interfaces both define the \"true\" state\
    \ as the\n      one having the highest positive voltage. TTL defines a nominal\n\
    \      absence of voltage as the \"false\" state, but RS-232C (V.24/V.28)\n  \
    \    defines the \"false\" state by the presence of a negative voltage.\n   The\
    \ API supports the direct provision of PPS events (and timestamps)\n   to an in-kernel\
    \ PPS consumer.  This could be the function called\n   \"hardpps()\", as described\
    \ in RFC 1589 [4], but the API does not\n   require the kernel implementation\
    \ to use that function name\n   internally.  The current version of the API supports\
    \ at most one in-\n   kernel PPS consumer, and does not provide a way to explicitly\
    \ name\n   it.  The implementation SHOULD impose access controls on the use of\n\
    \   this feature.\n   The API optionally supports an \"echo\" feature, in which\
    \ events on the\n   incoming PPS signal may be reflected through software, after\
    \ the\n   capture of the corresponding timestamp, to an output signal pin.\n \
    \  This feature may be used to discover an upper bound on the actual\n   delay\
    \ between the edges of the PPS signal and the capture of the\n   timestamps; such\
    \ information may be useful in precise calibration of\n   the system.\n   The\
    \ designation of an output pin for the echo signal, and sense and\n   shape of\
    \ the output transition, is outside the scope of this\n   specification, but SHOULD\
    \ be documented for each implementation.  The\n   output pin MAY also undergo\
    \ transitions at other times besides those\n   caused by PPS input events.\n \
    \     Note: this allows an implementation of the echo feature to\n      generate\
    \ an output pulse per input pulse, or an output edge per\n      input pulse, or\
    \ an output pulse per input edge. It also allows the\n      same signal pin to\
    \ be used for several purposes simultaneously.\n   Also, the API optionally provides\
    \ an application with the ability to\n   specify an offset value to be applied\
    \ to captured timestamps.  This\n   can be used to correct for cable and/or radio-wave\
    \ propagation\n   delays, or to compensate for systematic jitter in the external\n\
    \   signal.  The implementation SHOULD impose access controls on the use\n   of\
    \ this feature.\n"
- title: 3.2 New data structures
  contents:
  - "3.2 New data structures\n   The data structure declarations and symbol definitions\
    \ for this API\n   will appear in the header file <sys/timepps.h>.  The header\
    \ file MUST\n   define all constants described in this specification, even if\
    \ they\n   are not supported by the implementation.\n   The API includes several\
    \ implementation-specific types:\n      typedef ... pps_handle_t;       /* represents\
    \ a PPS source */\n      typedef unsigned ... pps_seq_t; /* sequence number */\n\
    \   The \"pps_handle_t\" type is an opaque scalar type used to represent a\n \
    \  PPS source within the API.\n   The \"pps_seq_t\" type is an unsigned integer\
    \ data type of at least 32\n   bits.\n   The precise declaration of the pps_handle_t\
    \ and pps_seq_t types is\n   system-dependent.\n   The API imports the standard\
    \ POSIX definition for this data type:\n      struct timespec {\n            \
    \  time_t  tv_sec;         /* seconds */\n              long    tv_nsec;     \
    \   /* nanoseconds */\n      };\n   The API defines this structure as an internal\
    \ (not \"on the wire\")\n   representation of the NTP \"64-bit unsigned fixed-point\"\
    \ timestamp\n   format [3]:\n      typedef struct ntp_fp {\n              unsigned\
    \ int    integral;\n              unsigned int    fractional;\n      } ntp_fp_t;\n\
    \   The two fields in this structure may be declared as any unsigned\n   integral\
    \ type, each of at least 32 bits.\n   The API defines this new union as an extensible\
    \ type for representing\n   times:\n      typedef union pps_timeu {\n        \
    \      struct timespec tspec;\n              ntp_fp_t        ntpfp;\n        \
    \      unsigned long   longpad[3];\n      } pps_timeu_t;\n   Future revisions\
    \ of this specification may add more fields to this\n   union.\n      Note: adding\
    \ a field to this union that is larger than\n      3*sizeof(long) will break binary\
    \ compatibility.\n   The API defines these new data structures:\n      typedef\
    \ struct {\n          pps_seq_t   assert_sequence;        /* assert event seq\
    \ # */\n          pps_seq_t   clear_sequence;         /* clear event seq # */\n\
    \          pps_timeu_t assert_tu;\n          pps_timeu_t clear_tu;\n         \
    \ int         current_mode;           /* current mode bits */\n      } pps_info_t;\n\
    \      #define assert_timestamp        assert_tu.tspec\n      #define clear_timestamp\
    \         clear_tu.tspec\n      #define assert_timestamp_ntpfp  assert_tu.ntpfp\n\
    \      #define clear_timestamp_ntpfp   clear_tu.ntpfp\n      typedef struct {\n\
    \          int         api_version;            /* API version # */\n         \
    \ int         mode;                   /* mode bits */\n          pps_timeu_t assert_off_tu;\n\
    \          pps_timeu_t clear_off_tu;\n      } pps_params_t;\n      #define assert_offset\
    \   assert_off_tu.tspec\n      #define clear_offset    clear_off_tu.tspec\n  \
    \    #define assert_offset_ntpfp     assert_off_tu.ntpfp\n      #define clear_offset_ntpfp\
    \      clear_off_tu.ntpfp\n   The \"pps_info_t\" type is returned on an inquiry\
    \ to PPS source.  It\n   contains the timestamps for the most recent assert event,\
    \ and the\n   most recent clear event.  The order in which these events were\n\
    \   actually received is defined by the timetamps, not by any other\n   aspect\
    \ of the specification.  Each timestamp field represents the\n   value of the\
    \ operating system's internal timebase when the\n   timestamped event occurred,\
    \ or as close as possible to that time\n   (with the optional addition of a specified\
    \ offset).  The current_mode\n   field contains the value of the mode bits (see\
    \ section 3.3) at the\n   time of the most recent transition was captured for\
    \ this PPS source.\n   An application can use current_mode to discover the format\
    \ of the\n   timestamps returned.\n   The assert_sequence number increases once\
    \ per captured assert\n   timestamp.  Its initial value is undefined.  If incremented\
    \ past the\n   largest value for the type, the next value is zero.  The\n   clear_sequence\
    \ number increases once per captured clear timestamp.\n   Its initial value is\
    \ undefined, and may be different from the initial\n   value of assert_sequence.\
    \  If incremented past the largest value for\n   the type, the next value is zero.\
    \  Due to possible signal loss or\n   excessive signal noise, the assert-sequence\
    \ number and the clear-\n   sequence number might not always increase in step\
    \ with each other.\n      Note that these sequence numbers are most useful in\
    \ applications\n      where events other than PPS transitions are to be captured,\
    \ which\n      might be involved in a precision stopwatch application, for\n \
    \     example. In such cases, the sequence numbers may be used to detect\n   \
    \   overruns, where the application has missed one or more events.\n      They\
    \ may also be used to detect an excessive event rate, or to\n      detect that\
    \ an event has failed to occur between two calls to the\n      time_pps_fetch()\
    \ function (defined later).\n      In order to obtain an uninterrupted series\
    \ of sequence numbers\n      (and hence of event timestamps), it may be necessary\
    \ to sample the\n      pps_info_t values at a rate somewhat faster than the underlying\n\
    \      event rate.  For example, an application interested in both assert\n  \
    \    and clear timestamps may need to sample at least twice per second.\n    \
    \  Proper use of the sequence numbers allows an application to\n      discover\
    \ if it has missed any event timestamps due to an\n      insufficient sampling\
    \ rate.\n   The pps_params_t data type is used to discover and modify parameters\n\
    \   of a PPS source.  The data type includes a mode field, described in\n   section\
    \ 3.3.  It also includes an api_version field, a read-only\n   value giving the\
    \ version of the API.  Currently, the only defined\n   value is:\n      #define\
    \ PPS_API_VERS_1  1\n   This field is present to enable binary compatibility with\
    \ future\n   versions of the API.\n      Note: the term \"read-only\" in this\
    \ specification means that an\n      application cannot modify the relevant data\
    \ item; only the\n      implementation can modify the value.  The implementation\
    \ MUST\n      ignore attempts by the application to modify a read-only field.\n\
    \   As an OPTIONAL feature of the API, the implementation MAY support\n   adding\
    \ offsets to the timestamps that are captured.  (Values of type\n   \"struct timespec\"\
    \ can represent negative offsets.)  The assert_offset\n   field of a pps_params_t\
    \ value specifies a value to be added to\n   generate a captured assert_timestamp.\
    \  The clear_offset of a\n   pps_params_t value field specifies a value to be\
    \ added to generate a\n   captured clear_timestamp.  Since the offsets, if any,\
    \ apply to all\n   users of a given PPS source, the implementation SHOULD impose\
    \ access\n   controls on the use of this feature; for example, allowing only the\n\
    \   super-user to set the offset values.  The default value for both\n   offsets\
    \ is zero.\n"
- title: 3.3 Mode bit definitions
  contents:
  - "3.3 Mode bit definitions\n   A set of mode bits is associated with each PPS source.\n\
    \   The bits in the mode field of the pps_params_t type are:\n      /* Device/implementation\
    \ parameters */\n      #define PPS_CAPTUREASSERT       0x01\n      #define PPS_CAPTURECLEAR\
    \        0x02\n      #define PPS_CAPTUREBOTH         0x03\n      #define PPS_OFFSETASSERT\
    \        0x10\n      #define PPS_OFFSETCLEAR         0x20\n      #define PPS_CANWAIT\
    \             0x100\n      #define PPS_CANPOLL             0x200\n      /* Kernel\
    \ actions */\n      #define PPS_ECHOASSERT          0x40\n      #define PPS_ECHOCLEAR\
    \           0x80\n      /* Timestamp formats */\n      #define PPS_TSFMT_TSPEC\
    \         0x1000\n      #define PPS_TSFMT_NTPFP         0x2000\n   These mode\
    \ bits are divided into three categories:\n      1. Device/implementation parameters:\
    \  These are parameters either\n         of the device or of the implementation.\
    \  If the implementation\n         allows these to be changed, then these bits\
    \ are read/write for\n         users with sufficient privilege (such as the super-user),\
    \ and\n         read-only for other users.  If the implementation does not\n \
    \        allow these bits to be changed, they are read-only.\n      2. Kernel\
    \ actions:  These bits specify certain kernel actions to\n         be taken on\
    \ arrival of a signal.  If the implementation\n         supports one of these\
    \ actions, then the corresponding bit is\n         read/write for users with sufficient\
    \ privilege (such as the\n         super-user), and read-only for other users.\
    \  If the\n         implementation does not support the action, the corresponding\n\
    \         bit is always zero.\n      3. Timestamp formats:  These bits indicate\
    \ the set of timestamp\n         formats available for the device.  They are always\
    \ read-only.\n   In more detail, the meanings of the Device/implementation parameter\n\
    \   mode bits are:\n   PPS_CAPTUREASSERT\n                   If this bit is set,\
    \ the assert timestamp for the\n                   associated PPS source will\
    \ be captured.\n   PPS_CAPTURECLEAR\n                   If this bit is set, the\
    \ clear timestamp for the\n                   associated PPS source will be captured.\n\
    \   PPS_CAPTUREBOTH Defined as the union of PPS_CAPTUREASSERT and\n          \
    \         PPS_CAPTURECLEAR, for convenience.\n   PPS_OFFSETASSERT\n          \
    \         If set, the assert_offset value is added to the\n                  \
    \ current value of the operating system's internal\n                   timebase\
    \ in order to generate the captured\n                   assert_timestamp.\n  \
    \ PPS_OFFSETCLEAR If set, the clear_offset value is added to the\n           \
    \        current value of the operating system's internal\n                  \
    \ timebase in order to generate the captured\n                   clear_timestamp.\n\
    \   PPS_CANWAIT     If set, the application may request that the\n           \
    \        time_pps_fetch() function (see section 3.4.3) should\n              \
    \     block until the next timestamp arrives.  Note: this\n                  \
    \ mode bit is read-only.\n   PPS_CANPOLL     This bit is reserved for future use.\
    \  An application\n                   SHOULD NOT depend on any functionality implied\
    \ either\n                   by its presence or by its absence.\n   If neither\
    \ PPS_CAPTUREASSERT nor PPS_CAPTURECLEAR is set, no valid\n   timestamp will be\
    \ available via the API.\n   The meanings of the Kernel action mode bits are:\n\
    \   PPS_ECHOASSERT   If set, after the capture of an assert timestamp,\n     \
    \              the implementation generates a signal transition as\n         \
    \          rapidly as possible on an output signal pin.  This\n              \
    \     MUST NOT affect the delay between the PPS source's\n                   transition\
    \ to the asserted phase and the capture of\n                   the assert timestamp.\n\
    \   PPS_ECHOCLEAR    If set, after the capture of a clear timestamp, the\n   \
    \                implementation generates a signal transition as\n           \
    \        rapidly as possible on an output signal pin.  This\n                \
    \   MUST NOT affect the delay between the PPS source's\n                   transition\
    \ to the clear phase and the capture of the\n                   clear timestamp.\n\
    \   The timestamp formats are:\n   PPS_TSFMT_TSPEC Timestamps and offsets are\
    \ represented as values of\n                   type \"struct timespec\".  All\
    \ implementations MUST\n                   support this format, and this format\
    \ is the default\n                   unless an application specifies otherwise.\n\
    \   PPS_TSFMT_NTPFP Timestamps and offsets are represented as values of\n    \
    \               type \"ntp_fp_t\", which corresponds to the NTP\n            \
    \       \"64-bit unsigned fixed-point\" timestamp format [3].\n              \
    \     Support for this format is OPTIONAL.\n   Other timestamp format bits may\
    \ be defined as fields are added to the\n   \"pps_timeu_t\" union.\n   The operating\
    \ system may implement all of these mode bits, or just a\n   subset of them. \
    \ If an attempt is made to set an unsupported mode\n   bit, the API will return\
    \ an error.  If an attempt is made to modify a\n   read-only mode bit, the API\
    \ will return an error.\n"
- title: 3.4 New functions
  contents:
  - "3.4 New functions\n   In the description of functions that follows, we use the\
    \ following\n   function parameters:\n   filedes         A file descriptor (type:\
    \ int), for a serial line or\n                   other source of PPS events.\n\
    \   ppshandle       A variable of type \"pps_handle_t\", as defined in\n     \
    \              section 3.2.\n   ppsinfobuf      A record of type \"pps_info_t\"\
    , as defined in\n                   section 3.2.\n   ppsparams       A record\
    \ of type \"pps_params_t\", as defined in\n                   section 3.2.\n \
    \  tsformat        An integer with exactly one of the timestamp format\n     \
    \              bits set.\n"
- title: '3.4.1 New functions: obtaining PPS sources'
  contents:
  - "3.4.1 New functions: obtaining PPS sources\n   The API includes functions to\
    \ create and destroy PPS source\n   \"handles\".\n   SYNOPSIS\n      int time_pps_create(int\
    \ filedes, pps_handle_t *handle);\n      int time_pps_destroy(pps_handle_t handle);\n\
    \   DESCRIPTION\n   All of the other functions in the PPS API operate on PPS handles\n\
    \   (type: pps_handle_t).  The time_pps_create() is used to convert an\n   already-open\
    \ UNIX file descriptor, for an appropriate special file,\n   into a PPS handle.\n\
    \   The definition of what special files are appropriate for use with the\n  \
    \ PPS API is outside the scope of this specification, and may vary\n   based on\
    \ both operating system implementation, and local system\n   configuration.  One\
    \ typical case is a serial line, whose DCD pin is\n   connected to a source of\
    \ PPS events.\n   The mode in which the UNIX file descriptor was originally opened\n\
    \   affects what operations are allowed on the PPS handle.  The\n   time_pps_setparams()\
    \ and time_pps_kcbind() functions (see sections\n   3.4.2 and 3.4.4) SHOULD be\
    \ prohibited by the implementation if the\n   descriptor is open only for reading\
    \ (O_RDONLY).\n      Note: operations on a descriptor opened with an inappropriate\
    \ mode\n      might fail with EBADF.\n   The time_pps_destroy() function makes\
    \ the PPS handle unusable, and\n   frees any storage that might have been allocated\
    \ for it.  It does not\n   close the associated file descriptor, nor does it change\
    \ any of the\n   parameter settings for the PPS source.\n      Note: If this API\
    \ is adapted to an operating system that does not\n      follow UNIX conventions\
    \ for representing an accessible PPS source\n      as an integer file descriptor,\
    \ the time_pps_create() function may\n      take different parameters from those\
    \ shown here.\n   RETURN VALUES\n   On successful completion, the time_pps_create()\
    \ function returns 0.\n   Otherwise, a value of -1 is returned and errno is set\
    \ to indicate the\n   error.\n   If called with a valid handle parameter, the\
    \ time_pps_destroy()\n   function returns 0.  Otherwise, it returns -1.\n   ERRORS\n\
    \   If the time_pps_create() function fails, errno may be set to one of\n   the\
    \ following values:\n   [EBADF]         The filedes parameter is not a valid file\
    \ descriptor.\n   [EOPNOTSUPP]    The use of the PPS API is not supported for\
    \ the file\n                   descriptor.\n   [EPERM]         The process's effective\
    \ user ID does not have the\n                   required privileges to use the\
    \ PPS API.\n"
- title: '3.4.2 New functions: setting PPS parameters'
  contents:
  - "3.4.2 New functions: setting PPS parameters\n   The API includes several functions\
    \ use to set or obtain the\n   parameters of a PPS source.\n   SYNOPSIS\n    \
    \  int time_pps_setparams(pps_handle_t handle,\n                             \
    \ const pps_params_t *ppsparams);\n      int time_pps_getparams(pps_handle_t handle,\n\
    \                              pps_params_t *ppsparams);\n      int time_pps_getcap(pps_handle_t\
    \ handle, int *mode);\n   DESCRIPTION\n   A suitably privileged application may\
    \ use time_pps_setparams() to set\n   the parameters (mode bits and timestamp\
    \ offsets) for a PPS source.\n   The pps_params_t type is defined in section 3.2;\
    \ mode bits are\n   defined in section 3.3.  An application may use time_pps_getparams()\n\
    \   to discover the current settings of the PPS parameters.  An\n   application\
    \ that needs to change only a subset of the existing\n   parameters must first\
    \ call time_pps_getparams() to obtain the current\n   parameter values, then set\
    \ the new values using time_pps_setparams().\n      Note: a call to time_pps_setparams()\
    \ replaces the current values\n      of all mode bits with those specified via\
    \ the ppsparams argument,\n      except those bits whose state cannot be changed.\
    \  Bits might be\n      read-only due to access controls, or because they are\
    \ fixed by the\n      implementation.\n   The timestamp format of the assert_offset\
    \ and clear_offset fields is\n   defined by the mode field.  That is, on a call\
    \ to\n   time_pps_setparams(), the kernel interprets the supplied offset\n   values\
    \ using the timestamp format given in the mode field of the\n   ppsparams argument.\
    \  If the requested timestamp format is not\n   supported, the time_pps_setparams()\
    \ function has no effect and\n   returns an error value.  On a call to time_pps_getparams(),\
    \ the\n   kernel provides the timestamp format of the offsets by setting one of\n\
    \   the timestamp format bits in the mode field.\n      Note: an application that\
    \ uses time_pps_getparams() to read the\n      current offset values cannot specify\
    \ which format is used.  The\n      implementation SHOULD return the offsets using\
    \ the same timestamp\n      format as was used when the offsets were set.\n  \
    \ An application wishing to discover which mode bits it may set, with\n   its\
    \ current effective user ID, may call time_pps_getcap().  This\n   function returns\
    \ the set of mode bits that may be set by the\n   application, without generating\
    \ an EINVAL or EPERM error, for the\n   specified PPS source.  It does not return\
    \ the current values for the\n   mode bits.  A call to time_pps_getcap() returns\
    \ the mode bits\n   corresponding to all supported timestamp formats.\n   The\
    \ time_pps_getcap() function MAY ignore the mode in which the\n   associated UNIX\
    \ file descriptor was opened, so the application might\n   still receive an EBADF\
    \ error on a call to time_pps_setparams(), even\n   if time_pps_getcap() says\
    \ that the chosen mode bits are allowed.\n   The mode bits returned by time_pps_getcap()\
    \ for distinct PPS handles\n   may differ, reflecting the specific capabilities\
    \ of the underlying\n   hardware connection to the PPS source, or of the source\
    \ itself.\n   RETURN VALUES\n   On successful completion, the time_pps_setparams(),\n\
    \   time_pps_getparams(), and time_pps_getcap() functions return 0.\n   Otherwise,\
    \ a value of -1 is returned and errno is set to indicate the\n   error.\n   ERRORS\n\
    \   If the time_pps_setparams(), time_pps_getparams(), or\n   time_pps_getcap()\
    \ function fails, errno may be set to one of the\n   following values:\n   [EBADF]\
    \         The handle parameter is not associated with a valid\n              \
    \     file descriptor, or the descriptor is not open for\n                   writing.\n\
    \   [EFAULT]        A parameter points to an invalid address.\n   [EOPNOTSUPP]\
    \    The use of the PPS API is not supported for the\n                   associated\
    \ file descriptor.\n   [EINVAL]        The operating system does not support all\
    \ of the\n                   requested mode bits.\n   [EPERM]         The process's\
    \ effective user ID does not have the\n                   required privileges\
    \ to use the PPS API, or to set the\n                   given mode bits.\n"
- title: '3.4.3 New functions: access to PPS timestamps'
  contents:
  - "3.4.3 New functions: access to PPS timestamps\n   The API includes one function\
    \ that gives applications access to PPS\n   timestamps.  As an implementation\
    \ option, the application may request\n   the API to block until the next timestamp\
    \ is captured.  (The API does\n   not directly support the use of the select()\
    \ or poll() system calls\n   to wait for PPS events.)\n   SYNOPSIS\n      int\
    \ time_pps_fetch(pps_handle_t handle,\n                              const int\
    \ tsformat,\n                              pps_info_t *ppsinfobuf,\n         \
    \                     const struct timespec *timeout);\n   DESCRIPTION\n   An\
    \ application may use time_pps_fetch() to obtain the most recent\n   timestamps\
    \ captured for the PPS source specified by the handle\n   parameter.  The tsformat\
    \ parameter specifies the desired timestamp\n   format; if the requested timestamp\
    \ format is not supported, the call\n   fails and returns an error value.  The\
    \ application MUST specify\n   exactly one timestamp format.\n   This function\
    \ blocks until either a timestamp is captured from the\n   PPS source, or until\
    \ the specified timeout duration has expired.  If\n   the timeout parameter is\
    \ a NULL pointer, the function simply blocks\n   until a timestamp is captured.\
    \  If the timeout parameter specifies a\n   delay of zero, the function returns\
    \ immediately.\n   Support for blocking behavior is an implementation option.\
    \  If the\n   PPS_CANWAIT mode bit is clear, and the timeout parameter is either\n\
    \   NULL or points to a non-zero value, the function returns an\n   EOPNOTSUPP\
    \ error.  An application can discover whether the feature is\n   implemented by\
    \ using time_pps_getcap() to see if the PPS_CANWAIT mode\n   bit is set.\n   The\
    \ result is stored in the ppsinfobuf parameter, whose fields are\n   defined in\
    \ section 3.2.  If the function returns as the result of a\n   timeout or error,\
    \ the contents of the ppsinfobuf are undefined.\n   If this function is invoked\
    \ before the system has captured a\n   timestamp for the signal source, the ppsinfobuf\
    \ returned will have\n   its timestamp fields set to the time format's base date\
    \ (e.g., for\n   PPS_TSFMT_TSPEC, both the tv_sec and tv_nsec fields will be zero).\n\
    \   RETURN VALUES\n   On successful completion, the time_pps_fetch() function\
    \ returns 0.\n   Otherwise, a value of -1 is returned and errno is set to indicate\
    \ the\n   error.\n   ERRORS\n   If the time_pps_fetch() function fails, errno\
    \ may be set to one of\n   the following values:\n   [EBADF]         The handle\
    \ parameter is not associated with a valid\n                   file descriptor.\n\
    \   [EFAULT]        A parameter points to an invalid address.\n   [EINTR]    \
    \     A signal was delivered before the time limit\n                   specified\
    \ by the timeout parameter expired and before\n                   a timestamp\
    \ has been captured.\n   [EINVAL]        The requested timestamp format is not\
    \ supported.\n   [EOPNOTSUPP]    The use of the PPS API is not supported for the\n\
    \                   associated file descriptor.\n   [ETIMEDOUT]     The timeout\
    \ duration has expired.\n"
- title: '3.4.4 New functions: disciplining the kernel timebase'
  contents:
  - "3.4.4 New functions: disciplining the kernel timebase\n   The API includes one\
    \ OPTIONAL function to specify if and how a PPS\n   source is provided to a kernel\
    \ consumer of PPS events, such as the\n   code used to discipline the operating\
    \ system's internal timebase.\n   SYNOPSIS\n      int time_pps_kcbind(pps_handle_t\
    \ handle,\n                              const int kernel_consumer,\n        \
    \                      const int edge,\n                              const int\
    \ tsformat);\n   DESCRIPTION\n   An application with appropriate privileges may\
    \ use time_pps_kcbind()\n   to bind a kernel consumer to the PPS source specified\
    \ by the handle.\n   The kernel consumer is identified by the kernel_consumer\
    \ parameter.\n   In the current version of the API, the possible values for this\n\
    \   parameter are:\n      #define PPS_KC_HARDPPS          0\n      #define PPS_KC_HARDPPS_PLL\
    \      1\n      #define PPS_KC_HARDPPS_FLL      2\n   with these meanings:\n \
    \  PPS_KC_HARDPPS  The kernel's hardpps() function (or equivalent).\n   PPS_KC_HARDPPS_PLL\n\
    \                   A variant of hardpps() constrained to use a\n            \
    \       phase-locked loop.\n   PPS_KC_HARDPPS_FLL\n                   A variant\
    \ of hardpps() constrained to use a\n                   frequency-locked loop.\n\
    \   Implementation of any or all of these values is OPTIONAL.\n   The edge parameter\
    \ indicates which edge of the PPS signal causes a\n   timestamp to be delivered\
    \ to the kernel consumer.  It may have the\n   value PPS_CAPTUREASSERT, PPS_CAPTURECLEAR,\
    \ or PPS_CAPTUREBOTH,\n   depending on particular characteristics of the PPS source.\
    \  It may\n   also be zero, which removes any binding between the PPS source and\n\
    \   the kernel consumer.\n   The tsformat parameter specifies the format for the\
    \ timestamps\n   delivered to the kernel consumer.  If this value is zero, the\n\
    \   implementation MAY choose the appropriate format, or return EINVAL.\n   The\
    \ implementation MAY ignore a non-zero value for this parameter.\n   The binding\
    \ created by this call persists until it is changed by a\n   subsequent call specifying\
    \ the same kernel_consumer.  In particular,\n   a subsequent call to time_pps_destroy()\
    \ for the specified handle does\n   not affect the binding.\n   The binding is\
    \ independent of any prior or subsequent changes to the\n   PPS_CAPTUREASSERT\
    \ and PPS_CAPTURECLEAR mode bits for the device.\n   However, if either the edge\
    \ or the tsformat parameter values are\n   inconsistent with the capabilities\
    \ of the PPS source, an error is\n   returned.  The implementation MAY also return\
    \ an error if the\n   tsformat value is unsupported for time_pps_kcbind(), even\
    \ if it is\n   supported for other uses of the API.\n   The operating system may\
    \ enforce two restrictions on the bindings\n   created by time_pps_kcbind():\n\
    \      1. the kernel MAY return an error if an attempt is made to bind a\n   \
    \      kernel consumer to more than one PPS source a time.\n      2. the kernel\
    \ MAY restrict the ability to set bindings to\n         processes with sufficient\
    \ privileges to modify the system's\n         internal timebase.  (On UNIX systems,\
    \ such modification is\n         normally done using settimeofday() and/or adjtime(),\
    \ and is\n         restricted to users with superuser privilege.)\n      Warning:\
    \ If this feature is configured for a PPS source that does\n      not have an\
    \ accurate 1-pulse-per-second signal, or is otherwise\n      inappropriately configured,\
    \ use of this feature may result in\n      seriously incorrect timekeeping for\
    \ the entire system.  For best\n      results, the 1-PPS signal should have much\
    \ better frequency\n      stability than the system's internal clock source (usually\
    \ a\n      crystal-controlled oscillator), and should have jitter (variation\n\
    \      in interarrival time) much less than the system's clock-tick\n      interval.\n\
    \   See RFC 1589 [4] for more information about how the system's timebase\n  \
    \ may be disciplined using a PPS signal.\n   RETURN VALUES\n   On successful completion,\
    \ the time_pps_kcbind() function returns 0.\n   Otherwise, a value of -1 is returned\
    \ and errno is set to indicate the\n   error.\n   ERRORS\n   If the time_pps_kcbind()\
    \ function fails, errno may be set to one of\n   the following values:\n   [EBADF]\
    \         The handle parameter is not associated with a valid\n              \
    \     file descriptor, or the descriptor is not open for\n                   writing.\n\
    \   [EFAULT]        A parameter points to an invalid address.\n   [EINVAL]   \
    \     The requested timestamp format is not supported.\n   [EOPNOTSUPP]    The\
    \ use of the PPS API is not supported for the\n                   associated file\
    \ descriptor, or this OPTIONAL\n                   function is not supported.\n\
    \   [EPERM]         The process's effective user ID does not have the\n      \
    \             required privileges to set the binding.\n"
- title: 3.5 Compliance rules
  contents:
  - "3.5 Compliance rules\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",\"\
    SHOULD\", SHOULD NOT\",\n   \"MAY\", and \"OPTIONAL\" in this document are to\
    \ be interpreted as\n   described in RFC 2119 [1].\n   Some features of this specification\
    \ are OPTIONAL, but others are\n   REQUIRED.\n"
- title: 3.5.1 Functions
  contents:
  - "3.5.1 Functions\n   An implementation MUST provide these functions:\n      -\
    \ time_pps_create()\n      - time_pps_destroy()\n      - time_pps_setparams()\n\
    \      - time_pps_getparams()\n      - time_pps_getcap()\n      - time_pps_fetch()\n\
    \   An implementation MUST provide this function, but it may be\n   implemented\
    \ as a function that always return an EOPNOTSUPP error,\n   possibly on a per-source\
    \ basis:\n      - time_pps_kcbind()\n"
- title: 3.5.2 Mode bits
  contents:
  - "3.5.2 Mode bits\n   An implementation MUST support at least one of these mode\
    \ bits for\n   each PPS source:\n      - PPS_CAPTUREASSERT\n      - PPS_CAPTURECLEAR\n\
    \   and MAY support both of them.  If an implementation supports both of\n   these\
    \ bits for a PPS source, it SHOULD allow them to be set\n   simultaneously.\n\
    \   An implementation MUST support this timestamp format:\n      - PPS_TSFMT_TSPEC\n\
    \   An implementation MAY support these mode bits:\n      - PPS_ECHOASSERT\n \
    \     - PPS_ECHOCLEAR\n      - PPS_OFFSETASSERT\n      - PPS_OFFSETCLEAR\n   An\
    \ implementation MAY support this timestamp format:\n      - PPS_TSFMT_NTPFP\n"
- title: 3.6 Examples
  contents:
  - "3.6 Examples\n   A very simple use of this API might be:\n      int fd;\n   \
    \   pps_handle_t handle;\n      pps_params_t params;\n      pps_info_t infobuf;\n\
    \      struct timespec timeout;\n      /* Open a file descriptor and enable PPS\
    \ on rising edges */\n      fd = open(PPSfilename, O_RDWR, 0);\n      time_pps_create(fd,\
    \ &handle);\n      time_pps_getparams(handle, &params);\n      if ((params.mode\
    \ & PPS_CAPTUREASSERT) == 0) {\n          fprintf(stderr, \"%s cannot currently\
    \ CAPTUREASSERT\\n\",\n                PPSfilename);\n          exit(1);\n   \
    \   }\n      /* create a zero-valued timeout */\n      timeout.tv_sec = 0;\n \
    \     timeout.tv_nsec = 0;\n      /* loop, printing the most recent timestamp\
    \ every second or so */\n      while (1) {\n          sleep(1);\n          time_pps_fetch(handle,\
    \ PPS_TSFMT_TSPEC, &infobuf, &timeout);\n          printf(\"Assert timestamp:\
    \ %d.%09d, sequence: %ld\\n\",\n                      infobuf.assert_timestamp.tv_sec,\n\
    \                      infobuf.assert_timestamp.tv_nsec,\n                   \
    \   infobuf.assert_sequence);\n      }\n   Note that this example omits most of\
    \ the error-checking that would be\n   expected in a reliable program.\n   Also\
    \ note that, on a system that supports PPS_CANWAIT, the function\n   of these\
    \ lines:\n         sleep(1);\n         time_pps_fetch(handle, PPS_TSFMT_TSPEC,\
    \ &infobuf, &timeout);\n   might be more reliably accomplished using:\n      \
    \   timeout.tv_sec = 100;\n         timeout.tv_nsec = 0;\n         time_pps_fetch(handle,\
    \ PPS_TSFMT_TSPEC, &infobuf, &timeout);\n   The (arbitrary) timeout value is used\
    \ to protect against the\n   possibility that another application might disable\
    \ PPS timestamps, or\n   that the hardware generating the timestamps might fail.\n\
    \   A slightly more elaborate use of this API might be:\n      int fd;\n     \
    \ pps_handle_t handle;\n      pps_params_t params;\n      pps_info_t infobuf;\n\
    \      int avail_mode;\n      struct timespec timeout;\n      /* Open a file descriptor\
    \ */\n      fd = open(PPSfilename, O_RDWR, 0);\n      time_pps_create(fd, &handle);\n\
    \      /*\n       * Find out what features are supported\n       */\n      time_pps_getcap(handle,\
    \ &avail_mode);\n      if ((avail_mode & PPS_CAPTUREASSERT) == 0) {\n        \
    \  fprintf(stderr, \"%s cannot CAPTUREASSERT\\n\", PPSfilename);\n          exit(1);\n\
    \      }\n      if ((avail_mode & PPS_OFFSETASSERT) == 0) {\n          fprintf(stderr,\
    \ \"%s cannot OFFSETASSERT\\n\", PPSfilename);\n          exit(1);\n      }\n\
    \      /*\n       * Capture assert timestamps, and\n       *   compensate for\
    \ a 675 nsec propagation delay\n       */\n      time_pps_getparams(handle, &params);\n\
    \      params.assert_offset.tv_sec = 0;\n      params.assert_offset.tv_nsec =\
    \ 675;\n      params.mode |= PPS_CAPTUREASSERT | PPS_OFFSETASSERT;\n      time_pps_setparams(handle,\
    \ &params);\n      /* create a zero-valued timeout */\n      timeout.tv_sec =\
    \ 0;\n      timeout.tv_nsec = 0;\n      /* loop, printing the most recent timestamp\
    \ every second or so */\n      while (1) {\n          if (avail_mode & PPS_CANWAIT)\
    \ {\n              time_pps_fetch(handle, PPS_TSFMT_TSPEC, &infobuf, NULL);\n\
    \                              /* waits for the next event */\n          } else\
    \ {\n              sleep(1);\n              time_pps_fetch(handle, PPS_TSFMT_TSPEC,\
    \ &infobuf,\n                timeout);\n          }\n          printf(\"Assert\
    \ timestamp: %d.%09d, sequence: %ld\\n\",\n                      infobuf.assert_timestamp.tv_sec,\n\
    \                      infobuf.assert_timestamp.tv_nsec,\n                   \
    \   infobuf.assert_sequence);\n      }\n   Again, most of the necessary error-checking\
    \ has been omitted from\n   this example.\n"
- title: 4 Security Considerations
  contents:
  - "4 Security Considerations\n   This API gives applications three capabilities:\n\
    \      - Causing the system to capture timestamps on certain events.\n      -\
    \ Obtaining timestamps for certain events.\n      - Affecting the system's internal\
    \ timebase.\n   The first capability should not affect security directly, but\
    \ might\n   cause a slight increase in interrupt latency and interrupt-handling\n\
    \   overhead.\n   The second capability might be useful in implementing certain\
    \ kinds\n   of covert communication channels.\n   In most cases, neither of these\
    \ first two issues is a significant\n   security threat, because the traditional\
    \ UNIX file protection\n   facility may be used to to limit access to the relevant\
    \ special\n   files.  Provision of the PPS API adds minimal additional risk.\n\
    \   The final capability is reserved to highly privileged users.  In UNIX\n  \
    \ systems, this means those with superuser privilege.  Such users can\n   evade\
    \ protections based on file permissions; however, such users can\n   in general\
    \ cause unbounded havoc, and can set the internal timebase\n   (and its rate of\
    \ change), so this API creates no new vulnerabilities.\n"
- title: 5 Acknowledgements
  contents:
  - "5 Acknowledgements\n   The API in this document draws some of its inspiration\
    \ from the LBL\n   \"ppsclock\" distribution [2], originally implemented in 1993\
    \ by Steve\n   McCanne, Craig Leres, and Van Jacobson.  We also thank Poul-Henning\n\
    \   Kamp, Craig Leres, Judah Levine, and Harlan Stenn for helpful\n   comments\
    \ they contributed during the drafting of this document.\n"
- title: 6 References
  contents:
  - "6 References\n   1.  Bradner, S., \"Key words for use in RFCs to Indicate Requirement\n\
    \       Levels\", BCP 14, RFC 2119, March 1997.\n   2.  Steve McCanne, Craig Leres,\
    \ and Van Jacobson.  PPSCLOCK.\n       ftp://ftp.ee.lbl.gov/ppsclock.tar.Z.\n\
    \   3.  Mills, D., \"Network Time Protocol (Version 3):  Specification,\n    \
    \   Implementation and Analysis\", RFC 1305, March 1992.\n   4.  Mills, D., \"\
    A Kernel Model for Precision Timekeeping\", RFC 1589,\n       March, 1994.\n \
    \  5.  The Open Group.  The Single UNIX Specification, Version 2 - 6 Vol\n   \
    \    Set for UNIX 98.  Document number T912, The Open Group, February,\n     \
    \  1997.\n"
- title: 7 Authors' Addresses
  contents:
  - "7 Authors' Addresses\n   Jeffrey C. Mogul\n   Western Research Laboratory\n \
    \  Compaq Computer Corporation\n   250 University Avenue\n   Palo Alto, California,\
    \ 94305, U.S.A.\n   Phone: 1 650 617 3304 (email preferred)\n   EMail: mogul@wrl.dec.com\n\
    \   David L. Mills\n   Electrical and Computer Engineering Department\n   University\
    \ of Delaware\n   Newark, DE 19716\n   Phone: (302) 831-8247\n   EMail: mills@udel.edu\n\
    \   Jan Brittenson\n   Sun Microsystems, Inc.\n   901 San Antonio Rd  M/S MPK17-202\n\
    \   Palo Alto, CA 94303\n   Email: Jan.Brittenson@Eng.Sun.COM\n   Jonathan Stone\n\
    \   Stanford Distributed Systems Group\n   Stanford, CA 94305\n   Phone: (650)\
    \ 723-2513\n   EMail: jonathan@dsg.stanford.edu\n   Ulrich Windl\n   Universitaet\
    \ Regensburg, Klinikum\n   EMail: ulrich.windl@rz.uni-regensburg.de\n"
- title: A. Extensions and related APIs
  contents:
  - "A. Extensions and related APIs\n   The API specified in the main body of this\
    \ document could be more\n   useful with the provision of several extensions or\
    \ companion APIs.\n   At present, the interfaces listed in this appendix are not\
    \ part of\n   the formal specification in this document.\n"
- title: 'A.1 Extension: Parameters for the "echo" mechanism'
  contents:
  - "A.1 Extension: Parameters for the \"echo\" mechanism\n   The \"echo\" mechanism\
    \ described in the body of this specification\n   leaves most of the details to\
    \ the implementor, especially the\n   designation of one or more output pins.\n\
    \   It might be useful to extend this API to provide either or both of\n   these\
    \ features:\n      - A means by which the application can discover which output\n\
    \        pin is echoing the input pin.\n      - A means by which the application\
    \ can select which output\n        pin is echoing the input pin.\n"
- title: 'A.2 Extension: Obtaining information about external clocks'
  contents:
  - "A.2 Extension: Obtaining information about external clocks\n   The PPS API may\
    \ be useful with a wide variety of reference clocks,\n   connected via several\
    \ different interface technologies (including\n   serial lines, parallel interfaces,\
    \ and bus-level interfaces).  These\n   reference clocks can have many features\
    \ and parameters, some of which\n   might not even have been invented yet.\n \
    \  We believe that it would be useful to have a mechanism by which an\n   application\
    \ can discover arbitrary features and parameters of a\n   reference clock.  These\
    \ might include:\n      - Clock manufacturer, model number, and revision level\n\
    \      - Whether the clock is synchronized to an absolute standard\n      - For\
    \ synchronized clocks,\n           * The specific standard\n           * The accuracy\
    \ of the standard\n           * The path used (direct connection, shortwave, longwave,\n\
    \             satellite, etc.)\n           * The distance (offset) and variability\
    \ of this path\n      - For PPS sources,\n           * The pulse rate\n      \
    \     * The pulse shape\n           * Which edge of the pulse corresponds to the\
    \ epoch\n      - The time representation format\n   This information might best\
    \ be provided by an API analogous to the\n   standard \"curses\" API, with a database\
    \ analogous to the standard\n   \"terminfo\" database.  That is, a \"clockinfo\"\
    \ database would contain a\n   set of (attribute, value) pairs for each type of\
    \ clock, and the API\n   would provide a means to query this database.\n   Additional\
    \ mechanisms would allow an application to discover the\n   clock or clocks connected\
    \ to the local system, and to discover the\n   clockinfo type of a specific clock\
    \ device.\n"
- title: 'A.3 Extension: Finding a PPS source'
  contents:
  - "A.3 Extension: Finding a PPS source\n   Although the clockinfo database described\
    \ in section A.2, together\n   with the discover mechanisms described there, would\
    \ allow an\n   application to discover the PPS source (or sources) connected to\
    \ a\n   system, it might be more complex than necessary.\n   A simpler approach\
    \ would be to support a single function that\n   provides the identity of one\
    \ or more PPS sources.\n   For example, the function might be declared as\n  \
    \    int time_pps_findsource(int index,\n                              char *path,\
    \ int pathlen,\n                              char *idstring, int idlen);\n  \
    \ The index argument implicitly sets up an ordering on the PPS sources\n   attached\
    \ to the system.  An application would use this function to\n   inquire about\
    \ the Nth source.  The function would return -1 if no\n   such source exists;\
    \ otherwise, it would return 0, and would place the\n   pathname of the associated\
    \ special file in the path argument.  It\n   would also place an identification\
    \ string in the idstring argument.\n   The identification string could include\
    \ the clock make, model,\n   version, etc., which could then be used by the application\
    \ to control\n   its behavior.\n   This function might simply read the Nth line\
    \ from a simple database,\n   containing lines such as:\n      /dev/tty00    \
    \  \"TrueTime 468-DC\"\n      /dev/pps1       \"Homebrew rubidium frequency standard\"\
    \n   allowing the system administrator to describe the configuration of\n   PPS\
    \ sources.\n"
- title: 'B. Example implementation: PPSDISC Line discipline'
  contents:
  - "B. Example implementation: PPSDISC Line discipline\n   One possible implementation\
    \ of the PPS API might be to define a new\n   \"line discipline\" and then map\
    \ the API onto a set of ioctl()\n   commands.  Here we sketch such an implementation;\
    \ note that this is\n   not part of the specification of the API, and applications\
    \ should not\n   expect this low-level interface to be available.\n   In this\
    \ approach, the set of line disciplines is augmented with one\n   new line discipline,\
    \ PPSDISC.  This discipline will act exactly the\n   same as the TTYDISC discipline,\
    \ except for its handling of modem DCD\n   interrupts.\n   Once the TIOCSETD ioctl()\
    \ has been used to select this line\n   discipline, PPS-related operations on\
    \ the serial line may be invoked\n   using new ioctl() commands.  For example\
    \ (values used only for\n   illustration):\n   #define PPSFETCH      _IOR('t',\
    \ 75, pps_info_t)\n   #define PPSSETPARAM   _IOW('t', 76, pps_params_t)\n   #define\
    \ PPSGETPARAM   _IOR('t', 77, pps_params_t)\n   #define PPSGETCAP     _IOR('t',\
    \ 78, int)\n"
- title: B.1 Example
  contents:
  - "B.1 Example\n   A typical use might be:\n      int ldisc = PPSDISC;\n      pps_params_t\
    \ params;\n      pps_info_t infobuf;\n      ioctl(fd, TIOCSETD, &ldisc);    /*\
    \ set discipline */\n      /*\n       * Check the capabilities of this PPS source\
    \ to see\n       * if it supports what we need.\n       */\n      ioctl(fd, PPSGETCAP,\
    \ &params);\n      if ((params.mode & PPS_CAPTUREASSERT) == 0) {\n          fprintf(stderr,\
    \ \"PPS source is not suitable\\n\");\n          exit(1);\n      }\n      /*\n\
    \       * Set this line to timestamp on a rising-edge interrupt\n       */\n \
    \     ioctl(fd, PPSGETPARAMS, &params);\n      params.mode |= PPS_CAPTUREASSERT;\n\
    \      ioctl(fd, PPSSETPARAMS, &params);\n      sleep(2);       /* allow time\
    \ for the PPS pulse to happen */\n      /* obtain most recent timestamp and sequence\
    \ # for this line */\n      ioctl(fd, PPSFETCH, &infobuf);\n   Again, this example\
    \ imprudently omits any error-checking.\n"
- title: C. Available implementations
  contents:
  - "C. Available implementations\n   Several available implementations of this API\
    \ are listed at\n   <http://www.ntp.org/ppsapi/PPSImpList.html>.  Note that not\
    \ all of\n   these implementations correspond to the current version of the\n\
    \   specification.\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2000).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
