- title: __initial_text__
  contents:
  - '                    NFILE -  A File Access Protocol

    '
- title: STATUS OF THIS MEMO
  contents:
  - "STATUS OF THIS MEMO\n   This document includes a specification of the NFILE file\
    \ access\n   protocol and its underlying levels of protocol, the Token List\n\
    \   Transport Layer and Byte Stream with Mark.  The goal of this\n   specification\
    \ is to promote discussion of the ideas described here,\n   and to encourage designers\
    \ of future file protocols to take advantage\n   of these ideas.  A secondary\
    \ goal is to make the specification\n   available to sites that might benefit\
    \ from implementing NFILE.  The\n   distribution of this document is unlimited.\n\
    \                             TABLE OF CONTENTS\n   1.  INTRODUCTION         \
    \                                           3\n   2.  NFILE PROTOCOL LAYERING\
    \                                         4\n   3.  OVERVIEW OF AN NFILE SESSION\
    \                                    5\n   4.  NFILE CONTROL AND DATA CONNECTIONS\
    \                              6\n   5.  NFILE FILE OPENING MODES            \
    \                            7\n   6.  NFILE CHARACTER SET                   \
    \                          9\n   7.  CONVENTIONS USED IN THIS DOCUMENT       \
    \                       10\n       7.1  Mapping Data Types Into Token List Representation\
    \         10\n       7.2  Format of NFILE Commands and Responses             \
    \       10\n       7.3  Data Channel Handles and Direct File Identifiers     \
    \     13\n       7.4  Syntax of File and Directory Pathname Arguments        \
    \   13\n       7.5  Format of NFILE File Property/Value Pairs                \
    \ 14\n   8.  NFILE COMMANDS                                                 16\n\
    \       8.1  ABORT Command                                             16\n  \
    \     8.2  CHANGE-PROPERTIES Command                                 16\n    \
    \   8.3  CLOSE Command                                             17\n      \
    \ 8.4  COMPLETE Command                                          19\n       8.5\
    \  CONTINUE Command                                          20\n       8.6  CREATE-DIRECTORY\
    \ Command                                  21\n       8.7  CREATE-LINK Command\
    \                                       21\n       8.8  DATA-CONNECTION Command\
    \                                   22\n       8.9  DELETE Command           \
    \                                 23\n       8.10  DIRECT-OUTPUT Command     \
    \                               23\n       8.11  DIRECTORY Command           \
    \                             24\n            8.11.1  NFILE DIRECTORY Data Format\
    \                       26\n       8.12  DISABLE-CAPABILITIES Command        \
    \                     27\n       8.13  ENABLE-CAPABILITIES Command           \
    \                   28\n       8.14  EXPUNGE Command                         \
    \                 28\n       8.15  FILEPOS Command                           \
    \               29\n            8.15.1  Implementation Hint for FILEPOS Command\
    \           30\n       8.16  FINISH Command                                  \
    \         30\n       8.17  HOME-DIRECTORY Command                            \
    \       31\n       8.18  LOGIN Command                                       \
    \     32\n       8.19  MULTIPLE-FILE-PLISTS Command                          \
    \   34\n       8.20  OPEN Command                                            \
    \ 35\n            8.20.1  NFILE OPEN Optional Keyword/Value Pairs           39\n\
    \            8.20.2  NFILE OPEN Response Return Values                 45\n  \
    \     8.21  PROPERTIES Command                                       47\n    \
    \   8.22  READ Command                                             49\n      \
    \ 8.23  RENAME Command                                           50\n       8.24\
    \  RESYNCHRONIZE-DATA-CHANNEL Command                       51\n            8.24.1\
    \  Implementation Hints for RESYNCHRONIZE-DATA-      51\n                    CHANNEL\
    \ Command\n       8.25  UNDATA-CONNECTION Command                            \
    \    52\n   9.  NFILE RESYNCHRONIZATION PROCEDURE                            \
    \  53\n       9.1  NFILE Control Connection Resynchronization                54\n\
    \       9.2  NFILE Data Connection Resynchronization                   55\n  \
    \ 10.  NFILE ERRORS AND NOTIFICATIONS                                58\n    \
    \   10.1  Notifications From the NFILE Server                      58\n      \
    \ 10.2  NFILE Command Response Errors                            59\n       10.3\
    \  NFILE Asynchronous Errors                                60\n       10.4  NFILE\
    \ Three-letter Error Codes                           61\n   11.  TOKEN LIST TRANSPORT\
    \ LAYER                                    65\n       11.1  Introduction to the\
    \ Token List Transport Layer           65\n       11.2  Token List Stream    \
    \                                    66\n            11.2.1  Types of Tokens and\
    \ Token Lists                   66\n            11.2.2  Token List Stream Example\
    \                         68\n            11.2.3  Mapping of Lisp Objects to Token\
    \ List Stream      70\n                    Representation\n            11.2.4\
    \  Aborting and the Token List Stream                71\n       11.3  Token List\
    \ Data Stream                                   72\n   12.  BYTE STREAM WITH MARK\
    \                                         73\n       12.1  Discussion of Byte\
    \ Stream with Mark                      73\n       12.2  Byte Stream with Mark\
    \ Abortable States                   75\n   13.  POSSIBLE FUTURE EXTENSIONS  \
    \                                  77\n   APPENDIX A.  NORMAL TRANSLATION MODE\
    \                               79\n   APPENDIX B.  RAW TRANSLATION MODE     \
    \                             83\n   APPENDIX C.  SUPER-IMAGE TRANSLATION MODE\
    \                          84\n   NOTES                                      \
    \                        86\n                              LIST OF TABLES\n  \
    \ TABLE 1.    TRANSLATIONS FROM NFILE CHARACTERS TO UNIX CHARACTERS  80\n   TABLE\
    \ 2.    TRANSLATIONS FROM UNIX CHARACTERS TO NFILE CHARACTERS  80\n   TABLE 3.\
    \    TRANSLATIONS FROM NFILE TO PDP-10 CHARACTERS           81\n   TABLE 4.  \
    \  TRANSLATIONS FROM PDP-10 CHARACTERS TO NFILE           82\n               CHARACTERS\n\
    \   TABLE 5.    SUPER-IMAGE TRANSLATION FROM NFILE TO ASCII            84\n  \
    \ TABLE 6.    SUPER-IMAGE TRANSLATION FROM ASCII TO NFILE            85\n"
- title: 1.  INTRODUCTION
  contents:
  - "1.  INTRODUCTION\n   NFILE stands for \"New File Protocol\".  NFILE was originally\
    \ designed\n   as a replacement for an older protocol named QFILE, with the goal\
    \ of\n   solving robustness problems of QFILE, hence the name \"New File\n   Protocol\"\
    .\n   NFILE was designed and implemented at Symbolics by Bernard S.\n   Greenberg.\
    \  Mike McMahon made important contributions, especially in\n   the design and\
    \ implementation of the Byte Stream with Mark and Token\n   List Transport layers.\
    \  NFILE has been used successfully for file\n   access between Symbolics computers\
    \ since 1985.  NFILE servers have\n   been written for UNIX hosts as well.  NFILE\
    \ is intended for use by\n   any type of file system, not just the native Symbolics\
    \ file system.\n   NFILE is a file access protocol that supports a large set of\n\
    \   operations on files and directories on remote systems, including:\n      \
    \      - Reading and writing entire files\n            - Reading and writing selected\
    \ portions of files\n            - Deleting and renaming files\n            -\
    \ Creating links\n            - Listing, creating, and expunging directories\n\
    \            - Listing and changing the properties of files\n            - Enabling\
    \ and disabling access capabilities on a remote\n              host\n   NFILE\
    \ supports file transfer of binary or character files.\n   The NFILE server provides\
    \ information about any errors that occur in\n   the course of a command.  In\
    \ addition, NFILE has a robust scheme for\n   handling aborts on the user side.\n\
    \   This specification defines NFILE user version 2 and server version 2.\n  \
    \ We do not envision NFILE as an unchanging protocol, but rather as a\n   protocol\
    \ that could continue to develop if additional requirements\n   are identified\
    \ though the process of this Request for Comments.  The\n   design of NFILE makes\
    \ room for various useful extensions.  Some of\n   the extensions that we are\
    \ considering are described later on in this\n   document:  See the section \"\
    Possible Future Extensions\", section 13.\n"
- title: 2.  NFILE PROTOCOL LAYERING
  contents:
  - "2.  NFILE PROTOCOL LAYERING\n   NFILE is a layered file protocol.  The layers\
    \ are:\n             +-----------------------------------------------+\n     \
    \        |client program or user interface               |\n             +-----------------------------------------------+\n\
    \             |NFILE                                          |\n            \
    \ +-----------------------------------------------+\n             |Token List\
    \ Transport Layer                     |\n             +-----------------------------------------------+\n\
    \             |Byte Stream with Mark                          |\n            \
    \ +-----------------------------------------------+\n             |reliable host-host\
    \ byte transmission protocol  |\n             +-----------------------------------------------+\n\
    \   Byte Stream with Mark is a simple protocol that guarantees that an\n   out-of-band\
    \ signal can be transmitted in the case of program\n   interruption.  Byte Stream\
    \ with Mark is to be layered upon extant\n   byte stream protocols.  An important\
    \ goal of the NFILE design was\n   that NFILE could be built on any byte stream.\
    \  It is currently\n   implemented on TCP and Chaosnet.  See the section \"Byte\
    \ Stream with\n   Mark\", section 12.\n   The Token List Transport Layer is a\
    \ protocol that facilitates the\n   transmission of simple structured data, such\
    \ as lists.  See the\n   section \"Token List Transport Layer\", section 11.\n\
    \   The NFILE commands and command responses are transmitted in \"token\n   lists\"\
    .  See the section \"NFILE Commands\", section 8.\n   This specification does\
    \ not include a client program or user\n   interface to the protocol.  In the\
    \ Symbolics implementation, the\n   normal file operations transparently invoke\
    \ NFILE, when the remote\n   host is known to support NFILE.  Another possible\
    \ interface to NFILE\n   would be through a dedicated client program that would\
    \ issue NFILE\n   commands in response to explicit requests by the user.\n"
- title: 3.  OVERVIEW OF AN NFILE SESSION
  contents:
  - "3.  OVERVIEW OF AN NFILE SESSION\n   An NFILE session is a dialogue between two\
    \ hosts.  The host that\n   initiates the NFILE session is known as the \"user\
    \ side\", and the\n   other host is the \"server side\".  The user side sends\
    \ all NFILE\n   commands.  The server receives each command, processes it, and\n\
    \   responds to it, indicating the success or failure of the command.\n   The\
    \ user side keeps track of commands sent and command responses\n   received by\
    \ using \"transaction identifiers\" to identify each command.\n   The user side\
    \ generates a transaction identifier (which must be\n   unique per this dialogue)\
    \ for each command, and sends the transaction\n   identifier to the server along\
    \ with the command.  Each NFILE server\n   response includes the transaction identifier\
    \ of the command with\n   which the response is associated.  The server is not\
    \ required to\n   respond to commands in the same order that the user gave them.\n\
    \   The user side sends NFILE commands over a bidirectional network\n   connection\
    \ called the \"control connection\".  The server sends its\n   command responses\
    \ on the same control connection.  The control\n   connection governing the NFILE\
    \ session is established at the\n   beginning of the session.  If the control\
    \ connection is ever broken,\n   the NFILE session is ended.\n   Whereas NFILE\
    \ commands and responses are transmitted on the control\n   connection, file data\
    \ is transferred over \"data channels\".  An \"input\n   data channel\" transfers\
    \ data from server to user.  An \"output data\n   channel\" transfers data from\
    \ user to server.  Each input data channel\n   is associated with an output data\
    \ channel; together these two\n   channels comprise a \"data connection\".\n \
    \  Often more than one NFILE activity is occurring at any given time.\n   For\
    \ example, several files can be open and transferring data\n   simultaneously;\
    \ one or more commands can be in process at the same\n   time; and the server\
    \ can be simultaneously transmitting directory\n   lists and processing further\
    \ commands.  This happens in an\n   implementation in which the user side has\
    \ multiple processes, and\n   several processes share a single NFILE server.\n"
- title: 4.  NFILE CONTROL AND DATA CONNECTIONS
  contents:
  - "4.  NFILE CONTROL AND DATA CONNECTIONS\n   The user and server communicate through\
    \ a single control connection\n   and a set of data connections.  Data connections\
    \ are established and\n   disestablished by NFILE commands.  The user side sends\
    \ NFILE commands\n   to the server over the control connection.  The server responds\
    \ to\n   every user command over this control connection.  The actual file\n \
    \  data is transmitted over the data connections.\n   User aborts can disrupt\
    \ the normal flow of data on the control\n   connection and data connections.\
    \  An important aspect of any file\n   protocol is the way it handles user aborts.\
    \  NFILE uses a\n   resynchronization procedure to bring the affected control\
    \ connection\n   or data channel from an unknown, unsafe state into a known state.\n\
    \   After resynchronization, the control connection or data channel can\n   be\
    \ reused.  See the section \"NFILE Resynchronization Procedure\",\n   section\
    \ 9.\n   THE CONTROL CONNECTION\n   An NFILE session is begun when the NFILE user\
    \ program connects to a\n   remote host and establishes a network connection.\
    \  This initial\n   connection is the control conection of the dialogue.  If TCP\
    \ is used\n   as the underlying protocol, contact NFILE's well-known port, 59.\
    \  If\n   Chaos is used, use the contact name \"NFILE\".\n   The control connection\
    \ is the vehicle used by the user to send its\n   commands, and the server to\
    \ send its command responses.  These types\n   of communication occur over the\
    \ NFILE control connection:\n         - The user side sends NFILE commands.\n\
    \         - The server sends command responses.\n         - The server sends \"\
    notifications\" and \"asynchronous errors\".\n           See the section \"NFILE\
    \ Errors and Notifications\", section 10.\n         - During resynchronization\
    \ (a special circumstance) either the\n           user or server sends a mark.\n\
    \   All commands, command responses, and other data flowing over the\n   NFILE\
    \ control connection are transmitted in the format of \"top-level\n   token lists\"\
    .  The control connection expects never to receive \"loose\n   tokens\"; that\
    \ is, tokens not contained in token lists.\n   DATA CONNECTIONS\n   Data connections\
    \ are established and discarded at user request, by\n   means of two NFILE commands:\
    \  DATA-CONNECTION and UNDATA-CONNECTION.\n   Each data connection is associated\
    \ with a specific control\n   connection, which is the same control connection\
    \ that caused the data\n   connection to be established.\n   Each data connection\
    \ is composed of two \"data channels\".  Each data\n   channel is capable of sending\
    \ data in one direction.  The term \"input\n   channel\" refers to the data channel\
    \ that transmits data from the\n   server to the user side; \"output channel\"\
    \ refers to the data channel\n   that transmits data from the user to the server\
    \ side.  Throughout the\n   NFILE documentation, the terms \"input channel\" and\
    \ \"output channel\"\n   are seen from the perspective of the user side.  A single\
    \ data\n   channel can be used for one data transfer after another.\n   The format\
    \ of the data transferred on the data channels is defined as\n   a \"token list\
    \ data stream\".  See the section \"Token List Data\n   Stream\", section 11.3.\
    \ When the end of data is reached, the keyword\n   token EOF is sent.  Occasionally,\
    \ token lists are transmitted over\n   the data channels, such as asynchronous\
    \ error descriptions.\n"
- title: 5.  NFILE FILE OPENING MODES
  contents:
  - "5.  NFILE FILE OPENING MODES\n   The NFILE OPEN command opens a file for reading,\
    \ writing, or \"direct\n   access\" at the server host.  That means, in general,\
    \ asking the host\n   file system to access the file and obtaining a file number,\
    \ pointer,\n   or other quantity for subsequent rapid access to the file; this\
    \ is\n   called an \"opening\".  The term \"opening\" translates to a file stream\n\
    \   in Symbolics terminology, a JFN in TOPS-20 terminology, and a file\n   descriptor\
    \ in UNIX terminology.  An opening usually keeps track of\n   how many bytes have\
    \ been read or written, and other bookkeeping\n   information.\n   NFILE supports\
    \ two ways of transferring file data, \"data stream mode\"\n   and \"direct access\
    \ mode\".  A single mode is associated with each\n   opening.  Note that an NFILE\
    \ dialogue can have more than one opening,\n   and thus use both modes.\n   DATA\
    \ STREAM MODE:\n   Data stream mode of file transfer is the default mode of NFILE's\
    \ OPEN\n   command.  Data stream mode is appropriate when the entire file is\n\
    \   transferred, either from user to server, or from server to user.\n   Data\
    \ stream mode is used more often than direct access mode.\n   The OPEN command\
    \ includes a \"handle\" argument, which identifies the\n   data channel to be\
    \ used to transfer the data.  The handle is used in\n   subsequent commands to\
    \ reference this particular opening.  When a\n   data stream opening is requested\
    \ with the OPEN command, the file is\n   opened and the data begins to flow immediately.\n\
    \   The sending side transmits the entire contents of the specified file\n   over\
    \ the specified data channel as rapidly as the network permits.\n   When the sending\
    \ side reaches the end of the file, it transmits a\n   special control token to\
    \ signal end of file.  The receiving side\n   expects an uninterrupted stream\
    \ of bytes to appear immediately on its\n   side of the data channel.\n   The\
    \ user gives the CLOSE command to terminate a data stream transfer.\n   CLOSE\
    \ results in closing the file.\n   DIRECT ACCESS MODE:\n   Direct access mode\
    \ enables reading or writing data from a given\n   starting point in a file through\
    \ a specified number of bytes.  In\n   direct access mode, data is requested and\
    \ sent in individual\n   transactions.  To request a direct access mode opening,\
    \ the OPEN\n   command is used with a DIRECT-FILE-ID argument.  (In data stream\n\
    \   mode, no DIRECT-FILE-ID is supplied.)  The direct file identifier is\n   used\
    \ in subsequent commands to reference the direct access opening.\n   When a file\
    \ is opened in direct access mode, the flow of data does\n   not start immediately.\
    \  Rather, the user gives either a READ command\n   (to request data to flow from\
    \ server to user) or a DIRECT-OUTPUT\n   command (to request data to flow from\
    \ user to server).  When reading,\n   the READ command allows the user to specify\
    \ the starting point and\n   the number of bytes of data to transfer.  When writing,\
    \ the FILEPOS\n   command can be used to specify the starting point, before the\n\
    \   DIRECT-OUTPUT command is given.  The user can give many READ and\n   DIRECT-OUTPUT\
    \ commands, one after another.\n   The user side terminates the direct access\
    \ transfer by using the\n   CLOSE command.  The ABORT command can be given to\
    \ terminate without\n   transmitting all of the specified bytes.\n"
- title: 6.  NFILE CHARACTER SET
  contents:
  - "6.  NFILE CHARACTER SET\n   The NFILE character set <1> is an extension of standard\
    \ ASCII.  NFILE\n   command and response names use only the standard ASCII characters.\n\
    \   However, the protocol supports the transfer of the non-ASCII\n   characters\
    \ in the NFILE character set; these characters might be\n   stored in files, or\
    \ might be used in pathnames.\n   Servers on machines that do not natively use\
    \ the NFILE character set\n   must perform character set translations for character\
    \ openings,\n   depending on the requested translation mode.  No translation is\n\
    \   required for binary openings.  There are three translation modes for\n   character\
    \ openings:  NORMAL, RAW, and SUPER-IMAGE.  Each mode\n   specifies a way to translate\
    \ between the server's native set and the\n   NFILE character set.\n   NORMAL\
    \ mode is the default of the OPEN command.  The translation for\n   NORMAL mode\
    \ ensures that a file containing characters in the NFILE\n   character set can\
    \ be written to a remote host and read back intact.\n   OPEN has optional keyword\
    \ arguments to specify RAW or SUPER-IMAGE.\n   RAW mode means to perform no translation\
    \ whatsoever.  SUPER-IMAGE\n   mode is intended for use by PDP-10 family machines\
    \ only.  It is\n   included largely as an illustration of a system-dependent extension.\n\
    \   The details of each translation mode are given in Appendices:\n         See\
    \ the section \"NORMAL Translation Mode\", Appendix A.  See the\n         section\
    \ \"RAW Translation Mode\", Appendix B.  See the section\n         \"SUPER-IMAGE\
    \ Translation Mode\", Appendix C.\n   The use of the NFILE character set brings\
    \ up a difficulty involved\n   with determining an exact position within a character\
    \ file.  Some\n   NFILE characters expand to more than one native character on\
    \ some\n   servers.  Thus, for character files, when we speak of a given\n   position\
    \ in a file or the length of a file, we must specify whether\n   we are speaking\
    \ in \"NFILE units\" or \"server units\", because the\n   counting of characters\
    \ is different.  This causes major problems in\n   file position reckoning for\
    \ character files.  Specifically, it is\n   futile for a user side to carefully\
    \ monitor file position during\n   output by counting characters, when character\
    \ translation is in\n   effect.  The server's operating system interface for \"\
    position to\n   point x in a file\" necessarily operates in server units, but\
    \ the user\n   side has counted in NFILE units.  The user side cannot try to\n\
    \   second-guess the translation-counting process without losing host-\n   independence.\
    \  See the section \"FILEPOS NFILE Command\".\n"
- title: 7.  CONVENTIONS USED IN THIS DOCUMENT
  contents:
  - '7.  CONVENTIONS USED IN THIS DOCUMENT

    '
- title: 7.1  Mapping Data Types Into Token List Representation
  contents:
  - "7.1  Mapping Data Types Into Token List Representation\n   Throughout this NFILE\
    \ specification, the data types of arguments,\n   return values, asynchronous\
    \ error descriptions, and notifications are\n   described as being strings, integers,\
    \ dates, time intervals, and so\n   on.  However, each conceptual data type must\
    \ be mapped into the\n   appropriate token list representation for transmission.\
    \  The mapping\n   of conceptual data types to token list representation is shown\
    \ here:\n    Conceptual Type     Token List Representation\n    ----------------------------------------------------------------\n\
    \    Keyword             A keyword token\n    Keyword list        A token list\
    \ of keyword tokens\n    Integer             A numeric data token\n    String\
    \              A data token containing the characters of the\n               \
    \         string in the NFILE character set.\n    Boolean Truth       The token\
    \ known as BOOLEAN-TRUTH.\n    Boolean False       The empty token list.\n   \
    \ Date                A numeric data token.  The date is expressed in\n      \
    \                  Universal Time format, which measures a time as\n         \
    \               the number of seconds since January 1, 1900, at\n            \
    \            midnight GMT.\n    Date-or-never       Can be either a date or the\
    \ empty token list,\n                        representing \"never\".  \"Never\"\
    \ is used for\n                        values such as the time a directory was\
    \ last\n                        expunged, if it has never been expunged.\n   \
    \ Time interval       A numeric data token.  The time interval is\n          \
    \              expressed in seconds.  A time interval\n                      \
    \  indicating \"never\" is represented by the empty\n                        token\
    \ list.\n"
- title: 7.2  Format of NFILE Commands and Responses
  contents:
  - "7.2  Format of NFILE Commands and Responses\n   Each command description begins\
    \ by giving the command format and\n   response format.  Here is the beginning\
    \ of the DATA-CONNECTION\n   command description:\n   Command:  (DATA-CONNECTION\
    \ tid new-input-handle new-output-handle)\n   Response: (DATA-CONNECTION tid connection-identifier)\n\
    \   The command descriptions follow these conventions:\n    1. NFILE commands\
    \ and responses are transmitted as top-level token\n       lists.\n       Top-level\
    \ token lists are enclosed in parentheses in these\n       command descriptions.\
    \  These parentheses are not sent literally\n       across the control or data\
    \ connections, but are a shorthand\n       representation of special control tokens\
    \ that delimit top-level\n       token lists.  Specifically, TOP-LEVEL-LIST-BEGIN\
    \ starts a top-\n       level token list; TOP-LEVEL-LIST-END ends a top-level\
    \ token list.\n    2. NFILE command names are keywords.\n       The command name\
    \ is required in every command and command\n       response.  All NFILE command\
    \ names are keywords.  Keywords appear\n       in the NFILE documentation as their\
    \ names in uppercase.  For\n       example, DATA-CONNECTION and DELETE are two\
    \ command names.\n    3. A unique transaction identifier (tid) identifies each\
    \ command.\n       The transaction identifier is a string made up by the user\
    \ side\n       to identify this particular transaction, which is composed of the\n\
    \       command and the response associated with this command.  The\n       transaction\
    \ identifier is abbreviated in the command descriptions\n       as tid.  Transaction\
    \ identifiers are limited to fifteen\n       characters in length.  The transaction\
    \ identifier is required in\n       every command and command response.\n   OPTIONAL\
    \ ARGUMENTS\n   Many NFILE commands have \"optional arguments\".  Optional arguments\n\
    \   can be supplied (with appropriate values), or left out.  If optional\n   arguments\
    \ are left out, their omission must be made explicit by means\n   of substituting\
    \ the empty token list in their place.  The only\n   exception to that rule is\
    \ for trailing optional arguments or return\n   values, which can be omitted without\
    \ including the empty token list.\n   For example, the text of the DELETE command\
    \ description explains that\n   either a handle or a pathname must be supplied,\
    \ but not both;\n   therefore, one of them is an optional argument.  Here is the\
    \ command\n   format of DELETE:\n         (DELETE tid handle pathname)\n    If\
    \ you supply a handle and no pathname, the command format is:\n         (DELETE\
    \ tid handle)\n    If you supply a pathname and no handle, the command format\
    \ is:\n         (DELETE tid empty-token-list pathname)\n   The empty token list\
    \ in the token list stream appears as a LIST-BEGIN\n   followed immediately by\
    \ a LIST-END.\n   OPTIONAL KEYWORD/VALUE PAIRS\n   Four NFILE commands have \"\
    optional keyword/value pairs\".  These\n   commands are: COMPLETE, LOGIN, OPEN,\
    \ and READ.  Optional\n   keyword/value pairs can be either included in the command\
    \ or omitted\n   entirely.  There is no need to substitute the empty token list\
    \ for\n   ommitted optional keyword tokens, unlike optional arguments.  The\n\
    \   order of the option keyword/value pairs is not significant.\n   If included,\
    \ optional keyword/value pairs are a sequence of\n   alternating keywords and\
    \ values.  The values associated with the\n   keywords can be keywords, lists,\
    \ strings, Booleans, integers, dates,\n   date-or-never's, and time intervals.\
    \  The text of each command\n   description states what type of value is appropriate\
    \ for each\n   optional keyword.\n   Optional keyword/value pairs appear in the\
    \ text as the keyword only,\n   in uppercase letters.  For example, here is the\
    \ format of the LOGIN\n   command:\n   Command Format:\n         (LOGIN tid user\
    \ password FILE-SYSTEM USER-VERSION)\n   FILE-SYSTEM and USER-VERSION are two\
    \ optional keywords associated\n   with the LOGIN command.  The user side can\
    \ supply USER-VERSION, and\n   omit FILE-SYSTEM as shown in this example:\n  \
    \       (LOGIN x105 tjones let-me-in USER-VERSION 2)\n   As seen above, the optional\
    \ keyword/value pair USER-VERSION, if\n   supplied in a command, consists of the\
    \ keyword USER-VERSION followed\n   by the value to be used for that keyword (in\
    \ this example, 2).\n"
- title: 7.3  Data Channel Handles and Direct File Identifiers
  contents:
  - "7.3  Data Channel Handles and Direct File Identifiers\n   Several NFILE commands\
    \ require an argument that specifies an opening.\n   This kind of argument is\
    \ called a handle in the command description.\n   It is always a string type argument.\
    \  A handle can be either a data\n   channel handle or a direct file identifier,\
    \ depending on the mode of\n   the opening:\n   Data Stream\n   The handle must\
    \ identify a data channel that is bound to an opening.\n   Direct Access\n   In\
    \ general, the handle must be a direct file identifier.  A direct\n   file identifier\
    \ specifies a direct access opening.  It is the same as\n   the value supplied\
    \ in the DIRECT-FILE-ID keyword/value pair in the\n   OPEN command.  It is used\
    \ for all operations that identify an opening\n   rather than a data channel.\n\
    \   Two NFILE commands applicable to direct access openings are\n   exceptions\
    \ to the general rule.  The handle supplied in ABORT and\n   CONTINUE cannot be\
    \ a direct file identifier, but must be a data\n   channel handle instead.\n"
- title: 7.4  Syntax of File and Directory Pathname Arguments
  contents:
  - "7.4  Syntax of File and Directory Pathname Arguments\n   Some arguments and return\
    \ values in the NFILE command descriptions\n   represent file pathnames.  These\
    \ are strings in the pathname syntax\n   native to the server host.  These pathnames\
    \ contain no host\n   identifiers of any kind.  These pathnames must be fully\
    \ defaulted, in\n   the sense that they have a directory and file name (and file\
    \ type, if\n   the server operating system supports file types).  If appropriate,\
    \ a\n   device is referenced in the pathname.  If the server file system\n   supports\
    \ version numbers, there is always an explicit version number,\n   even if that\
    \ number or other specification is that system's\n   representation of \"newest\"\
    \ or \"oldest\".\n   Here are some examples of file pathnames, for different server\
    \ hosts:\n   Server Host     Example of File Pathname\n   ------------------------------------------------------------\n\
    \      UNIX            /usr/max/life.c\n      TOPS-20         ps:<max>life.bin.17\n\
    \      VMS             MACD:[MAX]LIFE.FOR;3\n      Symbolics LMFS  >max>life.lisp.newest\n\
    \   ------------------------------------------------------------\n   The CREATE-DIRECTORY\
    \ and HOME-DIRECTORY commands take a directory as\n   an argument.  In NFILE commands,\
    \ a directory is represented by a\n   string that names the directory.  In most\
    \ cases this string is in the\n   syntax native to the server host.  However in\
    \ some cases the native\n   format is modified somewhat to clarify that the string\
    \ names a\n   directory, and not a file.  For example, a directory on UNIX is\n\
    \   represented by \"/usr/max/\", not \"/usr/max\".\n   Here are some examples\
    \ of directory pathnames for different server\n   hosts:\n   Server Host     Example\
    \ of Directory Pathname\n   ------------------------------------------------------------\n\
    \      UNIX            /usr/max/\n      TOPS-20         <max>\n      VMS     \
    \        MACD:[MAX]\n      Symbolics LMFS  >max>hacks>\n   ------------------------------------------------------------\n"
- title: 7.5  Format of NFILE File Property/Value Pairs
  contents:
  - "7.5  Format of NFILE File Property/Value Pairs\n   Several NFILE commands request\
    \ information regarding the properties\n   of files or directories.  These commands\
    \ include:  DIRECTORY,\n   MULTIPLE-FILE-PLISTS, PROPERTIES, and CHANGE-PROPERTIES.\
    \  This\n   section describes how file property information is conveyed over the\n\
    \   token list stream.\n   File property information is usually sent in property/value\
    \ pairs,\n   where the property identifies the property, and the following value\n\
    \   gives the value of that property for the specified file.\n   Each property\
    \ is denoted either by a keyword or an integer.  You can\n   mix both ways of\
    \ specifying properties (keyword or integer) within a\n   single description.\
    \  An integer is interpreted as an index into the\n   Property Index Table, an\
    \ array of property keywords.  The server can\n   optionally send a Property Index\
    \ Table to the user during the\n   execution of the LOGIN command, although it\
    \ is not required.  This\n   greatly reduces the length of transmissions.\n  \
    \ In command arguments, file properties cannot be specified with\n   integers;\
    \ keywords must be used to specify file properties in command\n   arguments. \
    \ Integers can be used to denote file properties only in\n   command responses.\n\
    \   We now list the keywords associated with file properties.  This list\n   is\
    \ not intended to be restrictive.  If a programmer implementing\n   NFILE needs\
    \ a new keyword, a new keyword (not on this list) can be\n   invented.  The type\
    \ of value of any new keywords is by default\n   string.  The keywords are sorted\
    \ here by conceptual data type:\n    Data type       Keywords denoting file properties\n\
    \   ----------------------------------------------------------------\n    Integers\
    \        BLOCK-SIZE, BYTE-SIZE, GENERATION-RETENTION-COUNT,\n                \
    \    LENGTH-IN-BLOCKS, LENGTH-IN-BYTES,\n                    DEFAULT-GENERATION-RETENTION-COUNT\n\
    \    Dates           CREATION-DATE, MODIFICATION-DATE\n    Date-or-never's REFERENCE-DATE,\
    \ INCREMENTAL-DUMP-DATE,\n                    COMPLETE-DUMP-DATE, DATE-LAST-EXPUNGED,\n\
    \                    EXPIRATION-DATE\n    Time intervals  AUTO-EXPUNGE-INTERVAL\n\
    \    Keyword Lists   SETTABLE-PROPERTIES, LINK-TRANSPARENCIES,\n             \
    \       DEFAULT-LINK-TRANSPARENCIES\n    Boolean values  DELETED, DONT-DELETE,\
    \ DONT-DUMP, DONT-REAP,\n                    SUPERSEDE-PROTECT, NOT-BACKED-UP,\
    \ OFFLINE,\n                    TEMPORARY, CHARACTERS, DIRECTORY\n    Strings\
    \         ACCOUNT, AUTHOR, LINK-TO, PHYSICAL-VOLUME,\n                    PROTECTION,\
    \ VOLUME-NAME, PACK-NUMBER, READER,\n                    DISK-SPACE-DESCRIPTION,\
    \ and any keywords not\n                    on this list\n   Note that these keyword\
    \ names are intended to imply the semantics of\n   the properties.  For a discussion\
    \ of the semantics of CREATION-DATE:\n   See the section \"NFILE OPEN Response\
    \ Return Values\", section 8.20.2.\n   The \"Reference Guide to Streams, Files,\
    \ and I/O\" in the Symbolics\n   documentation set details the semantics that\
    \ Symbolics associates\n   with these properties.\n"
- title: 8.  NFILE COMMANDS
  contents:
  - "8.  NFILE COMMANDS\n   It is important to understand the conventions used in\
    \ each of the\n   following command descriptions.  See the section \"Conventions\
    \ Used in\n   This Document\", section 7.\n"
- title: 8.1  ABORT Command
  contents:
  - "8.1  ABORT Command\n   Command:  (ABORT tid input-handle)\n   Response: (ABORT\
    \ tid)\n   ABORT cleanly interrupts and prematurely terminates a single direct\n\
    \   access mode data transfer initiated with READ.  The required input-\n   handle\
    \ string argument identifies a data channel on which an input\n   transfer is\
    \ currently taking place; this must be a direct access\n   transfer.  input-handle\
    \ must identify a data channel; it cannot be a\n   direct file identifier.\n \
    \  Upon receiving the ABORT command, the server checks to see if a\n   transfer\
    \ is still active on that channel.  If so, the server\n   terminates the transfer\
    \ by telling the data connection logical\n   process to stop transferring bytes\
    \ of data.  The user side needs to\n   issue this command only when there are\
    \ outstanding unread bytes.\n   This excludes the case of the data channel having\
    \ been disestablished\n   or reallocated by the user side.\n   Whether or not\
    \ a transfer is active on that channel, the user side\n   puts the data channel\
    \ into the unsafe state.  Before the data channel\n   can be used again, it must\
    \ be resynchronized.\n"
- title: 8.2  CHANGE-PROPERTIES Command
  contents:
  - "8.2  CHANGE-PROPERTIES Command\n   Command:  (CHANGE-PROPERTIES tid handle pathname\
    \ property-pairs)\n   Response: (CHANGE-PROPERTIES tid)\n   CHANGE-PROPERTIES\
    \ changes one or more properties of a file.  Either a\n   handle or a pathname\
    \ must be given, but not both.  Whichever one is\n   given must be supplied as\
    \ a string.  handle identifies a data channel\n   that is bound to an open file;\
    \ it can be a direct file identifier.\n   pathname identifies a file on the server\
    \ machine.\n   property-pairs is a required token list of keyword/value pairs,\
    \ where\n   the name of the property to be changed is the keyword, and the\n \
    \  desired new property value is the value.\n   The properties that can be changed\
    \ are host-dependent, as are any\n   restrictions on the values of those properties.\
    \  The properties that\n   can be changed are the same as those returned as settable-properties,\n\
    \   in the command response for the PROPERTIES command.\n   The server tries to\
    \ modify all the properties listed in property-\n   pairs to the desired new values.\
    \  There is currently no definition\n   about what should be done if the server\
    \ can successfully change some\n   properties but not others.\n   For further\
    \ information on file property keywords and associated\n   values:  See the section\
    \ \"Format of NFILE File Property/Value Pairs\",\n   section 7.5.\n"
- title: 8.3  CLOSE Command
  contents:
  - "8.3  CLOSE Command\n   Command:  (CLOSE tid handle abort-p)\n   Response: (CLOSE\
    \ tid truename binary-p other-properties)\n   CLOSE terminates a data transfer,\
    \ and frees a data channel.  The\n   handle must be a data channel handle for\
    \ a data stream opening, or a\n   direct file identifier for a direct access opening.\
    \  If a data\n   channel is given, a transfer must be active on that handle. \
    \ If\n   abort-p is supplied as Boolean truth, the file is close-aborted, as\n\
    \   described below.\n   \"Closing the file\" has different implications specific\
    \ to each\n   operating system.  It generally implies invalidation of the pointer\n\
    \   or logical identifier obtained from the operating system when the\n   file\
    \ was \"opened\", and freeing of operating system and/or job\n   resources associated\
    \ with active file access.  For output files, it\n   involves ensuring that every\
    \ last bit sent by the user has been\n   successfully written to disk.  The server\
    \ should not send a\n   successful response until all these things have completed\n\
    \   successfully.\n   In either data stream or direct access mode, the user can\
    \ request the\n   server to close-abort the file, instead of simply closing it.\
    \  To\n   close-abort a file means to close it in such a way, if possible, that\n\
    \   it is as if the file had never been opened.  In the specific case of\n   a\
    \ file being created, it must appear as if the file had never been\n   created.\
    \  This might be more difficult to implement on certain\n   operating systems\
    \ than others, but tricks with temporary names and\n   close-time renamings by\
    \ the server can usually be used to implement\n   close-abort in these cases.\
    \  In the case of a file being appended to,\n   close-abort means to forget the\
    \ appended data.\n   AN UNSUCCESSFUL CLOSE OPERATION\n   For the normal CLOSE\
    \ operation (not a close-abort), after writing\n   every last bit sent by the\
    \ user to disk, and before closing the file,\n   the server checks the data channel\
    \ specified by handle to see if an\n   asynchronous error is outstanding on that\
    \ channel.  That is, the\n   server must determine whether it has sent an asynchronous\
    \ error\n   description to the user, to which the user has not yet responded with\n\
    \   a CONTINUE command.  If so, the server is unable to close the file,\n   and\
    \ therefore sends a command error response indicating that an error\n   is pending\
    \ on the channel.  The appropriate three-letter error code\n   is EPC.  See the\
    \ section \"NFILE Errors and Notifications\", section\n   10.\n   A SUCCESSFUL\
    \ CLOSE OPERATION\n   The return values for OPEN and CLOSE are syntactically identical,\
    \ but\n   the values might change between the time of the file being opened and\n\
    \   when it is closed.  For example, the truename return value is\n   supplied\
    \ after all the close-time renaming of output files is done\n   and the version\
    \ numbers resolved (for operating systems supporting\n   version numbers).  Therefore,\
    \ on some systems the truename of a file\n   has one value at the time it is opened,\
    \ and a different value when it\n   has been closed.  For a description of the\
    \ CLOSE return values:  See\n   the section \"NFILE OPEN Response Return Values\"\
    , section 8.20.2.\n   If the user gives the CLOSE command with abort-p supplied\
    \ as Boolean\n   truth, thus requesting a close-abort of the file, the server\
    \ need not\n   check whether an asynchronous error description is outstanding\
    \ on the\n   channel.  The server simply close-aborts the file.\n"
- title: 8.4  COMPLETE Command
  contents:
  - "8.4  COMPLETE Command\n   Command:  (COMPLETE tid string pathname DIRECTION NEW-OK\
    \ DELETED)\n   Response: (COMPLETE tid new-string success)\n   COMPLETE performs\
    \ file pathname completion.\n   string is a partial filename typed by the user\
    \ and pathname is the\n   default name against which it is being typed.  Both\
    \ string and\n   pathname are required arguments, and are of type string.  The\n\
    \   remaining arguments are optional keyword/value pairs.\n   NEW-OK is Boolean;\
    \ if followed by Boolean truth, the server should\n   allow either a file that\
    \ already exists, or a file that does not yet\n   exist.  The default of NEW-OK\
    \ is false; that is, the server does not\n   consider files that do not already\
    \ exist.\n   DELETED is a Boolean type argument; if followed by Boolean truth,\
    \ the\n   server is instructed to look for files that have been deleted but not\n\
    \   yet expunged, as well as non-deleted files.  The default is to ignore\n  \
    \ soft-deleted files.\n   DIRECTION can be followed by READ, to indicate that\
    \ the file is to be\n   read.  If the file is to be written, DIRECTION can be\
    \ followed by\n   WRITE.  The default is READ.\n   The filename is completed according\
    \ to the files present in the host\n   file system, and the expanded string new-string\
    \ is returned. New-\n   string is always a string containing a file name:  either\
    \ the\n   original string, or a new, more specific string.  The value of\n   success\
    \ indicates the status of the completion. The keyword value OLD\n   or NEW means\
    \ complete success, whereas the empty token list means\n   failure.  The following\
    \ values of success are possible:\n   Value               Meaning\n   ----------------------------------------------------------------\n\
    \   OLD                 Success:  the string completed to the name of\n      \
    \                 a file that exists.\n   NEW                 Success:  the string\
    \ completed to the name of\n                       a file that could be created.\n\
    \   Empty token list    Failure due to one of these reasons:\n               \
    \        The file is on a file system that does not\n                       support\
    \ completion.  new-string is supplied as\n                       the unchanged\
    \ string.\n                       There is no possible completion.  new-string\n\
    \                       is supplied as the unchanged string.\n               \
    \        There is more than one possible completion.\n                       The\
    \ given string is completed up to the first\n                       point of ambiguity,\
    \ and the result is supplied\n                       as new-string.\n        \
    \               A directory name was completed.  Completion\n                \
    \       was not successful because additional\n                       components\
    \ to the right of this directory\n                       remain to be specified.\
    \  The string is\n                       completed through the directory name\
    \ and the\n                       delimiter that follows it, and the result is\n\
    \                       returned in new-string.\n   The semantics of COMPLETE\
    \ are not documented here.  See the\n   \"Reference Guide to Streams, Files, and\
    \ I/O\" in the Symbolics\n   documentation set for the recommended semantics of\
    \ COMPLETE.\n"
- title: 8.5  CONTINUE Command
  contents:
  - "8.5  CONTINUE Command\n   Command:  (CONTINUE tid handle)\n   Response: (CONTINUE\
    \ tid)\n   CONTINUE resumes a data transfer that was temporarily suspended due\n\
    \   to an asynchronous error.  Each asynchronous error description has an\n  \
    \ optional argument of RESTARTABLE, indicating whether it makes any\n   sense\
    \ to try to continue after this particular error occurred.\n   CONTINUE tries\
    \ to resume the data transfer if the error is\n   potentially recoverable, according\
    \ to the RESTARTABLE argument in the\n   asynchronous error description.  For\
    \ a discussion of asynchronous\n   errors:  See the section \"NFILE Errors and\
    \ Notifications\", section\n   10.\n   handle is a required string-type argument\
    \ that refers to the handle\n   of the data channel that received an asynchronous\
    \ error.  That data\n   channel could have been in use for a data stream or direct\
    \ access\n   transfer.  handle cannot be a direct file identifier.\n   If the\
    \ asynchronous error description does not contain the\n   RESTARTABLE argument,\
    \ and the user issues the CONTINUE command\n   anyway, the server gives a command\
    \ error response.\n"
- title: 8.6  CREATE-DIRECTORY Command
  contents:
  - "8.6  CREATE-DIRECTORY Command\n   Command:  (CREATE-DIRECTORY tid pathname property-pairs)\n\
    \   Response: (CREATE-DIRECTORY tid dir-truename)\n   CREATE-DIRECTORY creates\
    \ a directory on the remote file system.  The\n   required pathname argument is\
    \ a string identifying the pathname of\n   the directory to be created.  The return\
    \ value dir-truename is the\n   pathname of the directory that was successfully\
    \ created.  Both of\n   these pathnames are directory pathnames:  See the section\
    \ \"Syntax of\n   File and Directory Pathname Arguments\", section 7.4.\n   property-pairs\
    \ is a keyword/value list of properties that further\n   define the attributes\
    \ of the directory to be created.  The allowable\n   keywords and associated values\
    \ are operating system dependent;\n   typically they indicate arguments to be\
    \ given to the native primitive\n   for creating directories.\n   If property-pairs\
    \ is supplied as the empty token list, default access\n   and creation attributes\
    \ apply and should be assured by the server.\n   See the section \"Format of NFILE\
    \ File Property/Value Pairs\", section\n   7.5.\n"
- title: 8.7  CREATE-LINK Command
  contents:
  - "8.7  CREATE-LINK Command\n   Command:  (CREATE-LINK tid pathname target-pathname\
    \ properties)\n   Response: (CREATE-LINK tid link-truename)\n   CREATE-LINK creates\
    \ a link on the remote file system.\n   pathname is the pathname of the link to\
    \ be created; target-pathname\n   is the place in the file system to which the\
    \ link points.  Both are\n   required arguments.  The return value link-truename\
    \ names the\n   resulting link.\n   If a server on a file system that does not\
    \ support links receives the\n   CREATE-LINK command, it sends a command error\
    \ response.\n   The arguments pathname and target-pathname, and the return value\n\
    \   link-truename, are all strings in the full pathname syntax of the\n   server\
    \ host.  See the section \"Syntax of File and Directory Pathname\n   Arguments\"\
    , section 7.4.\n   The required properties argument is a token list of keyword/value\n\
    \   pairs. These properties and their values specify certain attributes\n   to\
    \ be given to the link.  The allowable keywords and associated\n   values are\
    \ operating system dependent; typically they indicate\n   arguments to be given\
    \ to the native primitive for creating links.\n   If no property pairs are given\
    \ in the command, the server should\n   apply a reasonable default set of attributes\
    \ to the link.  See the\n   section \"Format of NFILE File Property/Value Pairs\"\
    , section 7.5.\n"
- title: 8.8  DATA-CONNECTION Command
  contents:
  - "8.8  DATA-CONNECTION Command\n   Command:  (DATA-CONNECTION tid new-input-handle\
    \ new-output-handle)\n   Response: (DATA-CONNECTION tid connection-identifier)\n\
    \   DATA-CONNECTION enablesthe user side to initiate the establishment of\n  \
    \ a new data connection.  The user side supplies two required string\n   arguments,\
    \ new-input-handle and  new-output-handle.  These arguments\n   are used by subsequent\
    \ commands to reference the two data channels\n   that constitute the data connection\
    \ now being created.  new-input-\n   handle describes the server-to-user data\
    \ channel, and new-output-\n   handle describes the user-to-server channel.  new-input-handle\
    \ and\n   new-output-handle cannot refer to any data channels already in use.\n\
    \   Upon receiving the DATA-CONNECTION command, the server arranges for a\n  \
    \ logical port (called socket or contact name on some networks) to be\n   made\
    \ available on the foreign host machine.  When the server has made\n   that port\
    \ available, it must inform the user of its identity.  The\n   server relays that\
    \ information in the command response, in the\n   required connection-identifier,\
    \ a string.  The server then listens on\n   the port named by connection-identifier,\
    \ and waits for the user side\n   to connect to it.\n   Upon receiving the success\
    \ command response, the user side supplies\n   the connection-identifier to the\
    \ local network implementation, in\n   order to connect to the specified port.\
    \  The data connection is not\n   fully established until the user side connects\
    \ successfully to that\n   port.  This command is unusual in that the successful\
    \ command\n   response does not signify the completion of the command; it indicates\n\
    \   only that the server has fulfilled its responsibility in the process\n   of\
    \ establishing a data connection.\n   The connection-identifier informs the user\
    \ of the correct identity of\n   the logical port that the server has provided.\
    \  NFILE expects the\n   connection-identifier to be a string.  For TCP this string\
    \ is the\n   port number represented in decimal.  For Chaosnet, this string is\
    \ the\n   contact name.  The connection-identifier is used only once; in all\n\
    \   subsequent NFILE commands that need to reference either of the data\n   channels\
    \ that constitute this data connection, the new-input-handle\n   and new-output-handle\
    \ are used.\n   For background information:  See the section \"NFILE Control and\
    \ Data\n   Connections\", section 4.\n"
- title: 8.9  DELETE Command
  contents:
  - "8.9  DELETE Command\n   Command:  (DELETE tid handle pathname)\n   Response:\
    \ (DELETE tid)\n   DELETE deletes a file on the remote file system.\n   Either\
    \ a handle or a pathname must be supplied, but not both.  If\n   given, the handle\
    \ must be a data channel handle for a data stream\n   opening, or a direct file\
    \ identifier for a direct access opening.\n   pathname is a string in the full\
    \ pathname syntax of the server host.\n   See the section \"Syntax of File and\
    \ Directory Pathname Arguments\",\n   section 7.4.\n   With a pathname supplied,\
    \ the DELETE command causes the specified\n   file to be deleted.  DELETE has\
    \ different results depending on the\n   operating system involved.  That is,\
    \ DELETE causes soft deletion on\n   TOPS-20 and LMFS, and hard deletion on UNIX\
    \ and Multics.  If an\n   attempt is made to delete a delete-through link on a\
    \ Symbolics LMFS,\n   its target is deleted instead.\n   If the handle argument\
    \ is supplied to DELETE, the server deletes the\n   open file bound to the data\
    \ channel specified by handle at close\n   time.  This is true in both the output\
    \ and input cases.\n"
- title: 8.10  DIRECT-OUTPUT Command
  contents:
  - "8.10  DIRECT-OUTPUT Command\n   Command:  (DIRECT-OUTPUT tid direct-handle output-handle)\n\
    \   Response: (DIRECT-OUTPUT tid)\n   DIRECT-OUTPUT starts and stops output data\
    \ flow for a direct access\n   file opening.  DIRECT-OUTPUT explicitly controls\
    \ binding and\n   unbinding of an output data channel to a direct access opening.\n\
    \   direct-handle is a required argument, and output-handle is optional.\n   If\
    \ supplied, output-handle is a request to bind an output data\n   channel (indicated\
    \ by output-handle) to the direct access opening\n   designated by the direct-handle.\
    \  The specified output data channel\n   must be free.  The server binds the data\
    \ channel and begins accepting\n   data from that connection and writing it to\
    \ the opening.\n   If the output-handle is omitted, this is a request to unbind\
    \ the\n   channel and terminate the active output transfer.\n"
- title: 8.11  DIRECTORY Command
  contents:
  - "8.11  DIRECTORY Command\n   Command:  (DIRECTORY tid input-handle pathname control-keywords\n\
    \              properties)\n   Response: (DIRECTORY tid)\n   DIRECTORY returns\
    \ a directory listing including the identities and\n   attributes for logically\
    \ related groups of files, directories, and\n   links.  If the command is successful,\
    \ a single token list containing\n   the requested information is sent over the\
    \ data channel specified by\n   input-handle, and the data channel is then implicitly\
    \ freed by both\n   sides <2>.  For details on the format of the token list: \
    \ See the\n   section \"NFILE DIRECTORY Data Format\", section 8.11.1.\n   pathname\
    \ specifies the files that are to be described; it is a string\n   in the full\
    \ pathname syntax of the server host.  See the section\n   \"Syntax of File and\
    \ Directory Pathname Arguments\", section 7.4.\n   The pathname generally contains\
    \ wildcard characters, in operating-\n   system-specific format, describing potential\
    \ file name matches.  Most\n   operating systems provide a facility that accepts\
    \ such a pathname and\n   returns information about all files matching this pathname.\
    \  Some\n   operating systems allow wildcard (potential multiple) matches in the\n\
    \   directory or device portions of the pathname; other operating systems\n  \
    \ do not.  There is no clear contract at this time about what is\n   expected\
    \ of servers on systems that do not allow wildcard matches (or\n   some kinds\
    \ of wild card matches), when presented with a wildcard.\n   properties is a token\
    \ list of keywords that are the names of\n   properties.  If properties is omitted\
    \ or supplied as the empty token\n   list, the server sends along all properties.\
    \  If any properties are\n   supplied, the user is requesting the server to send\
    \ only those\n   properties.\n   control-keywords ARGUMENT TO DIRECTORY\n   control-keywords\
    \ is a token list of keywords.  The control-keywords\n   affect the way the DIRECTORY\
    \ command works on the server machine.\n   Although some of the options below\
    \ request the server to limit (by\n   some filter) the data to be returned, it\
    \ is never an error if the\n   server returns more information than is requested.\n\
    \   The following keywords are recognized:\n   DELETED\n   Includes soft-deleted\
    \ files in the directory list.  Without this\n   option, they must not be included.\
    \ Such files have the DELETED\n   property indicated as true\" among their properties.\
    \  DELETED is\n   ignored on systems that do not support soft deletion.\n   DIRECTORIES-ONLY\n\
    \   This option changes the semantics of DIRECTORY fairly drastically.\n   Normally,\
    \ the server returns information about all files,\n   directories, and links whose\
    \ pathnames match the supplied pathname.\n   This means that for each file, directory,\
    \ or link to be listed, its\n   directory name must match the potentially wildcarded)\
    \ directory name\n   in the supplied pathname, its file name must match the file\
    \ name in\n   the supplied pathname, and so on.\n   When DIRECTORIES-ONLY is supplied,\
    \ the server is to list only\n   directories, not whose pathnames match the supplied\
    \ pathname, but\n   whose pathnames expressed as directory pathnames match the\n\
    \   (potentially wildcarded) directory portion of the supplied pathname.\n   The\
    \ description of the PROBE-DIRECTORY keyword that can be supplied\n   as the direction\
    \ argument of the OPEN command discusses this:  See\n   the section \"OPEN Command\"\
    , section 8.20.\n   It is not yet established what servers on hosts that do not\
    \ support\n   this type of action natively are to do when presented with\n   DIRECTORIES-ONLY\
    \ and a pathname with a wildcard directory component.\n   FAST Speeds up the operation\
    \ and data transmission by not listing any\n   properties at all for the files\
    \ concerned; that is, only the\n   truenames are returned.\n   NO-EXTRA-INFO\n\
    \   Specifies that the server is to suppress listing those properties\n   that\
    \ are generally more difficult or expensive to obtain.  This\n   typically eliminates\
    \ listing of directory-specific properties such as\n   information about default\
    \ generation counts and expunge dates.\n   SORTED\n   This causes the directory\
    \ listing to be sorted.  The sorting is done\n   alphabetically by directory,\
    \ then by file name, then file type, then\n   file version (by increasing version\
    \ number).\n"
- title: 8.11.1  NFILE DIRECTORY Data Format
  contents:
  - "8.11.1  NFILE DIRECTORY Data Format\n   If the NFILE DIRECTORY command completes\
    \ successfully, a single token\n   list containing the requested directory information\
    \ is sent on the\n   data channel specified by the input-handle argument in the\
    \ DIRECTORY\n   command.  This section describes the format of that single token\n\
    \   list, and gives further detail on the properties argument to\n   DIRECTORY.\n\
    \   The token list is a top-level token list, so it is delimited by TOP-\n   LEVEL-LIST-BEGIN\
    \ and TOP-LEVEL-LIST-END.  The top-level token list\n   contains embedded token\
    \ lists.  The first embedded token list\n   contains the empty token list followed\
    \ by property/value pairs\n   describing property information of the file system\
    \ as a whole rather\n   than of a specific file.  NFILE requires one property\
    \ of the file\n   system to be present: DISK-SPACE-DESCRIPTION is a string describing\n\
    \   the amount of free file space available on the system.  The following\n  \
    \ embedded token lists contain the pathname of a file, followed by\n   property/value\
    \ pairs describing the properties of that file.\n   The following example shows\
    \ the format of the top-level token list\n   returned by DIRECTORY, for two files.\
    \  It is expected that the server\n   return several property/value pairs for\
    \ each file; the number of\n   pairs returned is not constrained.  In this example,\
    \ two\n   property/value pairs are returned for the file system, two pairs are\n\
    \   returned for the first file, and only one pair is returned for the\n   second\
    \ file.\n             TOP-LEVEL-LIST-BEGIN\n             LIST-BEGIN       - first\
    \ embedded token list starts\n             LIST-BEGIN       - an empty embedded\
    \ token list starts\n             LIST-END         - the empty embedded token\
    \ list ends\n             prop1 value1     - property/value pairs of file system\n\
    \             prop2 value2\n             LIST-END\n             LIST-BEGIN\n \
    \            pathname1        - pathname of the first file\n             prop1\
    \ value1     - property/value pairs of first file\n             prop2 value2\n\
    \             LIST-END\n             LIST-BEGIN\n             pathname2      \
    \  - pathname of the second file\n             prop1 value1     - property/value\
    \ pairs of second file\n             LIST-END\n             TOP-LEVEL-LIST-END\n\
    \   The following example is designed to illustrate the structure of the\n   top-level\
    \ token list by depicting TOP-LEVEL-LIST-BEGIN and TOP-\n   LEVEL-LIST-END by\
    \ parentheses and LIST-BEGIN and LIST-END by squarbe\n   rackets.  respectively.\
    \ The indentation, blank spaces, and newlines\n   in the example are not part\
    \ of the token list, but are used here to\n   make the structure of the token\
    \ list clear.\n                   ([   [ ]    prop1 value1 prop2 value2]\n   \
    \                 [pathname1 prop1 value1 prop2 value2]\n                    [pathname2\
    \ prop1 value1])\n   The pathname is a string in the full pathname syntax of the\
    \ server\n   host.  See the section \"Syntax of File and Directory Pathname\n\
    \   Arguments\", section 7.4.\n   For further information on file property/value\
    \ pairs:  See the\n   section \"Format of NFILE File Property/Value Pairs\", section\
    \ 7.5.\n"
- title: 8.12  DISABLE-CAPABILITIES Command
  contents:
  - "8.12  DISABLE-CAPABILITIES Command\n   Command:  (DISABLE-CAPABILITIES tid capability)\n\
    \   Response: (DISABLE-CAPABILITIES tid cap-1 success-1\n                  cap-2\
    \ success-2 cap-3 success-3 ...)\n   DISABLE-CAPABILITIES causes an access capability\
    \ to be disabled on\n   the server machine.  capability is a string naming the\
    \ capability to\n   be disabled.  The meaning of the capability is dependent on\
    \ the\n   operating system.\n   The return values cap-1, cap-2, and so on, are\
    \ strings specifying\n   names of capabilities.  If the capability named by cap-1\
    \ was\n   successfully disabled, the corresponding success-1 is supplied as\n\
    \   Boolean truth; otherwise it is the empty token list.\n   Although the user\
    \ can specify only one capability to disable, it is\n   conceivable that the result\
    \ of disabling that particular capability\n   is the disabling of other, related\
    \ capabilities.  That is why the\n   command response can contain information\
    \ on more than one capability.\n"
- title: 8.13  ENABLE-CAPABILITIES Command
  contents:
  - "8.13  ENABLE-CAPABILITIES Command\n   Command:  (ENABLE-CAPABILITIES tid capability\
    \ password)}\n   Response: (ENABLE-CAPABILITIES tid cap-1 success-1\n        \
    \      cap-2 success-2 cap-3 success-3 ...)\n   ENABLE-CAPABILITIES causes an\
    \ access capability to be enabled on the\n   server machine.  The password argument\
    \ is optional, and should be\n   included only if it is needed to enable this\
    \ particular capability.\n   Both password and capability are strings.  The meaning\
    \ of the\n   capability is dependent on the operating system.\n   The return values\
    \ cap-1, cap-2 and so on, are strings specifying\n   names of capabilities.  If\
    \ the capability named by cap-1 was\n   successfully enabled, the corresponding\
    \ success-1 is supplied as\n   Boolean truth; otherwise it is the empty token\
    \ list.\n   Although the user can specify only one capability to enable, it is\n\
    \   conceivable that the result of enabling that particular capability is\n  \
    \ the enabling of other, related capabilities.  That is why the command\n   response\
    \ can contain information on more than one capability.\n"
- title: 8.14  EXPUNGE Command
  contents:
  - "8.14  EXPUNGE Command\n   Command:  (EXPUNGE tid directory-pathname)\n   Response:\
    \ (EXPUNGE tid server-storage-units-freed)\n   EXPUNGE causes the directory specified\
    \ by pathname to be expunged.\n   Expunging means that any files that have been\
    \ soft deleted are to be\n   permanently removed.\n   For file systems that do\
    \ not support soft deletion, the command is to\n   be ignored; a success command\
    \ response is sent, but no action is\n   performed on the file system.  In this\
    \ case, the number-of-server-\n   storage-units-freed return value should be omitted.\n\
    \   directory-pathname is a required string argument in the directory\n   pathname\
    \ format; it must refer to a directory on the server file\n   system, and not\
    \ to a file.  See the section \"Syntax of File and\n   Directory Pathname Arguments\"\
    , section 7.4.\n   The return value server-storage-units-freed is an integer specifying\n\
    \   how many records, blocks, or whatever unit is used to measure file\n   storage\
    \ on the server host system, were recovered.  This return value\n   should be\
    \ omitted if the server does not know how many storage units\n   were freed.\n\
    \   The protocol does not define whether directory-pathname is really a\n   pathname\
    \ as directory or a wildcard pathname of files to be expunged.\n   The protocol\
    \ does not define whether or not wildcards are permitted,\n   or required to be\
    \ supported, in the directory portion of the pathname\n   (representing an implicit\
    \ request to expunge many directories).\n"
- title: 8.15  FILEPOS Command
  contents:
  - "8.15  FILEPOS Command\n   Command:  (FILEPOS tid handle position resync-uid)\n\
    \   Response: (FILEPOS tid)\n   FILEPOS sets the file access pointer to a given\
    \ position, relative to\n   the beginning of the file.  FILEPOS is used to indicate\
    \ the position\n   of the next byte of data to be transferred.\n   The handle\
    \ indicates the file to be affected.  handle must be a data\n   channel handle\
    \ for a data stream opening, or a direct file identifier\n   for a direct access\
    \ opening.  Both handle and position are required\n   arguments.\n   position\
    \ is an integer indicating to which point in the file the file\n   access pointer\
    \ is to be reset.  position is either a byte number\n   according to the current\
    \ byte size being used, or characters for\n   character openings.  Position zero\
    \ is the beginning of the file.  If\n   this is a character opening, position\
    \ is measured in server units,\n   not in NFILE character set units.\n   If the\
    \ FILEPOS command is given on an input data channel (that is, a\n   data channel\
    \ currently sending data from server to user), the\n   affected data channel must\
    \ be resynchronized after the FILEPOS is\n   accomplished, in order to identify\
    \ the start of the new data.  The\n   resync-uid is a unique identifier associated\
    \ with the\n   resynchronization of the data channel; it is unique with respect\
    \ to\n   this dialogue.  resync-uid must be supplied if handle is an input\n \
    \  handle, but it is not supplied otherwise.  For more information on\n   the\
    \ resynchronization procedure:  See the section \"NFILE Data\n   Connection Resynchronization\"\
    , section 9.2.\n   In the output case, the user must somehow indicate to the server,\
    \ on\n   the output data channel, when there is no more data.  The user side\n\
    \   sends the keyword token EOF to do so.  Upon receiving that control\n   token,\
    \ the server is required to position the file pointer according\n   to the position\
    \ given.  When the new file position is established,\n   the server resumes accepting\
    \ data at the new file position.\n   In most cases, using the direct access mode\
    \ of transfer is more\n   convenient and efficient than repeated use of FILEPOS\
    \ with a data\n   stream opening.\n   There are problems inherent in trying to\
    \ set a file position of a\n   character-oriented file on a foreign host, if one\
    \ machine is a\n   Symbolics computer and the other is not.  For example, character\
    \ set\n   translation must take place.  See the section \"NFILE Character Set\"\
    ,\n   section 6.  Because of these difficulties, FILEPOS might not be\n   supported\
    \ in the future on character files.  FILEPOS is not\n   problematic for binary\
    \ files.\n"
- title: 8.15.1  Implementation Hint for FILEPOS Command
  contents:
  - "8.15.1  Implementation Hint for FILEPOS Command\n   The server processing of\
    \ this command (by the control connection\n   handler) must not attempt to wait\
    \ for the resynchronization procedure\n   to complete.  It is possible that the\
    \ user could abort between\n   sending the FILEPOS command and reading for the\
    \ mark and\n   resynchronization identifier.  That scenario could leave the sender\n\
    \   of the resynchronization identifier, on the server side, blocked for\n   output\
    \ indefinitely.\n   Only two commands received on the control connection can break\
    \ the\n   data channel out of the blocked state described above:  CLOSE with\n\
    \   abort-p supplied as Boolean truth, and RESYNCHRONIZE-DATA-CHANNEL.\n   Therefore,\
    \ the control connection must not wait for the data channel\n   to finish performing\
    \ the resynchronization procedure.  This wait\n   should instead be performed\
    \ by the process managing the data channel.\n"
- title: 8.16  FINISH Command
  contents:
  - "8.16  FINISH Command\n   Command:  (FINISH tid handle)\n   Response: (FINISH\
    \ tid truename binary-p other-properties)\n   FINISH closes a file and reopens\
    \ it immediately with the file\n   position pointer saved, thus leaving it open\
    \ for further I/O.  If\n   possible, the implementation should do the closing\
    \ and opening in an\n   indivisible operation, such that no other process can\
    \ get access to\n   the file.\n   The arguments, results, and their meaning are\
    \ identical to those of\n   the CLOSE command.  See the section \"CLOSE Command\"\
    , section 8.3.\n   FINISH requires a handle, which has the same meaning as the\
    \ handle of\n   the CLOSE command.\n   In the output case, for both direct mode\
    \ and data stream mode of\n   openings, the server writes out all buffers and\
    \ sets the byte count\n   of the file.  The user sends the keyword token EOF on\
    \ the data\n   channel, to indicate that the end of data has been reached.  The\n\
    \   server leaves the file in such a state that if the system or server\n   crashes\
    \ anytime after the FINISH command has completed, it would\n   later appear as\
    \ though the file had been closed by this command.\n   However, the file is not\
    \ left in a closed state now; it is left open\n   for further I/O operations.\
    \  FINISH is a reliability feature.\n   FINISH is somewhat pointless in the input\
    \ case, but valid.  The\n   native Symbolics file system (LMFS) implements FINISH\
    \ on an output\n   file by an internal operation that effectively goes through\
    \ the work\n   of closing but leaves the file open for appending.\n   ERRORS ON\
    \ FINISH\n   After writing every last bit sent by the user to disk, and before\n\
    \   closing the file, the server checks the data channel specified by\n   handle\
    \ to see if an asynchronous error is outstanding on that\n   channel.  That is,\
    \ the server must determine whether it has sent an\n   asynchronous error to the\
    \ user, to which the user has not yet\n   responded with a CONTINUE command. \
    \ If so, the server is unable to\n   finish the file, and it must send a command\
    \ error response response,\n   indicating that an error is pending on the channel.\
    \  The appropriate\n   three-letter error code is EPC.  See the section \"NFILE\
    \ Errors and\n   Notifications\", section 10.\n"
- title: 8.17  HOME-DIRECTORY Command
  contents:
  - "8.17  HOME-DIRECTORY Command\n   Command:  (HOME-DIRECTORY tid user)\n   Response:\
    \ (HOME-DIRECTORY tid directory-pathname)\n   HOME-DIRECTORY returns the full\
    \ pathname of the home directory on the\n   server machine for the given user.\n\
    \   user is a string that should be recognizable as a user's login name\n   on\
    \ the server operating system.  directory-pathname is a string in\n   the directory\
    \ pathname format.  See the section \"Syntax of File and\n   Directory Pathname\
    \ Arguments\", section 7.4.\n"
- title: 8.18  LOGIN Command
  contents:
  - "8.18  LOGIN Command\n   Command:  (LOGIN tid user password FILE-SYSTEM USER-VERSION)\n\
    \   Response: (LOGIN tid keyword/value-pairs)\n   LOGIN logs the given user in\
    \ to the server machine, using the\n   password if necessary.  Both user and password\
    \ are string arguments;\n   user is required, password is optional.  An omitted\
    \ password is valid\n   if the host allows the specified user to log in without\
    \ a password.\n   Depending on the operating system and server, it might be necessary\n\
    \   to log in to run a program (in this case the NFILE server program) on\n  \
    \ the host.  LOGIN establishes a user identity that is used by the\n   operating\
    \ system to establish the file author and determine file\n   access rights during\
    \ the current session.\n   The server has the option to reject with an error any\
    \ command except\n   LOGIN if a successful LOGIN command has not been performed.\
    \  This is\n   recommended.  Many operating systems perform the login function\
    \ in a\n   different process and/or environment than user programs.  The portion\n\
    \   of the NFILE server running in the special login environment could\n   conceivably\
    \ be capable only of processing the LOGIN command; this is\n   the reason for\
    \ having the LOGIN command in NFILE.\n   FILE-SYSTEM and USER-VERSION are optional\
    \ keyword/value pairs.  The\n   FILE-SYSTEM keyword/value pair selects the identity\
    \ of the file\n   system to which all following commands in this session are to\
    \ be\n   directed.  This argument has meaning only if the server host machine\n\
    \   has multiple file systems, and the targeted file system is other than\n  \
    \ the default file system that a user would get by initiating a\n   dialogue with\
    \ that host.  The FILE-SYSTEM argument is an arbitrary\n   token list.  If the\
    \ server does not recognize it, the server gives an\n   appropriate command error\
    \ response.\n   Currently, the only use of FILE-SYSTEM is for Symbolics servers\
    \ to\n   select one of the front-end processor hosts instead of the LMFS,\n  \
    \ which is the default.  In this case, the first element in the token\n   list\
    \ is the keyword FEP, and the second element in the token list is\n   an integer,\
    \ indicating the desired FEP disk unit number.  If the\n   server discovers there\
    \ is no such file system, the server gives a\n   command error response including\
    \ the three-letter code NFS, meaning\n   \"no file system\".  See the section\
    \ \"NFILE Errors and Notifications\",\n   section 10.\n   The user tells the server\
    \ what version of NFILE it is running by\n   including the optional USER-VERSION\
    \ keyword/value pair.  The value\n   associated with USER-VERSION can be a string,\
    \ an integer, or a token\n   list.  This document describes NFILE user version\
    \ 2 and server\n   version 2.\n   Upon receiving the representation of the user\
    \ version, the server can\n   either adjust certain parameters to handle this\
    \ particular version,\n   or simply ignore the user version altogether.  Currently,\
    \ the only\n   released versions of NFILE are user version 2 and server version\
    \ 2.\n   LOGIN RETURN VALUES:  keyword/value-pairs\n   The keyword/value-pairs\
    \ is a token list composed of keywords followed\n   by their values.  The server\
    \ includes any or all of the following\n   keywords and their values; they are\
    \ all optional.  The following\n   keywords are recognized:\n   NAME\n   The value\
    \ associated with NAME is a string specifying the user\n   identity, in the server\
    \ host's terms.\n   PERSONAL-NAME\n   The value associated with PERSONAL-NAME\
    \ is a string representing the\n   user's personal name, last name first.  For\
    \ example:  \"McGillicuddy,\n   Aloysius X.\".\n   HOMEDIR-PATHNAME\n   The value\
    \ associated with HOMEDIR-PATHNAME is a string in the\n   pathname as directory\
    \ format, indicating the home directory of the\n   user.  See the section \"Syntax\
    \ of File and Directory Pathname\n   Arguments\", section 7.4.\n   GROUP-AFFILIATION\n\
    \   The value associated with GROUP-AFFILIATION is a string specifying\n   the\
    \ group to which the user belongs, when this concept is\n   appropriate.\n   SERVER-VERSION\n\
    \   The value associated with SERVER-VERSION can be a string, an integer,\n  \
    \ or a token list.  The value is a representation of the version of the\n   server\
    \ is running.  Upon receiving the server version, the user can:\n   adjust certain\
    \ parameters to handle this particular version; accept\n   the version; or close\
    \ the connection.  Currently, the only released\n   versions of NFILE are user\
    \ version 2 and server version 2.\n   PROPERTY-INDEX-TABLE\n   The value associated\
    \ with PROPERTY-INDEX-TABLE is a token list of\n   keywords.  This return value\
    \ enables the server to inform the user\n   which file properties are meaningful\
    \ on its file system.  The\n   keywords in PROPERTY-INDEX-TABLE can be used by\
    \ the DIRECTORY command\n   (a user request for information on file properties\
    \ of a specified\n   directory or directories).  The server can specify a certain\
    \ property\n   by giving an integer that is the index of that file property into\
    \ the\n   PROPERTY-INDEX-TABLE.  This reduces the volume of data sent during\n\
    \   directory listings.  The first element in PROPERTY-INDEX-TABLE is\n   indexed\
    \ by the number 0.  See the section \"DIRECTORY Command\",\n   section 8.11.\n"
- title: 8.19  MULTIPLE-FILE-PLISTS Command
  contents:
  - "8.19  MULTIPLE-FILE-PLISTS Command\n   Command:  (MULTIPLE-FILE-PLISTS tid input-handle\
    \ paths\n              characters properties)\n   Response: (MULTIPLE-FILE-PLISTS\
    \ tid)\n   MULTIPLE-FILE-PLISTS returns file property information of one or more\n\
    \   files.  The server sends the information in a data structure (the\n   format\
    \ is described later in this section) on the given input-handle.\n   paths is\
    \ an embedded token list composed of the pathnames in which\n   the user is interested.\
    \  Each pathname in this list is a string in\n   the full pathname syntax of the\
    \ server host.  Unlike for the\n   DIRECTORY command, wildcards are not allowed\
    \ in these pathnames.  See\n   the section \"Syntax of File and Directory Pathname\
    \ Arguments\",\n   section 7.4.\n   characters is either Boolean truth (indicating\
    \ that each file is a\n   character file), the empty token list (each file is\
    \ a binary file),\n   or the keyword DEFAULT.  DEFAULT indicates that the server\
    \ itself is\n   to figure out whether a file is a character or binary file.  For\
    \ more\n   information on the meaning of the DEFAULT keyword:  See the section\n\
    \   \"OPEN Command\", section 8.20.  The value of characters can influence\n \
    \  some servers' idea of a file's length.\n   properties is a token list of keywords\
    \ indicating which properties\n   the user wants returned.  The server is always\
    \ free to return more\n   properties than those requested in the properties argument.\
    \  If\n   properties is supplied as the empty token list, the server should\n\
    \   transmit all known properties on the files.\n   The server transmits as much\
    \ of the requested information as possible\n   on the given input-handle.  The\
    \ information is contained in a top-\n   level token list of elements.  Each element\
    \ corresponds with a\n   supplied pathname; the order of the original pathlist\
    \ must be\n   retained in the returned token list.  An element is an empty token\n\
    \   list if the corresponding file or any of its containing directories\n   does\
    \ not exist.  The elements that correspond to successfully located\n   files are\
    \ lists composed of truename followed by any properties.\n   properties are keyword/value\
    \ pairs.  truename is a string in the full\n   pathname syntax of the server host.\n\
    \   The following example shows TOP-LEVEL-LIST-BEGIN and TOP-LEVEL-LIST-\n   END\
    \ as parentheses, and LIST-BEGIN and LIST-END with square brackets.\n   For example,\
    \ the user supplied a pathlist argument resembling:\n                        \
    \    [file1 file2 file3]\n   The server could not locate file1 or file3, but did\
    \ locate file2, and\n   found the length and author of file2.  The top-level token\
    \ list\n   transmitted by the server is:\n        ( [] [ truename-of-file2 LENGTH\
    \ 381 AUTHOR williams ] [] )\n   For further detail on how file properties and\
    \ values are expressed:\n   See the section \"Format of NFILE File Property/Value\
    \ Pairs\", section\n   7.5.\n"
- title: 8.20  OPEN Command
  contents:
  - "8.20  OPEN Command\n   Command:  (OPEN tid handle pathname direction binary-p\n\
    \                TEMPORARY RAW SUPER-IMAGE DELETED PRESERVE-DATES\n          \
    \      SUBMIT DIRECT-FILE-ID ESTIMATED-LENGTH BYTE-SIZE\n                IF-EXISTS\
    \ IF-DOES-NOT-EXIST)\n   Response: (OPEN tid truename binary-p other-properties)\n\
    \   OPEN opens a file for reading, writing, or direct access at the\n   server\
    \ host.  That means, in general, asking the host file system to\n   access the\
    \ file and obtaining a file number, pointer, or other\n   quantity for subsequent\
    \ rapid access to the file; this is called an\n   \"opening\".  See the section\
    \ \"NFILE File Opening Modes\", section 5.\n   The OPEN command has the most complicated\
    \ syntax of any NFILE\n   command.  The OPEN command has required arguments, an\
    \ optional\n   argument, and many optional keyword/value pairs.  For details on\
    \ the\n   syntax of each of these parts of the OPEN command:  See the section\n\
    \   \"Conventions Used in This Document\", section 7.\n   The following arguments\
    \ are required:  pathname, direction, and\n   binary-p.  handle is an optional\
    \ argument, which must either be\n   supplied or explicitly omitted by means of\
    \ substituting in its place\n   the empty token list.\n   The OPEN command has\
    \ many optional keyword/value pairs, which encode\n   conceptual arguments to\
    \ the server file system for the OPEN\n   operation.  A detailed description of\
    \ all the supported OPEN optional\n   keywords is given below.\n   The OPEN return\
    \ values reflect information about the file opened,\n   when the opening is successful.\
    \  In the case of a probe-type opening,\n   this information is returned when\
    \ the given file (or link, or\n   directory) exists and is accessible, even though\
    \ the file (or link,\n   or directory) is not actually opened.  For detail on\
    \ the OPEN return\n   values: See the section \"NFILE OPEN Response Return Values\"\
    , section\n   8.20.2.\n   THE pathname OPEN ARGUMENT\n   The pathname is a required\
    \ argument specifying the file to be opened.\n   pathname is a string in the full\
    \ pathname syntax of the server host.\n   See the section \"Syntax of File and\
    \ Directory Pathname Arguments\",\n   section 7.4.\n   For some purposes (for\
    \ example, when the OPEN argument direction is\n   supplied as PROBE-DIRECTORY),\
    \ only the directory specified by this\n   pathname is utilized.  See the section\
    \ \"NFILE OPEN Optional\n   Keyword/Value Pairs\", section 8.20.1.\n   THE handle\
    \ OPEN ARGUMENT\n   The handle argument of the OPEN command specifies a data channel\
    \ to\n   be used for the transfer.  Subsequent commands in this session use\n\
    \   the same handle to specify this opening.  It is the user side's\n   responsibility\
    \ to ensure that handle refers to an existing and free\n   data channel that does\
    \ not require resynchronization before use.  A\n   handle must be supplied, unless\
    \ a probe-type opening is desired (that\n   is, the direction is supplied as PROBE,\
    \ PROBE-DIRECTORY, or PROBE-\n   LINK) or a direct access opening is being requested\
    \ (that is, a\n   DIRECT-FILE-ID is supplied).  In those cases, the empty token\
    \ list is\n   supplied for handle.\n   THE direction OPEN ARGUMENT\n   The direction\
    \ argument must be supplied as one of these keywords:\n   INPUT, OUTPUT, IO, PROBE,\
    \ PROBE-DIRECTORY, and PROBE-LINK.  The\n   meanings of the direction keywords\
    \ are as follows:\n   INPUT\n      Specifies that the file is to be opened for\
    \ input server-to-user\n      transfer).  To request a direct access opening,\
    \ supply a value for\n      DIRECT-FILE-ID. If no DIRECT-FILE-ID is supplied,\
    \ the opening is a\n      data stream opening.\n   OUTPUT\n      Specifies that\
    \ the file is to be opened for output user-to-server\n      transfer).  To request\
    \ a direct access opening, supply a value for\n      DIRECT-FILE-ID. If no DIRECT-FILE-ID\
    \ is supplied, the opening is a\n      data stream opening.\n   IO\n      Specifies\
    \ that interspersed input and output will be performed on\n      the file.  This\
    \ is only meaningful in direct access mode.  A\n      DIRECT-FILE-ID must also\
    \ be supplied.  See the section \"NFILE OPEN\n      Optional Keyword/Value Pairs\"\
    , section 8.20.1.\n   If direction is supplied as PROBE, PROBE-LINK, or PROBE-DIRECTORY,\n\
    \   the opening is said to be a probe-type opening.  The DIRECT-FILE-ID\n   option\
    \ is meaningless and an error for probe-type openings.  The file\n   handle must\
    \ be supplied as an empty token list for probe-type\n   openings.\n   PROBE\n\
    \      Specifies that the file is not to be opened at all, but simply\n      checked\
    \ for existence.  If the file does not exist or is not\n      accessible, the\
    \ error indications and actions are identical to\n      those that would be given\
    \ for an INPUT opening.  If the file does\n      exist, the successful command\
    \ response contains the same\n      information as it would have if the file had\
    \ been opened for\n      INPUT.  If it is a link, the link is followed to its\
    \ target.\n   PROBE-LINK\n      Like PROBE, with one difference.  PROBE-LINK specifies\
    \ that if the\n      pathname is found to refer to a link, that link is not to\
    \ be\n      followed, and information about the link itself is to be returned.\n\
    \   PROBE-DIRECTORY\n      PROBE-DIRECTORY requests information about the directory\n\
    \      designated by the pathname argument.  In the PROBE-DIRECTORY case,\n  \
    \    the pathname argument refers to the directory on which information\n    \
    \  is requested.  In all other cases, the pathname refers to a file\n      to\
    \ be opened.  If pathname contains a file name and file type,\n      these parts\
    \ of the pathname are ignored for PROBE-DIRECTORY\n      openings as long as they\
    \ are syntactically valid.\n   THE binary-p OPEN ARGUMENT\n   The value of binary-p\
    \ affects the mode in which the server opens the\n   file, as well as informing\
    \ it whether or not character set\n   translation must be performed.\n   If binary-p\
    \ is supplied as the empty token list, the opening is said\n   to be a character\
    \ opening.  The server performs character set\n   translation between its native\
    \ character set and the NFILE character\n   set.  The data is transferred over\
    \ the data connection one character\n   per eight-bit byte.  See the section \"\
    NFILE Character Set\", section\n   6.\n   If binary-p is supplied as Boolean truth,\
    \ the opening is said to be a\n   binary opening.  The user side supplies the\
    \ byte size via the BYTE-\n   SIZE option; if not supplied, the default byte size\
    \ is 16 bits.  If\n   byte size is less than 9, the file data is transferred byte\
    \ by byte.\n   If the byte size is 9 or greater, the server transfers each byte\
    \ of\n   the file as two eight-bit bytes, low-order first.\n   binary-p can also\
    \ be supplied as the keyword DEFAULT.  DEFAULT\n   specifies that the server itself\
    \ is to determine whether to transfer\n   binary or character data.  DEFAULT is\
    \ meaningful only for input\n   openings; it is an error for OUTPUT, IO, or probe-type\
    \ openings.  For\n   file systems that maintain the innate binary or character\
    \ nature of a\n   file, the server simply asks the file system which case is in\
    \ force\n   for the file specified by pathname.\n   When binary-p is supplied\
    \ as DEFAULT, on file systems that do not\n   maintain thisinformation, the server\
    \ is required to perform a\n   heuristic check for Symbolicsobject fileson the\
    \ first two 16-bit\n   bytes of the file.  If the file isdetermined to be aSymbolics\
    \ object\n   file, the server performs a BINARY openingwith BYTE-SIZE of16;\n\
    \   otherwise, it performs a CHARACTER opening.\n   The details of the check are\
    \ as follows: if the first 16-bit byte is\n   the octal number170023 and the second\
    \ 16-bit byte is any number\n   between 0 and 77 octal(inclusive), the file is\
    \ recognized as a\n   Symbolics object file.  In any othercase, it is not.\n"
- title: 8.20.1  NFILE OPEN Optional Keyword/Value Pairs
  contents:
  - "8.20.1  NFILE OPEN Optional Keyword/Value Pairs\n   The OPEN command has many\
    \ optional keyword/value pairs that encode\n   conceptual arguments to the file\
    \ system for the OPEN operation.\n   The following options are used often:\n \
    \  BYTE-SIZE\n      Must be followed by an integer between 1 and 16, inclusive,\
    \ or the\n      empty token list.  BYTE-SIZE is meaningful only for binary\n \
    \     openings.  BYTE-SIZE can be ignored for probe-type openings.  It\n     \
    \ can be omitted entirely for character openings, but if supplied,\n      must\
    \ be followed by the empty token list.  If binary-p is supplied\n      as DEFAULT,\
    \ BYTE-SIZE can be omitted entirely, or followed by the\n      empty token list.\n\
    \      If a binary opening is requested and BYTE-SIZE is not supplied,\n     \
    \ the assumed value is 16 for output openings. For input binary\n      openings,\
    \ the default is the host file system's stored conception\n      of the file's\
    \ byte size (for those hosts that natively support\n      byte size).  For file\
    \ systems that do not natively support\n      natively byte size, the default\
    \ byte-size on binary input is 16.\n      For file systems that maintain the innate\
    \ byte-size of each file,\n      the server should supply this number to the appropriate\
    \ operating\n      system interface that performs the semantics of opening the\
    \ file.\n      For other operating systems, a file written with a given byte size\n\
    \      must produce the same bytes in the same order when read with that\n   \
    \   byte size.  In this case, the server or host operating system can\n      choose\
    \ any packing scheme that complies with this rule.\n      Operating systems that\
    \ do not support byte size must ensure that\n      binary files written from user\
    \ ends of the current protocol can be\n      read back correctly.  However, the\
    \ server can choose packing\n      schemes that allow all bits of the server host's\
    \ word to be\n      accessed and concur with other packing schemes used by native\
    \ host\n      software.\n      For example, Multics supports 36 bit words and\
    \ 9 bit bytes.  A\n      packing scheme appropriate for a Multics NFILE server\
    \ is:\n               Byte Size                Packing Scheme\n              \
    \ 7, 8, or 9 bits          four per 36-bit word\n               10, 11, or 12\
    \ bits       three per 36-bit word\n               13, 14, 15, or 16 bits   two\
    \ per 36-bit word\n      In the first packing scheme in the table, native Multics\n\
    \      character-oriented software can access each logical byte\n      sequentially.\
    \  In the last packing scheme, each Symbolics byte is\n      in a halfword, easily\
    \ accessible and visible in an octal\n      representation.  To achieve maximum\
    \ data transfer rate and access\n      all bits of a Multics word, a byte size\
    \ of 12 must be specified.\n   DELETED\n      If supplied as Boolean truth, DELETED\
    \ specifies that deleted\"\n      files are to be treated as though they were\
    \ not \"deleted\".\n      DELETED is meaningful only for operating systems that\
    \ support\n      \"soft deletion\" and subsequent \"undeletion\" of files.  Other\n\
    \      operating systems must ignore this option.  Normally, deleted\n      files\
    \ are not visible to the OPEN operation; this option makes\n      them visible.\n\
    \      DELETED can also be followed by the empty token list, which has\n     \
    \ the same effect as omitting the DELETED keyword/value pair\n      entirely.\
    \  For output openings, DELETED is meaningless and an\n      error if supplied.\n\
    \   DIRECT-FILE-ID\n      If supplied, the DIRECT-FILE-ID indicates that the opening\
    \ is to\n      be a direct access mode opening.  If not supplied, the opening\
    \ is\n      a data stream opening.  The value of DIRECT-FILE-ID is a string\n\
    \      generated by the user, that has not been used as a DIRECT-FILE-ID\n   \
    \   in this dialogue, and does not designate any data channel.  The\n      DIRECT-FILE-ID\
    \ is a unique identifier for the direct access\n      opening.  It is used for\
    \ all operations that identify an opening\n      rather than a data channel. \
    \ The DIRECT-FILE-ID is used to\n      identify a direct access opening, just\
    \ as a file handle is used to\n      identify a data stream opening.  The PROPERTIES,\
    \ CLOSE, and RENAME\n      commands use the DIRECT-FILE-ID in this way.  There\
    \ are only two\n      NFILE commands applicable to direct access openings (ABORT\
    \ and\n      CONTINUE) that do not use the DIRECT-FILE-ID, but use a data\n  \
    \    channel handle instead.\n   PRESERVE-DATES\n      If supplied as Boolean\
    \ truth, PRESERVE-DATES specifies that the\n      server is to attempt to prevent\
    \ the operating system from updating\n      the \"reference date\" or date-time\
    \ used\" of the file.  This is\n      meaningful only for input openings, and\
    \ is an error otherwise.\n      The Symbolics operating system invokes this option\
    \ for operations\n      such as View File in the editor, where it wishes to assert\
    \ that\n      the user did not \"read\" the file, but just \"looked at it\".\n\
    \      Servers on operating systems that do not support reference dates\n    \
    \  or users revising or suppressing update of the reference dates\n      must\
    \ ignore this option.\n   ESTIMATED-LENGTH\n      The value of ESTIMATED-LENGTH\
    \ is an integer estimating the length\n      of the file to be transferred. This\
    \ option is meaningful and\n      permitted only for output openings.  ESTIMATED-LENGTH\
    \ enables the\n      user end to suggest to the server's file system how long\
    \ the file\n      is going to be.  This can be useful for file systems that must\n\
    \      preallocate files or file maps or that accrue performance benefits\n  \
    \    from knowing this information at nthe time the file is first\n      opened.\
    \  This estimate, if supplied, is not required to be exact.\n      It is ignored\
    \ by servers to which it is not useful or interesting.\n      The units of the\
    \ estimate are characters for character openings,\n      and bytes of the agreed-upon\
    \ byte size for binary openings.  The\n      character units should be server\
    \ units, if possible, but since\n      this is only an estimate, NFILE character\
    \ units are acceptable.\n      See the section \"NFILE Character Set\", section\
    \ 6.\n   IF-EXISTS\n      Meaningful only for output openings, ignored otherwise,\
    \ but not\n      diagnosed as an error.  The value of IF-EXISTS is a keyword that\n\
    \      specifies the action to Be taken if a file of the given name\n      already\
    \ exists.  The semantics of the values are derived from the\n      Common Lisp\
    \ specification and repeated here for completeness.  If\n      the file does not\
    \ already exist, the IF-EXISTS option and its\n      value are ignored.\n    \
    \  If the user side does not give the IF-EXISTS option, The action to\n      be\
    \ taken if a file of the given name already exists depends on\n      whether or\
    \ not the file system supports file versions.  If it\n      does, the default\
    \ is ERROR (if an explicit version is given in the\n      file pathname) or NEW-VERSION\
    \ (if the version in the file pathname\n      is the newest version).  For file\
    \ systems not supporting versions,\n      the default is SUPERSEDE.  These actions\
    \ are described below.\n      IF-EXISTS provides the mechanism for overwriting\
    \ or appending to\n      files.  With the default setting of IF-EXISTS, new files\
    \ are\n      created by every output opening.\n      Operating systems supporting\
    \ soft deletion can take different\n      actions if a \"deleted\" file already\
    \ exists with the same name (and\n      type and version, where appropriate) as\
    \ a file to be created.  The\n      Symbolics file system (LMFS) effectively uses\
    \ SUPERSEDE, even if\n      not asked to do so.  Other servers and file systems\
    \ are urged to\n      do similarly.  Recommended action is to not allow deleted\
    \ files to\n      prevent successful file creation (with specific version number)\n\
    \      even if an IF-EXISTS option weaker than SUPERSEDE, RENAME, or\n      RENAME-AND-DELETE\
    \ is specified or implied.\n      Here are the possible values and their meanings:\n\
    \      ERROR\n         Reports an error.\n      NEW-VERSION\n         Creates\
    \ a new file with the same file name but with a larger\n         version number.\
    \  This is the default when the version component\n         of the filename is\
    \ newest.  File systems without version\n         numbers can implement this by\
    \ effectively treating it as\n         SUPERSEDE.\n      RENAME\n         Renames\
    \ the existing file to some other name and then creates a\n         new file with\
    \ the specified name.  On most file systems, this\n         renaming happens at\
    \ the time of a successful close.\n      RENAME-AND-DELETE\n         Renames the\
    \ existing file to some other name and then deletes\n         it (but does not\
    \ expunge it, on those systems that distinguish\n         deletion from expunging).\
    \  Then it creates a new file with the\n         specified name.  On most file\
    \ systems, this renaming happens at\n         the time of a successful close.\n\
    \      OVERWRITE\n         Output operations on the opening destructively modify\
    \ the\n         existing file.  New data replaces old data at the beginning of\n\
    \         the file; however, the file is not truncated to length zero\n      \
    \   upon opening.\n      TRUNCATE\n         Output operations on the opening destructively\
    \ modify the\n         existing file.  The file pointer is initially positioned\
    \ at the\n         beginning of the file; at that time, TRUNCATE truncates the\n\
    \         file to length zero and frees disk storage occupied by it.\n      APPEND\n\
    \         Output operations on the opening destructively modify the\n        \
    \ existing file.  New data is placed at the current end of the\n         file.\n\
    \      SUPERSEDE\n         Supersedes the existing file.  This means that the\
    \ old file is\n         removed or deleted and expunged.  The new file takes its\
    \ place.\n         If possible, the file system does not destroy the old file\n\
    \         until the new file is closed, against the possibility that the\n   \
    \      file will be close-aborted.  This differs from NEW-VERSION in\n       \
    \  that SUPERSEDE creates a new file with the same name as the old\n         one,\
    \ rather than a file name with a higher version number.\n         There are currently\
    \ no standards on what a server can do if it\n         cannot implement some of\
    \ these actions.\n   IF-DOES-NOT-EXIST\n      Meaningful for input openings, never\
    \ meaningful for probe-type\n      openings, and sometimes meaningful for output\
    \ openings.  IF-DOES-\n      NOT-EXIST takes a value token, which specifies the\
    \ action to be\n      taken if the file does not already exist.  Like IF-EXISTS,\
    \ it is a\n      derivative of Common Lisp.  The default is as follows: If this\
    \ is\n      a probe-type opening or read opening, or if the IF-EXISTS option\n\
    \      is specified as OVERWRITE, TRUNCATE, or APPEND, the default is\n      ERROR.\
    \  Otherwise, the default is CREATE.\n      These are the values for IF-DOES-NOT-EXIST:\n\
    \      ERROR\n         Reports an error.\n      CREATE\n         Creates an empty\
    \ file with the specified name and then proceeds\n         as if it already existed.\n\
    \   The following optional keyword/value pairs are rarely used, if ever:\n   RAW\n\
    \      If supplied as Boolean truth, RAW specifies that character set\n      translation\
    \ is not to be performed, but that characters are to be\n      transferred intact,\
    \ without inspection.  This option is meaningful\n      only for character openings;\
    \ it is an error otherwise.  It is also\n      an error to supply RAW as Boolean\
    \ truth for probe-type openings.\n      RAW can also be followed by the empty\
    \ token list, which has the\n      same effect as if the RAW keyword/value pair\
    \ were omitted\n      entirely.  See the section \"RAW Translation Mode\", Appendix\
    \ B.\n   SUPER-IMAGE\n      If supplied as Boolean truth, SUPER-IMAGE specifies\
    \ that Rubout\n      quoting is not to be performed.  This operation is meaningful\
    \ only\n      for character openings; it is an error otherwise.  It is also an\n\
    \      error for probe-type openings.  SUPER-IMAGE can also be followed\n    \
    \  by the empty token list, which has the same effect as if the\n      SUPER-IMAGE\
    \ keyword/value pair were omitted entirely.\n      SUPER-IMAGE mode causes the\
    \ server to read or write character\n      files where ASCII Rubout characters\
    \ are a significant part of the\n      file content, not where they are an escape\
    \ for this protocol.\n      However, other translations must still be performed:\
    \  See the\n      section SUPER-IMAGE Translation Mode\", Appendix C.\n   TEMPORARY\n\
    \      Used by the TOPS-20 server only.  TEMPORARY says to use GJ%TMP in\n   \
    \   the GTJFN.  This is useful mainly when writing files, and\n      indicates\
    \ that the foreign operating system is to treat the file\n      as temporary.\
    \  See TOPS-20 documentation for more about the\n      implications of this option.\
    \  Other servers can ignore it.  This\n      option is meaningless and an error\
    \ for input or probe-type\n      openings.  TEMPORARY can also be followed by\
    \ the empty token list,\n      which has the same effect as if the TEMPORARY keyword/value\
    \ pair\n      were omitted entirely.\n   SUBMIT\n      SUBMIT is meaningful for\
    \ output only.  If supplied as Boolean\n      truth, SUBMIT causes the server\
    \ to submit the contents of the file\n      being written to the operating system\
    \ as a job, after the file is\n      closed.  VMS is an example of an operating\
    \ system that could\n      conveniently support SUBMIT.  SUBMIT can also be followed\
    \ by the\n      empty token list, which has the same effect as if the SUBMIT\n\
    \      keyword/value pair were omitted entirely.  Servers that do not\n      implement\
    \ this option should give an error response if requested\n      to submit a file\
    \ to the operating system.\n"
- title: 8.20.2  NFILE OPEN Response Return Values
  contents:
  - "8.20.2  NFILE OPEN Response Return Values\n   The results of a successful OPEN\
    \ operation are reported in the\n   command response.  Here is the specification\
    \ of the OPEN response\n   format:\n   Response Format:\n      (OPEN tid truename\
    \ binary-p other-properties)\n   The return values for OPEN and CLOSE are syntactically\
    \ identical, but\n   the values can change in the time interval between open and\
    \ close.\n   truename is a string representing the pathname of the file in the\n\
    \   full pathname syntax of the server host.  It should be determined by\n   the\
    \ server once it has opened the file, via some request to its\n   operating system.\
    \  The request can be of the form:  \"What file\n   corresponds to this JFN, file\
    \ number, pointer, etc.?\"  If the\n   operating system supports version numbers,\
    \ this string always\n   contains an explicit version number.  It always contains\
    \ a directory\n   name, a file name, and so on.\n   Some operating systems might\
    \ not know the truename of an output file\n   until it is closed.  It is permissible\
    \ not to supply an explicit\n   version number in the pathname in the OPEN response\
    \ in this specific\n   case.  On these systems the truename when the file is opened\
    \ is\n   different than the truename after it has been closed.\n   The return\
    \ value binary-p indicates whether the opening is a binary\n   or character opening.\
    \  For binary openings, binary-p is supplied as\n   Boolean truth; for character\
    \ openings it is the empty token list.\n   other-properties is a list of keyword/value\
    \ pairs.  other-properties\n   must contain CREATION-DATE and LENGTH.  AUTHOR\
    \ should be included if\n   the server operating system has a convenient mechanism\
    \ for\n   determining the author of the sfile.  The other properties described\n\
    \   here can be included if desired.\n   AUTHOR\n   The value of AUTHOR is a string\
    \ representing the name of the author\n   of the file.  This is some kind of user\
    \ identifier, whose format is\n   system-specific.  As with CREATION-DATE (see\
    \ below), AUTHOR is\n   supposed to represent the logical determinor of the current\
    \ data\n   content of the file, not necessarily the agency that actually created\n\
    \   the file.\n   BYTE-SIZE\n   The byte-size agreed upon via the rules described\
    \ for the BYTE-SIZE\n   option.  The value of BYTE-SIZE is an integer.  For details\
    \ on the\n   ramifications of BYTE-SIZE:  See the section \"NFILE OPEN Optional\n\
    \   Keyword/Value Pairs\", section 8.20.1.  This parameter is only\n   meaningful\
    \ for BINARY openings.  However, if FILEPOS is returned in\n   the other-properties\
    \ list, BYTE-SIZE should also be included, even\n   for character openings.\n\
    \   CREATION-DATE\n   The creation date of the file.  The date is expressed in\
    \ Universal\n   Time format, which measures a time as the number of seconds since\n\
    \   January 1, 1900, at midnight GMT.  Creation date does not necessarily\n  \
    \ mean the time the file system created the directory entry or records\n   of\
    \ the file.  For systems that support modification or appending to\n   files,\
    \ it is usually the modification date of the file.  Creation\n   date can mean\
    \ the date that the bit count or byte count of the file\n   was set by an application\
    \ program.\n   Some types of file systems support a user-settable quantity\n \
    \  (CREATION-DATE) which the user can set to an arbitrary time, to\n   indicate\
    \ that the contents of this file were written a long time ago\n   by someone else\
    \ on another computer.  The default value of this\n   quantity, if the user has\
    \ not set it, is the time someone last\n   modified the information in the file.\
    \  This quantity, in the OPEN\n   response for an output file, is disregarded\
    \ by the user side, but\n   nevertheless must be present.\n   The Symbolics computer\
    \ system software uses this quantity as a unique\n   identifier of file contents,\
    \ for a given file name, type, and\n   version, to prove that a file has not changed\
    \ since it last recorded\n   this quantity for a file.\n   FILEPOS\n   An integer\
    \ giving the position of the logical file pointer, in\n   characters or bytes\
    \ as appropriate for the type of opening.  This is\n   always zero for an input\
    \ opening and for an output opening creating a\n   new file.  For an output opening\
    \ appending to an existing file,\n   FILEPOS is the number of characters or bytes,\
    \ as appropriate,\n   currently in the file.  This number, for character openings,\
    \ is\n   measured in server units: See the section \"NFILE Character Set\",\n\
    \   section 6.\n   LENGTH\n   An integer reporting the length of the file, in\
    \ characters for\n   character openings and in bytes of the agreed-upon size for\
    \ binary\n   openings.  LENGTH should be reported as zero for output openings,\n\
    \   even if appending to an existing file.  The server usually only knows\n  \
    \ the length for a character opening in server units; thus, it reports\n   length\
    \ in server units.\n"
- title: 8.21  PROPERTIES Command
  contents:
  - "8.21  PROPERTIES Command\n   Command:  (PROPERTIES tid handle pathname control-keywords\n\
    \   properties)\n   Response: (PROPERTIES tid property-element settable-properties)\n\
    \   PROPERTIES requests the property information about one file.  The\n   file\
    \ is identified by the pathname argument or the handle argument,\n   but not both.\
    \  If pathname is supplied, it is a string in the full\n   pathname syntax of\
    \ the server host.  See the section \"Syntax of File\n   and Directory Pathname\
    \ Arguments\", section 7.4.\n   If handle is supplied, its value is a string identifying\
    \ an opening,\n   which implicitly identifies a file.  For direct access mode\
    \ openings,\n   handle must be a direct file identifier.\n   control-keywords\
    \ is reserved in the current design.  However, it is a\n   required argument,\
    \ and must be supplied as the empty token list.  Its\n   presence in the NFILE\
    \ specification allows for future expansion.  In\n   the future the value of control-keywords\
    \ might affect the listing\n   mode.\n   properties is a token list of keywords\
    \ indicating the properties the\n   user wants returned.  (In command arguments,\
    \ properties cannot be\n   specified with integers, such as indices into the Property\
    \ Index\n   Table).  For a list of keywords associated with file properties: \
    \ See\n   the section \"Format of NFILE File Property/Value Pairs\", section 7.5.\n\
    \   The server is always free to return more properties than those\n   requested\
    \ in the properties argument.  If properties is supplied as\n   the empty token\
    \ list, the server transmits all known properties of\n   the file.\n   PROPERTIES\
    \ COMMAND RESPONSE\n   The server returns the property information for the given\
    \ file in the\n   command response.  The PROPERTIES command does not use any data\n\
    \   channels.  If the specified file does not exist or is not accessible,\n  \
    \ the server signals an error and includes an appropriate three-letter\n   error\
    \ code in the command error response.  See the section \"NFILE\n   Errors and\
    \ Notifications\", section 10.\n   The return value property-element is a token\
    \ list.  The first element\n   in that token list is the pathname of the file,\
    \ in the full pathname\n   syntax of the server host.  The following elements\
    \ of the property-\n   element token list are property/value pairs.  The server\
    \ is expected\n   to return several property/value pairs; the number of pairs\
    \ is not\n   constrained.  For further details on file properties and their\n\
    \   associated values:  See the section \"Format of NFILE File\n   Property/Value\
    \ Pairs\", section 7.5.\n   The return value settable-properties is a token list\
    \ of keywords.\n   The number of keywords is not constrained.  (Note that integers\n\
    \   cannot be used in settable-properties to indicate the file property;\n   keywords\
    \ are to be used instead.)  Each keyword supplied in\n   settable-properties identifies\
    \ a property considered settable by the\n   server.  The server is implicitly\
    \ guaranteeing a mechanism for\n   changing the properties reported as settable.\
    \  The user can change\n   any of the settable properties for this file by using\
    \ the CHANGE-\n   PROPERTIES command.  See the section \"CHANGE-PROPERTIES Command\"\
    ,\n   section 8.2.\n   The following example shows the format of the PROPERTIES\
    \ command\n   response.  Remember that the number of property/value pairs and\n\
    \   keywords is not constrained; this example has two property/value\n   pairs\
    \ and three settable-properties keywords returned:\n             TOP-LEVEL-LIST-BEGIN\n\
    \             PROPERTIES         - name of the command\n             tid     \
    \           - transaction identifier\n             LIST-BEGIN\n             pathname\
    \ of file\n             prop1 value1       - file's property/value pairs\n   \
    \          prop2 value2\n             LIST-END\n             LIST-BEGIN\n    \
    \         keyword-1          - file's settable properties\n             keyword-2\n\
    \             keyword-3\n             LIST-END\n             TOP-LEVEL-LIST-END\n\
    \   The following example is designed to better show the structure of the\n  \
    \ top-level token list by depicting TOP-LEVEL-LIST-BEGIN and TOP-\n   LEVEL-LIST-END\
    \ by parentheses and LIST-BEGIN and LIST-END by square\n   brackets.  The indentation\
    \ and newlines in the example are not part\n   of the token list, but are used\
    \ here to make the structure of the\n   token list clear.\n             (PROPERTIES\
    \ tid [ pathname prop1 value1 prop2 value2 ...]\n                            \
    \ [ keyword1 keyword2 keyword3 ... ]\n"
- title: 8.22  READ Command
  contents:
  - "8.22  READ Command\n   Command: (READ tid direct-file-id input-handle count FILEPOS)\n\
    \   Response: (READ tid)\n   READ requests input data flow for direct access openings.\
    \  The\n   direct-file-id is the same as the DIRECT-FILE-ID argument that was\n\
    \   given when opening the file; it designates the opening from which the\n  \
    \ characters or bytes are to be transferred.  The input-handle\n   specifies which\
    \ data channel should be used for the transfer of data\n   from server to user.\
    \  The data channel should have been already\n   established, cannot have been\
    \ disestablished, and must not currently\n   be in use.\n   count is an integer\
    \ specifying how many bytes (or NFILE characters,\n   as appropriate) to read.\
    \  count can be supplied as the empty token\n   list, meaning read to the end\
    \ of the file.  If the user specifies the\n   empty token list or a count greater\
    \ than the number of bytes\n   remaining in the file, the server sends the keyword\
    \ EOF to mark the\n   end of the file.\n   FILEPOS is an optional keyword/value\
    \ pair.  If the keyword FILEPOS is\n   supplied, it must be followed by an integer.\
    \  Before data is\n   transferred, the opening is positioned to the point specified\
    \ by the\n   value of FILEPOS.  The position of the point is measured in server\n\
    \   units for character openings; for binary openings it is measured in\n   binary\
    \ bytes.  See the section \"FILEPOS NFILE Command\".\n   Upon receiving the READ\
    \ command, the server binds the data channel to\n   the opening and immediately\
    \ begins transferring data.  The server\n   stops when all data has been transferred.\
    \  After the server sends the\n   last requested byte, it unbinds the data channel,\
    \ freeing it for\n   other use.  When the user side has processed the last byte,\
    \ the user\n   side assumes that the data channel can now be reused for another\
    \ data\n   transfer.\n"
- title: 8.23  RENAME Command
  contents:
  - "8.23  RENAME Command\n   Command:  (RENAME tid handle pathname to-pathname)\n\
    \   Response: (RENAME tid from-pathname to-pathname)\n   RENAME requests the server\
    \ to give a file a new name.  This is\n   NFILE's interface to the system's native\
    \ rename operation, with all\n   of its system-specific semantics and constraints.\n\
    \   Either a handle or a pathname (but not both) specifies the file that\n   is\
    \ to receive a new name.  The argument to-pathname designates that\n   new name.\
    \  The return value from-pathname gives the full original\n   name of the file,\
    \ and to-pathname gives the full new name of the\n   file.  For systems that support\
    \ version numbers, the return values\n   can differ in version number from the\
    \ values of the arguments given\n   to RENAME.\n   The arguments pathname and\
    \ to-pathname and the return values from-\n   pathname and to-pathname are strings\
    \ in the full pathname syntax of\n   the server host.  See the section \"Syntax\
    \ of File and Directory\n   Pathname Arguments\", section 7.4.\n   If the file\
    \ to be renamed is specified by a pathname, the file should\n   be renamed immediately.\
    \  If the file is specified by handle, it is\n   acceptable to wait until close-time\
    \ to rename the file.\n   Some operating systems can rename only within a directory.\n\
    \   Nevertheless, the to-pathname of the RENAME must be fully specified;\n   the\
    \ server on these systems must check for and reject an attempted\n   cross-directory\
    \ rename.\n"
- title: 8.24  RESYNCHRONIZE-DATA-CHANNEL Command
  contents:
  - "8.24  RESYNCHRONIZE-DATA-CHANNEL Command\n   The command and response format\
    \ for this command varies, depending on\n   whether the handle argument indicates\
    \ an input or output data\n   channel.\n   For an Input Handle:\n   Command: \
    \ (RESYNCHRONIZE-DATA-CHANNEL tid handle)\n   Response: (RESYNCHRONIZE-DATA-CHANNEL\
    \ tid identifier)\n   For an Output Handle:\n   Command:  (RESYNCHRONIZE-DATA-CHANNEL\
    \ tid handle identifier)\n   Response: (RESYNCHRONIZE-DATA-CHANNEL tid)\n   RESYNCHRONIZE-DATA-CHANNEL\
    \ begins a prescribed procedure between user\n   and server over the unsafe data\
    \ channel specified by handle.  The\n   resynchronization procedure clears the\
    \ data channel of any unwanted\n   data, and restores the data channel to a safe\
    \ state, ready to\n   transfer data again.\n   All arguments to RESYNCHRONIZE-DATA-CHANNEL\
    \ are required.\n   For a detailed description of how the user and server coordinate\
    \ the\n   resynchronization of data channels:  See the section \"NFILE Data\n\
    \   Connection Resynchronization\", section 9.2.\n"
- title: 8.24.1  Implementation Hints for RESYNCHRONIZE-DATA-CHANNEL Command
  contents:
  - "8.24.1  Implementation Hints for RESYNCHRONIZE-DATA-CHANNEL Command\n   In general,\
    \ both the user and server should should be implemented\n   with the knowledge\
    \ that a transmission can be aborted.  That is, the\n   receiving side must be\
    \ careful not to act upon a transmission (that\n   is, to perform any action or\
    \ side effect) until the transmission has\n   been successfully received in entirety.\
    \  This protects the user\n   program from the possibility that an abort can occur\
    \ after a\n   transmission has been partially sent.\n   RESYNCHRONIZING AN OUTPUT\
    \ DATA CHANNEL\n   The server will probably want to dispatch the looping and reading\
    \ to\n   the logical data process.  Looping reading for the resynchronization\n\
    \   identifier in the control connection handler is not a viable option.\n   If\
    \ the user side fails to send the resynchronization identifier (for\n   example,\
    \ due to a user abort) the control connection handler can\n   never be broken\
    \ out of this loop.\n   Should the user side send the control connection handler\
    \ command\n   first, or send the marks and identifiers first?\n   Sending the\
    \ marks first is problematic, because the data channel at\n   the other end might\
    \ not be reading them (for it has not yet been so\n   instructed by the control\
    \ connection handler).  The user might then\n   become blocked for output, thus\
    \ prohibiting sending of the\n   RESYNCHRONIZE-DATA-CHANNEL command.\n   On the\
    \ other hand, sending the control connection handler command\n   first requires\
    \ that the user side can send the marks and identifiers\n   between sending the\
    \ control connection handler command and receiving\n   a response for it.  The\
    \ response will never come until the marks and\n   identifiers have been successfully\
    \ received.  The user implementation\n   must allow for this one case of a command\
    \ where a subroutine that\n   \"sends a command and waits for a response\" is\
    \ inapplicable.\n   RESYNCHRONIZING AN INPUT DATA CHANNEL\n   The server control\
    \ process should dispatch the data process to send\n   the mark, and not wait,\
    \ lest the data process become blocked for\n   output due to a user abort.  The\
    \ control process must go back to its\n   command loop, to possibly receive a\
    \ command that might break the data\n   process out of that block.\n"
- title: 8.25  UNDATA-CONNECTION Command
  contents:
  - "8.25  UNDATA-CONNECTION Command\n   Command:  (UNDATA-CONNECTION tid input-handle\
    \ output-handle)\n   Response: (UNDATA-CONNECTION tid)\n   UNDATA-CONNECTION explicitly\
    \ disestablishes a data connection from\n   the user side.  The user side has\
    \ the option of disestablishing data\n   connections at its discretion.  There\
    \ is no place in the protocol\n   where disestablishment of data connections is\
    \ required, other than at\n   the end of the session, where it is implicit.\n\
    \   The data connection to be disestablished is the one designated by the\n  \
    \ input-handle and output-handle arguments.  These two handles must\n   refer\
    \ to the same data connection.\n   It is not permitted to explicitly disestablish\
    \ a data connection\n   either of whose channels is active.  If the session is\
    \ terminated by\n   the breaking of the control connection, all file handles become\n\
    \   meaningless, and the server must close all data connections known to\n   it\
    \ and close-abort all files opened on behalf of the user during the\n   dialogue.\n\
    \   In the Symbolics implementation, the user side disestablishes data\n   connections\
    \ that have not been used for a long time, such as twenty\n   minutes or so.\n\
    \   For more information about data connections:  See the section \"NFILE\n  \
    \ Control and Data Connections\", section 4.\n"
- title: 9.  NFILE RESYNCHRONIZATION PROCEDURE
  contents:
  - "9.  NFILE RESYNCHRONIZATION PROCEDURE\n   Ordinarily, the user side sends NFILE\
    \ commands to the server side\n   over the control connection; the server side\
    \ responds to every user\n   command, and file data is transmitted over the data\
    \ channels.  This\n   section describes a resynchronization procedure that takes\
    \ place when\n   something disturbs the usual course of events.\n   First, if\
    \ the server side aborts while sending or receiving data,\n   nothing can be done\
    \ to salvage the connection between the two hosts.\n   The control connection\
    \ and any data channels associated with this\n   connection are broken.  This\
    \ happens rarely, if at all.\n   It is not unusual for the user side to abort\
    \ file operations, either\n   commands or data transfer.  On a Symbolics computer,\
    \ the user can do\n   this by pressing CONTROL-ABORT.  An important aspect of\
    \ any file\n   protocol is the way it handles the situation when the user side\n\
    \   aborts file operations.\n   An NFILE user side reacts to user side aborts\
    \ by immediately marking\n   the connection unsafe.  When a control connection\
    \ is unsafe, it must\n   be resynchronized before it can be used again.  Data\
    \ channels can\n   also be marked unsafe, and must also be resynchronized before\
    \ further\n   use.  The resynchronization process rids the connection (whether\n\
    \   control or data connection) of bytes of data that are now unwanted,\n   and\
    \ thus cleans up the channel so it can be used again.\n   The resynchronization\
    \ procedure is somewhat complex, but it fulfills\n   a genuine need.  For those\
    \ interested, a brief design discussion is\n   included as note <3>.\n"
- title: 9.1  NFILE Control Connection Resynchronization
  contents:
  - "9.1  NFILE Control Connection Resynchronization\n   NFILE requires any unsafe\
    \ control connection to undergo a\n   resynchronization procedure before further\
    \ use.  Therefore, the\n   resynchronization does not necessarily occur immediately\
    \ after the\n   control connection is marked unsafe.  The user side initiates\
    \ the\n   control connection resynchronization when another operation on the\n\
    \   control connection is attempted.\n   A \"mark\" is defined in the context\
    \ of Byte Stream with Mark:  See the\n   section \"Discussion of Byte Stream with\
    \ Mark\", section 12.1.\n   USER SIDE STEPS:  CONTROL CONNECTION RESYNCHRONIZATION\n\
    \       1. The user side sends a mark over the control connection to\n       \
    \   the server.\n       2. The user side sends the ASCII characters USER-RESYNC-DUMMY\n\
    \          (as a data token) to the server.\n       3. The user side sends a second\
    \ mark to the server.\n       4. The user side declares the control connection\
    \ safe (at the\n          token list level).\n       5. The user side generates\
    \ and sends a unique data token to\n          the server.\n       6. The user\
    \ side then waits, expecting to detect a mark\n          followed by the unique\
    \ data token.  The user side reads and\n          discards all tokens and marks\
    \ until the desired match is\n          found.\n   Once the user side detects\
    \ the mark and unique data token, the\n   control connection has been fully resynchronized,\
    \ and can be used\n   again.\n   SERVER SIDE STEPS:  CONTROL CONNECTION RESYNCHRONIZATION\n\
    \        1. The server side detects a mark.  The server is thus alerted\n    \
    \       that the control connection is unsafe, and that\n           resynchronization\
    \ is in progress.\n        2. The server continues to read data coming from the\
    \ user side\n           until it detects the second mark, and the token following\n\
    \           it.\n        3. The server checks to see if the token following the\
    \ mark is\n           USER-RESYNC-DUMMY.  This rare situation occurs if the user\n\
    \           aborts during the course of the resynchronization itself.\n      \
    \     If so, the server side discards the USER-RESYNC-DUMMY\n           token.\
    \  The control connection is still unsafe, and the\n           user side restarts\
    \ the resynchronization procedure; the\n           server side therefore begins\
    \ at Step 2 again.\n        4. If the token following the mark is not USER-RESYNC-DUMMY\n\
    \           (this is the expected circumstance), the server should have\n    \
    \       received a single data token that is the unique data token\n         \
    \  generated by the user side.\n               a. The server sends a mark to the\
    \ user side.\n               b. The server declares the control connection safe\
    \ (at\n                  the token list level).\n               c. The server\
    \ sends the unique data token to the user\n                  side.\n        5.\
    \ If the server detects something following the mark that was\n           neither\
    \ USER-RESYNC-DUMMY nor a single data token, a\n           protocol error has\
    \ occurred.\n"
- title: 9.2  NFILE Data Connection Resynchronization
  contents:
  - "9.2  NFILE Data Connection Resynchronization\n   The NFILE data channel resynchronization\
    \ procedure is similar to the\n   NFILE control connection resynchronization.\
    \  Both procedures are\n   based on a mark signalling the unsafe condition, then\
    \ a second mark\n   followed by a unique identifier.  One important difference\
    \ between\n   the two procedures is the circumstances in which they occur.  Control\n\
    \   connections are put into unsafe states only when the user aborts\n   during\
    \ control connection I/O operations.  Data channels are made\n   unsafe by a larger\
    \ set of circumstances:\n       - User aborts occur during the file protocol operations\
    \ that\n         assign and deassign data channels.  This is the most common\n\
    \         cause of data channels becoming unsafe.\n       - A server receives\
    \ a CLOSE command (with abort-p supplied as\n         Boolean truth) specifying\
    \ an open file that has not finished\n         transmitting data.  That is, file\
    \ reading is aborted.\n       - The ABORT command is issued, causing data channels\
    \ to be\n         made unsafe.\n       - The FILEPOS command is issued, causing\
    \ the input data\n         channel to become unsafe.\n   The resynchronization\
    \ clears the data channel of unwanted data from\n   aborted operations and puts\
    \ the data channel in a known state.  The\n   data channel resynchronization procedure\
    \ is invoked when the user\n   side gives the RESYNCHRONIZE-DATA-CHANNEL command\
    \ over the control\n   connection.\n   The following policies can be used to improve\
    \ response time, but are\n   not required by the NFILE protocol:  The user side\
    \ can initiate\n   resynchronization only if it needs the data channel, having\
    \ first\n   tried to use a free data channel that does not require\n   resynchronization.\
    \  Also, the user side can periodically\n   resynchronize all unsafe data channels.\n\
    \   In giving the RESYNCHRONIZE-DATA-CHANNEL command, the user side\n   indicates\
    \ which data channel should be resynchronized.  Data channels\n   are unidirectional,\
    \ which means that depending on the direction\n   (either input or output) of\
    \ the data channel, either the user side or\n   the server side sends the resynchronization\
    \ data.  This is another\n   difference from the resynchronization of the control\
    \ connection, in\n   which the resynchronization data is always sent by the user\
    \ side.\n   The resynchronization steps for input data channels are different\n\
    \   than the steps for output data channels.\n   INPUT DATA CHANNEL RESYNCHRONIZATION\n\
    \      1. The user side gives the RESYNCHRONIZE-DATA-CHANNEL command\n       \
    \  on the control connection, with only one argument, the\n         handle of\
    \ the data channel to be resynchronized.\n      2. The server side of the data\
    \ channel generates a unique\n         identifier, and sends that data token in\
    \ its regular\n         command response to the user side.\n      3. The server\
    \ side sends a mark over the data channel.\n      4. The server side sends the\
    \ unique identifier token over the\n         data channel.\n      5. The user\
    \ side reads until it detects a mark followed by the\n         unique identifier\
    \ token.  The resynchronization is then\n         complete.  The data channel\
    \ is no longer in an unsafe\n         state.\n   OUTPUT DATA CHANNEL RESYNCHRONIZATION\n\
    \      1. The user side gives the RESYNCHRONIZE-DATA-CHANNEL command\n       \
    \  on the control connection, with two arguments: the handle\n         of the\
    \ data channel to be resynchronized, and a unique\n         identifier that it\
    \ has just generated.\n      2. The user side of the data channel sends a mark.\n\
    \      3. The user side of the data channel sends a dummy identifier\n       \
    \  token.  The dummy identifier can be any token that the\n         server could\
    \ not interpret as being the unique identifier.\n         One suggestion is the\
    \ data token DUMMY-IDENTIFIER.\n      4. The server side of the data channel was\
    \ alerted by the\n         RESYNCHRONIZE-DATA-CHANNEL command that resynchronization\n\
    \         is in progress.  The server side now reads the data,\n         seeking\
    \ the first mark.\n      5. The server side reads and discards the first mark\
    \ and the\n         dummy identifier.\n      6. The user side sends a second mark.\n\
    \      7. The user side sends the unique identifier.\n      8. The server side\
    \ recognizes the mark and the unique\n         identifier that follows, and the\
    \ resynchronization is\n         complete.  The data channel is no longer in the\
    \ unsafe\n         state.\n"
- title: 10.  NFILE ERRORS AND NOTIFICATIONS
  contents:
  - "10.  NFILE ERRORS AND NOTIFICATIONS\n   NFILE recognizes two types of errors:\
    \  command response errors and\n   asynchronous errors.  In addition to errors,\
    \ NFILE supports\n   notifications.\n   Command response errors:\n       - Signify\
    \ an error that prevented the successful completion of\n         the command;\
    \ when such an error occurs, a command response\n         error is sent instead\
    \ of a normal command response.\n       - Occur frequently in normal operations\n\
    \   Asynchronous errors:\n       - Are not related to any specific command\n \
    \      - Are associated with an erring data channel\n       - Typically indicate\
    \ a problem in the transfer, such as\n         running out of disk space or allocation,\
    \ or an unreadable\n         disk record\n       - Occur rarely in normal operations\n\
    \   Notifications:\n       - Are not associated with an error\n       - Are sent\
    \ at the server's discretion\n       - Provide general information, such as a\
    \ warning that the\n         system is going down\n"
- title: 10.1  Notifications From the NFILE Server
  contents:
  - "10.1  Notifications From the NFILE Server\n   The NFILE server can send asynchronous\
    \ notifications to the user side\n   over the control connection.  The text of\
    \ the notification contains\n   information of interest to the person using NFILE,\
    \ such as a warning\n   that the server's operating system will be going down\
    \ soon.\n   Notifications can come from the server side at any time that the\n\
    \   server is not sending something else.\n   The format of NFILE notifications\
    \ is:\n             (NOTIFICATION \"\" text)\n   The empty string \"\" takes the\
    \ place of a transaction identifier.\n   Notifications are initiated by the server,\
    \ and are not associated\n   with any transaction originated by the user side.n\n"
- title: 10.2  NFILE Command Response Errors
  contents:
  - "10.2  NFILE Command Response Errors\n   When an error prevents the successful\
    \ completion of an NFILE command,\n   a command response error is sent instead\
    \ of the normal command\n   response.  A normal command response indicates success;\
    \ a command\n   response error indicates failure of the command.\n   NFILE command\
    \ response errors are sent from the server to the user\n   across the control\
    \ connection as top-level token lists, in this\n   format:\n             (ERROR\
    \ tid three-letter-code error-vars message)\n   ERROR is a keyword.  The tid is\
    \ the transaction identifier of the\n   command that encountered this error. \
    \ The arguments three-letter-\n   code, error-vars, and message are all required.\n\
    \   The three-letter-code provides the information on what kind of an\n   error\
    \ was encountered.  For a table of the three-letter codes and\n   their meanings:\
    \  See the section \"NFILE Three-letter Error Codes\",\n   section 10.4.\n   message\
    \ is a string that is displayed to the human user of the\n   protocol.\n   error-vars\
    \ is a keyword/value list.  The three possible keywords are:\n   PATHNAME, OPERATION,\
    \ and NEW-PATHNAME.  Before transmitting an error,\n   the server looks at the\
    \ type of error to see if it can easily\n   determine the value of any of the\
    \ keywords.  If so, the server\n   includes the keyword/value pair in its error.\
    \  If not, the\n   keyword/value pair is omitted.  The value associated with OPERATION\n\
    \   is the keyword naming the NFILE command that failed.  The values\n   associated\
    \ with PATHNAME and NEW-PATHNAME are strings in the full\n   pathname syntax of\
    \ the server host.\n   For example, suppose the server on a file system with hierarchical\n\
    \   directories could not access a file because its containing directory\n   did\
    \ not exist.  The command error response would use the PATHNAME\n   keyword to\
    \ indicate the first directory level that did not exist,\n   instead of the full\
    \ pathname which was supplied as the command\n   argument.  This gives the user\
    \ side valuable information that it\n   otherwise would not have known.\n"
- title: 10.3  NFILE Asynchronous Errors
  contents:
  - "10.3  NFILE Asynchronous Errors\n   When a data channel process, in either direction,\
    \ encounters an error\n   condition, the server sends an asynchronous error description.\
    \ An\n   asynchronous error description consists of a top-level token list.\n\
    \   Typically, asynchronous errors indicate error conditions in the\n   transfer,\
    \ such as running out of disk space or allocation, or a\n   unreadable disk record.\n\
    \   The format of asynchronous error descriptions is:\n         (ASYNC-ERROR handle\
    \ three-letter-code error-vars message)\n   ASYNC-ERROR is a keyword.  The handle\
    \ argument identifies the erring\n   data channel.  The arguments three-letter-code,\
    \ error-vars, and\n   message are all required.  Their meanings are the same as\
    \ in NFILE\n   command error responses: See the section \"NFILE Command Response\n\
    \   Errors\", section 10.2.\n   When the server detects an asynchronous error\
    \ on an input data\n   channel, the server sends an asynchronous error description\
    \ on that\n   data channel itself.  When an asynchronous error occurs on an output\n\
    \   data channel, the asynchronous error description is sent on the\n   control\
    \ connection.\n   Some asynchronous errors are restartable.  In this context,\n\
    \   restartable means it makes sense to try to resume the operation.  One\n  \
    \ example of a restartable error is an attempt to write a file to a\n   file system\
    \ that is out of room.  The server side indicates whether\n   an asynchronous\
    \ error is restartable by prepending the keyword\n   RESTARTABLE and the associated\
    \ value Boolean truth to the error-vars\n   list.  To proceed from a restartable\
    \ error, the user side sends a\n   CONTINUE command over the control connection.\n\
    \   On any asynchronous error, either input or output, the data channel\n   on\
    \ the server side enters an \"asynchronous error outstanding\" state.\n   The\
    \ server can exit that state in one of two ways:  by receiving a\n   CONTINUE\
    \ command or a CLOSE command with the abort-p argument\n   supplied as Boolean\
    \ truth.\n   On a normal CLOSE (not a close-abort), the server side checks the\n\
    \   channel it was requested to close.  If an asynchronous error\n   description\
    \ has been sent on the data channel, but not yet processed\n   by CONTINUE, the\
    \ server side does not close the channel, but sends a\n   command error response.\
    \  The same thing happens on a FINISH command\n   received on a channel that has\
    \ an asynchronous error pending.  In\n   both cases, the three-letter code included\
    \ in the command error\n   response is EPC, for Error Pending on Channel.\n"
- title: 10.4  NFILE Three-letter Error Codes
  contents:
  - "10.4  NFILE Three-letter Error Codes\n   Usually the server's operating system\
    \ provides some description of an\n   error that occurs.  NFILE has a mechanism\
    \ for conveying that\n   information to the user side.  Upon detecting an error,\
    \ the NFILE\n   server should characterize the error by choosing the three-letter\n\
    \   code that best describes the error.  The three-letter code is an\n   argument\
    \ in both the command response error and asynchronous error\n   messages from\
    \ the server to the user.\n   Each of the NFILE three-letter codes represents\
    \ some system error.\n   The set of codes enables all operating systems to use\
    \ one error-\n   reporting mechanism.  Some operating systems will never encounter\n\
    \   certain of the error conditions.\n   Some errors fit logically into two error\
    \ codes.  For example, suppose\n   the server could not delete a file because\
    \ the file was not found.\n   This error could be considered either CDF (Cannot\
    \ Delete File) or FNF\n   (File Not Found).  In this case, File Not Found gives\
    \ more specific\n   and valuable information than Cannot Delete File.  Since the\
    \ protocol\n   does not allow more than one error code to be reported when an\
    \ error\n   occurs, the server must choose the most appropriate error code, given\n\
    \   the information available to it from the operating system.\n   This is the\
    \ set of three-letter codes:\n     ACC   Access error.  This indicates a protection-violation\
    \ error.\n     ATD   Incorrect access to directory.  A directory could not be\n\
    \           accessed because the user's access rights to it did not\n        \
    \   permit this type of access.\n     ATF   Incorrect access to file.  A file\
    \ could not be accessed\n           because the user's access rights to it did\
    \ not permit this\n           type of access.\n     BUG   File system bug.  This\
    \ includes all protocol violations\n           detected by the server, as well\
    \ as by the host file system.\n     CCD   Cannot create directory.  An error occurred\
    \ in attempting to\n           create a directory.\n     CDF   Cannot delete file.\
    \  The file system reported that it cannot\n           delete a file.\n     CCL\
    \   Cannot create link.  An error occurred in attempting to\n           create\
    \ a link.\n     CIR   Circular link.  An operation was attempted on a pathname\
    \ that\n           designates a link that eventually links back to itself.\n \
    \    CRF   Cannot rename file.  An error occurred in attempting to\n         \
    \  rename a file.\n     CSP   Cannot set property.  An error occurred in attempting\
    \ to\n           change the properties of a file.  This could mean that you\n\
    \           tried to set a property that only the file system is allowed\n   \
    \        to set, or a property that is not defined on this type of\n         \
    \  file system.\n     DAE   Directory already exists.  A directory could not be\
    \ created\n           because a directory or file of this name already exists.\n\
    \     DAT   Data error.  The file system contains unreadable data.  This\n   \
    \        could mean data errors detected by hardware or inconsistent\n       \
    \    data inside the file system.\n     DEV   Device not found.  The device of\
    \ the file was not found or\n           does not exist.\n     DND   \"Do Not Delete\"\
    \ flag set.  An attempt was made to delete a\n           file that is marked by\
    \ a \"Do Not Delete\" flag.\n     DNE   Directory not empty.  An invalid deletion\
    \ of a nonempty\n           directory was attempted.\n     DNF   Directory not\
    \ found.  The directory was not found or does not\n           exist.  This refers\
    \ specifically to the containing directory;\n           if you are trying to access\
    \ a directory, and the actual\n           directory you are trying to access is\
    \ not found, FNF (for\n           File Not Found) should be indicated instead.\n\
    \     EPC   Error pending on channel.  The server cannot close the\n         \
    \  channel in attempting to close or finish the channel.\n     FAE   File already\
    \ exists.  The file could not be created because a\n           file or directory\
    \ of this name already exists.\n     FNF   File not found.  The file was not found\
    \ in the containing\n           directory.  The TOPS-20 and TENEX \"no such file\
    \ type\" and \"no\n           such file version\" errors should also report this\
    \ condition.\n     FOO   File open for output.  Opening a file that was already\
    \ opened\n           for output was attempted.\n     FOR   Filepos out of range.\
    \  Setting the file pointer past the\n           end-of-file position or to a\
    \ negative position was attempted.\n     FTB   File too big.  File is larger than\
    \ the maximum file size\n           supported by the file system.\n     HNA  \
    \  Host not available The file server or file system is\n           intentionally\
    \ denying service to user.  This does not mean\n           that the network connection\
    \ failed; it means that the file\n           system is explicitly not available.\n\
    \     IBS    Invalid byte size.  The value of the \"byte size\" option was\n \
    \          not valid.\n     ICO   Inconsistent options.  Some of the options given\
    \ in this\n           operation are inconsistent with others.\n     IOD   Invalid\
    \ operation for directory.  The specified operation is\n           invalid for\
    \ directories, and the given pathname specifies a\n           directory, in directory\
    \ pathname as file format.\n     IOL   Invalid operation for link.  The specified\
    \ operation is\n           invalid for links, and this pathname is the name of\
    \ a link.\n     IP?   Invalid password.  The specified password was invalid.\n\
    \     IPS   Invalid pathname syntax.  This includes all invalid pathname\n   \
    \        syntax errors.\n     IPV   Invalid property value.  The new value provided\
    \ for the\n           property is invalid.\n     IWC   Invalid wildcard.  The\
    \ pathname is not a valid wildcard\n           pathname.\n     LCK   File locked.\
    \  The file is locked.  It cannot be accessed,\n           possibly because it\
    \ is in use by some other process.\n     LIP   Login problems.  A problem was\
    \ encountered while trying to\n           log in to the file system.\n     MSC\
    \   Miscellaneous problems.\n     NAV   Not available.  The file or device exists\
    \ but is not\n           available.  Typically, the disk pack is not mounted on\
    \ a\n           drive, the drive is broken, or the like.  Operator\n         \
    \  intervention is probably required to fix the problem, but\n           retrying\
    \ the operation is likely to succeed after the problem\n           is solved.\n\
    \     NER   Not enough resources.  For example, a system limit on the\n      \
    \     number of open files or network connections has been reached.\n     NET\
    \   Network problem.  The file server had some sort of trouble\n           trying\
    \ to create a new data connection, or perform some other\n           network operation,\
    \ and was unable to do so.\n     NFS   No file system.  The file system was not\
    \ available.  For\n           example, this host does not have any file systems,\
    \ or this\n           host's file system cannot be initialized or accessed for\
    \ some\n           reason, or the file system simply does not exist.\n     NLI\
    \   Not logged in.  A file operation was attempted before logging\n          \
    \ in.  Normally the file system interface always logs in before\n           doing\
    \ any operation, but this problem can occur in certain\n           unusual cases\
    \ in which logging in has been aborted.\n     NMR   No more room.  The file system\
    \ is out of room.  This can mean\n           any of several things:\n        \
    \              - The entire file system is full.\n                      - The\
    \ particular volume involved is full.\n                      - The particular\
    \ directory involved is full.\n                      - The user's allocated quota\
    \ has been exceeded.\n     RAD   Rename across directories.  The devices or directories\
    \ of the\n           initial and target pathnames are not the same, but on this\n\
    \           file system they are required to be.\n     REF   Rename to existing\
    \ file.  The target name of a rename\n           operation is the name of a file\
    \ that already exists.\n     UKC   Unknown operation. An unsupported file system\
    \ operation was\n           attempted, or an unsupported command was attempted.\n\
    \     UKP   Unknown property.  The property is unknown.\n     UNK   Unknown user.\
    \  The specified user name is unknown to this\n           host.\n     UUO   Unimplemented\
    \ option.  An option to a command is not\n           implemented.\n     WKF  \
    \ Wrong kind of file.  This includes errors in which an invalid\n           operation\
    \ for a file, directory, or link was attempted.\n     WNA   Wildcard not allowed.\n"
- title: 11.  TOKEN LIST TRANSPORT LAYER
  contents:
  - "11.  TOKEN LIST TRANSPORT LAYER\n   PURPOSE:  The Token List Transport Layer\
    \ is a protocol that\n   facilitates the transmission of simple structured data,\
    \ such as\n   lists.\n"
- title: 11.1  Introduction to the Token List Transport Layer
  contents:
  - "11.1  Introduction to the Token List Transport Layer\n   The Token List Transport\
    \ Layer is a general-purpose protocol.  The\n   Token List Transport Layer sends\
    \ \"tokens\" through its underlying\n   stream.  Each token usually represents\
    \ a simple quantity, such as a\n   string or integer.\n   Tokens can be organized\
    \ into \"token lists\".  Special tokens are\n   provided to denote the starting\
    \ and ending point of lists.  The token\n   list transport layer differentiates\
    \ between \"top-level token lists\",\n   which are not contained in other lists,\
    \ and \"embedded token lists\",\n   which are contained in other lists.  Using\
    \ lists makes it convenient\n   to send structured records, such as commands and\
    \ command responses of\n   the client protocol.  The top-level token lists provide\
    \ robustness.\n   The Token List Transport Layer is a general term that includes\
    \ two\n   separate but related subjects:  the \"token list stream\" and the\n\
    \   \"token list data stream\".  The token list stream is commonly used for\n\
    \   applications that can easily organize the information to be\n   transmitted\
    \ into tokens and lists.  The token list data stream is\n   more appropriate for\
    \ transmitting a large volume of data that cannot\n   easily be structured into\
    \ tokens and lists, such as file data, which\n   is simply a sequence of characters\
    \ or bytes.\n   The following table illustrates the main differences between token\n\
    \   list streams and token list data streams:\n                     Token List\
    \ Data Stream      Token List Stream\n                     ----------------------\
    \      -----------------\n     Built on:     token list stream           Byte\
    \ Stream with Mark\n     Transmits:    stream data                 tokens, token\
    \ lists\n     Example\n     of use:       NFILE data channels         NFILE control\n\
    \                                               connection\n   NFILE uses the\
    \ the Token List Transport Layer, and provides an\n   excellent example of its\
    \ usefulness.  The NFILE commands and command\n   responses are sent over the\
    \ control connection in a token list\n   stream.  File data is sent across each\
    \ data channel in a token list\n   data stream.\n"
- title: 11.2  Token List Stream
  contents:
  - '11.2  Token List Stream

    '
- title: 11.2.1  Types of Tokens and Token Lists
  contents:
  - "11.2.1  Types of Tokens and Token Lists\n   All numbers in the token list documentation\
    \ are represented in\n   decimal notation.  Bytes are 8 bits long.\n   TYPES OF\
    \ TOKENS\n   Tokens are of the following types:\n            1. Atomic tokens.\n\
    \               Atomic tokens are of the following subtypes:\n              -\
    \ Data tokens.  A data token consists of a sequence of\n                bytes\
    \ with an effectively infinite maximum length.  In\n                some contexts\
    \ a data token represents a string; in\n                other contexts, a data\
    \ token is other arbitrary data.\n                Each data token is preceded\
    \ in the token list stream\n                by a representation of its length\
    \ in bytes.\n                Data tokens that are under 200 bytes long are preceded\n\
    \                by one byte containing their length in bytes.  That\n       \
    \         is, a data token of 34 bytes is preceded by one byte\n             \
    \   of value 34.\n                Data tokens 200 bytes or over are preceded by\
    \ the byte\n                known as PUNCTUATION-LONG, of value 201.  After the\n\
    \                201 comes a four-byte-long number (least significant\n      \
    \          byte first) containing the length of the data token\n             \
    \   that follows.\n              - Numeric tokens.  A sequence of bytes that represent\n\
    \                and encode a nonnegative binary integer.  The largest\n     \
    \           valid integer is 2^63 - 1.\n                Numeric tokens are either\
    \ short integers (less than\n                256) or long integers (greater than\
    \ or equal to 256).\n                Short integers are preceded by the byte known\
    \ as\n                PUNCTUATION-SHORT-INTEGER, of value 206.\n             \
    \   Long integers are begun by PUNCTUATION-LONG-INTEGER,\n                of value\
    \ 207.  One byte follows, containing the length\n                (in bytes) of\
    \ the long integer.  The integer itself is\n                next, least significant\
    \ byte first.\n              - Keyword tokens.  A sequence of bytes that represent\n\
    \                and encode a named identifier of the implemented\n          \
    \      protocol.  Keyword tokens are used by the client\n                protocol\
    \ to convey a name; the only significance of a\n                keyword token\
    \ is in its name.\n                Each keyword is preceded by the byte known\
    \ as\n                PUNCTUATION-KEYWORD, of value 208.  The data token\n   \
    \             following PUNCTUATION-KEYWORD represents the name of\n         \
    \       the keyword as a string.  The characters are in\n                upper-case\
    \ standard ASCII.\n              - Boolean truth.  A special token that represents\
    \ the\n                Boolean truth value.  This token is known as\n        \
    \        BOOLEAN-TRUTH, of value 209 <4>.\n   2. Control tokens.\n   The token\
    \ list stream supports four control tokens to delimit token\n   lists, and one\
    \ padding token.\n               TOP-LEVEL-LIST-BEGIN  202   This control token\n\
    \                                           appears at the start of\n        \
    \                                   each top-level token list.\n             \
    \  TOP-LEVEL-LIST-END    203   This control token\n                          \
    \                 appears at the end of\n                                    \
    \       each top-level token list.\n               LIST-BEGIN            204 \
    \  This control token\n                                           appears at the\
    \ start of\n                                           each embedded token list.\n\
    \               LIST-END              205   This control token\n             \
    \                              appears at the end of\n                       \
    \                    each embedded token list.\n               PUNCTUATION-PAD\
    \       200   This padding token should\n                                    \
    \       be ignored by the token\n                                           list\
    \ stream.  It can be\n                                           sent to fill\
    \ buffers.\n   TOKEN LISTS\n   A token list consists of a sequence of atomic tokens\
    \ or token lists.\n   Token lists are begun and ended by control tokens that delimit\
    \ the\n   token lists.  There are three types of token lists:\n         1. Top-level\
    \ token lists.\n            Top-level token lists begin with TOP-LEVEL-LIST-BEGIN\
    \ and\n            end with TOP-LEVEL-LIST-END.  Top-level token lists are not\n\
    \            contained in other lists.\n         2. Embedded token lists.\n  \
    \          These token lists occur inside other token lists.  They\n         \
    \   begin with LIST-BEGIN and end with LIST-END.\n         3. The empty token\
    \ list.\n            This is a special example of the embedded token list.  In\n\
    \            some contexts, the empty token list represents Boolean\n        \
    \    falsity.  An embedded empty token list is composed of a\n            LIST-BEGIN\
    \ followed immediately by a LIST-END.  A top-level\n            empty token list\
    \ is composed of TOP-LEVEL-LIST-BEGIN\n            followed immediately by TOP-LEVEL-LIST-END.\n"
- title: 11.2.2  Token List Stream Example
  contents:
  - "11.2.2  Token List Stream Example\n   This section contains an example of some\
    \ data that can appear on a\n   token list stream.  The example is a top-level\
    \ token list encoding an\n   NFILE DELETE command.\n   The DELETE command is composed\
    \ of the following pieces:  a TOP-\n   LEVEL-LIST-BEGIN, the keyword DELETE, a\
    \ data token containing the\n   transaction identifier, a LIST-BEGIN, a LIST-END,\
    \ a data token\n   containing a pathname of a file to be deleted, and a TOP-LEVEL-LIST-\n\
    \   END.  This example uses t105 as the transaction identifier, and\n   /usr/max/temp\
    \ as the pathname.\n   All numbers in this section are expressed in decimal notation.\n\
    \   The pieces of the command are displayed here in order:\n            1. TOP-LEVEL-LIST-BEGIN\n\
    \            2. The keyword token whose name is DELETE\n            3. The data\
    \ token containing the characters:  t105\n            4. LIST-BEGIN\n        \
    \    5. LIST-END\n            6. The data token containing the characters:  /usr/max/temp\n\
    \            7. TOP-LEVEL-LIST-END\n   Now, let's translate each piece of the\
    \ command into the bytes that\n   are transmitted through the token list stream.\n\
    \        1. TOP-LEVEL-LIST-BEGIN\n           202     represents TOP-LEVEL-LIST-BEGIN\n\
    \        2. The keyword token whose name is DELETE.\n           A keyword token\
    \ is introduced by PUNCTUATION-KEYWORD, which\n           is represented in the\
    \ token list stream as the byte 208.\n           A data token follows, containing\
    \ the string \"DELETE\".  A\n           data token under 200 bytes long is introduced\
    \ by one byte\n           containing its length in bytes.  The length of this\
    \ data\n           token is 6 bytes.\n           The data token continues with\
    \ the standard ASCII character\n           set representation of each character\
    \ in the string DELETE:\n               208     represents PUNCTUATION-KEYWORD\n\
    \               006     represents the length of this data token\n           \
    \    068     represents \"D\"\n               069     represents \"E\"\n     \
    \          076     represents \"L\"\n               069     represents \"E\"\n\
    \               084     represents \"T\"\n               069     represents \"\
    E\"\n        3. The data token containing the characters:  t105\n           This\
    \ data token is begun by its length in bytes (4), and\n           continues with\
    \ the NFILE character set representation of\n           each character in the\
    \ string:\n               004     represents the length of this data token\n \
    \              116     represents \"t\"\n               049     represents \"\
    1\"\n               048     represents \"0\"\n               053     represents\
    \ \"5\"\n        4. LIST-BEGIN\n               204     represents LIST-BEGIN\n\
    \        5. LIST-END\n               205     represents LIST-END\n        6. The\
    \ data token containing the characters:  /usr/max/temp\n               013   \
    \  represents length of this data token\n               047     represents \"\
    /\"\n               117     represents \"u\"\n               115     represents\
    \ \"s\"\n               114     represents \"r\"\n               047     represents\
    \ \"/\"\n               109     represents \"m\"\n               097     represents\
    \ \"a\"\n               120     represents \"x\"\n               047     represents\
    \ \"/\"\n               116     represents \"t\"\n               101     represents\
    \ \"e\"\n               109     represents \"m\"\n               112     represents\
    \ \"p\"\n        7. TOP-LEVEL-LIST-END\n               203     represents TOP-LEVEL-LIST-END\n"
- title: 11.2.3  Mapping of Lisp Objects to Token List Stream Representation
  contents:
  - "11.2.3  Mapping of Lisp Objects to Token List Stream Representation\n   The Symbolics\
    \ interface to the token list stream sends Lisp objects\n   through the underlying\
    \ Byte Stream with Mark and produces Lisp\n   objects on the other end.  Not all\
    \ Lisp objects can be sent in this\n   way.  For example, compound objects other\
    \ than lists are not handled.\n   An appropriate analogy is the sending and reconstruction\
    \ of list\n   structure via printed representation.  These are the types of objects\n\
    \   that can be sent, and their representations:\n        - Lisp strings are represented\
    \ as data tokens in the NFILE\n          character set.  Only 8-bit strings can\
    \ be sent <5>.\n        - Keyword symbols are represented as keyword tokens. \
    \ Although\n          identifiable and reconstructable as keyword symbols, only\n\
    \          their names are sent.  Any properties, bindings, and the\n        \
    \  like are not sent.\n        - T is represented as BOOLEAN-TRUTH.\n        -\
    \ NIL is represented as the empty token list.\n        - Lists are represented\
    \ as token lists.  Circular lists cannot\n          be sent.  See the footnote\
    \ related to the ambiguity between\n          NIL and the empty list:  See the\
    \ section \"Types of Tokens\n          and Token Lists\", section 11.2.1.\n  \
    \      - Integers are represented as numeric tokens.  Only\n          nonnegative\
    \ integers less than 2^63 can be sent.\n"
- title: 11.2.4  Aborting and the Token List Stream
  contents:
  - "11.2.4  Aborting and the Token List Stream\n   A token list stream accrues the\
    \ benefits of the abort management\n   policy of the Byte Stream with Mark on\
    \ which it is built.  In order\n   to fully realize this benefit, some simple\
    \ rules must be obeyed by\n   any implementation of the token list stream.\n \
    \  The term \"transmission\" means either an atomic token or a complete\n   top-level\
    \ token list. A transmission starts with the control token\n   TOP-LEVEL-BEGIN\
    \ and ends with TOP-LEVEL-END.  The top-level token\n   list can contain embedded\
    \ token lists.\n   The interface that writes to the token list stream must be\
    \ capable of\n   writing the representation of entire transmissions.  When this\n\
    \   interface is called, it must effectively lock the token list stream,\n   and\
    \ exclude access by other processes until the entire transmission\n   has been\
    \ encoded and sent.\n   If the sending is aborted while the stream is locked,\
    \ the stream\n   enters an \"unsafe\" state.  Trying to send data while the stream\
    \ is\n   unsafe signals an error.  The application and the token list stream\n\
    \   must send a mark to cause resynchronization, and allow the token list\n  \
    \ stream to be used again.  When the reading side encounters this mark,\n   it\
    \ resynchronizes itself according to whatever client protocol is in\n   use.\n\
    \   Similarly, the interface that reads from the token list stream must\n   be\
    \ capable of reading entire transmissions.  When this interface is\n   called,\
    \ it must lock the stream, excluding access by other processes\n   until the entire\
    \ transmission has been read.\n   If the reading is aborted while the stream is\
    \ locked, the stream\n   enters an unsafe state.  The only exit from this unsafe\
    \ state is by\n   means of receiving a mark.  When the stream is unsafe, the only\
    \ valid\n   operation that can be performed upon it is \"read and discard all\n\
    \   tokens until a mark is encountered; read and discard that mark;\n   declare\
    \ the stream safe again\".\n   Depending on the client protocol, the receipt of\
    \ a mark might cause\n   the reading side to read for further marks.  NFILE implements\
    \ the\n   resynchronization of token list streams, and serves as a useful\n  \
    \ example: See the section \"NFILE Control Connection\n   Resynchronization\"\
    , section 9.1.\n   The Symbolics implementation provides the two mark-handling\n\
    \   primitives in this way:\n      1. Send token (or list) preceded by a mark.\
    \  When the stream\n         is in the unsafe state (on the output side), this\
    \ is the\n         only permitted output operation (other than closing).\n   \
    \   2. Read through to a mark and read the token (or list)\n         following\
    \ the mark.  When the stream is in the unsafe state\n         (on the input side),\
    \ this is the only permitted input\n         operation (other than closing).\n"
- title: 11.3  Token List Data Stream
  contents:
  - "11.3  Token List Data Stream\n   The token list data stream is a facility to\
    \ transmit stream data\n   through a token list stream.  The token list data stream\
    \ imposes the\n   following protocol on the data transmitted:\n            - Data\
    \ is sent in the format of loose data tokens, not\n              contained in\
    \ token lists.\n            - The keyword token EOF indicates that the end of\
    \ data has\n              been reached.\n            - Token lists can be transmitted\
    \ through the token list\n              data stream.\n            - No loose tokens\
    \ other than data tokens or the keyword\n              token EOF can be sent.\n\
    \            - Boundaries between data tokens are not signification.\n       \
    \       The data is considered to be a continuous stream, with\n             \
    \ the possible exception of marks.\n   The token list data stream is most appropriate\
    \ for sending file data.\n   It is expected (but not required) that its typical\
    \ mode of use is to\n   send a large number of data tokens, with an occasional\
    \ token list.\n   The design intent was that token lists would be used by the\n\
    \   application program to indicate exceptional situations.\n   Data tokens, the\
    \ keyword token EOF, and token lists are defined in\n   the token list stream\
    \ documentation:  See the section \"Types of\n   Tokens and Token Lists\", section\
    \ 11.2.1.\n   The NFILE file protocol provides a good example of the use of token\n\
    \   list data streams.  NFILE sends file data through token list data\n   streams;\
    \ each NFILE data channel is a token list data stream.  Errors\n   such as disk\
    \ errors during the reading of a file are conveyed as\n   token lists through\
    \ the token list data stream.\n"
- title: 12.  BYTE STREAM WITH MARK
  contents:
  - "12.  BYTE STREAM WITH MARK\n   PURPOSE:  Byte Stream with Mark is a simple layer\
    \ of protocol that\n   guarantees that an out-of-band signal can be transmitted\
    \ in the case\n   of program interruption.  Byte Stream with Mark is designed\
    \ to\n   provide end-to-end stream consistency in the face of user program\n \
    \  aborts.\n"
- title: 12.1  Discussion of Byte Stream with Mark
  contents:
  - "12.1  Discussion of Byte Stream with Mark\n   INTRODUCTION\n   Byte Stream with\
    \ Mark is a reliable, bidirectional byte stream with\n   one out-of-band (but\
    \ not out-of-sequence) signal called a \"mark\".\n   The design of Byte Stream\
    \ with Mark ensures that the mark is always\n   recognizable on the receiving\
    \ end.  The Byte Stream with Mark is\n   built on an underlying stream, which\
    \ must support the transmission of\n   8-bit bytes.  Byte Stream with Mark has\
    \ been implemented to run on\n   TCP and Chaos.  Marks are implemented differently\
    \ on the two\n   protocols.\n   Marks are used to resynchronize the stream when\
    \ something has\n   occurred to interrupt normal operations.  For example, an\
    \ application\n   layer sending data over the Byte Stream with Mark can abort\
    \ in the\n   middle of sending that data.  Recovery is handled by sending a mark.\n\
    \   In the context of this document, \"aborting\" is defined as follows:\n   Aborting\
    \ the current execution of a program means to halt that\n   execution and to abandon\
    \ it, never to complete it.  The data\n   representing the state of the execution\
    \ are irrevocably discarded.\n   EXAMPLE OF USE\n   Byte Stream with Mark is the\
    \ layer of protocol underlying NFILE.\n   NFILE uses the marks implemented in\
    \ Byte Stream with Mark to\n   resynchronize control connections or data channels\
    \ whose\n   synchronization has been lost.  For a description of NFILE's use of\n\
    \   marks to resynchronize streams:  See the section \"NFILE\n   Resynchronization\
    \ Procedure\", section 9.\n   BYTE STREAM WITH MARK ON CHAOSNET\n   A mark is\
    \ recognized on Chaosnet by a packet bearing the opcode 201\n   (octal).  There\
    \ is no data in a mark packet, so the data portion of\n   the packet is ignored.\
    \  Byte Stream with Mark transmits all data in\n   packets bearing opcode 200\
    \ (octal).\n   If Byte Stream with Mark is implemented on another (non-Chaos)\
    \ stream\n   that supports opcode-bearing packets, the recommended implementation\n\
    \   is the reservation of an opcode for the mark.\n   BYTE STREAM WITH MARK ON\
    \ TCP:  RECORD MODE\n   The purpose of Byte Stream with Mark is to guarantee that\
    \ marks can\n   always be unambiguously identified.  Therefore, for TCP (and for\
    \ any\n   transport layer that does not implement packets natively) a simple\n\
    \   record stream is imposed on the stream.  The record boundaries serve\n   only\
    \ to distinguish where a mark can occur.  A record consists of a\n   two-byte\
    \ byte count, most significant byte first, followed by that\n   many bytes of\
    \ data.  A byte count of zero is recognized as a mark.\n   Both the sending side\
    \ and the receiving side must rigorously maintain\n   the integrity of the record\
    \ boundaries.  A writer to the stream must\n   never output a byte count without\
    \ that number of data bytes\n   following.  Similarly, a reader of the stream,\
    \ after reading a byte\n   count, has effectively contracted to read that many\
    \ bytes from the\n   encapsulated stream, regardless of whether those bytes are\
    \ requested\n   by the application layer.\n   MAINTAINING RECORD INTEGRITY\n \
    \  This subsection deals with maintaining record integrity on non-Chaos\n   networks.\
    \  Since Chaos implements packets natively, no special care\n   is required to\
    \ maintain record integrity on the Chaos network.\n   The design discussed here\
    \ guarantees record integrity; the underlying\n   stream must guarantee data integrity.\n\
    \   The basic design of Byte Stream with Mark on TCP (and other transport\n  \
    \ layers that do not implement packets natively) is to preserve record\n   integrity\
    \ by putting clearly demarcated, byte-counted records in the\n   natural records\
    \ of the encapsulated stream.  Therefore, when the\n   outer stream requests a\
    \ buffer's worth of file data from the\n   encapsulated stream, it expects to\
    \ receive a buffer containing one\n   entire, ntegral, record of that stream,\
    \ complete with byte count.\n   Because of diverse network implementations on\
    \ different operating\n   systems, the software that implements the encapsulated\
    \ stream might\n   not be able to provide integral record buffers to the Byte\
    \ Stream\n   with Mark implementation.  For example, the writing stream could\
    \ have\n   written records that are much longer than available buffers on the\n\
    \   receiving system.  In this case, a request to read from the\n   encapsulated\
    \ stream returns some buffer or some amount of data\n   representing less than\
    \ an entire Byte Stream with Mark record.  The\n   input subroutine of the Byte\
    \ Stream with Mark implementation must\n   therefore return a region of this (smaller)\
    \ buffer, representing less\n   than the full Byte Stream with Mark record.  Nevertheless,\
    \ the Byte\n   Stream with Mark must extract the count of the full Byte Stream\
    \ with\n   Mark record from the first such buffer of each Byte Stream with Mark\n\
    \   record, and maintain and update this count as succeeding component\n   buffers\
    \ are read.\n   In this case, if the program reading from the Byte Stream with\
    \ Mark\n   aborts while reading data, the implementation of Byte Stream with\n\
    \   Mark must continue to read through the remaining buffers of the Byte\n   Stream\
    \ with Mark record that has been subdivided in this fashion.\n   The user side\
    \ program will have determined that an abort has\n   occurred, and will request\
    \ the Byte Stream with Mark to read up to\n   and through the next mark.  The\
    \ Byte Stream with Mark will have\n   processed a fractional record, and must\
    \ discard the remaining buffers\n   of the record now being read.\n"
- title: 12.2  Byte Stream with Mark Abortable States
  contents:
  - "12.2  Byte Stream with Mark Abortable States\n   Byte Stream with Mark is designed\
    \ to provide end-to-end stream\n   consistency in the face of user program aborts.\
    \  This section\n   describes user program aborts, and how Byte Stream with Mark\
    \ handles\n   them.  In the context of this document, \"aborting\" is defined\
    \ as\n   follows:  Aborting the current execution of a program means to halt\n\
    \   that execution and to abandon it, never to complete it.  The data\n   representing\
    \ the state of the execution are irrevocably discarded.\n   USER PROGRAM ABORTS\
    \ AND I/O STREAMS\n   Aborting the execution of the code that manipulates I/O\
    \ streams, in\n   general, poses significant problems.  Given that a stream is\
    \ a static\n   data object, and is intended to be used over and over again, aborting\n\
    \   the execution of any routine manipulating a stream can leave it in an\n  \
    \ inconsistent, unusable state.\n   Many operating systems solve this problem\
    \ by manipulating a large\n   subset of streams within the confines of the supervisor\
    \ or executive\n   program, which is not vulnerable to aborts, short of system\
    \ or\n   network failure.  Nevertheless, the need still exists to implement\n\
    \   streams outside of the boundaries of the supervisor.  Furthermore,\n   the\
    \ Symbolics computer environment has no supervisor or executive\n   program, and\
    \ is thus vulnerable to aborts everywhere.\n   BYTE STREAM WITH MARK HANDLING\
    \ OF USER PROGRAM ABORTS\n   Byte Stream with Mark is designed to be nearly impervious\
    \ to the\n   aborting of programs using it.  Its design is based on careful\n\
    \   analysis of all possible states of the stream, and of the effect of\n   aborts\
    \ of the programs using the stream in each of these states.\n   This section provides\
    \ that analysis.\n   A \"transmission\" is a collection of user data sent by the\
    \ application\n   level through the Byte Stream with Mark whose end is well-defined,\n\
    \   once its start has been recognized.  For instance, the token list\n   stream,\
    \ when using Byte Stream with Mark, sends token lists.  When a\n   TOP-LEVEL-LIST-BEGIN\
    \ has been sent, the containing transmission is\n   not considered complete until\
    \ the corresponding TOP-LEVEL-LIST-END is\n   read.  See the section \"Token List\
    \ Transport Layer\", section 11.\n   The following cases are possible states of\
    \ the stream when an abort\n   occurs:\n         1. Abort occurs when the user\
    \ program is not manipulating the\n            stream.\n            This case\
    \ presents no problem.\n         2. Abort occurs after a transmission has been\
    \ partially sent,\n            at a packet or record boundary.\n            This\
    \ implies that the datum that would indicate the\n            successful complete\
    \ sending of that transmission has been\n            not yet been sent.\n    \
    \        The Byte Stream with Mark state is consistent, but the\n            application\
    \ level state is not.  The application level must\n            determine that\
    \ the execution of the code composing and\n            sending its transmission\
    \ was, in fact, aborted, and\n            initiate resynchronization via marks.\n\
    \            The receiving side must be careful not to act upon a\n          \
    \  transmission (that is, to perform any action or side\n            effect) until\
    \ the transmission has been successfully\n            received in entirety.  This\
    \ protects the user program from\n            the possibility that an abort can\
    \ occur after a\n            transmission has been partially sent.\n         3.\
    \ Abort occurs during the sending or receiving of a record.\n            This\
    \ is the most vulnerable state of the mechanism.  This\n            case does\
    \ not occur on packet-oriented media; it is\n            subsumed by the next\
    \ case.\n            This case is handled by minimizing the extent of this\n \
    \           window, and killing the connection when and if the\n            situation\
    \ is detected.  Depending on the operating system\n            involved, this\
    \ window could be minimized by using\n            interrupt-disabling mechanisms,\
    \ auxiliary processes or\n            tasks, or some other technique.\n      \
    \      For buffered streams, input and output waiting can be done\n          \
    \  in consistent states, thus minimizing the amount of time\n            manipulating\
    \ the actual encapsulated stream.  For\n            unbuffered streams, a lot\
    \ of time can be spent in this\n            window.  It is expected that unbuffered\
    \ streams will be\n            exceedingly uncommon.  Nevertheless, the implementation\
    \ of\n            Byte Stream with Mark must detect this case.\n         4. Abort\
    \ occurs during the sending or receiving of fundamental\n            units of\
    \ the lowest-level underlying stream (packets,\n            buffers, or bytes).\n\
    \            This case is usually handled by inhibiting interrupts, or\n     \
    \       other forms of masking, in the code implementing the\n            encapsulated\
    \ stream, since no waiting is possible at\n            unexpected times.\n"
- title: 13.  POSSIBLE FUTURE EXTENSIONS
  contents:
  - "13.  POSSIBLE FUTURE EXTENSIONS\n   NFILE was designed to be extended as the\
    \ needs of its clients grow,\n   or as new clients with different needs appear.\
    \  Currently it meets\n   the needs of the Symbolics Genera 7.0 operating system,\
    \ although its\n   design is intentionally general.  If users of other operating\
    \ systems\n   identify new features that would be useful, they could be added\
    \ to\n   NFILE.  This section illustrates some areas areas where the design of\n\
    \   NFILE intentionally accommodates extensions.\n         - The NFILE protocol\
    \ encodes commands and responses as text,\n           rather than using prearranged\
    \ numbers.  This means that new\n           commands and responses can be added\
    \ without having to obtain\n           a new number from a central registry.\n\
    \         - The Token List Transport Layer provides a general substrate\n    \
    \       for the value-transmission portion of network protocols.  In\n       \
    \    fact, it has been used at Symbolics for other protocols\n           besides\
    \ NFILE.  The Token List Transport Layer could\n           conveniently be extended\
    \ to support transmission of other\n           types of values besides those it\
    \ currently supports.\n         - The character set to be used for file transfer\
    \ could be made\n           negotiable.\n         - The command character set\
    \ could be made negotiable.\n           Currently there is no negotiation sequence,\
    \ but one could be\n           added.\n         - Greater support for more complex\
    \ file organizations could be\n           added, such as record files, databases,\
    \ and so on.  This\n           could be an extension to the direct access mode\
    \ facility.\n         - Currently, the LOGIN command allows the user side to inform\n\
    \           the server which version of NFILE it is running.  This\n         \
    \  feature is included in NFILE so that a server can continue\n           to support\
    \ older versions of the protocol even after new,\n           extended versions\
    \ have been implemented.  However, the\n           specification is currently\
    \ somewhat vague as to how the\n           server can make use of the version.\n\
    \         - NFILE is not restricted to using TCP or Chaos as its\n           underlying\
    \ protocol.  NFILE can be built on any byte stream\n           protocol that supports\
    \ reliable transmission of 8-bit bytes\n           and multiple connections.\n\
    \   In addition to the possible future extensions, we would like to\n   mention\
    \ a known limitation of NFILE.\n   Currently NFILE requires multiple connections\
    \ for a single session.\n   That is, the control connection must be separate from\
    \ the data\n   connections.  If NFILE is to be used over a telephone, this\n \
    \  requirement poses an inconvenient restriction.  It is possible to\n   implement\
    \ a multiplexing scheme as a level between NFILE and the\n   communication medium.\n\
    \                                APPENDIX A\n                          NORMAL\
    \ TRANSLATION MODE\n   NORMAL translation mode guarantees the following:\n   \
    \      - A file containing characters in the NFILE character set can\n       \
    \    be written to any NFILE server and read back intact\n           (containing\
    \ the same characters).\n         - A file written by NFILE should not appear\
    \ as \"foreign\" to a\n           server operating system unless the file contains\
    \ NFILE's\n           extended characters.  That is, a server file that uses only\n\
    \           the subset of the NFILE character set limited to standard\n      \
    \     ASCII characters (the 95 printing characters, and the native\n         \
    \  representation of return, linefeed, page, backspace, rubout,\n           and\
    \ tab) can be read and written, with the result being the\n           same data\
    \ in NFILE characters as exists in server\n           characters.\n   In this\
    \ section, all numbers designating values of character codes\n   are to be interpreted\
    \ in octal.  The notation \"x in c1..c2\" means\n   \"for all character codes\
    \ x such that c1 <= x <= c2.\"\n   The NFILE character set is an extension of\
    \ standard ASCII.  The 95\n   ASCII printing characters have the same numerical\
    \ codes in the NFILE\n   character set.  Five ASCII non-printing characters have\
    \ counterparts\n   in the NFILE character set, as shown in the following table.\
    \  The\n   NFILE character set includes a single Return character, rather than\n\
    \   the carriage-return line-feed sequence typically used in ASCII.  The\n   NFILE\
    \ character set does not include the ASCII control characters,\n   other than\
    \ the five shown in the following table, but does include\n   some additional\
    \ printing and formatting characters that have no\n   counterparts in ASCII.\n\
    \                             NFILE     Standard ASCII\n         Rubout:     \
    \        207       177\n         Backspace:          210       10\n         Tab:\
    \                211       11\n         Linefeed:           212       12\n   \
    \      Page:               214       14\n   Note that the NFILE Return character\
    \ is of code 215.  This character\n   includes \"going to the next line\".  This\
    \ is a notable difference from\n   the convention used in PDP-10 ASCII in which\
    \ lines are ended by a\n   pair of characters, \"carriage return\" and \"line\
    \ feed\".\n   NORMAL TRANSLATION TO UNIX SERVERS\n   The translation given in\
    \ this table is appropriate for use by UNIX\n   servers, or other servers that\
    \ use 8-bit bytes to store ASCII\n   characters.  Machines with 8-bit bytes usually\
    \ place the extra NFILE\n   characters in the top half of their character set.\n\
    \       TABLE 1.   TRANSLATIONS FROM NFILE CHARACTERS TO UNIX CHARACTERS\n   \
    \         NFILE character       UNIX character\n            x in 000..007    \
    \     x\n            x in 010..015         x + 200\n            x in 016..176\
    \         x\n            177                   377\n            x in 200..207\
    \         x\n            x in 210..211         x - 200\n            212      \
    \             015\n            x in 213..214         x - 200\n            215\
    \                   012\n            x in 216..376         x\n            377\
    \                   177\n       TABLE 2.   TRANSLATIONS FROM UNIX CHARACTERS TO\
    \ NFILE CHARACTERS\n            UNIX character        NFILE character\n      \
    \      x in 000..007         x\n            x in 010..011         x + 200\n  \
    \          012                   215\n            x in 013..014         x + 200\n\
    \            015                   212\n            x in 016..176         x\n\
    \            177                   377\n            x in 200..207         x\n\
    \            x in 210..215         x - 200\n            x in 216..376        \
    \ x\n            377                   177\n   NORMAL TRANSLATION TO PDP-10 FAMILY\
    \ SERVERS\n   The translation given in this table is appropriate for use by PDP-10\n\
    \   family servers, or other servers that use 7-bit bytes to store ASCII\n   characters.\
    \  On the PDP-10 the sequence CRLF, 015 012, represents a\n   new line.\n   The\
    \ mechanism for this translation on machines with 7-bit bytes is to\n   use the\
    \ RUBOUT character (octal code 177) as an escape character.\n         TABLE 3.\
    \   TRANSLATIONS FROM NFILE TO PDP-10 CHARACTERS\n            NFILE character\
    \       PDP-10 character(s)\n            x in 000..007         x\n           \
    \ x in 010..012         177 x\n            013                   013\n       \
    \     x in 014..015         177 x\n            x in 016..176         x\n     \
    \       177                   177 177\n            x in 200..207         177 x\
    \ - 200\n            x in 210..212         x - 200\n            213          \
    \         177 013\n            214                   014\n            215    \
    \               015 012\n            x in 216..376         177 x - 200\n     \
    \       377                   no corresponding code\n   These tables might seem\
    \ confusing at first, but there are some\n   general rules about it that should\
    \ make it clearer.  First, NFILE\n   characters in the range 000..177 are generally\
    \ represented as\n   themselves, and x in 200..377 is generally represented as\
    \ 177\n   followed by x - 200.  That is, 177 is used to quote the second 200\n\
    \   NFILE characters.  It was deemed that 177 is a more useful and common\n  \
    \ character than 377, so 177 177 means 177, and there is no way to\n   describe\
    \ 377 with PDP-10 ASCII characters.  In the NFILE character\n   set, the formatting\
    \ control characters appear offset up by 200 with\n   respect to standard ASCII.\
    \  This explains why the preferred mode of\n   expressing 210 (backspace) is 010,\
    \ and 010 turns into 177 010.  The\n   same reasoning applies to 211 (Tab), 212\
    \ (Linefeed), 214 (Formfeed),\n   and 215 (Return).\n   More special care is needed\
    \ for the Return character, which is the\n   mapping of the system-dependent representation\
    \ of \"the start of a new\n   line\".  The NFILE Return (215) is equivalent to\
    \ 015 012 (CRLF) in\n   some ASCII systems.  In the NFILE character set there\
    \ is no\n   representation\n     TABLE 4.   TRANSLATIONS FROM PDP-10 CHARACTERS\
    \ TO NFILE CHARACTERS\n            PDP-10 character      NFILE character\n   \
    \         x in 000..007         x\n            x in 010..012         x + 200\n\
    \            013                   013\n            014                   214\n\
    \            015 012               215\n            015 not-012           115\n\
    \            x in 016..176         x\n            177 x in 000..007     x + 200\n\
    \            177 x in 010..012     x\n            177 013               213\n\
    \            177 x in 014..015     x\n            177 x in 016..176     x + 200\n\
    \            177 177               177\n   of a carriage that doesn't go to a\
    \ new line, so if there is one in a\n   server file, it must be translated to\
    \ something else.  When\n   converting ASCII characters to NFILE characters, an\
    \ 015 followed by\n   an 012 therefore turns into a 215.  A stray CR is arbitrarily\n\
    \   translated into a single M (115).\n                                APPENDIX\
    \ B\n                           RAW TRANSLATION MODE\n   RAW mode means no translation\
    \ should be performed.  In RAW mode the\n   server operating system should treat\
    \ the file as a character file and\n   use the same data formatting that would\
    \ be appropriate for a\n   character file, but transfer the actual binary values\
    \ of the\n   character codes.\n                                APPENDIX C\n  \
    \                     SUPER-IMAGE TRANSLATION MODE\n   SUPER-IMAGE mode is intended\
    \ for use by PDP-10 family machines only.\n   It is included largely as an illustration\
    \ of a system-dependent\n   extension.  A server machine that has 8-bit bytes\
    \ should treat\n   SUPER-IMAGE mode the same as NORMAL mode.\n   In this section,\
    \ all numbers designating values of character codes\n   are to be interpreted\
    \ in octal.  The notation \"x in c1..c2\" means\n   \"for all character codes\
    \ x such that c1 <= x <= c2.\"\n   SUPER-IMAGE mode suppresses the use of the\
    \ 177 character as an escape\n   character.  Character translation should be done\
    \ as in NORMAL mode,\n   with one exception.  When a two-character sequence beginning\
    \ with 177\n   is detected, the 177 should not be output at all.\n   In this section,\
    \ all numbers designating values of character codes\n   are to be interpreted\
    \ in octal.  SUPER-IMAGE mode is intended for use\n   by PDP-10 machines only.\n\
    \   SUPER-IMAGE suppresses the use of Rubout for quoting.  That is, for\n   each\
    \ entry beginning with a 177 in the PDP-10 character column in the\n   NORMAL\
    \ translation table, the NFILE character has the 177 removed.\n         TABLE\
    \ 5.   SUPER-IMAGE TRANSLATION FROM NFILE TO ASCII\n            NFILE character\
    \   PDP-10 character(s)\n            x in 000..177     x\n            x in 200..214\
    \     <x - 200>\n            215               015 012\n            x in 216..376\
    \     <x - 200>\n            377               no corresponding code\n       \
    \  TABLE 6.   SUPER-IMAGE TRANSLATION FROM ASCII TO NFILE\n            PDP-10\
    \ character  NFILE character\n            x in 000..007     x\n            x in\
    \ 010..012     x + 200\n            013               013\n            014   \
    \            214\n            015 012           215\n            015 not-012 \
    \      115\n            x in <016..176>   x\n            177               177\n\
    \                                   NOTES\n   1. NFILE's requirement for using\
    \ the NFILE character set is\n      recognized as a drawback for non-Symbolics\
    \ machines.  A useful\n      extension to NFILE would be a provision to make the\
    \ character set\n      negotiable.\n   2. Implementation note:  Care must be taken\
    \ that the freeing is done\n      before the control connection is allowed to\
    \ process another\n      command, or else the control connection may find the\
    \ data channel\n      to be falsely indicated as being in use.\n   3. The Symbolics\
    \ operating system has the policy that whenever the\n      user side is waiting\
    \ for the server side, a user abort can occur.\n      This user side waiting can\
    \ occur in any context, such awaiting a\n      response, waiting in the middle\
    \ of reading network input, or\n      waiting in the middle of transmitting network\
    \ output.  Thus there\n      are no \"hung\" states.\n   4. Note that the Token\
    \ List Transport Layer supplies a special token\n      to indicate Boolean truth,\
    \ but no corresponding token to indicate\n      Boolean falsity.  NFILE uses an\
    \ empty token list to indicate\n      Boolean falsity.  The historical reason\
    \ for this asymmetry is the\n      inability of the Lisp language to differentiate\
    \ between the empty\n      list and NIL, which is traditionally used to mean Boolean\
    \ falsity.\n      If the flexibility of both a Boolean falsity and an empty token\n\
    \      list were allowed, it would create problems for an operating\n      system\
    \ that cannot distinguish between the two.  This aspect of\n      the protocol\
    \ is recognized as a concession to the Lisp language.\n      The unfortunate effect\
    \ is to disallow operating systems to\n      distinguish between Boolean falsity\
    \ and an empty list.\n   5. No so-called \"fat strings\" can be sent.\n"
