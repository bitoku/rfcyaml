- title: __initial_text__
  contents:
  - '            Internet Key Exchange Protocol Version 2 (IKEv2)

    '
- title: Abstract
  contents:
  - "Abstract\n   This document describes version 2 of the Internet Key Exchange (IKE)\n\
    \   protocol.  IKE is a component of IPsec used for performing mutual\n   authentication\
    \ and establishing and maintaining Security Associations\n   (SAs).  This document\
    \ replaces and updates RFC 4306, and includes all\n   of the clarifications from\
    \ RFC 4718.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc5996.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2010 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n   This document\
    \ may contain material from IETF Documents or IETF\n   Contributions published\
    \ or made publicly available before November\n   10, 2008.  The person(s) controlling\
    \ the copyright in some of this\n   material may not have granted the IETF Trust\
    \ the right to allow\n   modifications of such material outside the IETF Standards\
    \ Process.\n   Without obtaining an adequate license from the person(s) controlling\n\
    \   the copyright in such materials, this document may not be modified\n   outside\
    \ the IETF Standards Process, and derivative works of it may\n   not be created\
    \ outside the IETF Standards Process, except to format\n   it for publication\
    \ as an RFC or to translate it into languages other\n   than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................5\n\
    \      1.1. Usage Scenarios ............................................6\n  \
    \         1.1.1. Security Gateway to Security Gateway in\n                  Tunnel\
    \ Mode .........................................7\n           1.1.2. Endpoint-to-Endpoint\
    \ Transport Mode .................7\n           1.1.3. Endpoint to Security Gateway\
    \ in Tunnel Mode .........8\n           1.1.4. Other Scenarios .....................................9\n\
    \      1.2. The Initial Exchanges ......................................9\n  \
    \    1.3. The CREATE_CHILD_SA Exchange ..............................13\n    \
    \       1.3.1. Creating New Child SAs with the\n                  CREATE_CHILD_SA\
    \ Exchange ...........................14\n           1.3.2. Rekeying IKE SAs with\
    \ the CREATE_CHILD_SA\n                  Exchange ...........................................15\n\
    \           1.3.3. Rekeying Child SAs with the CREATE_CHILD_SA\n             \
    \     Exchange ...........................................16\n      1.4. The INFORMATIONAL\
    \ Exchange ................................17\n           1.4.1. Deleting an SA\
    \ with INFORMATIONAL Exchanges ........17\n      1.5. Informational Messages outside\
    \ of an IKE SA ...............18\n      1.6. Requirements Terminology ..................................19\n\
    \      1.7. Significant Differences between RFC 4306 and This\n           Document\
    \ ..................................................20\n   2. IKE Protocol Details\
    \ and Variations ............................22\n      2.1. Use of Retransmission\
    \ Timers ..............................23\n      2.2. Use of Sequence Numbers\
    \ for Message ID ....................24\n      2.3. Window Size for Overlapping\
    \ Requests ......................25\n      2.4. State Synchronization and Connection\
    \ Timeouts .............26\n      2.5. Version Numbers and Forward Compatibility\
    \ .................28\n      2.6. IKE SA SPIs and Cookies ...................................30\n\
    \           2.6.1. Interaction of COOKIE and INVALID_KE_PAYLOAD .......33\n  \
    \    2.7. Cryptographic Algorithm Negotiation .......................34\n    \
    \  2.8. Rekeying ..................................................34\n      \
    \     2.8.1. Simultaneous Child SA Rekeying .....................36\n        \
    \   2.8.2. Simultaneous IKE SA Rekeying .......................39\n          \
    \ 2.8.3. Rekeying the IKE SA versus Reauthentication ........40\n      2.9. Traffic\
    \ Selector Negotiation ..............................40\n           2.9.1. Traffic\
    \ Selectors Violating Own Policy .............43\n      2.10. Nonces ...................................................44\n\
    \      2.11. Address and Port Agility .................................44\n  \
    \    2.12. Reuse of Diffie-Hellman Exponentials .....................44\n    \
    \  2.13. Generating Keying Material ...............................45\n      2.14.\
    \ Generating Keying Material for the IKE SA ................46\n      2.15. Authentication\
    \ of the IKE SA .............................47\n      2.16. Extensible Authentication\
    \ Protocol Methods ...............50\n      2.17. Generating Keying Material for\
    \ Child SAs .................52\n      2.18. Rekeying IKE SAs Using a CREATE_CHILD_SA\
    \ Exchange ........53\n      2.19. Requesting an Internal Address on a Remote\
    \ Network .......53\n      2.20. Requesting the Peer's Version ............................55\n\
    \      2.21. Error Handling ...........................................56\n  \
    \         2.21.1. Error Handling in IKE_SA_INIT .....................56\n    \
    \       2.21.2. Error Handling in IKE_AUTH ........................57\n      \
    \     2.21.3. Error Handling after IKE SA is Authenticated ......58\n        \
    \   2.21.4. Error Handling Outside IKE SA .....................58\n      2.22.\
    \ IPComp ...................................................59\n      2.23. NAT\
    \ Traversal ............................................60\n           2.23.1.\
    \ Transport Mode NAT Traversal ......................64\n      2.24. Explicit\
    \ Congestion Notification (ECN) ...................68\n      2.25. Exchange Collisions\
    \ ......................................68\n           2.25.1. Collisions while\
    \ Rekeying or Closing Child SAs ....69\n           2.25.2. Collisions while Rekeying\
    \ or Closing IKE SAs ......69\n   3. Header and Payload Formats .....................................69\n\
    \      3.1. The IKE Header ............................................70\n  \
    \    3.2. Generic Payload Header ....................................73\n    \
    \  3.3. Security Association Payload ..............................75\n      \
    \     3.3.1. Proposal Substructure ..............................78\n        \
    \   3.3.2. Transform Substructure .............................79\n          \
    \ 3.3.3. Valid Transform Types by Protocol ..................82\n           3.3.4.\
    \ Mandatory Transform IDs ............................83\n           3.3.5. Transform\
    \ Attributes ...............................84\n           3.3.6. Attribute Negotiation\
    \ ..............................86\n      3.4. Key Exchange Payload ......................................87\n\
    \      3.5. Identification Payloads ...................................87\n  \
    \    3.6. Certificate Payload .......................................90\n    \
    \  3.7. Certificate Request Payload ...............................93\n      3.8.\
    \ Authentication Payload ....................................95\n      3.9. Nonce\
    \ Payload .............................................96\n      3.10. Notify\
    \ Payload ...........................................97\n           3.10.1. Notify\
    \ Message Types ..............................98\n      3.11. Delete Payload ..........................................101\n\
    \      3.12. Vendor ID Payload .......................................102\n  \
    \    3.13. Traffic Selector Payload ................................103\n    \
    \       3.13.1. Traffic Selector .................................105\n      3.14.\
    \ Encrypted Payload .......................................107\n      3.15. Configuration\
    \ Payload ...................................109\n           3.15.1. Configuration\
    \ Attributes .........................110\n           3.15.2. Meaning of INTERNAL_IP4_SUBNET\
    \ and\n                   INTERNAL_IP6_SUBNET ..............................113\n\
    \           3.15.3. Configuration Payloads for IPv6 ..................115\n  \
    \         3.15.4. Address Assignment Failures ......................116\n    \
    \  3.16. Extensible Authentication Protocol (EAP) Payload ........117\n   4. Conformance\
    \ Requirements ......................................118\n   5. Security Considerations\
    \ .......................................120\n      5.1. Traffic Selector Authorization\
    \ ...........................123\n   6. IANA Considerations ...........................................124\n\
    \   7. Acknowledgements ..............................................125\n  \
    \ 8. References ....................................................126\n    \
    \  8.1. Normative References .....................................126\n      8.2.\
    \ Informative References ...................................127\n   Appendix A.\
    \ Summary of Changes from IKEv1 ........................132\n   Appendix B. Diffie-Hellman\
    \ Groups ................................133\n     B.1. Group 1 - 768-bit MODP\
    \ ....................................133\n     B.2. Group 2 - 1024-bit MODP ...................................133\n\
    \   Appendix C.  Exchanges and Payloads ..............................134\n  \
    \   C.1. IKE_SA_INIT Exchange  .....................................134\n    \
    \ C.2. IKE_AUTH Exchange without EAP .............................135\n     C.3.\
    \ IKE_AUTH Exchange with EAP  ...............................136\n     C.4. CREATE_CHILD_SA\
    \ Exchange for Creating or Rekeying\n          Child SAs .................................................137\n\
    \     C.5. CREATE_CHILD_SA Exchange for Rekeying the IKE SA ..........137\n  \
    \   C.6. INFORMATIONAL Exchange ....................................137\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   IP Security (IPsec) provides confidentiality, data integrity,\
    \ access\n   control, and data source authentication to IP datagrams.  These\n\
    \   services are provided by maintaining shared state between the source\n   and\
    \ the sink of an IP datagram.  This state defines, among other\n   things, the\
    \ specific services provided to the datagram, which\n   cryptographic algorithms\
    \ will be used to provide the services, and\n   the keys used as input to the\
    \ cryptographic algorithms.\n   Establishing this shared state in a manual fashion\
    \ does not scale\n   well.  Therefore, a protocol to establish this state dynamically\
    \ is\n   needed.  This document describes such a protocol -- the Internet Key\n\
    \   Exchange (IKE).  Version 1 of IKE was defined in RFCs 2407 [DOI],\n   2408\
    \ [ISAKMP], and 2409 [IKEV1].  IKEv2 replaced all of those RFCs.\n   IKEv2 was\
    \ defined in [IKEV2] (RFC 4306) and was clarified in [Clarif]\n   (RFC 4718).\
    \  This document replaces and updates RFC 4306 and RFC\n   4718.  IKEv2 was a\
    \ change to the IKE protocol that was not backward\n   compatible.  In contrast,\
    \ the current document not only provides a\n   clarification of IKEv2, but makes\
    \ minimum changes to the IKE\n   protocol.  A list of the significant differences\
    \ between RFC 4306 and\n   this document is given in Section 1.7.\n   IKE performs\
    \ mutual authentication between two parties and\n   establishes an IKE security\
    \ association (SA) that includes shared\n   secret information that can be used\
    \ to efficiently establish SAs for\n   Encapsulating Security Payload (ESP) [ESP]\
    \ or Authentication Header\n   (AH) [AH] and a set of cryptographic algorithms\
    \ to be used by the SAs\n   to protect the traffic that they carry.  In this document,\
    \ the term\n   \"suite\" or \"cryptographic suite\" refers to a complete set of\n\
    \   algorithms used to protect an SA.  An initiator proposes one or more\n   suites\
    \ by listing supported algorithms that can be combined into\n   suites in a mix-and-match\
    \ fashion.  IKE can also negotiate use of IP\n   Compression (IPComp) [IP-COMP]\
    \ in connection with an ESP or AH SA.\n   The SAs for ESP or AH that get set up\
    \ through that IKE SA we call\n   \"Child SAs\".\n   All IKE communications consist\
    \ of pairs of messages: a request and a\n   response.  The pair is called an \"\
    exchange\", and is sometimes called\n   a \"request/response pair\".  The first\
    \ exchange of messages\n   establishing an IKE SA are called the IKE_SA_INIT and\
    \ IKE_AUTH\n   exchanges; subsequent IKE exchanges are called the CREATE_CHILD_SA\
    \ or\n   INFORMATIONAL exchanges.  In the common case, there is a single\n   IKE_SA_INIT\
    \ exchange and a single IKE_AUTH exchange (a total of four\n   messages) to establish\
    \ the IKE SA and the first Child SA.  In\n   exceptional cases, there may be more\
    \ than one of each of these\n   exchanges.  In all cases, all IKE_SA_INIT exchanges\
    \ MUST complete\n   before any other exchange type, then all IKE_AUTH exchanges\
    \ MUST\n   complete, and following that, any number of CREATE_CHILD_SA and\n \
    \  INFORMATIONAL exchanges may occur in any order.  In some scenarios,\n   only\
    \ a single Child SA is needed between the IPsec endpoints, and\n   therefore there\
    \ would be no additional exchanges.  Subsequent\n   exchanges MAY be used to establish\
    \ additional Child SAs between the\n   same authenticated pair of endpoints and\
    \ to perform housekeeping\n   functions.\n   An IKE message flow always consists\
    \ of a request followed by a\n   response.  It is the responsibility of the requester\
    \ to ensure\n   reliability.  If the response is not received within a timeout\n\
    \   interval, the requester needs to retransmit the request (or abandon\n   the\
    \ connection).\n   The first exchange of an IKE session, IKE_SA_INIT, negotiates\n\
    \   security parameters for the IKE SA, sends nonces, and sends Diffie-\n   Hellman\
    \ values.\n   The second exchange, IKE_AUTH, transmits identities, proves knowledge\n\
    \   of the secrets corresponding to the two identities, and sets up an SA\n  \
    \ for the first (and often only) AH or ESP Child SA (unless there is\n   failure\
    \ setting up the AH or ESP Child SA, in which case the IKE SA\n   is still established\
    \ without the Child SA).\n   The types of subsequent exchanges are CREATE_CHILD_SA\
    \ (which creates\n   a Child SA) and INFORMATIONAL (which deletes an SA, reports\
    \ error\n   conditions, or does other housekeeping).  Every request requires a\n\
    \   response.  An INFORMATIONAL request with no payloads (other than the\n   empty\
    \ Encrypted payload required by the syntax) is commonly used as a\n   check for\
    \ liveness.  These subsequent exchanges cannot be used until\n   the initial exchanges\
    \ have completed.\n   In the description that follows, we assume that no errors\
    \ occur.\n   Modifications to the flow when errors occur are described in\n  \
    \ Section 2.21.\n"
- title: 1.1.  Usage Scenarios
  contents:
  - "1.1.  Usage Scenarios\n   IKE is used to negotiate ESP or AH SAs in a number\
    \ of different\n   scenarios, each with its own special requirements.\n"
- title: 1.1.1.  Security Gateway to Security Gateway in Tunnel Mode
  contents:
  - "1.1.1.  Security Gateway to Security Gateway in Tunnel Mode\n               \
    \ +-+-+-+-+-+            +-+-+-+-+-+\n                |         | IPsec      |\
    \         |\n   Protected    |Tunnel   | tunnel     |Tunnel   |     Protected\n\
    \   Subnet   <-->|Endpoint |<---------->|Endpoint |<--> Subnet\n             \
    \   |         |            |         |\n                +-+-+-+-+-+          \
    \  +-+-+-+-+-+\n          Figure 1:  Security Gateway to Security Gateway Tunnel\n\
    \   In this scenario, neither endpoint of the IP connection implements\n   IPsec,\
    \ but network nodes between them protect traffic for part of the\n   way.  Protection\
    \ is transparent to the endpoints, and depends on\n   ordinary routing to send\
    \ packets through the tunnel endpoints for\n   processing.  Each endpoint would\
    \ announce the set of addresses\n   \"behind\" it, and packets would be sent in\
    \ tunnel mode where the inner\n   IP header would contain the IP addresses of\
    \ the actual endpoints.\n"
- title: 1.1.2.  Endpoint-to-Endpoint Transport Mode
  contents:
  - "1.1.2.  Endpoint-to-Endpoint Transport Mode\n   +-+-+-+-+-+                 \
    \                         +-+-+-+-+-+\n   |         |                 IPsec transport\
    \          |         |\n   |Protected|                or tunnel mode SA      \
    \   |Protected|\n   |Endpoint |<---------------------------------------->|Endpoint\
    \ |\n   |         |                                          |         |\n   +-+-+-+-+-+\
    \                                          +-+-+-+-+-+\n                    Figure\
    \ 2:  Endpoint to Endpoint\n   In this scenario, both endpoints of the IP connection\
    \ implement\n   IPsec, as required of hosts in [IPSECARCH].  Transport mode will\n\
    \   commonly be used with no inner IP header.  A single pair of addresses\n  \
    \ will be negotiated for packets to be protected by this SA.  These\n   endpoints\
    \ MAY implement application-layer access controls based on\n   the IPsec authenticated\
    \ identities of the participants.  This\n   scenario enables the end-to-end security\
    \ that has been a guiding\n   principle for the Internet since [ARCHPRINC], [TRANSPARENCY],\
    \ and a\n   method of limiting the inherent problems with complexity in networks\n\
    \   noted by [ARCHGUIDEPHIL].  Although this scenario may not be fully\n   applicable\
    \ to the IPv4 Internet, it has been deployed successfully in\n   specific scenarios\
    \ within intranets using IKEv1.  It should be more\n   broadly enabled during\
    \ the transition to IPv6 and with the adoption\n   of IKEv2.\n   It is possible\
    \ in this scenario that one or both of the protected\n   endpoints will be behind\
    \ a network address translation (NAT) node, in\n   which case the tunneled packets\
    \ will have to be UDP encapsulated so\n   that port numbers in the UDP headers\
    \ can be used to identify\n   individual endpoints \"behind\" the NAT (see Section\
    \ 2.23).\n"
- title: 1.1.3.  Endpoint to Security Gateway in Tunnel Mode
  contents:
  - "1.1.3.  Endpoint to Security Gateway in Tunnel Mode\n   +-+-+-+-+-+         \
    \                 +-+-+-+-+-+\n   |         |         IPsec            |     \
    \    |     Protected\n   |Protected|         tunnel           |Tunnel   |    \
    \ Subnet\n   |Endpoint |<------------------------>|Endpoint |<--- and/or\n   |\
    \         |                          |         |     Internet\n   +-+-+-+-+-+\
    \                          +-+-+-+-+-+\n              Figure 3:  Endpoint to Security\
    \ Gateway Tunnel\n   In this scenario, a protected endpoint (typically a portable\
    \ roaming\n   computer) connects back to its corporate network through an IPsec-\n\
    \   protected tunnel.  It might use this tunnel only to access\n   information\
    \ on the corporate network, or it might tunnel all of its\n   traffic back through\
    \ the corporate network in order to take advantage\n   of protection provided\
    \ by a corporate firewall against Internet-based\n   attacks.  In either case,\
    \ the protected endpoint will want an IP\n   address associated with the security\
    \ gateway so that packets returned\n   to it will go to the security gateway and\
    \ be tunneled back.  This IP\n   address may be static or may be dynamically allocated\
    \ by the security\n   gateway.  In support of the latter case, IKEv2 includes\
    \ a mechanism\n   (namely, configuration payloads) for the initiator to request\
    \ an IP\n   address owned by the security gateway for use for the duration of\
    \ its\n   SA.\n   In this scenario, packets will use tunnel mode.  On each packet\
    \ from\n   the protected endpoint, the outer IP header will contain the source\n\
    \   IP address associated with its current location (i.e., the address\n   that\
    \ will get traffic routed to the endpoint directly), while the\n   inner IP header\
    \ will contain the source IP address assigned by the\n   security gateway (i.e.,\
    \ the address that will get traffic routed to\n   the security gateway for forwarding\
    \ to the endpoint).  The outer\n   destination address will always be that of\
    \ the security gateway,\n   while the inner destination address will be the ultimate\
    \ destination\n   for the packet.\n   In this scenario, it is possible that the\
    \ protected endpoint will be\n   behind a NAT.  In that case, the IP address as\
    \ seen by the security\n   gateway will not be the same as the IP address sent\
    \ by the protected\n   endpoint, and packets will have to be UDP encapsulated\
    \ in order to be\n   routed properly.  Interaction with NATs is covered in detail\
    \ in\n   Section 2.23.\n"
- title: 1.1.4.  Other Scenarios
  contents:
  - "1.1.4.  Other Scenarios\n   Other scenarios are possible, as are nested combinations\
    \ of the\n   above.  One notable example combines aspects of Sections 1.1.1 and\n\
    \   1.1.3.  A subnet may make all external accesses through a remote\n   security\
    \ gateway using an IPsec tunnel, where the addresses on the\n   subnet are routed\
    \ to the security gateway by the rest of the\n   Internet.  An example would be\
    \ someone's home network being virtually\n   on the Internet with static IP addresses\
    \ even though connectivity is\n   provided by an ISP that assigns a single dynamically\
    \ assigned IP\n   address to the user's security gateway (where the static IP\
    \ addresses\n   and an IPsec relay are provided by a third party located elsewhere).\n"
- title: 1.2.  The Initial Exchanges
  contents:
  - "1.2.  The Initial Exchanges\n   Communication using IKE always begins with IKE_SA_INIT\
    \ and IKE_AUTH\n   exchanges (known in IKEv1 as Phase 1).  These initial exchanges\n\
    \   normally consist of four messages, though in some scenarios that\n   number\
    \ can grow.  All communications using IKE consist of request/\n   response pairs.\
    \  We'll describe the base exchange first, followed by\n   variations.  The first\
    \ pair of messages (IKE_SA_INIT) negotiate\n   cryptographic algorithms, exchange\
    \ nonces, and do a Diffie-Hellman\n   exchange [DH].\n   The second pair of messages\
    \ (IKE_AUTH) authenticate the previous\n   messages, exchange identities and certificates,\
    \ and establish the\n   first Child SA.  Parts of these messages are encrypted\
    \ and integrity\n   protected with keys established through the IKE_SA_INIT exchange,\
    \ so\n   the identities are hidden from eavesdroppers and all fields in all\n\
    \   the messages are authenticated.  See Section 2.14 for information on\n   how\
    \ the encryption keys are generated.  (A man-in-the-middle attacker\n   who cannot\
    \ complete the IKE_AUTH exchange can nonetheless see the\n   identity of the initiator.)\n\
    \   All messages following the initial exchange are cryptographically\n   protected\
    \ using the cryptographic algorithms and keys negotiated in\n   the IKE_SA_INIT\
    \ exchange.  These subsequent messages use the syntax\n   of the Encrypted payload\
    \ described in Section 3.14, encrypted with\n   keys that are derived as described\
    \ in Section 2.14.  All subsequent\n   messages include an Encrypted payload,\
    \ even if they are referred to\n   in the text as \"empty\".  For the CREATE_CHILD_SA,\
    \ IKE_AUTH, or\n   INFORMATIONAL exchanges, the message following the header is\n\
    \   encrypted and the message including the header is integrity protected\n  \
    \ using the cryptographic algorithms negotiated for the IKE SA.\n   Every IKE\
    \ message contains a Message ID as part of its fixed header.\n   This Message\
    \ ID is used to match up requests and responses, and to\n   identify retransmissions\
    \ of messages.\n   In the following descriptions, the payloads contained in the\
    \ message\n   are indicated by names as listed below.\n   Notation    Payload\n\
    \   -----------------------------------------\n   AUTH        Authentication\n\
    \   CERT        Certificate\n   CERTREQ     Certificate Request\n   CP       \
    \   Configuration\n   D           Delete\n   EAP         Extensible Authentication\n\
    \   HDR         IKE header (not a payload)\n   IDi         Identification - Initiator\n\
    \   IDr         Identification - Responder\n   KE          Key Exchange\n   Ni,\
    \ Nr      Nonce\n   N           Notify\n   SA          Security Association\n\
    \   SK          Encrypted and Authenticated\n   TSi         Traffic Selector -\
    \ Initiator\n   TSr         Traffic Selector - Responder\n   V           Vendor\
    \ ID\n   The details of the contents of each payload are described in section\n\
    \   3.  Payloads that may optionally appear will be shown in brackets,\n   such\
    \ as [CERTREQ]; this indicates that a Certificate Request payload\n   can optionally\
    \ be included.\n   The initial exchanges are as follows:\n   Initiator       \
    \                  Responder\n   -------------------------------------------------------------------\n\
    \   HDR, SAi1, KEi, Ni  -->\n   HDR contains the Security Parameter Indexes (SPIs),\
    \ version numbers,\n   and flags of various sorts.  The SAi1 payload states the\n\
    \   cryptographic algorithms the initiator supports for the IKE SA.  The\n   KE\
    \ payload sends the initiator's Diffie-Hellman value.  Ni is the\n   initiator's\
    \ nonce.\n                                <--  HDR, SAr1, KEr, Nr, [CERTREQ]\n\
    \   The responder chooses a cryptographic suite from the initiator's\n   offered\
    \ choices and expresses that choice in the SAr1 payload,\n   completes the Diffie-Hellman\
    \ exchange with the KEr payload, and sends\n   its nonce in the Nr payload.\n\
    \   At this point in the negotiation, each party can generate SKEYSEED,\n   from\
    \ which all keys are derived for that IKE SA.  The messages that\n   follow are\
    \ encrypted and integrity protected in their entirety, with\n   the exception\
    \ of the message headers.  The keys used for the\n   encryption and integrity\
    \ protection are derived from SKEYSEED and are\n   known as SK_e (encryption)\
    \ and SK_a (authentication, a.k.a. integrity\n   protection); see Sections 2.13\
    \ and 2.14 for details on the key\n   derivation.  A separate SK_e and SK_a is\
    \ computed for each direction.\n   In addition to the keys SK_e and SK_a derived\
    \ from the Diffie-Hellman\n   value for protection of the IKE SA, another quantity\
    \ SK_d is derived\n   and used for derivation of further keying material for Child\
    \ SAs.\n   The notation SK { ... } indicates that these payloads are encrypted\n\
    \   and integrity protected using that direction's SK_e and SK_a.\n   HDR, SK\
    \ {IDi, [CERT,] [CERTREQ,]\n       [IDr,] AUTH, SAi2,\n       TSi, TSr}  -->\n\
    \   The initiator asserts its identity with the IDi payload, proves\n   knowledge\
    \ of the secret corresponding to IDi and integrity protects\n   the contents of\
    \ the first message using the AUTH payload (see\n   Section 2.15).  It might also\
    \ send its certificate(s) in CERT\n   payload(s) and a list of its trust anchors\
    \ in CERTREQ payload(s).  If\n   any CERT payloads are included, the first certificate\
    \ provided MUST\n   contain the public key used to verify the AUTH field.\n  \
    \ The optional payload IDr enables the initiator to specify to which of\n   the\
    \ responder's identities it wants to talk.  This is useful when the\n   machine\
    \ on which the responder is running is hosting multiple\n   identities at the\
    \ same IP address.  If the IDr proposed by the\n   initiator is not acceptable\
    \ to the responder, the responder might use\n   some other IDr to finish the exchange.\
    \  If the initiator then does\n   not accept the fact that responder used an IDr\
    \ different than the one\n   that was requested, the initiator can close the SA\
    \ after noticing the\n   fact.\n   The Traffic Selectors (TSi and TSr) are discussed\
    \ in Section 2.9.\n   The initiator begins negotiation of a Child SA using the\
    \ SAi2\n   payload.  The final fields (starting with SAi2) are described in the\n\
    \   description of the CREATE_CHILD_SA exchange.\n                           \
    \     <--  HDR, SK {IDr, [CERT,] AUTH,\n                                     \
    \    SAr2, TSi, TSr}\n   The responder asserts its identity with the IDr payload,\
    \ optionally\n   sends one or more certificates (again with the certificate containing\n\
    \   the public key used to verify AUTH listed first), authenticates its\n   identity\
    \ and protects the integrity of the second message with the\n   AUTH payload,\
    \ and completes negotiation of a Child SA with the\n   additional fields described\
    \ below in the CREATE_CHILD_SA exchange.\n   Both parties in the IKE_AUTH exchange\
    \ MUST verify that all signatures\n   and Message Authentication Codes (MACs)\
    \ are computed correctly.  If\n   either side uses a shared secret for authentication,\
    \ the names in the\n   ID payload MUST correspond to the key used to generate\
    \ the AUTH\n   payload.\n   Because the initiator sends its Diffie-Hellman value\
    \ in the\n   IKE_SA_INIT, it must guess the Diffie-Hellman group that the\n  \
    \ responder will select from its list of supported groups.  If the\n   initiator\
    \ guesses wrong, the responder will respond with a Notify\n   payload of type\
    \ INVALID_KE_PAYLOAD indicating the selected group.  In\n   this case, the initiator\
    \ MUST retry the IKE_SA_INIT with the\n   corrected Diffie-Hellman group.  The\
    \ initiator MUST again propose its\n   full set of acceptable cryptographic suites\
    \ because the rejection\n   message was unauthenticated and otherwise an active\
    \ attacker could\n   trick the endpoints into negotiating a weaker suite than\
    \ a stronger\n   one that they both prefer.\n   If creating the Child SA during\
    \ the IKE_AUTH exchange fails for some\n   reason, the IKE SA is still created\
    \ as usual.  The list of Notify\n   message types in the IKE_AUTH exchange that\
    \ do not prevent an IKE SA\n   from being set up include at least the following:\
    \ NO_PROPOSAL_CHOSEN,\n   TS_UNACCEPTABLE, SINGLE_PAIR_REQUIRED, INTERNAL_ADDRESS_FAILURE,\
    \ and\n   FAILED_CP_REQUIRED.\n   If the failure is related to creating the IKE\
    \ SA (for example, an\n   AUTHENTICATION_FAILED Notify error message is returned),\
    \ the IKE SA\n   is not created.  Note that although the IKE_AUTH messages are\n\
    \   encrypted and integrity protected, if the peer receiving this Notify\n   error\
    \ message has not yet authenticated the other end (or if the peer\n   fails to\
    \ authenticate the other end for some reason), the information\n   needs to be\
    \ treated with caution.  More precisely, assuming that the\n   MAC verifies correctly,\
    \ the sender of the error Notify message is\n   known to be the responder of the\
    \ IKE_SA_INIT exchange, but the\n   sender's identity cannot be assured.\n   Note\
    \ that IKE_AUTH messages do not contain KEi/KEr or Ni/Nr payloads.\n   Thus, the\
    \ SA payloads in the IKE_AUTH exchange cannot contain\n   Transform Type 4 (Diffie-Hellman\
    \ group) with any value other than\n   NONE.  Implementations SHOULD omit the\
    \ whole transform substructure\n   instead of sending value NONE.\n"
- title: 1.3.  The CREATE_CHILD_SA Exchange
  contents:
  - "1.3.  The CREATE_CHILD_SA Exchange\n   The CREATE_CHILD_SA exchange is used to\
    \ create new Child SAs and to\n   rekey both IKE SAs and Child SAs.  This exchange\
    \ consists of a single\n   request/response pair, and some of its function was\
    \ referred to as a\n   Phase 2 exchange in IKEv1.  It MAY be initiated by either\
    \ end of the\n   IKE SA after the initial exchanges are completed.\n   An SA is\
    \ rekeyed by creating a new SA and then deleting the old one.\n   This section\
    \ describes the first part of rekeying, the creation of\n   new SAs; Section 2.8\
    \ covers the mechanics of rekeying, including\n   moving traffic from old to new\
    \ SAs and the deletion of the old SAs.\n   The two sections must be read together\
    \ to understand the entire\n   process of rekeying.\n   Either endpoint may initiate\
    \ a CREATE_CHILD_SA exchange, so in this\n   section the term initiator refers\
    \ to the endpoint initiating this\n   exchange.  An implementation MAY refuse\
    \ all CREATE_CHILD_SA requests\n   within an IKE SA.\n   The CREATE_CHILD_SA request\
    \ MAY optionally contain a KE payload for\n   an additional Diffie-Hellman exchange\
    \ to enable stronger guarantees\n   of forward secrecy for the Child SA.  The\
    \ keying material for the\n   Child SA is a function of SK_d established during\
    \ the establishment\n   of the IKE SA, the nonces exchanged during the CREATE_CHILD_SA\n\
    \   exchange, and the Diffie-Hellman value (if KE payloads are included\n   in\
    \ the CREATE_CHILD_SA exchange).\n   If a CREATE_CHILD_SA exchange includes a\
    \ KEi payload, at least one of\n   the SA offers MUST include the Diffie-Hellman\
    \ group of the KEi.  The\n   Diffie-Hellman group of the KEi MUST be an element\
    \ of the group the\n   initiator expects the responder to accept (additional Diffie-Hellman\n\
    \   groups can be proposed).  If the responder selects a proposal using a\n  \
    \ different Diffie-Hellman group (other than NONE), the responder MUST\n   reject\
    \ the request and indicate its preferred Diffie-Hellman group in\n   the INVALID_KE_PAYLOAD\
    \ Notify payload.  There are two octets of data\n   associated with this notification:\
    \ the accepted Diffie-Hellman group\n   number in big endian order.  In the case\
    \ of such a rejection, the\n   CREATE_CHILD_SA exchange fails, and the initiator\
    \ will probably retry\n   the exchange with a Diffie-Hellman proposal and KEi\
    \ in the group that\n   the responder gave in the INVALID_KE_PAYLOAD Notify payload.\n\
    \   The responder sends a NO_ADDITIONAL_SAS notification to indicate that\n  \
    \ a CREATE_CHILD_SA request is unacceptable because the responder is\n   unwilling\
    \ to accept any more Child SAs on this IKE SA.  This\n   notification can also\
    \ be used to reject IKE SA rekey.  Some minimal\n   implementations may only accept\
    \ a single Child SA setup in the\n   context of an initial IKE exchange and reject\
    \ any subsequent attempts\n   to add more.\n"
- title: 1.3.1.  Creating New Child SAs with the CREATE_CHILD_SA Exchange
  contents:
  - "1.3.1.  Creating New Child SAs with the CREATE_CHILD_SA Exchange\n   A Child\
    \ SA may be created by sending a CREATE_CHILD_SA request.  The\n   CREATE_CHILD_SA\
    \ request for creating a new Child SA is:\n   Initiator                      \
    \   Responder\n   -------------------------------------------------------------------\n\
    \   HDR, SK {SA, Ni, [KEi],\n              TSi, TSr}  -->\n   The initiator sends\
    \ SA offer(s) in the SA payload, a nonce in the Ni\n   payload, optionally a Diffie-Hellman\
    \ value in the KEi payload, and\n   the proposed Traffic Selectors for the proposed\
    \ Child SA in the TSi\n   and TSr payloads.\n   The CREATE_CHILD_SA response for\
    \ creating a new Child SA is:\n                                <--  HDR, SK {SA,\
    \ Nr, [KEr],\n                                         TSi, TSr}\n   The responder\
    \ replies (using the same Message ID to respond) with the\n   accepted offer in\
    \ an SA payload, and a Diffie-Hellman value in the\n   KEr payload if KEi was\
    \ included in the request and the selected\n   cryptographic suite includes that\
    \ group.\n   The Traffic Selectors for traffic to be sent on that SA are specified\n\
    \   in the TS payloads in the response, which may be a subset of what the\n  \
    \ initiator of the Child SA proposed.\n   The USE_TRANSPORT_MODE notification\
    \ MAY be included in a request\n   message that also includes an SA payload requesting\
    \ a Child SA.  It\n   requests that the Child SA use transport mode rather than\
    \ tunnel mode\n   for the SA created.  If the request is accepted, the response\
    \ MUST\n   also include a notification of type USE_TRANSPORT_MODE.  If the\n \
    \  responder declines the request, the Child SA will be established in\n   tunnel\
    \ mode.  If this is unacceptable to the initiator, the initiator\n   MUST delete\
    \ the SA.  Note: Except when using this option to negotiate\n   transport mode,\
    \ all Child SAs will use tunnel mode.\n   The ESP_TFC_PADDING_NOT_SUPPORTED notification\
    \ asserts that the\n   sending endpoint will not accept packets that contain Traffic\
    \ Flow\n   Confidentiality (TFC) padding over the Child SA being negotiated. \
    \ If\n   neither endpoint accepts TFC padding, this notification is included\n\
    \   in both the request and the response.  If this notification is\n   included\
    \ in only one of the messages, TFC padding can still be sent\n   in the other\
    \ direction.\n   The NON_FIRST_FRAGMENTS_ALSO notification is used for fragmentation\n\
    \   control.  See [IPSECARCH] for a fuller explanation.  Both parties\n   need\
    \ to agree to sending non-first fragments before either party does\n   so.  It\
    \ is enabled only if NON_FIRST_FRAGMENTS_ALSO notification is\n   included in\
    \ both the request proposing an SA and the response\n   accepting it.  If the\
    \ responder does not want to send or receive non-\n   first fragments, it only\
    \ omits NON_FIRST_FRAGMENTS_ALSO notification\n   from its response, but does\
    \ not reject the whole Child SA creation.\n   An IPCOMP_SUPPORTED notification,\
    \ covered in Section 2.22, can also\n   be included in the exchange.\n   A failed\
    \ attempt to create a Child SA SHOULD NOT tear down the IKE\n   SA: there is no\
    \ reason to lose the work done to set up the IKE SA.\n   See Section 2.21 for\
    \ a list of error messages that might occur if\n   creating a Child SA fails.\n"
- title: 1.3.2.  Rekeying IKE SAs with the CREATE_CHILD_SA Exchange
  contents:
  - "1.3.2.  Rekeying IKE SAs with the CREATE_CHILD_SA Exchange\n   The CREATE_CHILD_SA\
    \ request for rekeying an IKE SA is:\n   Initiator                         Responder\n\
    \   -------------------------------------------------------------------\n   HDR,\
    \ SK {SA, Ni, KEi} -->\n   The initiator sends SA offer(s) in the SA payload,\
    \ a nonce in the Ni\n   payload, and a Diffie-Hellman value in the KEi payload.\
    \  The KEi\n   payload MUST be included.  A new initiator SPI is supplied in the\
    \ SPI\n   field of the SA payload.  Once a peer receives a request to rekey an\n\
    \   IKE SA or sends a request to rekey an IKE SA, it SHOULD NOT start any\n  \
    \ new CREATE_CHILD_SA exchanges on the IKE SA that is being rekeyed.\n   The CREATE_CHILD_SA\
    \ response for rekeying an IKE SA is:\n                                <--  HDR,\
    \ SK {SA, Nr, KEr}\n   The responder replies (using the same Message ID to respond)\
    \ with the\n   accepted offer in an SA payload, and a Diffie-Hellman value in\
    \ the\n   KEr payload if the selected cryptographic suite includes that group.\n\
    \   A new responder SPI is supplied in the SPI field of the SA payload.\n   The\
    \ new IKE SA has its message counters set to 0, regardless of what\n   they were\
    \ in the earlier IKE SA.  The first IKE requests from both\n   sides on the new\
    \ IKE SA will have Message ID 0.  The old IKE SA\n   retains its numbering, so\
    \ any further requests (for example, to\n   delete the IKE SA) will have consecutive\
    \ numbering.  The new IKE SA\n   also has its window size reset to 1, and the\
    \ initiator in this rekey\n   exchange is the new \"original initiator\" of the\
    \ new IKE SA.\n   Section 2.18 also covers IKE SA rekeying in detail.\n"
- title: 1.3.3.  Rekeying Child SAs with the CREATE_CHILD_SA Exchange
  contents:
  - "1.3.3.  Rekeying Child SAs with the CREATE_CHILD_SA Exchange\n   The CREATE_CHILD_SA\
    \ request for rekeying a Child SA is:\n   Initiator                         Responder\n\
    \   -------------------------------------------------------------------\n   HDR,\
    \ SK {N(REKEY_SA), SA, Ni, [KEi],\n       TSi, TSr}   -->\n   The initiator sends\
    \ SA offer(s) in the SA payload, a nonce in the Ni\n   payload, optionally a Diffie-Hellman\
    \ value in the KEi payload, and\n   the proposed Traffic Selectors for the proposed\
    \ Child SA in the TSi\n   and TSr payloads.\n   The notifications described in\
    \ Section 1.3.1 may also be sent in a\n   rekeying exchange.  Usually, these will\
    \ be the same notifications\n   that were used in the original exchange; for example,\
    \ when rekeying a\n   transport mode SA, the USE_TRANSPORT_MODE notification will\
    \ be used.\n   The REKEY_SA notification MUST be included in a CREATE_CHILD_SA\n\
    \   exchange if the purpose of the exchange is to replace an existing ESP\n  \
    \ or AH SA.  The SA being rekeyed is identified by the SPI field in the\n   Notify\
    \ payload; this is the SPI the exchange initiator would expect\n   in inbound\
    \ ESP or AH packets.  There is no data associated with this\n   Notify message\
    \ type.  The Protocol ID field of the REKEY_SA\n   notification is set to match\
    \ the protocol of the SA we are rekeying,\n   for example, 3 for ESP and 2 for\
    \ AH.\n   The CREATE_CHILD_SA response for rekeying a Child SA is:\n         \
    \                       <--  HDR, SK {SA, Nr, [KEr],\n                       \
    \                  TSi, TSr}\n   The responder replies (using the same Message\
    \ ID to respond) with the\n   accepted offer in an SA payload, and a Diffie-Hellman\
    \ value in the\n   KEr payload if KEi was included in the request and the selected\n\
    \   cryptographic suite includes that group.\n   The Traffic Selectors for traffic\
    \ to be sent on that SA are specified\n   in the TS payloads in the response,\
    \ which may be a subset of what the\n   initiator of the Child SA proposed.\n"
- title: 1.4.  The INFORMATIONAL Exchange
  contents:
  - "1.4.  The INFORMATIONAL Exchange\n   At various points during the operation of\
    \ an IKE SA, peers may desire\n   to convey control messages to each other regarding\
    \ errors or\n   notifications of certain events.  To accomplish this, IKE defines\
    \ an\n   INFORMATIONAL exchange.  INFORMATIONAL exchanges MUST ONLY occur\n  \
    \ after the initial exchanges and are cryptographically protected with\n   the\
    \ negotiated keys.  Note that some informational messages, not\n   exchanges,\
    \ can be sent outside the context of an IKE SA.  Section\n   2.21 also covers\
    \ error messages in great detail.\n   Control messages that pertain to an IKE\
    \ SA MUST be sent under that\n   IKE SA.  Control messages that pertain to Child\
    \ SAs MUST be sent\n   under the protection of the IKE SA that generated them\
    \ (or its\n   successor if the IKE SA was rekeyed).\n   Messages in an INFORMATIONAL\
    \ exchange contain zero or more\n   Notification, Delete, and Configuration payloads.\
    \  The recipient of\n   an INFORMATIONAL exchange request MUST send some response;\
    \ otherwise,\n   the sender will assume the message was lost in the network and\
    \ will\n   retransmit it.  That response MAY be an empty message.  The request\n\
    \   message in an INFORMATIONAL exchange MAY also contain no payloads.\n   This\
    \ is the expected way an endpoint can ask the other endpoint to\n   verify that\
    \ it is alive.\n   The INFORMATIONAL exchange is defined as:\n   Initiator   \
    \                      Responder\n   -------------------------------------------------------------------\n\
    \   HDR, SK {[N,] [D,]\n       [CP,] ...}  -->\n                             \
    \   <--  HDR, SK {[N,] [D,]\n                                         [CP], ...}\n\
    \   The processing of an INFORMATIONAL exchange is determined by its\n   component\
    \ payloads.\n"
- title: 1.4.1.  Deleting an SA with INFORMATIONAL Exchanges
  contents:
  - "1.4.1.  Deleting an SA with INFORMATIONAL Exchanges\n   ESP and AH SAs always\
    \ exist in pairs, with one SA in each direction.\n   When an SA is closed, both\
    \ members of the pair MUST be closed (that\n   is, deleted).  Each endpoint MUST\
    \ close its incoming SAs and allow\n   the other endpoint to close the other SA\
    \ in each pair.  To delete an\n   SA, an INFORMATIONAL exchange with one or more\
    \ Delete payloads is\n   sent listing the SPIs (as they would be expected in the\
    \ headers of\n   inbound packets) of the SAs to be deleted.  The recipient MUST\
    \ close\n   the designated SAs.  Note that one never sends Delete payloads for\n\
    \   the two sides of an SA in a single message.  If there are many SAs to\n  \
    \ delete at the same time, one includes Delete payloads for the inbound\n   half\
    \ of each SA pair in the INFORMATIONAL exchange.\n   Normally, the response in\
    \ the INFORMATIONAL exchange will contain\n   Delete payloads for the paired SAs\
    \ going in the other direction.\n   There is one exception.  If, by chance, both\
    \ ends of a set of SAs\n   independently decide to close them, each may send a\
    \ Delete payload\n   and the two requests may cross in the network.  If a node\
    \ receives a\n   delete request for SAs for which it has already issued a delete\n\
    \   request, it MUST delete the outgoing SAs while processing the request\n  \
    \ and the incoming SAs while processing the response.  In that case,\n   the responses\
    \ MUST NOT include Delete payloads for the deleted SAs,\n   since that would result\
    \ in duplicate deletion and could in theory\n   delete the wrong SA.\n   Similar\
    \ to ESP and AH SAs, IKE SAs are also deleted by sending an\n   Informational\
    \ exchange.  Deleting an IKE SA implicitly closes any\n   remaining Child SAs\
    \ negotiated under it.  The response to a request\n   that deletes the IKE SA\
    \ is an empty INFORMATIONAL response.\n   Half-closed ESP or AH connections are\
    \ anomalous, and a node with\n   auditing capability should probably audit their\
    \ existence if they\n   persist.  Note that this specification does not specify\
    \ time periods,\n   so it is up to individual endpoints to decide how long to\
    \ wait.  A\n   node MAY refuse to accept incoming data on half-closed connections\n\
    \   but MUST NOT unilaterally close them and reuse the SPIs.  If\n   connection\
    \ state becomes sufficiently messed up, a node MAY close the\n   IKE SA, as described\
    \ above.  It can then rebuild the SAs it needs on\n   a clean base under a new\
    \ IKE SA.\n"
- title: 1.5.  Informational Messages outside of an IKE SA
  contents:
  - "1.5.  Informational Messages outside of an IKE SA\n   There are some cases in\
    \ which a node receives a packet that it cannot\n   process, but it may want to\
    \ notify the sender about this situation.\n   o  If an ESP or AH packet arrives\
    \ with an unrecognized SPI.  This\n      might be due to the receiving node having\
    \ recently crashed and\n      lost state, or because of some other system malfunction\
    \ or attack.\n   o  If an encrypted IKE request packet arrives on port 500 or\
    \ 4500\n      with an unrecognized IKE SPI.  This might be due to the receiving\n\
    \      node having recently crashed and lost state, or because of some\n     \
    \ other system malfunction or attack.\n   o  If an IKE request packet arrives\
    \ with a higher major version\n      number than the implementation supports.\n\
    \   In the first case, if the receiving node has an active IKE SA to the\n   IP\
    \ address from whence the packet came, it MAY send an INVALID_SPI\n   notification\
    \ of the wayward packet over that IKE SA in an\n   INFORMATIONAL exchange.  The\
    \ Notification Data contains the SPI of\n   the invalid packet.  The recipient\
    \ of this notification cannot tell\n   whether the SPI is for AH or ESP, but this\
    \ is not important because\n   the SPIs are supposed to be different for the two.\
    \  If no suitable\n   IKE SA exists, the node MAY send an informational message\
    \ without\n   cryptographic protection to the source IP address, using the source\n\
    \   UDP port as the destination port if the packet was UDP (UDP-\n   encapsulated\
    \ ESP or AH).  In this case, it should only be used by the\n   recipient as a\
    \ hint that something might be wrong (because it could\n   easily be forged).\
    \  This message is not part of an INFORMATIONAL\n   exchange, and the receiving\
    \ node MUST NOT respond to it because doing\n   so could cause a message loop.\
    \  The message is constructed as\n   follows: there are no IKE SPI values that\
    \ would be meaningful to the\n   recipient of such a notification; using zero\
    \ values or random values\n   are both acceptable, this being the exception to\
    \ the rule in\n   Section 3.1 that prohibits zero IKE Initiator SPIs.  The Initiator\n\
    \   flag is set to 1, the Response flag is set to 0, and the version\n   flags\
    \ are set in the normal fashion; these flags are described in\n   Section 3.1.\n\
    \   In the second and third cases, the message is always sent without\n   cryptographic\
    \ protection (outside of an IKE SA), and includes either\n   an INVALID_IKE_SPI\
    \ or an INVALID_MAJOR_VERSION notification (with no\n   notification data).  The\
    \ message is a response message, and thus it\n   is sent to the IP address and\
    \ port from whence it came with the same\n   IKE SPIs and the Message ID and Exchange\
    \ Type are copied from the\n   request.  The Response flag is set to 1, and the\
    \ version flags are\n   set in the normal fashion.\n"
- title: 1.6.  Requirements Terminology
  contents:
  - "1.6.  Requirements Terminology\n   Definitions of the primitive terms in this\
    \ document (such as Security\n   Association or SA) can be found in [IPSECARCH].\
    \  It should be noted\n   that parts of IKEv2 rely on some of the processing rules\
    \ in\n   [IPSECARCH], as described in various sections of this document.\n   The\
    \ key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n\
    \   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in\
    \ this\n   document are to be interpreted as described in [MUSTSHOULD].\n"
- title: 1.7.  Significant Differences between RFC 4306 and This Document
  contents:
  - "1.7.  Significant Differences between RFC 4306 and This Document\n   This document\
    \ contains clarifications and amplifications to IKEv2\n   [IKEV2].  Many of the\
    \ clarifications are based on [Clarif].  The\n   changes listed in that document\
    \ were discussed in the IPsec Working\n   Group and, after the Working Group was\
    \ disbanded, on the IPsec\n   mailing list.  That document contains detailed explanations\
    \ of areas\n   that were unclear in IKEv2, and is thus useful to implementers\
    \ of\n   IKEv2.\n   The protocol described in this document retains the same major\n\
    \   version number (2) and minor version number (0) as was used in RFC\n   4306.\
    \  That is, the version number is *not* changed from RFC 4306.\n   The small number\
    \ of technical changes listed here are not expected to\n   affect RFC 4306 implementations\
    \ that have already been deployed at\n   the time of publication of this document.\n\
    \   This document makes the figures and references a bit more consistent\n   than\
    \ they were in [IKEV2].\n   IKEv2 developers have noted that the SHOULD-level\
    \ requirements in RFC\n   4306 are often unclear in that they don't say when it\
    \ is OK to not\n   obey the requirements.  They also have noted that there are\
    \ MUST-\n   level requirements that are not related to interoperability.  This\n\
    \   document has more explanation of some of these requirements.  All\n   non-capitalized\
    \ uses of the words SHOULD and MUST now mean their\n   normal English sense, not\
    \ the interoperability sense of [MUSTSHOULD].\n   IKEv2 (and IKEv1) developers\
    \ have noted that there is a great deal of\n   material in the tables of codes\
    \ in Section 3.10.1 in RFC 4306.  This\n   leads to implementers not having all\
    \ the needed information in the\n   main body of the document.  Much of the material\
    \ from those tables\n   has been moved into the associated parts of the main body\
    \ of the\n   document.\n   This document removes discussion of nesting AH and\
    \ ESP.  This was a\n   mistake in RFC 4306 caused by the lag between finishing\
    \ RFC 4306 and\n   RFC 4301.  Basically, IKEv2 is based on RFC 4301, which does\
    \ not\n   include \"SA bundles\" that were part of RFC 2401.  While a single\n\
    \   packet can go through IPsec processing multiple times, each of these\n   passes\
    \ uses a separate SA, and the passes are coordinated by the\n   forwarding tables.\
    \  In IKEv2, each of these SAs has to be created\n   using a separate CREATE_CHILD_SA\
    \ exchange.\n   This document removes discussion of the INTERNAL_ADDRESS_EXPIRY\n\
    \   configuration attribute because its implementation was very\n   problematic.\
    \  Implementations that conform to this document MUST\n   ignore proposals that\
    \ have configuration attribute type 5, the old\n   value for INTERNAL_ADDRESS_EXPIRY.\
    \  This document also removed\n   INTERNAL_IP6_NBNS as a configuration attribute.\n\
    \   This document removes the allowance for rejecting messages in which\n   the\
    \ payloads were not in the \"right\" order; now implementations MUST\n   NOT reject\
    \ them.  This is due to the lack of clarity where the orders\n   for the payloads\
    \ are described.\n   The lists of items from RFC 4306 that ended up in the IANA\
    \ registry\n   were trimmed to only include items that were actually defined in\
    \ RFC\n   4306.  Also, many of those lists are now preceded with the very\n  \
    \ important instruction to developers that they really should look at\n   the\
    \ IANA registry at the time of development because new items have\n   been added\
    \ since RFC 4306.\n   This document adds clarification on when notifications are\
    \ and are\n   not sent encrypted, depending on the state of the negotiation at\
    \ the\n   time.\n   This document discusses more about how to negotiate combined-mode\n\
    \   ciphers.\n   In Section 1.3.2, \"The KEi payload SHOULD be included\" was\
    \ changed to\n   be \"The KEi payload MUST be included\".  This also led to changes\
    \ in\n   Section 2.18.\n   In Section 2.1, there is new material covering how\
    \ the initiator's\n   SPI and/or IP is used to differentiate if this is a \"half-open\"\
    \ IKE\n   SA or a new request.\n   This document clarifies the use of the critical\
    \ flag in Section 2.5.\n   In Section 2.8, \"Note that, when rekeying, the new\
    \ Child SA MAY have\n   different Traffic Selectors and algorithms than the old\
    \ one\" was\n   changed to \"Note that, when rekeying, the new Child SA SHOULD\
    \ NOT\n   have different Traffic Selectors and algorithms than the old one\".\n\
    \   The new Section 2.8.2 covers simultaneous IKE SA rekeying.\n   The new Section\
    \ 2.9.2 covers Traffic Selectors in rekeying.\n   This document adds the restriction\
    \ in Section 2.13 that all\n   pseudorandom functions (PRFs) used with IKEv2 MUST\
    \ take variable-\n   sized keys.  This should not affect any implementations because\
    \ there\n   were no standardized PRFs that have fixed-size keys.\n   Section 2.18\
    \ requires doing a Diffie-Hellman exchange when rekeying\n   the IKE_SA.  In theory,\
    \ RFC 4306 allowed a policy where the Diffie-\n   Hellman exchange was optional,\
    \ but this was not useful (or\n   appropriate) when rekeying the IKE_SA.\n   Section\
    \ 2.21 has been greatly expanded to cover the different cases\n   where error\
    \ responses are needed and the appropriate responses to\n   them.\n   Section\
    \ 2.23 clarified that, in NAT traversal, now both UDP-\n   encapsulated IPsec\
    \ packets and non-UDP-encapsulated IPsec packets\n   need to be understood when\
    \ receiving.\n   Added Section 2.23.1 to describe NAT traversal when transport\
    \ mode is\n   requested.\n   Added Section 2.25 to explain how to act when there\
    \ are timing\n   collisions when deleting and/or rekeying SAs, and two new error\n\
    \   notifications (TEMPORARY_FAILURE and CHILD_SA_NOT_FOUND) were\n   defined.\n\
    \   In Section 3.6, \"Implementations MUST support the HTTP method for\n   hash-and-URL\
    \ lookup.  The behavior of other URL methods is not\n   currently specified, and\
    \ such methods SHOULD NOT be used in the\n   absence of a document specifying\
    \ them\" was added.\n   In Section 3.15.3, a pointer to a new document that is\
    \ related to\n   configuration of IPv6 addresses was added.\n   Appendix C was\
    \ expanded and clarified.\n"
- title: 2.  IKE Protocol Details and Variations
  contents:
  - "2.  IKE Protocol Details and Variations\n   IKE normally listens and sends on\
    \ UDP port 500, though IKE messages\n   may also be received on UDP port 4500\
    \ with a slightly different\n   format (see Section 2.23).  Since UDP is a datagram\
    \ (unreliable)\n   protocol, IKE includes in its definition recovery from transmission\n\
    \   errors, including packet loss, packet replay, and packet forgery.\n   IKE\
    \ is designed to function so long as (1) at least one of a series\n   of retransmitted\
    \ packets reaches its destination before timing out;\n   and (2) the channel is\
    \ not so full of forged and replayed packets so\n   as to exhaust the network\
    \ or CPU capacities of either endpoint.  Even\n   in the absence of those minimum\
    \ performance requirements, IKE is\n   designed to fail cleanly (as though the\
    \ network were broken).\n   Although IKEv2 messages are intended to be short,\
    \ they contain\n   structures with no hard upper bound on size (in particular,\
    \ digital\n   certificates), and IKEv2 itself does not have a mechanism for\n\
    \   fragmenting large messages.  IP defines a mechanism for fragmentation\n  \
    \ of oversized UDP messages, but implementations vary in the maximum\n   message\
    \ size supported.  Furthermore, use of IP fragmentation opens\n   an implementation\
    \ to denial-of-service (DoS) attacks [DOSUDPPROT].\n   Finally, some NAT and/or\
    \ firewall implementations may block IP\n   fragments.\n   All IKEv2 implementations\
    \ MUST be able to send, receive, and process\n   IKE messages that are up to 1280\
    \ octets long, and they SHOULD be able\n   to send, receive, and process messages\
    \ that are up to 3000 octets\n   long.  IKEv2 implementations need to be aware\
    \ of the maximum UDP\n   message size supported and MAY shorten messages by leaving\
    \ out some\n   certificates or cryptographic suite proposals if that will keep\n\
    \   messages below the maximum.  Use of the \"Hash and URL\" formats rather\n\
    \   than including certificates in exchanges where possible can avoid\n   most\
    \ problems.  Implementations and configuration need to keep in\n   mind, however,\
    \ that if the URL lookups are possible only after the\n   Child SA is established,\
    \ recursion issues could prevent this\n   technique from working.\n   The UDP\
    \ payload of all packets containing IKE messages sent on port\n   4500 MUST begin\
    \ with the prefix of four zeros; otherwise, the\n   receiver won't know how to\
    \ handle them.\n"
- title: 2.1.  Use of Retransmission Timers
  contents:
  - "2.1.  Use of Retransmission Timers\n   All messages in IKE exist in pairs: a\
    \ request and a response.  The\n   setup of an IKE SA normally consists of two\
    \ exchanges.  Once the IKE\n   SA is set up, either end of the Security Association\
    \ may initiate\n   requests at any time, and there can be many requests and responses\n\
    \   \"in flight\" at any given moment.  But each message is labeled as\n   either\
    \ a request or a response, and for each exchange, one end of the\n   Security\
    \ Association is the initiator and the other is the responder.\n   For every pair\
    \ of IKE messages, the initiator is responsible for\n   retransmission in the\
    \ event of a timeout.  The responder MUST never\n   retransmit a response unless\
    \ it receives a retransmission of the\n   request.  In that event, the responder\
    \ MUST ignore the retransmitted\n   request except insofar as it causes a retransmission\
    \ of the response.\n   The initiator MUST remember each request until it receives\
    \ the\n   corresponding response.  The responder MUST remember each response\n\
    \   until it receives a request whose sequence number is larger than or\n   equal\
    \ to the sequence number in the response plus its window size\n   (see Section\
    \ 2.3).  In order to allow saving memory, responders are\n   allowed to forget\
    \ the response after a timeout of several minutes.\n   If the responder receives\
    \ a retransmitted request for which it has\n   already forgotten the response,\
    \ it MUST ignore the request (and not,\n   for example, attempt constructing a\
    \ new response).\n   IKE is a reliable protocol: the initiator MUST retransmit\
    \ a request\n   until it either receives a corresponding response or deems the\
    \ IKE SA\n   to have failed.  In the latter case, the initiator discards all state\n\
    \   associated with the IKE SA and any Child SAs that were negotiated\n   using\
    \ that IKE SA.  A retransmission from the initiator MUST be\n   bitwise identical\
    \ to the original request.  That is, everything\n   starting from the IKE header\
    \ (the IKE SA initiator's SPI onwards)\n   must be bitwise identical; items before\
    \ it (such as the IP and UDP\n   headers) do not have to be identical.\n   Retransmissions\
    \ of the IKE_SA_INIT request require some special\n   handling.  When a responder\
    \ receives an IKE_SA_INIT request, it has\n   to determine whether the packet\
    \ is a retransmission belonging to an\n   existing \"half-open\" IKE SA (in which\
    \ case the responder retransmits\n   the same response), or a new request (in\
    \ which case the responder\n   creates a new IKE SA and sends a fresh response),\
    \ or it belongs to an\n   existing IKE SA where the IKE_AUTH request has been\
    \ already received\n   (in which case the responder ignores it).\n   It is not\
    \ sufficient to use the initiator's SPI and/or IP address to\n   differentiate\
    \ between these three cases because two different peers\n   behind a single NAT\
    \ could choose the same initiator SPI.  Instead, a\n   robust responder will do\
    \ the IKE SA lookup using the whole packet,\n   its hash, or the Ni payload.\n\
    \   The retransmission policy for one-way messages is somewhat different\n   from\
    \ that for regular messages.  Because no acknowledgement is ever\n   sent, there\
    \ is no reason to gratuitously retransmit one-way messages.\n   Given that all\
    \ these messages are errors, it makes sense to send them\n   only once per \"\
    offending\" packet, and only retransmit if further\n   offending packets are received.\
    \  Still, it also makes sense to limit\n   retransmissions of such error messages.\n"
- title: 2.2.  Use of Sequence Numbers for Message ID
  contents:
  - "2.2.  Use of Sequence Numbers for Message ID\n   Every IKE message contains a\
    \ Message ID as part of its fixed header.\n   This Message ID is used to match\
    \ up requests and responses and to\n   identify retransmissions of messages. \
    \ Retransmission of a message\n   MUST use the same Message ID as the original\
    \ message.\n   The Message ID is a 32-bit quantity, which is zero for the\n  \
    \ IKE_SA_INIT messages (including retries of the message due to\n   responses\
    \ such as COOKIE and INVALID_KE_PAYLOAD), and incremented for\n   each subsequent\
    \ exchange.  Thus, the first pair of IKE_AUTH messages\n   will have an ID of\
    \ 1, the second (when EAP is used) will be 2, and so\n   on.  The Message ID is\
    \ reset to zero in the new IKE SA after the IKE\n   SA is rekeyed.\n   Each endpoint\
    \ in the IKE Security Association maintains two \"current\"\n   Message IDs: the\
    \ next one to be used for a request it initiates and\n   the next one it expects\
    \ to see in a request from the other end.\n   These counters increment as requests\
    \ are generated and received.\n   Responses always contain the same Message ID\
    \ as the corresponding\n   request.  That means that after the initial exchange,\
    \ each integer n\n   may appear as the Message ID in four distinct messages: the\
    \ nth\n   request from the original IKE initiator, the corresponding response,\n\
    \   the nth request from the original IKE responder, and the\n   corresponding\
    \ response.  If the two ends make a very different number\n   of requests, the\
    \ Message IDs in the two directions can be very\n   different.  There is no ambiguity\
    \ in the messages, however, because\n   the Initiator and Response flags in the\
    \ message header specify which\n   of the four messages a particular one is.\n\
    \   Throughout this document, \"initiator\" refers to the party who\n   initiated\
    \ the exchange being described.  The \"original initiator\"\n   always refers\
    \ to the party who initiated the exchange that resulted\n   in the current IKE\
    \ SA.  In other words, if the \"original responder\"\n   starts rekeying the IKE\
    \ SA, that party becomes the \"original\n   initiator\" of the new IKE SA.\n \
    \  Note that Message IDs are cryptographically protected and provide\n   protection\
    \ against message replays.  In the unlikely event that\n   Message IDs grow too\
    \ large to fit in 32 bits, the IKE SA MUST be\n   closed or rekeyed.\n"
- title: 2.3.  Window Size for Overlapping Requests
  contents:
  - "2.3.  Window Size for Overlapping Requests\n   The SET_WINDOW_SIZE notification\
    \ asserts that the sending endpoint is\n   capable of keeping state for multiple\
    \ outstanding exchanges,\n   permitting the recipient to send multiple requests\
    \ before getting a\n   response to the first.  The data associated with a SET_WINDOW_SIZE\n\
    \   notification MUST be 4 octets long and contain the big endian\n   representation\
    \ of the number of messages the sender promises to keep.\n   The window size is\
    \ always one until the initial exchanges complete.\n   An IKE endpoint MUST wait\
    \ for a response to each of its messages\n   before sending a subsequent message\
    \ unless it has received a\n   SET_WINDOW_SIZE Notify message from its peer informing\
    \ it that the\n   peer is prepared to maintain state for multiple outstanding\
    \ messages\n   in order to allow greater throughput.\n   After an IKE SA is set\
    \ up, in order to maximize IKE throughput, an\n   IKE endpoint MAY issue multiple\
    \ requests before getting a response to\n   any of them, up to the limit set by\
    \ its peer's SET_WINDOW_SIZE.\n   These requests may pass one another over the\
    \ network.  An IKE\n   endpoint MUST be prepared to accept and process a request\
    \ while it\n   has a request outstanding in order to avoid a deadlock in this\n\
    \   situation.  An IKE endpoint may also accept and process multiple\n   requests\
    \ while it has a request outstanding.\n   An IKE endpoint MUST NOT exceed the\
    \ peer's stated window size for\n   transmitted IKE requests.  In other words,\
    \ if the responder stated\n   its window size is N, then when the initiator needs\
    \ to make a request\n   X, it MUST wait until it has received responses to all\
    \ requests up\n   through request X-N.  An IKE endpoint MUST keep a copy of (or\
    \ be able\n   to regenerate exactly) each request it has sent until it receives\
    \ the\n   corresponding response.  An IKE endpoint MUST keep a copy of (or be\n\
    \   able to regenerate exactly) the number of previous responses equal to\n  \
    \ its declared window size in case its response was lost and the\n   initiator\
    \ requests its retransmission by retransmitting the request.\n   An IKE endpoint\
    \ supporting a window size greater than one ought to be\n   capable of processing\
    \ incoming requests out of order to maximize\n   performance in the event of network\
    \ failures or packet reordering.\n   The window size is normally a (possibly configurable)\
    \ property of a\n   particular implementation, and is not related to congestion\
    \ control\n   (unlike the window size in TCP, for example).  In particular, what\n\
    \   the responder should do when it receives a SET_WINDOW_SIZE\n   notification\
    \ containing a smaller value than is currently in effect\n   is not defined. \
    \ Thus, there is currently no way to reduce the window\n   size of an existing\
    \ IKE SA; you can only increase it.  When rekeying\n   an IKE SA, the new IKE\
    \ SA starts with window size 1 until it is\n   explicitly increased by sending\
    \ a new SET_WINDOW_SIZE notification.\n   The INVALID_MESSAGE_ID notification\
    \ is sent when an IKE Message ID\n   outside the supported window is received.\
    \  This Notify message MUST\n   NOT be sent in a response; the invalid request\
    \ MUST NOT be\n   acknowledged.  Instead, inform the other side by initiating\
    \ an\n   INFORMATIONAL exchange with Notification data containing the four-\n\
    \   octet invalid Message ID.  Sending this notification is OPTIONAL, and\n  \
    \ notifications of this type MUST be rate limited.\n"
- title: 2.4.  State Synchronization and Connection Timeouts
  contents:
  - "2.4.  State Synchronization and Connection Timeouts\n   An IKE endpoint is allowed\
    \ to forget all of its state associated with\n   an IKE SA and the collection\
    \ of corresponding Child SAs at any time.\n   This is the anticipated behavior\
    \ in the event of an endpoint crash\n   and restart.  It is important when an\
    \ endpoint either fails or\n   reinitializes its state that the other endpoint\
    \ detect those\n   conditions and not continue to waste network bandwidth by sending\n\
    \   packets over discarded SAs and having them fall into a black hole.\n   The\
    \ INITIAL_CONTACT notification asserts that this IKE SA is the only\n   IKE SA\
    \ currently active between the authenticated identities.  It MAY\n   be sent when\
    \ an IKE SA is established after a crash, and the\n   recipient MAY use this information\
    \ to delete any other IKE SAs it has\n   to the same authenticated identity without\
    \ waiting for a timeout.\n   This notification MUST NOT be sent by an entity that\
    \ may be\n   replicated (e.g., a roaming user's credentials where the user is\n\
    \   allowed to connect to the corporate firewall from two remote systems\n   at\
    \ the same time).  The INITIAL_CONTACT notification, if sent, MUST\n   be in the\
    \ first IKE_AUTH request or response, not as a separate\n   exchange afterwards;\
    \ receiving parties MAY ignore it in other\n   messages.\n   Since IKE is designed\
    \ to operate in spite of DoS attacks from the\n   network, an endpoint MUST NOT\
    \ conclude that the other endpoint has\n   failed based on any routing information\
    \ (e.g., ICMP messages) or IKE\n   messages that arrive without cryptographic\
    \ protection (e.g., Notify\n   messages complaining about unknown SPIs).  An endpoint\
    \ MUST conclude\n   that the other endpoint has failed only when repeated attempts\
    \ to\n   contact it have gone unanswered for a timeout period or when a\n   cryptographically\
    \ protected INITIAL_CONTACT notification is received\n   on a different IKE SA\
    \ to the same authenticated identity.  An\n   endpoint should suspect that the\
    \ other endpoint has failed based on\n   routing information and initiate a request\
    \ to see whether the other\n   endpoint is alive.  To check whether the other\
    \ side is alive, IKE\n   specifies an empty INFORMATIONAL message that (like all\
    \ IKE requests)\n   requires an acknowledgement (note that within the context\
    \ of an IKE\n   SA, an \"empty\" message consists of an IKE header followed by\
    \ an\n   Encrypted payload that contains no payloads).  If a cryptographically\n\
    \   protected (fresh, i.e., not retransmitted) message has been received\n   from\
    \ the other side recently, unprotected Notify messages MAY be\n   ignored.  Implementations\
    \ MUST limit the rate at which they take\n   actions based on unprotected messages.\n\
    \   The number of retries and length of timeouts are not covered in this\n   specification\
    \ because they do not affect interoperability.  It is\n   suggested that messages\
    \ be retransmitted at least a dozen times over\n   a period of at least several\
    \ minutes before giving up on an SA, but\n   different environments may require\
    \ different rules.  To be a good\n   network citizen, retransmission times MUST\
    \ increase exponentially to\n   avoid flooding the network and making an existing\
    \ congestion\n   situation worse.  If there has only been outgoing traffic on\
    \ all of\n   the SAs associated with an IKE SA, it is essential to confirm\n \
    \  liveness of the other endpoint to avoid black holes.  If no\n   cryptographically\
    \ protected messages have been received on an IKE SA\n   or any of its Child SAs\
    \ recently, the system needs to perform a\n   liveness check in order to prevent\
    \ sending messages to a dead peer.\n   (This is sometimes called \"dead peer detection\"\
    \ or \"DPD\", although it\n   is really detecting live peers, not dead ones.)\
    \  Receipt of a fresh\n   cryptographically protected message on an IKE SA or\
    \ any of its Child\n   SAs ensures liveness of the IKE SA and all of its Child\
    \ SAs.  Note\n   that this places requirements on the failure modes of an IKE\n\
    \   endpoint.  An implementation needs to stop sending over any SA if\n   some\
    \ failure prevents it from receiving on all of the associated SAs.\n   If a system\
    \ creates Child SAs that can fail independently from one\n   another without the\
    \ associated IKE SA being able to send a delete\n   message, then the system MUST\
    \ negotiate such Child SAs using separate\n   IKE SAs.\n   There is a DoS attack\
    \ on the initiator of an IKE SA that can be\n   avoided if the initiator takes\
    \ the proper care.  Since the first two\n   messages of an SA setup are not cryptographically\
    \ protected, an\n   attacker could respond to the initiator's message before the\
    \ genuine\n   responder and poison the connection setup attempt.  To prevent this,\n\
    \   the initiator MAY be willing to accept multiple responses to its\n   first\
    \ message, treat each as potentially legitimate, respond to it,\n   and then discard\
    \ all the invalid half-open connections when it\n   receives a valid cryptographically\
    \ protected response to any one of\n   its requests.  Once a cryptographically\
    \ valid response is received,\n   all subsequent responses should be ignored whether\
    \ or not they are\n   cryptographically valid.\n   Note that with these rules,\
    \ there is no reason to negotiate and agree\n   upon an SA lifetime.  If IKE presumes\
    \ the partner is dead, based on\n   repeated lack of acknowledgement to an IKE\
    \ message, then the IKE SA\n   and all Child SAs set up through that IKE SA are\
    \ deleted.\n   An IKE endpoint may at any time delete inactive Child SAs to recover\n\
    \   resources used to hold their state.  If an IKE endpoint chooses to\n   delete\
    \ Child SAs, it MUST send Delete payloads to the other end\n   notifying it of\
    \ the deletion.  It MAY similarly time out the IKE SA.\n   Closing the IKE SA\
    \ implicitly closes all associated Child SAs.  In\n   this case, an IKE endpoint\
    \ SHOULD send a Delete payload indicating\n   that it has closed the IKE SA unless\
    \ the other endpoint is no longer\n   responding.\n"
- title: 2.5.  Version Numbers and Forward Compatibility
  contents:
  - "2.5.  Version Numbers and Forward Compatibility\n   This document describes version\
    \ 2.0 of IKE, meaning the major version\n   number is 2 and the minor version\
    \ number is 0.  This document is a\n   replacement for [IKEV2].  It is likely\
    \ that some implementations will\n   want to support version 1.0 and version 2.0,\
    \ and in the future, other\n   versions.\n   The major version number should be\
    \ incremented only if the packet\n   formats or required actions have changed\
    \ so dramatically that an\n   older version node would not be able to interoperate\
    \ with a newer\n   version node if it simply ignored the fields it did not understand\n\
    \   and took the actions specified in the older specification.  The minor\n  \
    \ version number indicates new capabilities, and MUST be ignored by a\n   node\
    \ with a smaller minor version number, but used for informational\n   purposes\
    \ by the node with the larger minor version number.  For\n   example, it might\
    \ indicate the ability to process a newly defined\n   Notify message type.  The\
    \ node with the larger minor version number\n   would simply note that its correspondent\
    \ would not be able to\n   understand that message and therefore would not send\
    \ it.\n   If an endpoint receives a message with a higher major version number,\n\
    \   it MUST drop the message and SHOULD send an unauthenticated Notify\n   message\
    \ of type INVALID_MAJOR_VERSION containing the highest\n   (closest) version number\
    \ it supports.  If an endpoint supports major\n   version n, and major version\
    \ m, it MUST support all versions between\n   n and m.  If it receives a message\
    \ with a major version that it\n   supports, it MUST respond with that version\
    \ number.  In order to\n   prevent two nodes from being tricked into corresponding\
    \ with a lower\n   major version number than the maximum that they both support,\
    \ IKE has\n   a flag that indicates that the node is capable of speaking a higher\n\
    \   major version number.\n   Thus, the major version number in the IKE header\
    \ indicates the\n   version number of the message, not the highest version number\
    \ that\n   the transmitter supports.  If the initiator is capable of speaking\n\
    \   versions n, n+1, and n+2, and the responder is capable of speaking\n   versions\
    \ n and n+1, then they will negotiate speaking n+1, where the\n   initiator will\
    \ set a flag indicating its ability to speak a higher\n   version.  If they mistakenly\
    \ (perhaps through an active attacker\n   sending error messages) negotiate to\
    \ version n, then both will notice\n   that the other side can support a higher\
    \ version number, and they\n   MUST break the connection and reconnect using version\
    \ n+1.\n   Note that IKEv1 does not follow these rules, because there is no way\n\
    \   in v1 of noting that you are capable of speaking a higher version\n   number.\
    \  So an active attacker can trick two v2-capable nodes into\n   speaking v1.\
    \  When a v2-capable node negotiates down to v1, it should\n   note that fact\
    \ in its logs.\n   Also, for forward compatibility, all fields marked RESERVED\
    \ MUST be\n   set to zero by an implementation running version 2.0, and their\n\
    \   content MUST be ignored by an implementation running version 2.0 (\"Be\n \
    \  conservative in what you send and liberal in what you receive\" [IP]).\n  \
    \ In this way, future versions of the protocol can use those fields in\n   a way\
    \ that is guaranteed to be ignored by implementations that do not\n   understand\
    \ them.  Similarly, payload types that are not defined are\n   reserved for future\
    \ use; implementations of a version where they are\n   undefined MUST skip over\
    \ those payloads and ignore their contents.\n   IKEv2 adds a \"critical\" flag\
    \ to each payload header for further\n   flexibility for forward compatibility.\
    \  If the critical flag is set\n   and the payload type is unrecognized, the message\
    \ MUST be rejected\n   and the response to the IKE request containing that payload\
    \ MUST\n   include a Notify payload UNSUPPORTED_CRITICAL_PAYLOAD, indicating an\n\
    \   unsupported critical payload was included.  In that Notify payload,\n   the\
    \ notification data contains the one-octet payload type.  If the\n   critical\
    \ flag is not set and the payload type is unsupported, that\n   payload MUST be\
    \ ignored.  Payloads sent in IKE response messages MUST\n   NOT have the critical\
    \ flag set.  Note that the critical flag applies\n   only to the payload type,\
    \ not the contents.  If the payload type is\n   recognized, but the payload contains\
    \ something that is not (such as\n   an unknown transform inside an SA payload,\
    \ or an unknown Notify\n   Message Type inside a Notify payload), the critical\
    \ flag is ignored.\n   Although new payload types may be added in the future and\
    \ may appear\n   interleaved with the fields defined in this specification,\n\
    \   implementations SHOULD send the payloads defined in this\n   specification\
    \ in the order shown in the figures in Sections 1 and 2;\n   implementations MUST\
    \ NOT reject as invalid a message with those\n   payloads in any other order.\n"
- title: 2.6.  IKE SA SPIs and Cookies
  contents:
  - "2.6.  IKE SA SPIs and Cookies\n   The initial two eight-octet fields in the header,\
    \ called the \"IKE\n   SPIs\", are used as a connection identifier at the beginning\
    \ of IKE\n   packets.  Each endpoint chooses one of the two SPIs and MUST choose\n\
    \   them so as to be unique identifiers of an IKE SA.  An SPI value of\n   zero\
    \ is special: it indicates that the remote SPI value is not yet\n   known by the\
    \ sender.\n   Incoming IKE packets are mapped to an IKE SA only using the packet's\n\
    \   SPI, not using (for example) the source IP address of the packet.\n   Unlike\
    \ ESP and AH where only the recipient's SPI appears in the\n   header of a message,\
    \ in IKE the sender's SPI is also sent in every\n   message.  Since the SPI chosen\
    \ by the original initiator of the IKE\n   SA is always sent first, an endpoint\
    \ with multiple IKE SAs open that\n   wants to find the appropriate IKE SA using\
    \ the SPI it assigned must\n   look at the Initiator flag in the header to determine\
    \ whether it\n   assigned the first or the second eight octets.\n   In the first\
    \ message of an initial IKE exchange, the initiator will\n   not know the responder's\
    \ SPI value and will therefore set that field\n   to zero.  When the IKE_SA_INIT\
    \ exchange does not result in the\n   creation of an IKE SA due to INVALID_KE_PAYLOAD,\
    \ NO_PROPOSAL_CHOSEN,\n   or COOKIE (see Section 2.6), the responder's SPI will\
    \ be zero also in\n   the response message.  However, if the responder sends a\
    \ non-zero\n   responder SPI, the initiator should not reject the response for\
    \ only\n   that reason.\n   Two expected attacks against IKE are state and CPU\
    \ exhaustion, where\n   the target is flooded with session initiation requests\
    \ from forged IP\n   addresses.  These attacks can be made less effective if a\
    \ responder\n   uses minimal CPU and commits no state to an SA until it knows\
    \ the\n   initiator can receive packets at the address from which it claims to\n\
    \   be sending them.\n   When a responder detects a large number of half-open\
    \ IKE SAs, it\n   SHOULD reply to IKE_SA_INIT requests with a response containing\
    \ the\n   COOKIE notification.  The data associated with this notification MUST\n\
    \   be between 1 and 64 octets in length (inclusive), and its generation\n   is\
    \ described later in this section.  If the IKE_SA_INIT response\n   includes the\
    \ COOKIE notification, the initiator MUST then retry the\n   IKE_SA_INIT request,\
    \ and include the COOKIE notification containing\n   the received data as the\
    \ first payload, and all other payloads\n   unchanged.  The initial exchange will\
    \ then be as follows:\n   Initiator                         Responder\n   -------------------------------------------------------------------\n\
    \   HDR(A,0), SAi1, KEi, Ni  -->\n                                <--  HDR(A,0),\
    \ N(COOKIE)\n   HDR(A,0), N(COOKIE), SAi1,\n       KEi, Ni  -->\n            \
    \                    <--  HDR(A,B), SAr1, KEr,\n                             \
    \            Nr, [CERTREQ]\n   HDR(A,B), SK {IDi, [CERT,]\n       [CERTREQ,] [IDr,]\
    \ AUTH,\n       SAi2, TSi, TSr}  -->\n                                <--  HDR(A,B),\
    \ SK {IDr, [CERT,]\n                                         AUTH, SAr2, TSi,\
    \ TSr}\n   The first two messages do not affect any initiator or responder state\n\
    \   except for communicating the cookie.  In particular, the message\n   sequence\
    \ numbers in the first four messages will all be zero and the\n   message sequence\
    \ numbers in the last two messages will be one.  'A'\n   is the SPI assigned by\
    \ the initiator, while 'B' is the SPI assigned\n   by the responder.\n   An IKE\
    \ implementation can implement its responder cookie generation\n   in such a way\
    \ as to not require any saved state to recognize its\n   valid cookie when the\
    \ second IKE_SA_INIT message arrives.  The exact\n   algorithms and syntax used\
    \ to generate cookies do not affect\n   interoperability and hence are not specified\
    \ here.  The following is\n   an example of how an endpoint could use cookies\
    \ to implement limited\n   DoS protection.\n   A good way to do this is to set\
    \ the responder cookie to be:\n   Cookie = <VersionIDofSecret> | Hash(Ni | IPi\
    \ | SPIi | <secret>)\n   where <secret> is a randomly generated secret known only\
    \ to the\n   responder and periodically changed and | indicates concatenation.\n\
    \   <VersionIDofSecret> should be changed whenever <secret> is\n   regenerated.\
    \  The cookie can be recomputed when the IKE_SA_INIT\n   arrives the second time\
    \ and compared to the cookie in the received\n   message.  If it matches, the\
    \ responder knows that the cookie was\n   generated since the last change to <secret>\
    \ and that IPi must be the\n   same as the source address it saw the first time.\
    \  Incorporating SPIi\n   into the calculation ensures that if multiple IKE SAs\
    \ are being set\n   up in parallel they will all get different cookies (assuming\
    \ the\n   initiator chooses unique SPIi's).  Incorporating Ni in the hash\n  \
    \ ensures that an attacker who sees only message 2 can't successfully\n   forge\
    \ a message 3.  Also, incorporating SPIi in the hash prevents an\n   attacker\
    \ from fetching one cookie from the other end, and then\n   initiating many IKE_SA_INIT\
    \ exchanges all with different initiator\n   SPIs (and perhaps port numbers) so\
    \ that the responder thinks that\n   there are a lot of machines behind one NAT\
    \ box that are all trying to\n   connect.\n   If a new value for <secret> is chosen\
    \ while there are connections in\n   the process of being initialized, an IKE_SA_INIT\
    \ might be returned\n   with other than the current <VersionIDofSecret>.  The\
    \ responder in\n   that case MAY reject the message by sending another response\
    \ with a\n   new cookie or it MAY keep the old value of <secret> around for a\n\
    \   short time and accept cookies computed from either one.  The\n   responder\
    \ should not accept cookies indefinitely after <secret> is\n   changed, since\
    \ that would defeat part of the DoS protection.  The\n   responder should change\
    \ the value of <secret> frequently, especially\n   if under attack.\n   When one\
    \ party receives an IKE_SA_INIT request containing a cookie\n   whose contents\
    \ do not match the value expected, that party MUST\n   ignore the cookie and process\
    \ the message as if no cookie had been\n   included; usually this means sending\
    \ a response containing a new\n   cookie.  The initiator should limit the number\
    \ of cookie exchanges it\n   tries before giving up, possibly using exponential\
    \ back-off.  An\n   attacker can forge multiple cookie responses to the initiator's\n\
    \   IKE_SA_INIT message, and each of those forged cookie replies will\n   cause\
    \ two packets to be sent: one packet from the initiator to the\n   responder (which\
    \ will reject those cookies), and one response from\n   responder to initiator\
    \ that includes the correct cookie.\n   A note on terminology: the term \"cookies\"\
    \ originates with Karn and\n   Simpson [PHOTURIS] in Photuris, an early proposal\
    \ for key management\n   with IPsec, and it has persisted.  The Internet Security\
    \ Association\n   and Key Management Protocol (ISAKMP) [ISAKMP] fixed message\
    \ header\n   includes two eight-octet fields called \"cookies\", and that syntax\
    \ is\n   used by both IKEv1 and IKEv2, although in IKEv2 they are referred to\n\
    \   as the \"IKE SPI\" and there is a new separate field in a Notify\n   payload\
    \ holding the cookie.\n"
- title: 2.6.1.  Interaction of COOKIE and INVALID_KE_PAYLOAD
  contents:
  - "2.6.1.  Interaction of COOKIE and INVALID_KE_PAYLOAD\n   There are two common\
    \ reasons why the initiator may have to retry the\n   IKE_SA_INIT exchange: the\
    \ responder requests a cookie or wants a\n   different Diffie-Hellman group than\
    \ was included in the KEi payload.\n   If the initiator receives a cookie from\
    \ the responder, the initiator\n   needs to decide whether or not to include the\
    \ cookie in only the next\n   retry of the IKE_SA_INIT request, or in all subsequent\
    \ retries as\n   well.\n   If the initiator includes the cookie only in the next\
    \ retry, one\n   additional round trip may be needed in some cases.  An additional\n\
    \   round trip is needed also if the initiator includes the cookie in all\n  \
    \ retries, but the responder does not support this.  For instance, if\n   the\
    \ responder includes the KEi payloads in cookie calculation, it\n   will reject\
    \ the request by sending a new cookie.\n   If both peers support including the\
    \ cookie in all retries, a slightly\n   shorter exchange can happen.\n   Initiator\
    \                   Responder\n   -----------------------------------------------------------\n\
    \   HDR(A,0), SAi1, KEi, Ni -->\n                           <-- HDR(A,0), N(COOKIE)\n\
    \   HDR(A,0), N(COOKIE), SAi1, KEi, Ni  -->\n                           <-- HDR(A,0),\
    \ N(INVALID_KE_PAYLOAD)\n   HDR(A,0), N(COOKIE), SAi1, KEi', Ni -->\n        \
    \                   <-- HDR(A,B), SAr1, KEr, Nr\n   Implementations SHOULD support\
    \ this shorter exchange, but MUST NOT\n   fail if other implementations do not\
    \ support this shorter exchange.\n"
- title: 2.7.  Cryptographic Algorithm Negotiation
  contents:
  - "2.7.  Cryptographic Algorithm Negotiation\n   The payload type known as \"SA\"\
    \ indicates a proposal for a set of\n   choices of IPsec protocols (IKE, ESP,\
    \ or AH) for the SA as well as\n   cryptographic algorithms associated with each\
    \ protocol.\n   An SA payload consists of one or more proposals.  Each proposal\n\
    \   includes one protocol.  Each protocol contains one or more transforms\n  \
    \ -- each specifying a cryptographic algorithm.  Each transform\n   contains zero\
    \ or more attributes (attributes are needed only if the\n   Transform ID does\
    \ not completely specify the cryptographic\n   algorithm).\n   This hierarchical\
    \ structure was designed to efficiently encode\n   proposals for cryptographic\
    \ suites when the number of supported\n   suites is large because multiple values\
    \ are acceptable for multiple\n   transforms.  The responder MUST choose a single\
    \ suite, which may be\n   any subset of the SA proposal following the rules below.\n\
    \   Each proposal contains one protocol.  If a proposal is accepted, the\n   SA\
    \ response MUST contain the same protocol.  The responder MUST\n   accept a single\
    \ proposal or reject them all and return an error.  The\n   error is given in\
    \ a notification of type NO_PROPOSAL_CHOSEN.\n   Each IPsec protocol proposal\
    \ contains one or more transforms.  Each\n   transform contains a Transform Type.\
    \  The accepted cryptographic\n   suite MUST contain exactly one transform of\
    \ each type included in the\n   proposal.  For example: if an ESP proposal includes\
    \ transforms\n   ENCR_3DES, ENCR_AES w/keysize 128, ENCR_AES w/keysize 256,\n\
    \   AUTH_HMAC_MD5, and AUTH_HMAC_SHA, the accepted suite MUST contain one\n  \
    \ of the ENCR_ transforms and one of the AUTH_ transforms.  Thus, six\n   combinations\
    \ are acceptable.\n   If an initiator proposes both normal ciphers with integrity\n\
    \   protection as well as combined-mode ciphers, then two proposals are\n   needed.\
    \  One of the proposals includes the normal ciphers with the\n   integrity algorithms\
    \ for them, and the other proposal includes all\n   the combined-mode ciphers\
    \ without the integrity algorithms (because\n   combined-mode ciphers are not\
    \ allowed to have any integrity algorithm\n   other than \"none\").\n"
- title: 2.8.  Rekeying
  contents:
  - "2.8.  Rekeying\n   IKE, ESP, and AH Security Associations use secret keys that\
    \ should be\n   used only for a limited amount of time and to protect a limited\n\
    \   amount of data.  This limits the lifetime of the entire Security\n   Association.\
    \  When the lifetime of a Security Association expires,\n   the Security Association\
    \ MUST NOT be used.  If there is demand, new\n   Security Associations MAY be\
    \ established.  Reestablishment of\n   Security Associations to take the place\
    \ of ones that expire is\n   referred to as \"rekeying\".\n   To allow for minimal\
    \ IPsec implementations, the ability to rekey SAs\n   without restarting the entire\
    \ IKE SA is optional.  An implementation\n   MAY refuse all CREATE_CHILD_SA requests\
    \ within an IKE SA.  If an SA\n   has expired or is about to expire and rekeying\
    \ attempts using the\n   mechanisms described here fail, an implementation MUST\
    \ close the IKE\n   SA and any associated Child SAs and then MAY start new ones.\n\
    \   Implementations may wish to support in-place rekeying of SAs, since\n   doing\
    \ so offers better performance and is likely to reduce the number\n   of packets\
    \ lost during the transition.\n   To rekey a Child SA within an existing IKE SA,\
    \ create a new,\n   equivalent SA (see Section 2.17 below), and when the new one\
    \ is\n   established, delete the old one.  Note that, when rekeying, the new\n\
    \   Child SA SHOULD NOT have different Traffic Selectors and algorithms\n   than\
    \ the old one.\n   To rekey an IKE SA, establish a new equivalent IKE SA (see\n\
    \   Section 2.18 below) with the peer to whom the old IKE SA is shared\n   using\
    \ a CREATE_CHILD_SA within the existing IKE SA.  An IKE SA so\n   created inherits\
    \ all of the original IKE SA's Child SAs, and the new\n   IKE SA is used for all\
    \ control messages needed to maintain those\n   Child SAs.  After the new equivalent\
    \ IKE SA is created, the initiator\n   deletes the old IKE SA, and the Delete\
    \ payload to delete itself MUST\n   be the last request sent over the old IKE\
    \ SA.\n   SAs should be rekeyed proactively, i.e., the new SA should be\n   established\
    \ before the old one expires and becomes unusable.  Enough\n   time should elapse\
    \ between the time the new SA is established and the\n   old one becomes unusable\
    \ so that traffic can be switched over to the\n   new SA.\n   A difference between\
    \ IKEv1 and IKEv2 is that in IKEv1 SA lifetimes\n   were negotiated.  In IKEv2,\
    \ each end of the SA is responsible for\n   enforcing its own lifetime policy\
    \ on the SA and rekeying the SA when\n   necessary.  If the two ends have different\
    \ lifetime policies, the end\n   with the shorter lifetime will end up always\
    \ being the one to request\n   the rekeying.  If an SA has been inactive for a\
    \ long time and if an\n   endpoint would not initiate the SA in the absence of\
    \ traffic, the\n   endpoint MAY choose to close the SA instead of rekeying it\
    \ when its\n   lifetime expires.  It can also do so if there has been no traffic\n\
    \   since the last time the SA was rekeyed.\n   Note that IKEv2 deliberately allows\
    \ parallel SAs with the same\n   Traffic Selectors between common endpoints. \
    \ One of the purposes of\n   this is to support traffic quality of service (QoS)\
    \ differences among\n   the SAs (see [DIFFSERVFIELD], [DIFFSERVARCH], and Section\
    \ 4.1 of\n   [DIFFTUNNEL]).  Hence unlike IKEv1, the combination of the endpoints\n\
    \   and the Traffic Selectors may not uniquely identify an SA between\n   those\
    \ endpoints, so the IKEv1 rekeying heuristic of deleting SAs on\n   the basis\
    \ of duplicate Traffic Selectors SHOULD NOT be used.\n   There are timing windows\
    \ -- particularly in the presence of lost\n   packets -- where endpoints may not\
    \ agree on the state of an SA.  The\n   responder to a CREATE_CHILD_SA MUST be\
    \ prepared to accept messages on\n   an SA before sending its response to the\
    \ creation request, so there\n   is no ambiguity for the initiator.  The initiator\
    \ MAY begin sending\n   on an SA as soon as it processes the response.  The initiator,\n\
    \   however, cannot receive on a newly created SA until it receives and\n   processes\
    \ the response to its CREATE_CHILD_SA request.  How, then, is\n   the responder\
    \ to know when it is OK to send on the newly created SA?\n   From a technical\
    \ correctness and interoperability perspective, the\n   responder MAY begin sending\
    \ on an SA as soon as it sends its response\n   to the CREATE_CHILD_SA request.\
    \  In some situations, however, this\n   could result in packets unnecessarily\
    \ being dropped, so an\n   implementation MAY defer such sending.\n   The responder\
    \ can be assured that the initiator is prepared to\n   receive messages on an\
    \ SA if either (1) it has received a\n   cryptographically valid message on the\
    \ other half of the SA pair, or\n   (2) the new SA rekeys an existing SA and it\
    \ receives an IKE request\n   to close the replaced SA.  When rekeying an SA,\
    \ the responder\n   continues to send traffic on the old SA until one of those\
    \ events\n   occurs.  When establishing a new SA, the responder MAY defer sending\n\
    \   messages on a new SA until either it receives one or a timeout has\n   occurred.\
    \  If an initiator receives a message on an SA for which it\n   has not received\
    \ a response to its CREATE_CHILD_SA request, it\n   interprets that as a likely\
    \ packet loss and retransmits the\n   CREATE_CHILD_SA request.  An initiator MAY\
    \ send a dummy ESP message\n   on a newly created ESP SA if it has no messages\
    \ queued in order to\n   assure the responder that the initiator is ready to receive\
    \ messages.\n"
- title: 2.8.1.  Simultaneous Child SA Rekeying
  contents:
  - "2.8.1.  Simultaneous Child SA Rekeying\n   If the two ends have the same lifetime\
    \ policies, it is possible that\n   both will initiate a rekeying at the same\
    \ time (which will result in\n   redundant SAs).  To reduce the probability of\
    \ this happening, the\n   timing of rekeying requests SHOULD be jittered (delayed\
    \ by a random\n   amount of time after the need for rekeying is noticed).\n  \
    \ This form of rekeying may temporarily result in multiple similar SAs\n   between\
    \ the same pairs of nodes.  When there are two SAs eligible to\n   receive packets,\
    \ a node MUST accept incoming packets through either\n   SA.  If redundant SAs\
    \ are created though such a collision, the SA\n   created with the lowest of the\
    \ four nonces used in the two exchanges\n   SHOULD be closed by the endpoint that\
    \ created it.  \"Lowest\" means an\n   octet-by-octet comparison (instead of,\
    \ for instance, comparing the\n   nonces as large integers).  In other words,\
    \ start by comparing the\n   first octet; if they're equal, move to the next octet,\
    \ and so on.  If\n   you reach the end of one nonce, that nonce is the lower one.\
    \  The\n   node that initiated the surviving rekeyed SA should delete the\n  \
    \ replaced SA after the new one is established.\n   The following is an explanation\
    \ on the impact this has on\n   implementations.  Assume that hosts A and B have\
    \ an existing Child SA\n   pair with SPIs (SPIa1,SPIb1), and both start rekeying\
    \ it at the same\n   time:\n   Host A                            Host B\n   -------------------------------------------------------------------\n\
    \   send req1: N(REKEY_SA,SPIa1),\n       SA(..,SPIa2,..),Ni1,..  -->\n      \
    \                          <--  send req2: N(REKEY_SA,SPIb1),\n              \
    \                           SA(..,SPIb2,..),Ni2\n   recv req2 <--\n   At this\
    \ point, A knows there is a simultaneous rekeying happening.\n   However, it cannot\
    \ yet know which of the exchanges will have the\n   lowest nonce, so it will just\
    \ note the situation and respond as\n   usual.\n   send resp2: SA(..,SPIa3,..),\n\
    \        Nr1,..  -->\n                                -->  recv req1\n   Now B\
    \ also knows that simultaneous rekeying is going on.  It responds\n   as usual.\n\
    \                               <--  send resp1: SA(..,SPIb3,..),\n          \
    \                              Nr2,..\n   recv resp1 <--\n                   \
    \            -->  recv resp2\n   At this point, there are three Child SA pairs\
    \ between A and B (the\n   old one and two new ones).  A and B can now compare\
    \ the nonces.\n   Suppose that the lowest nonce was Nr1 in message resp2; in this\
    \ case,\n   B (the sender of req2) deletes the redundant new SA, and A (the node\n\
    \   that initiated the surviving rekeyed SA), deletes the old one.\n   send req3:\
    \ D(SPIa1) -->\n                                <--  send req4: D(SPIb2)\n   \
    \                             -->  recv req3\n                               \
    \ <--  send resp3: D(SPIb1)\n   recv req4 <--\n   send resp4: D(SPIa3) -->\n \
    \  The rekeying is now finished.\n   However, there is a second possible sequence\
    \ of events that can\n   happen if some packets are lost in the network, resulting\
    \ in\n   retransmissions.  The rekeying begins as usual, but A's first packet\n\
    \   (req1) is lost.\n   Host A                            Host B\n   -------------------------------------------------------------------\n\
    \   send req1: N(REKEY_SA,SPIa1),\n       SA(..,SPIa2,..),\n       Ni1,..  -->\
    \  (lost)\n                                <--  send req2: N(REKEY_SA,SPIb1),\n\
    \                                         SA(..,SPIb2,..),Ni2\n   recv req2 <--\n\
    \   send resp2: SA(..,SPIa3,..),\n       Nr1,.. -->\n                        \
    \        -->  recv resp2\n                                <--  send req3: D(SPIb1)\n\
    \   recv req3 <--\n   send resp3: D(SPIa1) -->\n                             \
    \   -->  recv resp3\n   From B's point of view, the rekeying is now completed,\
    \ and since it\n   has not yet received A's req1, it does not even know that there\
    \ was\n   simultaneous rekeying.  However, A will continue retransmitting the\n\
    \   message, and eventually it will reach B.\n   resend req1 -->\n           \
    \                     -->  recv req1\n   To B, it looks like A is trying to rekey\
    \ an SA that no longer exists;\n   thus, B responds to the request with something\
    \ non-fatal such as\n   CHILD_SA_NOT_FOUND.\n                                <--\
    \  send resp1: N(CHILD_SA_NOT_FOUND)\n   recv resp1 <--\n   When A receives this\
    \ error, it already knows there was simultaneous\n   rekeying, so it can ignore\
    \ the error message.\n"
- title: 2.8.2.  Simultaneous IKE SA Rekeying
  contents:
  - "2.8.2.  Simultaneous IKE SA Rekeying\n   Probably the most complex case occurs\
    \ when both peers try to rekey\n   the IKE_SA at the same time.  Basically, the\
    \ text in Section 2.8\n   applies to this case as well; however, it is important\
    \ to ensure that\n   the Child SAs are inherited by the correct IKE_SA.\n   The\
    \ case where both endpoints notice the simultaneous rekeying works\n   the same\
    \ way as with Child SAs.  After the CREATE_CHILD_SA exchanges,\n   three IKE SAs\
    \ exist between A and B: the old IKE SA and two new IKE\n   SAs.  The new IKE\
    \ SA containing the lowest nonce SHOULD be deleted by\n   the node that created\
    \ it, and the other surviving new IKE SA MUST\n   inherit all the Child SAs.\n\
    \   In addition to normal simultaneous rekeying cases, there is a special\n  \
    \ case where one peer finishes its rekey before it even notices that\n   other\
    \ peer is doing a rekey.  If only one peer detects a simultaneous\n   rekey, redundant\
    \ SAs are not created.  In this case, when the peer\n   that did not notice the\
    \ simultaneous rekey gets the request to rekey\n   the IKE SA that it has already\
    \ successfully rekeyed, it SHOULD return\n   TEMPORARY_FAILURE because it is an\
    \ IKE SA that it is currently trying\n   to close (whether or not it has already\
    \ sent the delete notification\n   for the SA).  If the peer that did notice the\
    \ simultaneous rekey gets\n   the delete request from the other peer for the old\
    \ IKE SA, it knows\n   that the other peer did not detect the simultaneous rekey,\
    \ and the\n   first peer can forget its own rekey attempt.\n   Host A        \
    \              Host B\n   -------------------------------------------------------------------\n\
    \   send req1:\n        SA(..,SPIa1,..),Ni1,.. -->\n                         \
    \    <-- send req2: SA(..,SPIb1,..),Ni2,..\n                             --> recv\
    \ req1\n                             <-- send resp1: SA(..,SPIb2,..),Nr2,..\n\
    \   recv resp1 <--\n   send req3: D() -->\n                             --> recv\
    \ req3\n   At this point, host B sees a request to close the IKE_SA.  There's\n\
    \   not much more to do than to reply as usual.  However, at this point\n   host\
    \ B should stop retransmitting req2, since once host A receives\n   resp3, it\
    \ will delete all the state associated with the old IKE_SA\n   and will not be\
    \ able to reply to it.\n                             <-- send resp3: ()\n   The\
    \ TEMPORARY_FAILURE notification was not included in RFC 4306, and\n   support\
    \ of the TEMPORARY_FAILURE notification is not negotiated.\n   Thus, older peers\
    \ that implement RFC 4306 but not this document may\n   receive these notifications.\
    \  In that case, they will treat it the\n   same as any other unknown error notification,\
    \ and will stop the\n   exchange.  Because the other peer has already rekeyed\
    \ the exchange,\n   doing so does not have any ill effects.\n"
- title: 2.8.3.  Rekeying the IKE SA versus Reauthentication
  contents:
  - "2.8.3.  Rekeying the IKE SA versus Reauthentication\n   Rekeying the IKE SA and\
    \ reauthentication are different concepts in\n   IKEv2.  Rekeying the IKE SA establishes\
    \ new keys for the IKE SA and\n   resets the Message ID counters, but it does\
    \ not authenticate the\n   parties again (no AUTH or EAP payloads are involved).\n\
    \   Although rekeying the IKE SA may be important in some environments,\n   reauthentication\
    \ (the verification that the parties still have access\n   to the long-term credentials)\
    \ is often more important.\n   IKEv2 does not have any special support for reauthentication.\n\
    \   Reauthentication is done by creating a new IKE SA from scratch (using\n  \
    \ IKE_SA_INIT/IKE_AUTH exchanges, without any REKEY_SA Notify\n   payloads), creating\
    \ new Child SAs within the new IKE SA (without\n   REKEY_SA Notify payloads),\
    \ and finally deleting the old IKE SA (which\n   deletes the old Child SAs as\
    \ well).\n   This means that reauthentication also establishes new keys for the\n\
    \   IKE SA and Child SAs.  Therefore, while rekeying can be performed\n   more\
    \ often than reauthentication, the situation where \"authentication\n   lifetime\"\
    \ is shorter than \"key lifetime\" does not make sense.\n   While creation of\
    \ a new IKE SA can be initiated by either party\n   (initiator or responder in\
    \ the original IKE SA), the use of EAP\n   and/or Configuration payloads means\
    \ in practice that reauthentication\n   has to be initiated by the same party\
    \ as the original IKE SA.  IKEv2\n   does not currently allow the responder to\
    \ request reauthentication in\n   this case; however, there are extensions that\
    \ add this functionality\n   such as [REAUTH].\n"
- title: 2.9.  Traffic Selector Negotiation
  contents:
  - "2.9.  Traffic Selector Negotiation\n   When an RFC4301-compliant IPsec subsystem\
    \ receives an IP packet that\n   matches a \"protect\" selector in its Security\
    \ Policy Database (SPD),\n   the subsystem protects that packet with IPsec.  When\
    \ no SA exists\n   yet, it is the task of IKE to create it.  Maintenance of a\
    \ system's\n   SPD is outside the scope of IKE, although some implementations\
    \ might\n   update their SPD in connection with the running of IKE (for an\n \
    \  example scenario, see Section 1.1.3).\n   Traffic Selector (TS) payloads allow\
    \ endpoints to communicate some of\n   the information from their SPD to their\
    \ peers.  These must be\n   communicated to IKE from the SPD (for example, the\
    \ PF_KEY API [PFKEY]\n   uses the SADB_ACQUIRE message).  TS payloads specify\
    \ the selection\n   criteria for packets that will be forwarded over the newly\
    \ set up SA.\n   This can serve as a consistency check in some scenarios to assure\n\
    \   that the SPDs are consistent.  In others, it guides the dynamic\n   update\
    \ of the SPD.\n   Two TS payloads appear in each of the messages in the exchange\
    \ that\n   creates a Child SA pair.  Each TS payload contains one or more\n  \
    \ Traffic Selectors.  Each Traffic Selector consists of an address\n   range (IPv4\
    \ or IPv6), a port range, and an IP protocol ID.\n   The first of the two TS payloads\
    \ is known as TSi (Traffic Selector-\n   initiator).  The second is known as TSr\
    \ (Traffic Selector-responder).\n   TSi specifies the source address of traffic\
    \ forwarded from (or the\n   destination address of traffic forwarded to) the\
    \ initiator of the\n   Child SA pair.  TSr specifies the destination address of\
    \ the traffic\n   forwarded to (or the source address of the traffic forwarded\
    \ from)\n   the responder of the Child SA pair.  For example, if the original\n\
    \   initiator requests the creation of a Child SA pair, and wishes to\n   tunnel\
    \ all traffic from subnet 198.51.100.* on the initiator's side\n   to subnet 192.0.2.*\
    \ on the responder's side, the initiator would\n   include a single Traffic Selector\
    \ in each TS payload.  TSi would\n   specify the address range (198.51.100.0 -\
    \ 198.51.100.255) and TSr\n   would specify the address range (192.0.2.0 - 192.0.2.255).\
    \  Assuming\n   that proposal was acceptable to the responder, it would send\n\
    \   identical TS payloads back.\n   IKEv2 allows the responder to choose a subset\
    \ of the traffic proposed\n   by the initiator.  This could happen when the configurations\
    \ of the\n   two endpoints are being updated but only one end has received the\
    \ new\n   information.  Since the two endpoints may be configured by different\n\
    \   people, the incompatibility may persist for an extended period even\n   in\
    \ the absence of errors.  It also allows for intentionally different\n   configurations,\
    \ as when one end is configured to tunnel all addresses\n   and depends on the\
    \ other end to have the up-to-date list.\n   When the responder chooses a subset\
    \ of the traffic proposed by the\n   initiator, it narrows the Traffic Selectors\
    \ to some subset of the\n   initiator's proposal (provided the set does not become\
    \ the null set).\n   If the type of Traffic Selector proposed is unknown, the\
    \ responder\n   ignores that Traffic Selector, so that the unknown type is not\n\
    \   returned in the narrowed set.\n   To enable the responder to choose the appropriate\
    \ range in this case,\n   if the initiator has requested the SA due to a data\
    \ packet, the\n   initiator SHOULD include as the first Traffic Selector in each\
    \ of TSi\n   and TSr a very specific Traffic Selector including the addresses\
    \ in\n   the packet triggering the request.  In the example, the initiator\n \
    \  would include in TSi two Traffic Selectors: the first containing the\n   address\
    \ range (198.51.100.43 - 198.51.100.43) and the source port and\n   IP protocol\
    \ from the packet and the second containing (198.51.100.0 -\n   198.51.100.255)\
    \ with all ports and IP protocols.  The initiator would\n   similarly include\
    \ two Traffic Selectors in TSr.  If the initiator\n   creates the Child SA pair\
    \ not in response to an arriving packet, but\n   rather, say, upon startup, then\
    \ there may be no specific addresses\n   the initiator prefers for the initial\
    \ tunnel over any other.  In that\n   case, the first values in TSi and TSr can\
    \ be ranges rather than\n   specific values.\n   The responder performs the narrowing\
    \ as follows:\n   o  If the responder's policy does not allow it to accept any\
    \ part of\n      the proposed Traffic Selectors, it responds with a TS_UNACCEPTABLE\n\
    \      Notify message.\n   o  If the responder's policy allows the entire set\
    \ of traffic covered\n      by TSi and TSr, no narrowing is necessary, and the\
    \ responder can\n      return the same TSi and TSr values.\n   o  If the responder's\
    \ policy allows it to accept the first selector\n      of TSi and TSr, then the\
    \ responder MUST narrow the Traffic\n      Selectors to a subset that includes\
    \ the initiator's first choices.\n      In this example above, the responder might\
    \ respond with TSi being\n      (198.51.100.43 - 198.51.100.43) with all ports\
    \ and IP protocols.\n   o  If the responder's policy does not allow it to accept\
    \ the first\n      selector of TSi and TSr, the responder narrows to an acceptable\n\
    \      subset of TSi and TSr.\n   When narrowing is done, there may be several\
    \ subsets that are\n   acceptable but their union is not.  In this case, the responder\n\
    \   arbitrarily chooses one of them, and MAY include an\n   ADDITIONAL_TS_POSSIBLE\
    \ notification in the response.  The\n   ADDITIONAL_TS_POSSIBLE notification asserts\
    \ that the responder\n   narrowed the proposed Traffic Selectors but that other\
    \ Traffic\n   Selectors would also have been acceptable, though only in a separate\n\
    \   SA.  There is no data associated with this Notify type.  This case\n   will\
    \ occur only when the initiator and responder are configured\n   differently from\
    \ one another.  If the initiator and responder agree\n   on the granularity of\
    \ tunnels, the initiator will never request a\n   tunnel wider than the responder\
    \ will accept.\n   It is possible for the responder's policy to contain multiple\
    \ smaller\n   ranges, all encompassed by the initiator's Traffic Selector, and\
    \ with\n   the responder's policy being that each of those ranges should be sent\n\
    \   over a different SA.  Continuing the example above, the responder\n   might\
    \ have a policy of being willing to tunnel those addresses to and\n   from the\
    \ initiator, but might require that each address pair be on a\n   separately negotiated\
    \ Child SA.  If the initiator didn't generate its\n   request based on the packet,\
    \ but (for example) upon startup, there\n   would not be the very specific first\
    \ Traffic Selectors helping the\n   responder to select the correct range.  There\
    \ would be no way for the\n   responder to determine which pair of addresses should\
    \ be included in\n   this tunnel, and it would have to make a guess or reject\
    \ the request\n   with a SINGLE_PAIR_REQUIRED Notify message.\n   The SINGLE_PAIR_REQUIRED\
    \ error indicates that a CREATE_CHILD_SA\n   request is unacceptable because its\
    \ sender is only willing to accept\n   Traffic Selectors specifying a single pair\
    \ of addresses.  The\n   requestor is expected to respond by requesting an SA\
    \ for only the\n   specific traffic it is trying to forward.\n   Few implementations\
    \ will have policies that require separate SAs for\n   each address pair.  Because\
    \ of this, if only some parts of the TSi\n   and TSr proposed by the initiator\
    \ are acceptable to the responder,\n   responders SHOULD narrow the selectors\
    \ to an acceptable subset rather\n   than use SINGLE_PAIR_REQUIRED.\n"
- title: 2.9.1.  Traffic Selectors Violating Own Policy
  contents:
  - "2.9.1.  Traffic Selectors Violating Own Policy\n   When creating a new SA, the\
    \ initiator needs to avoid proposing\n   Traffic Selectors that violate its own\
    \ policy.  If this rule is not\n   followed, valid traffic may be dropped.  If\
    \ you use decorrelated\n   policies from [IPSECARCH], this kind of policy violations\
    \ cannot\n   happen.\n   This is best illustrated by an example.  Suppose that\
    \ host A has a\n   policy whose effect is that traffic to 198.51.100.66 is sent\
    \ via host\n   B encrypted using AES, and traffic to all other hosts in\n   198.51.100.0/24\
    \ is also sent via B, but must use 3DES.  Suppose also\n   that host B accepts\
    \ any combination of AES and 3DES.\n   If host A now proposes an SA that uses\
    \ 3DES, and includes TSr\n   containing (198.51.100.0-198.51.100.255), this will\
    \ be accepted by\n   host B.  Now, host B can also use this SA to send traffic\
    \ from\n   198.51.100.66, but those packets will be dropped by A since it\n  \
    \ requires the use of AES for this traffic.  Even if host A creates a\n   new\
    \ SA only for 198.51.100.66 that uses AES, host B may freely\n   continue to use\
    \ the first SA for the traffic.  In this situation,\n   when proposing the SA,\
    \ host A should have followed its own policy,\n   and included a TSr containing\
    \ ((198.51.100.0-\n   198.51.100.65),(198.51.100.67-198.51.100.255)) instead.\n\
    \   In general, if (1) the initiator makes a proposal \"for traffic X\n   (TSi/TSr),\
    \ do SA\", and (2) for some subset X' of X, the initiator\n   does not actually\
    \ accept traffic X' with SA, and (3) the initiator\n   would be willing to accept\
    \ traffic X' with some SA' (!=SA), valid\n   traffic can be unnecessarily dropped\
    \ since the responder can apply\n   either SA or SA' to traffic X'.\n"
- title: 2.10.  Nonces
  contents:
  - "2.10.  Nonces\n   The IKE_SA_INIT messages each contain a nonce.  These nonces\
    \ are used\n   as inputs to cryptographic functions.  The CREATE_CHILD_SA request\n\
    \   and the CREATE_CHILD_SA response also contain nonces.  These nonces\n   are\
    \ used to add freshness to the key derivation technique used to\n   obtain keys\
    \ for Child SA, and to ensure creation of strong\n   pseudorandom bits from the\
    \ Diffie-Hellman key.  Nonces used in IKEv2\n   MUST be randomly chosen, MUST\
    \ be at least 128 bits in size, and MUST\n   be at least half the key size of\
    \ the negotiated pseudorandom function\n   (PRF).  However, the initiator chooses\
    \ the nonce before the outcome\n   of the negotiation is known.  Because of that,\
    \ the nonce has to be\n   long enough for all the PRFs being proposed.  If the\
    \ same random\n   number source is used for both keys and nonces, care must be\
    \ taken to\n   ensure that the latter use does not compromise the former.\n"
- title: 2.11.  Address and Port Agility
  contents:
  - "2.11.  Address and Port Agility\n   IKE runs over UDP ports 500 and 4500, and\
    \ implicitly sets up ESP and\n   AH associations for the same IP addresses over\
    \ which it runs.  The IP\n   addresses and ports in the outer header are, however,\
    \ not themselves\n   cryptographically protected, and IKE is designed to work\
    \ even through\n   Network Address Translation (NAT) boxes.  An implementation\
    \ MUST\n   accept incoming requests even if the source port is not 500 or 4500,\n\
    \   and MUST respond to the address and port from which the request was\n   received.\
    \  It MUST specify the address and port at which the request\n   was received\
    \ as the source address and port in the response.  IKE\n   functions identically\
    \ over IPv4 or IPv6.\n"
- title: 2.12.  Reuse of Diffie-Hellman Exponentials
  contents:
  - "2.12.  Reuse of Diffie-Hellman Exponentials\n   IKE generates keying material\
    \ using an ephemeral Diffie-Hellman\n   exchange in order to gain the property\
    \ of \"perfect forward secrecy\".\n   This means that once a connection is closed\
    \ and its corresponding\n   keys are forgotten, even someone who has recorded\
    \ all of the data\n   from the connection and gets access to all of the long-term\
    \ keys of\n   the two endpoints cannot reconstruct the keys used to protect the\n\
    \   conversation without doing a brute force search of the session key\n   space.\n\
    \   Achieving perfect forward secrecy requires that when a connection is\n   closed,\
    \ each endpoint MUST forget not only the keys used by the\n   connection but also\
    \ any information that could be used to recompute\n   those keys.\n   Because\
    \ computing Diffie-Hellman exponentials is computationally\n   expensive, an endpoint\
    \ may find it advantageous to reuse those\n   exponentials for multiple connection\
    \ setups.  There are several\n   reasonable strategies for doing this.  An endpoint\
    \ could choose a new\n   exponential only periodically though this could result\
    \ in less-than-\n   perfect forward secrecy if some connection lasts for less\
    \ than the\n   lifetime of the exponential.  Or it could keep track of which\n\
    \   exponential was used for each connection and delete the information\n   associated\
    \ with the exponential only when some corresponding\n   connection was closed.\
    \  This would allow the exponential to be reused\n   without losing perfect forward\
    \ secrecy at the cost of maintaining\n   more state.\n   Whether and when to reuse\
    \ Diffie-Hellman exponentials are private\n   decisions in the sense that they\
    \ will not affect interoperability.\n   An implementation that reuses exponentials\
    \ MAY choose to remember the\n   exponential used by the other endpoint on past\
    \ exchanges and if one\n   is reused to avoid the second half of the calculation.\
    \  See [REUSE]\n   for a security analysis of this practice and for additional\
    \ security\n   considerations when reusing ephemeral Diffie-Hellman keys.\n"
- title: 2.13.  Generating Keying Material
  contents:
  - "2.13.  Generating Keying Material\n   In the context of the IKE SA, four cryptographic\
    \ algorithms are\n   negotiated: an encryption algorithm, an integrity protection\n\
    \   algorithm, a Diffie-Hellman group, and a pseudorandom function (PRF).\n  \
    \ The PRF is used for the construction of keying material for all of\n   the cryptographic\
    \ algorithms used in both the IKE SA and the Child\n   SAs.\n   We assume that\
    \ each encryption algorithm and integrity protection\n   algorithm uses a fixed-size\
    \ key and that any randomly chosen value of\n   that fixed size can serve as an\
    \ appropriate key.  For algorithms that\n   accept a variable-length key, a fixed\
    \ key size MUST be specified as\n   part of the cryptographic transform negotiated\
    \ (see Section 3.3.5 for\n   the definition of the Key Length transform attribute).\
    \  For\n   algorithms for which not all values are valid keys (such as DES or\n\
    \   3DES with key parity), the algorithm by which keys are derived from\n   arbitrary\
    \ values MUST be specified by the cryptographic transform.\n   For integrity protection\
    \ functions based on Hashed Message\n   Authentication Code (HMAC), the fixed\
    \ key size is the size of the\n   output of the underlying hash function.\n  \
    \ It is assumed that PRFs accept keys of any length, but have a\n   preferred\
    \ key size.  The preferred key size MUST be used as the\n   length of SK_d, SK_pi,\
    \ and SK_pr (see Section 2.14).  For PRFs based\n   on the HMAC construction,\
    \ the preferred key size is equal to the\n   length of the output of the underlying\
    \ hash function.  Other types of\n   PRFs MUST specify their preferred key size.\n\
    \   Keying material will always be derived as the output of the\n   negotiated\
    \ PRF algorithm.  Since the amount of keying material needed\n   may be greater\
    \ than the size of the output of the PRF, the PRF is\n   used iteratively.  The\
    \ term \"prf+\" describes a function that outputs\n   a pseudorandom stream based\
    \ on the inputs to a pseudorandom function\n   called \"prf\".\n   In the following,\
    \ | indicates concatenation. prf+ is defined as:\n   prf+ (K,S) = T1 | T2 | T3\
    \ | T4 | ...\n   where:\n   T1 = prf (K, S | 0x01)\n   T2 = prf (K, T1 | S | 0x02)\n\
    \   T3 = prf (K, T2 | S | 0x03)\n   T4 = prf (K, T3 | S | 0x04)\n   ...\n   This\
    \ continues until all the material needed to compute all required\n   keys has\
    \ been output from prf+.  The keys are taken from the output\n   string without\
    \ regard to boundaries (e.g., if the required keys are a\n   256-bit Advanced\
    \ Encryption Standard (AES) key and a 160-bit HMAC\n   key, and the prf function\
    \ generates 160 bits, the AES key will come\n   from T1 and the beginning of T2,\
    \ while the HMAC key will come from\n   the rest of T2 and the beginning of T3).\n\
    \   The constant concatenated to the end of each prf function is a single\n  \
    \ octet.  The prf+ function is not defined beyond 255 times the size of\n   the\
    \ prf function output.\n"
- title: 2.14.  Generating Keying Material for the IKE SA
  contents:
  - "2.14.  Generating Keying Material for the IKE SA\n   The shared keys are computed\
    \ as follows.  A quantity called SKEYSEED\n   is calculated from the nonces exchanged\
    \ during the IKE_SA_INIT\n   exchange and the Diffie-Hellman shared secret established\
    \ during that\n   exchange.  SKEYSEED is used to calculate seven other secrets:\
    \ SK_d\n   used for deriving new keys for the Child SAs established with this\n\
    \   IKE SA; SK_ai and SK_ar used as a key to the integrity protection\n   algorithm\
    \ for authenticating the component messages of subsequent\n   exchanges; SK_ei\
    \ and SK_er used for encrypting (and of course\n   decrypting) all subsequent\
    \ exchanges; and SK_pi and SK_pr, which are\n   used when generating an AUTH payload.\
    \  The lengths of SK_d, SK_pi,\n   and SK_pr MUST be the preferred key length\
    \ of the PRF agreed upon.\n   SKEYSEED and its derivatives are computed as follows:\n\
    \   SKEYSEED = prf(Ni | Nr, g^ir)\n   {SK_d | SK_ai | SK_ar | SK_ei | SK_er |\
    \ SK_pi | SK_pr }\n                   = prf+ (SKEYSEED, Ni | Nr | SPIi | SPIr\
    \ )\n   (indicating that the quantities SK_d, SK_ai, SK_ar, SK_ei, SK_er,\n  \
    \ SK_pi, and SK_pr are taken in order from the generated bits of the\n   prf+).\
    \ g^ir is the shared secret from the ephemeral Diffie-Hellman\n   exchange. g^ir\
    \ is represented as a string of octets in big endian\n   order padded with zeros\
    \ if necessary to make it the length of the\n   modulus.  Ni and Nr are the nonces,\
    \ stripped of any headers.  For\n   historical backward-compatibility reasons,\
    \ there are two PRFs that\n   are treated specially in this calculation.  If the\
    \ negotiated PRF is\n   AES-XCBC-PRF-128 [AESXCBCPRF128] or AES-CMAC-PRF-128 [AESCMACPRF128],\n\
    \   only the first 64 bits of Ni and the first 64 bits of Nr are used in\n   calculating\
    \ SKEYSEED, but all the bits are used for input to the prf+\n   function.\n  \
    \ The two directions of traffic flow use different keys.  The keys used\n   to\
    \ protect messages from the original initiator are SK_ai and SK_ei.\n   The keys\
    \ used to protect messages in the other direction are SK_ar\n   and SK_er.\n"
- title: 2.15.  Authentication of the IKE SA
  contents:
  - "2.15.  Authentication of the IKE SA\n   When not using extensible authentication\
    \ (see Section 2.16), the\n   peers are authenticated by having each sign (or\
    \ MAC using a padded\n   shared secret as the key, as described later in this\
    \ section) a block\n   of data.  In these calculations, IDi' and IDr' are the\
    \ entire ID\n   payloads excluding the fixed header.  For the responder, the octets\n\
    \   to be signed start with the first octet of the first SPI in the\n   header\
    \ of the second message (IKE_SA_INIT response) and end with the\n   last octet\
    \ of the last payload in the second message.  Appended to\n   this (for the purposes\
    \ of computing the signature) are the\n   initiator's nonce Ni (just the value,\
    \ not the payload containing it),\n   and the value prf(SK_pr, IDr').  Note that\
    \ neither the nonce Ni nor\n   the value prf(SK_pr, IDr') are transmitted.  Similarly,\
    \ the initiator\n   signs the first message (IKE_SA_INIT request), starting with\
    \ the\n   first octet of the first SPI in the header and ending with the last\n\
    \   octet of the last payload.  Appended to this (for purposes of\n   computing\
    \ the signature) are the responder's nonce Nr, and the value\n   prf(SK_pi, IDi').\
    \  It is critical to the security of the exchange\n   that each side sign the\
    \ other side's nonce.\n   The initiator's signed octets can be described as:\n\
    \   InitiatorSignedOctets = RealMessage1 | NonceRData | MACedIDForI\n   GenIKEHDR\
    \ = [ four octets 0 if using port 4500 ] | RealIKEHDR\n   RealIKEHDR =  SPIi |\
    \ SPIr |  . . . | Length\n   RealMessage1 = RealIKEHDR | RestOfMessage1\n   NonceRPayload\
    \ = PayloadHeader | NonceRData\n   InitiatorIDPayload = PayloadHeader | RestOfInitIDPayload\n\
    \   RestOfInitIDPayload = IDType | RESERVED | InitIDData\n   MACedIDForI = prf(SK_pi,\
    \ RestOfInitIDPayload)\n   The responder's signed octets can be described as:\n\
    \   ResponderSignedOctets = RealMessage2 | NonceIData | MACedIDForR\n   GenIKEHDR\
    \ = [ four octets 0 if using port 4500 ] | RealIKEHDR\n   RealIKEHDR =  SPIi |\
    \ SPIr |  . . . | Length\n   RealMessage2 = RealIKEHDR | RestOfMessage2\n   NonceIPayload\
    \ = PayloadHeader | NonceIData\n   ResponderIDPayload = PayloadHeader | RestOfRespIDPayload\n\
    \   RestOfRespIDPayload = IDType | RESERVED | RespIDData\n   MACedIDForR = prf(SK_pr,\
    \ RestOfRespIDPayload)\n   Note that all of the payloads are included under the\
    \ signature,\n   including any payload types not defined in this document.  If\
    \ the\n   first message of the exchange is sent multiple times (such as with a\n\
    \   responder cookie and/or a different Diffie-Hellman group), it is the\n   latest\
    \ version of the message that is signed.\n   Optionally, messages 3 and 4 MAY\
    \ include a certificate, or\n   certificate chain providing evidence that the\
    \ key used to compute a\n   digital signature belongs to the name in the ID payload.\
    \  The\n   signature or MAC will be computed using algorithms dictated by the\n\
    \   type of key used by the signer, and specified by the Auth Method\n   field\
    \ in the Authentication payload.  There is no requirement that\n   the initiator\
    \ and responder sign with the same cryptographic\n   algorithms.  The choice of\
    \ cryptographic algorithms depends on the\n   type of key each has.  In particular,\
    \ the initiator may be using a\n   shared key while the responder may have a public\
    \ signature key and\n   certificate.  It will commonly be the case (but it is\
    \ not required)\n   that, if a shared secret is used for authentication, the same\
    \ key is\n   used in both directions.\n   Note that it is a common but typically\
    \ insecure practice to have a\n   shared key derived solely from a user-chosen\
    \ password without\n   incorporating another source of randomness.  This is typically\n\
    \   insecure because user-chosen passwords are unlikely to have\n   sufficient\
    \ unpredictability to resist dictionary attacks and these\n   attacks are not\
    \ prevented in this authentication method.\n   (Applications using password-based\
    \ authentication for bootstrapping\n   and IKE SA should use the authentication\
    \ method in Section 2.16,\n   which is designed to prevent off-line dictionary\
    \ attacks.)  The pre-\n   shared key needs to contain as much unpredictability\
    \ as the strongest\n   key being negotiated.  In the case of a pre-shared key,\
    \ the AUTH\n   value is computed as:\n   For the initiator:\n      AUTH = prf(\
    \ prf(Shared Secret, \"Key Pad for IKEv2\"),\n                       <InitiatorSignedOctets>)\n\
    \   For the responder:\n      AUTH = prf( prf(Shared Secret, \"Key Pad for IKEv2\"\
    ),\n                       <ResponderSignedOctets>)\n   where the string \"Key\
    \ Pad for IKEv2\" is 17 ASCII characters without\n   null termination.  The shared\
    \ secret can be variable length.  The pad\n   string is added so that if the shared\
    \ secret is derived from a\n   password, the IKE implementation need not store\
    \ the password in\n   cleartext, but rather can store the value prf(Shared Secret,\"\
    Key Pad\n   for IKEv2\"), which could not be used as a password equivalent for\n\
    \   protocols other than IKEv2.  As noted above, deriving the shared\n   secret\
    \ from a password is not secure.  This construction is used\n   because it is\
    \ anticipated that people will do it anyway.  The\n   management interface by\
    \ which the shared secret is provided MUST\n   accept ASCII strings of at least\
    \ 64 octets and MUST NOT add a null\n   terminator before using them as shared\
    \ secrets.  It MUST also accept\n   a hex encoding of the shared secret.  The\
    \ management interface MAY\n   accept other encodings if the algorithm for translating\
    \ the encoding\n   to a binary string is specified.\n   There are two types of\
    \ EAP authentication (described in\n   Section 2.16), and each type uses different\
    \ values in the AUTH\n   computations shown above.  If the EAP method is key-generating,\n\
    \   substitute master session key (MSK) for the shared secret in the\n   computation.\
    \  For non-key-generating methods, substitute SK_pi and\n   SK_pr, respectively,\
    \ for the shared secret in the two AUTH\n   computations.\n"
- title: 2.16.  Extensible Authentication Protocol Methods
  contents:
  - "2.16.  Extensible Authentication Protocol Methods\n   In addition to authentication\
    \ using public key signatures and shared\n   secrets, IKE supports authentication\
    \ using methods defined in RFC\n   3748 [EAP].  Typically, these methods are asymmetric\
    \ (designed for a\n   user authenticating to a server), and they may not be mutual.\
    \  For\n   this reason, these protocols are typically used to authenticate the\n\
    \   initiator to the responder and MUST be used in conjunction with a\n   public-key-signature-based\
    \ authentication of the responder to the\n   initiator.  These methods are often\
    \ associated with mechanisms\n   referred to as \"Legacy Authentication\" mechanisms.\n\
    \   While this document references [EAP] with the intent that new methods\n  \
    \ can be added in the future without updating this specification, some\n   simpler\
    \ variations are documented here.  [EAP] defines an\n   authentication protocol\
    \ requiring a variable number of messages.\n   Extensible Authentication is implemented\
    \ in IKE as additional\n   IKE_AUTH exchanges that MUST be completed in order\
    \ to initialize the\n   IKE SA.\n   An initiator indicates a desire to use EAP\
    \ by leaving out the AUTH\n   payload from the first message in the IKE_AUTH exchange.\
    \  (Note that\n   the AUTH payload is required for non-EAP authentication, and\
    \ is thus\n   not marked as optional in the rest of this document.)  By including\n\
    \   an IDi payload but not an AUTH payload, the initiator has declared an\n  \
    \ identity but has not proven it.  If the responder is willing to use\n   an EAP\
    \ method, it will place an Extensible Authentication Protocol\n   (EAP) payload\
    \ in the response of the IKE_AUTH exchange and defer\n   sending SAr2, TSi, and\
    \ TSr until initiator authentication is complete\n   in a subsequent IKE_AUTH\
    \ exchange.  In the case of a minimal EAP\n   method, the initial SA establishment\
    \ will appear as follows:\n   Initiator                         Responder\n  \
    \ -------------------------------------------------------------------\n   HDR,\
    \ SAi1, KEi, Ni  -->\n                                <--  HDR, SAr1, KEr, Nr,\
    \ [CERTREQ]\n   HDR, SK {IDi, [CERTREQ,]\n       [IDr,] SAi2,\n       TSi, TSr}\
    \  -->\n                                <--  HDR, SK {IDr, [CERT,] AUTH,\n   \
    \                                      EAP }\n   HDR, SK {EAP}  -->\n        \
    \                        <--  HDR, SK {EAP (success)}\n   HDR, SK {AUTH}  -->\n\
    \                                <--  HDR, SK {AUTH, SAr2, TSi, TSr }\n   As described\
    \ in Section 2.2, when EAP is used, each pair of IKE SA\n   initial setup messages\
    \ will have their message numbers incremented;\n   the first pair of AUTH messages\
    \ will have an ID of 1, the second will\n   be 2, and so on.\n   For EAP methods\
    \ that create a shared key as a side effect of\n   authentication, that shared\
    \ key MUST be used by both the initiator\n   and responder to generate AUTH payloads\
    \ in messages 7 and 8 using the\n   syntax for shared secrets specified in Section\
    \ 2.15.  The shared key\n   from EAP is the field from the EAP specification named\
    \ MSK.  This\n   shared key generated during an IKE exchange MUST NOT be used\
    \ for any\n   other purpose.\n   EAP methods that do not establish a shared key\
    \ SHOULD NOT be used, as\n   they are subject to a number of man-in-the-middle\
    \ attacks [EAPMITM]\n   if these EAP methods are used in other protocols that\
    \ do not use a\n   server-authenticated tunnel.  Please see the Security Considerations\n\
    \   section for more details.  If EAP methods that do not generate a\n   shared\
    \ key are used, the AUTH payloads in messages 7 and 8 MUST be\n   generated using\
    \ SK_pi and SK_pr, respectively.\n   The initiator of an IKE SA using EAP needs\
    \ to be capable of extending\n   the initial protocol exchange to at least ten\
    \ IKE_AUTH exchanges in\n   the event the responder sends notification messages\
    \ and/or retries\n   the authentication prompt.  Once the protocol exchange defined\
    \ by the\n   chosen EAP authentication method has successfully terminated, the\n\
    \   responder MUST send an EAP payload containing the Success message.\n   Similarly,\
    \ if the authentication method has failed, the responder\n   MUST send an EAP\
    \ payload containing the Failure message.  The\n   responder MAY at any time terminate\
    \ the IKE exchange by sending an\n   EAP payload containing the Failure message.\n\
    \   Following such an extended exchange, the EAP AUTH payloads MUST be\n   included\
    \ in the two messages following the one containing the EAP\n   Success message.\n\
    \   When the initiator authentication uses EAP, it is possible that the\n   contents\
    \ of the IDi payload is used only for Authentication,\n   Authorization, and Accounting\
    \ (AAA) routing purposes and selecting\n   which EAP method to use.  This value\
    \ may be different from the\n   identity authenticated by the EAP method.  It\
    \ is important that\n   policy lookups and access control decisions use the actual\n\
    \   authenticated identity.  Often the EAP server is implemented in a\n   separate\
    \ AAA server that communicates with the IKEv2 responder.  In\n   this case, the\
    \ authenticated identity, if different from that in the\n   IDi payload, has to\
    \ be sent from the AAA server to the IKEv2\n   responder.\n"
- title: 2.17.  Generating Keying Material for Child SAs
  contents:
  - "2.17.  Generating Keying Material for Child SAs\n   A single Child SA is created\
    \ by the IKE_AUTH exchange, and additional\n   Child SAs can optionally be created\
    \ in CREATE_CHILD_SA exchanges.\n   Keying material for them is generated as follows:\n\
    \   KEYMAT = prf+(SK_d, Ni | Nr)\n   Where Ni and Nr are the nonces from the IKE_SA_INIT\
    \ exchange if this\n   request is the first Child SA created or the fresh Ni and\
    \ Nr from the\n   CREATE_CHILD_SA exchange if this is a subsequent creation.\n\
    \   For CREATE_CHILD_SA exchanges including an optional Diffie-Hellman\n   exchange,\
    \ the keying material is defined as:\n   KEYMAT = prf+(SK_d, g^ir (new) | Ni |\
    \ Nr )\n   where g^ir (new) is the shared secret from the ephemeral Diffie-\n\
    \   Hellman exchange of this CREATE_CHILD_SA exchange (represented as an\n   octet\
    \ string in big endian order padded with zeros in the high-order\n   bits if necessary\
    \ to make it the length of the modulus).\n   A single CHILD_SA negotiation may\
    \ result in multiple Security\n   Associations.  ESP and AH SAs exist in pairs\
    \ (one in each direction),\n   so two SAs are created in a single Child SA negotiation\
    \ for them.\n   Furthermore, Child SA negotiation may include some future IPsec\n\
    \   protocol(s) in addition to, or instead of, ESP or AH (for example,\n   ROHC_INTEG\
    \ as described in [ROHCV2]).  In any case, keying material\n   for each Child\
    \ SA MUST be taken from the expanded KEYMAT using the\n   following rules:\n \
    \  o  All keys for SAs carrying data from the initiator to the responder\n   \
    \   are taken before SAs going from the responder to the initiator.\n   o  If\
    \ multiple IPsec protocols are negotiated, keying material for\n      each Child\
    \ SA is taken in the order in which the protocol headers\n      will appear in\
    \ the encapsulated packet.\n   o  If an IPsec protocol requires multiple keys,\
    \ the order in which\n      they are taken from the SA's keying material needs\
    \ to be described\n      in the protocol's specification.  For ESP and AH, [IPSECARCH]\n\
    \      defines the order, namely: the encryption key (if any) MUST be\n      taken\
    \ from the first bits and the integrity key (if any) MUST be\n      taken from\
    \ the remaining bits.\n   Each cryptographic algorithm takes a fixed number of\
    \ bits of keying\n   material specified as part of the algorithm, or negotiated\
    \ in SA\n   payloads (see Section 2.13 for description of key lengths, and\n \
    \  Section 3.3.5 for the definition of the Key Length transform\n   attribute).\n"
- title: 2.18.  Rekeying IKE SAs Using a CREATE_CHILD_SA Exchange
  contents:
  - "2.18.  Rekeying IKE SAs Using a CREATE_CHILD_SA Exchange\n   The CREATE_CHILD_SA\
    \ exchange can be used to rekey an existing IKE SA\n   (see Sections 1.3.2 and\
    \ 2.8).  New initiator and responder SPIs are\n   supplied in the SPI fields in\
    \ the Proposal structures inside the\n   Security Association (SA) payloads (not\
    \ the SPI fields in the IKE\n   header).  The TS payloads are omitted when rekeying\
    \ an IKE SA.\n   SKEYSEED for the new IKE SA is computed using SK_d from the existing\n\
    \   IKE SA as follows:\n   SKEYSEED = prf(SK_d (old), g^ir (new) | Ni | Nr)\n\
    \   where g^ir (new) is the shared secret from the ephemeral Diffie-\n   Hellman\
    \ exchange of this CREATE_CHILD_SA exchange (represented as an\n   octet string\
    \ in big endian order padded with zeros if necessary to\n   make it the length\
    \ of the modulus) and Ni and Nr are the two nonces\n   stripped of any headers.\n\
    \   The old and new IKE SA may have selected a different PRF.  Because\n   the\
    \ rekeying exchange belongs to the old IKE SA, it is the old IKE\n   SA's PRF\
    \ that is used to generate SKEYSEED.\n   The main reason for rekeying the IKE\
    \ SA is to ensure that the\n   compromise of old keying material does not provide\
    \ information about\n   the current keys, or vice versa.  Therefore, implementations\
    \ MUST\n   perform a new Diffie-Hellman exchange when rekeying the IKE SA.  In\n\
    \   other words, an initiator MUST NOT propose the value \"NONE\" for the\n  \
    \ Diffie-Hellman transform, and a responder MUST NOT accept such a\n   proposal.\
    \  This means that a successful exchange rekeying the IKE SA\n   always includes\
    \ the KEi/KEr payloads.\n   The new IKE SA MUST reset its message counters to\
    \ 0.\n   SK_d, SK_ai, SK_ar, SK_ei, and SK_er are computed from SKEYSEED as\n\
    \   specified in Section 2.14, using SPIi, SPIr, Ni, and Nr from the new\n   exchange,\
    \ and using the new IKE SA's PRF.\n"
- title: 2.19.  Requesting an Internal Address on a Remote Network
  contents:
  - "2.19.  Requesting an Internal Address on a Remote Network\n   Most commonly occurring\
    \ in the endpoint-to-security-gateway scenario,\n   an endpoint may need an IP\
    \ address in the network protected by the\n   security gateway and may need to\
    \ have that address dynamically\n   assigned.  A request for such a temporary\
    \ address can be included in\n   any request to create a Child SA (including the\
    \ implicit request in\n   message 3) by including a CP payload.  Note, however,\
    \ it is usual to\n   only assign one IP address during the IKE_AUTH exchange.\
    \  That\n   address persists at least until the deletion of the IKE SA.\n   This\
    \ function provides address allocation to an IPsec Remote Access\n   Client (IRAC)\
    \ trying to tunnel into a network protected by an IPsec\n   Remote Access Server\
    \ (IRAS).  Since the IKE_AUTH exchange creates an\n   IKE SA and a Child SA, the\
    \ IRAC MUST request the IRAS-controlled\n   address (and optionally other information\
    \ concerning the protected\n   network) in the IKE_AUTH exchange.  The IRAS may\
    \ procure an address\n   for the IRAC from any number of sources such as a DHCP/BOOTP\n\
    \   (Bootstrap Protocol) server or its own address pool.\n   Initiator       \
    \                  Responder\n   -------------------------------------------------------------------\n\
    \    HDR, SK {IDi, [CERT,]\n       [CERTREQ,] [IDr,] AUTH,\n       CP(CFG_REQUEST),\
    \ SAi2,\n       TSi, TSr}  -->\n                                <--  HDR, SK {IDr,\
    \ [CERT,] AUTH,\n                                         CP(CFG_REPLY), SAr2,\n\
    \                                         TSi, TSr}\n   In all cases, the CP payload\
    \ MUST be inserted before the SA payload.\n   In variations of the protocol where\
    \ there are multiple IKE_AUTH\n   exchanges, the CP payloads MUST be inserted\
    \ in the messages\n   containing the SA payloads.\n   CP(CFG_REQUEST) MUST contain\
    \ at least an INTERNAL_ADDRESS attribute\n   (either IPv4 or IPv6) but MAY contain\
    \ any number of additional\n   attributes the initiator wants returned in the\
    \ response.\n   For example, message from initiator to responder:\n   CP(CFG_REQUEST)=\n\
    \     INTERNAL_ADDRESS()\n   TSi = (0, 0-65535,0.0.0.0-255.255.255.255)\n   TSr\
    \ = (0, 0-65535,0.0.0.0-255.255.255.255)\n   NOTE: Traffic Selectors contain (protocol,\
    \ port range, address\n   range).\n   Message from responder to initiator:\n \
    \  CP(CFG_REPLY)=\n     INTERNAL_ADDRESS(192.0.2.202)\n     INTERNAL_NETMASK(255.255.255.0)\n\
    \     INTERNAL_SUBNET(192.0.2.0/255.255.255.0)\n   TSi = (0, 0-65535,192.0.2.202-192.0.2.202)\n\
    \   TSr = (0, 0-65535,192.0.2.0-192.0.2.255)\n   All returned values will be implementation\
    \ dependent.  As can be seen\n   in the above example, the IRAS MAY also send\
    \ other attributes that\n   were not included in CP(CFG_REQUEST) and MAY ignore\
    \ the non-\n   mandatory attributes that it does not support.\n   The responder\
    \ MUST NOT send a CFG_REPLY without having first received\n   a CP(CFG_REQUEST)\
    \ from the initiator, because we do not want the IRAS\n   to perform an unnecessary\
    \ configuration lookup if the IRAC cannot\n   process the REPLY.\n   In the case\
    \ where the IRAS's configuration requires that CP be used\n   for a given identity\
    \ IDi, but IRAC has failed to send a\n   CP(CFG_REQUEST), IRAS MUST fail the request,\
    \ and terminate the Child\n   SA creation with a FAILED_CP_REQUIRED error.  The\
    \ FAILED_CP_REQUIRED\n   is not fatal to the IKE SA; it simply causes the Child\
    \ SA creation to\n   fail.  The initiator can fix this by later starting a new\n\
    \   Configuration payload request.  There is no associated data in the\n   FAILED_CP_REQUIRED\
    \ error.\n"
- title: 2.20.  Requesting the Peer's Version
  contents:
  - "2.20.  Requesting the Peer's Version\n   An IKE peer wishing to inquire about\
    \ the other peer's IKE software\n   version information MAY use the method below.\
    \  This is an example of\n   a configuration request within an INFORMATIONAL exchange,\
    \ after the\n   IKE SA and first Child SA have been created.\n   An IKE implementation\
    \ MAY decline to give out version information\n   prior to authentication or even\
    \ after authentication in case some\n   implementation is known to have some security\
    \ weakness.  In that\n   case, it MUST either return an empty string or no CP\
    \ payload if CP is\n   not supported.\n   Initiator                         Responder\n\
    \   -------------------------------------------------------------------\n   HDR,\
    \ SK{CP(CFG_REQUEST)}  -->\n                                <--  HDR, SK{CP(CFG_REPLY)}\n\
    \   CP(CFG_REQUEST)=\n     APPLICATION_VERSION(\"\")\n   CP(CFG_REPLY) APPLICATION_VERSION(\"\
    foobar v1.3beta, (c) Foo Bar\n     Inc.\")\n"
- title: 2.21.  Error Handling
  contents:
  - "2.21.  Error Handling\n   There are many kinds of errors that can occur during\
    \ IKE processing.\n   The general rule is that if a request is received that is\
    \ badly\n   formatted, or unacceptable for reasons of policy (such as no matching\n\
    \   cryptographic algorithms), the response contains a Notify payload\n   indicating\
    \ the error.  The decision whether or not to send such a\n   response depends\
    \ whether or not there is an authenticated IKE SA.\n   If there is an error parsing\
    \ or processing a response packet, the\n   general rule is to not send back any\
    \ error message because responses\n   should not generate new requests (and a\
    \ new request would be the only\n   way to send back an error message).  Such\
    \ errors in parsing or\n   processing response packets should still cause the\
    \ recipient to clean\n   up the IKE state (for example, by sending a Delete for\
    \ a bad SA).\n   Only authentication failures (AUTHENTICATION_FAILED and EAP failure)\n\
    \   and malformed messages (INVALID_SYNTAX) lead to a deletion of the IKE\n  \
    \ SA without requiring an explicit INFORMATIONAL exchange carrying a\n   Delete\
    \ payload.  Other error conditions MAY require such an exchange\n   if policy\
    \ dictates that this is needed.  If the exchange is\n   terminated with EAP Failure,\
    \ an AUTHENTICATION_FAILED notification is\n   not sent.\n"
- title: 2.21.1.  Error Handling in IKE_SA_INIT
  contents:
  - "2.21.1.  Error Handling in IKE_SA_INIT\n   Errors that occur before a cryptographically\
    \ protected IKE SA is\n   established need to be handled very carefully.  There\
    \ is a trade-off\n   between wanting to help the peer to diagnose a problem and\
    \ thus\n   responding to the error and wanting to avoid being part of a DoS\n\
    \   attack based on forged messages.\n   In an IKE_SA_INIT exchange, any error\
    \ notification causes the\n   exchange to fail.  Note that some error notifications\
    \ such as COOKIE,\n   INVALID_KE_PAYLOAD or INVALID_MAJOR_VERSION may lead to\
    \ a subsequent\n   successful exchange.  Because all error notifications are completely\n\
    \   unauthenticated, the recipient should continue trying for some time\n   before\
    \ giving up.  The recipient should not immediately act based on\n   the error\
    \ notification unless corrective actions are defined in this\n   specification,\
    \ such as for COOKIE, INVALID_KE_PAYLOAD, and\n   INVALID_MAJOR_VERSION.\n"
- title: 2.21.2.  Error Handling in IKE_AUTH
  contents:
  - "2.21.2.  Error Handling in IKE_AUTH\n   All errors that occur in an IKE_AUTH\
    \ exchange, causing the\n   authentication to fail for whatever reason (invalid\
    \ shared secret,\n   invalid ID, untrusted certificate issuer, revoked or expired\n\
    \   certificate, etc.)  SHOULD result in an AUTHENTICATION_FAILED\n   notification.\
    \  If the error occurred on the responder, the\n   notification is returned in\
    \ the protected response, and is usually\n   the only payload in that response.\
    \  Although the IKE_AUTH messages\n   are encrypted and integrity protected, if\
    \ the peer receiving this\n   notification has not authenticated the other end\
    \ yet, that peer needs\n   to treat the information with caution.\n   If the error\
    \ occurs on the initiator, the notification MAY be\n   returned in a separate\
    \ INFORMATIONAL exchange, usually with no other\n   payloads.  This is an exception\
    \ for the general rule of not starting\n   new exchanges based on errors in responses.\n\
    \   Note, however, that request messages that contain an unsupported\n   critical\
    \ payload, or where the whole message is malformed (rather\n   than just bad payload\
    \ contents), MUST be rejected in their entirety,\n   and MUST only lead to an\
    \ UNSUPPORTED_CRITICAL_PAYLOAD or\n   INVALID_SYNTAX Notification sent as a response.\
    \  The receiver should\n   not verify the payloads related to authentication in\
    \ this case.\n   If authentication has succeeded in the IKE_AUTH exchange, the\
    \ IKE SA\n   is established; however, establishing the Child SA or requesting\n\
    \   configuration information may still fail.  This failure does not\n   automatically\
    \ cause the IKE SA to be deleted.  Specifically, a\n   responder may include all\
    \ the payloads associated with authentication\n   (IDr, CERT, and AUTH) while\
    \ sending error notifications for the\n   piggybacked exchanges (FAILED_CP_REQUIRED,\
    \ NO_PROPOSAL_CHOSEN, and so\n   on), and the initiator MUST NOT fail the authentication\
    \ because of\n   this.  The initiator MAY, of course, for reasons of policy later\n\
    \   delete such an IKE SA.\n   In an IKE_AUTH exchange, or in the INFORMATIONAL\
    \ exchange immediately\n   following it (in case an error happened when processing\
    \ a response to\n   IKE_AUTH), the UNSUPPORTED_CRITICAL_PAYLOAD, INVALID_SYNTAX,\
    \ and\n   AUTHENTICATION_FAILED notifications are the only ones to cause the\n\
    \   IKE SA to be deleted or not created, without a Delete payload.\n   Extension\
    \ documents may define new error notifications with these\n   semantics, but MUST\
    \ NOT use them unless the peer has been shown to\n   understand them, such as\
    \ by using the Vendor ID payload.\n"
- title: 2.21.3.  Error Handling after IKE SA is Authenticated
  contents:
  - "2.21.3.  Error Handling after IKE SA is Authenticated\n   After the IKE SA is\
    \ authenticated, all requests having errors MUST\n   result in a response notifying\
    \ about the error.\n   In normal situations, there should not be cases where a\
    \ valid\n   response from one peer results in an error situation in the other\n\
    \   peer, so there should not be any reason for a peer to send error\n   messages\
    \ to the other end except as a response.  Because sending such\n   error messages\
    \ as an INFORMATIONAL exchange might lead to further\n   errors that could cause\
    \ loops, such errors SHOULD NOT be sent.  If\n   errors are seen that indicate\
    \ that the peers do not have the same\n   state, it might be good to delete the\
    \ IKE SA to clean up state and\n   start over.\n   If a peer parsing a request\
    \ notices that it is badly formatted (after\n   it has passed the message authentication\
    \ code checks and window\n   checks) and it returns an INVALID_SYNTAX notification,\
    \ then this\n   error notification is considered fatal in both peers, meaning\
    \ that\n   the IKE SA is deleted without needing an explicit Delete payload.\n"
- title: 2.21.4.  Error Handling Outside IKE SA
  contents:
  - "2.21.4.  Error Handling Outside IKE SA\n   A node needs to limit the rate at\
    \ which it will send messages in\n   response to unprotected messages.\n   If\
    \ a node receives a message on UDP port 500 or 4500 outside the\n   context of\
    \ an IKE SA known to it (and the message is not a request to\n   start an IKE\
    \ SA), this may be the result of a recent crash of the\n   node.  If the message\
    \ is marked as a response, the node can audit the\n   suspicious event but MUST\
    \ NOT respond.  If the message is marked as a\n   request, the node can audit\
    \ the suspicious event and MAY send a\n   response.  If a response is sent, the\
    \ response MUST be sent to the IP\n   address and port from where it came with\
    \ the same IKE SPIs and the\n   Message ID copied.  The response MUST NOT be cryptographically\n\
    \   protected and MUST contain an INVALID_IKE_SPI Notify payload.  The\n   INVALID_IKE_SPI\
    \ notification indicates an IKE message was received\n   with an unrecognized\
    \ destination SPI; this usually indicates that the\n   recipient has rebooted\
    \ and forgotten the existence of an IKE SA.\n   A peer receiving such an unprotected\
    \ Notify payload MUST NOT respond\n   and MUST NOT change the state of any existing\
    \ SAs.  The message might\n   be a forgery or might be a response that a genuine\
    \ correspondent was\n   tricked into sending.  A node should treat such a message\
    \ (and also a\n   network message like ICMP destination unreachable) as a hint\
    \ that\n   there might be problems with SAs to that IP address and should\n  \
    \ initiate a liveness check for any such IKE SA.  An implementation\n   SHOULD\
    \ limit the frequency of such tests to avoid being tricked into\n   participating\
    \ in a DoS attack.\n   If an error occurs outside the context of an IKE request\
    \ (e.g., the\n   node is getting ESP messages on a nonexistent SPI), the node\
    \ SHOULD\n   initiate an INFORMATIONAL exchange with a Notify payload describing\n\
    \   the problem.\n   A node receiving a suspicious message from an IP address\
    \ (and port,\n   if NAT traversal is used) with which it has an IKE SA SHOULD\
    \ send an\n   IKE Notify payload in an IKE INFORMATIONAL exchange over that SA.\n\
    \   The recipient MUST NOT change the state of any SAs as a result, but\n   may\
    \ wish to audit the event to aid in diagnosing malfunctions.\n"
- title: 2.22.  IPComp
  contents:
  - "2.22.  IPComp\n   Use of IP Compression [IP-COMP] can be negotiated as part of\
    \ the\n   setup of a Child SA.  While IP Compression involves an extra header\n\
    \   in each packet and a compression parameter index (CPI), the virtual\n   \"\
    compression association\" has no life outside the ESP or AH SA that\n   contains\
    \ it.  Compression associations disappear when the\n   corresponding ESP or AH\
    \ SA goes away.  It is not explicitly mentioned\n   in any Delete payload.\n \
    \  Negotiation of IP Compression is separate from the negotiation of\n   cryptographic\
    \ parameters associated with a Child SA.  A node\n   requesting a Child SA MAY\
    \ advertise its support for one or more\n   compression algorithms through one\
    \ or more Notify payloads of type\n   IPCOMP_SUPPORTED.  This Notify message may\
    \ be included only in a\n   message containing an SA payload negotiating a Child\
    \ SA and indicates\n   a willingness by its sender to use IPComp on this SA. \
    \ The response\n   MAY indicate acceptance of a single compression algorithm with\
    \ a\n   Notify payload of type IPCOMP_SUPPORTED.  These payloads MUST NOT\n  \
    \ occur in messages that do not contain SA payloads.\n   The data associated with\
    \ this Notify message includes a two-octet\n   IPComp CPI followed by a one-octet\
    \ Transform ID optionally followed\n   by attributes whose length and format are\
    \ defined by that Transform\n   ID.  A message proposing an SA may contain multiple\
    \ IPCOMP_SUPPORTED\n   notifications to indicate multiple supported algorithms.\
    \  A message\n   accepting an SA may contain at most one.\n   The Transform IDs\
    \ are listed here.  The values in the following table\n   are only current as\
    \ of the publication date of RFC 4306.  Other\n   values may have been added since\
    \ then or will be added after the\n   publication of this document.  Readers should\
    \ refer to [IKEV2IANA]\n   for the latest values.\n   Name              Number\
    \   Defined In\n   -------------------------------------\n   IPCOMP_OUI      \
    \  1\n   IPCOMP_DEFLATE    2        RFC 2394\n   IPCOMP_LZS        3        RFC\
    \ 2395\n   IPCOMP_LZJH       4        RFC 3051\n   Although there has been discussion\
    \ of allowing multiple compression\n   algorithms to be accepted and to have different\
    \ compression\n   algorithms available for the two directions of a Child SA,\n\
    \   implementations of this specification MUST NOT accept an IPComp\n   algorithm\
    \ that was not proposed, MUST NOT accept more than one, and\n   MUST NOT compress\
    \ using an algorithm other than one proposed and\n   accepted in the setup of\
    \ the Child SA.\n   A side effect of separating the negotiation of IPComp from\n\
    \   cryptographic parameters is that it is not possible to propose\n   multiple\
    \ cryptographic suites and propose IP Compression with some of\n   them but not\
    \ others.\n   In some cases, Robust Header Compression (ROHC) may be more\n  \
    \ appropriate than IP Compression.  [ROHCV2] defines the use of ROHC\n   with\
    \ IKEv2 and IPsec.\n"
- title: 2.23.  NAT Traversal
  contents:
  - "2.23.  NAT Traversal\n   Network Address Translation (NAT) gateways are a controversial\n\
    \   subject.  This section briefly describes what they are and how they\n   are\
    \ likely to act on IKE traffic.  Many people believe that NATs are\n   evil and\
    \ that we should not design our protocols so as to make them\n   work better.\
    \  IKEv2 does specify some unintuitive processing rules in\n   order that NATs\
    \ are more likely to work.\n   NATs exist primarily because of the shortage of\
    \ IPv4 addresses,\n   though there are other rationales.  IP nodes that are \"\
    behind\" a NAT\n   have IP addresses that are not globally unique, but rather\
    \ are\n   assigned from some space that is unique within the network behind the\n\
    \   NAT but that are likely to be reused by nodes behind other NATs.\n   Generally,\
    \ nodes behind NATs can communicate with other nodes behind\n   the same NAT and\
    \ with nodes with globally unique addresses, but not\n   with nodes behind other\
    \ NATs.  There are exceptions to that rule.\n   When those nodes make connections\
    \ to nodes on the real Internet, the\n   NAT gateway \"translates\" the IP source\
    \ address to an address that\n   will be routed back to the gateway.  Messages\
    \ to the gateway from the\n   Internet have their destination addresses \"translated\"\
    \ to the\n   internal address that will route the packet to the correct endnode.\n\
    \   NATs are designed to be \"transparent\" to endnodes.  Neither software\n \
    \  on the node behind the NAT nor the node on the Internet requires\n   modification\
    \ to communicate through the NAT.  Achieving this\n   transparency is more difficult\
    \ with some protocols than with others.\n   Protocols that include IP addresses\
    \ of the endpoints within the\n   payloads of the packet will fail unless the\
    \ NAT gateway understands\n   the protocol and modifies the internal references\
    \ as well as those in\n   the headers.  Such knowledge is inherently unreliable,\
    \ is a network\n   layer violation, and often results in subtle problems.\n  \
    \ Opening an IPsec connection through a NAT introduces special\n   problems. \
    \ If the connection runs in transport mode, changing the IP\n   addresses on packets\
    \ will cause the checksums to fail and the NAT\n   cannot correct the checksums\
    \ because they are cryptographically\n   protected.  Even in tunnel mode, there\
    \ are routing problems because\n   transparently translating the addresses of\
    \ AH and ESP packets\n   requires special logic in the NAT and that logic is heuristic\
    \ and\n   unreliable in nature.  For that reason, IKEv2 will use UDP\n   encapsulation\
    \ of IKE and ESP packets.  This encoding is slightly less\n   efficient but is\
    \ easier for NATs to process.  In addition, firewalls\n   may be configured to\
    \ pass UDP-encapsulated IPsec traffic but not\n   plain, unencapsulated ESP/AH\
    \ or vice versa.\n   It is a common practice of NATs to translate TCP and UDP\
    \ port numbers\n   as well as addresses and use the port numbers of inbound packets\
    \ to\n   decide which internal node should get a given packet.  For this\n   reason,\
    \ even though IKE packets MUST be sent to and from UDP port 500\n   or 4500, they\
    \ MUST be accepted coming from any port and responses\n   MUST be sent to the\
    \ port from whence they came.  This is because the\n   ports may be modified as\
    \ the packets pass through NATs.  Similarly,\n   IP addresses of the IKE endpoints\
    \ are generally not included in the\n   IKE payloads because the payloads are\
    \ cryptographically protected and\n   could not be transparently modified by NATs.\n\
    \   Port 4500 is reserved for UDP-encapsulated ESP and IKE.  An IPsec\n   endpoint\
    \ that discovers a NAT between it and its correspondent (as\n   described below)\
    \ MUST send all subsequent traffic from port 4500,\n   which NATs should not treat\
    \ specially (as they might with port 500).\n   An initiator can use port 4500\
    \ for both IKE and ESP, regardless of\n   whether or not there is a NAT, even\
    \ at the beginning of IKE.  When\n   either side is using port 4500, sending ESP\
    \ with UDP encapsulation is\n   not required, but understanding received UDP-encapsulated\
    \ ESP packets\n   is required.  UDP encapsulation MUST NOT be done on port 500.\
    \  If\n   Network Address Translation Traversal (NAT-T) is supported (that is,\n\
    \   if NAT_DETECTION_*_IP payloads were exchanged during IKE_SA_INIT),\n   all\
    \ devices MUST be able to receive and process both UDP-encapsulated\n   ESP and\
    \ non-UDP-encapsulated ESP packets at any time.  Either side\n   can decide whether\
    \ or not to use UDP encapsulation for ESP\n   irrespective of the choice made\
    \ by the other side.  However, if a NAT\n   is detected, both devices MUST use\
    \ UDP encapsulation for ESP.\n   The specific requirements for supporting NAT\
    \ traversal [NATREQ] are\n   listed below.  Support for NAT traversal is optional.\
    \  In this\n   section only, requirements listed as MUST apply only to\n   implementations\
    \ supporting NAT traversal.\n   o  Both the IKE initiator and responder MUST include\
    \ in their\n      IKE_SA_INIT packets Notify payloads of type\n      NAT_DETECTION_SOURCE_IP\
    \ and NAT_DETECTION_DESTINATION_IP.  Those\n      payloads can be used to detect\
    \ if there is NAT between the hosts,\n      and which end is behind the NAT. \
    \ The location of the payloads in\n      the IKE_SA_INIT packets is just after\
    \ the Ni and Nr payloads\n      (before the optional CERTREQ payload).\n   o \
    \ The data associated with the NAT_DETECTION_SOURCE_IP notification\n      is\
    \ a SHA-1 digest of the SPIs (in the order they appear in the\n      header),\
    \ IP address, and port from which this packet was sent.\n      There MAY be multiple\
    \ NAT_DETECTION_SOURCE_IP payloads in a\n      message if the sender does not\
    \ know which of several network\n      attachments will be used to send the packet.\n\
    \   o  The data associated with the NAT_DETECTION_DESTINATION_IP\n      notification\
    \ is a SHA-1 digest of the SPIs (in the order they\n      appear in the header),\
    \ IP address, and port to which this packet\n      was sent.\n   o  The recipient\
    \ of either the NAT_DETECTION_SOURCE_IP or\n      NAT_DETECTION_DESTINATION_IP\
    \ notification MAY compare the supplied\n      value to a SHA-1 hash of the SPIs,\
    \ source or recipient IP address\n      (respectively), address, and port, and\
    \ if they don't match, it\n      SHOULD enable NAT traversal.  In the case there\
    \ is a mismatch of\n      the NAT_DETECTION_SOURCE_IP hash with all of the\n \
    \     NAT_DETECTION_SOURCE_IP payloads received, the recipient MAY\n      reject\
    \ the connection attempt if NAT traversal is not supported.\n      In the case\
    \ of a mismatching NAT_DETECTION_DESTINATION_IP hash, it\n      means that the\
    \ system receiving the NAT_DETECTION_DESTINATION_IP\n      payload is behind a\
    \ NAT and that system SHOULD start sending\n      keepalive packets as defined\
    \ in [UDPENCAPS]; alternately, it MAY\n      reject the connection attempt if\
    \ NAT traversal is not supported.\n   o  If none of the NAT_DETECTION_SOURCE_IP\
    \ payload(s) received matches\n      the expected value of the source IP and port\
    \ found from the IP\n      header of the packet containing the payload, it means\
    \ that the\n      system sending those payloads is behind a NAT (i.e., someone\
    \ along\n      the route changed the source address of the original packet to\n\
    \      match the address of the NAT box).  In this case, the system\n      receiving\
    \ the payloads should allow dynamic updates of the other\n      systems' IP address,\
    \ as described later.\n   o  The IKE initiator MUST check the NAT_DETECTION_SOURCE_IP\
    \ or\n      NAT_DETECTION_DESTINATION_IP payloads if present, and if they do\n\
    \      not match the addresses in the outer packet, MUST tunnel all\n      future\
    \ IKE and ESP packets associated with this IKE SA over UDP\n      port 4500.\n\
    \   o  To tunnel IKE packets over UDP port 4500, the IKE header has four\n   \
    \   octets of zero prepended and the result immediately follows the\n      UDP\
    \ header.  To tunnel ESP packets over UDP port 4500, the ESP\n      header immediately\
    \ follows the UDP header.  Since the first four\n      octets of the ESP header\
    \ contain the SPI, and the SPI cannot\n      validly be zero, it is always possible\
    \ to distinguish ESP and IKE\n      messages.\n   o  Implementations MUST process\
    \ received UDP-encapsulated ESP packets\n      even when no NAT was detected.\n\
    \   o  The original source and destination IP address required for the\n     \
    \ transport mode TCP and UDP packet checksum fixup (see [UDPENCAPS])\n      are\
    \ obtained from the Traffic Selectors associated with the\n      exchange.  In\
    \ the case of transport mode NAT traversal, the\n      Traffic Selectors MUST\
    \ contain exactly one IP address, which is\n      then used as the original IP\
    \ address.  This is covered in greater\n      detail in Section 2.23.1.\n   o\
    \  There are cases where a NAT box decides to remove mappings that\n      are\
    \ still alive (for example, the keepalive interval is too long,\n      or the\
    \ NAT box is rebooted).  This will be apparent to a host if\n      it receives\
    \ a packet whose integrity protection validates, but has\n      a different port,\
    \ address, or both from the one that was\n      associated with the SA in the\
    \ validated packet.  When such a\n      validated packet is found, a host that\
    \ does not support other\n      methods of recovery such as IKEv2 Mobility and\
    \ Multihoming\n      (MOBIKE) [MOBIKE], and that is not behind a NAT, SHOULD send\
    \ all\n      packets (including retransmission packets) to the IP address and\n\
    \      port in the validated packet, and SHOULD store this as the new\n      address\
    \ and port combination for the SA (that is, they SHOULD\n      dynamically update\
    \ the address).  A host behind a NAT SHOULD NOT\n      do this type of dynamic\
    \ address update if a validated packet has\n      different port and/or address\
    \ values because it opens a possible\n      DoS attack (such as allowing an attacker\
    \ to break the connection\n      with a single packet).  Also, dynamic address\
    \ update should only\n      be done in response to a new packet; otherwise, an\
    \ attacker can\n      revert the addresses with old replayed packets.  Because\
    \ of this,\n      dynamic updates can only be done safely if replay protection\
    \ is\n      enabled.  When IKEv2 is used with MOBIKE, dynamically updating the\n\
    \      addresses described above interferes with MOBIKE's way of\n      recovering\
    \ from the same situation.  See Section 3.8 of [MOBIKE]\n      for more information.\n"
- title: 2.23.1.  Transport Mode NAT Traversal
  contents:
  - "2.23.1.  Transport Mode NAT Traversal\n   Transport mode used with NAT Traversal\
    \ requires special handling of\n   the Traffic Selectors used in the IKEv2.  The\
    \ complete scenario looks\n   like:\n   +------+        +------+            +------+\
    \         +------+\n   |Client| IP1    | NAT  | IPN1  IPN2 | NAT  |     IP2 |Server|\n\
    \   |node  |<------>|  A   |<---------->|  B   |<------->|      |\n   +------+\
    \        +------+            +------+         +------+\n   (Other scenarios are\
    \ simplifications of this complex case, so this\n   discussion uses the complete\
    \ scenario.)\n   In this scenario, there are two address translating NATs: NAT\
    \ A and\n   NAT B.  NAT A is a dynamic NAT that maps the client's source address\n\
    \   IP1 to IPN1.  NAT B is a static NAT configured so that connections\n   coming\
    \ to IPN2 address are mapped to the gateway's address IP2, that\n   is, IPN2 destination\
    \ address is mapped to IP2.  This allows the\n   client to connect to a server\
    \ by connecting to the IPN2.  NAT B does\n   not necessarily need to be a static\
    \ NAT, but the client needs to know\n   how to connect to the server, and it can\
    \ only do that if it somehow\n   knows the outer address of the NAT B, that is,\
    \ the IPN2 address.  If\n   NAT B is a static NAT, then its address can be configured\
    \ to the\n   client's configuration.  Another option would be to find it using\n\
    \   some other protocol (like DNS), but that is outside of scope of\n   IKEv2.\n\
    \   In this scenario, both the client and server are configured to use\n   transport\
    \ mode for the traffic originating from the client node and\n   destined to the\
    \ server.\n   When the client starts creating the IKEv2 SA and Child SA for sending\n\
    \   traffic to the server, it may have a triggering packet with source IP\n  \
    \ address of IP1, and a destination IP address of IPN2.  Its Peer\n   Authorization\
    \ Database (PAD) and SPD needs to have a configuration\n   matching those addresses\
    \ (or wildcard entries covering them).\n   Because this is transport mode, it\
    \ uses exactly same addresses as the\n   Traffic Selectors and outer IP address\
    \ of the IKE packets.  For\n   transport mode, it MUST use exactly one IP address\
    \ in the TSi and TSr\n   payloads.  It can have multiple Traffic Selectors if\
    \ it has, for\n   example, multiple port ranges that it wants to negotiate, but\
    \ all TSi\n   entries must use the IP1-IP1 range as the IP addresses, and all\
    \ TSr\n   entries must have the IPN2-IPN2 range as IP addresses.  The first\n\
    \   Traffic Selector of TSi and TSr SHOULD have very specific Traffic\n   Selectors\
    \ including protocol and port numbers, such as from the\n   packet triggering\
    \ the request.\n   NAT A will then replace the source address of the IKE packet\
    \ from IP1\n   to IPN1, and NAT B will replace the destination address of the\
    \ IKE\n   packet from IPN2 to IP2, so when the packet arrives to the server it\n\
    \   will still have the exactly same Traffic Selectors that were sent by\n   the\
    \ client, but the IP address of the IKE packet has been replaced by\n   IPN1 and\
    \ IP2.\n   When the server receives this packet, it normally looks in the Peer\n\
    \   Authorization Database (PAD) described in RFC 4301 [IPSECARCH] based\n   on\
    \ the ID and then searches the SPD based on the Traffic Selectors.\n   Because\
    \ IP1 does not really mean anything to the server (it is the\n   address client\
    \ has behind the NAT), it is useless to do a lookup\n   based on that if transport\
    \ mode is used.  On the other hand, the\n   server cannot know whether transport\
    \ mode is allowed by its policy\n   before it finds the matching SPD entry.\n\
    \   In this case, the server should first check that the initiator\n   requested\
    \ transport mode, and then do address substitution on the\n   Traffic Selectors.\
    \  It needs to first store the old Traffic Selector\n   IP addresses to be used\
    \ later for the incremental checksum fixup (the\n   IP address in the TSi can\
    \ be stored as the original source address\n   and the IP address in the TSr can\
    \ be stored as the original\n   destination address).  After that, if the other\
    \ end was detected as\n   being behind a NAT, the server replaces the IP address\
    \ in TSi\n   payloads with the IP address obtained from the source address of\
    \ the\n   IKE packet received (that is, it replaces IP1 in TSi with IPN1).  If\n\
    \   the server's end was detected to be behind NAT, it replaces the IP\n   address\
    \ in the TSr payloads with the IP address obtained from the\n   destination address\
    \ of the IKE packet received (that is, it replaces\n   IPN2 in TSr with IP2).\n\
    \   After this address substitution, both the Traffic Selectors and the\n   IKE\
    \ UDP source/destination addresses look the same, and the server\n   does SPD\
    \ lookup based on those new Traffic Selectors.  If an entry is\n   found and it\
    \ allows transport mode, then that entry is used.  If an\n   entry is found but\
    \ it does not allow transport mode, then the server\n   MAY undo the address substitution\
    \ and redo the SPD lookup using the\n   original Traffic Selectors.  If the second\
    \ lookup succeeds, the\n   server will create an SA in tunnel mode using real\
    \ Traffic Selectors\n   sent by the other end.\n   This address substitution in\
    \ transport mode is needed because the SPD\n   is looked up using the addresses\
    \ that will be seen by the local host.\n   This also will make sure the Security\
    \ Association Database (SAD)\n   entries for the tunnel exit checks and return\
    \ packets is added using\n   the addresses as seen by the local operating system\
    \ stack.\n   The most common case is that the server's SPD will contain wildcard\n\
    \   entries matching any addresses, but this also allows making different\n  \
    \ SPD entries, for example, for different known NATs' outer addresses.\n   After\
    \ the SPD lookup, the server will do Traffic Selector narrowing\n   based on the\
    \ SPD entry it found.  It will again use the already\n   substituted Traffic Selectors,\
    \ and it will thus send back Traffic\n   Selectors having IPN1 and IP2 as their\
    \ IP addresses; it can still\n   narrow down the protocol number or port ranges\
    \ used by the Traffic\n   Selectors.  The SAD entry created for the Child SA will\
    \ have the\n   addresses as seen by the server, namely IPN1 and IP2.\n   When\
    \ the client receives the server's response to the Child SA, it\n   will do similar\
    \ processing.  If the transport mode SA was created,\n   the client can store\
    \ the original returned Traffic Selectors as\n   original source and destination\
    \ addresses.  It will replace the IP\n   addresses in the Traffic Selectors with\
    \ the ones from the IP header\n   of the IKE packet: it will replace IPN1 with\
    \ IP1 and IP2 with IPN2.\n   Then, it will use those Traffic Selectors when verifying\
    \ the SA\n   against sent Traffic Selectors, and when installing the SAD entry.\n\
    \   A summary of the rules for NAT traversal in transport mode is:\n   For the\
    \ client proposing transport mode:\n   - The TSi entries MUST have exactly one\
    \ IP address, and that MUST\n     match the source address of the IKE SA.\n  \
    \ - The TSr entries MUST have exactly one IP address, and that MUST\n     match\
    \ the destination address of the IKE SA.\n   - The first TSi and TSr Traffic Selectors\
    \ SHOULD have very specific\n     Traffic Selectors including protocol and port\
    \ numbers, such as\n     from the packet triggering the request.\n   - There MAY\
    \ be multiple TSi and TSr entries.\n   - If transport mode for the SA was selected\
    \ (that is, if the server\n     included USE_TRANSPORT_MODE notification in its\
    \ response):\n     - Store the original Traffic Selectors as the received source\
    \ and\n       destination address.\n     - If the server is behind a NAT, substitute\
    \ the IP address in the\n       TSr entries with the remote address of the IKE\
    \ SA.\n     - If the client is behind a NAT, substitute the IP address in the\n\
    \       TSi entries with the local address of the IKE SA.\n     - Do address substitution\
    \ before using those Traffic Selectors\n       for anything other than storing\
    \ original content of them.\n       This includes verification that Traffic Selectors\
    \ were narrowed\n       correctly by the other end, creation of the SAD entry,\
    \ and so on.\n   For the responder, when transport mode is proposed by client:\n\
    \   - Store the original Traffic Selector IP addresses as received source\n  \
    \   and destination address, in case undo address\n     substitution is needed,\
    \ to use as the \"real source and destination\n     address\" specified by [UDPENCAPS],\
    \ and for TCP/UDP checksum fixup.\n   - If the client is behind a NAT, substitute\
    \ the IP address in the\n     TSi entries with the remote address of the IKE SA.\n\
    \   - If the server is behind a NAT, substitute the IP address in the\n     TSr\
    \ entries with the local address of the IKE SA.\n   - Do PAD and SPD lookup using\
    \ the ID and substituted Traffic\n     Selectors.\n   - If no SPD entry was found,\
    \ or if found SPD entry does not\n     allow transport mode, undo the Traffic\
    \ Selector substitutions.\n     Do PAD and SPD lookup again using the ID and original\
    \ Traffic\n     Selectors, but also searching for tunnel mode SPD entry (that\n\
    \     is, fall back to tunnel mode).\n   - However, if a transport mode SPD entry\
    \ was found, do normal\n     traffic selection narrowing based on the substituted\
    \ Traffic\n     Selectors and SPD entry.  Use the resulting Traffic Selectors\
    \ when\n     creating SAD entries, and when sending Traffic Selectors back to\n\
    \     the client.\n"
- title: 2.24.  Explicit Congestion Notification (ECN)
  contents:
  - "2.24.  Explicit Congestion Notification (ECN)\n   When IPsec tunnels behave as\
    \ originally specified in [IPSECARCH-OLD],\n   ECN usage is not appropriate for\
    \ the outer IP headers because tunnel\n   decapsulation processing discards ECN\
    \ congestion indications to the\n   detriment of the network.  ECN support for\
    \ IPsec tunnels for IKEv1-\n   based IPsec requires multiple operating modes and\
    \ negotiation (see\n   [ECN]).  IKEv2 simplifies this situation by requiring that\
    \ ECN be\n   usable in the outer IP headers of all tunnel mode Child SAs created\n\
    \   by IKEv2.  Specifically, tunnel encapsulators and decapsulators for\n   all\
    \ tunnel mode SAs created by IKEv2 MUST support the ECN full-\n   functionality\
    \ option for tunnels specified in [ECN] and MUST\n   implement the tunnel encapsulation\
    \ and decapsulation processing\n   specified in [IPSECARCH] to prevent discarding\
    \ of ECN congestion\n   indications.\n"
- title: 2.25.  Exchange Collisions
  contents:
  - "2.25.  Exchange Collisions\n   Because IKEv2 exchanges can be initiated by either\
    \ peer, it is\n   possible that two exchanges affecting the same SA partly overlap.\n\
    \   This can lead to a situation where the SA state information is\n   temporarily\
    \ not synchronized, and a peer can receive a request that\n   it cannot process\
    \ in a normal fashion.\n   Obviously, using a window size greater than 1 leads\
    \ to more complex\n   situations, especially if requests are processed out of\
    \ order.  This\n   section concentrates on problems that can arise even with a\
    \ window\n   size of 1, and recommends solutions.\n   A TEMPORARY_FAILURE notification\
    \ SHOULD be sent when a peer receives\n   a request that cannot be completed due\
    \ to a temporary condition such\n   as a rekeying operation.  When a peer receives\
    \ a TEMPORARY_FAILURE\n   notification, it MUST NOT immediately retry the operation;\
    \ it MUST\n   wait so that the sender may complete whatever operation caused the\n\
    \   temporary condition.  The recipient MAY retry the request one or more\n  \
    \ times over a period of several minutes.  If a peer continues to\n   receive\
    \ TEMPORARY_FAILURE on the same IKE SA after several minutes,\n   it SHOULD conclude\
    \ that the state information is out of sync and\n   close the IKE SA.\n   A CHILD_SA_NOT_FOUND\
    \ notification SHOULD be sent when a peer receives\n   a request to rekey a Child\
    \ SA that does not exist.  The SA that the\n   initiator attempted to rekey is\
    \ indicated by the SPI field in the\n   Notify payload, which is copied from the\
    \ SPI field in the REKEY_SA\n   notification.  A peer that receives a CHILD_SA_NOT_FOUND\
    \ notification\n   SHOULD silently delete the Child SA (if it still exists) and\
    \ send a\n   request to create a new Child SA from scratch (if the Child SA does\n\
    \   not yet exist).\n"
- title: 2.25.1.  Collisions while Rekeying or Closing Child SAs
  contents:
  - "2.25.1.  Collisions while Rekeying or Closing Child SAs\n   If a peer receives\
    \ a request to rekey a Child SA that it is currently\n   trying to close, it SHOULD\
    \ reply with TEMPORARY_FAILURE.  If a peer\n   receives a request to rekey a Child\
    \ SA that it is currently rekeying,\n   it SHOULD reply as usual, and SHOULD prepare\
    \ to close redundant SAs\n   later based on the nonces (see Section 2.8.1).  If\
    \ a peer receives a\n   request to rekey a Child SA that does not exist, it SHOULD\
    \ reply with\n   CHILD_SA_NOT_FOUND.\n   If a peer receives a request to close\
    \ a Child SA that it is currently\n   trying to close, it SHOULD reply without\
    \ a Delete payload (see\n   Section 1.4.1).  If a peer receives a request to close\
    \ a Child SA\n   that it is currently rekeying, it SHOULD reply as usual, with\
    \ a\n   Delete payload.  If a peer receives a request to close a Child SA\n  \
    \ that does not exist, it SHOULD reply without a Delete payload.\n   If a peer\
    \ receives a request to rekey the IKE SA, and it is currently\n   creating, rekeying,\
    \ or closing a Child SA of that IKE SA, it SHOULD\n   reply with TEMPORARY_FAILURE.\n"
- title: 2.25.2.  Collisions while Rekeying or Closing IKE SAs
  contents:
  - "2.25.2.  Collisions while Rekeying or Closing IKE SAs\n   If a peer receives\
    \ a request to rekey an IKE SA that it is currently\n   rekeying, it SHOULD reply\
    \ as usual, and SHOULD prepare to close\n   redundant SAs and move inherited Child\
    \ SAs later based on the nonces\n   (see Section 2.8.2).  If a peer receives a\
    \ request to rekey an IKE SA\n   that it is currently trying to close, it SHOULD\
    \ reply with\n   TEMPORARY_FAILURE.\n   If a peer receives a request to close\
    \ an IKE SA that it is currently\n   rekeying, it SHOULD reply as usual, and forget\
    \ about its own rekeying\n   request.  If a peer receives a request to close an\
    \ IKE SA that it is\n   currently trying to close, it SHOULD reply as usual, and\
    \ forget about\n   its own close request.\n   If a peer receives a request to\
    \ create or rekey a Child SA when it is\n   currently rekeying the IKE SA, it\
    \ SHOULD reply with\n   TEMPORARY_FAILURE.  If a peer receives a request to delete\
    \ a Child SA\n   when it is currently rekeying the IKE SA, it SHOULD reply as\
    \ usual,\n   with a Delete payload.\n"
- title: 3.  Header and Payload Formats
  contents:
  - "3.  Header and Payload Formats\n   In the tables in this section, some cryptographic\
    \ primitives and\n   configuration attributes are marked as \"UNSPECIFIED\". \
    \ These are\n   items for which there are no known specifications and therefore\n\
    \   interoperability is currently impossible.  A future specification may\n  \
    \ describe their use, but until such specification is made,\n   implementations\
    \ SHOULD NOT attempt to use items marked as\n   \"UNSPECIFIED\" in implementations\
    \ that are meant to be interoperable.\n"
- title: 3.1.  The IKE Header
  contents:
  - "3.1.  The IKE Header\n   IKE messages use UDP ports 500 and/or 4500, with one\
    \ IKE message per\n   UDP datagram.  Information from the beginning of the packet\
    \ through\n   the UDP header is largely ignored except that the IP addresses and\n\
    \   UDP ports from the headers are reversed and used for return packets.\n   When\
    \ sent on UDP port 500, IKE messages begin immediately following\n   the UDP header.\
    \  When sent on UDP port 4500, IKE messages have\n   prepended four octets of\
    \ zero.  These four octets of zeros are not\n   part of the IKE message and are\
    \ not included in any of the length\n   fields or checksums defined by IKE.  Each\
    \ IKE message begins with the\n   IKE header, denoted HDR in this document.  Following\
    \ the header are\n   one or more IKE payloads each identified by a \"Next Payload\"\
    \ field in\n   the preceding payload.  Payloads are identified in the order in\
    \ which\n   they appear in an IKE message by looking in the \"Next Payload\" field\n\
    \   in the IKE header, and subsequently according to the \"Next Payload\"\n  \
    \ field in the IKE payload itself until a \"Next Payload\" field of zero\n   indicates\
    \ that no payloads follow.  If a payload of type \"Encrypted\"\n   is found, that\
    \ payload is decrypted and its contents parsed as\n   additional payloads.  An\
    \ Encrypted payload MUST be the last payload\n   in a packet and an Encrypted\
    \ payload MUST NOT contain another\n   Encrypted payload.\n   The responder's\
    \ SPI in the header identifies an instance of an IKE\n   Security Association.\
    \  It is therefore possible for a single instance\n   of IKE to multiplex distinct\
    \ sessions with multiple peers, including\n   multiple sessions per peer.\n  \
    \ All multi-octet fields representing integers are laid out in big\n   endian\
    \ order (also known as \"most significant byte first\", or\n   \"network byte\
    \ order\").\n   The format of the IKE header is shown in Figure 4.\n         \
    \               1                   2                   3\n    0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       IKE SA Initiator's SPI                  |\n   |  \
    \                                                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       IKE SA Responder's SPI                  |\n   |  \
    \                                                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Next Payload | MjVer | MnVer | Exchange Type |     Flags     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          Message ID                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                            Length                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                    Figure 4:  IKE Header Format\n   o  Initiator's SPI (8 octets)\
    \ - A value chosen by the initiator to\n      identify a unique IKE Security Association.\
    \  This value MUST NOT\n      be zero.\n   o  Responder's SPI (8 octets) - A value\
    \ chosen by the responder to\n      identify a unique IKE Security Association.\
    \  This value MUST be\n      zero in the first message of an IKE initial exchange\
    \ (including\n      repeats of that message including a cookie).\n   o  Next Payload\
    \ (1 octet) - Indicates the type of payload that\n      immediately follows the\
    \ header.  The format and value of each\n      payload are defined below.\n  \
    \ o  Major Version (4 bits) - Indicates the major version of the IKE\n      protocol\
    \ in use.  Implementations based on this version of IKE\n      MUST set the major\
    \ version to 2.  Implementations based on\n      previous versions of IKE and\
    \ ISAKMP MUST set the major version to\n      1.  Implementations based on this\
    \ version of IKE MUST reject or\n      ignore messages containing a version number\
    \ greater than 2 with an\n      INVALID_MAJOR_VERSION notification message as\
    \ described in Section\n      2.5.\n   o  Minor Version (4 bits) - Indicates the\
    \ minor version of the IKE\n      protocol in use.  Implementations based on this\
    \ version of IKE\n      MUST set the minor version to 0.  They MUST ignore the\
    \ minor\n      version number of received messages.\n   o  Exchange Type (1 octet)\
    \ - Indicates the type of exchange being\n      used.  This constrains the payloads\
    \ sent in each message in an\n      exchange.  The values in the following table\
    \ are only current as\n      of the publication date of RFC 4306.  Other values\
    \ may have been\n      added since then or will be added after the publication\
    \ of this\n      document.  Readers should refer to [IKEV2IANA] for the latest\n\
    \      values.\n      Exchange Type             Value\n      ----------------------------------\n\
    \      IKE_SA_INIT               34\n      IKE_AUTH                  35\n    \
    \  CREATE_CHILD_SA           36\n      INFORMATIONAL             37\n   o  Flags\
    \ (1 octet) - Indicates specific options that are set for the\n      message.\
    \  Presence of options is indicated by the appropriate bit\n      in the flags\
    \ field being set.  The bits are as follows:\n        +-+-+-+-+-+-+-+-+\n    \
    \    |X|X|R|V|I|X|X|X|\n        +-+-+-+-+-+-+-+-+\n   In the description below,\
    \ a bit being 'set' means its value is '1',\n   while 'cleared' means its value\
    \ is '0'.  'X' bits MUST be cleared\n   when sending and MUST be ignored on receipt.\n\
    \      *  R (Response) - This bit indicates that this message is a\n         response\
    \ to a message containing the same Message ID.  This bit\n         MUST be cleared\
    \ in all request messages and MUST be set in all\n         responses.  An IKE\
    \ endpoint MUST NOT generate a response to a\n         message that is marked\
    \ as being a response (with one exception;\n         see Section 2.21.2).\n  \
    \    *  V (Version) - This bit indicates that the transmitter is\n         capable\
    \ of speaking a higher major version number of the\n         protocol than the\
    \ one indicated in the major version number\n         field.  Implementations\
    \ of IKEv2 MUST clear this bit when\n         sending and MUST ignore it in incoming\
    \ messages.\n      *  I (Initiator) - This bit MUST be set in messages sent by\
    \ the\n         original initiator of the IKE SA and MUST be cleared in\n    \
    \     messages sent by the original responder.  It is used by the\n         recipient\
    \ to determine which eight octets of the SPI were\n         generated by the recipient.\
    \  This bit changes to reflect who\n         initiated the last rekey of the IKE\
    \ SA.\n   o  Message ID (4 octets, unsigned integer) - Message identifier used\n\
    \      to control retransmission of lost packets and matching of requests\n  \
    \    and responses.  It is essential to the security of the protocol\n      because\
    \ it is used to prevent message replay attacks.  See\n      Sections 2.1 and 2.2.\n\
    \   o  Length (4 octets, unsigned integer) - Length of the total message\n   \
    \   (header + payloads) in octets.\n"
- title: 3.2.  Generic Payload Header
  contents:
  - "3.2.  Generic Payload Header\n   Each IKE payload defined in Sections 3.3 through\
    \ 3.16 begins with a\n   generic payload header, shown in Figure 5.  Figures for\
    \ each payload\n   below will include the generic payload header, but for brevity,\
    \ the\n   description of each field will be omitted.\n                       \
    \ 1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Next Payload  |C|  RESERVED   |         Payload Length        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                      Figure 5:  Generic Payload Header\n   The Generic Payload\
    \ Header fields are defined as follows:\n   o  Next Payload (1 octet) - Identifier\
    \ for the payload type of the\n      next payload in the message.  If the current\
    \ payload is the last\n      in the message, then this field will be 0.  This\
    \ field provides a\n      \"chaining\" capability whereby additional payloads\
    \ can be added to\n      a message by appending each one to the end of the message\
    \ and\n      setting the \"Next Payload\" field of the preceding payload to\n\
    \      indicate the new payload's type.  An Encrypted payload, which must\n  \
    \    always be the last payload of a message, is an exception.  It\n      contains\
    \ data structures in the format of additional payloads.  In\n      the header\
    \ of an Encrypted payload, the Next Payload field is set\n      to the payload\
    \ type of the first contained payload (instead of 0);\n      conversely, the Next\
    \ Payload field of the last contained payload\n      is set to zero).  The payload\
    \ type values are listed here.  The\n      values in the following table are only\
    \ current as of the\n      publication date of RFC 4306.  Other values may have\
    \ been added\n      since then or will be added after the publication of this\n\
    \      document.  Readers should refer to [IKEV2IANA] for the latest\n      values.\n\
    \      Next Payload Type                Notation  Value\n      --------------------------------------------------\n\
    \      No Next Payload                             0\n      Security Association\
    \             SA         33\n      Key Exchange                     KE       \
    \  34\n      Identification - Initiator       IDi        35\n      Identification\
    \ - Responder       IDr        36\n      Certificate                      CERT\
    \       37\n      Certificate Request              CERTREQ    38\n      Authentication\
    \                   AUTH       39\n      Nonce                            Ni,\
    \ Nr     40\n      Notify                           N          41\n      Delete\
    \                           D          42\n      Vendor ID                   \
    \     V          43\n      Traffic Selector - Initiator     TSi        44\n  \
    \    Traffic Selector - Responder     TSr        45\n      Encrypted and Authenticated\
    \      SK         46\n      Configuration                    CP         47\n \
    \     Extensible Authentication        EAP        48\n      (Payload type values\
    \ 1-32 should not be assigned in the\n      future so that there is no overlap\
    \ with the code assignments\n      for IKEv1.)\n   o  Critical (1 bit) - MUST\
    \ be set to zero if the sender wants the\n      recipient to skip this payload\
    \ if it does not understand the\n      payload type code in the Next Payload field\
    \ of the previous\n      payload.  MUST be set to one if the sender wants the\
    \ recipient to\n      reject this entire message if it does not understand the\
    \ payload\n      type.  MUST be ignored by the recipient if the recipient\n  \
    \    understands the payload type code.  MUST be set to zero for\n      payload\
    \ types defined in this document.  Note that the critical\n      bit applies to\
    \ the current payload rather than the \"next\" payload\n      whose type code\
    \ appears in the first octet.  The reasoning behind\n      not setting the critical\
    \ bit for payloads defined in this document\n      is that all implementations\
    \ MUST understand all payload types\n      defined in this document and therefore\
    \ must ignore the critical\n      bit's value.  Skipped payloads are expected\
    \ to have valid Next\n      Payload and Payload Length fields.  See Section 2.5\
    \ for more\n      information on this bit.\n   o  RESERVED (7 bits) - MUST be\
    \ sent as zero; MUST be ignored on\n      receipt.\n   o  Payload Length (2 octets,\
    \ unsigned integer) - Length in octets of\n      the current payload, including\
    \ the generic payload header.\n   Many payloads contain fields marked as \"RESERVED\"\
    .  Some payloads in\n   IKEv2 (and historically in IKEv1) are not aligned to 4-octet\n\
    \   boundaries.\n"
- title: 3.3.  Security Association Payload
  contents:
  - "3.3.  Security Association Payload\n   The Security Association payload, denoted\
    \ SA in this document, is\n   used to negotiate attributes of a Security Association.\
    \  Assembly of\n   Security Association payloads requires great peace of mind.\
    \  An SA\n   payload MAY contain multiple proposals.  If there is more than one,\n\
    \   they MUST be ordered from most preferred to least preferred.  Each\n   proposal\
    \ contains a single IPsec protocol (where a protocol is IKE,\n   ESP, or AH),\
    \ each protocol MAY contain multiple transforms, and each\n   transform MAY contain\
    \ multiple attributes.  When parsing an SA, an\n   implementation MUST check that\
    \ the total Payload Length is consistent\n   with the payload's internal lengths\
    \ and counts.  Proposals,\n   Transforms, and Attributes each have their own variable-length\n\
    \   encodings.  They are nested such that the Payload Length of an SA\n   includes\
    \ the combined contents of the SA, Proposal, Transform, and\n   Attribute information.\
    \  The length of a Proposal includes the lengths\n   of all Transforms and Attributes\
    \ it contains.  The length of a\n   Transform includes the lengths of all Attributes\
    \ it contains.\n   The syntax of Security Associations, Proposals, Transforms,\
    \ and\n   Attributes is based on ISAKMP; however, the semantics are somewhat\n\
    \   different.  The reason for the complexity and the hierarchy is to\n   allow\
    \ for multiple possible combinations of algorithms to be encoded\n   in a single\
    \ SA.  Sometimes there is a choice of multiple algorithms,\n   whereas other times\
    \ there is a combination of algorithms.  For\n   example, an initiator might want\
    \ to propose using ESP with either\n   (3DES and HMAC_MD5) or (AES and HMAC_SHA1).\n\
    \   One of the reasons the semantics of the SA payload have changed from\n   ISAKMP\
    \ and IKEv1 is to make the encodings more compact in common\n   cases.\n   The\
    \ Proposal structure contains within it a Proposal Num and an IPsec\n   protocol\
    \ ID.  Each structure MUST have a proposal number one (1)\n   greater than the\
    \ previous structure.  The first Proposal in the\n   initiator's SA payload MUST\
    \ have a Proposal Num of one (1).  One\n   reason to use multiple proposals is\
    \ to propose both standard crypto\n   ciphers and combined-mode ciphers.  Combined-mode\
    \ ciphers include\n   both integrity and encryption in a single encryption algorithm,\
    \ and\n   MUST either offer no integrity algorithm or a single integrity\n   algorithm\
    \ of \"none\", with no integrity algorithm being the\n   RECOMMENDED method. \
    \ If an initiator wants to propose both combined-\n   mode ciphers and normal\
    \ ciphers, it must include two proposals: one\n   will have all the combined-mode\
    \ ciphers, and the other will have all\n   the normal ciphers with the integrity\
    \ algorithms.  For example, one\n   such proposal would have two proposal structures.\
    \  Proposal 1 is ESP\n   with AES-128, AES-192, and AES-256 bits in Cipher Block\
    \ Chaining\n   (CBC) mode, with either HMAC-SHA1-96 or XCBC-96 as the integrity\n\
    \   algorithm; Proposal 2 is AES-128 or AES-256 in GCM mode with an\n   8-octet\
    \ Integrity Check Value (ICV).  Both proposals allow but do not\n   require the\
    \ use of ESNs (Extended Sequence Numbers).  This can be\n   illustrated as:\n\
    \   SA Payload\n      |\n      +--- Proposal #1 ( Proto ID = ESP(3), SPI size\
    \ = 4,\n      |     |            7 transforms,      SPI = 0x052357bb )\n     \
    \ |     |\n      |     +-- Transform ENCR ( Name = ENCR_AES_CBC )\n      |   \
    \  |     +-- Attribute ( Key Length = 128 )\n      |     |\n      |     +-- Transform\
    \ ENCR ( Name = ENCR_AES_CBC )\n      |     |     +-- Attribute ( Key Length =\
    \ 192 )\n      |     |\n      |     +-- Transform ENCR ( Name = ENCR_AES_CBC )\n\
    \      |     |     +-- Attribute ( Key Length = 256 )\n      |     |\n      |\
    \     +-- Transform INTEG ( Name = AUTH_HMAC_SHA1_96 )\n      |     +-- Transform\
    \ INTEG ( Name = AUTH_AES_XCBC_96 )\n      |     +-- Transform ESN ( Name = ESNs\
    \ )\n      |     +-- Transform ESN ( Name = No ESNs )\n      |\n      +--- Proposal\
    \ #2 ( Proto ID = ESP(3), SPI size = 4,\n            |            4 transforms,\
    \      SPI = 0x35a1d6f2 )\n            |\n            +-- Transform ENCR ( Name\
    \ = AES-GCM with a 8 octet ICV )\n            |     +-- Attribute ( Key Length\
    \ = 128 )\n            |\n            +-- Transform ENCR ( Name = AES-GCM with\
    \ a 8 octet ICV )\n            |     +-- Attribute ( Key Length = 256 )\n    \
    \        |\n            +-- Transform ESN ( Name = ESNs )\n            +-- Transform\
    \ ESN ( Name = No ESNs )\n   Each Proposal/Protocol structure is followed by one\
    \ or more transform\n   structures.  The number of different transforms is generally\n\
    \   determined by the Protocol.  AH generally has two transforms:\n   Extended\
    \ Sequence Numbers (ESNs) and an integrity check algorithm.\n   ESP generally\
    \ has three: ESN, an encryption algorithm, and an\n   integrity check algorithm.\
    \  IKE generally has four transforms: a\n   Diffie-Hellman group, an integrity\
    \ check algorithm, a PRF algorithm,\n   and an encryption algorithm.  For each\
    \ Protocol, the set of\n   permissible transforms is assigned Transform ID numbers,\
    \ which appear\n   in the header of each transform.\n   If there are multiple\
    \ transforms with the same Transform Type, the\n   proposal is an OR of those\
    \ transforms.  If there are multiple\n   transforms with different Transform Types,\
    \ the proposal is an AND of\n   the different groups.  For example, to propose\
    \ ESP with (3DES or AES-\n   CBC) and (HMAC_MD5 or HMAC_SHA), the ESP proposal\
    \ would contain two\n   Transform Type 1 candidates (one for 3DES and one for\
    \ AEC-CBC) and\n   two Transform Type 3 candidates (one for HMAC_MD5 and one for\n\
    \   HMAC_SHA).  This effectively proposes four combinations of\n   algorithms.\
    \  If the initiator wanted to propose only a subset of\n   those, for example\
    \ (3DES and HMAC_MD5) or (IDEA and HMAC_SHA), there\n   is no way to encode that\
    \ as multiple transforms within a single\n   Proposal.  Instead, the initiator\
    \ would have to construct two\n   different Proposals, each with two transforms.\n\
    \   A given transform MAY have one or more Attributes.  Attributes are\n   necessary\
    \ when the transform can be used in more than one way, as\n   when an encryption\
    \ algorithm has a variable key size.  The transform\n   would specify the algorithm\
    \ and the attribute would specify the key\n   size.  Most transforms do not have\
    \ attributes.  A transform MUST NOT\n   have multiple attributes of the same type.\
    \  To propose alternate\n   values for an attribute (for example, multiple key\
    \ sizes for the AES\n   encryption algorithm), an implementation MUST include\
    \ multiple\n   transforms with the same Transform Type each with a single Attribute.\n\
    \   Note that the semantics of Transforms and Attributes are quite\n   different\
    \ from those in IKEv1.  In IKEv1, a single Transform carried\n   multiple algorithms\
    \ for a protocol with one carried in the Transform\n   and the others carried\
    \ in the Attributes.\n                        1                   2          \
    \         3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  \
    \ | Next Payload  |C|  RESERVED   |         Payload Length        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \                        <Proposals>                          ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \            Figure 6:  Security Association Payload\n   o  Proposals (variable)\
    \ - One or more proposal substructures.\n   The payload type for the Security\
    \ Association payload is thirty-three\n   (33).\n"
- title: 3.3.1.  Proposal Substructure
  contents:
  - "3.3.1.  Proposal Substructure\n                        1                   2\
    \                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | 0 (last) or 2 |   RESERVED    |         Proposal Length       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Proposal Num  |  Protocol ID  |    SPI Size   |Num  Transforms|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   ~                        SPI (variable)                         ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \                      <Transforms>                           ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \            Figure 7:  Proposal Substructure\n   o  0 (last) or 2 (more) (1 octet)\
    \ - Specifies whether this is the\n      last Proposal Substructure in the SA.\
    \  This syntax is inherited\n      from ISAKMP, but is unnecessary because the\
    \ last Proposal could be\n      identified from the length of the SA.  The value\
    \ (2) corresponds\n      to a payload type of Proposal in IKEv1, and the first\
    \ four octets\n      of the Proposal structure are designed to look somewhat like\
    \ the\n      header of a payload.\n   o  RESERVED (1 octet) - MUST be sent as\
    \ zero; MUST be ignored on\n      receipt.\n   o  Proposal Length (2 octets, unsigned\
    \ integer) - Length of this\n      proposal, including all transforms and attributes\
    \ that follow.\n   o  Proposal Num (1 octet) - When a proposal is made, the first\n\
    \      proposal in an SA payload MUST be 1, and subsequent proposals MUST\n  \
    \    be one more than the previous proposal (indicating an OR of the\n      two\
    \ proposals).  When a proposal is accepted, the proposal number\n      in the\
    \ SA payload MUST match the number on the proposal sent that\n      was accepted.\n\
    \   o  Protocol ID (1 octet) - Specifies the IPsec protocol identifier\n     \
    \ for the current negotiation.  The values in the following table\n      are only\
    \ current as of the publication date of RFC 4306.  Other\n      values may have\
    \ been added since then or will be added after the\n      publication of this\
    \ document.  Readers should refer to [IKEV2IANA]\n      for the latest values.\n\
    \      Protocol                Protocol ID\n      -----------------------------------\n\
    \      IKE                     1\n      AH                      2\n      ESP \
    \                    3\n   o  SPI Size (1 octet) - For an initial IKE SA negotiation,\
    \ this field\n      MUST be zero; the SPI is obtained from the outer header. \
    \ During\n      subsequent negotiations, it is equal to the size, in octets, of\n\
    \      the SPI of the corresponding protocol (8 for IKE, 4 for ESP and\n     \
    \ AH).\n   o  Num Transforms (1 octet) - Specifies the number of transforms in\n\
    \      this proposal.\n   o  SPI (variable) - The sending entity's SPI.  Even\
    \ if the SPI Size\n      is not a multiple of 4 octets, there is no padding applied\
    \ to the\n      payload.  When the SPI Size field is zero, this field is not\n\
    \      present in the Security Association payload.\n   o  Transforms (variable)\
    \ - One or more transform substructures.\n"
- title: 3.3.2.  Transform Substructure
  contents:
  - "3.3.2.  Transform Substructure\n                        1                   2\
    \                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | 0 (last) or 3 |   RESERVED    |        Transform Length       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |Transform Type |   RESERVED    |          Transform ID         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \                    Transform Attributes                     ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \            Figure 8:  Transform Substructure\n   o  0 (last) or 3 (more) (1\
    \ octet) - Specifies whether this is the\n      last Transform Substructure in\
    \ the Proposal.  This syntax is\n      inherited from ISAKMP, but is unnecessary\
    \ because the last\n      transform could be identified from the length of the\
    \ proposal.\n      The value (3) corresponds to a payload type of Transform in\
    \ IKEv1,\n      and the first four octets of the Transform structure are designed\n\
    \      to look somewhat like the header of a payload.\n   o  RESERVED - MUST be\
    \ sent as zero; MUST be ignored on receipt.\n   o  Transform Length - The length\
    \ (in octets) of the Transform\n      Substructure including Header and Attributes.\n\
    \   o  Transform Type (1 octet) - The type of transform being specified\n    \
    \  in this transform.  Different protocols support different\n      Transform\
    \ Types.  For some protocols, some of the transforms may\n      be optional. \
    \ If a transform is optional and the initiator wishes\n      to propose that the\
    \ transform be omitted, no transform of the\n      given type is included in the\
    \ proposal.  If the initiator wishes\n      to make use of the transform optional\
    \ to the responder, it\n      includes a transform substructure with Transform\
    \ ID = 0 as one of\n      the options.\n   o  Transform ID (2 octets) - The specific\
    \ instance of the Transform\n      Type being proposed.\n   The Transform Type\
    \ values are listed below.  The values in the\n   following table are only current\
    \ as of the publication date of RFC\n   4306.  Other values may have been added\
    \ since then or will be added\n   after the publication of this document.  Readers\
    \ should refer to\n   [IKEV2IANA] for the latest values.\n   Description     \
    \                Trans.  Used In\n                                   Type\n  \
    \ ------------------------------------------------------------------\n   Encryption\
    \ Algorithm (ENCR)     1       IKE and ESP\n   Pseudorandom Function (PRF)   \
    \  2       IKE\n   Integrity Algorithm (INTEG)     3       IKE*, AH, optional\
    \ in ESP\n   Diffie-Hellman group (D-H)      4       IKE, optional in AH & ESP\n\
    \   Extended Sequence Numbers (ESN) 5       AH and ESP\n   (*) Negotiating an\
    \ integrity algorithm is mandatory for the\n   Encrypted payload format specified\
    \ in this document.  For example,\n   [AEAD] specifies additional formats based\
    \ on authenticated\n   encryption, in which a separate integrity algorithm is\
    \ not\n   negotiated.\n   For Transform Type 1 (Encryption Algorithm), the Transform\
    \ IDs are\n   listed below.  The values in the following table are only current\
    \ as\n   of the publication date of RFC 4306.  Other values may have been\n  \
    \ added since then or will be added after the publication of this\n   document.\
    \  Readers should refer to [IKEV2IANA] for the latest values.\n   Name       \
    \          Number      Defined In\n   ---------------------------------------------------\n\
    \   ENCR_DES_IV64        1           (UNSPECIFIED)\n   ENCR_DES             2\
    \           (RFC2405), [DES]\n   ENCR_3DES            3           (RFC2451)\n\
    \   ENCR_RC5             4           (RFC2451)\n   ENCR_IDEA            5    \
    \       (RFC2451), [IDEA]\n   ENCR_CAST            6           (RFC2451)\n   ENCR_BLOWFISH\
    \        7           (RFC2451)\n   ENCR_3IDEA           8           (UNSPECIFIED)\n\
    \   ENCR_DES_IV32        9           (UNSPECIFIED)\n   ENCR_NULL            11\
    \          (RFC2410)\n   ENCR_AES_CBC         12          (RFC3602)\n   ENCR_AES_CTR\
    \         13          (RFC3686)\n   For Transform Type 2 (Pseudorandom Function),\
    \ the Transform IDs are\n   listed below.  The values in the following table are\
    \ only current as\n   of the publication date of RFC 4306.  Other values may have\
    \ been\n   added since then or will be added after the publication of this\n \
    \  document.  Readers should refer to [IKEV2IANA] for the latest values.\n   Name\
    \                        Number    Defined In\n   ------------------------------------------------------\n\
    \   PRF_HMAC_MD5                1         (RFC2104), [MD5]\n   PRF_HMAC_SHA1 \
    \              2         (RFC2104), [SHA]\n   PRF_HMAC_TIGER              3  \
    \       (UNSPECIFIED)\n   For Transform Type 3 (Integrity Algorithm), defined\
    \ Transform IDs are\n   listed below.  The values in the following table are only\
    \ current as\n   of the publication date of RFC 4306.  Other values may have been\n\
    \   added since then or will be added after the publication of this\n   document.\
    \  Readers should refer to [IKEV2IANA] for the latest values.\n   Name       \
    \          Number   Defined In\n   ----------------------------------------\n\
    \   NONE                 0\n   AUTH_HMAC_MD5_96     1        (RFC2403)\n   AUTH_HMAC_SHA1_96\
    \    2        (RFC2404)\n   AUTH_DES_MAC         3        (UNSPECIFIED)\n   AUTH_KPDK_MD5\
    \        4        (UNSPECIFIED)\n   AUTH_AES_XCBC_96     5        (RFC3566)\n\
    \   For Transform Type 4 (Diffie-Hellman group), defined Transform IDs\n   are\
    \ listed below.  The values in the following table are only current\n   as of\
    \ the publication date of RFC 4306.  Other values may have been\n   added since\
    \ then or will be added after the publication of this\n   document.  Readers should\
    \ refer to [IKEV2IANA] for the latest values.\n   Name               Number  \
    \   Defined In\n   ----------------------------------------\n   NONE         \
    \      0\n   768-bit MODP       1          Appendix B\n   1024-bit MODP      2\
    \          Appendix B\n   1536-bit MODP      5          [ADDGROUP]\n   2048-bit\
    \ MODP      14         [ADDGROUP]\n   3072-bit MODP      15         [ADDGROUP]\n\
    \   4096-bit MODP      16         [ADDGROUP]\n   6144-bit MODP      17       \
    \  [ADDGROUP]\n   8192-bit MODP      18         [ADDGROUP]\n   Although ESP and\
    \ AH do not directly include a Diffie-Hellman\n   exchange, a Diffie-Hellman group\
    \ MAY be negotiated for the Child SA.\n   This allows the peers to employ Diffie-Hellman\
    \ in the CREATE_CHILD_SA\n   exchange, providing perfect forward secrecy for the\
    \ generated Child\n   SA keys.\n   For Transform Type 5 (Extended Sequence Numbers),\
    \ defined Transform\n   IDs are listed below.  The values in the following table\
    \ are only\n   current as of the publication date of RFC 4306.  Other values may\n\
    \   have been added since then or will be added after the publication of\n   this\
    \ document.  Readers should refer to [IKEV2IANA] for the latest\n   values.\n\
    \   Name                               Number\n   --------------------------------------------\n\
    \   No Extended Sequence Numbers       0\n   Extended Sequence Numbers       \
    \   1\n   Note that an initiator who supports ESNs will usually include two ESN\n\
    \   transforms, with values \"0\" and \"1\", in its proposals.  A proposal\n \
    \  containing a single ESN transform with value \"1\" means that using\n   normal\
    \ (non-extended) sequence numbers is not acceptable.\n   Numerous additional Transform\
    \ Types have been defined since the\n   publication of RFC 4306.  Please refer\
    \ to the IANA IKEv2 registry for\n   details.\n"
- title: 3.3.3.  Valid Transform Types by Protocol
  contents:
  - "3.3.3.  Valid Transform Types by Protocol\n   The number and type of transforms\
    \ that accompany an SA payload are\n   dependent on the protocol in the SA itself.\
    \  An SA payload proposing\n   the establishment of an SA has the following mandatory\
    \ and optional\n   Transform Types.  A compliant implementation MUST understand\
    \ all\n   mandatory and optional types for each protocol it supports (though it\n\
    \   need not accept proposals with unacceptable suites).  A proposal MAY\n   omit\
    \ the optional types if the only value for them it will accept is\n   NONE.\n\
    \   Protocol    Mandatory Types          Optional Types\n   ---------------------------------------------------\n\
    \   IKE         ENCR, PRF, INTEG*, D-H\n   ESP         ENCR, ESN             \
    \   INTEG, D-H\n   AH          INTEG, ESN               D-H\n   (*) Negotiating\
    \ an integrity algorithm is mandatory for the\n   Encrypted payload format specified\
    \ in this document.  For example,\n   [AEAD] specifies additional formats based\
    \ on authenticated\n   encryption, in which a separate integrity algorithm is\
    \ not\n   negotiated.\n"
- title: 3.3.4.  Mandatory Transform IDs
  contents:
  - "3.3.4.  Mandatory Transform IDs\n   The specification of suites that MUST and\
    \ SHOULD be supported for\n   interoperability has been removed from this document\
    \ because they are\n   likely to change more rapidly than this document evolves.\
    \  At the\n   time of publication of this document, [RFC4307] specifies these\n\
    \   suites, but note that it might be updated in the future, and other\n   RFCs\
    \ might specify different sets of suites.\n   An important lesson learned from\
    \ IKEv1 is that no system should only\n   implement the mandatory algorithms and\
    \ expect them to be the best\n   choice for all customers.\n   It is likely that\
    \ IANA will add additional transforms in the future,\n   and some users may want\
    \ to use private suites, especially for IKE\n   where implementations should be\
    \ capable of supporting different\n   parameters, up to certain size limits. \
    \ In support of this goal, all\n   implementations of IKEv2 SHOULD include a management\
    \ facility that\n   allows specification (by a user or system administrator) of\
    \ Diffie-\n   Hellman parameters (the generator, modulus, and exponent lengths\
    \ and\n   values) for new Diffie-Hellman groups.  Implementations SHOULD\n   provide\
    \ a management interface through which these parameters and the\n   associated\
    \ Transform IDs may be entered (by a user or system\n   administrator), to enable\
    \ negotiating such groups.\n   All implementations of IKEv2 MUST include a management\
    \ facility that\n   enables a user or system administrator to specify the suites\
    \ that are\n   acceptable for use with IKE.  Upon receipt of a payload with a\
    \ set of\n   Transform IDs, the implementation MUST compare the transmitted\n\
    \   Transform IDs against those locally configured via the management\n   controls,\
    \ to verify that the proposed suite is acceptable based on\n   local policy. \
    \ The implementation MUST reject SA proposals that are\n   not authorized by these\
    \ IKE suite controls.  Note that cryptographic\n   suites that MUST be implemented\
    \ need not be configured as acceptable\n   to local policy.\n"
- title: 3.3.5.  Transform Attributes
  contents:
  - "3.3.5.  Transform Attributes\n   Each transform in a Security Association payload\
    \ may include\n   attributes that modify or complete the specification of the\n\
    \   transform.  The set of valid attributes depends on the transform.\n   Currently,\
    \ only a single attribute type is defined: the Key Length\n   attribute is used\
    \ by certain encryption transforms with variable-\n   length keys (see below for\
    \ details).\n   The attributes are type/value pairs and are defined below.\n \
    \  Attributes can have a value with a fixed two-octet length or a\n   variable-length\
    \ value.  For the latter, the attribute is encoded as\n   type/length/value.\n\
    \                        1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |A|       Attribute Type        |    AF=0  Attribute Length     |\n   |F|\
    \                             |    AF=1  Attribute Value      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                   AF=0  Attribute Value                       |\n   |  \
    \                 AF=1  Not Transmitted                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                   Figure 9:  Data Attributes\n   o  Attribute Format (AF) (1\
    \ bit) - Indicates whether the data\n      attribute follows the Type/Length/Value\
    \ (TLV) format or a\n      shortened Type/Value (TV) format.  If the AF bit is\
    \ zero (0), then\n      the attribute uses TLV format; if the AF bit is one (1),\
    \ the TV\n      format (with two-byte value) is used.\n   o  Attribute Type (15\
    \ bits) - Unique identifier for each type of\n      attribute (see below).\n \
    \  o  Attribute Value (variable length) - Value of the attribute\n      associated\
    \ with the attribute type.  If the AF bit is a zero (0),\n      this field has\
    \ a variable length defined by the Attribute Length\n      field.  If the AF bit\
    \ is a one (1), the Attribute Value has a\n      length of 2 octets.\n   The only\
    \ currently defined attribute type (Key Length) is fixed\n   length; the variable-length\
    \ encoding specification is included only\n   for future extensions.  Attributes\
    \ described as fixed length MUST NOT\n   be encoded using the variable-length\
    \ encoding unless that length\n   exceeds two bytes.  Variable-length attributes\
    \ MUST NOT be encoded as\n   fixed-length even if their value can fit into two\
    \ octets.  Note: This\n   is a change from IKEv1, where increased flexibility\
    \ may have\n   simplified the composer of messages but certainly complicated the\n\
    \   parser.\n   The values in the following table are only current as of the\n\
    \   publication date of RFC 4306.  Other values may have been added since\n  \
    \ then or will be added after the publication of this document.\n   Readers should\
    \ refer to [IKEV2IANA] for the latest values.\n   Attribute Type         Value\
    \         Attribute Format\n   ------------------------------------------------------------\n\
    \   Key Length (in bits)   14            TV\n   Values 0-13 and 15-17 were used\
    \ in a similar context in IKEv1, and\n   should not be assigned except to matching\
    \ values.\n   The Key Length attribute specifies the key length in bits (MUST\
    \ use\n   network byte order) for certain transforms as follows:\n   o  The Key\
    \ Length attribute MUST NOT be used with transforms that use\n      a fixed-length\
    \ key.  For example, this includes ENCR_DES,\n      ENCR_IDEA, and all the Type\
    \ 2 (Pseudorandom function) and Type 3\n      (Integrity Algorithm) transforms\
    \ specified in this document.  It\n      is recommended that future Type 2 or\
    \ 3 transforms do not use this\n      attribute.\n   o  Some transforms specify\
    \ that the Key Length attribute MUST be\n      always included (omitting the attribute\
    \ is not allowed, and\n      proposals not containing it MUST be rejected).  For\
    \ example, this\n      includes ENCR_AES_CBC and ENCR_AES_CTR.\n   o  Some transforms\
    \ allow variable-length keys, but also specify a\n      default key length if\
    \ the attribute is not included.  For example,\n      these transforms include\
    \ ENCR_RC5 and ENCR_BLOWFISH.\n   Implementation note: To further interoperability\
    \ and to support\n   upgrading endpoints independently, implementers of this protocol\n\
    \   SHOULD accept values that they deem to supply greater security.  For\n   instance,\
    \ if a peer is configured to accept a variable-length cipher\n   with a key length\
    \ of X bits and is offered that cipher with a larger\n   key length, the implementation\
    \ SHOULD accept the offer if it supports\n   use of the longer key.\n   Support\
    \ for this capability allows a responder to express a concept\n   of \"at least\"\
    \ a certain level of security -- \"a key length of _at\n   least_ X bits for cipher\
    \ Y\".  However, as the attribute is always\n   returned unchanged (see the next\
    \ section), an initiator willing to\n   accept multiple key lengths has to include\
    \ multiple transforms with\n   the same Transform Type, each with a different\
    \ Key Length attribute.\n"
- title: 3.3.6.  Attribute Negotiation
  contents:
  - "3.3.6.  Attribute Negotiation\n   During Security Association negotiation initiators\
    \ present offers to\n   responders.  Responders MUST select a single complete\
    \ set of\n   parameters from the offers (or reject all offers if none are\n  \
    \ acceptable).  If there are multiple proposals, the responder MUST\n   choose\
    \ a single proposal.  If the selected proposal has multiple\n   transforms with\
    \ the same type, the responder MUST choose a single\n   one.  Any attributes of\
    \ a selected transform MUST be returned\n   unmodified.  The initiator of an exchange\
    \ MUST check that the\n   accepted offer is consistent with one of its proposals,\
    \ and if not\n   MUST terminate the exchange.\n   If the responder receives a\
    \ proposal that contains a Transform Type\n   it does not understand, or a proposal\
    \ that is missing a mandatory\n   Transform Type, it MUST consider this proposal\
    \ unacceptable; however,\n   other proposals in the same SA payload are processed\
    \ as usual.\n   Similarly, if the responder receives a transform that it does\
    \ not\n   understand, or one that contains a Transform Attribute it does not\n\
    \   understand, it MUST consider this transform unacceptable; other\n   transforms\
    \ with the same Transform Type are processed as usual.  This\n   allows new Transform\
    \ Types and Transform Attributes to be defined in\n   the future.\n   Negotiating\
    \ Diffie-Hellman groups presents some special challenges.\n   SA offers include\
    \ proposed attributes and a Diffie-Hellman public\n   number (KE) in the same\
    \ message.  If in the initial exchange the\n   initiator offers to use one of\
    \ several Diffie-Hellman groups, it\n   SHOULD pick the one the responder is most\
    \ likely to accept and\n   include a KE corresponding to that group.  If the responder\
    \ selects a\n   proposal using a different Diffie-Hellman group (other than NONE),\n\
    \   the responder will indicate the correct group in the response and the\n  \
    \ initiator SHOULD pick an element of that group for its KE value when\n   retrying\
    \ the first message.  It SHOULD, however, continue to propose\n   its full supported\
    \ set of groups in order to prevent a man-in-the-\n   middle downgrade attack.\
    \  If one of the proposals offered is for the\n   Diffie-Hellman group of NONE,\
    \ and the responder selects that Diffie-\n   Hellman group, then it MUST ignore\
    \ the initiator's KE payload and\n   omit the KE payload from the response.\n"
- title: 3.4.  Key Exchange Payload
  contents:
  - "3.4.  Key Exchange Payload\n   The Key Exchange payload, denoted KE in this document,\
    \ is used to\n   exchange Diffie-Hellman public numbers as part of a Diffie-Hellman\n\
    \   key exchange.  The Key Exchange payload consists of the IKE generic\n   payload\
    \ header followed by the Diffie-Hellman public value itself.\n               \
    \         1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Next Payload  |C|  RESERVED   |         Payload Length        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   Diffie-Hellman Group Num    |           RESERVED            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \                     Key Exchange Data                       ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \             Figure 10:  Key Exchange Payload Format\n   A Key Exchange payload\
    \ is constructed by copying one's Diffie-Hellman\n   public value into the \"\
    Key Exchange Data\" portion of the payload.\n   The length of the Diffie-Hellman\
    \ public value for modular\n   exponentiation group (MODP) groups MUST be equal\
    \ to the length of the\n   prime modulus over which the exponentiation was performed,\
    \ prepending\n   zero bits to the value if necessary.\n   The Diffie-Hellman Group\
    \ Num identifies the Diffie-Hellman group in\n   which the Key Exchange Data was\
    \ computed (see Section 3.3.2).  This\n   Diffie-Hellman Group Num MUST match\
    \ a Diffie-Hellman group specified\n   in a proposal in the SA payload that is\
    \ sent in the same message, and\n   SHOULD match the Diffie-Hellman group in the\
    \ first group in the first\n   proposal, if such exists.  If none of the proposals\
    \ in that SA\n   payload specifies a Diffie-Hellman group, the KE payload MUST\
    \ NOT be\n   present.  If the selected proposal uses a different Diffie-Hellman\n\
    \   group (other than NONE), the message MUST be rejected with a Notify\n   payload\
    \ of type INVALID_KE_PAYLOAD.  See also Sections 1.2 and 2.7.\n   The payload\
    \ type for the Key Exchange payload is thirty-four (34).\n"
- title: 3.5.  Identification Payloads
  contents:
  - "3.5.  Identification Payloads\n   The Identification payloads, denoted IDi and\
    \ IDr in this document,\n   allow peers to assert an identity to one another.\
    \  This identity may\n   be used for policy lookup, but does not necessarily have\
    \ to match\n   anything in the CERT payload; both fields may be used by an\n \
    \  implementation to perform access control decisions.  When using the\n   ID_IPV4_ADDR/ID_IPV6_ADDR\
    \ identity types in IDi/IDr payloads, IKEv2\n   does not require this address\
    \ to match the address in the IP header\n   of IKEv2 packets, or anything in the\
    \ TSi/TSr payloads.  The contents\n   of IDi/IDr are used purely to fetch the\
    \ policy and authentication\n   data related to the other party.\n   NOTE: In\
    \ IKEv1, two ID payloads were used in each direction to hold\n   Traffic Selector\
    \ (TS) information for data passing over the SA.  In\n   IKEv2, this information\
    \ is carried in TS payloads (see Section 3.13).\n   The Peer Authorization Database\
    \ (PAD) as described in RFC 4301\n   [IPSECARCH] describes the use of the ID payload\
    \ in IKEv2 and provides\n   a formal model for the binding of identity to policy\
    \ in addition to\n   providing services that deal more specifically with the details\
    \ of\n   policy enforcement.  The PAD is intended to provide a link between\n\
    \   the SPD and the IKE Security Association management.  See Section\n   4.4.3\
    \ of RFC 4301 for more details.\n   The Identification payload consists of the\
    \ IKE generic payload header\n   followed by identification fields as follows:\n\
    \                        1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Next Payload  |C|  RESERVED   |         Payload Length        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   ID Type     |                 RESERVED                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \                 Identification Data                         ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \            Figure 11:  Identification Payload Format\n   o  ID Type (1 octet)\
    \ - Specifies the type of Identification being\n      used.\n   o  RESERVED -\
    \ MUST be sent as zero; MUST be ignored on receipt.\n   o  Identification Data\
    \ (variable length) - Value, as indicated by the\n      Identification Type. \
    \ The length of the Identification Data is\n      computed from the size in the\
    \ ID payload header.\n   The payload types for the Identification payload are\
    \ thirty-five (35)\n   for IDi and thirty-six (36) for IDr.\n   The following\
    \ table lists the assigned semantics for the\n   Identification Type field.  The\
    \ values in the following table are\n   only current as of the publication date\
    \ of RFC 4306.  Other values\n   may have been added since then or will be added\
    \ after the publication\n   of this document.  Readers should refer to [IKEV2IANA]\
    \ for the latest\n   values.\n   ID Type                           Value\n   -------------------------------------------------------------------\n\
    \   ID_IPV4_ADDR                        1\n      A single four (4) octet IPv4\
    \ address.\n   ID_FQDN                             2\n      A fully-qualified\
    \ domain name string.  An example of an ID_FQDN\n      is \"example.com\".  The\
    \ string MUST NOT contain any terminators\n      (e.g., NULL, CR, etc.). All characters\
    \ in the ID_FQDN are ASCII;\n      for an \"internationalized domain name\", the\
    \ syntax is as defined\n      in [IDNA], for example \"xn--tmonesimerkki-bfbb.example.net\"\
    .\n   ID_RFC822_ADDR                      3\n      A fully-qualified RFC 822 email\
    \ address string.  An example of a\n      ID_RFC822_ADDR is \"jsmith@example.com\"\
    .  The string MUST NOT\n      contain any terminators.  Because of [EAI], implementations\
    \ would\n      be wise to treat this field as UTF-8 encoded text, not as\n   \
    \   pure ASCII.\n   ID_IPV6_ADDR                        5\n      A single sixteen\
    \ (16) octet IPv6 address.\n   ID_DER_ASN1_DN                      9\n      The\
    \ binary Distinguished Encoding Rules (DER) encoding of an\n      ASN.1 X.500\
    \ Distinguished Name [PKIX].\n   ID_DER_ASN1_GN                      10\n    \
    \  The binary DER encoding of an ASN.1 X.509 GeneralName [PKIX].\n   ID_KEY_ID\
    \                           11\n      An opaque octet stream that may be used\
    \ to pass vendor-\n      specific information necessary to do certain proprietary\n\
    \      types of identification.\n   Two implementations will interoperate only\
    \ if each can generate a\n   type of ID acceptable to the other.  To assure maximum\n\
    \   interoperability, implementations MUST be configurable to send at\n   least\
    \ one of ID_IPV4_ADDR, ID_FQDN, ID_RFC822_ADDR, or ID_KEY_ID, and\n   MUST be\
    \ configurable to accept all of these four types.\n   Implementations SHOULD be\
    \ capable of generating and accepting all of\n   these types.  IPv6-capable implementations\
    \ MUST additionally be\n   configurable to accept ID_IPV6_ADDR.  IPv6-only implementations\
    \ MAY\n   be configurable to send only ID_IPV6_ADDR instead of ID_IPV4_ADDR for\n\
    \   IP addresses.\n   EAP [EAP] does not mandate the use of any particular type\
    \ of\n   identifier, but often EAP is used with Network Access Identifiers\n \
    \  (NAIs) defined in [NAI].  Although NAIs look a bit like email\n   addresses\
    \ (e.g., \"joe@example.com\"), the syntax is not exactly the\n   same as the syntax\
    \ of email address in [MAILFORMAT].  For those NAIs\n   that include the realm\
    \ component, the ID_RFC822_ADDR identification\n   type SHOULD be used.  Responder\
    \ implementations should not attempt to\n   verify that the contents actually\
    \ conform to the exact syntax given\n   in [MAILFORMAT], but instead should accept\
    \ any reasonable-looking\n   NAI.  For NAIs that do not include the realm component,\
    \ the ID_KEY_ID\n   identification type SHOULD be used.\n"
- title: 3.6.  Certificate Payload
  contents:
  - "3.6.  Certificate Payload\n   The Certificate payload, denoted CERT in this document,\
    \ provides a\n   means to transport certificates or other authentication-related\n\
    \   information via IKE.  Certificate payloads SHOULD be included in an\n   exchange\
    \ if certificates are available to the sender.  The Hash and\n   URL formats of\
    \ the Certificate payloads should be used in case the\n   peer has indicated an\
    \ ability to retrieve this information from\n   elsewhere using an HTTP_CERT_LOOKUP_SUPPORTED\
    \ Notify payload.  Note\n   that the term \"Certificate payload\" is somewhat\
    \ misleading, because\n   not all authentication mechanisms use certificates and\
    \ data other\n   than certificates may be passed in this payload.\n   The Certificate\
    \ payload is defined as follows:\n                        1                  \
    \ 2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Next Payload  |C|  RESERVED   |         Payload Length        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Cert Encoding |                                               |\n   +-+-+-+-+-+-+-+-+\
    \                                               |\n   ~                      \
    \ Certificate Data                        ~\n   |                            \
    \                                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \             Figure 12:  Certificate Payload Format\n   o  Certificate Encoding\
    \ (1 octet) - This field indicates the type of\n      certificate or certificate-related\
    \ information contained in the\n      Certificate Data field.  The values in the\
    \ following table are\n      only current as of the publication date of RFC 4306.\
    \  Other values\n      may have been added since then or will be added after the\n\
    \      publication of this document.  Readers should refer to [IKEV2IANA]\n  \
    \    for the latest values.\n      Certificate Encoding                 Value\n\
    \      ----------------------------------------------------\n      PKCS #7 wrapped\
    \ X.509 certificate    1   UNSPECIFIED\n      PGP Certificate                \
    \      2   UNSPECIFIED\n      DNS Signed Key                       3   UNSPECIFIED\n\
    \      X.509 Certificate - Signature        4\n      Kerberos Token          \
    \             6   UNSPECIFIED\n      Certificate Revocation List (CRL)    7\n\
    \      Authority Revocation List (ARL)      8   UNSPECIFIED\n      SPKI Certificate\
    \                     9   UNSPECIFIED\n      X.509 Certificate - Attribute   \
    \     10  UNSPECIFIED\n      Raw RSA Key                          11\n      Hash\
    \ and URL of X.509 certificate    12\n      Hash and URL of X.509 bundle     \
    \    13\n   o  Certificate Data (variable length) - Actual encoding of\n     \
    \ certificate data.  The type of certificate is indicated by the\n      Certificate\
    \ Encoding field.\n   The payload type for the Certificate payload is thirty-seven\
    \ (37).\n   Specific syntax for some of the certificate type codes above is not\n\
    \   defined in this document.  The types whose syntax is defined in this\n   document\
    \ are:\n   o  \"X.509 Certificate - Signature\" contains a DER-encoded X.509\n\
    \      certificate whose public key is used to validate the sender's AUTH\n  \
    \    payload.  Note that with this encoding, if a chain of certificates\n    \
    \  needs to be sent, multiple CERT payloads are used, only the first\n      of\
    \ which holds the public key used to validate the sender's AUTH\n      payload.\n\
    \   o  \"Certificate Revocation List\" contains a DER-encoded X.509\n      certificate\
    \ revocation list.\n   o  \"Raw RSA Key\" contains a PKCS #1 encoded RSA key,\
    \ that is, a DER-\n      encoded RSAPublicKey structure (see [RSA] and [PKCS1]).\n\
    \   o  Hash and URL encodings allow IKE messages to remain short by\n      replacing\
    \ long data structures with a 20-octet SHA-1 hash (see\n      [SHA]) of the replaced\
    \ value followed by a variable-length URL\n      that resolves to the DER-encoded\
    \ data structure itself.  This\n      improves efficiency when the endpoints have\
    \ certificate data\n      cached and makes IKE less subject to DoS attacks that\
    \ become\n      easier to mount when IKE messages are large enough to require\
    \ IP\n      fragmentation [DOSUDPPROT].\n   The \"Hash and URL of a bundle\" type\
    \ uses the following ASN.1\n   definition for the X.509 bundle:\n   CertBundle\n\
    \     { iso(1) identified-organization(3) dod(6) internet(1)\n       security(5)\
    \ mechanisms(5) pkix(7) id-mod(0)\n       id-mod-cert-bundle(34) }\n   DEFINITIONS\
    \ EXPLICIT TAGS ::=\n   BEGIN\n   IMPORTS\n     Certificate, CertificateList\n\
    \     FROM PKIX1Explicit88\n        { iso(1) identified-organization(3) dod(6)\n\
    \          internet(1) security(5) mechanisms(5) pkix(7)\n          id-mod(0)\
    \ id-pkix1-explicit(18) } ;\n   CertificateOrCRL ::= CHOICE {\n     cert [0] Certificate,\n\
    \     crl  [1] CertificateList }\n   CertificateBundle ::= SEQUENCE OF CertificateOrCRL\n\
    \   END\n   Implementations MUST be capable of being configured to send and\n\
    \   accept up to four X.509 certificates in support of authentication,\n   and\
    \ also MUST be capable of being configured to send and accept the\n   Hash and\
    \ URL format (with HTTP URLs).  Implementations SHOULD be\n   capable of being\
    \ configured to send and accept Raw RSA keys.  If\n   multiple certificates are\
    \ sent, the first certificate MUST contain\n   the public key used to sign the\
    \ AUTH payload.  The other certificates\n   may be sent in any order.\n   Implementations\
    \ MUST support the HTTP [HTTP] method for hash-and-URL\n   lookup.  The behavior\
    \ of other URL methods [URLS] is not currently\n   specified, and such methods\
    \ SHOULD NOT be used in the absence of a\n   document specifying them.\n"
- title: 3.7.  Certificate Request Payload
  contents:
  - "3.7.  Certificate Request Payload\n   The Certificate Request payload, denoted\
    \ CERTREQ in this document,\n   provides a means to request preferred certificates\
    \ via IKE and can\n   appear in the IKE_INIT_SA response and/or the IKE_AUTH request.\n\
    \   Certificate Request payloads MAY be included in an exchange when the\n   sender\
    \ needs to get the certificate of the receiver.\n   The Certificate Request payload\
    \ is defined as follows:\n                        1                   2      \
    \             3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Next Payload  |C|  RESERVED   |         Payload Length        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Cert Encoding |                                               |\n   +-+-+-+-+-+-+-+-+\
    \                                               |\n   ~                    Certification\
    \ Authority                    ~\n   |                                       \
    \                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \         Figure 13:  Certificate Request Payload Format\n   o  Certificate Encoding\
    \ (1 octet) - Contains an encoding of the type\n      or format of certificate\
    \ requested.  Values are listed in\n      Section 3.6.\n   o  Certification Authority\
    \ (variable length) - Contains an encoding\n      of an acceptable certification\
    \ authority for the type of\n      certificate requested.\n   The payload type\
    \ for the Certificate Request payload is thirty-eight\n   (38).\n   The Certificate\
    \ Encoding field has the same values as those defined\n   in Section 3.6.  The\
    \ Certification Authority field contains an\n   indicator of trusted authorities\
    \ for this certificate type.  The\n   Certification Authority value is a concatenated\
    \ list of SHA-1 hashes\n   of the public keys of trusted Certification Authorities\
    \ (CAs).  Each\n   is encoded as the SHA-1 hash of the Subject Public Key Info\
    \ element\n   (see section 4.1.2.7 of [PKIX]) from each Trust Anchor certificate.\n\
    \   The 20-octet hashes are concatenated and included with no other\n   formatting.\n\
    \   The contents of the \"Certification Authority\" field are defined only\n \
    \  for X.509 certificates, which are types 4, 12, and 13.  Other values\n   SHOULD\
    \ NOT be used until Standards-Track specifications that specify\n   their use\
    \ are published.\n   Note that the term \"Certificate Request\" is somewhat misleading,\
    \ in\n   that values other than certificates are defined in a \"Certificate\"\n\
    \   payload and requests for those values can be present in a Certificate\n  \
    \ Request payload.  The syntax of the Certificate Request payload in\n   such\
    \ cases is not defined in this document.\n   The Certificate Request payload is\
    \ processed by inspecting the \"Cert\n   Encoding\" field to determine whether\
    \ the processor has any\n   certificates of this type.  If so, the \"Certification\
    \ Authority\"\n   field is inspected to determine if the processor has any certificates\n\
    \   that can be validated up to one of the specified certification\n   authorities.\
    \  This can be a chain of certificates.\n   If an end-entity certificate exists\
    \ that satisfies the criteria\n   specified in the CERTREQ, a certificate or certificate\
    \ chain SHOULD\n   be sent back to the certificate requestor if the recipient\
    \ of the\n   CERTREQ:\n   o  is configured to use certificate authentication,\n\
    \   o  is allowed to send a CERT payload,\n   o  has matching CA trust policy\
    \ governing the current negotiation,\n      and\n   o  has at least one time-wise\
    \ and usage-appropriate end-entity\n      certificate chaining to a CA provided\
    \ in the CERTREQ.\n   Certificate revocation checking must be considered during\
    \ the\n   chaining process used to select a certificate.  Note that even if two\n\
    \   peers are configured to use two different CAs, cross-certification\n   relationships\
    \ should be supported by appropriate selection logic.\n   The intent is not to\
    \ prevent communication through the strict\n   adherence of selection of a certificate\
    \ based on CERTREQ, when an\n   alternate certificate could be selected by the\
    \ sender that would\n   still enable the recipient to successfully validate and\
    \ trust it\n   through trust conveyed by cross-certification, CRLs, or other out-of-\n\
    \   band configured means.  Thus, the processing of a CERTREQ should be\n   seen\
    \ as a suggestion for a certificate to select, not a mandated one.\n   If no certificates\
    \ exist, then the CERTREQ is ignored.  This is not\n   an error condition of the\
    \ protocol.  There may be cases where there\n   is a preferred CA sent in the\
    \ CERTREQ, but an alternate might be\n   acceptable (perhaps after prompting a\
    \ human operator).\n   The HTTP_CERT_LOOKUP_SUPPORTED notification MAY be included\
    \ in any\n   message that can include a CERTREQ payload and indicates that the\n\
    \   sender is capable of looking up certificates based on an HTTP-based\n   URL\
    \ (and hence presumably would prefer to receive certificate\n   specifications\
    \ in that format).\n"
- title: 3.8.  Authentication Payload
  contents:
  - "3.8.  Authentication Payload\n   The Authentication payload, denoted AUTH in\
    \ this document, contains\n   data used for authentication purposes.  The syntax\
    \ of the\n   Authentication data varies according to the Auth Method as specified\n\
    \   below.\n   The Authentication payload is defined as follows:\n           \
    \             1                   2                   3\n    0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Next Payload  |C|  RESERVED   |         Payload Length        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Auth Method   |                RESERVED                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \                    Authentication Data                      ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \              Figure 14:  Authentication Payload Format\n   o  Auth Method (1\
    \ octet) - Specifies the method of authentication\n      used.  The types of signatures\
    \ are listed here.  The values in the\n      following table are only current\
    \ as of the publication date of RFC\n      4306.  Other values may have been added\
    \ since then or will be\n      added after the publication of this document. \
    \ Readers should\n      refer to [IKEV2IANA] for the latest values.\n   Mechanism\
    \                              Value\n   -----------------------------------------------------------------\n\
    \   RSA Digital Signature                  1\n      Computed as specified in Section\
    \ 2.15 using an RSA private key\n      with RSASSA-PKCS1-v1_5 signature scheme\
    \ specified in [PKCS1]\n      (implementers should note that IKEv1 used a different\
    \ method for\n      RSA signatures).  To promote interoperability, implementations\n\
    \      that support this type SHOULD support signatures that use SHA-1\n     \
    \ as the hash function and SHOULD use SHA-1 as the default hash\n      function\
    \ when generating signatures.  Implementations can use the\n      certificates\
    \ received from a given peer as a hint for selecting a\n      mutually understood\
    \ hash function for the AUTH payload signature.\n      Note, however, that the\
    \ hash algorithm used in the AUTH payload\n      signature doesn't have to be\
    \ the same as any hash algorithm(s)\n      used in the certificate(s).\n   Shared\
    \ Key Message Integrity Code      2\n      Computed as specified in Section 2.15\
    \ using the shared key\n      associated with the identity in the ID payload and\
    \ the negotiated\n      PRF.\n   DSS Digital Signature                  3\n  \
    \    Computed as specified in Section 2.15 using a DSS private key\n      (see\
    \ [DSS]) over a SHA-1 hash.\n   o  Authentication Data (variable length) - see\
    \ Section 2.15.\n   The payload type for the Authentication payload is thirty-nine\
    \ (39).\n"
- title: 3.9.  Nonce Payload
  contents:
  - "3.9.  Nonce Payload\n   The Nonce payload, denoted as Ni and Nr in this document\
    \ for the\n   initiator's and responder's nonce, respectively, contains random\
    \ data\n   used to guarantee liveness during an exchange and protect against\n\
    \   replay attacks.\n   The Nonce payload is defined as follows:\n           \
    \             1                   2                   3\n    0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Next Payload  |C|  RESERVED   |         Payload Length        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \                          Nonce Data                         ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                Figure 15:  Nonce Payload Format\n   o  Nonce Data (variable\
    \ length) - Contains the random data generated\n      by the transmitting entity.\n\
    \   The payload type for the Nonce payload is forty (40).\n   The size of the\
    \ Nonce Data MUST be between 16 and 256 octets,\n   inclusive.  Nonce values MUST\
    \ NOT be reused.\n"
- title: 3.10.  Notify Payload
  contents:
  - "3.10.  Notify Payload\n   The Notify payload, denoted N in this document, is\
    \ used to transmit\n   informational data, such as error conditions and state\
    \ transitions,\n   to an IKE peer.  A Notify payload may appear in a response\
    \ message\n   (usually specifying why a request was rejected), in an INFORMATIONAL\n\
    \   Exchange (to report an error not in an IKE request), or in any other\n   message\
    \ to indicate sender capabilities or to modify the meaning of\n   the request.\n\
    \   The Notify payload is defined as follows:\n                        1     \
    \              2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Next Payload  |C|  RESERVED   |         Payload Length        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Protocol ID  |   SPI Size    |      Notify Message Type      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \              Security Parameter Index (SPI)                 ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \                     Notification Data                       ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \            Figure 16:  Notify Payload Format\n   o  Protocol ID (1 octet) -\
    \ If this notification concerns an existing\n      SA whose SPI is given in the\
    \ SPI field, this field indicates the\n      type of that SA.  For notifications\
    \ concerning Child SAs, this\n      field MUST contain either (2) to indicate\
    \ AH or (3) to indicate\n      ESP.  Of the notifications defined in this document,\
    \ the SPI is\n      included only with INVALID_SELECTORS and REKEY_SA.  If the\
    \ SPI\n      field is empty, this field MUST be sent as zero and MUST be\n   \
    \   ignored on receipt.\n   o  SPI Size (1 octet) - Length in octets of the SPI\
    \ as defined by the\n      IPsec protocol ID or zero if no SPI is applicable.\
    \  For a\n      notification concerning the IKE SA, the SPI Size MUST be zero\
    \ and\n      the field must be empty.\n   o  Notify Message Type (2 octets) -\
    \ Specifies the type of\n      notification message.\n   o  SPI (variable length)\
    \ - Security Parameter Index.\n   o  Notification Data (variable length) - Status\
    \ or error data\n      transmitted in addition to the Notify Message Type.  Values\
    \ for\n      this field are type specific (see below).\n   The payload type for\
    \ the Notify payload is forty-one (41).\n"
- title: 3.10.1.  Notify Message Types
  contents:
  - "3.10.1.  Notify Message Types\n   Notification information can be error messages\
    \ specifying why an SA\n   could not be established.  It can also be status data\
    \ that a process\n   managing an SA database wishes to communicate with a peer\
    \ process.\n   The table below lists the Notification messages and their\n   corresponding\
    \ values.  The number of different error statuses was\n   greatly reduced from\
    \ IKEv1 both for simplification and to avoid\n   giving configuration information\
    \ to probers.\n   Types in the range 0 - 16383 are intended for reporting errors.\
    \  An\n   implementation receiving a Notify payload with one of these types\n\
    \   that it does not recognize in a response MUST assume that the\n   corresponding\
    \ request has failed entirely.  Unrecognized error types\n   in a request and\
    \ status types in a request or response MUST be\n   ignored, and they should be\
    \ logged.\n   Notify payloads with status types MAY be added to any message and\n\
    \   MUST be ignored if not recognized.  They are intended to indicate\n   capabilities,\
    \ and as part of SA negotiation, are used to negotiate\n   non-cryptographic parameters.\n\
    \   More information on error handling can be found in Section 2.21.\n   The values\
    \ in the following table are only current as of the\n   publication date of RFC\
    \ 4306, plus two error types added in this\n   document.  Other values may have\
    \ been added since then or will be\n   added after the publication of this document.\
    \  Readers should refer\n   to [IKEV2IANA] for the latest values.\n  NOTIFY messages:\
    \ error types              Value\n  -------------------------------------------------------------------\n\
    \  UNSUPPORTED_CRITICAL_PAYLOAD              1\n      See Section 2.5.\n  INVALID_IKE_SPI\
    \                           4\n      See Section 2.21.\n  INVALID_MAJOR_VERSION\
    \                     5\n      See Section 2.5.\n  INVALID_SYNTAX            \
    \                7\n      Indicates the IKE message that was received was invalid\
    \ because\n      some type, length, or value was out of range or because the\n\
    \      request was rejected for policy reasons.  To avoid a DoS\n      attack\
    \ using forged messages, this status may only be\n      returned for and in an\
    \ encrypted packet if the Message ID and\n      cryptographic checksum were valid.\
    \  To avoid leaking information\n      to someone probing a node, this status\
    \ MUST be sent in response\n      to any error not covered by one of the other\
    \ status types.\n      To aid debugging, more detailed error information should\
    \ be\n      written to a console or log.\n  INVALID_MESSAGE_ID               \
    \         9\n      See Section 2.3.\n  INVALID_SPI                           \
    \   11\n      See Section 1.5.\n  NO_PROPOSAL_CHOSEN                       14\n\
    \      None of the proposed crypto suites was acceptable.  This can be\n     \
    \ sent in any case where the offered proposals (including but not\n      limited\
    \ to SA payload values, USE_TRANSPORT_MODE notify,\n      IPCOMP_SUPPORTED notify)\
    \ are not acceptable for the responder.\n      This can also be used as \"generic\"\
    \ Child SA error when Child SA\n      cannot be created for some other reason.\
    \  See also Section 2.7.\n  INVALID_KE_PAYLOAD                       17\n    \
    \  See Sections 1.2 and 1.3.\n  AUTHENTICATION_FAILED                    24\n\
    \      Sent in the response to an IKE_AUTH message when, for some reason,\n  \
    \    the authentication failed.  There is no associated data.  See also\n    \
    \  Section 2.21.2.\n  SINGLE_PAIR_REQUIRED                     34\n      See Section\
    \ 2.9.\n  NO_ADDITIONAL_SAS                        35\n      See Section 1.3.\n\
    \  INTERNAL_ADDRESS_FAILURE                 36\n      See Section 3.15.4.\n  FAILED_CP_REQUIRED\
    \                       37\n      See Section 2.19.\n  TS_UNACCEPTABLE       \
    \                   38\n      See Section 2.9.\n  INVALID_SELECTORS          \
    \              39\n      MAY be sent in an IKE INFORMATIONAL exchange when a node\
    \ receives\n      an ESP or AH packet whose selectors do not match those of the\
    \ SA\n      on which it was delivered (and that caused the packet to be\n    \
    \  dropped).  The Notification Data contains the start of the\n      offending\
    \ packet (as in ICMP messages) and the SPI field of the\n      notification is\
    \ set to match the SPI of the Child SA.\n  TEMPORARY_FAILURE                 \
    \       43\n      See section 2.25.\n  CHILD_SA_NOT_FOUND                    \
    \   44\n      See section 2.25.\n   NOTIFY messages: status types            Value\n\
    \   -------------------------------------------------------------------\n   INITIAL_CONTACT\
    \                          16384\n       See Section 2.4.\n   SET_WINDOW_SIZE\
    \                          16385\n       See Section 2.3.\n   ADDITIONAL_TS_POSSIBLE\
    \                   16386\n       See Section 2.9.\n   IPCOMP_SUPPORTED      \
    \                   16387\n       See Section 2.22.\n   NAT_DETECTION_SOURCE_IP\
    \                  16388\n       See Section 2.23.\n   NAT_DETECTION_DESTINATION_IP\
    \             16389\n       See Section 2.23.\n   COOKIE                     \
    \              16390\n       See Section 2.6.\n   USE_TRANSPORT_MODE         \
    \              16391\n       See Section 1.3.1.\n   HTTP_CERT_LOOKUP_SUPPORTED\
    \               16392\n       See Section 3.6.\n   REKEY_SA                  \
    \               16393\n       See Section 1.3.3.\n   ESP_TFC_PADDING_NOT_SUPPORTED\
    \            16394\n       See Section 1.3.1.\n   NON_FIRST_FRAGMENTS_ALSO   \
    \              16395\n       See Section 1.3.1.\n"
- title: 3.11.  Delete Payload
  contents:
  - "3.11.  Delete Payload\n   The Delete payload, denoted D in this document, contains\
    \ a protocol-\n   specific Security Association identifier that the sender has\
    \ removed\n   from its Security Association database and is, therefore, no longer\n\
    \   valid.  Figure 17 shows the format of the Delete payload.  It is\n   possible\
    \ to send multiple SPIs in a Delete payload; however, each SPI\n   MUST be for\
    \ the same protocol.  Mixing of protocol identifiers MUST\n   NOT be performed\
    \ in the Delete payload.  It is permitted, however, to\n   include multiple Delete\
    \ payloads in a single INFORMATIONAL exchange\n   where each Delete payload lists\
    \ SPIs for a different protocol.\n   Deletion of the IKE SA is indicated by a\
    \ protocol ID of 1 (IKE) but\n   no SPIs.  Deletion of a Child SA, such as ESP\
    \ or AH, will contain the\n   IPsec protocol ID of that protocol (2 for AH, 3\
    \ for ESP), and the SPI\n   is the SPI the sending endpoint would expect in inbound\
    \ ESP or AH\n   packets.\n   The Delete payload is defined as follows:\n     \
    \                   1                   2                   3\n    0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Next Payload  |C|  RESERVED   |         Payload Length        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Protocol ID   |   SPI Size    |          Num of SPIs          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \             Security Parameter Index(es) (SPI)              ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \               Figure 17:  Delete Payload Format\n   o  Protocol ID (1 octet)\
    \ - Must be 1 for an IKE SA, 2 for AH, or 3\n      for ESP.\n   o  SPI Size (1\
    \ octet) - Length in octets of the SPI as defined by the\n      protocol ID. \
    \ It MUST be zero for IKE (SPI is in message header)\n      or four for AH and\
    \ ESP.\n   o  Num of SPIs (2 octets, unsigned integer) - The number of SPIs\n\
    \      contained in the Delete payload.  The size of each SPI is defined\n   \
    \   by the SPI Size field.\n   o  Security Parameter Index(es) (variable length)\
    \ - Identifies the\n      specific Security Association(s) to delete.  The length\
    \ of this\n      field is determined by the SPI Size and Num of SPIs fields.\n\
    \   The payload type for the Delete payload is forty-two (42).\n"
- title: 3.12.  Vendor ID Payload
  contents:
  - "3.12.  Vendor ID Payload\n   The Vendor ID payload, denoted V in this document,\
    \ contains a vendor-\n   defined constant.  The constant is used by vendors to\
    \ identify and\n   recognize remote instances of their implementations.  This\
    \ mechanism\n   allows a vendor to experiment with new features while maintaining\n\
    \   backward compatibility.\n   A Vendor ID payload MAY announce that the sender\
    \ is capable of\n   accepting certain extensions to the protocol, or it MAY simply\n\
    \   identify the implementation as an aid in debugging.  A Vendor ID\n   payload\
    \ MUST NOT change the interpretation of any information defined\n   in this specification\
    \ (i.e., the critical bit MUST be set to 0).\n   Multiple Vendor ID payloads MAY\
    \ be sent.  An implementation is not\n   required to send any Vendor ID payload\
    \ at all.\n   A Vendor ID payload may be sent as part of any message.  Reception\
    \ of\n   a familiar Vendor ID payload allows an implementation to make use of\n\
    \   private use numbers described throughout this document, such as\n   private\
    \ payloads, private exchanges, private notifications, etc.\n   Unfamiliar Vendor\
    \ IDs MUST be ignored.\n   Writers of documents who wish to extend this protocol\
    \ MUST define a\n   Vendor ID payload to announce the ability to implement the\
    \ extension\n   in the document.  It is expected that documents that gain acceptance\n\
    \   and are standardized will be given \"magic numbers\" out of the Future\n \
    \  Use range by IANA, and the requirement to use a Vendor ID will go\n   away.\n\
    \   The Vendor ID payload fields are defined as follows:\n                   \
    \     1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Next Payload  |C|  RESERVED   |         Payload Length        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \                      Vendor ID (VID)                        ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \              Figure 18:  Vendor ID Payload Format\n   o  Vendor ID (variable\
    \ length) - It is the responsibility of the\n      person choosing the Vendor\
    \ ID to assure its uniqueness in spite of\n      the absence of any central registry\
    \ for IDs.  Good practice is to\n      include a company name, a person name,\
    \ or some such information.\n      If you want to show off, you might include\
    \ the latitude and\n      longitude and time where you were when you chose the\
    \ ID and some\n      random input.  A message digest of a long unique string is\n\
    \      preferable to the long unique string itself.\n   The payload type for the\
    \ Vendor ID payload is forty-three (43).\n"
- title: 3.13.  Traffic Selector Payload
  contents:
  - "3.13.  Traffic Selector Payload\n   The Traffic Selector payload, denoted TS\
    \ in this document, allows\n   peers to identify packet flows for processing by\
    \ IPsec security\n   services.  The Traffic Selector payload consists of the IKE\
    \ generic\n   payload header followed by individual Traffic Selectors as follows:\n\
    \                        1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Next Payload  |C|  RESERVED   |         Payload Length        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Number of TSs |                 RESERVED                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \                     <Traffic Selectors>                     ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \            Figure 19:  Traffic Selectors Payload Format\n   o  Number of TSs\
    \ (1 octet) - Number of Traffic Selectors being\n      provided.\n   o  RESERVED\
    \ - This field MUST be sent as zero and MUST be ignored on\n      receipt.\n \
    \  o  Traffic Selectors (variable length) - One or more individual\n      Traffic\
    \ Selectors.\n   The length of the Traffic Selector payload includes the TS header\
    \ and\n   all the Traffic Selectors.\n   The payload type for the Traffic Selector\
    \ payload is forty-four (44)\n   for addresses at the initiator's end of the SA\
    \ and forty-five (45)\n   for addresses at the responder's end.\n   There is no\
    \ requirement that TSi and TSr contain the same number of\n   individual Traffic\
    \ Selectors.  Thus, they are interpreted as follows:\n   a packet matches a given\
    \ TSi/TSr if it matches at least one of the\n   individual selectors in TSi, and\
    \ at least one of the individual\n   selectors in TSr.\n   For instance, the following\
    \ Traffic Selectors:\n   TSi = ((17, 100, 198.51.100.66-198.51.100.66),\n    \
    \      (17, 200, 198.51.100.66-198.51.100.66))\n   TSr = ((17, 300, 0.0.0.0-255.255.255.255),\n\
    \          (17, 400, 0.0.0.0-255.255.255.255))\n   would match UDP packets from\
    \ 198.51.100.66 to anywhere, with any of\n   the four combinations of source/destination\
    \ ports (100,300),\n   (100,400), (200,300), and (200, 400).\n   Thus, some types\
    \ of policies may require several Child SA pairs.  For\n   instance, a policy\
    \ matching only source/destination ports (100,300)\n   and (200,400), but not\
    \ the other two combinations, cannot be\n   negotiated as a single Child SA pair.\n"
- title: 3.13.1.  Traffic Selector
  contents:
  - "3.13.1.  Traffic Selector\n                        1                   2    \
    \               3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   TS Type     |IP Protocol ID*|       Selector Length         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           Start Port*         |           End Port*           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \                       Starting Address*                     ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \                       Ending Address*                       ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \               Figure 20: Traffic Selector\n   *Note: All fields other than TS\
    \ Type and Selector Length depend on\n   the TS Type.  The fields shown are for\
    \ TS Types 7 and 8, the only two\n   values currently defined.\n   o  TS Type\
    \ (one octet) - Specifies the type of Traffic Selector.\n   o  IP protocol ID\
    \ (1 octet) - Value specifying an associated IP\n      protocol ID (such as UDP,\
    \ TCP, and ICMP).  A value of zero means\n      that the protocol ID is not relevant\
    \ to this Traffic Selector --\n      the SA can carry all protocols.\n   o  Selector\
    \ Length - Specifies the length of this Traffic Selector\n      substructure including\
    \ the header.\n   o  Start Port (2 octets, unsigned integer) - Value specifying\
    \ the\n      smallest port number allowed by this Traffic Selector.  For\n   \
    \   protocols for which port is undefined (including protocol 0), or\n      if\
    \ all ports are allowed, this field MUST be zero.  ICMP and\n      ICMPv6 Type\
    \ and Code values, as well as Mobile IP version 6\n      (MIPv6) mobility header\
    \ (MH) Type values, are represented in this\n      field as specified in Section\
    \ 4.4.1.1 of [IPSECARCH].  ICMP Type\n      and Code values are treated as a single\
    \ 16-bit integer port\n      number, with Type in the most significant eight bits\
    \ and Code in\n      the least significant eight bits.  MIPv6 MH Type values are\n\
    \      treated as a single 16-bit integer port number, with Type in the\n    \
    \  most significant eight bits and the least significant eight bits\n      set\
    \ to zero.\n   o  End Port (2 octets, unsigned integer) - Value specifying the\n\
    \      largest port number allowed by this Traffic Selector.  For\n      protocols\
    \ for which port is undefined (including protocol 0), or\n      if all ports are\
    \ allowed, this field MUST be 65535.  ICMP and\n      ICMPv6 Type and Code values,\
    \ as well as MIPv6 MH Type values, are\n      represented in this field as specified\
    \ in Section 4.4.1.1 of\n      [IPSECARCH].  ICMP Type and Code values are treated\
    \ as a single\n      16-bit integer port number, with Type in the most significant\n\
    \      eight bits and Code in the least significant eight bits.  MIPv6 MH\n  \
    \    Type values are treated as a single 16-bit integer port number,\n      with\
    \ Type in the most significant eight bits and the least\n      significant eight\
    \ bits set to zero.\n   o  Starting Address - The smallest address included in\
    \ this Traffic\n      Selector (length determined by TS Type).\n   o  Ending Address\
    \ - The largest address included in this Traffic\n      Selector (length determined\
    \ by TS Type).\n   Systems that are complying with [IPSECARCH] that wish to indicate\n\
    \   \"ANY\" ports MUST set the start port to 0 and the end port to 65535;\n  \
    \ note that according to [IPSECARCH], \"ANY\" includes \"OPAQUE\".  Systems\n\
    \   working with [IPSECARCH] that wish to indicate \"OPAQUE\" ports, but\n   not\
    \ \"ANY\" ports, MUST set the start port to 65535 and the end port to\n   0.\n\
    \   The Traffic Selector types 7 and 8 can also refer to ICMP or ICMPv6\n   type\
    \ and code fields, as well as MH Type fields for the IPv6 mobility\n   header\
    \ [MIPV6].  Note, however, that neither ICMP nor MIPv6 packets\n   have separate\
    \ source and destination fields.  The method for\n   specifying the Traffic Selectors\
    \ for ICMP and MIPv6 is shown by\n   example in Section 4.4.1.3 of [IPSECARCH].\n\
    \   The following table lists values for the Traffic Selector Type field\n   and\
    \ the corresponding Address Selector Data.  The values in the\n   following table\
    \ are only current as of the publication date of RFC\n   4306.  Other values may\
    \ have been added since then or will be added\n   after the publication of this\
    \ document.  Readers should refer to\n   [IKEV2IANA] for the latest values.\n\
    \   TS Type                            Value\n   -------------------------------------------------------------------\n\
    \   TS_IPV4_ADDR_RANGE                  7\n       A range of IPv4 addresses, represented\
    \ by two four-octet\n       values.  The first value is the beginning IPv4 address\n\
    \       (inclusive) and the second value is the ending IPv4 address\n       (inclusive).\
    \  All addresses falling between the two specified\n       addresses are considered\
    \ to be within the list.\n   TS_IPV6_ADDR_RANGE                  8\n       A range\
    \ of IPv6 addresses, represented by two sixteen-octet\n       values.  The first\
    \ value is the beginning IPv6 address\n       (inclusive) and the second value\
    \ is the ending IPv6 address\n       (inclusive).  All addresses falling between\
    \ the two specified\n       addresses are considered to be within the list.\n"
- title: 3.14.  Encrypted Payload
  contents:
  - "3.14.  Encrypted Payload\n   The Encrypted payload, denoted SK{...} in this document,\
    \ contains\n   other payloads in encrypted form.  The Encrypted payload, if present\n\
    \   in a message, MUST be the last payload in the message.  Often, it is\n   the\
    \ only payload in the message.  This payload is also called the\n   \"Encrypted\
    \ and Authenticated\" payload.\n   The algorithms for encryption and integrity\
    \ protection are negotiated\n   during IKE SA setup, and the keys are computed\
    \ as specified in\n   Sections 2.14 and 2.18.\n   This document specifies the\
    \ cryptographic processing of Encrypted\n   payloads using a block cipher in CBC\
    \ mode and an integrity check\n   algorithm that computes a fixed-length checksum\
    \ over a variable size\n   message.  The design is modeled after the ESP algorithms\
    \ described in\n   RFCs 2104 [HMAC], 4303 [ESP], and 2451 [ESPCBC].  This document\n\
    \   completely specifies the cryptographic processing of IKE data, but\n   those\
    \ documents should be consulted for design rationale.  Future\n   documents may\
    \ specify the processing of Encrypted payloads for other\n   types of transforms,\
    \ such as counter mode encryption and\n   authenticated encryption algorithms.\
    \  Peers MUST NOT negotiate\n   transforms for which no such specification exists.\n\
    \   When an authenticated encryption algorithm is used to protect the IKE\n  \
    \ SA, the construction of the Encrypted payload is different than what\n   is\
    \ described here.  See [AEAD] for more information on authenticated\n   encryption\
    \ algorithms and their use in ESP.\n   The payload type for an Encrypted payload\
    \ is forty-six (46).  The\n   Encrypted payload consists of the IKE generic payload\
    \ header followed\n   by individual fields as follows:\n                     \
    \   1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Next Payload  |C|  RESERVED   |         Payload Length        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Initialization Vector                     |\n   |  \
    \       (length is block size for encryption algorithm)       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   ~                    Encrypted IKE Payloads                     ~\n   +  \
    \             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |        \
    \       |             Padding (0-255 octets)            |\n   +-+-+-+-+-+-+-+-+\
    \                               +-+-+-+-+-+-+-+-+\n   |                      \
    \                         |  Pad Length   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   ~                    Integrity Checksum Data                    ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \            Figure 21:  Encrypted Payload Format\n   o  Next Payload - The payload\
    \ type of the first embedded payload.\n      Note that this is an exception in\
    \ the standard header format,\n      since the Encrypted payload is the last payload\
    \ in the message and\n      therefore the Next Payload field would normally be\
    \ zero.  But\n      because the content of this payload is embedded payloads and\
    \ there\n      was no natural place to put the type of the first one, that type\n\
    \      is placed here.\n   o  Payload Length - Includes the lengths of the header,\n\
    \      initialization vector (IV), Encrypted IKE payloads, Padding, Pad\n    \
    \  Length, and Integrity Checksum Data.\n   o  Initialization Vector - For CBC\
    \ mode ciphers, the length of the\n      initialization vector (IV) is equal to\
    \ the block length of the\n      underlying encryption algorithm.  Senders MUST\
    \ select a new\n      unpredictable IV for every message; recipients MUST accept\
    \ any\n      value.  The reader is encouraged to consult [MODES] for advice on\n\
    \      IV generation.  In particular, using the final ciphertext block of\n  \
    \    the previous message is not considered unpredictable.  For modes\n      other\
    \ than CBC, the IV format and processing is specified in the\n      document specifying\
    \ the encryption algorithm and mode.\n   o  IKE payloads are as specified earlier\
    \ in this section.  This field\n      is encrypted with the negotiated cipher.\n\
    \   o  Padding MAY contain any value chosen by the sender, and MUST have\n   \
    \   a length that makes the combination of the payloads, the Padding,\n      and\
    \ the Pad Length to be a multiple of the encryption block size.\n      This field\
    \ is encrypted with the negotiated cipher.\n   o  Pad Length is the length of\
    \ the Padding field.  The sender SHOULD\n      set the Pad Length to the minimum\
    \ value that makes the combination\n      of the payloads, the Padding, and the\
    \ Pad Length a multiple of the\n      block size, but the recipient MUST accept\
    \ any length that results\n      in proper alignment.  This field is encrypted\
    \ with the negotiated\n      cipher.\n   o  Integrity Checksum Data is the cryptographic\
    \ checksum of the\n      entire message starting with the Fixed IKE header through\
    \ the Pad\n      Length.  The checksum MUST be computed over the encrypted message.\n\
    \      Its length is determined by the integrity algorithm negotiated.\n"
- title: 3.15.  Configuration Payload
  contents:
  - "3.15.  Configuration Payload\n   The Configuration payload, denoted CP in this\
    \ document, is used to\n   exchange configuration information between IKE peers.\
    \  The exchange\n   is for an IRAC to request an internal IP address from an IRAS\
    \ and to\n   exchange other information of the sort that one would acquire with\n\
    \   Dynamic Host Configuration Protocol (DHCP) if the IRAC were directly\n   connected\
    \ to a LAN.\n   The Configuration payload is defined as follows:\n           \
    \             1                   2                   3\n    0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Next Payload  |C| RESERVED    |         Payload Length        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   CFG Type    |                    RESERVED                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \                 Configuration Attributes                    ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \            Figure 22:  Configuration Payload Format\n   The payload type for\
    \ the Configuration payload is forty-seven (47).\n   o  CFG Type (1 octet) - The\
    \ type of exchange represented by the\n      Configuration Attributes.  The values\
    \ in the following table are\n      only current as of the publication date of\
    \ RFC 4306.  Other values\n      may have been added since then or will be added\
    \ after the\n      publication of this document.  Readers should refer to [IKEV2IANA]\n\
    \      for the latest values.\n      CFG Type           Value\n      --------------------------\n\
    \      CFG_REQUEST        1\n      CFG_REPLY          2\n      CFG_SET       \
    \     3\n      CFG_ACK            4\n   o  RESERVED (3 octets) - MUST be sent\
    \ as zero; MUST be ignored on\n      receipt.\n   o  Configuration Attributes\
    \ (variable length) - These are type length\n      value (TLV) structures specific\
    \ to the Configuration payload and\n      are defined below.  There may be zero\
    \ or more Configuration\n      Attributes in this payload.\n"
- title: 3.15.1.  Configuration Attributes
  contents:
  - "3.15.1.  Configuration Attributes\n                        1                \
    \   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |R|         Attribute Type      |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \                           Value                             ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \            Figure 23:  Configuration Attribute Format\n   o  Reserved (1 bit)\
    \ - This bit MUST be set to zero and MUST be\n      ignored on receipt.\n   o\
    \  Attribute Type (15 bits) - A unique identifier for each of the\n      Configuration\
    \ Attribute Types.\n   o  Length (2 octets, unsigned integer) - Length in octets\
    \ of value.\n   o  Value (0 or more octets) - The variable-length value of this\n\
    \      Configuration Attribute.  The following lists the attribute types.\n  \
    \ The values in the following table are only current as of the\n   publication\
    \ date of RFC 4306 (except INTERNAL_ADDRESS_EXPIRY and\n   INTERNAL_IP6_NBNS which\
    \ were removed by this document).  Other values\n   may have been added since\
    \ then or will be added after the publication\n   of this document.  Readers should\
    \ refer to [IKEV2IANA] for the latest\n   values.\n      Attribute Type      \
    \     Value  Multi-Valued  Length\n      ------------------------------------------------------------\n\
    \      INTERNAL_IP4_ADDRESS     1      YES*          0 or 4 octets\n      INTERNAL_IP4_NETMASK\
    \     2      NO            0 or 4 octets\n      INTERNAL_IP4_DNS         3   \
    \   YES           0 or 4 octets\n      INTERNAL_IP4_NBNS        4      YES   \
    \        0 or 4 octets\n      INTERNAL_IP4_DHCP        6      YES           0\
    \ or 4 octets\n      APPLICATION_VERSION      7      NO            0 or more\n\
    \      INTERNAL_IP6_ADDRESS     8      YES*          0 or 17 octets\n      INTERNAL_IP6_DNS\
    \         10     YES           0 or 16 octets\n      INTERNAL_IP6_DHCP       \
    \ 12     YES           0 or 16 octets\n      INTERNAL_IP4_SUBNET      13     YES\
    \           0 or 8 octets\n      SUPPORTED_ATTRIBUTES     14     NO          \
    \  Multiple of 2\n      INTERNAL_IP6_SUBNET      15     YES           17 octets\n\
    \      * These attributes may be multi-valued on return only if\n        multiple\
    \ values were requested.\n   o  INTERNAL_IP4_ADDRESS, INTERNAL_IP6_ADDRESS - An\
    \ address on the\n      internal network, sometimes called a red node address\
    \ or private\n      address, and it MAY be a private address on the Internet.\
    \  In a\n      request message, the address specified is a requested address (or\n\
    \      a zero-length address if no specific address is requested).  If a\n   \
    \   specific address is requested, it likely indicates that a previous\n     \
    \ connection existed with this address and the requestor would like\n      to\
    \ reuse that address.  With IPv6, a requestor MAY supply the low-\n      order\
    \ address octets it wants to use.  Multiple internal addresses\n      MAY be requested\
    \ by requesting multiple internal address\n      attributes.  The responder MAY\
    \ only send up to the number of\n      addresses requested.  The INTERNAL_IP6_ADDRESS\
    \ is made up of two\n      fields: the first is a 16-octet IPv6 address, and the\
    \ second is a\n      one-octet prefix-length as defined in [ADDRIPV6].  The requested\n\
    \      address is valid as long as this IKE SA (or its rekeyed\n      successors)\
    \ requesting the address is valid.  This is described in\n      more detail in\
    \ Section 3.15.3.\n   o  INTERNAL_IP4_NETMASK - The internal network's netmask.\
    \  Only one\n      netmask is allowed in the request and response messages (e.g.,\n\
    \      255.255.255.0), and it MUST be used only with an\n      INTERNAL_IP4_ADDRESS\
    \ attribute.  INTERNAL_IP4_NETMASK in a\n      CFG_REPLY means roughly the same\
    \ thing as INTERNAL_IP4_SUBNET\n      containing the same information (\"send\
    \ traffic to these addresses\n      through me\"), but also implies a link boundary.\
    \  For instance, the\n      client could use its own address and the netmask to\
    \ calculate the\n      broadcast address of the link.  An empty INTERNAL_IP4_NETMASK\n\
    \      attribute can be included in a CFG_REQUEST to request this\n      information\
    \ (although the gateway can send the information even\n      when not requested).\
    \  Non-empty values for this attribute in a\n      CFG_REQUEST do not make sense\
    \ and thus MUST NOT be included.\n   o  INTERNAL_IP4_DNS, INTERNAL_IP6_DNS - Specifies\
    \ an address of a DNS\n      server within the network.  Multiple DNS servers\
    \ MAY be requested.\n      The responder MAY respond with zero or more DNS server\
    \ attributes.\n   o  INTERNAL_IP4_NBNS - Specifies an address of a NetBios Name\
    \ Server\n      (WINS) within the network.  Multiple NBNS servers MAY be\n   \
    \   requested.  The responder MAY respond with zero or more NBNS\n      server\
    \ attributes.\n   o  INTERNAL_IP4_DHCP, INTERNAL_IP6_DHCP - Instructs the host\
    \ to send\n      any internal DHCP requests to the address contained within the\n\
    \      attribute.  Multiple DHCP servers MAY be requested.  The responder\n  \
    \    MAY respond with zero or more DHCP server attributes.\n   o  APPLICATION_VERSION\
    \ - The version or application information of\n      the IPsec host.  This is\
    \ a string of printable ASCII characters\n      that is NOT null terminated.\n\
    \   o  INTERNAL_IP4_SUBNET - The protected sub-networks that this edge-\n    \
    \  device protects.  This attribute is made up of two fields: the\n      first\
    \ being an IP address and the second being a netmask.\n      Multiple sub-networks\
    \ MAY be requested.  The responder MAY respond\n      with zero or more sub-network\
    \ attributes.  This is discussed in\n      more detail in Section 3.15.2.\n  \
    \ o  SUPPORTED_ATTRIBUTES - When used within a Request, this attribute\n     \
    \ MUST be zero-length and specifies a query to the responder to\n      reply back\
    \ with all of the attributes that it supports.  The\n      response contains an\
    \ attribute that contains a set of attribute\n      identifiers each in 2 octets.\
    \  The length divided by 2 (octets)\n      would state the number of supported\
    \ attributes contained in the\n      response.\n   o  INTERNAL_IP6_SUBNET - The\
    \ protected sub-networks that this edge-\n      device protects.  This attribute\
    \ is made up of two fields: the\n      first is a 16-octet IPv6 address, and the\
    \ second is a one-octet\n      prefix-length as defined in [ADDRIPV6].  Multiple\
    \ sub-networks MAY\n      be requested.  The responder MAY respond with zero or\
    \ more sub-\n      network attributes.  This is discussed in more detail in\n\
    \      Section 3.15.2.\n   Note that no recommendations are made in this document\
    \ as to how an\n   implementation actually figures out what information to send\
    \ in a\n   response.  That is, we do not recommend any specific method of an\n\
    \   IRAS determining which DNS server should be returned to a requesting\n   IRAC.\n\
    \   The CFG_REQUEST and CFG_REPLY pair allows an IKE endpoint to request\n   information\
    \ from its peer.  If an attribute in the CFG_REQUEST\n   Configuration payload\
    \ is not zero-length, it is taken as a suggestion\n   for that attribute.  The\
    \ CFG_REPLY Configuration payload MAY return\n   that value, or a new one.  It\
    \ MAY also add new attributes and not\n   include some requested ones.  Unrecognized\
    \ or unsupported attributes\n   MUST be ignored in both requests and responses.\n\
    \   The CFG_SET and CFG_ACK pair allows an IKE endpoint to push\n   configuration\
    \ data to its peer.  In this case, the CFG_SET\n   Configuration payload contains\
    \ attributes the initiator wants its\n   peer to alter.  The responder MUST return\
    \ a Configuration payload if\n   it accepted any of the configuration data and\
    \ it MUST contain the\n   attributes that the responder accepted with zero-length\
    \ data.  Those\n   attributes that it did not accept MUST NOT be in the CFG_ACK\n\
    \   Configuration payload.  If no attributes were accepted, the responder\n  \
    \ MUST return either an empty CFG_ACK payload or a response message\n   without\
    \ a CFG_ACK payload.  There are currently no defined uses for\n   the CFG_SET/CFG_ACK\
    \ exchange, though they may be used in connection\n   with extensions based on\
    \ Vendor IDs.  An implementation of this\n   specification MAY ignore CFG_SET\
    \ payloads.\n"
- title: 3.15.2.  Meaning of INTERNAL_IP4_SUBNET and INTERNAL_IP6_SUBNET
  contents:
  - "3.15.2.  Meaning of INTERNAL_IP4_SUBNET and INTERNAL_IP6_SUBNET\n   INTERNAL_IP4/6_SUBNET\
    \ attributes can indicate additional subnets,\n   ones that need one or more separate\
    \ SAs, that can be reached through\n   the gateway that announces the attributes.\
    \  INTERNAL_IP4/6_SUBNET\n   attributes may also express the gateway's policy\
    \ about what traffic\n   should be sent through the gateway; the client can choose\
    \ whether\n   other traffic (covered by TSr, but not in INTERNAL_IP4/6_SUBNET)\
    \ is\n   sent through the gateway or directly to the destination.  Thus,\n   traffic\
    \ to the addresses listed in the INTERNAL_IP4/6_SUBNET\n   attributes should be\
    \ sent through the gateway that announces the\n   attributes.  If there are no\
    \ existing Child SAs whose Traffic\n   Selectors cover the address in question,\
    \ new SAs need to be created.\n   For instance, if there are two subnets, 198.51.100.0/26\
    \ and\n   192.0.2.0/24, and the client's request contains the following:\n   CP(CFG_REQUEST)\
    \ =\n     INTERNAL_IP4_ADDRESS()\n   TSi = (0, 0-65535, 0.0.0.0-255.255.255.255)\n\
    \   TSr = (0, 0-65535, 0.0.0.0-255.255.255.255)\n   then a valid response could\
    \ be the following (in which TSr and\n   INTERNAL_IP4_SUBNET contain the same\
    \ information):\n   CP(CFG_REPLY) =\n     INTERNAL_IP4_ADDRESS(198.51.100.234)\n\
    \     INTERNAL_IP4_SUBNET(198.51.100.0/255.255.255.192)\n     INTERNAL_IP4_SUBNET(192.0.2.0/255.255.255.0)\n\
    \   TSi = (0, 0-65535, 198.51.100.234-198.51.100.234)\n   TSr = ((0, 0-65535,\
    \ 198.51.100.0-198.51.100.63),\n          (0, 0-65535, 192.0.2.0-192.0.2.255))\n\
    \   In these cases, the INTERNAL_IP4_SUBNET does not really carry any\n   useful\
    \ information.\n   A different possible response would have been this:\n   CP(CFG_REPLY)\
    \ =\n     INTERNAL_IP4_ADDRESS(198.51.100.234)\n     INTERNAL_IP4_SUBNET(198.51.100.0/255.255.255.192)\n\
    \     INTERNAL_IP4_SUBNET(192.0.2.0/255.255.255.0)\n   TSi = (0, 0-65535, 198.51.100.234-198.51.100.234)\n\
    \   TSr = (0, 0-65535, 0.0.0.0-255.255.255.255)\n   That response would mean that\
    \ the client can send all its traffic\n   through the gateway, but the gateway\
    \ does not mind if the client\n   sends traffic not included by INTERNAL_IP4_SUBNET\
    \ directly to the\n   destination (without going through the gateway).\n   A different\
    \ situation arises if the gateway has a policy that\n   requires the traffic for\
    \ the two subnets to be carried in separate\n   SAs.  Then a response like this\
    \ would indicate to the client that if\n   it wants access to the second subnet,\
    \ it needs to create a separate\n   SA:\n   CP(CFG_REPLY) =\n     INTERNAL_IP4_ADDRESS(198.51.100.234)\n\
    \     INTERNAL_IP4_SUBNET(198.51.100.0/255.255.255.192)\n     INTERNAL_IP4_SUBNET(192.0.2.0/255.255.255.0)\n\
    \   TSi = (0, 0-65535, 198.51.100.234-198.51.100.234)\n   TSr = (0, 0-65535, 198.51.100.0-198.51.100.63)\n\
    \   INTERNAL_IP4_SUBNET can also be useful if the client's TSr included\n   only\
    \ part of the address space.  For instance, if the client requests\n   the following:\n\
    \   CP(CFG_REQUEST) =\n     INTERNAL_IP4_ADDRESS()\n   TSi = (0, 0-65535, 0.0.0.0-255.255.255.255)\n\
    \   TSr = (0, 0-65535, 192.0.2.155-192.0.2.155)\n   then the gateway's response\
    \ might be:\n   CP(CFG_REPLY) =\n     INTERNAL_IP4_ADDRESS(198.51.100.234)\n \
    \    INTERNAL_IP4_SUBNET(198.51.100.0/255.255.255.192)\n     INTERNAL_IP4_SUBNET(192.0.2.0/255.255.255.0)\n\
    \   TSi = (0, 0-65535, 198.51.100.234-198.51.100.234)\n   TSr = (0, 0-65535, 192.0.2.155-192.0.2.155)\n\
    \   Because the meaning of INTERNAL_IP4_SUBNET/INTERNAL_IP6_SUBNET in\n   CFG_REQUESTs\
    \ is unclear, they cannot be used reliably in\n   CFG_REQUESTs.\n"
- title: 3.15.3.  Configuration Payloads for IPv6
  contents:
  - "3.15.3.  Configuration Payloads for IPv6\n   The Configuration payloads for IPv6\
    \ are based on the corresponding\n   IPv4 payloads, and do not fully follow the\
    \ \"normal IPv6 way of doing\n   things\".  In particular, IPv6 stateless autoconfiguration\
    \ or router\n   advertisement messages are not used, neither is neighbor discovery.\n\
    \   Note that there is an additional document that discusses IPv6\n   configuration\
    \ in IKEv2, [IPV6CONFIG].  At the present time, it is an\n   experimental document,\
    \ but there is a hope that with more\n   implementation experience, it will gain\
    \ the same standards treatment\n   as this document.\n   A client can be assigned\
    \ an IPv6 address using the\n   INTERNAL_IP6_ADDRESS Configuration payload.  A\
    \ minimal exchange might\n   look like this:\n   CP(CFG_REQUEST) =\n     INTERNAL_IP6_ADDRESS()\n\
    \     INTERNAL_IP6_DNS()\n   TSi = (0, 0-65535, :: - FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF)\n\
    \   TSr = (0, 0-65535, :: - FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF)\n   CP(CFG_REPLY)\
    \ =\n     INTERNAL_IP6_ADDRESS(2001:DB8:0:1:2:3:4:5/64)\n     INTERNAL_IP6_DNS(2001:DB8:99:88:77:66:55:44)\n\
    \   TSi = (0, 0-65535, 2001:DB8:0:1:2:3:4:5 - 2001:DB8:0:1:2:3:4:5)\n   TSr =\
    \ (0, 0-65535, :: - FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF)\n   The client MAY\
    \ send a non-empty INTERNAL_IP6_ADDRESS attribute in the\n   CFG_REQUEST to request\
    \ a specific address or interface identifier.\n   The gateway first checks if\
    \ the specified address is acceptable, and\n   if it is, returns that one.  If\
    \ the address was not acceptable, the\n   gateway attempts to use the interface\
    \ identifier with some other\n   prefix; if even that fails, the gateway selects\
    \ another interface\n   identifier.\n   The INTERNAL_IP6_ADDRESS attribute also\
    \ contains a prefix length\n   field.  When used in a CFG_REPLY, this corresponds\
    \ to the\n   INTERNAL_IP4_NETMASK attribute in the IPv4 case.\n   Although this\
    \ approach to configuring IPv6 addresses is reasonably\n   simple, it has some\
    \ limitations.  IPsec tunnels configured using\n   IKEv2 are not fully featured\
    \ \"interfaces\" in the IPv6 addressing\n   architecture sense [ADDRIPV6].  In\
    \ particular, they do not\n   necessarily have link-local addresses, and this\
    \ may complicate the\n   use of protocols that assume them, such as [MLDV2].\n"
- title: 3.15.4.  Address Assignment Failures
  contents:
  - "3.15.4.  Address Assignment Failures\n   If the responder encounters an error\
    \ while attempting to assign an IP\n   address to the initiator during the processing\
    \ of a Configuration\n   payload, it responds with an INTERNAL_ADDRESS_FAILURE\
    \ notification.\n   The IKE SA is still created even if the initial Child SA cannot\
    \ be\n   created because of this failure.  If this error is generated within\n\
    \   an IKE_AUTH exchange, no Child SA will be created.  However, there\n   are\
    \ some more complex error cases.\n   If the responder does not support Configuration\
    \ payloads at all, it\n   can simply ignore all Configuration payloads.  This\
    \ type of\n   implementation never sends INTERNAL_ADDRESS_FAILURE notifications.\n\
    \   If the initiator requires the assignment of an IP address, it will\n   treat\
    \ a response without CFG_REPLY as an error.\n   The initiator may request a particular\
    \ type of address (IPv4 or IPv6)\n   that the responder does not support, even\
    \ though the responder\n   supports Configuration payloads.  In this case, the\
    \ responder simply\n   ignores the type of address it does not support and processes\
    \ the\n   rest of the request as usual.\n   If the initiator requests multiple\
    \ addresses of a type that the\n   responder supports, and some (but not all)\
    \ of the requests fail, the\n   responder replies with the successful addresses\
    \ only.  The responder\n   sends INTERNAL_ADDRESS_FAILURE only if no addresses\
    \ can be assigned.\n   If the initiator does not receive the IP address(es) required\
    \ by its\n   policy, it MAY keep the IKE SA up and retry the Configuration payload\n\
    \   as separate INFORMATIONAL exchange after suitable timeout, or it MAY\n   tear\
    \ down the IKE SA by sending a Delete payload inside a separate\n   INFORMATIONAL\
    \ exchange and later retry IKE SA from the beginning\n   after some timeout. \
    \ Such a timeout should not be too short\n   (especially if the IKE SA is started\
    \ from the beginning) because\n   these error situations may not be able to be\
    \ fixed quickly; the\n   timeout should likely be several minutes.  For example,\
    \ an address\n   shortage problem on the responder will probably only be fixed\
    \ when\n   more entries are returned to the address pool when other clients\n\
    \   disconnect or when responder is reconfigured with larger address\n   pool.\n"
- title: 3.16.  Extensible Authentication Protocol (EAP) Payload
  contents:
  - "3.16.  Extensible Authentication Protocol (EAP) Payload\n   The Extensible Authentication\
    \ Protocol payload, denoted EAP in this\n   document, allows IKE SAs to be authenticated\
    \ using the protocol\n   defined in RFC 3748 [EAP] and subsequent extensions to\
    \ that protocol.\n   When using EAP, an appropriate EAP method needs to be selected.\
    \  Many\n   of these methods have been defined, specifying the protocol's use\n\
    \   with various authentication mechanisms.  EAP method types are listed\n   in\
    \ [EAP-IANA].  A short summary of the EAP format is included here\n   for clarity.\n\
    \                        1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Next Payload  |C|  RESERVED   |         Payload Length        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \                     EAP Message                             ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                   Figure 24:  EAP Payload Format\n   The payload type for an\
    \ EAP payload is forty-eight (48).\n                        1                \
    \   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     Code      | Identifier    |           Length              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     Type      | Type_Data...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\n\
    \                   Figure 25:  EAP Message Format\n   o  Code (1 octet) indicates\
    \ whether this message is a Request (1),\n      Response (2), Success (3), or\
    \ Failure (4).\n   o  Identifier (1 octet) is used in PPP to distinguish replayed\n\
    \      messages from repeated ones.  Since in IKE, EAP runs over a\n      reliable\
    \ protocol, it serves no function here.  In a response\n      message, this octet\
    \ MUST be set to match the identifier in the\n      corresponding request.\n \
    \  o  Length (2 octets, unsigned integer) is the length of the EAP\n      message\
    \ and MUST be four less than the Payload Length of the\n      encapsulating payload.\n\
    \   o  Type (1 octet) is present only if the Code field is Request (1) or\n  \
    \    Response (2).  For other codes, the EAP message length MUST be\n      four\
    \ octets and the Type and Type_Data fields MUST NOT be present.\n      In a Request\
    \ (1) message, Type indicates the data being requested.\n      In a Response (2)\
    \ message, Type MUST either be Nak or match the\n      type of the data requested.\
    \  Note that since IKE passes an\n      indication of initiator identity in the\
    \ first message in the\n      IKE_AUTH exchange, the responder SHOULD NOT send\
    \ EAP Identity\n      requests (type 1).  The initiator MAY, however, respond\
    \ to such\n      requests if it receives them.\n   o  Type_Data (Variable Length)\
    \ varies with the Type of Request and\n      the associated Response.  For the\
    \ documentation of the EAP\n      methods, see [EAP].\n   Note that since IKE\
    \ passes an indication of initiator identity in the\n   first message in the IKE_AUTH\
    \ exchange, the responder should not send\n   EAP Identity requests.  The initiator\
    \ may, however, respond to such\n   requests if it receives them.\n"
- title: 4.  Conformance Requirements
  contents:
  - "4.  Conformance Requirements\n   In order to assure that all implementations\
    \ of IKEv2 can\n   interoperate, there are \"MUST support\" requirements in addition\
    \ to\n   those listed elsewhere.  Of course, IKEv2 is a security protocol, and\n\
    \   one of its major functions is to allow only authorized parties to\n   successfully\
    \ complete establishment of SAs.  So a particular\n   implementation may be configured\
    \ with any of a number of restrictions\n   concerning algorithms and trusted authorities\
    \ that will prevent\n   universal interoperability.\n   IKEv2 is designed to permit\
    \ minimal implementations that can\n   interoperate with all compliant implementations.\
    \  The following are\n   features that can be omitted in a minimal implementation:\n\
    \   o  Ability to negotiate SAs through a NAT and tunnel the resulting\n     \
    \ ESP SA over UDP.\n   o  Ability to request (and respond to a request for) a\
    \ temporary IP\n      address on the remote end of a tunnel.\n   o  Ability to\
    \ support EAP-based authentication.\n   o  Ability to support window sizes greater\
    \ than one.\n   o  Ability to establish multiple ESP or AH SAs within a single\
    \ IKE\n      SA.\n   o  Ability to rekey SAs.\n   To assure interoperability,\
    \ all implementations MUST be capable of\n   parsing all payload types (if only\
    \ to skip over them) and to ignore\n   payload types that it does not support\
    \ unless the critical bit is set\n   in the payload header.  If the critical bit\
    \ is set in an unsupported\n   payload header, all implementations MUST reject\
    \ the messages\n   containing those payloads.\n   Every implementation MUST be\
    \ capable of doing four-message\n   IKE_SA_INIT and IKE_AUTH exchanges establishing\
    \ two SAs (one for IKE,\n   one for ESP or AH).  Implementations MAY be initiate-only\
    \ or respond-\n   only if appropriate for their platform.  Every implementation\
    \ MUST be\n   capable of responding to an INFORMATIONAL exchange, but a minimal\n\
    \   implementation MAY respond to any request in the INFORMATIONAL\n   exchange\
    \ with an empty response (note that within the context of an\n   IKE SA, an \"\
    empty\" message consists of an IKE header followed by an\n   Encrypted payload\
    \ with no payloads contained in it).  A minimal\n   implementation MAY support\
    \ the CREATE_CHILD_SA exchange only in so\n   far as to recognize requests and\
    \ reject them with a Notify payload of\n   type NO_ADDITIONAL_SAS.  A minimal\
    \ implementation need not be able to\n   initiate CREATE_CHILD_SA or INFORMATIONAL\
    \ exchanges.  When an SA\n   expires (based on locally configured values of either\
    \ lifetime or\n   octets passed), and implementation MAY either try to renew it\
    \ with a\n   CREATE_CHILD_SA exchange or it MAY delete (close) the old SA and\n\
    \   create a new one.  If the responder rejects the CREATE_CHILD_SA\n   request\
    \ with a NO_ADDITIONAL_SAS notification, the implementation\n   MUST be capable\
    \ of instead deleting the old SA and creating a new\n   one.\n   Implementations\
    \ are not required to support requesting temporary IP\n   addresses or responding\
    \ to such requests.  If an implementation does\n   support issuing such requests\
    \ and its policy requires using temporary\n   IP addresses, it MUST include a\
    \ CP payload in the first message in\n   the IKE_AUTH exchange containing at least\
    \ a field of type\n   INTERNAL_IP4_ADDRESS or INTERNAL_IP6_ADDRESS.  All other\
    \ fields are\n   optional.  If an implementation supports responding to such requests,\n\
    \   it MUST parse the CP payload of type CFG_REQUEST in the first message\n  \
    \ in the IKE_AUTH exchange and recognize a field of type\n   INTERNAL_IP4_ADDRESS\
    \ or INTERNAL_IP6_ADDRESS.  If it supports leasing\n   an address of the appropriate\
    \ type, it MUST return a CP payload of\n   type CFG_REPLY containing an address\
    \ of the requested type.  The\n   responder may include any other related attributes.\n\
    \   For an implementation to be called conforming to this specification,\n   it\
    \ MUST be possible to configure it to accept the following:\n   o  Public Key\
    \ Infrastructure using X.509 (PKIX) Certificates\n      containing and signed\
    \ by RSA keys of size 1024 or 2048 bits, where\n      the ID passed is any of\
    \ ID_KEY_ID, ID_FQDN, ID_RFC822_ADDR, or\n      ID_DER_ASN1_DN.\n   o  Shared\
    \ key authentication where the ID passed is any of ID_KEY_ID,\n      ID_FQDN,\
    \ or ID_RFC822_ADDR.\n   o  Authentication where the responder is authenticated\
    \ using PKIX\n      Certificates and the initiator is authenticated using shared\
    \ key\n      authentication.\n"
- title: 5.  Security Considerations
  contents:
  - "5.  Security Considerations\n   While this protocol is designed to minimize disclosure\
    \ of\n   configuration information to unauthenticated peers, some such\n   disclosure\
    \ is unavoidable.  One peer or the other must identify\n   itself first and prove\
    \ its identity first.  To avoid probing, the\n   initiator of an exchange is required\
    \ to identify itself first, and\n   usually is required to authenticate itself\
    \ first.  The initiator can,\n   however, learn that the responder supports IKE\
    \ and what cryptographic\n   protocols it supports.  The responder (or someone\
    \ impersonating the\n   responder) can probe the initiator not only for its identity,\
    \ but\n   using CERTREQ payloads may be able to determine what certificates the\n\
    \   initiator is willing to use.\n   Use of EAP authentication changes the probing\
    \ possibilities somewhat.\n   When EAP authentication is used, the responder proves\
    \ its identity\n   before the initiator does, so an initiator that knew the name\
    \ of a\n   valid initiator could probe the responder for both its name and\n \
    \  certificates.\n   Repeated rekeying using CREATE_CHILD_SA without additional\
    \ Diffie-\n   Hellman exchanges leaves all SAs vulnerable to cryptanalysis of\
    \ a\n   single key.  Implementers should take note of this fact and set a\n  \
    \ limit on CREATE_CHILD_SA exchanges between exponentiations.  This\n   document\
    \ does not prescribe such a limit.\n   The strength of a key derived from a Diffie-Hellman\
    \ exchange using\n   any of the groups defined here depends on the inherent strength\
    \ of\n   the group, the size of the exponent used, and the entropy provided by\n\
    \   the random number generator used.  Due to these inputs, it is\n   difficult\
    \ to determine the strength of a key for any of the defined\n   groups.  Diffie-Hellman\
    \ group number two, when used with a strong\n   random number generator and an\
    \ exponent no less than 200 bits, is\n   common for use with 3DES.  Group five\
    \ provides greater security than\n   group two.  Group one is for historic purposes\
    \ only and does not\n   provide sufficient strength except for use with DES, which\
    \ is also\n   for historic use only.  Implementations should make note of these\n\
    \   estimates when establishing policy and negotiating security\n   parameters.\n\
    \   Note that these limitations are on the Diffie-Hellman groups\n   themselves.\
    \  There is nothing in IKE that prohibits using stronger\n   groups nor is there\
    \ anything that will dilute the strength obtained\n   from stronger groups (limited\
    \ by the strength of the other algorithms\n   negotiated including the PRF). \
    \ In fact, the extensible framework of\n   IKE encourages the definition of more\
    \ groups; use of elliptic curve\n   groups may greatly increase strength using\
    \ much smaller numbers.\n   It is assumed that all Diffie-Hellman exponents are\
    \ erased from\n   memory after use.\n   The IKE_SA_INIT and IKE_AUTH exchanges\
    \ happen before the initiator\n   has been authenticated.  As a result, an implementation\
    \ of this\n   protocol needs to be completely robust when deployed on any insecure\n\
    \   network.  Implementation vulnerabilities, particularly DoS attacks,\n   can\
    \ be exploited by unauthenticated peers.  This issue is\n   particularly worrisome\
    \ because of the unlimited number of messages in\n   EAP-based authentication.\n\
    \   The strength of all keys is limited by the size of the output of the\n   negotiated\
    \ PRF.  For this reason, a PRF whose output is less than 128\n   bits (e.g., 3DES-CBC)\
    \ MUST NOT be used with this protocol.\n   The security of this protocol is critically\
    \ dependent on the\n   randomness of the randomly chosen parameters.  These should\
    \ be\n   generated by a strong random or properly seeded pseudorandom source\n\
    \   (see [RANDOMNESS]).  Implementers should take care to ensure that use\n  \
    \ of random numbers for both keys and nonces is engineered in a fashion\n   that\
    \ does not undermine the security of the keys.\n   For information on the rationale\
    \ of many of the cryptographic design\n   choices in this protocol, see [SIGMA]\
    \ and [SKEME].  Though the\n   security of negotiated Child SAs does not depend\
    \ on the strength of\n   the encryption and integrity protection negotiated in\
    \ the IKE SA,\n   implementations MUST NOT negotiate NONE as the IKE integrity\n\
    \   protection algorithm or ENCR_NULL as the IKE encryption algorithm.\n   When\
    \ using pre-shared keys, a critical consideration is how to assure\n   the randomness\
    \ of these secrets.  The strongest practice is to ensure\n   that any pre-shared\
    \ key contain as much randomness as the strongest\n   key being negotiated.  Deriving\
    \ a shared secret from a password,\n   name, or other low-entropy source is not\
    \ secure.  These sources are\n   subject to dictionary and social-engineering\
    \ attacks, among others.\n   The NAT_DETECTION_*_IP notifications contain a hash\
    \ of the addresses\n   and ports in an attempt to hide internal IP addresses behind\
    \ a NAT.\n   Since the IPv4 address space is only 32 bits, and it is usually very\n\
    \   sparse, it would be possible for an attacker to find out the internal\n  \
    \ address used behind the NAT box by trying all possible IP addresses\n   and\
    \ trying to find the matching hash.  The port numbers are normally\n   fixed to\
    \ 500, and the SPIs can be extracted from the packet.  This\n   reduces the number\
    \ of hash calculations to 2^32.  With an educated\n   guess of the use of private\
    \ address space, the number of hash\n   calculations is much smaller.  Designers\
    \ should therefore not assume\n   that use of IKE will not leak internal address\
    \ information.\n   When using an EAP authentication method that does not generate\
    \ a\n   shared key for protecting a subsequent AUTH payload, certain man-in-\n\
    \   the-middle and server-impersonation attacks are possible [EAPMITM].\n   These\
    \ vulnerabilities occur when EAP is also used in protocols that\n   are not protected\
    \ with a secure tunnel.  Since EAP is a general-\n   purpose authentication protocol,\
    \ which is often used to provide\n   single-signon facilities, a deployed IPsec\
    \ solution that relies on an\n   EAP authentication method that does not generate\
    \ a shared key (also\n   known as a non-key-generating EAP method) can become\
    \ compromised due\n   to the deployment of an entirely unrelated application that\
    \ also\n   happens to use the same non-key-generating EAP method, but in an\n\
    \   unprotected fashion.  Note that this vulnerability is not limited to\n   just\
    \ EAP, but can occur in other scenarios where an authentication\n   infrastructure\
    \ is reused.  For example, if the EAP mechanism used by\n   IKEv2 utilizes a token\
    \ authenticator, a man-in-the-middle attacker\n   could impersonate the web server,\
    \ intercept the token authentication\n   exchange, and use it to initiate an IKEv2\
    \ connection.  For this\n   reason, use of non-key-generating EAP methods SHOULD\
    \ be avoided where\n   possible.  Where they are used, it is extremely important\
    \ that all\n   usages of these EAP methods SHOULD utilize a protected tunnel,\
    \ where\n   the initiator validates the responder's certificate before initiating\n\
    \   the EAP authentication.  Implementers should describe the\n   vulnerabilities\
    \ of using non-key-generating EAP methods in the\n   documentation of their implementations\
    \ so that the administrators\n   deploying IPsec solutions are aware of these\
    \ dangers.\n   An implementation using EAP MUST also use a public-key-based\n\
    \   authentication of the server to the client before the EAP\n   authentication\
    \ begins, even if the EAP method offers mutual\n   authentication.  This avoids\
    \ having additional IKEv2 protocol\n   variations and protects the EAP data from\
    \ active attackers.\n   If the messages of IKEv2 are long enough that IP-level\
    \ fragmentation\n   is necessary, it is possible that attackers could prevent\
    \ the\n   exchange from completing by exhausting the reassembly buffers.  The\n\
    \   chances of this can be minimized by using the Hash and URL encodings\n   instead\
    \ of sending certificates (see Section 3.6).  Additional\n   mitigations are discussed\
    \ in [DOSUDPPROT].\n   Admission control is critical to the security of the protocol.\
    \  For\n   example, trust anchors used for identifying IKE peers should probably\n\
    \   be different than those used for other forms of trust, such as those\n   used\
    \ to identify public web servers.  Moreover, although IKE provides\n   a great\
    \ deal of leeway in defining the security policy for a trusted\n   peer's identity,\
    \ credentials, and the correlation between them,\n   having such security policy\
    \ defined explicitly is essential to a\n   secure implementation.\n"
- title: 5.1.  Traffic Selector Authorization
  contents:
  - "5.1.  Traffic Selector Authorization\n   IKEv2 relies on information in the Peer\
    \ Authorization Database (PAD)\n   when determining what kind of Child SAs a peer\
    \ is allowed to create.\n   This process is described in Section 4.4.3 of [IPSECARCH].\
    \  When a\n   peer requests the creation of an Child SA with some Traffic\n  \
    \ Selectors, the PAD must contain \"Child SA Authorization Data\" linking\n  \
    \ the identity authenticated by IKEv2 and the addresses permitted for\n   Traffic\
    \ Selectors.\n   For example, the PAD might be configured so that authenticated\n\
    \   identity \"sgw23.example.com\" is allowed to create Child SAs for\n   192.0.2.0/24,\
    \ meaning this security gateway is a valid\n   \"representative\" for these addresses.\
    \  Host-to-host IPsec requires\n   similar entries, linking, for example, \"fooserver4.example.com\"\
    \ with\n   198.51.100.66/32, meaning this identity is a valid \"owner\" or\n \
    \  \"representative\" of the address in question.\n   As noted in [IPSECARCH],\
    \ \"It is necessary to impose these constraints\n   on creation of child SAs to\
    \ prevent an authenticated peer from\n   spoofing IDs associated with other, legitimate\
    \ peers\".  In the\n   example given above, a correct configuration of the PAD\
    \ prevents\n   sgw23 from creating Child SAs with address 198.51.100.66, and\n\
    \   prevents fooserver4 from creating Child SAs with addresses from\n   192.0.2.0/24.\n\
    \   It is important to note that simply sending IKEv2 packets using some\n   particular\
    \ address does not imply a permission to create Child SAs\n   with that address\
    \ in the Traffic Selectors.  For example, even if\n   sgw23 would be able to spoof\
    \ its IP address as 198.51.100.66, it\n   could not create Child SAs matching\
    \ fooserver4's traffic.\n   The IKEv2 specification does not specify how exactly\
    \ IP address\n   assignment using Configuration payloads interacts with the PAD.\
    \  Our\n   interpretation is that when a security gateway assigns an address\n\
    \   using Configuration payloads, it also creates a temporary PAD entry\n   linking\
    \ the authenticated peer identity and the newly allocated inner\n   address.\n\
    \   It has been recognized that configuring the PAD correctly may be\n   difficult\
    \ in some environments.  For instance, if IPsec is used\n   between a pair of\
    \ hosts whose addresses are allocated dynamically\n   using DHCP, it is extremely\
    \ difficult to ensure that the PAD\n   specifies the correct \"owner\" for each\
    \ IP address.  This would\n   require a mechanism to securely convey address assignments\
    \ from the\n   DHCP server, and link them to identities authenticated using IKEv2.\n\
    \   Due to this limitation, some vendors have been known to configure\n   their\
    \ PADs to allow an authenticated peer to create Child SAs with\n   Traffic Selectors\
    \ containing the same address that was used for the\n   IKEv2 packets.  In environments\
    \ where IP spoofing is possible (i.e.,\n   almost everywhere) this essentially\
    \ allows any peer to create Child\n   SAs with any Traffic Selectors.  This is\
    \ not an appropriate or secure\n   configuration in most circumstances.  See [H2HIPSEC]\
    \ for an extensive\n   discussion about this issue, and the limitations of host-to-host\n\
    \   IPsec in general.\n"
- title: 6.  IANA Considerations
  contents:
  - "6.  IANA Considerations\n   [IKEV2] defined many field types and values.  IANA\
    \ has already\n   registered those types and values in [IKEV2IANA], so they are\
    \ not\n   listed here again.\n   Two items have been removed from the IKEv2 Configuration\
    \ Payload\n   Attribute Types table: INTERNAL_IP6_NBNS and INTERNAL_ADDRESS_EXPIRY.\n\
    \   Two new additions to the IKEv2 parameters \"NOTIFY MESSAGES - ERROR\n   TYPES\"\
    \ registry are defined here that were not defined in [IKEV2]:\n   43   TEMPORARY_FAILURE\n\
    \   44   CHILD_SA_NOT_FOUND\n   IANA has changed the existing IKEv2 Payload Types\
    \ table from:\n   46        Encrypted                        E          [IKEV2]\n\
    \   to\n   46        Encrypted and Authenticated      SK    [This document]\n\
    \   IANA has updated all references to RFC 4306 to point to this\n   document.\n"
- title: 7.  Acknowledgements
  contents:
  - "7.  Acknowledgements\n   Many individuals in the IPsecME Working Group were very\
    \ helpful in\n   contributing ideas and text for this document, as well as in\n\
    \   reviewing the clarifications suggested by others.\n   The acknowledgements\
    \ from the IKEv2 document were:\n   This document is a collaborative effort of\
    \ the entire IPsec WG.  If\n   there were no limit to the number of authors that\
    \ could appear on an\n   RFC, the following, in alphabetical order, would have\
    \ been listed:\n   Bill Aiello, Stephane Beaulieu, Steve Bellovin, Sara Bitan,\
    \ Matt\n   Blaze, Ran Canetti, Darren Dukes, Dan Harkins, Paul Hoffman, John\n\
    \   Ioannidis, Charlie Kaufman, Steve Kent, Angelos Keromytis, Tero\n   Kivinen,\
    \ Hugo Krawczyk, Andrew Krywaniuk, Radia Perlman, Omer\n   Reingold, and Michael\
    \ Richardson.  Many other people contributed to\n   the design.  It is an evolution\
    \ of IKEv1, ISAKMP, and the IPsec DOI,\n   each of which has its own list of authors.\
    \  Hugh Daniel suggested the\n   feature of having the initiator, in message 3,\
    \ specify a name for the\n   responder, and gave the feature the cute name \"\
    You Tarzan, Me Jane\".\n   David Faucher and Valery Smyslov helped refine the\
    \ design of the\n   Traffic Selector negotiation.\n"
- title: 8.  References
  contents:
  - '8.  References

    '
- title: 8.1.  Normative References
  contents:
  - "8.1.  Normative References\n   [ADDGROUP] Kivinen, T. and M. Kojo, \"More Modular\
    \ Exponential (MODP)\n              Diffie-Hellman groups for Internet Key Exchange\
    \ (IKE)\",\n              RFC 3526, May 2003.\n   [ADDRIPV6] Hinden, R. and S.\
    \ Deering, \"IP Version 6 Addressing\n              Architecture\", RFC 4291,\
    \ February 2006.\n   [AEAD]     Black, D. and D. McGrew, \"Using Authenticated\
    \ Encryption\n              Algorithms with the Encrypted Payload of the Internet\
    \ Key\n              Exchange version 2 (IKEv2) Protocol\", RFC 5282,\n      \
    \        August 2008.\n   [AESCMACPRF128]\n              Song, J., Poovendran,\
    \ R., Lee, J., and T. Iwata, \"The\n              Advanced Encryption Standard-Cipher-based\
    \ Message\n              Authentication Code-Pseudo-Random Function-128 (AES-CMAC-\n\
    \              PRF-128) Algorithm for the Internet Key Exchange Protocol\n   \
    \           (IKE)\", RFC 4615, August 2006.\n   [AESXCBCPRF128]\n            \
    \  Hoffman, P., \"The AES-XCBC-PRF-128 Algorithm for the\n              Internet\
    \ Key Exchange Protocol (IKE)\", RFC 4434,\n              February 2006.\n   [EAP]\
    \      Aboba, B., Blunk, L., Vollbrecht, J., Carlson, J., and H.\n           \
    \   Levkowetz, \"Extensible Authentication Protocol (EAP)\",\n              RFC\
    \ 3748, June 2004.\n   [ECN]      Ramakrishnan, K., Floyd, S., and D. Black, \"\
    The Addition\n              of Explicit Congestion Notification (ECN) to IP\"\
    ,\n              RFC 3168, September 2001.\n   [ESPCBC]   Pereira, R. and R. Adams,\
    \ \"The ESP CBC-Mode Cipher\n              Algorithms\", RFC 2451, November 1998.\n\
    \   [HTTP]     Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,\n           \
    \   Masinter, L., Leach, P., and T. Berners-Lee, \"Hypertext\n              Transfer\
    \ Protocol -- HTTP/1.1\", RFC 2616, June 1999.\n   [IKEV2IANA]\n             \
    \ \"Internet Key Exchange Version 2 (IKEv2) Parameters\",\n              <http://www.iana.org>.\n\
    \   [IPSECARCH]\n              Kent, S. and K. Seo, \"Security Architecture for\
    \ the\n              Internet Protocol\", RFC 4301, December 2005.\n   [MUSTSHOULD]\n\
    \              Bradner, S., \"Key words for use in RFCs to Indicate\n        \
    \      Requirement Levels\", BCP 14, RFC 2119, March 1997.\n   [PKCS1]    Jonsson,\
    \ J. and B. Kaliski, \"Public-Key Cryptography\n              Standards (PKCS)\
    \ #1: RSA Cryptography Specifications\n              Version 2.1\", RFC 3447,\
    \ February 2003.\n   [PKIX]     Cooper, D., Santesson, S., Farrell, S., Boeyen,\
    \ S.,\n              Housley, R., and W. Polk, \"Internet X.509 Public Key\n \
    \             Infrastructure Certificate and Certificate Revocation List\n   \
    \           (CRL) Profile\", RFC 5280, May 2008.\n   [RFC4307]  Schiller, J.,\
    \ \"Cryptographic Algorithms for Use in the\n              Internet Key Exchange\
    \ Version 2 (IKEv2)\", RFC 4307,\n              December 2005.\n   [UDPENCAPS]\n\
    \              Huttunen, A., Swander, B., Volpe, V., DiBurro, L., and M.\n   \
    \           Stenberg, \"UDP Encapsulation of IPsec ESP Packets\",\n          \
    \    RFC 3948, January 2005.\n   [URLS]     Berners-Lee, T., Fielding, R., and\
    \ L. Masinter, \"Uniform\n              Resource Identifier (URI): Generic Syntax\"\
    , STD 66,\n              RFC 3986, January 2005.\n"
- title: 8.2.  Informative References
  contents:
  - "8.2.  Informative References\n   [AH]       Kent, S., \"IP Authentication Header\"\
    , RFC 4302,\n              December 2005.\n   [ARCHGUIDEPHIL]\n              Bush,\
    \ R. and D. Meyer, \"Some Internet Architectural\n              Guidelines and\
    \ Philosophy\", RFC 3439, December 2002.\n   [ARCHPRINC]\n              Carpenter,\
    \ B., \"Architectural Principles of the Internet\",\n              RFC 1958, June\
    \ 1996.\n   [Clarif]   Eronen, P. and P. Hoffman, \"IKEv2 Clarifications and\n\
    \              Implementation Guidelines\", RFC 4718, October 2006.\n   [DES]\
    \      American National Standards Institute, \"American National\n          \
    \    Standard for Information Systems-Data Link Encryption\",\n              ANSI\
    \ X3.106, 1983.\n   [DH]       Diffie, W. and M. Hellman, \"New Directions in\n\
    \              Cryptography\", IEEE Transactions on Information Theory,\n    \
    \          V.IT-22 n. 6, June 1977.\n   [DIFFSERVARCH]\n              Blake, S.,\
    \ Black, D., Carlson, M., Davies, E., Wang, Z.,\n              and W. Weiss, \"\
    An Architecture for Differentiated\n              Services\", RFC 2475, December\
    \ 1998.\n   [DIFFSERVFIELD]\n              Nichols, K., Blake, S., Baker, F.,\
    \ and D. Black,\n              \"Definition of the Differentiated Services Field\
    \ (DS\n              Field) in the IPv4 and IPv6 Headers\", RFC 2474,\n      \
    \        December 1998.\n   [DIFFTUNNEL]\n              Black, D., \"Differentiated\
    \ Services and Tunnels\",\n              RFC 2983, October 2000.\n   [DOI]   \
    \   Piper, D., \"The Internet IP Security Domain of\n              Interpretation\
    \ for ISAKMP\", RFC 2407, November 1998.\n   [DOSUDPPROT]\n              C. Kaufman,\
    \ R. Perlman, and B. Sommerfeld, \"DoS protection\n              for UDP-based\
    \ protocols\", ACM Conference on Computer and\n              Communications Security,\
    \ October 2003.\n   [DSS]      National Institute of Standards and Technology,\
    \ U.S.\n              Department of Commerce, \"Digital Signature Standard\",\n\
    \              Draft FIPS 186-3, June 2008.\n   [EAI]      Abel, Y., \"Internationalized\
    \ Email Headers\", RFC 5335,\n              September 2008.\n   [EAP-IANA] \"\
    Extensible Authentication Protocol (EAP) Registry: Method\n              Types\"\
    , <http://www.iana.org>.\n   [EAPMITM]  N. Asokan, V. Nierni, and K. Nyberg, \"\
    Man-in-the-Middle in\n              Tunneled Authentication Protocols\", November\
    \ 2002,\n              <http://eprint.iacr.org/2002/163>.\n   [ESP]      Kent,\
    \ S., \"IP Encapsulating Security Payload (ESP)\",\n              RFC 4303, December\
    \ 2005.\n   [EXCHANGEANALYSIS]\n              R. Perlman and C. Kaufman, \"Analysis\
    \ of the IPsec key\n              exchange Standard\", WET-ICE Security Conference,\
    \ MIT,\n              2001,\n              <http://sec.femto.org/wetice-2001/papers/radia-paper.pdf>.\n\
    \   [H2HIPSEC] Aura, T., Roe, M., and A. Mohammed, \"Experiences with\n      \
    \        Host-to-Host IPsec\", 13th International Workshop on\n              Security\
    \ Protocols, Cambridge, UK, April 2005.\n   [HMAC]     Krawczyk, H., Bellare,\
    \ M., and R. Canetti, \"HMAC: Keyed-\n              Hashing for Message Authentication\"\
    , RFC 2104,\n              February 1997.\n   [IDEA]     X. Lai, \"On the Design\
    \ and Security of Block Ciphers\", ETH\n              Series in Information Processing,\
    \ v. 1, Konstanz: Hartung-\n              Gorre Verlag, 1992.\n   [IDNA]     Klensin,\
    \ J., \"Internationalized Domain Names for\n              Applications (IDNA):\
    \ Definitions and Document Framework\",\n              RFC 5890, August 2010.\n\
    \   [IKEV1]    Harkins, D. and D. Carrel, \"The Internet Key Exchange\n      \
    \        (IKE)\", RFC 2409, November 1998.\n   [IKEV2]    Kaufman, C., \"Internet\
    \ Key Exchange (IKEv2) Protocol\",\n              RFC 4306, December 2005.\n \
    \  [IP]       Postel, J., \"Internet Protocol\", STD 5, RFC 791,\n           \
    \   September 1981.\n   [IP-COMP]  Shacham, A., Monsour, B., Pereira, R., and\
    \ M. Thomas, \"IP\n              Payload Compression Protocol (IPComp)\", RFC\
    \ 3173,\n              September 2001.\n   [IPSECARCH-OLD]\n              Kent,\
    \ S. and R. Atkinson, \"Security Architecture for the\n              Internet\
    \ Protocol\", RFC 2401, November 1998.\n   [IPV6CONFIG]\n              Eronen,\
    \ P., Laganier, J., and C. Madson, \"IPv6\n              Configuration in Internet\
    \ Key Exchange Protocol Version 2\n              (IKEv2)\", RFC 5739, February\
    \ 2010.\n   [ISAKMP]   Maughan, D., Schneider, M., and M. Schertler, \"Internet\n\
    \              Security Association and Key Management Protocol\n            \
    \  (ISAKMP)\", RFC 2408, November 1998.\n   [MAILFORMAT]\n              Resnick,\
    \ P., Ed., \"Internet Message Format\", RFC 5322,\n              October 2008.\n\
    \   [MD5]      Rivest, R., \"The MD5 Message-Digest Algorithm\", RFC 1321,\n \
    \             April 1992.\n   [MIPV6]    Johnson, D., Perkins, C., and J. Arkko,\
    \ \"Mobility Support\n              in IPv6\", RFC 3775, June 2004.\n   [MLDV2]\
    \    Vida, R. and L. Costa, \"Multicast Listener Discovery\n              Version\
    \ 2 (MLDv2) for IPv6\", RFC 3810, June 2004.\n   [MOBIKE]   Eronen, P., \"IKEv2\
    \ Mobility and Multihoming Protocol\n              (MOBIKE)\", RFC 4555, June\
    \ 2006.\n   [MODES]    National Institute of Standards and Technology, U.S.\n\
    \              Department of Commerce, \"Recommendation for Block Cipher\n   \
    \           Modes of Operation\", SP 800-38A, 2001.\n   [NAI]      Aboba, B.,\
    \ Beadles, M., Arkko, J., and P. Eronen, \"The\n              Network Access Identifier\"\
    , RFC 4282, December 2005.\n   [NATREQ]   Aboba, B. and W. Dixon, \"IPsec-Network\
    \ Address Translation\n              (NAT) Compatibility Requirements\", RFC 3715,\
    \ March 2004.\n   [OAKLEY]   Orman, H., \"The OAKLEY Key Determination Protocol\"\
    ,\n              RFC 2412, November 1998.\n   [PFKEY]    McDonald, D., Metz, C.,\
    \ and B. Phan, \"PF_KEY Key\n              Management API, Version 2\", RFC 2367,\
    \ July 1998.\n   [PHOTURIS] Karn, P. and W. Simpson, \"Photuris: Session-Key Management\n\
    \              Protocol\", RFC 2522, March 1999.\n   [RANDOMNESS]\n          \
    \    Eastlake, D., Schiller, J., and S. Crocker, \"Randomness\n              Requirements\
    \ for Security\", BCP 106, RFC 4086, June 2005.\n   [REAUTH]   Nir, Y., \"Repeated\
    \ Authentication in Internet Key Exchange\n              (IKEv2) Protocol\", RFC\
    \ 4478, April 2006.\n   [REUSE]    Menezes, A. and B. Ustaoglu, \"On Reusing Ephemeral\
    \ Keys In\n              Diffie-Hellman  Key Agreement Protocols\", December 2008,\n\
    \              <http://www.cacr.math.uwaterloo.ca/techreports/2008/\n        \
    \      cacr2008-24.pdf>.\n   [ROHCV2]   Ertekin, E., Christou, C., Jasani, R.,\
    \ Kivinen, T., and C.\n              Bormann, \"IKEv2 Extensions to Support Robust\
    \ Header\n              Compression over IPsec\", RFC 5857, May 2010.\n   [RSA]\
    \      R. Rivest, A. Shamir, and L. Adleman, \"A Method for\n              Obtaining\
    \ Digital Signatures and Public-Key\n              Cryptosystems\", February 1978.\n\
    \   [SHA]      National Institute of Standards and Technology, U.S.\n        \
    \      Department of Commerce, \"Secure Hash Standard\",\n              FIPS 180-3,\
    \ October 2008.\n   [SIGMA]    H. Krawczyk, \"SIGMA: the `SIGn-and-MAc' Approach\
    \ to\n              Authenticated Diffie-Hellman and its Use in the IKE\n    \
    \          Protocols\", Advances in Cryptography - CRYPTO 2003\n             \
    \ Proceedings LNCS 2729, 2003, <http://\n              www.informatik.uni-trier.de/~ley/db/conf/crypto/\n\
    \              crypto2003.html>.\n   [SKEME]    H. Krawczyk, \"SKEME: A Versatile\
    \ Secure Key Exchange\n              Mechanism for Internet\", IEEE Proceedings\
    \ of the 1996\n              Symposium on Network and Distributed Systems Security\
    \ ,\n              1996.\n   [TRANSPARENCY]\n              Carpenter, B., \"Internet\
    \ Transparency\", RFC 2775,\n              February 2000.\n"
- title: Appendix A.  Summary of Changes from IKEv1
  contents:
  - "Appendix A.  Summary of Changes from IKEv1\n   The goals of this revision to\
    \ IKE are:\n   1.   To define the entire IKE protocol in a single document,\n\
    \        replacing RFCs 2407, 2408, and 2409 and incorporating subsequent\n  \
    \      changes to support NAT Traversal, Extensible Authentication, and\n    \
    \    Remote Address acquisition;\n   2.   To simplify IKE by replacing the eight\
    \ different initial\n        exchanges with a single four-message exchange (with\
    \ changes in\n        authentication mechanisms affecting only a single AUTH payload\n\
    \        rather than restructuring the entire exchange) see\n        [EXCHANGEANALYSIS];\n\
    \   3.   To remove the Domain of Interpretation (DOI), Situation (SIT),\n    \
    \    and Labeled Domain Identifier fields, and the Commit and\n        Authentication\
    \ only bits;\n   4.   To decrease IKE's latency in the common case by making the\n\
    \        initial exchange be 2 round trips (4 messages), and allowing the\n  \
    \      ability to piggyback setup of a Child SA on that exchange;\n   5.   To\
    \ replace the cryptographic syntax for protecting the IKE\n        messages themselves\
    \ with one based closely on ESP to simplify\n        implementation and security\
    \ analysis;\n   6.   To reduce the number of possible error states by making the\n\
    \        protocol reliable (all messages are acknowledged) and sequenced.\n  \
    \      This allows shortening CREATE_CHILD_SA exchanges from 3 messages\n    \
    \    to 2;\n   7.   To increase robustness by allowing the responder to not do\n\
    \        significant processing until it receives a message proving that\n   \
    \     the initiator can receive messages at its claimed IP address;\n   8.   To\
    \ fix cryptographic weaknesses such as the problem with\n        symmetries in\
    \ hashes used for authentication (documented by Tero\n        Kivinen);\n   9.\
    \   To specify Traffic Selectors in their own payloads type rather\n        than\
    \ overloading ID payloads, and making more flexible the\n        Traffic Selectors\
    \ that may be specified;\n   10.  To specify required behavior under certain error\
    \ conditions or\n        when data that is not understood is received in order\
    \ to make it\n        easier to make future revisions in a way that does not break\n\
    \        backward compatibility;\n   11.  To simplify and clarify how shared state\
    \ is maintained in the\n        presence of network failures and DoS attacks;\
    \ and\n   12.  To maintain existing syntax and magic numbers to the extent\n \
    \       possible to make it likely that implementations of IKEv1 can be\n    \
    \    enhanced to support IKEv2 with minimum effort.\n"
- title: Appendix B.  Diffie-Hellman Groups
  contents:
  - "Appendix B.  Diffie-Hellman Groups\n   There are two Diffie-Hellman groups defined\
    \ here for use in IKE.\n   These groups were generated by Richard Schroeppel at\
    \ the University\n   of Arizona.  Properties of these primes are described in\
    \ [OAKLEY].\n   The strength supplied by group 1 may not be sufficient for typical\n\
    \   uses and is here for historic reasons.\n   Additional Diffie-Hellman groups\
    \ have been defined in [ADDGROUP].\n"
- title: B.1.  Group 1 - 768-bit MODP
  contents:
  - "B.1.  Group 1 - 768-bit MODP\n   This group is assigned ID 1 (one).\n   The prime\
    \ is: 2^768 - 2 ^704 - 1 + 2^64 * { [2^638 pi] + 149686 }\n   Its hexadecimal\
    \ value is:\n   FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1\n   29024E08\
    \ 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD\n   EF9519B3 CD3A431B 302B0A6D\
    \ F25F1437 4FE1356D 6D51C245\n   E485B576 625E7EC6 F44C42E9 A63A3620 FFFFFFFF\
    \ FFFFFFFF\n   The generator is 2.\n"
- title: B.2.  Group 2 - 1024-bit MODP
  contents:
  - "B.2.  Group 2 - 1024-bit MODP\n   This group is assigned ID 2 (two).\n   The\
    \ prime is 2^1024 - 2^960 - 1 + 2^64 * { [2^894 pi] + 129093 }.\n   Its hexadecimal\
    \ value is:\n   FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1\n   29024E08\
    \ 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD\n   EF9519B3 CD3A431B 302B0A6D\
    \ F25F1437 4FE1356D 6D51C245\n   E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6\
    \ F406B7ED\n   EE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE65381\n   FFFFFFFF\
    \ FFFFFFFF\n   The generator is 2.\n"
- title: Appendix C.  Exchanges and Payloads
  contents:
  - "Appendix C.  Exchanges and Payloads\n   This appendix contains a short summary\
    \ of the IKEv2 exchanges, and\n   what payloads can appear in which message. \
    \ This appendix is purely\n   informative; if it disagrees with the body of this\
    \ document, the\n   other text is considered correct.\n   Vendor ID (V) payloads\
    \ may be included in any place in any message.\n   This sequence here shows what\
    \ are the most logical places for them.\n"
- title: C.1.  IKE_SA_INIT Exchange
  contents:
  - "C.1.  IKE_SA_INIT Exchange\n   request             --> [N(COOKIE)],\n       \
    \                    SA, KE, Ni,\n                           [N(NAT_DETECTION_SOURCE_IP)+,\n\
    \                            N(NAT_DETECTION_DESTINATION_IP)],\n             \
    \              [V+][N+]\n   normal response     <-- SA, KE, Nr,\n   (no cookie)\
    \             [N(NAT_DETECTION_SOURCE_IP),\n                            N(NAT_DETECTION_DESTINATION_IP)],\n\
    \                           [[N(HTTP_CERT_LOOKUP_SUPPORTED)], CERTREQ+],\n   \
    \                        [V+][N+]\n   cookie response     <-- N(COOKIE),\n   \
    \                        [V+][N+]\n   different Diffie-   <-- N(INVALID_KE_PAYLOAD),\n\
    \   Hellman group           [V+][N+]\n   wanted\n"
- title: C.2.  IKE_AUTH Exchange without EAP
  contents:
  - "C.2.  IKE_AUTH Exchange without EAP\n   request             --> IDi, [CERT+],\n\
    \                           [N(INITIAL_CONTACT)],\n                          \
    \ [[N(HTTP_CERT_LOOKUP_SUPPORTED)], CERTREQ+],\n                           [IDr],\n\
    \                           AUTH,\n                           [CP(CFG_REQUEST)],\n\
    \                           [N(IPCOMP_SUPPORTED)+],\n                        \
    \   [N(USE_TRANSPORT_MODE)],\n                           [N(ESP_TFC_PADDING_NOT_SUPPORTED)],\n\
    \                           [N(NON_FIRST_FRAGMENTS_ALSO)],\n                 \
    \          SA, TSi, TSr,\n                           [V+][N+]\n   response   \
    \         <-- IDr, [CERT+],\n                           AUTH,\n              \
    \             [CP(CFG_REPLY)],\n                           [N(IPCOMP_SUPPORTED)],\n\
    \                           [N(USE_TRANSPORT_MODE)],\n                       \
    \    [N(ESP_TFC_PADDING_NOT_SUPPORTED)],\n                           [N(NON_FIRST_FRAGMENTS_ALSO)],\n\
    \                           SA, TSi, TSr,\n                           [N(ADDITIONAL_TS_POSSIBLE)],\n\
    \                           [V+][N+]\n   error in Child SA  <--  IDr, [CERT+],\n\
    \   creation                AUTH,\n                           N(error),\n    \
    \                       [V+][N+]\n"
- title: C.3.  IKE_AUTH Exchange with EAP
  contents:
  - "C.3.  IKE_AUTH Exchange with EAP\n   first request       --> IDi,\n         \
    \                  [N(INITIAL_CONTACT)],\n                           [[N(HTTP_CERT_LOOKUP_SUPPORTED)],\
    \ CERTREQ+],\n                           [IDr],\n                           [CP(CFG_REQUEST)],\n\
    \                           [N(IPCOMP_SUPPORTED)+],\n                        \
    \   [N(USE_TRANSPORT_MODE)],\n                           [N(ESP_TFC_PADDING_NOT_SUPPORTED)],\n\
    \                           [N(NON_FIRST_FRAGMENTS_ALSO)],\n                 \
    \          SA, TSi, TSr,\n                           [V+][N+]\n   first response\
    \      <-- IDr, [CERT+], AUTH,\n                           EAP,\n            \
    \               [V+][N+]\n                     / --> EAP\n   repeat 1..N times\
    \ |\n                     \\ <-- EAP\n   last request        --> AUTH\n   last\
    \ response       <-- AUTH,\n                           [CP(CFG_REPLY)],\n    \
    \                       [N(IPCOMP_SUPPORTED)],\n                           [N(USE_TRANSPORT_MODE)],\n\
    \                           [N(ESP_TFC_PADDING_NOT_SUPPORTED)],\n            \
    \               [N(NON_FIRST_FRAGMENTS_ALSO)],\n                           SA,\
    \ TSi, TSr,\n                           [N(ADDITIONAL_TS_POSSIBLE)],\n       \
    \                    [V+][N+]\n"
- title: C.4.  CREATE_CHILD_SA Exchange for Creating or Rekeying Child SAs
  contents:
  - "C.4.  CREATE_CHILD_SA Exchange for Creating or Rekeying Child SAs\n   request\
    \             --> [N(REKEY_SA)],\n                           [CP(CFG_REQUEST)],\n\
    \                           [N(IPCOMP_SUPPORTED)+],\n                        \
    \   [N(USE_TRANSPORT_MODE)],\n                           [N(ESP_TFC_PADDING_NOT_SUPPORTED)],\n\
    \                           [N(NON_FIRST_FRAGMENTS_ALSO)],\n                 \
    \          SA, Ni, [KEi], TSi, TSr\n                           [V+][N+]\n   normal\
    \              <-- [CP(CFG_REPLY)],\n   response                [N(IPCOMP_SUPPORTED)],\n\
    \                           [N(USE_TRANSPORT_MODE)],\n                       \
    \    [N(ESP_TFC_PADDING_NOT_SUPPORTED)],\n                           [N(NON_FIRST_FRAGMENTS_ALSO)],\n\
    \                           SA, Nr, [KEr], TSi, TSr,\n                       \
    \    [N(ADDITIONAL_TS_POSSIBLE)]\n                           [V+][N+]\n   error\
    \ case          <-- N(error)\n   different Diffie-   <-- N(INVALID_KE_PAYLOAD),\n\
    \   Hellman group           [V+][N+]\n   wanted\n"
- title: C.5.  CREATE_CHILD_SA Exchange for Rekeying the IKE SA
  contents:
  - "C.5.  CREATE_CHILD_SA Exchange for Rekeying the IKE SA\n   request          \
    \   --> SA, Ni, KEi\n                           [V+][N+]\n   response        \
    \    <-- SA, Nr, KEr\n                           [V+][N+]\n"
- title: C.6.  INFORMATIONAL Exchange
  contents:
  - "C.6.  INFORMATIONAL Exchange\n   request             --> [N+],\n            \
    \               [D+],\n                           [CP(CFG_REQUEST)]\n   response\
    \            <-- [N+],\n                           [D+],\n                   \
    \        [CP(CFG_REPLY)]\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Charlie Kaufman\n   Microsoft\n   1 Microsoft Way\n  \
    \ Redmond, WA  98052\n   US\n   Phone: 1-425-707-3335\n   EMail: charliek@microsoft.com\n\
    \   Paul Hoffman\n   VPN Consortium\n   127 Segre Place\n   Santa Cruz, CA  95060\n\
    \   US\n   Phone: 1-831-426-9827\n   EMail: paul.hoffman@vpnc.org\n   Yoav Nir\n\
    \   Check Point Software Technologies Ltd.\n   5 Hasolelim St.\n   Tel Aviv 67897\n\
    \   Israel\n   EMail: ynir@checkpoint.com\n   Pasi Eronen\n   Independent\n  \
    \ EMail: pe@iki.fi\n"
