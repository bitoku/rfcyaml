- title: __initial_text__
  contents:
  - '  Publicly Verifiable Nominations Committee (NomCom) Random Selection

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2004).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes a method for making random selections in\
    \ such\n   a way that the unbiased nature of the choice is publicly verifiable.\n\
    \   As an example, the selection of the voting members of the IETF\n   Nominations\
    \ Committee (NomCom) from the pool of eligible volunteers\n   is used.  Similar\
    \ techniques would be applicable to other cases.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction. . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  2\n   2. General Flow of a Publicly Verifiable Process . . . .\
    \ . . . . .  2\n      2.1.  Determination of the Pool . . . . . . . . . . . .\
    \ . . . .  2\n      2.2.  Publication of the Algorithm. . . . . . . . . . . .\
    \ . . .  3\n      2.3.  Publication of Selection. . . . . . . . . . . . . . .\
    \ . .  3\n   3. Randomness. . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ .  3\n      3.1.  Sources of Randomness . . . . . . . . . . . . . . . . . .\
    \  3\n      3.2.  Skew. . . . . . . . . . . . . . . . . . . . . . . . . . .  4\n\
    \      3.3.  Entropy Needed. . . . . . . . . . . . . . . . . . . . . .  4\n  \
    \ 4. A Suggested Precise Algorithm . . . . . . . . . . . . . . . . .  5\n   5.\
    \ Handling Real World Problems. . . . . . . . . . . . . . . . . .  7\n      5.1.\
    \  Uncertainty as to the Pool. . . . . . . . . . . . . . . .  7\n      5.2.  Randomness\
    \ Ambiguities. . . . . . . . . . . . . . . . . .  7\n   6. Fully Worked Example.\
    \ . . . . . . . . . . . . . . . . . . . . .  8\n   7. Security Considerations\
    \ . . . . . . . . . . . . . . . . . . . .  9\n   8. Reference Code. . . . . .\
    \ . . . . . . . . . . . . . . . . . . . 10\n   Appendix A: History of NomCom Member\
    \ Selection . . . . . . . . . . 16\n   Appendix B: Changes from RFC 2777. . .\
    \ . . . . . . . . . . . . . . 16\n   Acknowledgements . . . . . . . . . . . .\
    \ . . . . . . . . . . . . . 17\n   References . . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . . . 17\n      Normative References. . . . . . . . . . .\
    \ . . . . . . . . . . . 17\n      Informative References. . . . . . . . . . .\
    \ . . . . . . . . . . 17\n   Author's Address . . . . . . . . . . . . . . . .\
    \ . . . . . . . . . 18\n   Full Copyright Statement . . . . . . . . . . . . .\
    \ . . . . . . . . 19\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Under the IETF rules, each year ten people are randomly\
    \ selected from\n   among eligible volunteers to be the voting members of the\
    \ IETF\n   nominations committee (NomCom).  The NomCom nominates members of the\n\
    \   Internet Engineering Steering Group (IESG) and the Internet\n   Architecture\
    \ Board (IAB) as described in [RFC 3777].  The number of\n   eligible volunteers\
    \ in recent years has been around 100.\n   It is highly desirable that the random\
    \ selection of the voting NomCom\n   be done in an unimpeachable fashion so that\
    \ no reasonable charges of\n   bias or favoritism can be brought.  This is as\
    \ much for the\n   protection of the selection administrator (currently, the appointed\n\
    \   non-voting NomCom chair) from suspicion of bias as it is for the\n   protection\
    \ of the IETF.\n   A method such that public information will enable any person\
    \ to\n   verify the randomness of the selection meets this criterion.  This\n\
    \   document gives an example of such a method.\n   The method, in the form it\
    \ appears in RFC 2777, was also used by IANA\n   in February 2003 to determine\
    \ the ACE prefix for Internationalized\n   Domain Names [RFC 3490] so as to avoid\
    \ claim jumping.\n"
- title: 2.  General Flow of a Publicly Verifiable Process
  contents:
  - "2.  General Flow of a Publicly Verifiable Process\n   A selection of NomCom members\
    \ publicly verifiable as unbiased or\n   similar selection could follow the three\
    \ steps given below.\n"
- title: 2.1.  Determination of the Pool
  contents:
  - "2.1.  Determination of the Pool\n   First, determine the pool from which the\
    \ selection is to be made as\n   provided in [RFC 3777] or its successor.\n  \
    \ Volunteers are solicited by the selection administrator.  Their names\n   are\
    \ then passed through the IETF Secretariat to check eligibility.\n   (Current\
    \ eligibility criteria relate to IETF meeting attendance,\n   records of which\
    \ are maintained by the Secretariat.)  The full list\n   of eligible volunteers\
    \ is made public early enough that a reasonable\n   time can be given to resolve\
    \ any disputes as to who should be in the\n   pool.\n"
- title: 2.2.  Publication of the Algorithm
  contents:
  - "2.2.  Publication of the Algorithm\n   The exact algorithm to be used, including\
    \ the public future sources\n   of randomness, is made public.  For example, the\
    \ members of the final\n   list of eligible volunteers are ordered by publicly\
    \ numbering them,\n   some public future sources of randomness such as government\
    \ run\n   lotteries are specified, and an exact algorithm is specified whereby\n\
    \   eligible volunteers are selected based on a strong hash function\n   [RFC\
    \ 1750] of these future sources of randomness.\n"
- title: 2.3.  Publication of Selection
  contents:
  - "2.3.  Publication of Selection\n   When the pre-specified sources of randomness\
    \ produce their output,\n   those values plus a summary of the execution of the\
    \ algorithm for\n   selection should be announced so that anyone can verify that\
    \ the\n   correct randomness source values were used and the algorithm properly\n\
    \   executed.  The algorithm can be run to select, in an ordered fashion,\n  \
    \ a larger number than are actually necessary so that if any of those\n   selected\
    \ need to be passed over or replaced for any reason, an\n   ordered set of additional\
    \ alternate selections will be available.  A\n   cut off time for any complaint\
    \ that the algorithm was run with the\n   wrong inputs or not faithfully executed\
    \ must be specified to finalize\n   the output and provide a stable selection.\n"
- title: 3.  Randomness
  contents:
  - "3.  Randomness\n   The crux of the unbiased nature of the selection is that it\
    \ is based\n   in an exact, predetermined fashion on random information which\
    \ will\n   be revealed in the future and thus can not be known to the person\n\
    \   specifying the algorithm.  That random information will be used to\n   control\
    \ the selection.  The random information must be such that it\n   will be publicly\
    \ and unambiguously revealed in a timely fashion.\n   The random sources must\
    \ not include anything that any reasonable\n   person would believe to be under\
    \ the control or influence of the IETF\n   or its components, such as IETF meeting\
    \ attendance statistics,\n   numbers of documents issued, or the like.\n"
- title: 3.1.  Sources of Randomness
  contents:
  - "3.1.  Sources of Randomness\n   Examples of good information to use are winning\
    \ lottery numbers for\n   specified runnings of specified public lotteries.  Particularly\
    \ for\n   government run lotteries, great care is taken to see that they occur\n\
    \   on time and produce random quantities.  Even in the unlikely case one\n  \
    \ were to have been rigged, it would almost certainly be in connection\n   with\
    \ winning money in the lottery, not in connection with IETF use.\n   Other possibilities\
    \ are such things as the daily balance in the US\n   Treasury on a specified day,\
    \ the volume of trading on the New York\n   Stock exchange on a specified day,\
    \ etc.  (However, the reference code\n   given below will not handle integers\
    \ that are too large.)  Sporting\n   events can also be used.  (Experience has\
    \ indicated that stock prices\n   and/or volumes are a poor source of unambiguous\
    \ data due trading\n   suspensions, company mergers, delistings, splits, multiple\
    \ markets,\n   etc.)  In all cases, great care must be taken to specify exactly\
    \ what\n   quantities are being presumed random and what will be done if their\n\
    \   issuance is cancelled, delayed, or advanced.\n   It is important that the\
    \ last source of randomness, chronologically,\n   produce a substantial amount\
    \ of the entropy needed.  If most of the\n   randomness has come from the earlier\
    \ of the specified sources, and\n   someone has even limited influence on the\
    \ final source, they might do\n   an exhaustive analysis and exert such influence\
    \ so as to bias the\n   selection in the direction they wanted.  Thus it is best\
    \ for the last\n   source to be an especially strong and unbiased source of a\
    \ large\n   amount of randomness such as a government run lottery.\n   It is best\
    \ not to use too many different sources.  Every additional\n   source increases\
    \ the probability that one or more sources might be\n   delayed, cancelled, or\
    \ just plain screwed up somehow, calling into\n   play contingency provisions\
    \ or, worst of all, creating a situation\n   that was not anticipated.  This would\
    \ either require arbitrary\n   judgment by the selection administrator, defeating\
    \ the randomness of\n   the selection, or a re-run with a new set of sources,\
    \ causing much\n   delay.  Three or four would be a good number of sources.  Ten\
    \ is too\n   many.\n"
- title: 3.2.  Skew
  contents:
  - "3.2.  Skew\n   Some of the sources of randomness produce data that is not uniformly\n\
    \   distributed.  This is certainly true of volumes, prices, and horse\n   race\
    \ results, for example.  However, use of a strong mixing function\n   [RFC 1750]\
    \ will extract the available entropy and produce a hash\n   value whose bits,\
    \ remainder modulo a small divisor, etc., deviate\n   from a uniform distribution\
    \ only by an insignificant amount.\n"
- title: 3.3.  Entropy Needed
  contents:
  - "3.3.  Entropy Needed\n   What we are doing is selecting N items without replacement\
    \ from a\n   population of P items.  The number of different ways to do this is\
    \ as\n   follows, where \"!\" represents the factorial function:\n           \
    \                 P!\n                       -------------\n                 \
    \      N! * (P - N)!\n   To do this in a completely random fashion requires as\
    \ many random\n   bits as the logarithm base 2 of that quantity.  Some sample\n\
    \   calculated approximate number of random bits for the completely\n   random\
    \ selection of 10 NomCom members from various pool sizes is\n   given below:\n\
    \               Random Selection of Ten Items From Pool\n     Pool size     20\
    \   25   30   35   40   50   60   75  100  120\n     Bits needed   18   22   25\
    \   28   30   34   37   40   44   47\n   Using an inadequate number of bits means\
    \ that not all of the possible\n   sets of ten selected items would be available.\
    \  For a substantially\n   inadequate amount of entropy, there could be a significant\n\
    \   correlation between the selection of two different members of the\n   pool,\
    \ for example.  However, as a practical matter, for pool sizes\n   likely to be\
    \ encountered in IETF NomCom membership selection, 40 bits\n   of entropy should\
    \ always be adequate.  Even if there is a large pool\n   and more bits are needed\
    \ for perfect randomness, 40 bits of entropy\n   will assure only an insignificant\
    \ deviation from completely random\n   selection for the difference in probability\
    \ of selection of different\n   pool members, the correlation between the selection\
    \ of any pair of\n   pool members, etc.\n   An MD5 [RFC 1321] hash has 128 bits\
    \ and therefore can produce no more\n   than that number of bits of entropy. \
    \ However, this is more than\n   three times what is likely to ever be needed\
    \ for IETF NomCom\n   membership selection.  A even stronger hash, such as SHA-1\n\
    \   [RFC 3174], can be used if desired.\n"
- title: 4.  A Suggested Precise Algorithm
  contents:
  - "4.  A Suggested Precise Algorithm\n   It is important that a precise algorithm\
    \ be given for mixing the\n   random sources specified and making the selection\
    \ based thereon.\n   Sources suggested above produce either a single positive\
    \ number\n   (i.e., NY Stock Exchange volume in thousands of shares) or a small\n\
    \   set of positive numbers (many lotteries provide 6 numbers in the\n   range\
    \ of 1 through 40 or the like, a sporting event could produce the\n   scores of\
    \ two teams, etc.).  A suggested precise algorithm is as\n   follows:\n      1.\
    \ For each source producing multiple numeric values, represent\n         each\
    \ as a decimal number terminated by a period (or with a\n         period separating\
    \ the whole from the fractional part), without\n         leading zeroes (except\
    \ for a single leading zero if the integer\n         part is zero), and without\
    \ trailing zeroes after the period.\n      2. Order the values from each source\
    \ from smallest to the largest\n         and concatenate them and suffix the result\
    \ with a \"/\".  For\n         each source producing a single number, simply represent\
    \ it as\n         above with a suffix \"/\".  (This sorting is necessary because\n\
    \         the same lottery results, for example, are sometimes reported\n    \
    \     in the order numbers were drawn and sometimes in numeric order\n       \
    \  and such things as the scores of two sports teams that play a\n         game\
    \ has no inherent order.)\n      3. At this point you have a string for each source,\
    \ say s1/, s2/,\n         ...  Concatenate these strings in a pre-specified order,\
    \ the\n         order in which the sources were listed if not otherwise\n    \
    \     specified, and represent each character as its ASCII code\n         [ASCII]\
    \ producing \"s1/s2/.../\".\n   You then produce a sequence of random values derived\
    \ from a strong\n   mixing of these sources by calculating the MD5 hash [RFC 1321]\
    \ of\n   this string prefixed and suffixed with an all zeros two byte sequence\n\
    \   for the first value, the string prefixed and suffixed by 0x0001 for\n   the\
    \ second value, etc., treating the two bytes as a big endian\n   counter.  Treat\
    \ each of these derived \"random\" MD5 output values as a\n   positive 128-bit\
    \ multiprecision big endian integer.\n   Then totally order the pool of listed\
    \ volunteers as follows: If there\n   are P volunteers, select the first by dividing\
    \ the first derived\n   random value by P and using the remainder plus one as\
    \ the position of\n   the selectee in the published list.  Select the second by\
    \ dividing\n   the second derived random value by P-1 and using the remainder\
    \ plus\n   one as the position in the list with the first selected person\n  \
    \ eliminated.  Etc.\n   It is STRONGLY recommended that alphanumeric random sources\
    \ be\n   avoided due to the much greater difficulty in canonicalizing them in\n\
    \   an independently repeatable fashion; however, if you choose to ignore\n  \
    \ this advice and use an ASCII or similar Roman alphabet source or\n   sources,\
    \ all white space, punctuation, accents, and special\n   characters should be\
    \ removed and all letters set to upper case.  This\n   will leave only an unbroken\
    \ sequence of letters A-Z and digits 0-9\n   which can be treated as a canonicalized\
    \ number above and suffixed\n   with a \"./\".  If you choose to not just ignore\
    \ but flagrantly flout\n   this advice and try to use even more complex and harder\
    \ to\n   canonicalize internationalized text, such as UNICODE, you are on your\n\
    \   own.\n"
- title: 5.  Handling Real World Problems
  contents:
  - "5.  Handling Real World Problems\n   In the real world, problems can arise in\
    \ following the steps and flow\n   outlined in Sections 2 through 4 above.  Some\
    \ problems that have\n   actually arisen are described below with recommendations\
    \ for handling\n   them.\n"
- title: 5.1.  Uncertainty as to the Pool
  contents:
  - "5.1.  Uncertainty as to the Pool\n   Every reasonable effort should be made to\
    \ see that the published pool\n   from which selection is made is of certain and\
    \ eligible persons.\n   However, especially with compressed schedules or perhaps\
    \ someone\n   whose claim that they volunteered and are eligible has not been\n\
    \   resolved by the deadline, or a determination that someone is not\n   eligible\
    \ which occurs after the publication of the pool, it may be\n   that there are\
    \ still uncertainties.\n   The best way to handle this is to maintain the announced\
    \ schedule,\n   INCLUDE in the published pool all those whose eligibility is\n\
    \   uncertain and to keep the published pool list numbering IMMUTABLE\n   after\
    \ its publication.  If someone in the pool is later selected by\n   the algorithm\
    \ and random input but it has been determined they are\n   ineligible, they can\
    \ be skipped and the algorithm run further to make\n   an additional selection.\
    \  Thus the uncertainty only effects one\n   selection and in general no more\
    \ than a maximum of U selections where\n   there are U uncertain pool members.\n\
    \   Other courses of action are far worse.  Actual insertion or deletion\n   of\
    \ entries in the pool after its publication changes the length of\n   the list\
    \ and totally scrambles who is selected, possibly changing\n   every selection.\
    \  Insertion into the pool raises questions of where\n   to insert: at the beginning,\
    \ end, alphabetic order, ... Any such\n   choices by the selection administrator\
    \ after the random numbers are\n   known destroys the public verifiability of\
    \ fair choice.  Even if done\n   before the random numbers are known, such dinking\
    \ with the list after\n   its publication just smells bad.  There should be clear\
    \ fixed public\n   deadlines and someone who challenges their absence from the\
    \ pool\n   after the published deadline should have their challenge\n   automatically\
    \ denied for tardiness.\n"
- title: 5.2.  Randomness Ambiguities
  contents:
  - "5.2.  Randomness Ambiguities\n   The best good faith efforts have been made to\
    \ specify precise and\n   unambiguous sources of randomness.  These sources have\
    \ been made\n   public in advance and there has not been objection to them.  However,\n\
    \   it has happened that when the time comes to actually get and use this\n  \
    \ randomness, the real world has thrown a curve ball and it isn't quite\n   clear\
    \ what data to use.  Problems have particularly arisen in\n   connection with\
    \ stock prices, volumes, and financial exchange rates\n   or indices.  If volumes\
    \ that were published in thousands are\n   published in hundreds, you have a rounding\
    \ problem.  Prices that were\n   quoted in fractions or decimals can change to\
    \ the other.  If you take\n   care of every contingency that has come up in the\
    \ past, you can be\n   hit with a new one.  When this sort of thing happens, it\
    \ is generally\n   too late to announce new sources, an action which could raise\n\
    \   suspicions of its own.  About the only course of action is to make a\n   reasonable\
    \ choice within the ambiguity and depend on confidence in\n   the good faith of\
    \ the selection administrator.  With care, such cases\n   should be extremely\
    \ rare.\n   Based on these experiences, it is again recommended that public\n\
    \   lottery numbers or the like be used as the random inputs and stock\n   prices\
    \ and volumes avoided.\n"
- title: 6.  Fully Worked Example
  contents:
  - "6.  Fully Worked Example\n   Assume the following ordered list of 25 eligible\
    \ volunteers is\n   published in advance of selection:\n         1. John     \
    \    11. Pollyanna       21. Pride\n         2. Mary         12. Pendragon   \
    \    22. Sloth\n         3. Bashful      13. Pandora         23. Envy\n      \
    \   4. Dopey        14. Faith           24. Anger\n         5. Sleepy       15.\
    \ Hope            25. Kasczynski\n         6. Grouchy      16. Charity\n     \
    \    7. Doc          17. Lee\n         8. Sneazy       18. Longsuffering\n   \
    \      9. Handsome     19. Chastity\n        10. Cassandra    20. Smith\n   Assume\
    \ the following (fake example) ordered list of randomness\n   sources:\n   1.\
    \ The Kingdom of Alphaland State Lottery daily number for 1 November\n      2004\
    \ treated as a single four digit integer.\n   2. Numbers of the winning horses\
    \ at Hialeia for all races for the\n      first day on or after 13 October 2004\
    \ on which at least two races\n      are run.\n   3. The People's Democratic Republic\
    \ of Betastani State Lottery six\n      winning numbers (ignoring the seventh\
    \ \"extra\" number) for 1\n      November 2004.\n   Hypothetical randomness publicly\
    \ produced:\n       Source 1:  9319\n       Source 2:  2, 5, 12, 8, 10\n     \
    \  Source 3:  9, 18, 26, 34, 41, 45\n   Resulting key string:\n       9319./2.5.8.10.12./9.18.26.34.41.45./\n\
    \   The table below gives the hex of the MD5 of the above key string\n   bracketed\
    \ with a two byte string that is successively 0x0000, 0x0001,\n   0x0002, through\
    \ 0x0010 (16 decimal).  The divisor for the number size\n   of the remaining pool\
    \ at each stage is given and the index of the\n   selectee as per the original\
    \ number of those in the pool.\n   index        hex value of MD5        div  selected\n\
    \    1  990DD0A5692A029A98B5E01AA28F3459  25  -> 17 <-\n    2  3691E55CB63FCC37914430B2F70B5EC6\
    \  24  ->  7 <-\n    3  FE814EDF564C190AC1D25753979990FA  23  ->  2 <-\n    4\
    \  1863CCACEB568C31D7DDBDF1D4E91387  22  -> 16 <-\n    5  F4AB33DF4889F0AF29C513905BE1D758\
    \  21  -> 25 <-\n    6  13EAEB529F61ACFB9A29D0BA3A60DE4A  20  -> 23 <-\n    7\
    \  992DB77C382CA2BDB9727001F3CDCCD9  19  ->  8 <-\n    8  63AB4258ECA922976811C7F55C383CE7\
    \  18  -> 24 <-\n    9  DFBC5AC97CED01B3A6E348E3CC63F40D  17  -> 19 <-\n   10\
    \  31CB111C4A4EBE9287CEAE16FE51B909  16  -> 13 <-\n   11  07FA46C122F164C215BBC72793B189A3\
    \  15  -> 22 <-\n   12  AC52F8D75CCBE2E61AFEB3387637D501  14  ->  5 <-\n   13\
    \  53306F73E14FC0B2FBF434218D25948E  13  -> 18 <-\n   14  B5D1403501A81F9A47318BE7893B347C\
    \  12  ->  9 <-\n   15  85B10B356AA06663EF1B1B407765100A  11  ->  1 <-\n   16\
    \  3269E6CE559ABD57E2BA6AAB495EB9BD  10  ->  4 <-\n   Resulting first ten selected,\
    \ in order selected:\n         1. Lee (17)           6. Envy (23)\n         2.\
    \ Doc (7)            7. Sneazy (8)\n         3. Mary (2)           8. Anger (24)\n\
    \         4. Charity (16)       9. Chastity (19)\n         5. Kasczynski (25)\
    \   10. Pandora (13)\n   Should one of the above turn out to be ineligible or\
    \ decline to\n   serve, the next would be Sloth, number 22.\n"
- title: 7. Security Considerations
  contents:
  - "7. Security Considerations\n   Careful choice of should be made of randomness\
    \ inputs so that there\n   is no reasonable suspicion that they are under the\
    \ control of the\n   administrator.  Guidelines given above to use a small number\
    \ of\n   inputs with a substantial amount of entropy from the last should be\n\
    \   followed.  And equal care needs to be given that the algorithm\n   selected\
    \ is faithfully executed with the designated inputs values.\n   Publication of\
    \ the results and a week or so window for the community\n   of interest to duplicate\
    \ the calculations should give a reasonable\n   assurance against implementation\
    \ tampering.\n"
- title: 8.  Reference Code
  contents:
  - "8.  Reference Code\n   This code makes use of the MD5 reference code from [RFC\
    \ 1321] (\"RSA\n   Data Security, Inc.  MD5 Message-Digest Algorithm\").  The\
    \ portion of\n   the code dealing with multiple floating point numbers was written\
    \ by\n   Matt Crawford.  The original code in RFC 2777 could only handle pools\n\
    \   of up to 255 members and was extended to 2**16-1 by Erik Nordmark.\n   This\
    \ code has been extracted from this document, compiled, and\n   tested.  While\
    \ no flaws have been found, it is possible that when\n   used with some compiler\
    \ on some system some flaw will manifest\n   itself.\n   /****************************************************************\n\
    \     *\n     *  Reference code for\n     *      \"Publicly Verifiable Random\
    \ Selection\"\n     *          Donald E. Eastlake 3rd\n     *              February\
    \ 2004\n     *\n     ****************************************************************/\n\
    \    #include <limits.h>\n    #include <math.h>\n    #include <stdio.h>\n    #include\
    \ <stdlib.h>\n    #include <string.h>\n    /* From RFC 1321 */\n    #include \"\
    global.h\"\n    #include \"MD5.h\"\n    /* local prototypes */\n    int longremainder\
    \ ( unsigned short divisor,\n                        unsigned char dividend[16]\
    \ );\n    long int getinteger ( char *string );\n    double NPentropy ( int N,\
    \ int P );\n    /* limited to up to 16 inputs of up to sixteen integers each */\n\
    \    /* pool limit of 2**8-1 extended to 2**16-1 by Erik Nordmark */\n    /****************************************************************/\n\
    \    main ()\n    {\n    int         i, j,  k, k2, err, keysize, selection, usel;\n\
    \    unsigned short   remaining, *selected;\n    long int    pool, temp, array[16];\n\
    \    MD5_CTX     ctx;\n    char        buffer[257], key [800], sarray[16][256];\n\
    \    unsigned char    uc16[16], unch1, unch2;\n    pool = getinteger ( \"Type\
    \ size of pool:\\n\" );\n    if ( pool > 65535 )\n        {\n        printf (\
    \ \"Pool too big.\\n\" );\n        exit ( 1 );\n        }\n    selected = (unsigned\
    \ short *) malloc ( (size_t)pool );\n    if ( !selected )\n        {\n       \
    \ printf ( \"Out of memory.\\n\" );\n        exit ( 1 );\n        }\n    selection\
    \ = getinteger ( \"Type number of items to be selected:\\n\" );\n    if ( selection\
    \ > pool )\n        {\n        printf ( \"Pool too small.\\n\" );\n        exit\
    \ ( 1 );\n        }\n    if ( selection == pool )\n        printf ( \"All of the\
    \ pool is selected.\\n\" );\n    else\n        {\n        err = printf ( \"Approximately\
    \ %.1f bits of entropy needed.\\n\",\n                        NPentropy ( selection,\
    \ pool ) + 0.1 );\n        if ( err <= 0 ) exit ( 1 );\n        }\n    for ( i\
    \ = 0, keysize = 0; i < 16; ++i )\n        {\n        if ( keysize > 500 )\n \
    \           {\n            printf ( \"Too much input.\\n\" );\n            exit\
    \ ( 1 );\n            }\n        /* get the \"random\" inputs. echo back to user\
    \ so the user may\n           be able to tell if truncation or other glitches\
    \ occur.  */\n        err = printf (\n            \"\\nType #%d randomness or\
    \ 'end' followed by new line.\\n\"\n            \"Up to 16 integers or the word\
    \ 'float' followed by up\\n\"\n            \"to 16 x.y format reals.\\n\", i+1\
    \ );\n        if ( err <= 0 ) exit ( 1 );\n        gets ( buffer );\n        j\
    \ = sscanf ( buffer,\n                \"%ld%ld%ld%ld%ld%ld%ld%ld%ld%ld%ld%ld%ld%ld%ld%ld\"\
    ,\n            &array[0], &array[1], &array[2], &array[3],\n            &array[4],\
    \ &array[5], &array[6], &array[7],\n            &array[8], &array[9], &array[10],\
    \ &array[11],\n            &array[12], &array[13], &array[14], &array[15] );\n\
    \        if ( j == EOF )\n            exit ( j );\n        if ( !j )\n       \
    \     if ( buffer[0] == 'e' )\n                break;\n            else\n    \
    \            {   /* floating point code by Matt Crawford */\n                j\
    \ = sscanf ( buffer,\n                    \"float %ld.%[0-9]%ld.%[0-9]%ld.%[0-9]%ld.%[0-9]\"\
    \n                    \"%ld.%[0-9]%ld.%[0-9]%ld.%[0-9]%ld.%[0-9]\"\n         \
    \           \"%ld.%[0-9]%ld.%[0-9]%ld.%[0-9]%ld.%[0-9]\"\n                   \
    \ \"%ld.%[0-9]%ld.%[0-9]%ld.%[0-9]%ld.%[0-9]\",\n                    &array[0],\
    \ sarray[0], &array[1], sarray[1],\n                    &array[2], sarray[2],\
    \ &array[3], sarray[3],\n                    &array[4], sarray[4], &array[5],\
    \ sarray[5],\n                    &array[6], sarray[6], &array[7], sarray[7],\n\
    \                    &array[8], sarray[8], &array[9], sarray[9],\n           \
    \         &array[10], sarray[10], &array[11], sarray[11],\n                  \
    \  &array[12], sarray[12], &array[13], sarray[13],\n                    &array[14],\
    \ sarray[14], &array[15], sarray[15] );\n                if ( j == 0 || j & 1\
    \ )\n                    printf ( \"Bad format.\" );\n                else {\n\
    \                     for ( k = 0, j /= 2; k < j; k++ )\n                    \
    \ {\n                           /* strip trailing zeros */\n                 \
    \    for ( k2=strlen(sarray[k]); sarray[k][--k2]=='0';)\n                    \
    \       sarray[k][k2] = '\\0';\n                     err = printf ( \"%ld.%s\\\
    n\", array[k], sarray[k] );\n                     if ( err <= 0 ) exit ( 1 );\n\
    \                     keysize += sprintf ( &key[keysize], \"%ld.%s\",\n      \
    \                                    array[k], sarray[k] );\n                \
    \     }\n                     keysize += sprintf ( &key[keysize], \"/\" );\n \
    \                    }\n                }\n        else\n            {   /* sort\
    \ values, not a very efficient algorithm */\n            for ( k2 = 0; k2 < j\
    \ - 1; ++k2 )\n                for ( k = 0; k < j - 1; ++k )\n               \
    \     if ( array[k] > array[k+1] )\n                        {\n              \
    \          temp = array[k];\n                        array[k] = array[k+1];\n\
    \                        array[k+1] = temp;\n                        }\n     \
    \       for ( k = 0; k < j; ++k )\n                { /* print for user check */\n\
    \                err = printf ( \"%ld \", array[k] );\n                if ( err\
    \ <= 0 ) exit ( 1 );\n                keysize += sprintf ( &key[keysize], \"%ld.\"\
    , array[k] );\n                }\n            keysize += sprintf ( &key[keysize],\
    \ \"/\" );\n            }\n        }   /* end for i */\n    /* have obtained all\
    \ the input, now produce the output */\n    err = printf ( \"Key is:\\n %s\\n\"\
    , key );\n    if ( err <= 0 ) exit ( 1 );\n    for ( i = 0; i < pool; ++i )\n\
    \        selected [i] = (unsigned short)(i + 1);\n    printf ( \"index       \
    \ hex value of MD5        div  selected\\n\" );\n    for (   usel = 0, remaining\
    \ = (unsigned short)pool;\n            usel < selection;\n            ++usel,\
    \ --remaining )\n        {\n        unch1 = (unsigned char)usel;\n        unch2\
    \ = (unsigned char)(usel>>8);\n        /* prefix/suffix extended to 2 bytes by\
    \ Donald Eastlake */\n        MD5Init ( &ctx );\n        MD5Update ( &ctx, &unch2,\
    \ 1 );\n        MD5Update ( &ctx, &unch1, 1 );\n        MD5Update ( &ctx, (unsigned\
    \ char *)key, keysize );\n        MD5Update ( &ctx, &unch2, 1 );\n        MD5Update\
    \ ( &ctx, &unch1, 1 );\n        MD5Final ( uc16, &ctx );\n        k = longremainder\
    \ ( remaining, uc16 );\n    /* printf ( \"Remaining = %d, remainder = %d.\\n\"\
    , remaining, k ); */\n        for ( j = 0; j < pool; ++j )\n            if ( selected[j]\
    \ )\n                if ( --k < 0 )\n                    {\n                 \
    \   printf ( \"%2d  \"\n    \"%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X\
    \  \"\n    \"%2d  -> %2d <-\\n\",\n    usel+1, uc16[0],uc16[1],uc16[2],uc16[3],uc16[4],uc16[5],uc16[6],\n\
    \    uc16[7],uc16[8],uc16[9],uc16[10],uc16[11],uc16[12],uc16[13],\n    uc16[14],uc16[15],\
    \ remaining, selected[j] );\n                    selected[j] = 0;\n          \
    \          break;\n                    }\n        }\n     printf ( \"\\nDone,\
    \ type any character to exit.\\n\" );\n     getchar ();\n     return 0;\n    \
    \ }\n     /* prompt for a positive non-zero integer input */\n     /****************************************************************/\n\
    \     long int getinteger ( char *string )\n     {\n     long int     i;\n   \
    \  int          j;\n     char    tin[257];\n     while ( 1 )\n     {\n     printf\
    \ ( string );\n     printf ( \"(or 'exit' to exit) \" );\n     gets ( tin );\n\
    \     j = sscanf ( tin, \"%ld\", &i );\n     if (    ( j == EOF )\n         ||\
    \  ( !j && ( ( tin[0] == 'e' ) || ( tin[0] == 'E' ) ) )\n             )\n    \
    \     exit ( j );\n     if ( ( j == 1 ) &&\n          ( i > 0 ) )\n         return\
    \ i;\n     }   /* end while */\n     }\n     /* get remainder of dividing a 16\
    \ byte unsigned int\n        by a small positive number */\n     /****************************************************************/\n\
    \     int longremainder ( unsigned short divisor,\n                         unsigned\
    \ char dividend[16] )\n     {\n     int i;\n     long int kruft;\n     if ( !divisor\
    \ )\n         return -1;\n     for ( i = 0, kruft = 0; i < 16; ++i )\n       \
    \  {\n         kruft = ( kruft << 8 ) + dividend[i];\n         kruft %= divisor;\n\
    \         }\n     return kruft;\n     }   /* end longremainder */\n    /* calculate\
    \ how many bits of entropy it takes to select N from P */\n    /****************************************************************/\n\
    \    /*             P!\n      log  ( ----------------- )\n         2    N! * (\
    \ P - N )!\n    */\n    double NPentropy ( int N, int P )\n    {\n    int    \
    \     i;\n    double      result = 0.0;\n    if (    ( N < 1 )   /* not selecting\
    \ anything? */\n       ||   ( N >= P )  /* selecting all of pool or more? */\n\
    \       )\n        return 0.0;     /* degenerate case */\n    for ( i = P; i >\
    \ ( P - N ); --i )\n        result += log ( i );\n    for ( i = N; i > 1; --i\
    \ )\n        result -= log ( i );\n    /* divide by [ log (base e) of 2 ] to convert\
    \ to bits */\n    result /= 0.69315;\n    return result;\n    }   /* end NPentropy\
    \ */\n"
- title: 'Appendix A: History of NomCom Member Selection'
  contents:
  - "Appendix A: History of NomCom Member Selection\n   For reference purposes, here\
    \ is a list of the IETF Nominations\n   Committee member selection techniques\
    \ and chairs so far:\n           YEAR      CHAIR               SELECTION METHOD\n\
    \        1993/1994  Jeff Case             Clergy\n        1994/1995  Fred Baker\
    \            Clergy\n        1995/1996  Guy Almes             Clergy\n       \
    \ 1996/1997  Geoff Huston          Spouse\n        1997/1998  Mike St.Johns  \
    \       Algorithm\n        1998/1999  Donald Eastlake 3rd   RFC 2777\n       \
    \ 1999/2000  Avri Doria            RFC 2777\n        2000/2001  Bernard Aboba\
    \         RFC 2777\n        2001/2002  Theodore Ts'o         RFC 2777\n      \
    \  2002/2003  Phil Roberts          RFC 2777\n        2003/2004  Rich Draves \
    \          RFC 2777\n   Clergy = Names were written on pieces of paper, placed\
    \ in a\n   receptacle, and a member of the clergy picked the NomCom members.\n\
    \   Spouse = Same as Clergy except chair's spouse made the selection.\n   Algorithm\
    \ = Algorithmic selection based on similar concepts to those\n   documented in\
    \ RFC 2777 and herein.\n   RFC 2777 = Algorithmic selection using the algorithm\
    \ and reference\n   code provided in RFC 2777 (but not the fake example sources\
    \ of\n   randomness).\n"
- title: 'Appendix B: Changes from RFC 2777'
  contents:
  - "Appendix B: Changes from RFC 2777\n   This document differs from [RFC 2777],\
    \ the previous version, in three\n   primary ways as follows:\n   (1) Section\
    \ 5, on problems actually encountered with using these\n       recommendations\
    \ for selecting an IETF NomCom and on how to handle\n       them, has been added.\n\
    \   (2) The selection algorithm code has been modified to handle pools of\n  \
    \     up to 2**16-1 elements and the counter based prefix and suffix\n       concatenated\
    \ with the key string before hashing has been extended\n       to two bytes.\n\
    \   (3) Mention has been added that the algorithm documented herein was\n    \
    \   used by IANA to select the Internationalized Domain Name ACE\n       prefix\
    \ and some minor wording changes made.\n   (4) References have been divided into\
    \ Informative and Normative.\n   (5) The list in Appendix A has been brought up\
    \ to date.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   Matt Crawford and Erik Nordmark made major contributions\
    \ to this\n   document.  Comments by Bernard Aboba, Theodore Ts'o, Jim Galvin,\n\
    \   Steve Bellovin, and others have been incorporated.\n"
- title: References
  contents:
  - 'References

    '
- title: Normative References
  contents:
  - "Normative References\n   [ASCII]    \"USA Standard Code for Information Interchange\"\
    , X3.4,\n              American National Standards Institute: New York, 1968.\n\
    \   [RFC 1321] Rivest, R., \"The MD5 Message-Digest Algorithm\", RFC 1321,\n \
    \             April 1992.\n   [RFC 1750] Eastlake, 3rd, D., Crocker, S. and J.\
    \ Schiller,\n              \"Randomness Recommendations for Security\", RFC 1750,\n\
    \              December 1994.\n   [RFC 3174] Eastlake, 3rd, D. and P. Jones, \"\
    US Secure Hash Algorithm\n              1 (SHA1)\", RFC 3174, September 2001.\n"
- title: Informative References
  contents:
  - "Informative References\n   [RFC 3777] Galvin, J., \"IAB and IESG Selection, Confirmation,\
    \ and\n              Recall Process: Operation of the Nominating and Recall\n\
    \              Committees\", BCP 10, RFC 3777, April 2004.\n   [RFC 2777] Eastlake,\
    \ 3rd, D., \"Publicly Verifiable Nomcom Random\n              Selection\", RFC\
    \ 2777, February 2000.\n   [RFC 3490] Falstrom, P., Hoffman, P. and A. Costello,\n\
    \              \"Internationalizing Domain Names in Applications (IDNA)\",\n \
    \             RFC 3490, March 2003.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Donald E. Eastlake, 3rd\n   Motorola Laboratories\n   155\
    \ Beaver Street\n   Milford, MA 01757 USA\n   Phone: +1-508-786-7554(w)\n    \
    \      +1-508-634-2066(h)\n   EMail: Donald.Eastlake@motorola.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2004).  This\
    \ document is subject\n   to the rights, licenses and restrictions contained in\
    \ BCP 78, and\n   except as set forth therein, the authors retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at ietf-\n   ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
