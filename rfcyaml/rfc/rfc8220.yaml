- title: __initial_text__
  contents:
  - "                  Protocol Independent Multicast (PIM)\n                over\
    \ Virtual Private LAN Service (VPLS)\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes the procedures and recommendations for\n\
    \   Virtual Private LAN Service (VPLS) Provider Edges (PEs) to facilitate\n  \
    \ replication of multicast traffic to only certain ports (behind which\n   there\
    \ are interested Protocol Independent Multicast (PIM) routers\n   and/or Internet\
    \ Group Management Protocol (IGMP) hosts) via PIM\n   snooping and proxying.\n\
    \   With PIM snooping, PEs passively listen to certain PIM control\n   messages\
    \ to build control and forwarding states while transparently\n   flooding those\
    \ messages.  With PIM proxying, PEs do not flood PIM\n   Join/Prune messages but\
    \ only generate their own and send them out of\n   certain ports, based on the\
    \ control states built from downstream\n   Join/Prune messages.  PIM proxying\
    \ is required when PIM Join\n   suppression is enabled on the Customer Edge (CE)\
    \ devices and is\n   useful for reducing PIM control traffic in a VPLS domain.\n\
    \   This document also describes PIM relay, which can be viewed as\n   lightweight\
    \ proxying, where all downstream Join/Prune messages are\n   simply forwarded\
    \ out of certain ports and are not flooded, thereby\n   avoiding the triggering\
    \ of PIM Join suppression on CE devices.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It represents the consensus\
    \ of the IETF community.  It has\n   received public review and has been approved\
    \ for publication by the\n   Internet Engineering Steering Group (IESG).  Not\
    \ all documents\n   approved by the IESG are a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 7841.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   https://www.rfc-editor.org/info/rfc8220.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2017 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n\
    \      1.1. Multicast Snooping in VPLS .................................5\n  \
    \    1.2. Assumptions ................................................6\n    \
    \  1.3. Definitions ................................................6\n      1.4.\
    \ Requirements Language ......................................7\n   2. PIM Snooping\
    \ for VPLS ...........................................7\n      2.1. PIM Protocol\
    \ Background ....................................7\n      2.2. General Rules for\
    \ PIM Snooping in VPLS .....................8\n           2.2.1. Preserving Assert\
    \ Triggers ..........................8\n      2.3. Some Considerations for PIM\
    \ Snooping .......................9\n           2.3.1. Scaling .............................................9\n\
    \           2.3.2. IPv4 and IPv6 ......................................10\n  \
    \         2.3.3. PIM-SM (*,*,RP) ....................................10\n    \
    \  2.4. PIM Snooping vs. PIM Proxying .............................10\n      \
    \     2.4.1. Differences between PIM Snooping, Relay,\n                  and Proxying\
    \ .......................................10\n           2.4.2. PIM Control Message\
    \ Latency ........................11\n           2.4.3. When to Snoop and When\
    \ to Proxy ....................12\n      2.5. Discovering PIM Routers ...................................13\n\
    \      2.6. PIM-SM and PIM-SSM ........................................14\n  \
    \         2.6.1. Building PIM-SM States .............................15\n    \
    \       2.6.2. Explanation for Per-(S,G,N) States .................17\n      \
    \     2.6.3. Receiving (*,G) PIM-SM Join/Prune Messages .........18\n        \
    \   2.6.4. Receiving (S,G) PIM-SM Join/Prune Messages .........20\n          \
    \ 2.6.5. Receiving (S,G,rpt) Join/Prune Messages ............22\n           2.6.6.\
    \ Sending Join/Prune Messages Upstream ...............23\n      2.7. Bidirectional\
    \ PIM (BIDIR-PIM) .............................24\n      2.8. Interaction with\
    \ IGMP Snooping ............................24\n      2.9. PIM-DM ....................................................25\n\
    \           2.9.1. Building PIM-DM States .............................25\n  \
    \         2.9.2. PIM-DM Downstream Per-Port PIM(S,G,N) State\n               \
    \   Machine ............................................25\n           2.9.3.\
    \ Triggering Assert Election in PIM-DM ...............26\n      2.10. PIM Proxy\
    \ ................................................26\n           2.10.1. Upstream\
    \ PIM Proxy Behavior .......................26\n      2.11. Directly Connected\
    \ Multicast Source ......................26\n      2.12. Data-Forwarding Rules\
    \ ....................................27\n           2.12.1. PIM-SM Data-Forwarding\
    \ Rules ......................28\n           2.12.2. PIM-DM Data-Forwarding Rules\
    \ ......................29\n   3. IANA Considerations ............................................29\n\
    \   4. Security Considerations ........................................30\n  \
    \ 5. References .....................................................30\n    \
    \  5.1. Normative References ......................................30\n      5.2.\
    \ Informative References ....................................31\n   Appendix A.\
    \ BIDIR-PIM Considerations ..............................32\n     A.1. BIDIR-PIM\
    \ Data-Forwarding Rules ............................32\n   Appendix B. Example\
    \ Network Scenario ..............................33\n     B.1. PIM Snooping Example\
    \ .......................................33\n     B.2. PIM Proxy Example with\
    \ (S,G) / (*,G) Interaction ...........36\n   Acknowledgements ..................................................42\n\
    \   Contributors ......................................................42\n  \
    \ Authors' Addresses ................................................43\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   In the Virtual Private LAN Service (VPLS), the Provider\
    \ Edge (PE)\n   devices provide a logical interconnect such that Customer Edge\
    \ (CE)\n   devices belonging to a specific VPLS instance appear to be connected\n\
    \   by a single LAN.  The Forwarding Information Base (FIB) for a VPLS\n   instance\
    \ is populated dynamically by Media Access Control (MAC)\n   address learning.\
    \  Once a unicast MAC address is learned and\n   associated with a particular\
    \ Attachment Circuit (AC) or pseudowire\n   (PW), a frame destined to that MAC\
    \ address only needs to be sent on\n   that AC or PW.\n   For a frame not addressed\
    \ to a known unicast MAC address, flooding\n   has to be used.  This happens with\
    \ the following so-called \"BUM\"\n   (Broadcast, Unknown Unicast, and Multicast)\
    \ traffic:\n   o  B: The destination MAC address is a broadcast address.\n   o\
    \  U: The destination MAC address is unknown (has not been learned).\n   o  M:\
    \ The destination MAC address is a multicast address.\n   Multicast frames are\
    \ flooded because a PE cannot know where\n   corresponding multicast group members\
    \ reside.  VPLS solutions\n   (RFC 4762 [VPLS-LDP] and RFC 4761 [VPLS-BGP]) perform\
    \ replication for\n   multicast traffic at the ingress PE devices.  As stated\
    \ in the VPLS\n   Multicast Requirements document (RFC 5501 [VPLS-MCAST-REQ]),\
    \ there\n   are two issues with VPLS multicast today:\n   1.  Multicast traffic\
    \ is replicated to non-member sites.\n   2.  Multicast traffic may be replicated\
    \ when several PWs share a\n       physical path.\n   Issue 1 can be solved by\
    \ multicast snooping -- PEs learn sites with\n   multicast group members by snooping\
    \ multicast protocol control\n   messages on ACs and forward IP multicast traffic\
    \ only to member\n   sites.  This document describes the procedures to achieve\
    \ this when\n   CE devices are PIM adjacencies of each other.  Issue 2 is outside\
    \ the\n   scope of this document and is discussed in RFC 7117 [VPLS-MCAST].\n\
    \   While descriptions in this document are in the context of the VPLS,\n   the\
    \ procedures also apply to regular Layer 2 switches interconnected\n   by physical\
    \ connections, except that the PW-related concepts and\n   procedures do not apply\
    \ in that case.\n"
- title: 1.1.  Multicast Snooping in VPLS
  contents:
  - "1.1.  Multicast Snooping in VPLS\n   IGMP snooping procedures described in RFC\
    \ 4541 [IGMP-SNOOP] make sure\n   that IP multicast traffic is only sent on the\
    \ following:\n   o  ACs connecting to hosts that report related group membership\n\
    \   o  ACs connecting to routers that join related multicast groups\n   o  PWs\
    \ connecting to remote PEs that have the above-described ACs\n   Note that traffic\
    \ is always sent on ports that have point-to-point\n   connections to routers\
    \ that are attached to a LAN on which there is\n   at least one other router.\
    \  Because IGMP snooping alone cannot\n   determine if there are interested receivers\
    \ beyond those routers, we\n   always need to send traffic to these ports, even\
    \ if there are no\n   snooped group memberships.  To further restrict traffic\
    \ sent to those\n   routers, PIM snooping can be used.  This document describes\
    \ the\n   procedures for PIM snooping, including rules for when both IGMP and\n\
    \   PIM snooping are enabled in a VPLS instance; see Sections 2.8 and\n   2.11\
    \ for details.\n   Note that for both IGMP and PIM, the term \"snooping\" is used\
    \ loosely,\n   referring to the fact that a Layer 2 device peeks into Layer 3\n\
    \   routing protocol messages to build relevant control and forwarding\n   states.\
    \  Depending on whether the control messages are transparently\n   flooded, selectively\
    \ forwarded, or aggregated, the processing may be\n   called \"snooping\" or \"\
    proxying\" in different contexts.\n   We will use the term \"PIM snooping\" in\
    \ this document; however, unless\n   explicitly noted otherwise, the procedures\
    \ apply equally to PIM\n   snooping and PIM proxying.  The procedures specific\
    \ to PIM proxying\n   are described in Section 2.6.6.  Differences that need to\
    \ be observed\n   while implementing one or the other and recommendations on which\n\
    \   method to employ in different scenarios are noted in Section 2.4.\n   This\
    \ document also describes PIM relay, which can be viewed as\n   lightweight PIM\
    \ proxying.  Unless explicitly noted otherwise, in the\n   rest of this document\
    \ proxying implicitly includes relay as well.\n   Please refer to Section 2.4.1\
    \ for an overview of the differences\n   between snooping, proxying, and relay.\n"
- title: 1.2.  Assumptions
  contents:
  - "1.2.  Assumptions\n   This document assumes that the reader has a good understanding\
    \ of the\n   PIM protocols.  To help correlate the concepts and make the text\n\
    \   easier to follow, this document is written in the same style as the\n   following\
    \ PIM RFCs:\n   o  RFC 3973 [PIM-DM]\n   o  RFC 4607 [PIM-SSM]\n   o  RFC 5015\
    \ [BIDIR-PIM]\n   o  RFC 5384 [JOIN-ATTR]\n   o  RFC 7761 [PIM-SM]\n   In order\
    \ to avoid replicating text related to PIM protocol handling\n   from the PIM\
    \ RFCs, this document cross-references corresponding\n   definitions and procedures\
    \ in those RFCs.  Deviations in protocol\n   handling specific to PIM snooping\
    \ are specified in this document.\n"
- title: 1.3.  Definitions
  contents:
  - "1.3.  Definitions\n   There are several definitions referenced in this document\
    \ that are\n   well described in the following PIM RFCs: RFC 3973 [PIM-DM], RFC\
    \ 5015\n   [BIDIR-PIM], and RFC 7761 [PIM-SM].  The following definitions and\n\
    \   abbreviations are used throughout this document:\n   o  A port is defined\
    \ as either an AC or a PW.\n   o  When we say that a PIM message is received on\
    \ a PE port, it means\n      that the PE is processing the message for snooping/proxying\
    \ or\n      relaying.\n   Abbreviations used in this document:\n   o  S: IP address\
    \ of the multicast source.\n   o  G: IP address of the multicast group.\n   o\
    \  N: Upstream Neighbor field in a Join/Prune/Graft message.\n   o  Port(N): Port\
    \ on which neighbor N is learned, i.e., the port on\n      which N's Hellos are\
    \ received.\n   o  rpt: Rendezvous Point Tree.\n   o  PIM-DM: Protocol Independent\
    \ Multicast - Dense Mode.\n   o  PIM-SM: Protocol Independent Multicast - Sparse\
    \ Mode.\n   o  PIM-SSM: Protocol Independent Multicast - Source-Specific\n   \
    \   Multicast.\n"
- title: 1.4.  Requirements Language
  contents:
  - "1.4.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted\
    \ as described in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear\
    \ in all\n   capitals, as shown here.\n"
- title: 2.  PIM Snooping for VPLS
  contents:
  - '2.  PIM Snooping for VPLS

    '
- title: 2.1.  PIM Protocol Background
  contents:
  - "2.1.  PIM Protocol Background\n   PIM is a multicast routing protocol running\
    \ between routers, which\n   are CE devices in a VPLS.  It uses the unicast routing\
    \ table to\n   provide reverse-path information for building multicast trees.\
    \  There\n   are a few variants of PIM.  As described in RFC 3973 [PIM-DM],\n\
    \   multicast datagrams are pushed towards downstream neighbors, similar\n   to\
    \ a broadcast mechanism, but in areas of the network where there are\n   no group\
    \ members, routers prune back branches of the multicast tree\n   towards the source.\
    \  Unlike PIM-DM, other PIM flavors (RFC 7761\n   [PIM-SM], RFC 4607 [PIM-SSM],\
    \ and RFC 5015 [BIDIR-PIM]) employ a pull\n   methodology via explicit Joins instead\
    \ of the push-and-prune\n   technique.\n   PIM routers periodically exchange Hello\
    \ messages to discover and\n   maintain stateful sessions with neighbors.  After\
    \ neighbors are\n   discovered, PIM routers can signal their intentions to join\
    \ or prune\n   specific multicast groups.  This is accomplished by having downstream\n\
    \   routers send an explicit Join/Prune message (for the sake of\n   generalization,\
    \ consider Graft messages for PIM-DM as Join messages)\n   to their corresponding\
    \ upstream router.  The Join/Prune message can\n   be group specific (*,G) or\
    \ group and source specific (S,G).\n"
- title: 2.2.  General Rules for PIM Snooping in VPLS
  contents:
  - "2.2.  General Rules for PIM Snooping in VPLS\n   The following rules for the\
    \ correct operation of PIM snooping MUST be\n   followed.\n   o  PIM snooping\
    \ MUST NOT affect the operation of customer Layer 2\n      protocols or Layer\
    \ 3 protocols.\n   o  PIM messages and multicast data traffic forwarded by PEs\
    \ MUST\n      follow the split-horizon rule for mesh PWs, as defined in RFC 4762\n\
    \      [VPLS-LDP].\n   o  PIM states in a PE MUST be per VPLS instance.\n   o\
    \  PIM Assert triggers MUST be preserved to the extent necessary to\n      avoid\
    \ sending duplicate traffic to the same PE (see\n      Section 2.2.1).\n"
- title: 2.2.1.  Preserving Assert Triggers
  contents:
  - "2.2.1.  Preserving Assert Triggers\n   In PIM-SM / PIM-DM, there are scenarios\
    \ where multiple routers could\n   be forwarding the same multicast traffic on\
    \ a LAN.  When this\n   happens, these routers start the PIM Assert election process\
    \ by\n   sending PIM Assert messages, to ensure that only the Assert winner\n\
    \   forwards multicast traffic on the LAN.  The Assert election is a\n   data-driven\
    \ event and happens only if a router sees traffic on the\n   interface to which\
    \ it should be forwarding the traffic.  In the case\n   of a VPLS with PIM snooping,\
    \ two routers may forward the same\n   multicast datagrams at the same time, but\
    \ each copy may reach a\n   different set of PEs; this is acceptable from the\
    \ point of view of\n   avoiding duplicate traffic.  If the two copies may reach\
    \ the same PE,\n   then the sending routers must be able to see each other's traffic,\
    \ in\n   order to trigger Assert election and stop duplicate traffic.  To\n  \
    \ achieve that, PEs enabled with PIM-SSM / PIM-SM snooping MUST forward\n   multicast\
    \ traffic for an (S,G) / (*,G) not only on the ports on which\n   they snooped\
    \ Join(S,G) / Join(*,G) but also towards the upstream\n   neighbor(s).  In other\
    \ words, the ports on which the upstream\n   neighbors are learned must be added\
    \ to the outgoing port list, along\n   with the ports on which Joins are snooped.\
    \  Please refer to\n   Section 2.6.1 for the rules that determine the set of upstream\n\
    \   neighbors for a particular (x,G).\n   Similarly, PIM-DM snooping SHOULD make\
    \ sure that Asserts can be\n   triggered (Section 2.9.3).\n   The above logic\
    \ needs to be facilitated without breaking VPLS\n   split-horizon forwarding rules.\
    \  That is, traffic should not be\n   forwarded on the port on which it was received,\
    \ and traffic arriving\n   on a PW MUST NOT be forwarded onto other PW(s).\n"
- title: 2.3.  Some Considerations for PIM Snooping
  contents:
  - "2.3.  Some Considerations for PIM Snooping\n   The PIM snooping solution described\
    \ here requires a PE to examine and\n   operate on only PIM Hello and PIM Join/Prune\
    \ packets.  The PE\n   does not need to examine any other PIM packets.\n   Most\
    \ of the PIM snooping procedures for handling Hello/Join/Prune\n   messages are\
    \ very similar to those executed in a PIM router.\n   However, the PE does not\
    \ need to have any routing tables like those\n   required in PIM routing.  It\
    \ knows how to forward Join/Prune messages\n   only by looking at the Upstream\
    \ Neighbor field in the Join/Prune\n   packets, as described in Section 2.12.\n\
    \   The PE does not need to know about Rendezvous Points (RPs) and\n   does not\
    \ have to maintain any RP Set.  All of that is transparent to\n   a PIM snooping\
    \ PE.\n   In the following subsections, we list some considerations and\n   observations\
    \ for the implementation of PIM snooping in the VPLS.\n"
- title: 2.3.1.  Scaling
  contents:
  - "2.3.1.  Scaling\n   PIM snooping needs to be employed on ACs at the downstream\
    \ PEs (PEs\n   receiving multicast traffic across the VPLS core) to prevent traffic\n\
    \   from being sent out of ACs unnecessarily.  PIM snooping techniques\n   can\
    \ also be employed on PWs at the upstream PEs (PEs receiving\n   traffic from\
    \ local ACs in a hierarchical VPLS) to prevent traffic\n   from being sent to\
    \ PEs unnecessarily.  This may work well for\n   small-scale or medium-scale deployments.\
    \  However, if there are a\n   large number of VPLS instances with a large number\
    \ of PEs per\n   instance, then the amount of snooping required at the upstream\
    \ PEs\n   can overwhelm the upstream PEs.\n   There are two methods to reduce\
    \ the burden on the upstream PEs.  One\n   is to use PIM proxying, as described\
    \ in Section 2.6.6, to reduce the\n   control messages forwarded by a PE.  The\
    \ other is not to snoop on the\n   PWs at all but to have PEs signal the snooped\
    \ states to other PEs out\n   of band via BGP, as described in RFC 7117 [VPLS-MCAST].\
    \  In this\n   document, it is assumed that snooping is performed on PWs.\n"
- title: 2.3.2.  IPv4 and IPv6
  contents:
  - "2.3.2.  IPv4 and IPv6\n   In the VPLS, PEs forward Ethernet frames received from\
    \ CEs and as\n   such are agnostic of the Layer 3 protocol used by the CEs.  However,\n\
    \   as a PIM snooping PE, the PE would have to look deeper into the IP\n   and\
    \ PIM packets and build snooping state based on that.  The PIM\n   protocol specifications\
    \ handle both IPv4 and IPv6.  The specification\n   for PIM snooping in this document\
    \ can be applied to both IPv4 and\n   IPv6 payloads.\n"
- title: 2.3.3.  PIM-SM (*,*,RP)
  contents:
  - "2.3.3.  PIM-SM (*,*,RP)\n   This document does not address (*,*,RP) states in\
    \ the VPLS network,\n   as they have been removed from the PIM protocol as described\
    \ in\n   RFC 7761 [PIM-SM].\n"
- title: 2.4.  PIM Snooping vs. PIM Proxying
  contents:
  - "2.4.  PIM Snooping vs. PIM Proxying\n   This document has previously alluded\
    \ to PIM snooping/relay/proxying.\n   Details on the PIM relay/proxying solution\
    \ are discussed in\n   Section 2.6.6.  In this section, a brief description and\
    \ comparison\n   are given.\n"
- title: 2.4.1.  Differences between PIM Snooping, Relay, and Proxying
  contents:
  - "2.4.1.  Differences between PIM Snooping, Relay, and Proxying\n   Differences\
    \ between PIM snooping and relay/proxying can be summarized\n   as follows:\n\
    \    +--------------------+---------------------+-----------------------+\n  \
    \  |     PIM snooping   |    PIM relay        |    PIM proxying       |\n    +====================|=====================|=======================+\n\
    \    | Join/Prune messages| Join/Prune messages | Join/Prune messages   |\n  \
    \  | snooped and flooded| snooped; forwarded  | consumed.  Regenerated|\n    |\
    \ according to VPLS  | as is out of certain| ones sent out of      |\n    | flooding\
    \ procedures| upstream ports      | certain upstream ports|\n    +--------------------+---------------------+-----------------------+\n\
    \    | Hello messages     | Hello messages      | Hello messages        |\n  \
    \  | snooped and flooded| snooped and flooded | snooped and flooded   |\n    |\
    \ according to VPLS  | according to VPLS   | according to VPLS     |\n    | flooding\
    \ procedures| flooding procedures | flooding procedures   |\n    +--------------------+---------------------+-----------------------+\n\
    \    | No PIM packets     | No PIM packets      | New Join/Prune        |\n  \
    \  | generated          | generated           | messages generated    |\n    +--------------------+---------------------+-----------------------+\n\
    \    | CE Join suppression| CE Join suppression | CE Join suppression   |\n  \
    \  | not allowed        | allowed             | allowed               |\n    +--------------------+---------------------+-----------------------+\n\
    \   Other than the above differences, most of the procedures are common\n   to\
    \ PIM snooping and PIM relay/proxying, unless specifically stated\n   otherwise.\n\
    \   Pure PIM snooping PEs simply snoop on PIM packets as they are being\n   forwarded\
    \ in the VPLS.  As such, they truly provide transparent LAN\n   services, since\
    \ no customer packets are modified or consumed nor are\n   new packets introduced\
    \ in the VPLS.  It is also simpler to implement\n   than PIM proxying.  However,\
    \ for PIM snooping to work correctly, it\n   is a requirement that CE routers\
    \ MUST disable Join suppression in the\n   VPLS.  Otherwise, most of the CE routers\
    \ with interest in a given\n   multicast data stream will fail to send Join/Prune\
    \ messages for that\n   stream, and the PEs will not be able to tell which ACs\
    \ and/or PWs\n   have listeners for that stream.\n   Given that a large number\
    \ of existing CE deployments do not support\n   the disabling of Join suppression\
    \ and given the operational\n   complexity for a provider to manage the disabling\
    \ of Join suppression\n   in the VPLS, it becomes a difficult solution to deploy.\
    \  Another\n   disadvantage of PIM snooping is that it does not scale as well\
    \ as PIM\n   proxying.  If there are a large number of CEs in a VPLS, then every\n\
    \   CE will see every other CE's Join/Prune messages.\n   PIM relay/proxying has\
    \ the advantage that it does not require Join\n   suppression to be disabled in\
    \ the VPLS.  Multicast as part of a VPLS\n   can be very easily provided without\
    \ requiring any changes on the CE\n   routers.  PIM relay/proxying helps scale\
    \ VPLS multicast, since\n   Join/Prune messages are only sent to certain upstream\
    \ ports instead\n   of flooded, and in cases of full proxying (vs. relay), the\
    \ PEs\n   intelligently generate only one Join/Prune message for a given\n   multicast\
    \ stream.\n   PIM proxying, however, loses the transparency argument, since\n\
    \   Join/Prune packets could get modified or even consumed at a PE.\n   Also,\
    \ new packets could get introduced in the VPLS.  However, this\n   loss of transparency\
    \ is limited to PIM Join/Prune packets.  It is in\n   the interest of optimizing\
    \ multicast in the VPLS and helping a VPLS\n   network scale much better, for\
    \ both the provider and the customer.\n   Data traffic will still be completely\
    \ transparent.\n"
- title: 2.4.2.  PIM Control Message Latency
  contents:
  - "2.4.2.  PIM Control Message Latency\n   A PIM snooping/relay/proxying PE snoops\
    \ on PIM Hello packets while\n   transparently flooding them in the VPLS.  As\
    \ such, there is no\n   latency introduced by the VPLS in the delivery of PIM\
    \ Hello packets\n   to remote CEs in the VPLS.\n   A PIM snooping PE snoops on\
    \ PIM Join/Prune packets while\n   transparently flooding them in the VPLS.  There\
    \ is no latency\n   introduced by the VPLS in the delivery of PIM Join/Prune packets\
    \ when\n   PIM snooping is employed.\n   A PIM relay/proxying PE does not simply\
    \ flood PIM Join/Prune packets.\n   This can result in additional latency for\
    \ a downstream CE to receive\n   multicast traffic after it has sent a Join. \
    \ When a downstream CE\n   prunes a multicast stream, the traffic SHOULD stop\
    \ flowing to the CE\n   with no additional latency introduced by the VPLS.\n \
    \  Performing only proxying of Join/Prune and not Hello messages keeps\n   the\
    \ PE's behavior very similar to that of a PIM router, without\n   introducing\
    \ too much additional complexity.  It keeps the PIM\n   proxying solution fairly\
    \ simple.  Since Join/Prune messages are\n   forwarded by a PE along the slow\
    \ path and all other PIM packet types\n   are forwarded along the fast path, it\
    \ is very likely that packets\n   forwarded along the fast path will arrive \"\
    ahead\" of Join/Prune\n   packets at a CE router (note the stress on the fact\
    \ that fast-path\n   messages will never arrive after Join/Prune packets).  Of\
    \ particular\n   importance are Hello packets sent along the fast path.  We can\n\
    \   construct a variety of scenarios resulting in out-of-order delivery\n   of\
    \ Hellos and Join/Prune messages.  However, there should be no\n   deviation from\
    \ normal expected behavior observed at the CE router\n   receiving these messages\
    \ out of order.\n"
- title: 2.4.3.  When to Snoop and When to Proxy
  contents:
  - "2.4.3.  When to Snoop and When to Proxy\n   From the above descriptions, factors\
    \ that affect the choice of\n   snooping/relay/proxying include:\n   o  Whether\
    \ CEs do Join suppression or not\n   o  Whether Join/Prune latency is critical\
    \ or not\n   o  Whether the scale of PIM protocol messages/states in a VPLS\n\
    \      requires the scaling benefit of proxying\n   Of the above factors, Join\
    \ suppression is the hard one -- pure\n   snooping can only be used when Join\
    \ suppression is disabled on all\n   CEs.  The latency associated with relay/proxying\
    \ is implementation\n   dependent and may not be a concern at all with a particular\n\
    \   implementation.  The scaling benefit may not be important either,\n   in that\
    \ on a real LAN with Explicit Tracking (ET) a PIM router will\n   need to receive\
    \ and process all PIM Join/Prune messages as well.\n   A PIM router indicates\
    \ that Join suppression is disabled if the T-bit\n   is set in the LAN Prune Delay\
    \ option of its Hello message.  If all\n   PIM routers on a LAN set the T-bit,\
    \ ET is possible, allowing an\n   upstream router to track all the downstream\
    \ neighbors that have Join\n   states for any (S,G) or (*,G).  This has two benefits:\n\
    \   o  No need for the Prune-Pending process -- the upstream router may\n    \
    \  immediately stop forwarding data when it receives a Prune from the\n      last\
    \ downstream neighbor and immediately prune to its upstream\n      neighbor.\n\
    \   o  For management purposes, the upstream router knows exactly which\n    \
    \  downstream routers exist for a particular Join state.\n   While full proxying\
    \ can be used with or without Join suppression on\n   CEs and does not interfere\
    \ with an upstream CE's bypass of the\n   Prune-Pending process, it does proxy\
    \ all its downstream CEs as a\n   single one to the upstream neighbors, removing\
    \ the second benefit\n   mentioned above.\n   Therefore, the general rule is that\
    \ if Join suppression is enabled on\n   one or more CEs, then proxying or relay\
    \ MUST be used, but if Join\n   suppression is known to be disabled on all CEs,\
    \ then snooping, relay,\n   or proxying MAY be used, while snooping or relay SHOULD\
    \ be used.\n   An implementation MAY choose to dynamically determine which mode\
    \ to\n   use, through the tracking of the above-mentioned T-bit in all snooped\n\
    \   PIM Hello messages, or MAY simply require static provisioning.\n"
- title: 2.5.  Discovering PIM Routers
  contents:
  - "2.5.  Discovering PIM Routers\n   A PIM snooping PE MUST snoop on PIM Hellos\
    \ received on ACs and PWs.\n   That is, the PE transparently floods the PIM Hello\
    \ while snooping on\n   it.  PIM Hellos are used by the snooping PE to discover\
    \ PIM routers\n   and their characteristics.\n   For each neighbor discovered\
    \ by a PE, it includes an entry in the PIM\n   Neighbor Database with the following\
    \ fields:\n   o  Layer 2 encapsulation for the router sending the PIM Hello.\n\
    \   o  IP address and address family of the router sending the PIM Hello.\n  \
    \ o  Port (AC/PW) on which the PIM Hello was received.\n   o  Hello Option fields.\n\
    \   The PE should be able to interpret and act on Hello Option fields as\n   currently\
    \ defined in RFC 7761 [PIM-SM].  The Option fields of\n   particular interest\
    \ in this document are:\n   o  Hello-Hold-Time\n   o  Tracking Support\n   o \
    \ Designated Router (DR) Priority\n   Please refer to RFC 7761 [PIM-SM] for a\
    \ list of the Hello Option\n   fields.  When a PIM Hello is received, the PE MUST\
    \ reset the\n   neighbor-expiry-timer to Hello-Hold-Time.  If a PE does not receive\
    \ a\n   Hello message from a router within Hello-Hold-Time, the PE MUST\n   remove\
    \ that neighbor from its PIM Neighbor Database.  If a PE\n   receives a Hello\
    \ message from a router with the Hello-Hold-Time value\n   set to zero, the PE\
    \ MUST remove that router from the PIM snooping\n   state immediately.\n   From\
    \ the PIM Neighbor Database, a PE MUST be able to use the\n   procedures defined\
    \ in RFC 7761 [PIM-SM] to identify the PIM DR in the\n   VPLS instance.  It should\
    \ also be able to determine if tracking\n   support is active in the VPLS instance.\n"
- title: 2.6.  PIM-SM and PIM-SSM
  contents:
  - "2.6.  PIM-SM and PIM-SSM\n   The key characteristic of PIM-SM and PIM-SSM is\
    \ explicit Join\n   behavior.  In this model, multicast traffic is only forwarded\
    \ to\n   locations that specifically request it.  All the procedures described\n\
    \   in this section apply to both PIM-SM and PIM-SSM, except for the fact\n  \
    \ that there is no (*,G) state in PIM-SSM.\n"
- title: 2.6.1.  Building PIM-SM States
  contents:
  - "2.6.1.  Building PIM-SM States\n   PIM-SM and PIM-SSM states are built by snooping\
    \ on the PIM-SM\n   Join/Prune messages received on ACs/PWs.\n   The downstream\
    \ state machine of a PIM-SM snooping PE very closely\n   resembles the downstream\
    \ state machine of PIM-SM routers.  The\n   downstream state consists of:\n  \
    \ Per downstream (Port,*,G):\n   o  DownstreamJPState: One of {\"NoInfo\" (NI),\
    \ \"Join\" (J),\n      \"Prune-Pending\" (PP)}\n   Per downstream (Port,*,G,N):\n\
    \   o  Prune-Pending Timer (PPT(N))\n   o  Join Expiry Timer (ET(N))\n   Per downstream\
    \ (Port,S,G):\n   o  DownstreamJPState: One of {\"NoInfo\" (NI), \"Join\" (J),\n\
    \      \"Prune-Pending\" (PP)}\n   Per downstream (Port,S,G,N):\n   o  Prune-Pending\
    \ Timer (PPT(N))\n   o  Join Expiry Timer (ET(N))\n   Per downstream (Port,S,G,rpt):\n\
    \   o  DownstreamJPRptState: One of {\"NoInfo\" (NI), \"Pruned\" (P),\n      \"\
    Prune-Pending\" (PP)}\n   Per downstream (Port,S,G,rpt,N):\n   o  Prune-Pending\
    \ Timer (PPT(N))\n   o  Join Expiry Timer (ET(N))\n   where S is the address of\
    \ the multicast source, G is the group\n   address, and N is the Upstream Neighbor\
    \ field in the Join/Prune\n   message.\n   Note that unlike the case of PIM-SM\
    \ routers, where the PPT and ET are\n   per (Interface,S,G), PIM snooping PEs\
    \ have to maintain the PPT and ET\n   per (Port,S,G,N).  The reasons for this\
    \ are explained in\n   Section 2.6.2.\n   Apart from the above states, we define\
    \ the following state\n   summarization macros:\n   UpstreamNeighbors(*,G):  If\
    \ there are one or more Join(*,G)s received\n      on any port with upstream neighbor\
    \ N and ET(N) is active, then N\n      is added to UpstreamNeighbors(*,G).  This\
    \ set is used to determine\n      if a Join(*,G) or a Prune(*,G) with upstream\
    \ neighbor N needs to\n      be sent upstream.\n   UpstreamNeighbors(S,G):  If\
    \ there are one or more Join(S,G)s received\n      on any port with upstream neighbor\
    \ N and ET(N) is active, then N\n      is added to UpstreamNeighbors(S,G).  This\
    \ set is used to determine\n      if a Join(S,G) or a Prune(S,G) with upstream\
    \ neighbor N needs to\n      be sent upstream.\n   UpstreamPorts(*,G):  This is\
    \ the set of all Port(N) ports where N is\n      in the set UpstreamNeighbors(*,G).\
    \  Multicast streams forwarded\n      using a (*,G) match MUST be forwarded to\
    \ these ports.  So,\n      UpstreamPorts(*,G) MUST be added to OutgoingPortList(*,G).\n\
    \   UpstreamPorts(S,G):  This is the set of all Port(N) ports where N is\n   \
    \   in the set UpstreamNeighbors(S,G).  UpstreamPorts(S,G) MUST be\n      added\
    \ to OutgoingPortList(S,G).\n   InheritedUpstreamPorts(S,G):  This is the union\
    \ of UpstreamPorts(S,G)\n      and UpstreamPorts(*,G).\n   UpstreamPorts(S,G,rpt):\
    \  If PruneDesired(S,G,rpt) becomes TRUE, then\n      this set is set to UpstreamPorts(*,G).\
    \  Otherwise, this set is\n      empty.  UpstreamPorts(*,G) (-) UpstreamPorts(S,G,rpt)\
    \ MUST be\n      added to OutgoingPortList(S,G).\n   UpstreamPorts(G):  This set\
    \ is the union of all the\n      UpstreamPorts(S,G) and UpstreamPorts(*,G) for\
    \ a given G.  Proxy\n      (S,G) Join/Prune and (*,G) Join/Prune messages MUST\
    \ be sent to a\n      subset of UpstreamPorts(G) as specified in Section 2.6.6.1.\n\
    \   PWPorts:  This is the set of all PWs.\n   OutgoingPortList(*,G):  This is\
    \ the set of all ports to which traffic\n      needs to be forwarded on a (*,G)\
    \ match.\n   OutgoingPortList(S,G):  This is the set of all ports to which traffic\n\
    \      needs to be forwarded on an (S,G) match.\n   See Section 2.12 (\"Data-Forwarding\
    \ Rules\") for the specification on\n   how OutgoingPortList is calculated.\n\
    \   NumETsActive(Port,*,G):  This is the number of (Port,*,G,N) entries\n    \
    \  that have the Expiry Timer running.  This macro keeps track of the\n      number\
    \ of Join(*,G)s that are received on this Port with different\n      upstream\
    \ neighbors.\n   NumETsActive(Port,S,G):  This is the number of (Port,S,G,N) entries\n\
    \      that have the Expiry Timer running.  This macro keeps track of the\n  \
    \    number of Join(S,G)s that are received on this Port with different\n    \
    \  upstream neighbors.\n   JoinAttributeTlvs(*,G):  Join Attributes (RFC 5384\
    \ [JOIN-ATTR]) are\n      TLVs that may be present in received Join(*,G) messages.\
    \  An\n      example would be Reverse Path Forwarding (RPF) Vectors (RFC 5496\n\
    \      [RPF-VECTOR]).  If present, they must be copied to\n      JoinAttributeTlvs(*,G).\n\
    \   JoinAttributeTlvs(S,G):  Join Attributes (RFC 5384 [JOIN-ATTR]) are\n    \
    \  TLVs that may be present in received Join(S,G) messages.  If\n      present,\
    \ they must be copied to JoinAttributeTlvs(S,G).\n   Since there are a few differences\
    \ between the downstream state\n   machines of PIM-SM routers and PIM-SM snooping\
    \ PEs, we specify the\n   details of the downstream state machine of PIM-SM snooping\
    \ PEs, at\n   the risk of repeating most of the text documented in RFC 7761\n\
    \   [PIM-SM].\n"
- title: 2.6.2.  Explanation for Per-(S,G,N) States
  contents:
  - "2.6.2.  Explanation for Per-(S,G,N) States\n   In PIM routing protocols, states\
    \ are built per (S,G).  On a router,\n   an (S,G) has only one RPF-Neighbor. \
    \ However, a PIM snooping PE\n   does not have the Layer 3 routing information\
    \ available to the\n   routers in order to determine the RPF-Neighbor for a multicast\
    \ flow.\n   It merely discovers it by snooping the Join/Prune message.  A PE\n\
    \   could have snooped on two or more different Join/Prune messages for\n   the\
    \ same (S,G) that could have carried different Upstream Neighbor\n   fields. \
    \ This could happen during transient network conditions or due\n   to dual-homed\
    \ sources.  A PE cannot make assumptions on which one to\n   pick but instead\
    \ must allow the CE routers to decide which upstream\n   neighbor gets elected\
    \ as the RPF-Neighbor.  And for this purpose,\n   the PE will have to track downstream\
    \ and upstream Joins and Prunes\n   per (S,G,N).\n"
- title: 2.6.3.  Receiving (*,G) PIM-SM Join/Prune Messages
  contents:
  - "2.6.3.  Receiving (*,G) PIM-SM Join/Prune Messages\n   A Join(*,G) or Prune(*,G)\
    \ is considered \"received\" if one of the\n   following conditions is met:\n\
    \   o  The port on which it arrived is not Port(N) where N is the\n      upstream\
    \ neighbor N of the Join/Prune(*,G).\n   o  If both Port(N) and the arrival port\
    \ are PWs, then there exists at\n      least one other (*,G,Nx) or (Sx,G,Nx) state\
    \ with an AC\n      UpstreamPort.\n   For simplicity, the case where both Port(N)\
    \ and the arrival port are\n   PWs is referred to as \"PW-only Join/Prune\" in\
    \ this document.  The\n   PW-only Join/Prune handling is so that the Port(N) PW\
    \ can be added to\n   the related forwarding entries' OutgoingPortList to trigger\
    \ an\n   Assert, but that is only needed for those states with AC\n   UpstreamPorts.\
    \  Note that in the PW-only case, it is OK for the\n   arrival port and Port(N)\
    \ to be the same.  See Appendix B for\n   examples.\n   When a router receives\
    \ a Join(*,G) or a Prune(*,G) with upstream\n   neighbor N, it must process the\
    \ message as defined in the state\n   machine below.  Note that the macro computations\
    \ of the various\n   macros resulting from this state machine transition are exactly\
    \ as\n   specified in RFC 7761 [PIM-SM].\n   We define the following per-port\
    \ (*,G,N) macro to help with the state\n   machine below.\n   +---------------++-------------------------------------------------+\n\
    \   |               ||                 Previous State                  |\n   |\
    \               ++-------------+--------------+--------------------+\n   | Event\
    \         || NoInfo (NI) | Join (J)     | Prune-Pending (PP) |\n   +---------------++-------------+--------------+--------------------+\n\
    \   | Receive       || -> J state  | -> J state   | -> J state         |\n   |\
    \ Join(*,G)     || Action      | Action       | Action             |\n   |   \
    \            || RxJoin(N)   | RxJoin(N)    | RxJoin(N)          |\n   +---------------++-------------+--------------+--------------------+\n\
    \   |Receive        || -           | -> PP state  | -> PP state        |\n   |Prune(*,G)\
    \ and ||             | Start PPT(N) |                    |\n   |NumETsActive<=1||\
    \             |              |                    |\n   +---------------++-------------+--------------+--------------------+\n\
    \   |Receive        || -           | -> J state   | -                  |\n   |Prune(*,G)\
    \ and ||             | Start PPT(N) |                    |\n   |NumETsActive>1\
    \ ||             |              |                    |\n   +---------------++-------------+--------------+--------------------+\n\
    \   |PPT(N) expires || -           | -> J state   | -> NI state        |\n   |\
    \               ||             | Action       | Action             |\n   |   \
    \            ||             | PPTExpiry(N) | PPTExpiry(N)       |\n   +---------------++-------------+--------------+--------------------+\n\
    \   |ET(N) expires  || -           | -> NI state  | -> NI state        |\n   |and\
    \            ||             | Action       | Action             |\n   |NumETsActive<=1||\
    \             | ETExpiry(N)  | ETExpiry(N)        |\n   +---------------++-------------+--------------+--------------------+\n\
    \   |ET(N) expires  || -           | -> J state   | -                  |\n   |and\
    \            ||             | Action       |                    |\n   |NumETsActive>1\
    \ ||             | ETExpiry(N)  |                    |\n   +---------------++-------------+--------------+--------------------+\n\
    \     Figure 1: Downstream Per-Port (*,G) State Machine in Tabular Form\n   Action\
    \ RxJoin(N):\n      If ET(N) is not already running, then start ET(N).  Otherwise,\n\
    \      restart ET(N).  If N is not already in UpstreamNeighbors(*,G),\n      then\
    \ add N to UpstreamNeighbors(*,G) and trigger a Join(*,G) with\n      upstream\
    \ neighbor N to be forwarded upstream.  If there are Join\n      Attribute TLVs\
    \ in the received (*,G) message and if they are\n      different from the recorded\
    \ JoinAttributeTlvs(*,G), then copy them\n      into JoinAttributeTlvs(*,G). \
    \ In the case of conflicting\n      attributes, the PE will need to perform conflict\
    \ resolution per\n      (N) as described in RFC 5384 [JOIN-ATTR].\n   Action PPTExpiry(N):\n\
    \      Same as Action ETExpiry(N) below, plus send a Prune-Echo(*,G) with\n  \
    \    upstream neighbor N on the downstream port.\n   Action ETExpiry(N):\n   \
    \   Disable timers ET(N) and PPT(N).  Delete Neighbor state\n      (Port,*,G,N).\
    \  If there are no other (Port,*,G) states with\n      NumETsActive(Port,*,G)\
    \ > 0, transition DownstreamJPState (RFC 7761\n      [PIM-SM]) to NoInfo.  If\
    \ there are no other (Port,*,G,N) states\n      (different ports but for the same\
    \ N), remove N from\n      UpstreamPorts(*,G) -- this will also trigger the Upstream\
    \ Finite\n      State Machine (FSM) with \"JoinDesired(*,G,N) to FALSE\".\n"
- title: 2.6.4.  Receiving (S,G) PIM-SM Join/Prune Messages
  contents:
  - "2.6.4.  Receiving (S,G) PIM-SM Join/Prune Messages\n   A Join(S,G) or Prune(S,G)\
    \ is considered \"received\" if one of the\n   following conditions is met:\n\
    \   o  The port on which it arrived is not Port(N) where N is the\n      upstream\
    \ neighbor N of the Join/Prune(S,G).\n   o  If both Port(N) and the arrival port\
    \ are PWs, then there exists at\n      least one other (*,G,Nx) or (S,G,Nx) state\
    \ with an AC\n      UpstreamPort.\n   For simplicity, the case where both Port(N)\
    \ and the arrival port are\n   PWs is referred to as \"PW-only Join/Prune\" in\
    \ this document.  The\n   PW-only Join/Prune handling is so that the Port(N) PW\
    \ can be added to\n   the related forwarding entries' OutgoingPortList to trigger\
    \ an\n   Assert, but that is only needed for those states with AC\n   UpstreamPorts.\
    \  Note that in the PW-only case, it is OK for the\n   arrival port and Port(N)\
    \ to be the same.  See Appendix B for\n   examples.\n   When a router receives\
    \ a Join(S,G) or a Prune(S,G) with upstream\n   neighbor N, it must process the\
    \ message as defined in the state\n   machine below.  Note that the macro computations\
    \ of the various\n   macros resulting from this state machine transition are exactly\
    \ as\n   specified in RFC 7761 [PIM-SM].\n   +---------------++-------------------------------------------------+\n\
    \   |               ||                 Previous State                  |\n   |\
    \               ++-------------+--------------+--------------------+\n   | Event\
    \         || NoInfo (NI) | Join (J)     | Prune-Pending (PP) |\n   +---------------++-------------+--------------+--------------------+\n\
    \   | Receive       || -> J state  | -> J state   | -> J state         |\n   |\
    \ Join(S,G)     || Action      | Action       | Action             |\n   |   \
    \            || RxJoin(N)   | RxJoin(N)    | RxJoin(N)          |\n   +---------------++-------------+--------------+--------------------+\n\
    \   |Receive        || -           | -> PP state  | -                  |\n   |Prune(S,G)\
    \ and ||             | Start PPT(N) |                    |\n   |NumETsActive<=1||\
    \             |              |                    |\n   +---------------++-------------+--------------+--------------------+\n\
    \   |Receive        || -           | -> J state   | -                  |\n   |Prune(S,G)\
    \ and ||             | Start PPT(N) |                    |\n   |NumETsActive>1\
    \ ||             |              |                    |\n   +---------------++-------------+--------------+--------------------+\n\
    \   |PPT(N) expires || -           | -> J state   | -> NI state        |\n   |\
    \               ||             | Action       | Action             |\n   |   \
    \            ||             | PPTExpiry(N) |PPTExpiry(N)        |\n   +---------------++-------------+--------------+--------------------+\n\
    \   |ET(N) expires  || -           | -> NI state  | -> NI state        |\n   |and\
    \            ||             | Action       | Action             |\n   |NumETsActive<=1||\
    \             | ETExpiry(N)  | ETExpiry(N)        |\n   +---------------++-------------+--------------+--------------------+\n\
    \   |ET(N) expires  || -           | -> J state   | -                  |\n   |and\
    \            ||             | Action       |                    |\n   |NumETsActive>1\
    \ ||             | ETExpiry(N)  |                    |\n   +---------------++-------------+--------------+--------------------+\n\
    \     Figure 2: Downstream Per-Port (S,G) State Machine in Tabular Form\n   Action\
    \ RxJoin(N):\n      If ET(N) is not already running, then start ET(N).  Otherwise,\n\
    \      restart ET(N).\n      If N is not already in UpstreamNeighbors(S,G), then\
    \ add N to\n      UpstreamNeighbors(S,G) and trigger a Join(S,G) with upstream\n\
    \      neighbor N to be forwarded upstream.  If there are Join Attribute\n   \
    \   TLVs in the received (S,G) message and if they are different from\n      the\
    \ recorded JoinAttributeTlvs(S,G), then copy them into\n      JoinAttributeTlvs(S,G).\
    \  In cases of conflicting attributes, the\n      PE will need to perform conflict\
    \ resolution per (N) as described\n      in RFC 5384 [JOIN-ATTR].\n   Action PPTExpiry(N):\n\
    \      Same as Action ETExpiry(N) below, plus send a Prune-Echo(S,G) with\n  \
    \    upstream neighbor N on the downstream port.\n   Action ETExpiry(N):\n   \
    \   Disable timers ET(N) and PPT(N).  Delete Neighbor state\n      (Port,S,G,N).\
    \  If there are no other (Port,S,G) states with\n      NumETsActive(Port,S,G)\
    \ > 0, transition DownstreamJPState to\n      NoInfo.  If there are no other (Port,S,G,N)\
    \ states (different\n      ports but for the same N), remove N from UpstreamPorts(S,G)\
    \ --\n      this will also trigger the Upstream FSM with \"JoinDesired(S,G,N)\n\
    \      to FALSE\".\n"
- title: 2.6.5.  Receiving (S,G,rpt) Join/Prune Messages
  contents:
  - "2.6.5.  Receiving (S,G,rpt) Join/Prune Messages\n   A Join(S,G,rpt) or Prune(S,G,rpt)\
    \ is \"received\" when the port on\n   which it was received is not also the port\
    \ on which the\n   upstream neighbor N of the Join/Prune(S,G,rpt) was learned.\n\
    \   While it is important to ensure that the (S,G) and (*,G) state\n   machines\
    \ allow for handling per-(S,G,N) states, it is not as\n   important for (S,G,rpt)\
    \ states.  It suffices to say that the\n   downstream (S,G,rpt) state machine\
    \ is the same as what is defined in\n   Section 4.5.3 of RFC 7761 [PIM-SM].\n"
- title: 2.6.6.  Sending Join/Prune Messages Upstream
  contents:
  - "2.6.6.  Sending Join/Prune Messages Upstream\n   This section applies only to\
    \ a PIM relay/proxying PE and not to a PIM\n   snooping PE.\n   A full PIM proxying\
    \ (not relay) PE MUST implement the Upstream FSM\n   along the lines of the procedure\
    \ described in Section 4.5.4 of\n   RFC 7761 [PIM-SM].\n   For the purposes of\
    \ the Upstream FSM, a Join or Prune message with\n   upstream neighbor N is \"\
    seen\" on a PIM relay/proxying PE if the port\n   on which the message was received\
    \ is also Port(N) and the port is an\n   AC.  The AC requirement is needed because\
    \ a Join received on the\n   Port(N) PW must not suppress this PE's Join on that\
    \ PW.\n   A PIM relay PE does not implement the Upstream FSM.  It simply\n   forwards\
    \ received Join/Prune messages out of the same set of upstream\n   ports as in\
    \ the PIM proxying case.\n   In order to correctly facilitate Asserts among the\
    \ CE routers, such\n   Join/Prune messages need to send not only towards the upstream\n\
    \   neighbor but also on certain PWs, as described below.\n   If JoinAttributeTlvs(*,G)\
    \ is not empty, then it must be encoded in a\n   Join(*,G) message sent upstream.\n\
    \   If JoinAttributeTlvs(S,G) is not empty, then it must be encoded in a\n   Join(S,G)\
    \ message sent upstream.\n"
- title: 2.6.6.1.  Where to Send Join/Prune Messages
  contents:
  - "2.6.6.1.  Where to Send Join/Prune Messages\n   The following rules apply to\
    \ both (1) forwarded (in the case of PIM\n   relay) and (2) refreshed and triggered\
    \ (in the case of PIM proxying)\n   (S,G) / (*,G) Join/Prune messages.\n   o \
    \ The Upstream Neighbor field in the Join/Prune to be sent is set to\n      the\
    \ N in the corresponding Upstream FSM.\n   o  If Port(N) is an AC, send the message\
    \ to Port(N).\n   o  Additionally, if OutgoingPortList(x,G,N) contains at least\
    \ one AC,\n      then the message MUST be sent to at least all the PWs in\n  \
    \    UpstreamPorts(G) (for (*,G)) or InheritedUpstreamPorts(S,G) (for\n      (S,G)).\
    \  Alternatively, the message MAY be sent to all PWs.\n   Sending to a subset\
    \ of PWs as described above guarantees that if\n   traffic (of the same flow)\
    \ from two upstream routers were to reach\n   this PE, then the two routers will\
    \ receive from each other,\n   triggering an Assert.\n   Sending to all PWs guarantees\
    \ that if two upstream routers both send\n   traffic for the same flow (even if\
    \ it is to different sets of\n   downstream PEs), then the two routers will receive\
    \ from each other,\n   triggering an Assert.\n"
- title: 2.7.  Bidirectional PIM (BIDIR-PIM)
  contents:
  - "2.7.  Bidirectional PIM (BIDIR-PIM)\n   Bidirectional PIM (BIDIR-PIM) is a variation\
    \ of PIM-SM.  The main\n   differences between PIM-SM and BIDIR-PIM are as follows:\n\
    \   o  There are no source-based trees, and SSM is not supported (i.e.,\n    \
    \  no (S,G) states) in BIDIR-PIM.\n   o  Multicast traffic can flow up the shared\
    \ tree in BIDIR-PIM.\n   o  To avoid forwarding loops, one router on each link\
    \ is elected as\n      the Designated Forwarder (DF) for each RP in BIDIR-PIM.\n\
    \   The main advantage of BIDIR-PIM is that it scales well for\n   many-to-many\
    \ applications.  However, the lack of source-based trees\n   means that multicast\
    \ traffic is forced to remain on the shared tree.\n   As described in RFC 5015\
    \ [BIDIR-PIM], parts of a BIDIR-PIM-enabled\n   network may forward traffic without\
    \ exchanging Join/Prune messages --\n   for instance, between DFs and the Rendezvous\
    \ Point Link (RPL).\n   As the described procedures for PIM snooping rely on the\
    \ presence of\n   Join/Prune messages, enabling PIM snooping on BIDIR-PIM networks\n\
    \   could break the BIDIR-PIM functionality.  Deploying PIM snooping on\n   BIDIR-PIM-enabled\
    \ networks will require some further study.  Some\n   thoughts on this topic are\
    \ discussed in Appendix A.\n"
- title: 2.8.  Interaction with IGMP Snooping
  contents:
  - "2.8.  Interaction with IGMP Snooping\n   Whenever IGMP snooping is enabled in\
    \ conjunction with PIM snooping in\n   the same VPLS instance, the PE SHOULD follow\
    \ these rules:\n   o  To maintain the list of multicast routers and ports on which\
    \ they\n      are attached, the PE SHOULD NOT use the rules described in\n   \
    \   RFC 4541 [IGMP-SNOOP] but SHOULD rely on the neighbors discovered\n      by\
    \ PIM snooping.  This list SHOULD then be used to apply the first\n      forwarding\
    \ rule (rule 1) listed in Section 2.1.1 of RFC 4541\n      [IGMP-SNOOP].\n   o\
    \  If the PE supports proxy reporting, an IGMP membership learned\n      only\
    \ on a port to which a PIM neighbor is attached (i.e., not\n      learned elsewhere)\
    \ SHOULD NOT be included in the summarized\n      upstream report sent to that\
    \ port.\n"
- title: 2.9.  PIM-DM
  contents:
  - "2.9.  PIM-DM\n   The key characteristic of PIM-DM is flood-and-prune behavior.\n\
    \   Shortest-path trees are built as a multicast source starts\n   transmitting.\n"
- title: 2.9.1.  Building PIM-DM States
  contents:
  - "2.9.1.  Building PIM-DM States\n   PIM-DM states are built by snooping on the\
    \ PIM-DM Join, Prune, Graft,\n   and State Refresh messages received on ACs/PWs\
    \ and State Refresh\n   messages sent on ACs/PWs.  By snooping on these PIM-DM\
    \ messages, a PE\n   builds the following states per (S,G,N) where S is the address\
    \ of the\n   multicast source, G is the group address, and N is the upstream\n\
    \   neighbor to which Prunes/Grafts are sent by downstream CEs:\n   Per PIM(S,G,N):\n\
    \      Port PIM(S,G,N) Prune State:\n      *  DownstreamPState(S,G,N,Port): One\
    \ of {\"NoInfo\" (NI),\n         \"Pruned\" (P), \"Prune-Pending\" (PP)}\n   \
    \   *  Prune-Pending Timer (PPT)\n      *  Prune Timer (PT)\n      *  Upstream\
    \ Port (valid if the PIM(S,G,N) Prune state is \"Pruned\")\n"
- title: 2.9.2.  PIM-DM Downstream Per-Port PIM(S,G,N) State Machine
  contents:
  - "2.9.2.  PIM-DM Downstream Per-Port PIM(S,G,N) State Machine\n   The downstream\
    \ per-port PIM(S,G,N) state machine is as defined in\n   Section 4.4.2 of RFC\
    \ 3973 [PIM-DM], with a few changes relevant to\n   PIM snooping.  When reading\
    \ Section 4.4.2 of RFC 3973 [PIM-DM],\n   please be aware that, for the purposes\
    \ of PIM snooping, the\n   downstream states are built per (S,G,N,Downstream-Port)\
    \ in PIM\n   snooping and not per (Downstream-Interface,S,G) as in a PIM-DM\n\
    \   router.  As noted in Section 2.9.1, the states (DownstreamPState) and\n  \
    \ timers (PPT and PT) are per (S,G,N,Port).\n"
- title: 2.9.3.  Triggering Assert Election in PIM-DM
  contents:
  - "2.9.3.  Triggering Assert Election in PIM-DM\n   Since PIM-DM is a flood-and-prune\
    \ protocol, traffic is flooded to all\n   routers unless explicitly pruned.  Since\
    \ PIM-DM routers do not prune\n   on non-RPF interfaces, PEs should typically\
    \ not receive Prunes on\n   Port(RPF-Neighbor).  So, the asserting routers should\
    \ typically be in\n   pim_oiflist(S,G).  In most cases, Assert election should\
    \ occur\n   naturally without any special handling, since data traffic will be\n\
    \   forwarded to the asserting routers.\n   However, there are some scenarios\
    \ where a Prune might be received on\n   a port that is also an upstream port.\
    \  If we prune the port from\n   pim_oiflist(S,G), then it would not be possible\
    \ for the asserting\n   routers to determine if traffic arrived on their downstream\
    \ port.\n   This can be fixed by adding pim_iifs(S,G) to pim_oiflist(S,G) so that\n\
    \   data traffic flows to the upstream ports.\n"
- title: 2.10.  PIM Proxy
  contents:
  - "2.10.  PIM Proxy\n   As noted earlier, PIM snooping will work correctly only\
    \ if Join\n   suppression is disabled in the VPLS.  If Join suppression is enabled\n\
    \   in the VPLS, then PEs MUST do PIM relay/proxying for VPLS multicast\n   to\
    \ work correctly.  This section applies specifically to full\n   proxying and\
    \ not to relay.\n"
- title: 2.10.1.  Upstream PIM Proxy Behavior
  contents:
  - "2.10.1.  Upstream PIM Proxy Behavior\n   A PIM proxying PE consumes Join/Prune\
    \ messages and regenerates PIM\n   Join/Prune messages to be sent upstream by\
    \ implementing the Upstream\n   FSM as specified in Section 4.5.4 of RFC 7761\
    \ [PIM-SM].  This is the\n   only difference from PIM relay.\n   The source IP\
    \ address in PIM packets sent upstream SHOULD be the\n   address of a PIM downstream\
    \ neighbor in the corresponding Join/Prune\n   state.  The chosen address MUST\
    \ NOT be the Upstream Neighbor field to\n   be encoded in the packet.  The Layer\
    \ 2 encapsulation for the selected\n   source IP address MUST be the encapsulation\
    \ recorded in the PIM\n   Neighbor Database for that IP address.\n"
- title: 2.11.  Directly Connected Multicast Source
  contents:
  - "2.11.  Directly Connected Multicast Source\n   PIM snooping/relay/proxying could\
    \ be enabled on a LAN that connects a\n   multicast source and a PIM First-Hop\
    \ Router (FHR).  As the FHR\n   will not send any downstream Join/Prune messages,\
    \ we will not be able\n   to establish any forwarding states for that source.\
    \  Therefore, if\n   there is a source in the CE network that connects directly\
    \ into the\n   VPLS instance, then multicast traffic from that source MUST be\
    \ sent\n   to all PIM routers on the VPLS instance in addition to the IGMP\n \
    \  receivers in the VPLS.  If there is already (S,G) or (*,G) snooping\n   state\
    \ that is formed on any PE, this will not happen per the current\n   forwarding\
    \ rules and guidelines.  So, in order to determine if\n   traffic needs to be\
    \ flooded to all routers, a PE must be able to\n   determine if the traffic came\
    \ from a host on that LAN.  There are\n   three ways to address this problem:\n\
    \   o  The PE would have to do IPv4 ARP snooping and/or IPv6 Neighbor\n      Discovery\
    \ snooping to determine if a source is directly connected.\n   o  Another option\
    \ is to configure all PEs to indicate that there are\n      CE sources that are\
    \ directly connected to the VPLS instance and\n      disallow snooping for the\
    \ groups for which the source is going to\n      send traffic.  This way, traffic\
    \ from that source to those groups\n      will always be flooded within the provider\
    \ network.\n   o  A third option is to require that sources of CE multicast traffic\n\
    \      must be behind a router.\n   This document recommends the third option\
    \ -- sources of traffic must\n   be behind a router.\n"
- title: 2.12.  Data-Forwarding Rules
  contents:
  - "2.12.  Data-Forwarding Rules\n   First, we define the rules that are common to\
    \ PIM-SM and PIM-DM PEs.\n   Forwarding rules for each protocol type are specified\
    \ in the\n   subsections below.\n   If there is no matching forwarding state,\
    \ then the PE SHOULD discard\n   the packet, i.e., the UserDefinedPortList (Sections\
    \ 2.12.1 and\n   2.12.2) SHOULD be empty.\n   The following general rules MUST\
    \ be followed when forwarding\n   multicast traffic in a VPLS:\n   o  Traffic\
    \ arriving on a port MUST NOT be forwarded back onto the\n      same port.\n \
    \  o  Due to VPLS split-horizon rules, traffic ingressing on a PW\n      MUST\
    \ NOT be forwarded to any other PW.\n"
- title: 2.12.1.  PIM-SM Data-Forwarding Rules
  contents:
  - "2.12.1.  PIM-SM Data-Forwarding Rules\n   Per the rules in RFC 7761 [PIM-SM]\
    \ and per the additional rules\n   specified in this document,\n   OutgoingPortList(*,G)\
    \ = immediate_olist(*,G) (+)\n                           UpstreamPorts(*,G) (+)\n\
    \                           Port(PimDR)\n   OutgoingPortList(S,G) = inherited_olist(S,G)\
    \ (+)\n                           UpstreamPorts(S,G) (+)\n                   \
    \        (UpstreamPorts(*,G) (-)\n                           UpstreamPorts(S,G,rpt))\
    \ (+)\n                           Port(PimDR)\n   RFC 7761 [PIM-SM] specifies\
    \ how immediate_olist(*,G) and\n   inherited_olist(S,G) are built.  PimDR is the\
    \ IP address of the\n   PIM DR in the VPLS.\n   The PIM-SM snooping data-forwarding\
    \ rules are defined below in\n   pseudocode:\n   BEGIN\n       iif is the incoming\
    \ port of the multicast packet.\n       S is the source IP address of the multicast\
    \ packet.\n       G is the destination IP address of the multicast packet.\n \
    \      If there is (S,G) state on the PE\n       Then\n           OutgoingPortList\
    \ = OutgoingPortList(S,G)\n       Else if there is (*,G) state on the PE\n   \
    \    Then\n           OutgoingPortList = OutgoingPortList(*,G)\n       Else\n\
    \           OutgoingPortList = UserDefinedPortList\n       Endif\n       If iif\
    \ is an AC\n       Then\n           OutgoingPortList = OutgoingPortList (-) iif\n\
    \       Else\n           ## iif is a PW\n           OutgoingPortList = OutgoingPortList\
    \ (-) PWPorts\n       Endif\n       Forward the packet to OutgoingPortList.\n\
    \   END\n   First, if there is (S,G) state on the PE, then the set of outgoing\n\
    \   ports is OutgoingPortList(S,G).\n   Otherwise, if there is (*,G) state on\
    \ the PE, then the set of\n   outgoing ports is OutgoingPortList(*,G).\n   The\
    \ packet is forwarded to the selected set of outgoing ports while\n   observing\
    \ the general rules above in Section 2.12.\n"
- title: 2.12.2.  PIM-DM Data-Forwarding Rules
  contents:
  - "2.12.2.  PIM-DM Data-Forwarding Rules\n   The PIM-DM snooping data-forwarding\
    \ rules are defined below in\n   pseudocode:\n   BEGIN\n       iif is the incoming\
    \ port of the multicast packet.\n       S is the source IP address of the multicast\
    \ packet.\n       G is the destination IP address of the multicast packet.\n \
    \      If there is (S,G) state on the PE\n       Then\n           OutgoingPortList\
    \ = olist(S,G)\n       Else\n           OutgoingPortList = UserDefinedPortList\n\
    \       Endif\n       If iif is an AC\n       Then\n           OutgoingPortList\
    \ = OutgoingPortList (-) iif\n       Else\n           ## iif is a PW\n       \
    \    OutgoingPortList = OutgoingPortList (-) PWPorts\n       Endif\n       Forward\
    \ the packet to OutgoingPortList.\n   END\n   If there is forwarding state for\
    \ (S,G), then forward the packet to\n   olist(S,G) while observing the general\
    \ rules above in Section 2.12.\n   RFC 3973 [PIM-DM] specifies how olist(S,G)\
    \ is constructed.\n"
- title: 3.  IANA Considerations
  contents:
  - "3.  IANA Considerations\n   This document does not require any IANA actions.\n"
- title: 4.  Security Considerations
  contents:
  - "4.  Security Considerations\n   Security considerations provided in the VPLS\
    \ solution documents\n   (i.e., RFC 4762 [VPLS-LDP] and RFC 4761 [VPLS-BGP]) apply\
    \ to this\n   document as well.\n"
- title: 5.  References
  contents:
  - '5.  References

    '
- title: 5.1.  Normative References
  contents:
  - "5.1.  Normative References\n   [BIDIR-PIM]\n              Handley, M., Kouvelas,\
    \ I., Speakman, T., and L. Vicisano,\n              \"Bidirectional Protocol Independent\
    \ Multicast\n              (BIDIR-PIM)\", RFC 5015, DOI 10.17487/RFC5015,\n  \
    \            October 2007, <https://www.rfc-editor.org/info/rfc5015>.\n   [JOIN-ATTR]\n\
    \              Boers, A., Wijnands, I., and E. Rosen, \"The Protocol\n       \
    \       Independent Multicast (PIM) Join Attribute Format\",\n              RFC\
    \ 5384, DOI 10.17487/RFC5384, November 2008,\n              <https://www.rfc-editor.org/info/rfc5384>.\n\
    \   [PIM-DM]   Adams, A., Nicholas, J., and W. Siadak, \"Protocol\n          \
    \    Independent Multicast - Dense Mode (PIM-DM): Protocol\n              Specification\
    \ (Revised)\", RFC 3973, DOI 10.17487/RFC3973,\n              January 2005, <https://www.rfc-editor.org/info/rfc3973>.\n\
    \   [PIM-SM]   Fenner, B., Handley, M., Holbrook, H., Kouvelas, I.,\n        \
    \      Parekh, R., Zhang, Z., and L. Zheng, \"Protocol Independent\n         \
    \     Multicast - Sparse Mode (PIM-SM): Protocol Specification\n             \
    \ (Revised)\", STD 83, RFC 7761, DOI 10.17487/RFC7761,\n              March 2016,\
    \ <https://www.rfc-editor.org/info/rfc7761>.\n   [PIM-SSM]  Holbrook, H. and B.\
    \ Cain, \"Source-Specific Multicast for\n              IP\", RFC 4607, DOI 10.17487/RFC4607,\
    \ August 2006,\n              <https://www.rfc-editor.org/info/rfc4607>.\n   [RFC2119]\
    \  Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement\
    \ Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n\
    \              <https://www.rfc-editor.org/info/rfc2119>.\n   [RFC8174]  Leiba,\
    \ B., \"Ambiguity of Uppercase vs Lowercase in\n              RFC 2119 Key Words\"\
    , BCP 14, RFC 8174,\n              DOI 10.17487/RFC8174, May 2017,\n         \
    \     <https://www.rfc-editor.org/info/rfc8174>.\n   [RPF-VECTOR]\n          \
    \    Wijnands, IJ., Boers, A., and E. Rosen, \"The Reverse Path\n            \
    \  Forwarding (RPF) Vector TLV\", RFC 5496,\n              DOI 10.17487/RFC5496,\
    \ March 2009,\n              <https://www.rfc-editor.org/info/rfc5496>.\n"
- title: 5.2.  Informative References
  contents:
  - "5.2.  Informative References\n   [IGMP-SNOOP]\n              Christensen, M.,\
    \ Kimball, K., and F. Solensky,\n              \"Considerations for Internet Group\
    \ Management Protocol\n              (IGMP) and Multicast Listener Discovery (MLD)\
    \ Snooping\n              Switches\", RFC 4541, DOI 10.17487/RFC4541, May 2006,\n\
    \              <https://www.rfc-editor.org/info/rfc4541>.\n   [VPLS-BGP]\n   \
    \           Kompella, K., Ed., and Y. Rekhter, Ed., \"Virtual Private\n      \
    \        LAN Service (VPLS) Using BGP for Auto-Discovery and\n              Signaling\"\
    , RFC 4761, DOI 10.17487/RFC4761, January 2007,\n              <https://www.rfc-editor.org/info/rfc4761>.\n\
    \   [VPLS-LDP]\n              Lasserre, M., Ed., and V. Kompella, Ed., \"Virtual\
    \ Private\n              LAN Service (VPLS) Using Label Distribution Protocol\
    \ (LDP)\n              Signaling\", RFC 4762, DOI 10.17487/RFC4762, January 2007,\n\
    \              <https://www.rfc-editor.org/info/rfc4762>.\n   [VPLS-MCAST]\n \
    \             Aggarwal, R., Ed., Kamite, Y., Fang, L., Rekhter, Y., and\n    \
    \          C. Kodeboniya, \"Multicast in Virtual Private LAN Service\n       \
    \       (VPLS)\", RFC 7117, DOI 10.17487/RFC7117, February 2014,\n           \
    \   <https://www.rfc-editor.org/info/rfc7117>.\n   [VPLS-MCAST-REQ]\n        \
    \      Kamite, Y., Ed., Wada, Y., Serbest, Y., Morin, T., and L.\n           \
    \   Fang, \"Requirements for Multicast Support in Virtual\n              Private\
    \ LAN Services\", RFC 5501, DOI 10.17487/RFC5501,\n              March 2009, <https://www.rfc-editor.org/info/rfc5501>.\n"
- title: Appendix A.  BIDIR-PIM Considerations
  contents:
  - "Appendix A.  BIDIR-PIM Considerations\n   This appendix describes some guidelines\
    \ that may be used to preserve\n   BIDIR-PIM functionality in combination with\
    \ PIM snooping.\n   In order to preserve BIDIR-PIM snooping, routers need to set\
    \ up\n   forwarding states so that:\n   o  on the RPL, all traffic is forwarded\
    \ to all Port(N) ports.\n   o  on any other interface, traffic is always forwarded\
    \ to the DF.\n   The information needed to set up these states may be obtained\
    \ by:\n   o  determining the mapping between the group (range) and the RP.\n \
    \  o  snooping and storing DF election information.\n   o  determining where the\
    \ RPL is.  This could be achieved by static\n      configuration or by combining\
    \ the information mentioned in the two\n      bullet items above.\n"
- title: A.1.  BIDIR-PIM Data-Forwarding Rules
  contents:
  - "A.1.  BIDIR-PIM Data-Forwarding Rules\n   The BIDIR-PIM snooping data-forwarding\
    \ rules are defined below in\n   pseudocode:\n   BEGIN\n       iif is the incoming\
    \ port of the multicast packet.\n       G is the destination IP address of the\
    \ multicast packet.\n       If there is forwarding state for G\n       Then\n\
    \           OutgoingPortList = olist(G)\n       Else\n           OutgoingPortList\
    \ = UserDefinedPortList\n       Endif\n       If iif is an AC\n       Then\n \
    \          OutgoingPortList = OutgoingPortList (-) iif\n       Else\n        \
    \   ## iif is a PW\n           OutgoingPortList = OutgoingPortList (-) PWPorts\n\
    \       Endif\n       Forward the packet to OutgoingPortList.\n   END\n   If there\
    \ is forwarding state for G, then forward the packet to\n   olist(G) while observing\
    \ the general rules above in Section 2.12.\n   RFC 5015 [BIDIR-PIM] specifies\
    \ how olist(G) is constructed.\n"
- title: Appendix B.  Example Network Scenario
  contents:
  - "Appendix B.  Example Network Scenario\n   Let us consider the scenario in Figure\
    \ 3.\n                                            +------+ AC3 +------+\n    \
    \                                        |  PE2 |-----| CE3  |\n             \
    \                              /|      |     +------+\n                      \
    \                    / +------+         |\n                                  \
    \       /     |             |\n                                        /     \
    \ |             |\n                                       /PW12   |          \
    \   |\n                                      /        |           /---\\\n   \
    \                                  /         |PW23       | S |\n             \
    \                       /          |           \\---/\n                      \
    \             /           |             |\n                                  /\
    \            |             |\n                                 /             |\
    \             |\n                       +------+ /           +------+        \
    \ |\n          +------+     |  PE1 |/   PW13     |  PE3 |     +------+\n     \
    \     | CE1  |-----|      |-------------|      |-----| CE4  |\n          +------+\
    \ AC1 +------+             +------+ AC4 +------+\n                           |\n\
    \                           |AC2\n                       +------+\n          \
    \             | CE2  |\n                       +------+\n           Figure 3:\
    \ An Example Network for Triggering an Assert\n   In the examples below, JT(Port,S,G,N)\
    \ is the downstream Join Expiry\n   Timer on the specified Port for the (S,G)\
    \ with upstream neighbor N.\n"
- title: B.1.  PIM Snooping Example
  contents:
  - "B.1.  PIM Snooping Example\n   In the network depicted in Figure 3, S is the\
    \ source of a multicast\n   stream (S,G).  CE1 and CE2 both have two ECMP routes\
    \ to reach the\n   source.\n   1.  CE1 sends a Join(S,G) with UpstreamNeighbors(S,G)\
    \ = CE3.\n   2.  PE1 snoops on the Join(S,G) and builds forwarding state, since\
    \ it\n       is received on an AC.  It also floods the Join(S,G) in the VPLS.\n\
    \       PE2 snoops on the Join(S,G) and builds forwarding state, since\n     \
    \  the Join(S,G)is targeting a neighbor residing on an AC.  PE3\n       does not\
    \ create forwarding state for (S,G) because this is a\n       PW-only Join and\
    \ there is neither an existing (*,G) state with an\n       AC in UpstreamPorts(*,G)\
    \ nor an existing (S,G) state with an AC\n       in UpstreamPorts(S,G).  Both\
    \ PE2 and PE3 will also flood the\n       Join(S,G) in the VPLS.\n       The resulting\
    \ states at the PEs are as follows:\n       PE1 states:\n          JT(AC1,S,G,CE3)\
    \        = JP_HoldTime\n          UpstreamNeighbors(S,G) = { CE3 }\n         \
    \ UpstreamPorts(S,G)     = { PW12 }\n          OutgoingPortList(S,G)  = { AC1,\
    \ PW12 }\n       PE2 states:\n          JT(PW12,S,G,CE3)       = JP_HoldTime\n\
    \          UpstreamNeighbors(S,G) = { CE3 }\n          UpstreamPorts(S,G)    \
    \ = { AC3 }\n          OutgoingPortList(S,G)  = { PW12, AC3 }\n       PE3 states:\n\
    \          No (S,G) state\n   3.  The multicast stream (S,G) flows along CE3 ->\
    \ PE2 -> PE1 -> CE1.\n   4.  Now CE2 sends a Join(S,G) with UpstreamNeighbors(S,G)\
    \ = CE4.\n   5.  All PEs snoop on the Join(S,G), build forwarding state, and flood\n\
    \       the Join(S,G) in the VPLS.  Note that for PE2, even though this\n    \
    \   is a PW-only Join, forwarding state is built on this Join(S,G),\n       since\
    \ PE2 has an existing (S,G) state with an AC in\n       UpstreamPorts(S,G).\n\
    \       The resulting states at the PEs are as follows:\n       PE1 states:\n\
    \          JT(AC1,S,G,CE3)        = active\n          JT(AC2,S,G,CE4)        =\
    \ JP_HoldTime\n          UpstreamNeighbors(S,G) = { CE3, CE4 }\n          UpstreamPorts(S,G)\
    \     = { PW12, PW13 }\n          OutgoingPortList(S,G)  = { AC1, PW12, AC2, PW13\
    \ }\n       PE2 states:\n          JT(PW12,S,G,CE4)       = JP_HoldTime\n    \
    \      JT(PW12,S,G,CE3)       = active\n          UpstreamNeighbors(S,G) = { CE3,\
    \ CE4 }\n          UpstreamPorts(S,G)     = { AC3, PW23 }\n          OutgoingPortList(S,G)\
    \  = { PW12, AC3, PW23 }\n       PE3 states:\n          JT(PW13,S,G,CE4)     \
    \  = JP_HoldTime\n          UpstreamNeighbors(S,G) = { CE4 }\n          UpstreamPorts(S,G)\
    \     = { AC4 }\n          OutgoingPortList(S,G)  = { PW13, AC4 }\n   6.  The\
    \ multicast stream (S,G) flows into the VPLS from two of the\n       CEs -- CE3\
    \ and CE4.  PE2 forwards the stream received from CE3 to\n       PW23, and PE3\
    \ forwards the stream to AC4.  This helps the CE\n       routers to trigger Assert\
    \ election.  Let us say that CE3 becomes\n       the Assert winner.\n   7.  CE3\
    \ sends an Assert message to the VPLS.  The PEs flood the\n       Assert message\
    \ without examining it.\n   8.  CE4 stops sending the multicast stream to the\
    \ VPLS.\n   9.  CE2 notices an RPF change due to the Assert and sends a\n    \
    \   Prune(S,G) with upstream neighbor = CE4.  CE2 also sends a\n       Join(S,G)\
    \ with upstream neighbor = CE3.\n   10. All the PEs start a Prune-Pending timer\
    \ on the ports on which\n       they received the Prune(S,G).  When the Prune-Pending\
    \ timer\n       expires, all PEs will remove the downstream (S,G,CE4) states.\n\
    \       The resulting states at the PEs are as follows:\n       PE1 states:\n\
    \          JT(AC1,S,G,CE3)        = active\n          UpstreamNeighbors(S,G) =\
    \ { CE3 }\n          UpstreamPorts(S,G)     = { PW12 }\n          OutgoingPortList(S,G)\
    \  = { AC1, AC2, PW12 }\n       PE2 states:\n          JT(PW12,S,G,CE3)      \
    \ = active\n          UpstreamNeighbors(S,G) = { CE3 }\n          UpstreamPorts(S,G)\
    \     = { AC3 }\n          OutgoingPortList(S,G)  = { PW12, AC3 }\n       PE3\
    \ states:\n          JT(PW13,S,G,CE3)       = JP_HoldTime\n          UpstreamNeighbors(S,G)\
    \ = { CE3 }\n          UpstreamPorts(S,G)     = { PW23 }\n          OutgoingPortList(S,G)\
    \  = { PW13, PW23 }\n       Note that at this point at PE3, since there is no\
    \ AC in\n       OutgoingPortList(S,G) and no (*,G) or (S,G) state with an AC in\n\
    \       UpstreamPorts(*,G) or UpstreamPorts(S,G), respectively, the\n       existing\
    \ (S,G) state at PE3 can also be removed.  So, finally:\n       PE3 states:\n\
    \          No (S,G) state\n   Note that at the end of the Assert election, there\
    \ should be no\n   duplicate traffic forwarded downstream, and traffic should\
    \ flow only\n   on the desired path.  Also note that there are no unnecessary\
    \ (S,G)\n   states on PE3 after the Assert election.\n"
- title: B.2.  PIM Proxy Example with (S,G) / (*,G) Interaction
  contents:
  - "B.2.  PIM Proxy Example with (S,G) / (*,G) Interaction\n   In the same network,\
    \ let us assume that CE4 is the upstream neighbor\n   towards the RP for G.\n\
    \   JPST(S,G,N) is the JP sending timer for the (S,G) with upstream\n   neighbor\
    \ N.\n   1.  CE1 sends a Join(S,G) with UpstreamNeighbors(S,G) = CE3.\n   2. \
    \ PE1 consumes the Join(S,G) and builds forwarding state, since the\n       Join(S,G)\
    \ is received on an AC.\n       PE2 consumes the Join(S,G) and builds forwarding\
    \ state, since the\n       Join(S,G) is targeting a neighbor residing on an AC.\n\
    \       PE3 consumes the Join(S,G) but does not create forwarding state\n    \
    \   for (S,G), since this is a PW-only Join and there is neither an\n       existing\
    \ (*,G) state with an AC in UpstreamPorts(*,G) nor an\n       existing (S,G) state\
    \ with an AC in UpstreamPorts(S,G).\n       The resulting states at the PEs are\
    \ as follows:\n       PE1 states:\n          JT(AC1,S,G,CE3)        = JP_HoldTime\n\
    \          JPST(S,G,CE3)          = t_periodic\n          UpstreamNeighbors(S,G)\
    \ = { CE3 }\n          UpstreamPorts(S,G)     = { PW12 }\n          OutgoingPortList(S,G)\
    \  = { AC1, PW12 }\n       PE2 states:\n          JT(PW12,S,G,CE3)       = JP_HoldTime\n\
    \          JPST(S,G,CE3)          = t_periodic\n          UpstreamNeighbors(S,G)\
    \ = { CE3 }\n          UpstreamPorts(S,G)     = { AC3 }\n          OutgoingPortList(S,G)\
    \  = { PW12, AC3 }\n       PE3 states:\n          No (S,G) state\n       Joins\
    \ are triggered as follows:\n       PE1 triggers a Join(S,G) targeting CE3.  Since\
    \ the Join(S,G) was\n       received on an AC and is targeting a neighbor that\
    \ is residing\n       across a PW, the triggered Join(S,G) is sent on all PWs.\n\
    \       PE2 triggers a Join(S,G) targeting CE3.  Since the Join(S,G) is\n    \
    \   targeting a neighbor residing on an AC, it only sends the Join\n       on\
    \ AC3.\n       PE3 ignores the Join(S,G), since this is a PW-only Join and there\n\
    \       is neither an existing (*,G) state with an AC in\n       UpstreamPorts(*,G)\
    \ nor an existing (S,G) state with an AC in\n       UpstreamPorts(S,G).\n   3.\
    \  The multicast stream (S,G) flows along CE3 -> PE2 -> PE1 -> CE1.\n   4.  Now\
    \ let us say that CE2 sends a Join(*,G) with\n       UpstreamNeighbors(*,G) =\
    \ CE4.\n   5.  PE1 consumes the Join(*,G) and builds forwarding state, since the\n\
    \       Join(*,G) is received on an AC.\n       PE2 consumes the Join(*,G); although\
    \ this is a PW-only Join,\n       forwarding state is built on this Join(*,G),\
    \ since PE2 has an\n       existing (S,G) state with an AC in UpstreamPorts(S,G).\
    \  However,\n       since this is a PW-only Join, PE2 only adds the PW towards\
    \ PE3\n       (PW23) into UpstreamPorts(*,G) and hence into\n       OutgoingPortList(*,G).\
    \  It does not add the PW towards PE1 (PW12)\n       into OutgoingPortList(*,G).\n\
    \       PE3 consumes the Join(*,G) and builds forwarding state, since the\n  \
    \     Join(*,G) is targeting a neighbor residing on an AC.\n       The resulting\
    \ states at the PEs are as follows:\n       PE1 states:\n          JT(AC1,*,G,CE4)\
    \        = JP_HoldTime\n          JPST(*,G,CE4)          = t_periodic\n      \
    \    UpstreamNeighbors(*,G) = { CE4 }\n          UpstreamPorts(*,G)     = { PW13\
    \ }\n          OutgoingPortList(*,G)  = { AC2, PW13 }\n          JT(AC1,S,G,CE3)\
    \        = active\n          JPST(S,G,CE3)          = active\n          UpstreamNeighbors(S,G)\
    \ = { CE3 }\n          UpstreamPorts(S,G)     = { PW12 }\n          OutgoingPortList(S,G)\
    \  = { AC1, PW12, PW13 }\n       PE2 states:\n          JT(PW12,*,G,CE4)     \
    \  = JP_HoldTime\n          UpstreamNeighbors(*,G) = { CE4 }\n          UpstreamPorts(G)\
    \       = { PW23 }\n          OutgoingPortList(*,G)  = { PW23 }\n          JT(PW12,S,G,CE3)\
    \       = active\n          JPST(S,G,CE3)          = active\n          UpstreamNeighbors(S,G)\
    \ = { CE3 }\n          UpstreamPorts(S,G)     = { AC3 }\n          OutgoingPortList(S,G)\
    \  = { PW12, AC3, PW23 }\n       PE3 states:\n          JT(PW13,*,G,CE4)     \
    \  = JP_HoldTime\n          JPST(*,G,CE4)          = t_periodic\n          UpstreamNeighbors(*,G)\
    \ = { CE4 }\n          UpstreamPorts(*,G)     = { AC4 }\n          OutgoingPortList(*,G)\
    \  = { PW13, AC4 }\n       Joins are triggered as follows:\n       PE1 triggers\
    \ a Join(*,G) targeting CE4.  Since the Join(*,G) was\n       received on an AC\
    \ and is targeting a neighbor that is residing\n       across a PW, the triggered\
    \ Join(S,G) is sent on all PWs.\n       PE2 does not trigger a Join(*,G) based\
    \ on this Join, since this\n       is a PW-only Join.\n       PE3 triggers a Join(*,G)\
    \ targeting CE4.  Since the Join(*,G) is\n       targeting a neighbor residing\
    \ on an AC, it only sends the Join\n       on AC4.\n   6.  If traffic is not flowing\
    \ yet (i.e., step 3 is delayed so that it\n       occurs after step 6) and in\
    \ the interim JPST(S,G,CE3) on PE1\n       expires, causing it to send a refresh\
    \ Join(S,G) targeting CE3,\n       since the refresh Join(S,G) is targeting a\
    \ neighbor that is\n       residing across a PW, the refresh Join(S,G) is sent\
    \ on all PWs.\n   7.  Note that PE1 refreshes its JT based on reception of refresh\n\
    \       Joins from CE1 and CE2.\n       PE2 consumes the Join(S,G) and refreshes\
    \ the JT(PW12,S,G,CE3)\n       timer.\n       PE3 consumes the Join(S,G).  It\
    \ also builds forwarding state on\n       this Join(S,G), even though this is\
    \ a PW-only Join, since now PE2\n       has an existing (*,G) state with an AC\
    \ in UpstreamPorts(*,G).\n       However, since this is a PW-only Join, PE3 only\
    \ adds the PW\n       towards PE2 (PW23) into UpstreamPorts(S,G) and hence into\n\
    \       OutgoingPortList(S,G).  It does not add the PW towards PE1 (PW13)\n  \
    \     into OutgoingPortList(S,G).\n       PE3 states:\n          JT(PW13,*,G,CE4)\
    \       = active\n          JPST(S,G,CE4)          = active\n          UpstreamNeighbors(*,G)\
    \ = { CE4 }\n          UpstreamPorts(*,G)     = { AC4 }\n          OutgoingPortList(*,G)\
    \  = { PW13, AC4 }\n          JT(PW13,S,G,CE3)       = JP_HoldTime\n         \
    \ UpstreamNeighbors(*,G) = { CE3 }\n          UpstreamPorts(*,G)     = { PW23\
    \ }\n          OutgoingPortList(*,G)  = { PW13, AC4, PW23 }\n       Joins are\
    \ triggered as follows:\n       PE2 already has (S,G) state, so it does not trigger\
    \ a Join(S,G)\n       based on reception of this refresh Join.\n       PE3 does\
    \ not trigger a Join(S,G) based on this Join, since this\n       is a PW-only\
    \ Join.\n   8.  The multicast stream (S,G) flows into the VPLS from two of the\n\
    \       CEs -- CE3 and CE4.  PE2 forwards the stream received from CE3 to\n  \
    \     PW12 and PW23.  At the same time, PE3 forwards the stream\n       received\
    \ from CE4 to PW13 and PW23.\n       The stream received over PW12 and PW13 is\
    \ forwarded by PE1 to AC1\n       and AC2.\n       The stream received by PE3\
    \ over PW23 is forwarded to AC4.  The\n       stream received by PE2 over PW23\
    \ is forwarded to AC3.  Either of\n       these helps the CE routers to trigger\
    \ Assert election.\n   9.  CE3 and/or CE4 send(s) Assert message(s) to the VPLS.\
    \  The PEs\n       flood the Assert message(s) without examining it.\n   10. CE3\
    \ becomes the (S,G) Assert winner, and CE4 stops sending the\n       multicast\
    \ stream to the VPLS.\n   11. CE2 notices an RPF change due to the Assert and\
    \ sends a\n       Prune(S,G,rpt) with upstream neighbor = CE4.\n   12. PE1 consumes\
    \ the Prune(S,G,rpt), and since\n       PruneDesired(S,G,Rpt,CE4) is TRUE, it\
    \ triggers a Prune(S,G,rpt)\n       to CE4.  Since the Prune is targeting a neighbor\
    \ across a PW, it\n       is sent on all PWs.\n       PE2 consumes the Prune(S,G,rpt)\
    \ and does not trigger any Prune\n       based on this Prune(S,G,rpt), since this\
    \ was a PW-only Prune.\n       PE3 consumes the Prune(S,G,rpt), and since\n  \
    \     PruneDesired(S,G,rpt,CE4) is TRUE, it sends the Prune(S,G,rpt)\n       on\
    \ AC4.\n       PE1 states:\n          JT(AC2,*,G,CE4)        = active\n      \
    \    JPST(*,G,CE4)          = active\n          UpstreamNeighbors(*,G) = { CE4\
    \ }\n          UpstreamPorts(*,G)     = { PW13 }\n          OutgoingPortList(*,G)\
    \  = { AC2, PW13 }\n          JT(AC2,S,G,CE4)        = JP_HoldTime with S,G,rpt\
    \ prune flag\n          JPST(S,G,CE4)          = none, since this is sent along\n\
    \                                   with the Join(*,G) to CE4 based\n        \
    \                           on JPST(*,G,CE4) expiry\n          UpstreamPorts(S,G,rpt)\
    \ = { PW13 }\n          UpstreamNeighbors(S,G,rpt) = { CE4 }\n          JT(AC1,S,G,CE3)\
    \        = active\n          JPST(S,G,CE3)          = active\n          UpstreamNeighbors(S,G)\
    \ = { CE3 }\n          UpstreamPorts(S,G)     = { PW12 }\n          OutgoingPortList(S,G)\
    \  = { AC1, PW12, AC2 }\n       PE2 states:\n          JT(PW12,*,G,CE4)      \
    \ = active\n          UpstreamNeighbors(*,G) = { CE4 }\n          UpstreamPorts(*,G)\
    \     = { PW23 }\n          OutgoingPortList(*,G)  = { PW23 }\n          JT(PW12,S,G,CE4)\
    \       = JP_HoldTime with S,G,rpt prune flag\n          JPST(S,G,CE4)       \
    \   = none, since this was created\n                                   off a PW-only\
    \ Prune\n          UpstreamPorts(S,G,rpt) = { PW23 }\n          UpstreamNeighbors(S,G,rpt)\
    \ = { CE4 }\n          JT(PW12,S,G,CE3)       = active\n          JPST(S,G,CE3)\
    \          = active\n          UpstreamNeighbors(S,G) = { CE3 }\n          UpstreamPorts(S,G)\
    \     = { AC3 }\n          OutgoingPortList(*,G)  = { PW12, AC3 }\n       PE3\
    \ states:\n          JT(PW13,*,G,CE4)       = active\n          JPST(*,G,CE4)\
    \          = active\n          UpstreamNeighbors(*,G) = { CE4 }\n          UpstreamPorts(*,G)\
    \     = { AC4 }\n          OutgoingPortList(*,G)  = { PW13, AC4 }\n          JT(PW13,S,G,CE4)\
    \       = JP_HoldTime with S,G,rpt prune flag\n          JPST(S,G,CE4)       \
    \   = none, since this is sent along\n                                   with\
    \ the Join(*,G) to CE4 based\n                                   on JPST(*,G,CE4)\
    \ expiry\n          UpstreamNeighbors(S,G,rpt) = { CE4 }\n          UpstreamPorts(S,G,rpt)\
    \ = { AC4 }\n          JT(PW13,S,G,CE3)       = active\n          JPST(S,G,CE3)\
    \          = none, since this state is\n                                   created\
    \ by a PW-only Join\n          UpstreamNeighbors(S,G) = { CE3 }\n          UpstreamPorts(S,G)\
    \     = { PW23 }\n          OutgoingPortList(S,G)  = { PW23 }\n   Even in this\
    \ example, at the end of the (S,G) / (*,G) Assert\n   election, there should be\
    \ no duplicate traffic forwarded downstream,\n   and traffic should flow only\
    \ to the desired CEs.\n   However, we don't have duplicate traffic because one\
    \ of the CEs stops\n   sending traffic due to the Assert, not because we don't\
    \ have any\n   forwarding state in the PEs to do this forwarding.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   Many members of the former L2VPN and PIM working groups\
    \ have\n   contributed to, and provided valuable comments and feedback on, this\n\
    \   document, including Vach Kompella, Shane Amante, Sunil Khandekar, Rob\n  \
    \ Nath, Marc Lasserre, Yuji Kamite, Yiqun Cai, Ali Sajassi, Jozef\n   Raets, Himanshu\
    \ Shah (Ciena), and Himanshu Shah (Cisco).\n"
- title: Contributors
  contents:
  - "Contributors\n   Yetik Serbest and Suresh Boddapati coauthored earlier draft\
    \ versions\n   of this document.\n   Karl (Xiangrong) Cai and Princy Elizabeth\
    \ made significant\n   contributions to bring the specification to its current\
    \ state,\n   especially in the area of Join forwarding rules.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Olivier Dornon\n   Nokia\n   Copernicuslaan 50\n   B-2018\
    \  Antwerp\n   Belgium\n   Email: olivier.dornon@nokia.com\n   Jayant Kotalwar\n\
    \   Nokia\n   701 East Middlefield Rd.\n   Mountain View, CA  94043\n   United\
    \ States of America\n   Email: jayant.kotalwar@nokia.com\n   Venu Hemige\n   Nokia\n\
    \   Email: vhemige@gmail.com\n   Ray Qiu\n   mistnet.io\n   Email: ray@mistnet.io\n\
    \   Jeffrey Zhang\n   Juniper Networks, Inc.\n   10 Technology Park Drive\n  \
    \ Westford, MA  01886\n   United States of America\n   Email: zzhang@juniper.net\n"
